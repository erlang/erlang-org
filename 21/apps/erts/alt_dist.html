<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- How to Implement an Alternative Carrier for the Erlang Distribution
    </title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<div class="erlang-logo-wrapper"><a href="../../index.html"><img alt="Erlang Logo" src="../../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Erlang Run-Time System Application (ERTS)</p>
<p class="section-subtitle">User's Guide</p>
<p class="section-version">Version 10.3.5.19</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="index.html">Reference Manual</a></li>
<li><a href="release_notes.html">Release Notes</a></li>
<li><a href="erts.pdf">PDF</a></li>
<li><a href="../../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="introduction.html">
              Top of chapter
            </a></li>
<li title="Scope"><a href="introduction.html#scope">Scope</a></li>
<li title="Prerequisites"><a href="introduction.html#prerequisites">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="Communication in Erlang" expanded="false">Communication in Erlang<ul>
<li><a href="communication.html">
              Top of chapter
            </a></li>
<li title="Passing of Signals"><a href="communication.html#passing-of-signals">Passing of Signals</a></li>
<li title="Synchronous Communication"><a href="communication.html#synchronous-communication">Synchronous Communication</a></li>
<li title="Implementation"><a href="communication.html#implementation">Implementation</a></li>
</ul>
</li>
<li id="no" title="Time and Time Correction in Erlang" expanded="false">Time and Time Correction in Erlang<ul>
<li><a href="time_correction.html">
              Top of chapter
            </a></li>
<li title="New Extended Time Functionality"><a href="time_correction.html#new-extended-time-functionality">New Extended Time Functionality</a></li>
<li title="Terminology"><a href="time_correction.html#terminology">Terminology</a></li>
<li title="Introduction"><a href="time_correction.html#introduction">Introduction</a></li>
<li title="Time Correction"><a href="time_correction.html#time-correction">Time Correction</a></li>
<li title="Time Warp Safe Code"><a href="time_correction.html#time-warp-safe-code">Time Warp Safe Code</a></li>
<li title="Time Warp Modes"><a href="time_correction.html#time-warp-modes">Time Warp Modes</a></li>
<li title="New Time API"><a href="time_correction.html#new-time-api">New Time API</a></li>
<li title="Support of Both New and Old OTP Releases"><a href="time_correction.html#support-of-both-new-and-old-otp-releases">Support of Both New and Old OTP Releases</a></li>
</ul>
</li>
<li id="no" title="Match Specifications in Erlang" expanded="false">Match Specifications in Erlang<ul>
<li><a href="match_spec.html">
              Top of chapter
            </a></li>
<li title="Grammar"><a href="match_spec.html#grammar">Grammar</a></li>
<li title="Function Descriptions"><a href="match_spec.html#function-descriptions">Function Descriptions</a></li>
<li title="Match target"><a href="match_spec.html#match-target">Match target</a></li>
<li title="Variables and Literals"><a href="match_spec.html#variables-and-literals">Variables and Literals</a></li>
<li title="Execution of the Match"><a href="match_spec.html#execution-of-the-match">Execution of the Match</a></li>
<li title="Differences between Match Specifications in ETS and Tracing"><a href="match_spec.html#differences-between-match-specifications-in-ets-and-tracing">Differences between Match Specifications in ETS and Tracing</a></li>
<li title="Tracing Examples"><a href="match_spec.html#tracing-examples">Tracing Examples</a></li>
<li title="ETS Examples"><a href="match_spec.html#ets-examples">ETS Examples</a></li>
</ul>
</li>
<li id="no" title="How to Interpret the Erlang Crash Dumps" expanded="false">How to Interpret the Erlang Crash Dumps<ul>
<li><a href="crash_dump.html">
              Top of chapter
            </a></li>
<li title="General Information"><a href="crash_dump.html#general-information">General Information</a></li>
<li title="Scheduler Information"><a href="crash_dump.html#scheduler-information">Scheduler Information</a></li>
<li title="Memory Information"><a href="crash_dump.html#memory-information">Memory Information</a></li>
<li title="Internal Table Information"><a href="crash_dump.html#internal-table-information">Internal Table Information</a></li>
<li title="Allocated Areas"><a href="crash_dump.html#allocated-areas">Allocated Areas</a></li>
<li title="Allocator"><a href="crash_dump.html#allocator">Allocator</a></li>
<li title="Process Information"><a href="crash_dump.html#process-information">Process Information</a></li>
<li title="Port Information"><a href="crash_dump.html#port-information">Port Information</a></li>
<li title="ETS Tables"><a href="crash_dump.html#ets-tables">ETS Tables</a></li>
<li title="Timers"><a href="crash_dump.html#timers">Timers</a></li>
<li title="Distribution Information"><a href="crash_dump.html#distribution-information">Distribution Information</a></li>
<li title="Loaded Module Information"><a href="crash_dump.html#loaded-module-information">Loaded Module Information</a></li>
<li title="Fun Information"><a href="crash_dump.html#fun-information">Fun Information</a></li>
<li title="Process Data"><a href="crash_dump.html#process-data">Process Data</a></li>
<li title="Atoms"><a href="crash_dump.html#atoms">Atoms</a></li>
<li title="Disclaimer"><a href="crash_dump.html#disclaimer">Disclaimer</a></li>
</ul>
</li>
<li id="loadscrollpos" title="How to Implement an Alternative Carrier for the Erlang Distribution
    " expanded="true">How to Implement an Alternative Carrier for the Erlang Distribution
    <ul>
<li><a href="alt_dist.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="alt_dist.html#introduction">Introduction</a></li>
<li title="Distribution Module"><a href="alt_dist.html#distribution-module">Distribution Module</a></li>
<li title="The Driver"><a href="alt_dist.html#the-driver">The Driver</a></li>
<li title="Putting It All Together"><a href="alt_dist.html#putting-it-all-together">Putting It All Together</a></li>
</ul>
</li>
<li id="no" title="How to Implement an Alternative Service Discovery for Erlang Distribution
    " expanded="false">How to Implement an Alternative Service Discovery for Erlang Distribution
    <ul>
<li><a href="alt_disco.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="alt_disco.html#introduction">Introduction</a></li>
<li title="Discovery module"><a href="alt_disco.html#discovery-module">Discovery module</a></li>
</ul>
</li>
<li id="no" title="The Abstract Format" expanded="false">The Abstract Format<ul>
<li><a href="absform.html">
              Top of chapter
            </a></li>
<li title="Module Declarations and Forms"><a href="absform.html#module-declarations-and-forms">Module Declarations and Forms</a></li>
<li title="Atomic Literals"><a href="absform.html#atomic-literals">Atomic Literals</a></li>
<li title="Patterns"><a href="absform.html#patterns">Patterns</a></li>
<li title="Expressions"><a href="absform.html#expressions">Expressions</a></li>
<li title="Clauses"><a href="absform.html#clauses">Clauses</a></li>
<li title="Guards"><a href="absform.html#guards">Guards</a></li>
<li title="Types"><a href="absform.html#types">Types</a></li>
<li title="The Abstract Format after Preprocessing"><a href="absform.html#the-abstract-format-after-preprocessing">The Abstract Format after Preprocessing</a></li>
</ul>
</li>
<li id="no" title="tty - A Command-Line Interface" expanded="false">tty - A Command-Line Interface<ul>
<li><a href="tty.html">
              Top of chapter
            </a></li>
<li title="Normal Mode"><a href="tty.html#normal-mode">Normal Mode</a></li>
<li title="Shell Break Mode"><a href="tty.html#shell-break-mode">Shell Break Mode</a></li>
</ul>
</li>
<li id="no" title="How to Implement a Driver" expanded="false">How to Implement a Driver<ul>
<li><a href="driver.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="driver.html#introduction">Introduction</a></li>
<li title="Sample Driver"><a href="driver.html#sample-driver">Sample Driver</a></li>
<li title="Compiling and Linking the Sample Driver"><a href="driver.html#compiling-and-linking-the-sample-driver">Compiling and Linking the Sample Driver</a></li>
<li title="Calling a Driver as a Port in Erlang"><a href="driver.html#calling-a-driver-as-a-port-in-erlang">Calling a Driver as a Port in Erlang</a></li>
<li title="Sample Asynchronous Driver"><a href="driver.html#sample-asynchronous-driver">Sample Asynchronous Driver</a></li>
<li title="An Asynchronous Driver Using driver_async"><a href="driver.html#an-asynchronous-driver-using-driver_async">An Asynchronous Driver Using driver_async</a></li>
</ul>
</li>
<li id="no" title="Inet Configuration" expanded="false">Inet Configuration<ul>
<li><a href="inet_cfg.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="inet_cfg.html#introduction">Introduction</a></li>
<li title="Configuration Data"><a href="inet_cfg.html#configuration-data">Configuration Data</a></li>
<li title="User Configuration Example"><a href="inet_cfg.html#user-configuration-example">User Configuration Example</a></li>
</ul>
</li>
<li id="no" title="External Term Format" expanded="false">External Term Format<ul>
<li><a href="erl_ext_dist.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="erl_ext_dist.html#introduction">Introduction</a></li>
<li title="Distribution Header"><a href="erl_ext_dist.html#distribution-header">Distribution Header</a></li>
<li title="ATOM_CACHE_REF"><a href="erl_ext_dist.html#atom_cache_ref">ATOM_CACHE_REF</a></li>
<li title="SMALL_INTEGER_EXT"><a href="erl_ext_dist.html#small_integer_ext">SMALL_INTEGER_EXT</a></li>
<li title="INTEGER_EXT"><a href="erl_ext_dist.html#integer_ext">INTEGER_EXT</a></li>
<li title="FLOAT_EXT"><a href="erl_ext_dist.html#float_ext">FLOAT_EXT</a></li>
<li title="PORT_EXT"><a href="erl_ext_dist.html#port_ext">PORT_EXT</a></li>
<li title="NEW_PORT_EXT"><a href="erl_ext_dist.html#new_port_ext">NEW_PORT_EXT</a></li>
<li title="PID_EXT"><a href="erl_ext_dist.html#pid_ext">PID_EXT</a></li>
<li title="NEW_PID_EXT"><a href="erl_ext_dist.html#new_pid_ext">NEW_PID_EXT</a></li>
<li title="SMALL_TUPLE_EXT"><a href="erl_ext_dist.html#small_tuple_ext">SMALL_TUPLE_EXT</a></li>
<li title="LARGE_TUPLE_EXT"><a href="erl_ext_dist.html#large_tuple_ext">LARGE_TUPLE_EXT</a></li>
<li title="MAP_EXT"><a href="erl_ext_dist.html#map_ext">MAP_EXT</a></li>
<li title="NIL_EXT"><a href="erl_ext_dist.html#nil_ext">NIL_EXT</a></li>
<li title="STRING_EXT"><a href="erl_ext_dist.html#string_ext">STRING_EXT</a></li>
<li title="LIST_EXT"><a href="erl_ext_dist.html#list_ext">LIST_EXT</a></li>
<li title="BINARY_EXT"><a href="erl_ext_dist.html#binary_ext">BINARY_EXT</a></li>
<li title="SMALL_BIG_EXT"><a href="erl_ext_dist.html#small_big_ext">SMALL_BIG_EXT</a></li>
<li title="LARGE_BIG_EXT"><a href="erl_ext_dist.html#large_big_ext">LARGE_BIG_EXT</a></li>
<li title="REFERENCE_EXT (deprecated)"><a href="erl_ext_dist.html#reference_ext--deprecated-">REFERENCE_EXT (deprecated)</a></li>
<li title="NEW_REFERENCE_EXT"><a href="erl_ext_dist.html#new_reference_ext">NEW_REFERENCE_EXT</a></li>
<li title="NEWER_REFERENCE_EXT"><a href="erl_ext_dist.html#newer_reference_ext">NEWER_REFERENCE_EXT</a></li>
<li title="FUN_EXT"><a href="erl_ext_dist.html#fun_ext">FUN_EXT</a></li>
<li title="NEW_FUN_EXT"><a href="erl_ext_dist.html#new_fun_ext">NEW_FUN_EXT</a></li>
<li title="EXPORT_EXT"><a href="erl_ext_dist.html#export_ext">EXPORT_EXT</a></li>
<li title="BIT_BINARY_EXT"><a href="erl_ext_dist.html#bit_binary_ext">BIT_BINARY_EXT</a></li>
<li title="NEW_FLOAT_EXT"><a href="erl_ext_dist.html#new_float_ext">NEW_FLOAT_EXT</a></li>
<li title="ATOM_UTF8_EXT"><a href="erl_ext_dist.html#atom_utf8_ext">ATOM_UTF8_EXT</a></li>
<li title="SMALL_ATOM_UTF8_EXT"><a href="erl_ext_dist.html#small_atom_utf8_ext">SMALL_ATOM_UTF8_EXT</a></li>
<li title="ATOM_EXT (deprecated)"><a href="erl_ext_dist.html#atom_ext--deprecated-">ATOM_EXT (deprecated)</a></li>
<li title="SMALL_ATOM_EXT (deprecated)"><a href="erl_ext_dist.html#small_atom_ext--deprecated-">SMALL_ATOM_EXT (deprecated)</a></li>
</ul>
</li>
<li id="no" title="Distribution Protocol" expanded="false">Distribution Protocol<ul>
<li><a href="erl_dist_protocol.html">
              Top of chapter
            </a></li>
<li title="EPMD Protocol"><a href="erl_dist_protocol.html#epmd-protocol">EPMD Protocol</a></li>
<li title="Distribution Handshake"><a href="erl_dist_protocol.html#distribution-handshake">Distribution Handshake</a></li>
<li title="Protocol between Connected Nodes"><a href="erl_dist_protocol.html#protocol-between-connected-nodes">Protocol between Connected Nodes</a></li>
<li title="New Ctrlmessages for distrvsn = 1 (Erlang/OTP R4)"><a href="erl_dist_protocol.html#new-ctrlmessages-for-distrvsn-=-1--erlang-otp-r4-">New Ctrlmessages for distrvsn = 1 (Erlang/OTP R4)</a></li>
<li title="New Ctrlmessages for distrvsn = 2"><a href="erl_dist_protocol.html#new-ctrlmessages-for-distrvsn-=-2">New Ctrlmessages for distrvsn = 2</a></li>
<li title="New Ctrlmessages for distrvsn = 3 (Erlang/OTP R5C)"><a href="erl_dist_protocol.html#new-ctrlmessages-for-distrvsn-=-3--erlang-otp-r5c-">New Ctrlmessages for distrvsn = 3 (Erlang/OTP R5C)</a></li>
<li title="New Ctrlmessages for distrvsn = 4 (Erlang/OTP R6)"><a href="erl_dist_protocol.html#new-ctrlmessages-for-distrvsn-=-4--erlang-otp-r6-">New Ctrlmessages for distrvsn = 4 (Erlang/OTP R6)</a></li>
<li title="New Ctrlmessages for Erlang/OTP 21"><a href="erl_dist_protocol.html#new-ctrlmessages-for-erlang-otp-21">New Ctrlmessages for Erlang/OTP 21</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>6 How to Implement an Alternative Carrier for the Erlang Distribution
    </h1>
  
  <p>This section describes how to implement an alternative carrier
    protocol for the Erlang distribution. The distribution is normally
    carried by TCP/IP. Here is explained a method for replacing TCP/IP
    with another protocol.</p>

  <p>The section is a step-by-step explanation of the
    <span class="code">uds_dist</span> example application (in the
    Kernel application <span class="code">examples</span> directory). The
    <span class="code">uds_dist</span> application implements distribution over Unix
    domain sockets and is written for the Sun Solaris 2 operating environment.
    The mechanisms are however general and apply to any operating system Erlang
    runs on. The reason the C code is not made portable, is simply
    readability.</p>

  <h3><span onMouseOver="document.getElementById('ghlink-introduction-idm1868').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-introduction-idm1868').style.visibility = 'hidden';"><span id="ghlink-introduction-idm1868" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L50" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="introduction" href="#introduction">6.1 
          Introduction</a></span></h3>
    
    <p>To implement a new carrier for the Erlang distribution, the main
      steps are as follows.</p>

      <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>
	As of ERTS version 10.0 support for distribution controller
	processes has been introduced. That is, the traffic over a
	distribution channel can be managed by a process instead of
	only by a port. This makes it possible to implement large
	parts of the logic in Erlang code, and you perhaps do not
	even need a new driver for the protocol. One example could
	be Erlang distribution over UDP using <span class="code">gen_udp</span> (your
	Erlang code will of course have to take care of retranspissions,
	etc in this example). That is, depending on what you want
	to do you perhaps do not need to implement a driver at all
	and can then skip the driver related sections below.
	The <span class="code">gen_tcp_dist</span> example described in the
	<span class="bold_code bc-17"><a href="#distribution_module">Distribution Module</a></span> section utilize distribution controller
	processes and can be worth having a look at if you want to
	use distribution controller processes.
      </p></p></div>
</div>

    <h4><span onMouseOver="document.getElementById('ghlink-writing-an-erlang-driver-idm1876').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-writing-an-erlang-driver-idm1876').style.visibility = 'hidden';"><span id="ghlink-writing-an-erlang-driver-idm1876" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L74" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="writing-an-erlang-driver" href="#writing-an-erlang-driver">Writing an Erlang Driver</a></span></h4>
      
      <p>First, the protocol must be available to the Erlang machine, which
        involves writing an Erlang driver. A port program cannot be used,
        an Erlang driver is required. Erlang drivers can be:</p>

      <ul>
        <li>
          <p>Statically linked to the emulator, which can be an alternative
            when using the open source distribution of Erlang, or</p>
        </li>
        <li>
          <p>Dynamically loaded into the Erlang machines address space,
            which is the only alternative if a precompiled version of 
            Erlang is to be used</p>
        </li>
      </ul>

      <p>Writing an Erlang driver is not easy. The driver is written
        as some callback functions called by the Erlang emulator when
        data is sent to the driver, or the driver has any data available on
        a file descriptor. As the driver callback routines execute in the main
        thread of the Erlang machine, the callback functions can perform
        no blocking activity whatsoever. The callbacks are only to set up
        file descriptors for waiting and/or read/write available data. All
        I/O must be non-blocking. Driver callbacks are however executed
        in sequence, why a global state can safely be updated within the
        routines.</p>
    

    <h4><span onMouseOver="document.getElementById('ghlink-writing-an-erlang-interface-for-the-driver-idm1885').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-writing-an-erlang-interface-for-the-driver-idm1885').style.visibility = 'hidden';"><span id="ghlink-writing-an-erlang-interface-for-the-driver-idm1885" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L104" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="writing-an-erlang-interface-for-the-driver" href="#writing-an-erlang-interface-for-the-driver">Writing an Erlang Interface for the Driver</a></span></h4>
      
      <p>When the driver is implemented, one would preferably write an
        Erlang interface for the driver to be able to test the
        functionality of the driver separately. This interface can then
        be used by the distribution module, which will cover the details of
        the protocol from the <span class="code">net_kernel</span>.</p>

      <p>The easiest path
        is to mimic the <span class="code">inet</span> and <span class="code">inet_tcp</span>
        interfaces, but not much
        functionality in those modules needs to be implemented. In the
        example application, only a few of the usual interfaces are
        implemented, and they are much simplified.</p>
    

    <h4><span onMouseOver="document.getElementById('ghlink-writing-a-distribution-module-idm1892').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-writing-a-distribution-module-idm1892').style.visibility = 'hidden';"><span id="ghlink-writing-a-distribution-module-idm1892" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L120" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="writing-a-distribution-module" href="#writing-a-distribution-module">Writing a Distribution Module</a></span></h4>
      
      <p>When the protocol is available to Erlang through a driver and an
        Erlang interface module, a distribution module can be written.
        The distribution module is a module with well-defined callbacks,
        much like a <span class="code">gen_server</span> (there is no compiler support
        for checking the callbacks, though). This module implements:</p>

      <ul>
        <li>The details of finding other nodes (that is, talking to
          <span class="code">epmd</span> or something similar)</li>
        <li>Creating a listen port (or similar)</li>
        <li>Connecting to other nodes</li>
        <li>Performing the handshakes/cookie verification</li>
      </ul>

      <p>There is however a utility module, <span class="code">dist_util</span>, which
        does most of the hard work of handling handshakes, cookies, timers,
        and ticking. Using <span class="code">dist_util</span> makes implementing a
        distribution module much easier and that is done in
        the example application.</p>
    

    <h4><span onMouseOver="document.getElementById('ghlink-creating-boot-scripts-idm1905').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-creating-boot-scripts-idm1905').style.visibility = 'hidden';"><span id="ghlink-creating-boot-scripts-idm1905" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L143" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="creating-boot-scripts" href="#creating-boot-scripts">Creating Boot Scripts</a></span></h4>
      
      <p>The last step is to create boot scripts to make the protocol
        implementation available at boot time. The implementation can be
        debugged by starting the distribution when all the system is
        running, but in a real system the distribution is to start very
        early, why a boot script and some command-line parameters are
        necessary.</p>

      <p>This step also implies that the Erlang code in the
        interface and distribution modules is written in such a way that
        it can be run in the startup phase. In particular, there can be no
        calls to the <span class="code">application</span> module or to any modules
        not loaded at boot time. That is, only <span class="code">Kernel</span>,
        <span class="code">STDLIB</span>, and the application itself can be used.</p>
    
  

  <h3>
<a name="distribution_module"></a><span onMouseOver="document.getElementById('ghlink-distribution-module-idm1912').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-distribution-module-idm1912').style.visibility = 'hidden';"><span id="ghlink-distribution-module-idm1912" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L161" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="distribution-module" href="#distribution-module">6.2 
          Distribution Module</a></span>
</h3>
    
    
    <p>
      The distribution module expose an API that <span class="code">net_kernel</span> call
      in order to manage connections to other nodes. The module name
      should have the suffix <span class="code">_dist</span>.
    </p>
    <p>
      The module needs to create some kind of listening entity (process
      or port) and an acceptor process that accepts incoming connections
      using the listening entity. For each connection, the module at least
      needs to create one connection supervisor process, which also is
      responsible for the handshake when setting up the connection, and
      a distribution controller (process or port) responsible for
      transport of data over the connection. The distribution controller
      and the connection supervisor process should be linked together
      so both of them are cleaned up when the connection is taken down.
    </p>
    <p>
      Note that there need to be exactly one distribution controller
      per connection. A process or port can only be distribution
      controller for one connection. The registration as distribution
      controller cannot be undone. It will stick until the distribution
      controller terminates. The distribution controller should not
      ignore exit signals. It is allowed to trap exits, but it should
      then voluntarily terminate when an exit signal is received.
    </p>
    <p>
      An example implementation of a distribution module can be found
      in
      <span class="bold_code bc-20"><a href="gen_tcp_dist.erl">$ERL_TOP/lib/kernel/examples/gen_tcp_dist/src/gen_tcp_dist.erl</a></span>.
      It implements the distribution over TCP/IP using the <span class="code">gen_tcp</span>
      API with distribution controllers implemented by processes. This
      instead of using port distribution controllers as the ordinary TCP/IP
      distribution uses.
    </p>

    <h4>
<a name="distribution_module_exported_callback_functions"></a><span onMouseOver="document.getElementById('ghlink-exported-callback-functions-idm1923').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-exported-callback-functions-idm1923').style.visibility = 'hidden';"><span id="ghlink-exported-callback-functions-idm1923" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L199" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="exported-callback-functions" href="#exported-callback-functions">Exported Callback Functions</a></span>
</h4>
      
      

      <p>
	The following functions are mandatory:
      </p>
      <dl>
	<dt><strong><a name="listen"></a><span class="code">listen(Name) -&gt;</span><br>  <span class="code">{ok, {Listen, Address, Creation}} | {error, Error} </span></strong></dt>
	<dd>
	  <p>
	    <span class="code">listen/1</span> is called once in order to listen for incoming
	    connection requests. The call is made when the distribution is brought
	    up. The argument <span class="code">Name</span> is the part of the node name before
	    the <span class="code">@</span> sign in the full node name. It can be either an atom or a
	    string.
	  </p>
	  <p>
	    The return value consists of a <span class="code">Listen</span> handle (which is
	    later passed to the <span class="bold_code bc-17"><a href="#accept"><span class="code">accept/1</span></a></span>
	    callback), <span class="code">Address</span> which is a <span class="code">#net_address{}</span> record
	    with information about the address for the node (the
	    <span class="code">#net_address{}</span> record is defined in
	    <span class="code">kernel/include/net_address.hrl</span>), and <span class="code">Creation</span> which
	    (currently) is an integer <span class="code">1</span>, <span class="code">2</span>, or <span class="code">3</span>.
	  </p>
	  <p>
	    If <span class="bold_code bc-18"><a href="../../man/epmd.html"><span class="code">epmd</span></a></span> is to be used 
	    for node discovery, you typically want to use the (unfortunately
	    undocumented) <span class="code">erl_epmd</span> module (part of the <span class="code">kernel</span>
	    application) in order to register the listen port with <span class="code">epmd</span>
	    and retrieve <span class="code">Creation</span> to use.
	  </p>
	</dd>

	<dt><strong><a name="accept"></a><span class="code">accept(Listen) -&gt;</span><br>  <span class="code">AcceptorPid</span></strong></dt>
	<dd>
	  <p>
	    <span class="code">accept/1</span> should spawn a process that accepts connections. This
	    process should preferably execute on <span class="code">max</span> priority. The process
	    identifier of this process should be returned.
	  </p>
	  <p>
	    The <span class="code">Listen</span> argument will be the same as the <span class="code">Listen</span> handle
	    part of the return value of the
	    <span class="bold_code bc-17"><a href="#listen"><span class="code">listen/1</span></a></span> callback above.
	    <span class="code">accept/1</span> is called only once when the distribution protocol is
	    started.
	  </p>
	  <p>
	    The caller of this function is a representative for <span class="code">net_kernel</span>
	    (this may or may not be the process registered as <span class="code">net_kernel</span>)
	    and is in this document identified as <span class="code">Kernel</span>.
	    When a connection has been accepted by the acceptor process, it needs
	    to inform <span class="code">Kernel</span> about the accepted connection. This is done by
	    passing a message on the form:
	  </p>
	  <div class="example"><pre>Kernel ! {accept, AcceptorPid, DistController, Family, Proto}</pre></div>
	  <p>
	    <span class="code">DistController</span> is either the process or port identifier
	    of the distribution controller for the connection. The
	    distribution controller should be created by the acceptor
	    processes when a new connection is accepted. Its job is to
	    dispatch traffic on the connection.
	  </p>
	  <span class="code">Kernel</span> responds with one of the following messages:
	  <dl>
	    <dt><strong><span class="code">{Kernel, controller, SupervisorPid}</span></strong></dt>
	    <dd>
	      <p>
		The request was accepted and <span class="code">SupervisorPid</span> is the
		process identifier of the connection supervisor process
		(which is created in the
		<span class="bold_code bc-17"><a href="#accept_connection"><span class="code">accept_connection/5</span></a></span>
		callback).
	      </p>
	    </dd>
	    <dt><strong><span class="code">{Kernel, unsupported_protocol}</span></strong></dt>
	    <dd>
	      <p>
		The request was rejected. This is a fatal error. The acceptor
		process should terminate.
	      </p>
	    </dd>
	  </dl>
	  <p>
	    When an accept sequence has been completed the acceptor process
	    is expected to continue accepting further requests.
	  </p>
	</dd>

	<dt><strong><a name="accept_connection"></a><span class="code">accept_connection(AcceptorPid, DistCtrl, MyNode, Allowed, SetupTime) -&gt;</span><br>  <span class="code">ConnectionSupervisorPid</span></strong></dt>
	<dd>
	  <p>
	    <span class="code">accept_connection/5</span> should spawn a process that will
	    perform the Erlang distribution handshake for the connection.
	    If the handshake successfully completes it should continue to
	    function as a connection supervisor. This process
	    should preferably execute on <span class="code">max</span> priority.
	  </p>
	  <p>The arguments:</p>
	  <dl>
	    <dt><strong><span class="code">AcceptorPid</span></strong></dt>
	    <dd>
	      <p>
		Process identifier of the process created by the
		<span class="bold_code bc-17"><a href="#accept"><span class="code">accept/1</span></a></span>
		callback.
	      </p>
	    </dd>
	    <dt><strong><span class="code">DistCtrl</span></strong></dt>
	    <dd>
	      <p>The identifier of the distribution controller identifier
	      created by the acceptor process. To be passed along to
	      <span class="code">dist_util:handshake_other_started(HsData)</span>.
	      </p>
	    </dd>
	    <dt><strong><span class="code">MyNode</span></strong></dt>
	    <dd>
	      <p>
		Node name of this node. To be passed along to
	      <span class="code">dist_util:handshake_other_started(HsData)</span>.
	      </p>
	    </dd>
	    <dt><strong><span class="code">Allowed</span></strong></dt>
	    <dd>
	      <p>
		To be passed along to
		<span class="code">dist_util:handshake_other_started(HsData)</span>.
	      </p>
	    </dd>
	    <dt><strong><span class="code">SetupTime</span></strong></dt>
	    <dd>
	      <p>
		Time used for creating a setup timer by a
		call to <span class="code">dist_util:start_timer(SetupTime)</span>.
		The timer should be passed along to
		<span class="code">dist_util:handshake_other_started(HsData)</span>.
	      </p>
	    </dd>
	  </dl>
	  <p>
	    The created process should provide callbacks and other
	    information needed for the handshake in a
	    <span class="bold_code bc-17"><a href="#hs_data_record"><span class="code">#hs_data{}</span></a></span>
	    record and call <span class="code">dist_util:handshake_other_started(HsData)</span>
	    with this record.
	  </p>
	  <p>
	    <span class="code">dist_util:handshake_other_started(HsData)</span> will perform
	    the handshake and if the handshake successfully completes this
	    process will then continue in a connection supervisor loop
	    as long as the connection is up.
	  </p>
	</dd>
	
	<dt><strong><a name="setup"></a><span class="code">setup(Node, Type, MyNode, LongOrShortNames, SetupTime) -&gt;</span><br>  <span class="code">ConnectionSupervisorPid</span></strong></dt>
	<dd>
	  <p>
	    <span class="code">setup/5</span> should spawn a process that connects to
	    <span class="code">Node</span>. When connection has been established it should
	    perform the Erlang distribution handshake for the connection.
	    If the handshake successfully completes it should continue to
	    function as a connection supervisor. This process
	    should preferably execute on <span class="code">max</span> priority.
	  </p>
	  <p>The arguments:</p>
	  <dl>
	    <dt><strong><span class="code">Node</span></strong></dt>
	    <dd>
	      <p>
		Node name of remote node. To be passed along to
		<span class="code">dist_util:handshake_we_started(HsData)</span>.
	      </p>
	    </dd>
	    <dt><strong><span class="code">Type</span></strong></dt>
	    <dd>
	      <p>
		Connection type. To be passed along to
		<span class="code">dist_util:handshake_we_started(HsData)</span>.
	      </p>
	    </dd>
	    <dt><strong><span class="code">MyNode</span></strong></dt>
	    <dd>
	      <p>
		Node name of this node. To be passed along to
		<span class="code">dist_util:handshake_we_started(HsData)</span>.
	      </p>
	    </dd>
	    <dt><strong><span class="code">LongOrShortNames</span></strong></dt>
	    <dd>
	      <p>
		Either the atom <span class="code">longnames</span> or
		the atom <span class="code">shortnames</span> indicating
		whether long or short names is used.
	      </p>
	    </dd>
	    <dt><strong><span class="code">SetupTime</span></strong></dt>
	    <dd>
	      <p>
		Time used for creating a setup timer by a
		call to <span class="code">dist_util:start_timer(SetupTime)</span>.
		The timer should be passed along to
		<span class="code">dist_util:handshake_we_started(HsData)</span>.
	      </p>
	    </dd>
	  </dl>
	  <p>
	    The caller of this function is a representative for <span class="code">net_kernel</span>
	    (this may or may not be the process registered as <span class="code">net_kernel</span>)
	    and is in this document identified as <span class="code">Kernel</span>. 
	  </p>
	  <p>
	    This function should, besides spawning the connection supervisor,
	    also create a distribution controller. The distribution
	    controller is either a process or a port which is responsible
	    for dispatching traffic.
	  </p>
	  <p>
	    The created process should provide callbacks and other
	    information needed for the handshake in a
	    <span class="bold_code bc-17"><a href="#hs_data_record"><span class="code">#hs_data{}</span></a></span>
	    record and call <span class="code">dist_util:handshake_we_started(HsData)</span>
	    with this record.
	  </p>
	  <p>
	    <span class="code">dist_util:handshake_we_started(HsData)</span> will perform
	    the handshake and the handshake successfully completes this
	    process will then continue in a connection supervisor loop
	    as long as the connection is up.
	  </p>
	</dd>
	
	<dt><strong><a name="close"></a><span class="code">close(Listen) -&gt;</span><br>  <span class="code">void()</span></strong></dt>
	
	<dd><p>
	  Called in order to close the <span class="code">Listen</span> handle
	  that originally was passed from the
	  <span class="bold_code bc-17"><a href="#listen"><span class="code">listen/1</span></a></span> callback.
	</p></dd>
	
	<dt><strong><a name="select"></a><span class="code">select(NodeName) -&gt;</span><br>  <span class="code">boolean()</span></strong></dt>
	<dd>
	  <p>Return <span class="code">true</span> if the host name part
	  of the <span class="code">NodeName</span> is valid for use
	  with this protocol; otherwise, <span class="code">false</span>.
	  </p>
	</dd>
	
      </dl>

      <p>
	There are also two optional functions that may be
	exported:
      </p>
      <dl>
	<dt><strong><a name="select"></a><span class="code">setopts(Listen, Opts) -&gt;</span><br>  <span class="code">ok | {error, Error}</span></strong></dt>
	<dd>
	  <p>
	    The argument <span class="code">Listen</span> is the handle originally passed
	    from the
	    <span class="bold_code bc-17"><a href="#listen"><span class="code">listen/1</span></a></span> callback.
	    The argument <span class="code">Opts</span> is a list of options to set on future
	    connections.
	  </p>
	</dd>

	<dt><strong><a name="select"></a><span class="code">getopts(Listen, Opts) -&gt;</span><br>  <span class="code">{ok, OptionValues} | {error, Error}</span></strong></dt>
	<dd>
	  <p>
	    The argument <span class="code">Listen</span> is the handle originally passed
	    from the
	    <span class="bold_code bc-17"><a href="#listen"><span class="code">listen/1</span></a></span> callback.
	    The argument <span class="code">Opts</span> is a list of options to read for future
	    connections.
	  </p>
	</dd>
      </dl>
      
    
    <h4>
<a name="hs_data_record"></a><span onMouseOver="document.getElementById('ghlink-the-#hs_data{}-record-idm2132').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-the-#hs_data{}-record-idm2132').style.visibility = 'hidden';"><span id="ghlink-the-#hs_data{}-record-idm2132" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L479" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="the-#hs_data%7B%7D-record" href="#the-#hs_data%7B%7D-record">The #hs_data{} Record</a></span>
</h4>
      
      
      <p>
	The <span class="code">dist_util:handshake_we_started/1</span> and
	<span class="code">dist_util:handshake_other_started/1</span> functions
	takes a <span class="code">#hs_data{}</span> record as argument. There
	are quite a lot of fields in this record that you
	need to set. The record is defined in
	<span class="code">kernel/include/dist_util.hrl</span>. Not documented
	fields should not be set, i.e., should be left as
	<span class="code">undefined</span>.
      </p>
      <p>
	The following <span class="code">#hs_data{}</span> record fields need
	to be set unless otherwise stated:</p>
      <dl>
	<dt><strong><a name="hs_data_kernel_pid"></a><span class="code">kernel_pid</span></strong></dt>
	<dd>
	  <p>
	    Process identifier of the <span class="code">Kernel</span> process. That is,
	    the process that called either
	    <span class="bold_code bc-17"><a href="#setup"><span class="code">setup/5</span></a></span> or
	    <span class="bold_code bc-17"><a href="#accept_connection"><span class="code">accept_connection/5</span></a></span>.
	  </p>
	</dd>

	<dt><strong><a name="hs_data_other_node"></a><span class="code">other_node</span></strong></dt>
	<dd>
	  <p>Name of the other node. This field is only
	  mandatory when this node initiates the connection.
	  That is, when connection is set up via
	  <span class="bold_code bc-17"><a href="#setup"><span class="code">setup/5</span></a></span>.
	  </p>
	</dd>

	<dt><strong><a name="hs_data_this_node"></a><span class="code">this_node</span></strong></dt>
	<dd>
	  <p>
	    The node name of this node.
	  </p>
	</dd>

	<dt><strong><a name="hs_data_socket"></a><span class="code">socket</span></strong></dt>
	<dd>
	  <p>
	    The identifier of the distribution controller.
	  </p>
	</dd>
	
	<dt><strong><a name="hs_data_timer"></a><span class="code">timer</span></strong></dt>
	<dd>
	  <p>
	    The timer created using <span class="code">dist_util:start_timer/1</span>.
	  </p>
	</dd>

	<dt><strong><a name="hs_data_allowed"></a><span class="code">allowed</span></strong></dt>
	<dd>
	  <p>Information passed as <span class="code">Allowed</span> to
	  <span class="code">accept_connection/5</span>. This field is only
	  mandatory when the remote node initiated the
	  connection. That is, when the connection is set
	  up via
	  <span class="bold_code bc-17"><a href="#accept_connection"><span class="code">accept_connection/5</span></a></span>.
	  </p>
	</dd>
      
	<dt><strong><a name="hs_data_f_send"></a><span class="code">f_send</span></strong></dt>
	<dd>
	  <p>
	    A fun with the following signature:
	  </p>
	  <div class="example"><pre>fun (DistCtrlr, Data) -&gt; ok | {error, Error}</pre></div>
	  <p>
	    where <span class="code">DistCtrlr</span> is the identifier of
	    the distribution controller and <span class="code">Data</span>
	    is io data to pass to the other side.
	  </p>
	  <p>Only used during handshake phase.</p>
	</dd>
	
	<dt><strong><a name="hs_data_f_recv"></a><span class="code">f_recv</span></strong></dt>
	<dd>
	  <p>
	    A fun with the following signature:
	  </p>
	  <div class="example"><pre>fun (DistCtrlr, Length) -&gt; {ok, Packet} | {error, Reason}</pre></div>
	  <p>
	    where <span class="code">DistCtrlr</span> is the identifier of the distribution
	    controller.
	    If <span class="code">Length</span> is <span class="code">0</span>, all available bytes should be
	    returned. If <span class="code">Length &gt; 0</span>, exactly <span class="code">Length</span> bytes
	    should be returned, or an error; possibly discarding less
	    than <span class="code">Length</span> bytes of data when the connection is
	    closed from the other side.
	    It is used for passive receive of data from the
	    other end.
	  </p>
	  <p>Only used during handshake phase.</p>
	</dd>

	<dt><strong><a name="hs_data_f_setopts_pre_nodeup"></a><span class="code">f_setopts_pre_nodeup</span></strong></dt>
	<dd>
	  <p>
	    A fun with the following signature:
	  </p>
	  <div class="example"><pre>fun (DistCtrlr) -&gt; ok | {error, Error}</pre></div>
	  <p>
	    where <span class="code">DistCtrlr</span> is the identifier of
	    the distribution controller. Called just
	    before the distribution channel is taken up
	    for normal traffic.
	  </p>
	  <p>Only used during handshake phase.</p>
	</dd>

	<dt><strong><a name="hs_data_f_setopts_post_nodeup"></a><span class="code">f_setopts_post_nodeup</span></strong></dt>
	<dd>
	  <p>
	    A fun with the following signature:
	  </p>
	  <div class="example"><pre>fun (DistCtrlr) -&gt; ok | {error, Error}</pre></div>
	  <p>
	    where <span class="code">DistCtrlr</span> is the identifier of
	    the distribution controller. Called just
	    after distribution channel has been taken
	    up for normal traffic.
	  </p>
	  <p>Only used during handshake phase.</p>
	</dd>

	<dt><strong><a name="hs_data_f_getll"></a><span class="code">f_getll</span></strong></dt>
	<dd>
	  <p>
	    A fun with the following signature:
	  </p>
	  <div class="example"><pre>fun (DistCtrlr) -&gt; ID</pre></div>
	  <p>
	    where <span class="code">DistCtrlr</span> is the identifier of
	    the distribution controller and <span class="code">ID</span> is
	    the identifier of the low level entity that
	    handles the connection (often <span class="code">DistCtrlr</span>
	    itself).
	  </p>
	  <p>Only used during handshake phase.</p>
	</dd>

	<dt><strong><a name="hs_data_f_address"></a><span class="code">f_address</span></strong></dt>
	<dd>
	  <p>
	    A fun with the following signature:
	  </p>
	  <div class="example"><pre>fun (DistCtrlr, Node) -&gt; NetAddress</pre></div>
	  <p>
	    where <span class="code">DistCtrlr</span> is the identifier of
	    the distribution controller, <span class="code">Node</span>
	    is the node name of the node on the other end,
	    and <span class="code">NetAddress</span> is a <span class="code">#net_address{}</span>
	    record with information about the address
	    for the <span class="code">Node</span> on the other end of the
	    connection. The <span class="code">#net_address{}</span> record
	    is defined in
	    <span class="code">kernel/include/net_address.hrl</span>.
	  </p>
	  <p>Only used during handshake phase.</p>
	</dd>

	<dt><strong><a name="hs_data_mf_tick"></a><span class="code">mf_tick</span></strong></dt>
	<dd>
	  <p>
	    A fun with the following signature:
	  </p>
	  <div class="example"><pre>fun (DistCtrlr) -&gt; void()</pre></div>
	  <p>
	    where <span class="code">DistCtrlr</span> is the identifier
	    of the distribution controller. This
	    function should send information over
	    the connection that is not interpreted
	    by the other end while increasing the
	    statistics of received packets on the
	    other end. This is usually implemented by
	    sending an empty packet.
	  </p>
	  <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>
	    It is of vital importance that this operation
	    does not block the caller for a long time.
	    This since it is called from the connection
	    supervisor.
	  </p></p></div>
</div>
	  <p>Used when connection is up.</p>
	</dd>

	<dt><strong><a name="hs_data_mf_getstat"></a><span class="code">mf_getstat</span></strong></dt>
	<dd>
	  <p>
	    A fun with the following signature:
	  </p>
	  <div class="example"><pre>fun (DistCtrlr) -&gt; {ok, Received, Sent, PendSend}</pre></div>
	  <p>
	    where <span class="code">DistCtrlr</span> is the identifier
	    of the distribution controller, <span class="code">Received</span>
	    is received packets, <span class="code">Sent</span> is
	    sent packets, and <span class="code">PendSend</span> is
	    amount of packets in queue to be sent
	    or a <span class="code">boolean()</span> indicating whether
	    there are packets in queue to be sent.
	  </p>
	  <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>
	    It is of vital importance that this operation
	    does not block the caller for a long time.
	    This since it is called from the connection
	    supervisor.
	  </p></p></div>
</div>
	  <p>Used when connection is up.</p>
	</dd>

	<dt><strong><a name="hs_data_request_type"></a><span class="code">request_type</span></strong></dt>
	<dd>
	  <p>
	    The request <span class="code">Type</span> as passed to
	    <span class="bold_code bc-17"><a href="#setup"><span class="code">setup/5</span></a></span>.
	    This is only mandatory when the connection has
	    been initiated by this node. That is, the connection
	    is set up via <span class="code">setup/5</span>.
	  </p>
	</dd>

	<dt><strong><a name="hs_data_mf_setopts"></a><span class="code">mf_setopts</span></strong></dt>
	<dd>
	  <p>
	    A fun with the following signature:
	  </p>
	  <div class="example"><pre>fun (DistCtrl, Opts) -&gt; ok | {error, Error}</pre></div>
	  <p>
	    where <span class="code">DistCtrlr</span> is the identifier
	    of the distribution controller and <span class="code">Opts</span>
	    is a list of options to set on the connection.
	  </p>
	  <p>This function is optional. Used when connection is up.</p>
	</dd>
	
	<dt><strong><a name="hs_data_mf_getopts"></a><span class="code">mf_getopts</span></strong></dt>
	<dd>
	  <p>
	    A fun with the following signature:
	  </p>
	  <div class="example"><pre>fun (DistCtrl, Opts) -&gt; {ok, OptionValues} | {error, Error}</pre></div>
	  <p>
	    where <span class="code">DistCtrlr</span> is the identifier
	    of the distribution controller and <span class="code">Opts</span>
	    is a list of options to read for the connection.
	  </p>
	  <p>This function is optional. Used when connection is up.</p>
	</dd>

	<dt><strong><a name="hs_data_f_handshake_complete"></a><span class="code">f_handshake_complete</span></strong></dt>
	<dd>
	  <p>
	    A fun with the following signature:
	  </p>
	  <div class="example"><pre>fun (DistCtrlr, Node, DHandle) -&gt; void()</pre></div>
	  <p>
	    where <span class="code">DistCtrlr</span> is the identifier
	    of the distribution controller, <span class="code">Node</span> is
	    the node name of the node connected at the other
	    end, and <span class="code">DHandle</span> is a distribution handle
	    needed by a distribution controller process when
	    calling the following BIFs:
	  </p>
	  <ul>
	    <li><p><span class="bold_code bc-13"><a href="../../man/erlang.html#dist_ctrl_get_data-1"><span class="code">erlang:dist_ctrl_get_data/1</span></a></span></p></li>
	    <li><p><span class="bold_code bc-13"><a href="../../man/erlang.html#dist_ctrl_get_data_notification-1"><span class="code">erlang:dist_ctrl_get_data_notification/1</span></a></span></p></li>
	    <li><p><span class="bold_code bc-13"><a href="../../man/erlang.html#dist_ctrl_input_handler-2"><span class="code">erlang:dist_ctrl_input_handler/2</span></a></span></p></li>
	    <li><p><span class="bold_code bc-13"><a href="../../man/erlang.html#dist_ctrl_put_data-2"><span class="code">erlang:dist_ctrl_put_data/2</span></a></span></p></li>
	  </ul>
	  <p>
	    This function is called when the handshake has
	    completed and the distribution channel is up.
	    The distribution controller can begin dispatching
	    traffic over the channel. This function is optional.
	  </p>
	  <p>Only used during handshake phase.</p>
	</dd>
	
	<dt><strong><a name="hs_data_add_flags"></a><span class="code">add_flags</span></strong></dt>
	<dd>
	  <p>
	    <span class="bold_code bc-15"><a href="erl_dist_protocol.html#dflags">Distribution flags</a></span>
	    to add to the connection. Currently all (non obsolete) flags will
	    automatically be enabled.
	  </p>
	  <p>
	    This flag field is optional.
	  </p>
	</dd>

	<dt><strong><a name="hs_data_reject_flags"></a><span class="code">reject_flags</span></strong></dt>
	<dd>
	  <p>
	    <span class="bold_code bc-15"><a href="erl_dist_protocol.html#dflags">Distribution flags</a></span>
	    to reject. Currently the following distribution flags can be rejected:
	  </p>
	  <dl>
	    <dt><strong><span class="code">DFLAG_DIST_HDR_ATOM_CACHE</span></strong></dt>
	    <dd>Do not use atom cache over this connection.</dd>
	  </dl>
	  <p>Use function <span class="code">dist_util:strict_order_flags/0</span> to get all flags
	    for features that require strict order delivery.</p>
	  <p>
	    This flag field is optional.
	  </p>
	</dd>

	<dt><strong><a name="hs_data_require_flags"></a><span class="code">require_flags</span></strong></dt>
	<dd>
	  <p>
	    Require these <span class="bold_code bc-15"><a href="erl_dist_protocol.html#dflags">distribution flags</a></span> to be used. The connection will be aborted during the
	    handshake if the other end does not use them.
	  </p>
	  <p>
	    This flag field is optional.
	  </p>
	</dd>

      </dl>
    

    <h4>
<a name="distribution_data_delivery"></a><span onMouseOver="document.getElementById('ghlink-distribution-data-delivery-idm2365').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-distribution-data-delivery-idm2365').style.visibility = 'hidden';"><span id="ghlink-distribution-data-delivery-idm2365" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L808" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="distribution-data-delivery" href="#distribution-data-delivery">Distribution Data Delivery</a></span>
</h4>
      
      
      <p>
	When using the default configuration, the data to pass
	over a connection needs to be delivered as is
	to the node on the receiving end in the <strong>exact same
	order</strong>, with no loss of data what so ever, as sent
	from the sending node.
      </p>
      <p>
	The data delivery order can be relaxed by disabling
	features that require strict ordering. This is done by
	passing the
	<span class="bold_code bc-15"><a href="erl_dist_protocol.html#dflags">distribution flags</a></span>
	returned by <span class="code">dist_util:strict_order_flags/0</span> in the
	<span class="bold_code bc-15"><a href="alt_dist.html#hs_data_reject_flags"><span class="code">reject_flags</span></a></span>
	field of the <span class="bold_code bc-17"><a href="#hs_data_record"><span class="code">#hs_data{}</span></a></span>
	record used when setting up the connection. When relaxed
	ordering is used, only the order of signals with the same
	sender/receiver pair has to be preserved.
	However, note that disabling the features that require
	strict ordering may have a negative impact on performance,
	throughput, and/or latency. 
      </p>
    

    <h4>
<a name="enable_your_distribution_module"></a><span onMouseOver="document.getElementById('ghlink-enable-your-distribution-module-idm2377').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-enable-your-distribution-module-idm2377').style.visibility = 'hidden';"><span id="ghlink-enable-your-distribution-module-idm2377" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L835" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="enable-your-distribution-module" href="#enable-your-distribution-module">Enable Your Distribution Module</a></span>
</h4>
      
      

      <p>For <span class="code">net_kernel</span> to find out which distribution module to use,
      the <span class="code">erl</span> command-line argument <span class="code">-proto_dist</span> is used. It
      is followed by one or more distribution module names, with suffix
      "_dist" removed. That is, <span class="code">gen_tcp_dist</span> as a distribution module
      is specified as <span class="code">-proto_dist gen_tcp</span>.</p>

      <p>If no <span class="code">epmd</span> (TCP port mapper daemon) is used, also command-line
      option <span class="code">-no_epmd</span> is to be specified, which makes
      Erlang skip the <span class="code">epmd</span> startup, both as an OS process and as an
      Erlang ditto.</p>
    

  

  <h3><span onMouseOver="document.getElementById('ghlink-the-driver-idm2390').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-the-driver-idm2390').style.visibility = 'hidden';"><span id="ghlink-the-driver-idm2390" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L853" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="the-driver" href="#the-driver">6.3 
          The Driver</a></span></h3>
    

    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>This section was written a long time ago. Most of it is still
      valid, but some things have changed since then. Some updates have
      been made to the documentation of the driver presented here,
      but more can be done and is planned for the future.
      The reader is encouraged to read the
      <span class="bold_code bc-19"><a href="../../man/erl_driver.html"><span class="code">erl_driver</span></a></span> and
      <span class="bold_code bc-19"><a href="../../man/driver_entry.html"><span class="code">driver_entry</span></a></span>
      documentation also.</p>
    </p></div>
</div>

    <p>Although Erlang drivers in general can be beyond the scope of this
      section, a brief introduction seems to be in place.</p>

    <h4><span onMouseOver="document.getElementById('ghlink-drivers-in-general-idm2399').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-drivers-in-general-idm2399').style.visibility = 'hidden';"><span id="ghlink-drivers-in-general-idm2399" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L870" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="drivers-in-general" href="#drivers-in-general">Drivers in General</a></span></h4>
      
      <p>An Erlang driver is a native code module written in C (or
        assembler), which serves as an interface for some special operating
        system service. This is a general mechanism that is used
        throughout the Erlang emulator for all kinds of I/O. An Erlang
        driver can be dynamically linked (or loaded) to the Erlang
        emulator at runtime by using the <span class="code">erl_ddll</span> Erlang
        module. Some of the drivers in OTP are however statically linked
        to the runtime system, but that is more an optimization than a
        necessity.</p>

      <p>The driver data types and the functions available to the driver
        writer are defined in header file <span class="code">erl_driver.h</span>
        seated in Erlang's include directory. See the
        <span class="bold_code bc-18"><a href="../../man/erl_driver.html">erl_driver</a></span> documentation
        for details of which functions are available.</p>

      <p>When writing a driver to make a communications protocol available
        to Erlang, one should know just about everything worth knowing
        about that particular protocol. All operation must be
        non-blocking and all possible situations are to be accounted for in
        the driver. A non-stable driver will affect and/or crash the
        whole Erlang runtime system.</p>

      <p>The emulator calls the driver in the following situations:</p>

      <ul>
        <li>
          <p>When the driver is loaded. This callback must have a special
            name and inform the emulator of what callbacks are to be used 
            by returning a pointer to a <span class="code">ErlDrvEntry</span> struct,
            which is to be properly filled in (see below).</p>
        </li>
        <li>
          <p>When a port to the driver is opened (by a
            <span class="code">open_port</span> call from Erlang). This routine is to
            set up internal data structures and return an opaque data entity of
            the type <span class="code">ErlDrvData</span>, which is a data type large
            enough to hold a pointer.
            The pointer returned by this function is the first
            argument to all other callbacks concerning this particular
            port. It is usually called the port handle. The emulator only
            stores the handle and does never try to interpret it, why it can
            be virtually anything (anything not larger than a pointer
            that is) and can point to anything if it is a pointer. Usually
            this pointer refers to a structure holding information about
            the particular port, as it does in the example.</p>
        </li>
        <li>
          <p>When an Erlang process sends data to the port. The data
            arrives as a buffer of bytes, the interpretation is not defined,
            but is up to the implementor. This callback returns nothing to the
            caller, answers are sent to the caller as messages (using a
            routine called <span class="code">driver_output</span> available to all
            drivers). There is also a way to talk in a synchronous way to
            drivers, described below. There can be an additional callback
            function for handling data that is fragmented (sent in a deep
            io-list). That interface gets the data in a form suitable for
            Unix <span class="code">writev</span> rather than in a single buffer.
            There is no need for a distribution driver to implement such a
            callback, so we will not.</p>
        </li>
        <li>
          <p>When a file descriptor is signaled for input. This callback
            is called when the emulator detects input on a file descriptor
            that the driver has marked for monitoring by using the interface
            <span class="code">driver_select</span>. The mechanism of driver select
            makes it possible to read non-blocking from file descriptors by
            calling <span class="code">driver_select</span> when reading is needed, and
            then do the reading in this callback (when reading is possible).
            The typical scenario is that <span class="code">driver_select</span> is
            called when an Erlang process orders a read operation, and that
            this routine sends the answer when data is available on the file
            descriptor.</p>
        </li>
        <li>
          <p>When a file descriptor is signaled for output. This callback
            is called in a similar way as the previous, but when writing to a
            file descriptor is possible. The usual scenario is that Erlang
            orders writing on a file descriptor and that the driver calls
            <span class="code">driver_select</span>. When the descriptor is ready for
            output, this callback is called and the driver can try to send the
            output. Queuing can be involved in such operations, and there are
            convenient queue routines available to the driver writer to use.</p>
        </li>
        <li>
          <p>When a port is closed, either by an Erlang process or by the
            driver calling one of the <span class="code">driver_failure_XXX</span>
            routines. This routine is to clean up everything connected to one
            particular port. When other callbacks call a
            <span class="code">driver_failure_XXX</span> routine, this routine is
            immediately called. The callback routine issuing the error can
            make no more use of the data structures for the port, as this
            routine surely has freed all associated data and closed all file
            descriptors. If the queue utility available to driver writer is
            used, this routine is however <strong>not</strong> called until the
            queue is empty.</p>
        </li>
        <li>
          <p>When an Erlang process calls
            <span class="bold_code bc-15"><a href="../../man/erlang.html#port_control-3"><span class="code">erlang:port_control/3</span></a></span>,
            which is a synchronous interface to drivers. The control interface
            is used to set driver options, change states of ports, and so on.
            This interface is used a lot in the example.</p>
        </li>
        <li>
          <p>When a timer expires. The driver can set timers with the function
            <span class="code">driver_set_timer</span>. When such timers expire, a
            specific callback function is called. No timers are used in
            the example.</p>
        </li>
        <li>
          <p>When the whole driver is unloaded. Every resource allocated
            by the driver is to be freed.</p>
        </li>
      </ul>
    

    <h4><span onMouseOver="document.getElementById('ghlink-the-data-structures-of-the-distribution-driver-idm2442').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-the-data-structures-of-the-distribution-driver-idm2442').style.visibility = 'hidden';"><span id="ghlink-the-data-structures-of-the-distribution-driver-idm2442" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L990" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="the-data-structures-of-the-distribution-driver" href="#the-data-structures-of-the-distribution-driver">The Data Structures of the Distribution Driver</a></span></h4>
      
      <p>The driver used for Erlang distribution is to implement a
        reliable, order maintaining, variable length packet-oriented
        protocol. All error correction, resending and such need to be
        implemented in the driver or by the underlying communications
        protocol. If the protocol is stream-oriented (as is the case with
        both TCP/IP and our streamed Unix domain sockets), some mechanism
        for packaging is needed. We will use the simple method of having a
        header of four bytes containing the length of the package in a
        big-endian 32-bit integer. As Unix domain sockets only can be used
        between processes on the same machine, we do not need to
        code the integer in some special endianess, but we will do it anyway
        because in most situation you need to do it. Unix domain
        sockets are reliable and order maintaining, so we do not need to
        implement resends and such in the driver.</p>

      <p>We start writing the example Unix domain sockets driver by
        declaring prototypes and filling in a static <span class="code">ErlDrvEntry</span>
        structure:</p>

      <div class="example"><pre>( 1) #include &lt;stdio.h&gt;
( 2) #include &lt;stdlib.h&gt;
( 3) #include &lt;string.h&gt;
( 4) #include &lt;unistd.h&gt;
( 5) #include &lt;errno.h&gt;
( 6) #include &lt;sys/types.h&gt;
( 7) #include &lt;sys/stat.h&gt;
( 8) #include &lt;sys/socket.h&gt;
( 9) #include &lt;sys/un.h&gt;
(10) #include &lt;fcntl.h&gt;

(11) #define HAVE_UIO_H
(12) #include "erl_driver.h"

(13) /*
(14) ** Interface routines
(15) */
(16) static ErlDrvData uds_start(ErlDrvPort port, char *buff);
(17) static void uds_stop(ErlDrvData handle);
(18) static void uds_command(ErlDrvData handle, char *buff, int bufflen);
(19) static void uds_input(ErlDrvData handle, ErlDrvEvent event);
(20) static void uds_output(ErlDrvData handle, ErlDrvEvent event);
(21) static void uds_finish(void);
(22) static int uds_control(ErlDrvData handle, unsigned int command, 
(23)                        char* buf, int count, char** res, int res_size);

(24) /* The driver entry */
(25) static ErlDrvEntry uds_driver_entry = {
(26)     NULL,                            /* init, N/A */
(27)     uds_start,                       /* start, called when port is opened */
(28)     uds_stop,                        /* stop, called when port is closed */
(29)     uds_command,                     /* output, called when erlang has sent */
(30)     uds_input,                       /* ready_input, called when input
(31)                                         descriptor ready */
(32)     uds_output,                      /* ready_output, called when output 
(33)                                         descriptor ready */
(34)     "uds_drv",                       /* char *driver_name, the argument 
(35)                                         to open_port */
(36)     uds_finish,                      /* finish, called when unloaded */
(37)     NULL,                            /* void * that is not used (BC) */
(38)     uds_control,                     /* control, port_control callback */
(39)     NULL,                            /* timeout, called on timeouts */
(40)     NULL,                            /* outputv, vector output interface */
(41)     NULL,                            /* ready_async callback */
(42)     NULL,                            /* flush callback */
(43)     NULL,                            /* call callback */
(44)     NULL,                            /* event callback */
(45)     ERL_DRV_EXTENDED_MARKER,         /* Extended driver interface marker */
(46)     ERL_DRV_EXTENDED_MAJOR_VERSION,  /* Major version number */
(47)     ERL_DRV_EXTENDED_MINOR_VERSION,  /* Minor version number */
(48)     ERL_DRV_FLAG_SOFT_BUSY,          /* Driver flags. Soft busy flag is
(49)                                         required for distribution drivers */
(50)     NULL,                            /* Reserved for internal use */
(51)     NULL,                            /* process_exit callback */
(52)     NULL                             /* stop_select callback */
(53) };</pre></div>

      <p>On line 1-10 the OS headers needed for the driver are included.
        As this driver is written for Solaris, we know that the
        header <span class="code">uio.h</span> exists. So the preprocessor variable
        <span class="code">HAVE_UIO_H</span> can be defined before
        <span class="code">erl_driver.h</span> is included on line 12.
        The definition of <span class="code">HAVE_UIO_H</span> will make the
        I/O vectors used in Erlang's driver queues to correspond to the
        operating systems ditto, which is very convenient.</p>

      <p>On line 16-23 the different callback functions are declared ("forward
        declarations").</p>

      <p>The driver structure is similar for statically linked-in
        drivers and dynamically loaded. However, some of the fields
        are to be left empty (that is, initialized to NULL) in the
        different types of drivers. The first field (the <span class="code">init</span>
        function pointer) is always left blank in a dynamically loaded
        driver, see line 26. <span class="code">NULL</span> on line 37
        is always to be there, the field is no longer used and is
        retained for backward compatibility. No timers are used in this
        driver, why no callback for timers is needed. The <span class="code">outputv</span> field
        (line 40) can be used to implement an interface similar to
        Unix <span class="code">writev</span> for output. The Erlang runtime
        system could previously not use <span class="code">outputv</span> for the
        distribution, but it can as from ERTS 5.7.2.
        As this driver was written before ERTS 5.7.2 it does
        not use the <span class="code">outputv</span> callback. Using the <span class="code">outputv</span>
        callback is preferred, as it reduces copying of data. (We
        will however use scatter/gather I/O internally in the driver.)</p>

      <p>As from ERTS 5.5.3 the driver interface was extended with
        version control and the possibility to pass capability information.
        Capability flags are present on line 48. As from ERTS 5.7.4 flag
        <span class="bold_code bc-15"><a href="../../man/driver_entry.html#driver_flags"><span class="code">ERL_DRV_FLAG_SOFT_BUSY</span></a></span> is required for drivers that
        are to be used by the distribution. The soft busy flag implies that the
        driver can handle calls to the <span class="code">output</span> and <span class="code">outputv</span>
        callbacks although it has marked itself as busy. This has always been a
        requirement on drivers used by the distribution, but no capability
        information has been available about this previously. For more
        information. see <span class="bold_code bc-15"><a href="../../man/erl_driver.html#set_busy_port"><span class="code">erl_driver:set_busy_port()</span></a></span>).</p>

      <p>This driver was written before the runtime system had SMP support.
        The driver will still function in the runtime system with SMP support,
        but performance will suffer from lock contention on the driver lock
        used for the driver. This can be alleviated by reviewing and perhaps
        rewriting the code so that each instance of the driver safely can
        execute in parallel. When instances safely can execute in parallel, it
        is safe to enable instance-specific locking on the driver. This is done
        by passing <span class="bold_code bc-15"><a href="../../man/driver_entry.html#driver_flags"><span class="code">ERL_DRV_FLAG_USE_PORT_LOCKING</span></a></span> as a driver flag. This
        is left as an exercise for the reader.</p>

      <p>Thus, the defined callbacks are as follows:</p>

      <dl>
        <dt><strong><span class="code">uds_start</span></strong></dt>
        <dd>
          <p>Must initiate data for a port. We do not create any sockets
            here, only initialize data structures.</p>
        </dd>
        <dt><strong><span class="code">uds_stop</span></strong></dt>
        <dd>
          <p>Called when a port is closed.</p>
        </dd>
        <dt><strong><span class="code">uds_command</span></strong></dt>
        <dd>
          <p>Handles messages from Erlang. The
            messages can either be plain data to be sent or more subtle
            instructions to the driver. This function is here mostly for
            data pumping.</p>
        </dd>
        <dt><strong><span class="code">uds_input</span></strong></dt>
        <dd>
          <p>Called when there is something to read from a socket.</p>
        </dd>
        <dt><strong><span class="code">uds_output</span></strong></dt>
        <dd>
          <p>Called when it is possible to write to a socket.</p>
        </dd>
        <dt><strong><span class="code">uds_finish</span></strong></dt>
        <dd>
          <p>Called when the driver is unloaded. A distribution driver will
            never be unloaded, but we include this for completeness. To be
            able to clean up after oneself is always a good thing.</p>
        </dd>
        <dt><strong><span class="code">uds_control</span></strong></dt>
        <dd>
          <p>The <span class="bold_code bc-15"><a href="../../man/erlang.html#port_control-3"><span class="code">erlang:port_control/3</span></a></span> callback, which is
            used a lot in this implementation.</p>
        </dd>
      </dl>

      <p>The ports implemented by this driver operate in two major modes,
        named <span class="code">command</span> and <span class="code">data</span>. In <span class="code">command</span> mode,
        only passive reading and writing (like
        <span class="code">gen_tcp:recv</span>/<span class="code">gen_tcp:send</span>) can be done. The port is in
        this mode during the distribution handshake. When the connection is up,
        the port is switched to <span class="code">data</span> mode and all data is immediately
        read and passed further to the Erlang emulator. In <span class="code">data</span>
        mode, no data arriving to <span class="code">uds_command</span> is interpreted, only
        packaged and sent out on the socket. The <span class="code">uds_control</span> callback
        does the switching between those two modes.</p>

      <p>While <span class="code">net_kernel</span> informs different subsystems
        that the connection is coming up, the port is to accept data to send.
        However, the port should not receive any data, to avoid that data
        arrives from another node before every kernel subsystem is prepared
        to handle it. A third mode, named <span class="code">intermediate</span>, is used for this
        intermediate stage.</p>

      <p>An enum is defined for the different types of ports:</p>

      <div class="example"><pre>( 1) typedef enum { 
( 2)     portTypeUnknown,      /* An uninitialized port */
( 3)     portTypeListener,     /* A listening port/socket */
( 4)     portTypeAcceptor,     /* An intermediate stage when accepting
( 5)                              on a listen port */
( 6)     portTypeConnector,    /* An intermediate stage when connecting */
( 7)     portTypeCommand,      /* A connected open port in command mode */
( 8)     portTypeIntermediate, /* A connected open port in special
( 9)                              half active mode */
(10)     portTypeData          /* A connected open port in data mode */ 
(11) } PortType;      </pre></div>

      <p>The different types are as follows:</p>

      <dl>
        <dt><strong><span class="code">portTypeUnknown</span></strong></dt>
        <dd>
          <p>The type a port has when it is opened, but
            not bound to any file descriptor.</p>
        </dd>
        <dt><strong><span class="code">portTypeListener</span></strong></dt>
        <dd>
          <p>A port that is connected to a listen socket. This port does not
            do much, no data pumping is done on this socket, but read data is
            available when one is trying to do an accept on the port.</p>
        </dd>
        <dt><strong><span class="code">portTypeAcceptor</span></strong></dt>
        <dd>
          <p>This port is to represent the result of an accept operation. It is
            created when one wants to accept from a listen socket, and it is
            converted to a <span class="code">portTypeCommand</span> when the accept succeeds.</p>
        </dd>
        <dt><strong><span class="code">portTypeConnector</span></strong></dt>
        <dd>
          <p>Very similar to <span class="code">portTypeAcceptor</span>, an
            intermediate stage between the request for a connect operation and
            that the socket is connected to an accepting ditto in the
            other end. When the sockets are connected, the port
            switches type to <span class="code">portTypeCommand</span>.</p>
        </dd>
        <dt><strong><span class="code">portTypeCommand</span></strong></dt>
        <dd>
          <p>A connected socket (or accepted socket) in <span class="code">command</span> mode
            mentioned earlier.</p>
        </dd>
        <dt><strong><span class="code">portTypeIntermediate</span></strong></dt>
        <dd>
          <p>The intermediate stage for a connected socket.
            There is to be no processing of input for this socket.</p>
        </dd>
        <dt><strong><span class="code">portTypeData</span></strong></dt>
        <dd>
          <p>The mode where data is pumped through the port and the
            <span class="code">uds_command</span> routine regards every call as a call where
            sending is wanted. In this mode, all input available is read and
            sent to Erlang when it arrives on the socket, much like in the
            active mode of a <span class="code">gen_tcp</span> socket.</p>
        </dd>
      </dl>

      <p>We study the state that is needed for the ports. Notice
        that not all fields are used for all types of ports. Some space
        could be saved by using unions, but that would clutter the
        code with multiple indirections, so here is used one struct for
        all types of ports, for readability:</p>

      <div class="example"><pre>( 1) typedef unsigned char Byte;
( 2) typedef unsigned int Word;

( 3) typedef struct uds_data {
( 4)     int fd;                   /* File descriptor */
( 5)     ErlDrvPort port;          /* The port identifier */
( 6)     int lockfd;               /* The file descriptor for a lock file in 
( 7)                                  case of listen sockets */
( 8)     Byte creation;            /* The creation serial derived from the 
( 9)                                  lock file */
(10)     PortType type;            /* Type of port */
(11)     char *name;               /* Short name of socket for unlink */
(12)     Word sent;                /* Bytes sent */
(13)     Word received;            /* Bytes received */
(14)     struct uds_data *partner; /* The partner in an accept/listen pair */
(15)     struct uds_data *next;    /* Next structure in list */
(16)     /* The input buffer and its data */
(17)     int buffer_size;          /* The allocated size of the input buffer */
(18)     int buffer_pos;           /* Current position in input buffer */
(19)     int header_pos;           /* Where the current header is in the 
(20)                                  input buffer */
(21)     Byte *buffer;             /* The actual input buffer */
(22) } UdsData;      </pre></div>

      <p>This structure is used for all types of ports although some
        fields are useless for some types. The least memory consuming
        solution would be to arrange this structure as a union of
        structures. However, the multiple indirections in the code to
        access a field in such a structure would clutter the code too
        much for an example.</p>

      <p>The fields in the structure are as follows:</p>

      <dl>
        <dt><strong><span class="code">fd</span></strong></dt>
        <dd>
          <p>The file descriptor of the socket associated with the port.</p>
        </dd>
        <dt><strong><span class="code">port</span></strong></dt>
        <dd>
          <p>The port identifier for the port that this structure
            corresponds to. It is needed for most <span class="code">driver_XXX</span>
            calls from the driver back to the emulator.</p>
        </dd>
        <dt><strong><span class="code">lockfd</span></strong></dt>
        <dd>
          <p>If the socket is a listen socket, we use a separate
            (regular) file for two purposes:</p>
          <ul>
            <li>
              <p>We want a locking mechanism that gives no race
                conditions, to be sure if another Erlang
                node uses the listen socket name we require or if the
                file is only left there from a previous (crashed) session.</p>
            </li>
            <li>
              <p>We store the <span class="code">creation</span> serial number in the
                file. The <span class="code">creation</span> is a number that is to
                change between different instances of different Erlang
                emulators with the same name, so that process
                identifiers from one emulator do not become valid when sent
                to a new emulator with the same distribution name. The
                creation can be from 0 through 3 (two bits) and is stored
                in every process identifier sent to another node.</p>
              <p>In a system with TCP-based distribution, this data is
                kept in the <strong>Erlang port mapper daemon</strong>
                (<span class="code">epmd</span>), which is contacted when a distributed
                node starts. The lock file and a convention for the UDS
                listen socket's name remove the need for
                <span class="code">epmd</span> when using this distribution module. UDS
                is always restricted to one host, why avoiding a port
                mapper is easy.</p>
            </li>
          </ul>
        </dd>
        <dt><strong><span class="code">creation</span></strong></dt>
        <dd>
          <p>The creation number for a listen socket, which is
            calculated as (the value found in the lock-file + 1) rem 4.
            This creation value is also written back into the
            lock file, so that the next invocation of the emulator
            finds our value in the file.</p>
        </dd>
        <dt><strong><span class="code">type</span></strong></dt>
        <dd>
          <p>The current type/state of the port, which can be one
            of the values declared above.</p>
        </dd>
        <dt><strong><span class="code">name</span></strong></dt>
        <dd>
          <p>The name of the socket file (the path prefix removed),
            which allows for deletion (<span class="code">unlink</span>) when the
            socket is closed.</p>
        </dd>
        <dt><strong><span class="code">sent</span></strong></dt>
        <dd>
          <p>How many bytes that have been sent over the
            socket. This can wrap, but that is no problem for the
            distribution, as the Erlang distribution is only interested in
            if this value has changed. (The Erlang
            <span class="code">net_kernel</span> <span class="code">ticker</span> uses this value by calling the
            driver to fetch it, which is done through the
            <span class="bold_code bc-15"><a href="../../man/erlang.html#port_control-3"><span class="code">erlang:port_control/3</span></a></span> routine.)</p>
        </dd>
        <dt><strong><span class="code">received</span></strong></dt>
        <dd>
          <p>How many bytes that are read (received) from the
            socket, used in similar ways as <span class="code">sent</span>.</p>
        </dd>
        <dt><strong><span class="code">partner</span></strong></dt>
        <dd>
          <p>A pointer to another port structure, which is
            either the listen port from which this port is accepting a
            connection or conversely. The "partner relation"
            is always bidirectional.</p>
        </dd>
        <dt><strong><span class="code">next</span></strong></dt>
        <dd>
          <p>Pointer to next structure in a linked list of all
            port structures. This list is used when accepting
            connections and when the driver is unloaded.</p>
        </dd>
        <dt><strong><span class="code">buffer_size</span>, <span class="code">buffer_pos</span>, <span class="code">header_pos</span>,
          <span class="code">buffer</span></strong></dt>
        <dd>
          <p>Data for input buffering. For details about the input buffering,
            see the source code in directory <span class="code">kernel/examples</span>. That
            certainly goes beyond the scope of this section.</p>
        </dd>
      </dl>
    

    <h4><span onMouseOver="document.getElementById('ghlink-selected-parts-of-the-distribution-driver-implementation-idm2626').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-selected-parts-of-the-distribution-driver-implementation-idm2626').style.visibility = 'hidden';"><span id="ghlink-selected-parts-of-the-distribution-driver-implementation-idm2626" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L1385" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="selected-parts-of-the-distribution-driver-implementation" href="#selected-parts-of-the-distribution-driver-implementation">Selected Parts of the Distribution Driver Implementation</a></span></h4>
      
      <p>The implemenation of the distribution driver is not completely
        covered here, details about buffering and other things
        unrelated to driver writing are not explained. Likewise are
        some peculiarities of the UDS protocol not explained in
        detail. The chosen protocol is not important.</p>

      <p>Prototypes for the driver callback routines can be found in
        the <span class="code">erl_driver.h</span> header file.</p>

      <p>The driver initialization routine is (usually) declared with a
        macro to make the driver easier to port between different
        operating systems (and flavors of systems). This is the only
        routine that must have a well-defined name. All other
        callbacks are reached through the driver structure. The macro
        to use is named <span class="code">DRIVER_INIT</span> and takes the driver name
        as parameter:</p>

      <div class="example"><pre>(1) /* Beginning of linked list of ports */
(2) static UdsData *first_data;

(3) DRIVER_INIT(uds_drv)
(4) {
(5)     first_data = NULL;
(6)     return &amp;uds_driver_entry;
(7) }      </pre></div>

      <p>The routine initializes the single global data structure and
        returns a pointer to the driver entry. The routine is called
        when <span class="code">erl_ddll:load_driver</span> is called from Erlang.</p>

      <p>The <span class="code">uds_start</span> routine is called when a port is
        opened from Erlang. In this case, we only allocate a structure and
        initialize it. Creating the actual socket is left to the
        <span class="code">uds_command</span> routine.</p>

      <div class="example"><pre>( 1) static ErlDrvData uds_start(ErlDrvPort port, char *buff)
( 2) {
( 3)     UdsData *ud;
( 4)     
( 5)     ud = ALLOC(sizeof(UdsData));
( 6)     ud-&gt;fd = -1;
( 7)     ud-&gt;lockfd = -1;
( 8)     ud-&gt;creation = 0;
( 9)     ud-&gt;port = port;
(10)     ud-&gt;type = portTypeUnknown;
(11)     ud-&gt;name = NULL;
(12)     ud-&gt;buffer_size = 0;
(13)     ud-&gt;buffer_pos = 0;
(14)     ud-&gt;header_pos = 0;
(15)     ud-&gt;buffer = NULL;
(16)     ud-&gt;sent = 0;
(17)     ud-&gt;received = 0;
(18)     ud-&gt;partner = NULL;
(19)     ud-&gt;next = first_data;
(20)     first_data = ud;
(21)     
(22)     return((ErlDrvData) ud);
(23) }      </pre></div>

      <p>Every data item is initialized, so that no problems arise
        when a newly created port is closed (without there being any
        corresponding socket). This routine is called when
        <span class="code">open_port({spawn, "uds_drv"},[])</span> is called from
        Erlang.</p>

      <p>The <span class="code">uds_command</span> routine is the routine called when
        an Erlang process sends data to the port. This routine handles all
        asynchronous commands when the port is in <span class="code">command</span> mode and
        the sending of all data when the port is in <span class="code">data</span> mode:</p>

      <div class="example"><pre>( 1) static void uds_command(ErlDrvData handle, char *buff, int bufflen)
( 2) {
( 3)     UdsData *ud = (UdsData *) handle;

( 4)     if (ud-&gt;type == portTypeData || ud-&gt;type == portTypeIntermediate) {
( 5)         DEBUGF(("Passive do_send %d",bufflen));
( 6)         do_send(ud, buff + 1, bufflen - 1); /* XXX */
( 7)         return;
( 8)     } 
( 9)     if (bufflen == 0) {
(10)         return;
(11)     }
(12)     switch (*buff) {
(13)     case 'L':
(14)         if (ud-&gt;type != portTypeUnknown) {
(15)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(16)             return;
(17)         }
(18)         uds_command_listen(ud,buff,bufflen);
(19)         return;
(20)     case 'A':
(21)         if (ud-&gt;type != portTypeUnknown) {
(22)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(23)             return;
(24)         }
(25)         uds_command_accept(ud,buff,bufflen);
(26)         return;
(27)     case 'C':
(28)         if (ud-&gt;type != portTypeUnknown) {
(29)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(30)             return;
(31)         }
(32)         uds_command_connect(ud,buff,bufflen);
(33)         return;
(34)     case 'S':
(35)         if (ud-&gt;type != portTypeCommand) {
(36)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(37)             return;
(38)         }
(39)         do_send(ud, buff + 1, bufflen - 1);
(40)         return;
(41)     case 'R':
(42)         if (ud-&gt;type != portTypeCommand) {
(43)             driver_failure_posix(ud-&gt;port, ENOTSUP);
(44)             return;
(45)         }
(46)         do_recv(ud);
(47)         return;
(48)     default:
(49)         return;
(50)     }
(51) }      </pre></div>

      <p>The command routine takes three parameters; the handle returned for
        the port by <span class="code">uds_start</span>, which is a pointer
        to the internal port structure, the data buffer, and the length
        of the data buffer. The buffer is the data sent from Erlang
        (a list of bytes) converted to an C array (of bytes).</p>

      <p>If Erlang sends, for example, the list <span class="code">[$a,$b,$c]</span>
        to the port, the <span class="code">bufflen</span> variable is
        <span class="code">3</span> and the <span class="code">buff</span> variable contains
        <span class="code">{'a','b','c'}</span> (no
        <span class="code">NULL</span> termination). Usually the first byte is used as an
        opcode, which is the case in this driver too (at least when the
        port is in <span class="code">command</span> mode). The opcodes are defined as follows:</p>

      <dl>
        <dt><strong><span class="code">'L'&lt;socket name&gt;</span></strong></dt>
        <dd>
          <p>Creates and listens on socket with the specified name.</p>
        </dd>
        <dt><strong><span class="code">'A'&lt;listen number as 32-bit big-endian&gt;</span></strong></dt>
        <dd>
          <p>Accepts from the listen socket identified by the specified
            identification number. The identification number is retrieved with
            the <span class="code">uds_control</span> routine.</p>
        </dd>
        <dt><strong><span class="code">'C'&lt;socket name&gt;</span></strong></dt>
        <dd>
          <p>Connects to the socket named &lt;socket name&gt;.</p>
        </dd>
        <dt><strong><span class="code">'S'&lt;data&gt;</span></strong></dt>
        <dd>
          <p>Sends the data &lt;data&gt; on the
            connected/accepted socket (in <span class="code">command</span> mode). The sending is
            acknowledged when the data has left this process.</p>
        </dd>
        <dt><strong><span class="code">'R'</span></strong></dt>
        <dd>
          <p>Receives one packet of data.</p>
        </dd>
      </dl>

      <p>"One packet of data" in command <span class="code">'R'</span> can be explained
        as follows. This driver always sends data packaged with a 4
        byte header containing a big-endian 32-bit integer that
        represents the length of the data in the packet. There is no
        need for different packet sizes or some kind of streamed
        mode, as this driver is for the distribution only.
        Why is the header word coded explicitly in big-endian when a UDS
        socket is local to the host? It is good practice when writing a
        distribution driver, as distribution in practice usually crosses
        the host boundaries.</p>

      <p>On line 4-8 is handled the case where the port is in <span class="code">data</span> mode
        or <span class="code">intermediate</span> mode and the remaining routine handles the
        different commands. The routine uses the
        <span class="code">driver_failure_posix()</span> routine to report errors
        (see, for example, line 15). Notice that the failure routines make
        a call to the <span class="code">uds_stop</span> routine, which will
        remove the internal port data. The handle (and the casted handle
        <span class="code">ud</span>) is therefore <strong>invalid pointers</strong> after a
        <span class="code">driver_failure</span> call and we should <strong>return
        immediately</strong>. The runtime system will send exit signals to all
        linked processes.</p>

      <p>The <span class="code">uds_input</span> routine is called when data is available on a
        file descriptor previously passed to the
        <span class="code">driver_select</span> routine. This occurs typically when
        a read command is issued and no data is available. The
        <span class="code">do_recv</span> routine is as follows:</p>

      <div class="example"><pre>( 1) static void do_recv(UdsData *ud)
( 2) {
( 3)     int res;
( 4)     char *ibuf;
( 5)     for(;;) {
( 6)         if ((res = buffered_read_package(ud,&amp;ibuf)) &lt; 0) {
( 7)             if (res == NORMAL_READ_FAILURE) {
( 8)                 driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ, 1);
( 9)             } else {
(10)                 driver_failure_eof(ud-&gt;port);
(11)             }
(12)             return;
(13)         }
(14)         /* Got a package */
(15)         if (ud-&gt;type == portTypeCommand) {
(16)             ibuf[-1] = 'R'; /* There is always room for a single byte 
(17)                                opcode before the actual buffer 
(18)                                (where the packet header was) */
(19)             driver_output(ud-&gt;port,ibuf - 1, res + 1);
(20)             driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ,0);
(21)             return;
(22)         } else {
(23)             ibuf[-1] = DIST_MAGIC_RECV_TAG; /* XXX */
(24)             driver_output(ud-&gt;port,ibuf - 1, res + 1);
(25)             driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ,1);
(26)         }
(27)     }
(28) }      </pre></div>

      <p>The routine tries to read data until a packet is read or the
        <span class="code">buffered_read_package</span> routine returns a
        <span class="code">NORMAL_READ_FAILURE</span> (an internally defined constant
        for the module, which means that the read operation resulted in an
        <span class="code">EWOULDBLOCK</span>). If the port is in <span class="code">command</span> mode,
        the reading stops when one package is read. If the port is in
        <span class="code">data</span> mode, the reading continues until the socket buffer is empty
        (read failure). If no more data can be read and more is wanted (which
        is always the case when the socket is in <span class="code">data</span> mode),
        <span class="code">driver_select</span> is called to make the <span class="code">uds_input</span>
        callback be called when more data is available for reading.</p>

      <p>When the port is in <span class="code">data</span> mode, all data is sent to Erlang in a
        format that suits the distribution. In fact, the raw data will
        never reach any Erlang process, but will be
        translated/interpreted by the emulator itself and then
        delivered in the correct format to the correct processes. In
        the current emulator version, received data is to be tagged
        with a single byte of 100. That is what the macro
        <span class="code">DIST_MAGIC_RECV_TAG</span> is defined to. The tagging of
        data in the distribution can be changed in the future.</p>

      <p>The <span class="code">uds_input</span> routine handles other input events
        (like non-blocking <span class="code">accept</span>), but most importantly
        handle
        data arriving at the socket by calling <span class="code">do_recv</span>:</p>

      <div class="example"><pre>( 1) static void uds_input(ErlDrvData handle, ErlDrvEvent event)
( 2) {
( 3)     UdsData *ud = (UdsData *) handle;

( 4)     if (ud-&gt;type == portTypeListener) {
( 5)         UdsData *ad = ud-&gt;partner;
( 6)         struct sockaddr_un peer;
( 7)         int pl = sizeof(struct sockaddr_un);
( 8)         int fd;

( 9)         if ((fd = accept(ud-&gt;fd, (struct sockaddr *) &amp;peer, &amp;pl)) &lt; 0) {
(10)             if (errno != EWOULDBLOCK) {
(11)                 driver_failure_posix(ud-&gt;port, errno);
(12)                 return;
(13)             }
(14)             return;
(15)         }
(16)         SET_NONBLOCKING(fd);
(17)         ad-&gt;fd = fd;
(18)         ad-&gt;partner = NULL;
(19)         ad-&gt;type = portTypeCommand;
(20)         ud-&gt;partner = NULL;
(21)         driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ, 0);
(22)         driver_output(ad-&gt;port, "Aok",3);
(23)         return;
(24)     }
(25)     do_recv(ud);
(26) }      </pre></div>

      <p>The important line is the last line in the function: the
        <span class="code">do_read</span> routine is called to handle new input.
        The remaining function handles input on a listen socket, which means
        that it is to be possible to do an accept on the
        socket, which is also recognized as a read event.</p>

      <p>The output mechanisms are similar to the input.
        The <span class="code">do_send</span> routine is as follows:</p>

      <div class="example"><pre>( 1) static void do_send(UdsData *ud, char *buff, int bufflen) 
( 2) {
( 3)     char header[4];
( 4)     int written;
( 5)     SysIOVec iov[2];
( 6)     ErlIOVec eio;
( 7)     ErlDrvBinary *binv[] = {NULL,NULL};

( 8)     put_packet_length(header, bufflen);
( 9)     iov[0].iov_base = (char *) header;
(10)     iov[0].iov_len = 4;
(11)     iov[1].iov_base = buff;
(12)     iov[1].iov_len = bufflen;
(13)     eio.iov = iov;
(14)     eio.binv = binv;
(15)     eio.vsize = 2;
(16)     eio.size = bufflen + 4;
(17)     written = 0;
(18)     if (driver_sizeq(ud-&gt;port) == 0) {
(19)         if ((written = writev(ud-&gt;fd, iov, 2)) == eio.size) {
(20)             ud-&gt;sent += written;
(21)             if (ud-&gt;type == portTypeCommand) {
(22)                 driver_output(ud-&gt;port, "Sok", 3);
(23)             }
(24)             return;
(25)         } else if (written &lt; 0) {
(26)             if (errno != EWOULDBLOCK) {
(27)                 driver_failure_eof(ud-&gt;port);
(28)                 return;
(29)             } else {
(30)                 written = 0;
(31)             }
(32)         } else {
(33)             ud-&gt;sent += written;
(34)         }
(35)         /* Enqueue remaining */
(36)     }
(37)     driver_enqv(ud-&gt;port, &amp;eio, written);
(38)     send_out_queue(ud);
(39) }      </pre></div>

      <p>This driver uses the <span class="code">writev</span> system call to send data
        onto the socket. A combination of <span class="code">writev</span> and the driver output
        queues is very convenient. An <span class="code">ErlIOVec</span> structure
        contains a <span class="code">SysIOVec</span> (which is equivalent to the
        <span class="code">struct iovec</span> structure defined in
        <span class="code">uio.h</span>. The
        <span class="code">ErlIOVec</span> also contains an array of <span class="code">ErlDrvBinary</span>
        pointers, of the same length as the number of buffers in the
        I/O vector itself. One can use this to allocate the binaries
        for the queue "manually" in the driver, but here
        the binary array is filled with <span class="code">NULL</span> values (line 7).
        The runtime system then allocates its own buffers when
        <span class="code">driver_enqv</span> is called (line 37).</p>

      <p>The routine builds an I/O vector containing the header bytes
        and the buffer (the opcode has been removed and the buffer
        length decreased by the output routine). If the queue is
        empty, we write the data directly to the socket (or at
        least try to). If any data is left, it is stored in the queue
        and then we try to send the queue (line 38). An acknowledgement
        is sent when the message is delivered completely (line 22). The
        <span class="code">send_out_queue</span> sends acknowledgements if the sending
        is completed there. If the port is in <span class="code">command</span> mode, the Erlang
        code serializes the send operations so that only one packet
        can be waiting for delivery at a time. Therefore the acknowledgement
        can be sent whenever the queue is empty.</p>

      <p>The <span class="code">send_out_queue</span> routine is as follows:</p>

      <div class="example"><pre>( 1) static int send_out_queue(UdsData *ud)
( 2) {
( 3)     for(;;) {
( 4)         int vlen;
( 5)         SysIOVec *tmp = driver_peekq(ud-&gt;port, &amp;vlen);
( 6)         int wrote;
( 7)         if (tmp == NULL) {
( 8)             driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_WRITE, 0);
( 9)             if (ud-&gt;type == portTypeCommand) {
(10)                 driver_output(ud-&gt;port, "Sok", 3);
(11)             }
(12)             return 0;
(13)         }
(14)         if (vlen &gt; IO_VECTOR_MAX) {
(15)             vlen = IO_VECTOR_MAX;
(16)         } 
(17)         if ((wrote = writev(ud-&gt;fd, tmp, vlen)) &lt; 0) {
(18)             if (errno == EWOULDBLOCK) {
(19)                 driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, 
(20)                               DO_WRITE, 1);
(21)                 return 0;
(22)             } else {
(23)                 driver_failure_eof(ud-&gt;port);
(24)                 return -1;
(25)             }
(26)         }
(27)         driver_deq(ud-&gt;port, wrote);
(28)         ud-&gt;sent += wrote;
(29)     }
(30) }      </pre></div>

      <p>We simply pick out an I/O vector from the queue
        (which is the whole queue as a <span class="code">SysIOVec</span>). If the I/O
        vector is too long (<span class="code">IO_VECTOR_MAX</span> is defined to 16), the vector
        length is decreased (line 15), otherwise the <span class="code">writev</span>
        call (line 17) fails. Writing is tried and anything written is dequeued
        (line 27).
        If the write fails with <span class="code">EWOULDBLOCK</span> (notice that all
        sockets are in non-blocking mode), <span class="code">driver_select</span> is
        called to make the <span class="code">uds_output</span> routine be called when
        there is space to write again.</p>

      <p>We continue trying to write until the queue is empty or
        the writing blocks.</p>

      <p>The routine above is called from the <span class="code">uds_output</span>
        routine:</p>

      <div class="example"><pre>( 1) static void uds_output(ErlDrvData handle, ErlDrvEvent event)
( 2) {
( 3)    UdsData *ud = (UdsData *) handle;
( 4)    if (ud-&gt;type == portTypeConnector) {
( 5)        ud-&gt;type = portTypeCommand;
( 6)        driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_WRITE, 0);
( 7)        driver_output(ud-&gt;port, "Cok",3);
( 8)        return;
( 9)    }
(10)    send_out_queue(ud);
(11) }      </pre></div>

      <p>The routine is simple: it first handles the fact that the
        output select will concern a socket in the business of
        connecting (and the connecting blocked). If the socket is in
        a connected state, it simply sends the output queue. This
        routine is called when it is possible to write to a socket
        where we have an output queue, so there is no question what to
        do.</p>

      <p>The driver implements a control interface, which is a
        synchronous interface called when Erlang calls
        <span class="bold_code bc-15"><a href="../../man/erlang.html#port_control-3"><span class="code">erlang:port_control/3</span></a></span>. Only this interface
        can control the driver when it is in <span class="code">data</span> mode. It can
        be called with the following opcodes:</p>

      <dl>
        <dt><strong><span class="code">'C'</span></strong></dt>
        <dd>
          <p>Sets port in <span class="code">command</span> mode.</p>
        </dd>
        <dt><strong><span class="code">'I'</span></strong></dt>
        <dd>
          <p>Sets port in <span class="code">intermediate</span> mode.</p>
        </dd>
        <dt><strong><span class="code">'D'</span></strong></dt>
        <dd>
          <p>Sets port in <span class="code">data</span> mode.</p>
        </dd>
        <dt><strong><span class="code">'N'</span></strong></dt>
        <dd>
          <p>Gets identification number for listen port. This
            identification number is used in an accept command to the
            driver. It is returned as a big-endian 32-bit integer, which
            is the file identifier for the listen socket.</p>
        </dd>
        <dt><strong><span class="code">'S'</span></strong></dt>
        <dd>
          <p>Gets statistics, which is the number of bytes received,
            the number of bytes sent, and the number of bytes pending in
            the output queue. This data is used when the distribution
            checks that a connection is alive (ticking). The statistics
            is returned as three 32-bit big-endian integers.</p>
        </dd>
        <dt><strong><span class="code">'T'</span></strong></dt>
        <dd>
          <p>Sends a tick message, which is a packet of length 0.
            Ticking is done when the port is in <span class="code">data</span> mode, so the
            command for sending data cannot be used (besides it ignores
            zero length packages in <span class="code">command</span> mode). This is used by the
            ticker to send dummy data when no other traffic is present.</p>
          <p><strong>Note:</strong> It is important that the interface for
            sending ticks is not blocking. This implementation uses
            <span class="bold_code bc-15"><a href="../../man/erlang.html#port_control-3"><span class="code">erlang:port_control/3</span></a></span>, which does not block the
            caller. If <span class="code">erlang:port_command</span> is used, use
            <span class="bold_code bc-15"><a href="../../man/erlang.html#port_command-3"><span class="code">erlang:port_command/3</span></a></span> and pass <span class="code">[force]</span> as
            option list; otherwise the caller can be blocked indefinitely
            on a busy port and prevent the system from taking down a
            connection that is not functioning.</p>
        </dd>
        <dt><strong><span class="code">'R'</span></strong></dt>
        <dd>
          <p>Gets creation number of a listen socket, which is used to
            dig out the number stored in the lock file to differentiate
            between invocations of Erlang nodes with the same name.</p>
        </dd>
      </dl>

      <p>The control interface gets a buffer to return its value in,
        but is free to allocate its own buffer if the provided one is
        too small. The <span class="code">uds_control</span> code is as follows:</p>

      <div class="example"><pre>( 1) static int uds_control(ErlDrvData handle, unsigned int command, 
( 2)                        char* buf, int count, char** res, int res_size)
( 3) {
( 4) /* Local macro to ensure large enough buffer. */
( 5) #define ENSURE(N)                               \
( 6)    do {                                         \
( 7)        if (res_size &lt; N) {                      \
( 8)            *res = ALLOC(N);                     \
( 9)        }                                        \
(10)    } while(0)

(11)    UdsData *ud = (UdsData *) handle;

(12)    switch (command) {
(13)    case 'S':
(14)        {
(15)            ENSURE(13);
(16)            **res = 0;
(17)            put_packet_length((*res) + 1, ud-&gt;received);
(18)            put_packet_length((*res) + 5, ud-&gt;sent);
(19)            put_packet_length((*res) + 9, driver_sizeq(ud-&gt;port));
(20)            return 13;
(21)        }
(22)    case 'C':
(23)        if (ud-&gt;type &lt; portTypeCommand) {
(24)            return report_control_error(res, res_size, "einval");
(25)        }
(26)        ud-&gt;type = portTypeCommand;
(27)        driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ, 0);
(28)        ENSURE(1);
(29)        **res = 0;
(30)        return 1;
(31)    case 'I':
(32)        if (ud-&gt;type &lt; portTypeCommand) {
(33)            return report_control_error(res, res_size, "einval");
(34)        }
(35)        ud-&gt;type = portTypeIntermediate;
(36)        driver_select(ud-&gt;port, (ErlDrvEvent) ud-&gt;fd, DO_READ, 0);
(37)        ENSURE(1);
(38)        **res = 0;
(39)        return 1;
(40)    case 'D':
(41)        if (ud-&gt;type &lt; portTypeCommand) {
(42)            return report_control_error(res, res_size, "einval");
(43)        }
(44)        ud-&gt;type = portTypeData;
(45)        do_recv(ud);
(46)        ENSURE(1);
(47)        **res = 0;
(48)        return 1;
(49)    case 'N':
(50)        if (ud-&gt;type != portTypeListener) {
(51)            return report_control_error(res, res_size, "einval");
(52)        }
(53)        ENSURE(5);
(54)        (*res)[0] = 0;
(55)        put_packet_length((*res) + 1, ud-&gt;fd);
(56)        return 5;
(57)    case 'T': /* tick */
(58)        if (ud-&gt;type != portTypeData) {
(59)            return report_control_error(res, res_size, "einval");
(60)        }
(61)        do_send(ud,"",0);
(62)        ENSURE(1);
(63)        **res = 0;
(64)        return 1;
(65)    case 'R':
(66)        if (ud-&gt;type != portTypeListener) {
(67)            return report_control_error(res, res_size, "einval");
(68)        }
(69)        ENSURE(2);
(70)        (*res)[0] = 0;
(71)        (*res)[1] = ud-&gt;creation;
(72)        return 2;
(73)    default:
(74)        return report_control_error(res, res_size, "einval");
(75)    }
(76) #undef ENSURE
(77) }      </pre></div>

      <p>The macro <span class="code">ENSURE</span> (line 5-10) is used to ensure that
        the buffer is large enough for the answer. We switch on the command and
        take actions. We always have read select active on a port in <span class="code">data</span>
        mode (achieved by calling <span class="code">do_recv</span> on line 45), but
        we turn off read selection in <span class="code">intermediate</span> and <span class="code">command</span>
        modes (line 27 and 36).</p>

      <p>The rest of the driver is more or less UDS-specific and not of
        general interest.</p>
    
  

  <h3><span onMouseOver="document.getElementById('ghlink-putting-it-all-together-idm2803').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-putting-it-all-together-idm2803').style.visibility = 'hidden';"><span id="ghlink-putting-it-all-together-idm2803" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/erts/doc/src/alt_dist.xml#L1978" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="putting-it-all-together" href="#putting-it-all-together">6.4 
          Putting It All Together</a></span></h3>
    
    <p>To test the distribution, the <span class="code">net_kernel:start/1</span>
      function can be used. It is useful, as it starts the distribution on a
      running system, where tracing/debugging can be performed.
      The <span class="code">net_kernel:start/1</span> routine takes a
      list as its single argument. The list first element in the list is to be
      the node name (without the "@hostname") as an atom. The second (and
      last) element is to be one of the atoms <span class="code">shortnames</span> or 
      <span class="code">longnames</span>. In the example case,
      <span class="code">shortnames</span> is preferred.</p>

    <p>For <span class="code">net_kernel</span> to find out which distribution module to use,
      command-line argument <span class="code">-proto_dist</span> is used. It
      is followed by one or more distribution module names, with suffix
      "_dist" removed, that is, <span class="code">uds_dist</span> as a distribution module
      is specified as <span class="code">-proto_dist uds</span>.</p>

    <p>If no <span class="code">epmd</span> (TCP port mapper daemon) is used, also command-line
      option <span class="code">-no_epmd</span> is to be specified, which makes
      Erlang skip the <span class="code">epmd</span> startup, both as an OS process and as an
      Erlang ditto.</p>

    <p>The path to the directory where the distribution modules reside
      must be known at boot. This can be achieved either by
      specifying <span class="code">-pa &lt;path&gt;</span> on the command line or by
      building a boot script containing the applications used for your
      distribution protocol. (In the <span class="code">uds_dist</span> protocol, only the
      <span class="code">uds_dist</span> application needs to be added to the script.)</p>

    <p>The distribution starts at boot if all the above is
      specified and an <span class="code">-sname &lt;name&gt;</span> flag is present at the
      command line.</p>

    <p><strong>Example 1:</strong></p>

    <div class="example"><pre>
$ <span class="bold_code bc-12">erl -pa $ERL_TOP/lib/kernel/examples/uds_dist/ebin -proto_dist uds -no_epmd</span>
Erlang (BEAM) emulator version 5.0 
 
Eshell V5.0  (abort with ^G)
1&gt; <span class="bold_code bc-12">net_kernel:start([bing,shortnames]).</span>
{ok,&lt;0.30.0&gt;}
(bing@hador)2&gt;</pre></div>

    <p><strong>Example 2:</strong></p>

    <div class="example"><pre>
$ <span class="bold_code bc-12">erl -pa $ERL_TOP/lib/kernel/examples/uds_dist/ebin -proto_dist uds \ </span>
<span class="bold_code bc-12">      -no_epmd -sname bong</span>
Erlang (BEAM) emulator version 5.0 
 
Eshell V5.0  (abort with ^G)
(bong@hador)1&gt;</pre></div>

    <p>The <span class="code">ERL_FLAGS</span> environment variable can be used to store the
      complicated parameters in:</p>

    <div class="example"><pre>
$ <span class="bold_code bc-12">ERL_FLAGS=-pa $ERL_TOP/lib/kernel/examples/uds_dist/ebin \ </span>
<span class="bold_code bc-12">      -proto_dist uds -no_epmd</span>
$ <span class="bold_code bc-12">export ERL_FLAGS</span>
$ <span class="bold_code bc-12">erl -sname bang</span>
Erlang (BEAM) emulator version 5.0 
 
Eshell V5.0  (abort with ^G)
(bang@hador)1&gt;</pre></div>

    <p><span class="code">ERL_FLAGS</span> should not include the node name.</p>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2021 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../../js/';</script><script type="text/javascript" src="../../js/highlight.js"></script>
</body>
</html>
