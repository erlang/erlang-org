<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- erl_driver</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<div class="erlang-logo-wrapper"><a href="../index.html"><img alt="Erlang Logo" src="../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Erlang Run-Time System Application (ERTS)</p>
<p class="section-subtitle">Reference Manual</p>
<p class="section-version">Version 9.3</p>
<ul class="panel-sections">
<li><a href="../apps/erts/users_guide.html">User's Guide</a></li>
<li><a href="../apps/erts/index.html">Reference Manual</a></li>
<li><a href="../apps/erts/release_notes.html">Release Notes</a></li>
<li><a href="../apps/erts/erts.pdf">PDF</a></li>
<li><a href="../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Table of Contents</h3>
<ul class="flipMenu">
<li id="no" title="erl_prim_loader " expanded="false">erl_prim_loader<ul>
<li><a href="erl_prim_loader.html">
                  Top of manual page
                </a></li>
    <li title="get_file-1"><a href="erl_prim_loader.html#get_file-1">get_file/1</a></li>
    <li title="get_path-0"><a href="erl_prim_loader.html#get_path-0">get_path/0</a></li>
    <li title="list_dir-1"><a href="erl_prim_loader.html#list_dir-1">list_dir/1</a></li>
    <li title="read_file_info-1"><a href="erl_prim_loader.html#read_file_info-1">read_file_info/1</a></li>
    <li title="read_link_info-1"><a href="erl_prim_loader.html#read_link_info-1">read_link_info/1</a></li>
    <li title="set_path-1"><a href="erl_prim_loader.html#set_path-1">set_path/1</a></li>
    </ul>
</li>
<li id="no" title="erlang " expanded="false">erlang<ul>
<li><a href="erlang.html">
                  Top of manual page
                </a></li>
    <li title="abs-1"><a href="erlang.html#abs-1">abs/1</a></li>
    <li title="adler32-1"><a href="erlang.html#adler32-1">adler32/1</a></li>
    <li title="adler32-2"><a href="erlang.html#adler32-2">adler32/2</a></li>
    <li title="adler32_combine-3"><a href="erlang.html#adler32_combine-3">adler32_combine/3</a></li>
    <li title="append_element-2"><a href="erlang.html#append_element-2">append_element/2</a></li>
    <li title="apply-2"><a href="erlang.html#apply-2">apply/2</a></li>
    <li title="apply-3"><a href="erlang.html#apply-3">apply/3</a></li>
    <li title="atom_to_binary-2"><a href="erlang.html#atom_to_binary-2">atom_to_binary/2</a></li>
    <li title="atom_to_list-1"><a href="erlang.html#atom_to_list-1">atom_to_list/1</a></li>
    <li title="binary_part-2"><a href="erlang.html#binary_part-2">binary_part/2</a></li>
    <li title="binary_part-3"><a href="erlang.html#binary_part-3">binary_part/3</a></li>
    <li title="binary_to_atom-2"><a href="erlang.html#binary_to_atom-2">binary_to_atom/2</a></li>
    <li title="binary_to_existing_atom-2"><a href="erlang.html#binary_to_existing_atom-2">binary_to_existing_atom/2</a></li>
    <li title="binary_to_float-1"><a href="erlang.html#binary_to_float-1">binary_to_float/1</a></li>
    <li title="binary_to_integer-1"><a href="erlang.html#binary_to_integer-1">binary_to_integer/1</a></li>
    <li title="binary_to_integer-2"><a href="erlang.html#binary_to_integer-2">binary_to_integer/2</a></li>
    <li title="binary_to_list-1"><a href="erlang.html#binary_to_list-1">binary_to_list/1</a></li>
    <li title="binary_to_list-3"><a href="erlang.html#binary_to_list-3">binary_to_list/3</a></li>
    <li title="binary_to_term-1"><a href="erlang.html#binary_to_term-1">binary_to_term/1</a></li>
    <li title="binary_to_term-2"><a href="erlang.html#binary_to_term-2">binary_to_term/2</a></li>
    <li title="bit_size-1"><a href="erlang.html#bit_size-1">bit_size/1</a></li>
    <li title="bitstring_to_list-1"><a href="erlang.html#bitstring_to_list-1">bitstring_to_list/1</a></li>
    <li title="bump_reductions-1"><a href="erlang.html#bump_reductions-1">bump_reductions/1</a></li>
    <li title="byte_size-1"><a href="erlang.html#byte_size-1">byte_size/1</a></li>
    <li title="cancel_timer-1"><a href="erlang.html#cancel_timer-1">cancel_timer/1</a></li>
    <li title="cancel_timer-2"><a href="erlang.html#cancel_timer-2">cancel_timer/2</a></li>
    <li title="ceil-1"><a href="erlang.html#ceil-1">ceil/1</a></li>
    <li title="check_old_code-1"><a href="erlang.html#check_old_code-1">check_old_code/1</a></li>
    <li title="check_process_code-2"><a href="erlang.html#check_process_code-2">check_process_code/2</a></li>
    <li title="check_process_code-3"><a href="erlang.html#check_process_code-3">check_process_code/3</a></li>
    <li title="convert_time_unit-3"><a href="erlang.html#convert_time_unit-3">convert_time_unit/3</a></li>
    <li title="crc32-1"><a href="erlang.html#crc32-1">crc32/1</a></li>
    <li title="crc32-2"><a href="erlang.html#crc32-2">crc32/2</a></li>
    <li title="crc32_combine-3"><a href="erlang.html#crc32_combine-3">crc32_combine/3</a></li>
    <li title="date-0"><a href="erlang.html#date-0">date/0</a></li>
    <li title="decode_packet-3"><a href="erlang.html#decode_packet-3">decode_packet/3</a></li>
    <li title="delete_element-2"><a href="erlang.html#delete_element-2">delete_element/2</a></li>
    <li title="delete_module-1"><a href="erlang.html#delete_module-1">delete_module/1</a></li>
    <li title="demonitor-1"><a href="erlang.html#demonitor-1">demonitor/1</a></li>
    <li title="demonitor-2"><a href="erlang.html#demonitor-2">demonitor/2</a></li>
    <li title="disconnect_node-1"><a href="erlang.html#disconnect_node-1">disconnect_node/1</a></li>
    <li title="display-1"><a href="erlang.html#display-1">display/1</a></li>
    <li title="element-2"><a href="erlang.html#element-2">element/2</a></li>
    <li title="erase-0"><a href="erlang.html#erase-0">erase/0</a></li>
    <li title="erase-1"><a href="erlang.html#erase-1">erase/1</a></li>
    <li title="error-1"><a href="erlang.html#error-1">error/1</a></li>
    <li title="error-2"><a href="erlang.html#error-2">error/2</a></li>
    <li title="exit-1"><a href="erlang.html#exit-1">exit/1</a></li>
    <li title="exit-2"><a href="erlang.html#exit-2">exit/2</a></li>
    <li title="external_size-1"><a href="erlang.html#external_size-1">external_size/1</a></li>
    <li title="external_size-2"><a href="erlang.html#external_size-2">external_size/2</a></li>
    <li title="float-1"><a href="erlang.html#float-1">float/1</a></li>
    <li title="float_to_binary-1"><a href="erlang.html#float_to_binary-1">float_to_binary/1</a></li>
    <li title="float_to_binary-2"><a href="erlang.html#float_to_binary-2">float_to_binary/2</a></li>
    <li title="float_to_list-1"><a href="erlang.html#float_to_list-1">float_to_list/1</a></li>
    <li title="float_to_list-2"><a href="erlang.html#float_to_list-2">float_to_list/2</a></li>
    <li title="floor-1"><a href="erlang.html#floor-1">floor/1</a></li>
    <li title="fun_info-1"><a href="erlang.html#fun_info-1">fun_info/1</a></li>
    <li title="fun_info-2"><a href="erlang.html#fun_info-2">fun_info/2</a></li>
    <li title="fun_to_list-1"><a href="erlang.html#fun_to_list-1">fun_to_list/1</a></li>
    <li title="function_exported-3"><a href="erlang.html#function_exported-3">function_exported/3</a></li>
    <li title="garbage_collect-0"><a href="erlang.html#garbage_collect-0">garbage_collect/0</a></li>
    <li title="garbage_collect-1"><a href="erlang.html#garbage_collect-1">garbage_collect/1</a></li>
    <li title="garbage_collect-2"><a href="erlang.html#garbage_collect-2">garbage_collect/2</a></li>
    <li title="get-0"><a href="erlang.html#get-0">get/0</a></li>
    <li title="get-1"><a href="erlang.html#get-1">get/1</a></li>
    <li title="get_cookie-0"><a href="erlang.html#get_cookie-0">get_cookie/0</a></li>
    <li title="get_keys-0"><a href="erlang.html#get_keys-0">get_keys/0</a></li>
    <li title="get_keys-1"><a href="erlang.html#get_keys-1">get_keys/1</a></li>
    <li title="get_stacktrace-0"><a href="erlang.html#get_stacktrace-0">get_stacktrace/0</a></li>
    <li title="group_leader-0"><a href="erlang.html#group_leader-0">group_leader/0</a></li>
    <li title="group_leader-2"><a href="erlang.html#group_leader-2">group_leader/2</a></li>
    <li title="halt-0"><a href="erlang.html#halt-0">halt/0</a></li>
    <li title="halt-1"><a href="erlang.html#halt-1">halt/1</a></li>
    <li title="halt-2"><a href="erlang.html#halt-2">halt/2</a></li>
    <li title="hd-1"><a href="erlang.html#hd-1">hd/1</a></li>
    <li title="hibernate-3"><a href="erlang.html#hibernate-3">hibernate/3</a></li>
    <li title="insert_element-3"><a href="erlang.html#insert_element-3">insert_element/3</a></li>
    <li title="integer_to_binary-1"><a href="erlang.html#integer_to_binary-1">integer_to_binary/1</a></li>
    <li title="integer_to_binary-2"><a href="erlang.html#integer_to_binary-2">integer_to_binary/2</a></li>
    <li title="integer_to_list-1"><a href="erlang.html#integer_to_list-1">integer_to_list/1</a></li>
    <li title="integer_to_list-2"><a href="erlang.html#integer_to_list-2">integer_to_list/2</a></li>
    <li title="iolist_size-1"><a href="erlang.html#iolist_size-1">iolist_size/1</a></li>
    <li title="iolist_to_binary-1"><a href="erlang.html#iolist_to_binary-1">iolist_to_binary/1</a></li>
    <li title="iolist_to_iovec-1"><a href="erlang.html#iolist_to_iovec-1">iolist_to_iovec/1</a></li>
    <li title="is_alive-0"><a href="erlang.html#is_alive-0">is_alive/0</a></li>
    <li title="is_atom-1"><a href="erlang.html#is_atom-1">is_atom/1</a></li>
    <li title="is_binary-1"><a href="erlang.html#is_binary-1">is_binary/1</a></li>
    <li title="is_bitstring-1"><a href="erlang.html#is_bitstring-1">is_bitstring/1</a></li>
    <li title="is_boolean-1"><a href="erlang.html#is_boolean-1">is_boolean/1</a></li>
    <li title="is_builtin-3"><a href="erlang.html#is_builtin-3">is_builtin/3</a></li>
    <li title="is_float-1"><a href="erlang.html#is_float-1">is_float/1</a></li>
    <li title="is_function-1"><a href="erlang.html#is_function-1">is_function/1</a></li>
    <li title="is_function-2"><a href="erlang.html#is_function-2">is_function/2</a></li>
    <li title="is_integer-1"><a href="erlang.html#is_integer-1">is_integer/1</a></li>
    <li title="is_list-1"><a href="erlang.html#is_list-1">is_list/1</a></li>
    <li title="is_map-1"><a href="erlang.html#is_map-1">is_map/1</a></li>
    <li title="is_number-1"><a href="erlang.html#is_number-1">is_number/1</a></li>
    <li title="is_pid-1"><a href="erlang.html#is_pid-1">is_pid/1</a></li>
    <li title="is_port-1"><a href="erlang.html#is_port-1">is_port/1</a></li>
    <li title="is_process_alive-1"><a href="erlang.html#is_process_alive-1">is_process_alive/1</a></li>
    <li title="is_record-2"><a href="erlang.html#is_record-2">is_record/2</a></li>
    <li title="is_record-3"><a href="erlang.html#is_record-3">is_record/3</a></li>
    <li title="is_reference-1"><a href="erlang.html#is_reference-1">is_reference/1</a></li>
    <li title="is_tuple-1"><a href="erlang.html#is_tuple-1">is_tuple/1</a></li>
    <li title="length-1"><a href="erlang.html#length-1">length/1</a></li>
    <li title="link-1"><a href="erlang.html#link-1">link/1</a></li>
    <li title="list_to_atom-1"><a href="erlang.html#list_to_atom-1">list_to_atom/1</a></li>
    <li title="list_to_binary-1"><a href="erlang.html#list_to_binary-1">list_to_binary/1</a></li>
    <li title="list_to_bitstring-1"><a href="erlang.html#list_to_bitstring-1">list_to_bitstring/1</a></li>
    <li title="list_to_existing_atom-1"><a href="erlang.html#list_to_existing_atom-1">list_to_existing_atom/1</a></li>
    <li title="list_to_float-1"><a href="erlang.html#list_to_float-1">list_to_float/1</a></li>
    <li title="list_to_integer-1"><a href="erlang.html#list_to_integer-1">list_to_integer/1</a></li>
    <li title="list_to_integer-2"><a href="erlang.html#list_to_integer-2">list_to_integer/2</a></li>
    <li title="list_to_pid-1"><a href="erlang.html#list_to_pid-1">list_to_pid/1</a></li>
    <li title="list_to_port-1"><a href="erlang.html#list_to_port-1">list_to_port/1</a></li>
    <li title="list_to_ref-1"><a href="erlang.html#list_to_ref-1">list_to_ref/1</a></li>
    <li title="list_to_tuple-1"><a href="erlang.html#list_to_tuple-1">list_to_tuple/1</a></li>
    <li title="load_module-2"><a href="erlang.html#load_module-2">load_module/2</a></li>
    <li title="load_nif-2"><a href="erlang.html#load_nif-2">load_nif/2</a></li>
    <li title="loaded-0"><a href="erlang.html#loaded-0">loaded/0</a></li>
    <li title="localtime-0"><a href="erlang.html#localtime-0">localtime/0</a></li>
    <li title="localtime_to_universaltime-1"><a href="erlang.html#localtime_to_universaltime-1">localtime_to_universaltime/1</a></li>
    <li title="localtime_to_universaltime-2"><a href="erlang.html#localtime_to_universaltime-2">localtime_to_universaltime/2</a></li>
    <li title="make_ref-0"><a href="erlang.html#make_ref-0">make_ref/0</a></li>
    <li title="make_tuple-2"><a href="erlang.html#make_tuple-2">make_tuple/2</a></li>
    <li title="make_tuple-3"><a href="erlang.html#make_tuple-3">make_tuple/3</a></li>
    <li title="map_size-1"><a href="erlang.html#map_size-1">map_size/1</a></li>
    <li title="match_spec_test-3"><a href="erlang.html#match_spec_test-3">match_spec_test/3</a></li>
    <li title="max-2"><a href="erlang.html#max-2">max/2</a></li>
    <li title="md5-1"><a href="erlang.html#md5-1">md5/1</a></li>
    <li title="md5_final-1"><a href="erlang.html#md5_final-1">md5_final/1</a></li>
    <li title="md5_init-0"><a href="erlang.html#md5_init-0">md5_init/0</a></li>
    <li title="md5_update-2"><a href="erlang.html#md5_update-2">md5_update/2</a></li>
    <li title="memory-0"><a href="erlang.html#memory-0">memory/0</a></li>
    <li title="memory-1"><a href="erlang.html#memory-1">memory/1</a></li>
    <li title="min-2"><a href="erlang.html#min-2">min/2</a></li>
    <li title="module_loaded-1"><a href="erlang.html#module_loaded-1">module_loaded/1</a></li>
    <li title="monitor-2"><a href="erlang.html#monitor-2">monitor/2</a></li>
    <li title="monitor_node-2"><a href="erlang.html#monitor_node-2">monitor_node/2</a></li>
    <li title="monitor_node-3"><a href="erlang.html#monitor_node-3">monitor_node/3</a></li>
    <li title="monotonic_time-0"><a href="erlang.html#monotonic_time-0">monotonic_time/0</a></li>
    <li title="monotonic_time-1"><a href="erlang.html#monotonic_time-1">monotonic_time/1</a></li>
    <li title="nif_error-1"><a href="erlang.html#nif_error-1">nif_error/1</a></li>
    <li title="nif_error-2"><a href="erlang.html#nif_error-2">nif_error/2</a></li>
    <li title="node-0"><a href="erlang.html#node-0">node/0</a></li>
    <li title="node-1"><a href="erlang.html#node-1">node/1</a></li>
    <li title="nodes-0"><a href="erlang.html#nodes-0">nodes/0</a></li>
    <li title="nodes-1"><a href="erlang.html#nodes-1">nodes/1</a></li>
    <li title="now-0"><a href="erlang.html#now-0">now/0</a></li>
    <li title="open_port-2"><a href="erlang.html#open_port-2">open_port/2</a></li>
    <li title="phash-2"><a href="erlang.html#phash-2">phash/2</a></li>
    <li title="phash2-1"><a href="erlang.html#phash2-1">phash2/1</a></li>
    <li title="phash2-2"><a href="erlang.html#phash2-2">phash2/2</a></li>
    <li title="pid_to_list-1"><a href="erlang.html#pid_to_list-1">pid_to_list/1</a></li>
    <li title="port_call-3"><a href="erlang.html#port_call-3">port_call/3</a></li>
    <li title="port_close-1"><a href="erlang.html#port_close-1">port_close/1</a></li>
    <li title="port_command-2"><a href="erlang.html#port_command-2">port_command/2</a></li>
    <li title="port_command-3"><a href="erlang.html#port_command-3">port_command/3</a></li>
    <li title="port_connect-2"><a href="erlang.html#port_connect-2">port_connect/2</a></li>
    <li title="port_control-3"><a href="erlang.html#port_control-3">port_control/3</a></li>
    <li title="port_info-1"><a href="erlang.html#port_info-1">port_info/1</a></li>
    <li title="port_info-2"><a href="erlang.html#port_info-2">port_info/2</a></li>
    <li title="port_to_list-1"><a href="erlang.html#port_to_list-1">port_to_list/1</a></li>
    <li title="ports-0"><a href="erlang.html#ports-0">ports/0</a></li>
    <li title="pre_loaded-0"><a href="erlang.html#pre_loaded-0">pre_loaded/0</a></li>
    <li title="process_display-2"><a href="erlang.html#process_display-2">process_display/2</a></li>
    <li title="process_flag-2"><a href="erlang.html#process_flag-2">process_flag/2</a></li>
    <li title="process_flag-3"><a href="erlang.html#process_flag-3">process_flag/3</a></li>
    <li title="process_info-1"><a href="erlang.html#process_info-1">process_info/1</a></li>
    <li title="process_info-2"><a href="erlang.html#process_info-2">process_info/2</a></li>
    <li title="processes-0"><a href="erlang.html#processes-0">processes/0</a></li>
    <li title="purge_module-1"><a href="erlang.html#purge_module-1">purge_module/1</a></li>
    <li title="put-2"><a href="erlang.html#put-2">put/2</a></li>
    <li title="raise-3"><a href="erlang.html#raise-3">raise/3</a></li>
    <li title="read_timer-1"><a href="erlang.html#read_timer-1">read_timer/1</a></li>
    <li title="read_timer-2"><a href="erlang.html#read_timer-2">read_timer/2</a></li>
    <li title="ref_to_list-1"><a href="erlang.html#ref_to_list-1">ref_to_list/1</a></li>
    <li title="register-2"><a href="erlang.html#register-2">register/2</a></li>
    <li title="registered-0"><a href="erlang.html#registered-0">registered/0</a></li>
    <li title="resume_process-1"><a href="erlang.html#resume_process-1">resume_process/1</a></li>
    <li title="round-1"><a href="erlang.html#round-1">round/1</a></li>
    <li title="self-0"><a href="erlang.html#self-0">self/0</a></li>
    <li title="send-2"><a href="erlang.html#send-2">send/2</a></li>
    <li title="send-3"><a href="erlang.html#send-3">send/3</a></li>
    <li title="send_after-3"><a href="erlang.html#send_after-3">send_after/3</a></li>
    <li title="send_after-4"><a href="erlang.html#send_after-4">send_after/4</a></li>
    <li title="send_nosuspend-2"><a href="erlang.html#send_nosuspend-2">send_nosuspend/2</a></li>
    <li title="send_nosuspend-3"><a href="erlang.html#send_nosuspend-3">send_nosuspend/3</a></li>
    <li title="set_cookie-2"><a href="erlang.html#set_cookie-2">set_cookie/2</a></li>
    <li title="setelement-3"><a href="erlang.html#setelement-3">setelement/3</a></li>
    <li title="size-1"><a href="erlang.html#size-1">size/1</a></li>
    <li title="spawn-1"><a href="erlang.html#spawn-1">spawn/1</a></li>
    <li title="spawn-2"><a href="erlang.html#spawn-2">spawn/2</a></li>
    <li title="spawn-3"><a href="erlang.html#spawn-3">spawn/3</a></li>
    <li title="spawn-4"><a href="erlang.html#spawn-4">spawn/4</a></li>
    <li title="spawn_link-1"><a href="erlang.html#spawn_link-1">spawn_link/1</a></li>
    <li title="spawn_link-2"><a href="erlang.html#spawn_link-2">spawn_link/2</a></li>
    <li title="spawn_link-3"><a href="erlang.html#spawn_link-3">spawn_link/3</a></li>
    <li title="spawn_link-4"><a href="erlang.html#spawn_link-4">spawn_link/4</a></li>
    <li title="spawn_monitor-1"><a href="erlang.html#spawn_monitor-1">spawn_monitor/1</a></li>
    <li title="spawn_monitor-3"><a href="erlang.html#spawn_monitor-3">spawn_monitor/3</a></li>
    <li title="spawn_opt-2"><a href="erlang.html#spawn_opt-2">spawn_opt/2</a></li>
    <li title="spawn_opt-3"><a href="erlang.html#spawn_opt-3">spawn_opt/3</a></li>
    <li title="spawn_opt-4"><a href="erlang.html#spawn_opt-4">spawn_opt/4</a></li>
    <li title="spawn_opt-5"><a href="erlang.html#spawn_opt-5">spawn_opt/5</a></li>
    <li title="split_binary-2"><a href="erlang.html#split_binary-2">split_binary/2</a></li>
    <li title="start_timer-3"><a href="erlang.html#start_timer-3">start_timer/3</a></li>
    <li title="start_timer-4"><a href="erlang.html#start_timer-4">start_timer/4</a></li>
    <li title="statistics-1"><a href="erlang.html#statistics-1">statistics/1</a></li>
    <li title="suspend_process-1"><a href="erlang.html#suspend_process-1">suspend_process/1</a></li>
    <li title="suspend_process-2"><a href="erlang.html#suspend_process-2">suspend_process/2</a></li>
    <li title="system_flag-2"><a href="erlang.html#system_flag-2">system_flag/2</a></li>
    <li title="system_info-1"><a href="erlang.html#system_info-1">system_info/1</a></li>
    <li title="system_monitor-0"><a href="erlang.html#system_monitor-0">system_monitor/0</a></li>
    <li title="system_monitor-1"><a href="erlang.html#system_monitor-1">system_monitor/1</a></li>
    <li title="system_monitor-2"><a href="erlang.html#system_monitor-2">system_monitor/2</a></li>
    <li title="system_profile-0"><a href="erlang.html#system_profile-0">system_profile/0</a></li>
    <li title="system_profile-2"><a href="erlang.html#system_profile-2">system_profile/2</a></li>
    <li title="system_time-0"><a href="erlang.html#system_time-0">system_time/0</a></li>
    <li title="system_time-1"><a href="erlang.html#system_time-1">system_time/1</a></li>
    <li title="term_to_binary-1"><a href="erlang.html#term_to_binary-1">term_to_binary/1</a></li>
    <li title="term_to_binary-2"><a href="erlang.html#term_to_binary-2">term_to_binary/2</a></li>
    <li title="throw-1"><a href="erlang.html#throw-1">throw/1</a></li>
    <li title="time-0"><a href="erlang.html#time-0">time/0</a></li>
    <li title="time_offset-0"><a href="erlang.html#time_offset-0">time_offset/0</a></li>
    <li title="time_offset-1"><a href="erlang.html#time_offset-1">time_offset/1</a></li>
    <li title="timestamp-0"><a href="erlang.html#timestamp-0">timestamp/0</a></li>
    <li title="tl-1"><a href="erlang.html#tl-1">tl/1</a></li>
    <li title="trace-3"><a href="erlang.html#trace-3">trace/3</a></li>
    <li title="trace_delivered-1"><a href="erlang.html#trace_delivered-1">trace_delivered/1</a></li>
    <li title="trace_info-2"><a href="erlang.html#trace_info-2">trace_info/2</a></li>
    <li title="trace_pattern-2"><a href="erlang.html#trace_pattern-2">trace_pattern/2</a></li>
    <li title="trace_pattern-3"><a href="erlang.html#trace_pattern-3">trace_pattern/3</a></li>
    <li title="trunc-1"><a href="erlang.html#trunc-1">trunc/1</a></li>
    <li title="tuple_size-1"><a href="erlang.html#tuple_size-1">tuple_size/1</a></li>
    <li title="tuple_to_list-1"><a href="erlang.html#tuple_to_list-1">tuple_to_list/1</a></li>
    <li title="unique_integer-0"><a href="erlang.html#unique_integer-0">unique_integer/0</a></li>
    <li title="unique_integer-1"><a href="erlang.html#unique_integer-1">unique_integer/1</a></li>
    <li title="universaltime-0"><a href="erlang.html#universaltime-0">universaltime/0</a></li>
    <li title="universaltime_to_localtime-1"><a href="erlang.html#universaltime_to_localtime-1">universaltime_to_localtime/1</a></li>
    <li title="unlink-1"><a href="erlang.html#unlink-1">unlink/1</a></li>
    <li title="unregister-1"><a href="erlang.html#unregister-1">unregister/1</a></li>
    <li title="whereis-1"><a href="erlang.html#whereis-1">whereis/1</a></li>
    <li title="yield-0"><a href="erlang.html#yield-0">yield/0</a></li>
    </ul>
</li>
<li id="no" title="init " expanded="false">init<ul>
<li><a href="init.html">
                  Top of manual page
                </a></li>
    <li title="boot-1"><a href="init.html#boot-1">boot/1</a></li>
    <li title="get_argument-1"><a href="init.html#get_argument-1">get_argument/1</a></li>
    <li title="get_arguments-0"><a href="init.html#get_arguments-0">get_arguments/0</a></li>
    <li title="get_plain_arguments-0"><a href="init.html#get_plain_arguments-0">get_plain_arguments/0</a></li>
    <li title="get_status-0"><a href="init.html#get_status-0">get_status/0</a></li>
    <li title="reboot-0"><a href="init.html#reboot-0">reboot/0</a></li>
    <li title="restart-0"><a href="init.html#restart-0">restart/0</a></li>
    <li title="script_id-0"><a href="init.html#script_id-0">script_id/0</a></li>
    <li title="stop-0"><a href="init.html#stop-0">stop/0</a></li>
    <li title="stop-1"><a href="init.html#stop-1">stop/1</a></li>
    </ul>
</li>
<li id="no" title="zlib " expanded="false">zlib<ul>
<li><a href="zlib.html">
                  Top of manual page
                </a></li>
    <li title="adler32-2"><a href="zlib.html#adler32-2">adler32/2</a></li>
    <li title="adler32-3"><a href="zlib.html#adler32-3">adler32/3</a></li>
    <li title="adler32_combine-4"><a href="zlib.html#adler32_combine-4">adler32_combine/4</a></li>
    <li title="close-1"><a href="zlib.html#close-1">close/1</a></li>
    <li title="compress-1"><a href="zlib.html#compress-1">compress/1</a></li>
    <li title="crc32-1"><a href="zlib.html#crc32-1">crc32/1</a></li>
    <li title="crc32-2"><a href="zlib.html#crc32-2">crc32/2</a></li>
    <li title="crc32-3"><a href="zlib.html#crc32-3">crc32/3</a></li>
    <li title="crc32_combine-4"><a href="zlib.html#crc32_combine-4">crc32_combine/4</a></li>
    <li title="deflate-2"><a href="zlib.html#deflate-2">deflate/2</a></li>
    <li title="deflate-3"><a href="zlib.html#deflate-3">deflate/3</a></li>
    <li title="deflateEnd-1"><a href="zlib.html#deflateEnd-1">deflateEnd/1</a></li>
    <li title="deflateInit-1"><a href="zlib.html#deflateInit-1">deflateInit/1</a></li>
    <li title="deflateInit-2"><a href="zlib.html#deflateInit-2">deflateInit/2</a></li>
    <li title="deflateInit-6"><a href="zlib.html#deflateInit-6">deflateInit/6</a></li>
    <li title="deflateParams-3"><a href="zlib.html#deflateParams-3">deflateParams/3</a></li>
    <li title="deflateReset-1"><a href="zlib.html#deflateReset-1">deflateReset/1</a></li>
    <li title="deflateSetDictionary-2"><a href="zlib.html#deflateSetDictionary-2">deflateSetDictionary/2</a></li>
    <li title="getBufSize-1"><a href="zlib.html#getBufSize-1">getBufSize/1</a></li>
    <li title="gunzip-1"><a href="zlib.html#gunzip-1">gunzip/1</a></li>
    <li title="gzip-1"><a href="zlib.html#gzip-1">gzip/1</a></li>
    <li title="inflate-2"><a href="zlib.html#inflate-2">inflate/2</a></li>
    <li title="inflate-3"><a href="zlib.html#inflate-3">inflate/3</a></li>
    <li title="inflateChunk-1"><a href="zlib.html#inflateChunk-1">inflateChunk/1</a></li>
    <li title="inflateChunk-2"><a href="zlib.html#inflateChunk-2">inflateChunk/2</a></li>
    <li title="inflateEnd-1"><a href="zlib.html#inflateEnd-1">inflateEnd/1</a></li>
    <li title="inflateGetDictionary-1"><a href="zlib.html#inflateGetDictionary-1">inflateGetDictionary/1</a></li>
    <li title="inflateInit-1"><a href="zlib.html#inflateInit-1">inflateInit/1</a></li>
    <li title="inflateInit-2"><a href="zlib.html#inflateInit-2">inflateInit/2</a></li>
    <li title="inflateReset-1"><a href="zlib.html#inflateReset-1">inflateReset/1</a></li>
    <li title="inflateSetDictionary-2"><a href="zlib.html#inflateSetDictionary-2">inflateSetDictionary/2</a></li>
    <li title="open-0"><a href="zlib.html#open-0">open/0</a></li>
    <li title="safeInflate-2"><a href="zlib.html#safeInflate-2">safeInflate/2</a></li>
    <li title="setBufSize-2"><a href="zlib.html#setBufSize-2">setBufSize/2</a></li>
    <li title="set_controlling_process-2"><a href="zlib.html#set_controlling_process-2">set_controlling_process/2</a></li>
    <li title="uncompress-1"><a href="zlib.html#uncompress-1">uncompress/1</a></li>
    <li title="unzip-1"><a href="zlib.html#unzip-1">unzip/1</a></li>
    <li title="zip-1"><a href="zlib.html#zip-1">zip/1</a></li>
    </ul>
</li>
<li title="epmd"><a href="epmd.html">epmd</a></li>
<li title="erl"><a href="erl.html">erl</a></li>
<li title="erlc"><a href="erlc.html">erlc</a></li>
<li title="werl"><a href="werl.html">werl</a></li>
<li title="escript"><a href="escript.html">escript</a></li>
<li title="erlsrv"><a href="erlsrv.html">erlsrv</a></li>
<li title="start_erl"><a href="start_erl.html">start_erl</a></li>
<li title="run_erl"><a href="run_erl.html">run_erl</a></li>
<li title="start"><a href="start.html">start</a></li>
<li id="loadscrollpos" title="erl_driver " expanded="true">erl_driver<ul>
<li><a href="erl_driver.html">
                  Top of manual page
                </a></li>
    <li title="add_driver_entry"><a href="erl_driver.html#add_driver_entry">add_driver_entry()
                </a></li>
<li title="driver_alloc"><a href="erl_driver.html#driver_alloc">driver_alloc()
                </a></li>
<li title="driver_alloc_binary"><a href="erl_driver.html#driver_alloc_binary">driver_alloc_binary()
                </a></li>
<li title="driver_async"><a href="erl_driver.html#driver_async">driver_async()
                </a></li>
<li title="driver_async_port_key"><a href="erl_driver.html#driver_async_port_key">driver_async_port_key()
                </a></li>
<li title="driver_binary_dec_refc"><a href="erl_driver.html#driver_binary_dec_refc">driver_binary_dec_refc()
                </a></li>
<li title="driver_binary_get_refc"><a href="erl_driver.html#driver_binary_get_refc">driver_binary_get_refc()
                </a></li>
<li title="driver_binary_inc_refc"><a href="erl_driver.html#driver_binary_inc_refc">driver_binary_inc_refc()
                </a></li>
<li title="driver_caller"><a href="erl_driver.html#driver_caller">driver_caller()
                </a></li>
<li title="driver_cancel_timer"><a href="erl_driver.html#driver_cancel_timer">driver_cancel_timer()
                </a></li>
<li title="driver_compare_monitors"><a href="erl_driver.html#driver_compare_monitors">driver_compare_monitors()
                </a></li>
<li title="driver_connected"><a href="erl_driver.html#driver_connected">driver_connected()
                </a></li>
<li title="driver_create_port"><a href="erl_driver.html#driver_create_port">driver_create_port()
                </a></li>
<li title="driver_demonitor_process"><a href="erl_driver.html#driver_demonitor_process">driver_demonitor_process()
                </a></li>
<li title="driver_deq"><a href="erl_driver.html#driver_deq">driver_deq()
                </a></li>
<li title="driver_enq"><a href="erl_driver.html#driver_enq">driver_enq()
                </a></li>
<li title="driver_enq_bin"><a href="erl_driver.html#driver_enq_bin">driver_enq_bin()
                </a></li>
<li title="driver_enqv"><a href="erl_driver.html#driver_enqv">driver_enqv()
                </a></li>
<li title="driver_failure"><a href="erl_driver.html#driver_failure">driver_failure()
                </a></li>
<li title="driver_failure_atom"><a href="erl_driver.html#driver_failure_atom">driver_failure_atom()
                </a></li>
<li title="driver_failure_eof"><a href="erl_driver.html#driver_failure_eof">driver_failure_eof()
                </a></li>
<li title="driver_failure_posix"><a href="erl_driver.html#driver_failure_posix">driver_failure_posix()
                </a></li>
<li title="driver_free"><a href="erl_driver.html#driver_free">driver_free()
                </a></li>
<li title="driver_free_binary"><a href="erl_driver.html#driver_free_binary">driver_free_binary()
                </a></li>
<li title="driver_get_monitored_process"><a href="erl_driver.html#driver_get_monitored_process">driver_get_monitored_process()
                </a></li>
<li title="driver_get_now"><a href="erl_driver.html#driver_get_now">driver_get_now()
                </a></li>
<li title="driver_lock_driver"><a href="erl_driver.html#driver_lock_driver">driver_lock_driver()
                </a></li>
<li title="driver_mk_atom"><a href="erl_driver.html#driver_mk_atom">driver_mk_atom()
                </a></li>
<li title="driver_mk_port"><a href="erl_driver.html#driver_mk_port">driver_mk_port()
                </a></li>
<li title="driver_monitor_process"><a href="erl_driver.html#driver_monitor_process">driver_monitor_process()
                </a></li>
<li title="driver_output"><a href="erl_driver.html#driver_output">driver_output()
                </a></li>
<li title="driver_output2"><a href="erl_driver.html#driver_output2">driver_output2()
                </a></li>
<li title="driver_output_binary"><a href="erl_driver.html#driver_output_binary">driver_output_binary()
                </a></li>
<li title="driver_output_term"><a href="erl_driver.html#driver_output_term">driver_output_term()
                </a></li>
<li title="driver_outputv"><a href="erl_driver.html#driver_outputv">driver_outputv()
                </a></li>
<li title="driver_pdl_create"><a href="erl_driver.html#driver_pdl_create">driver_pdl_create()
                </a></li>
<li title="driver_pdl_dec_refc"><a href="erl_driver.html#driver_pdl_dec_refc">driver_pdl_dec_refc()
                </a></li>
<li title="driver_pdl_get_refc"><a href="erl_driver.html#driver_pdl_get_refc">driver_pdl_get_refc()
                </a></li>
<li title="driver_pdl_inc_refc"><a href="erl_driver.html#driver_pdl_inc_refc">driver_pdl_inc_refc()
                </a></li>
<li title="driver_pdl_lock"><a href="erl_driver.html#driver_pdl_lock">driver_pdl_lock()
                </a></li>
<li title="driver_pdl_unlock"><a href="erl_driver.html#driver_pdl_unlock">driver_pdl_unlock()
                </a></li>
<li title="driver_peekq"><a href="erl_driver.html#driver_peekq">driver_peekq()
                </a></li>
<li title="driver_peekqv"><a href="erl_driver.html#driver_peekqv">driver_peekqv()
                </a></li>
<li title="driver_pushq"><a href="erl_driver.html#driver_pushq">driver_pushq()
                </a></li>
<li title="driver_pushq_bin"><a href="erl_driver.html#driver_pushq_bin">driver_pushq_bin()
                </a></li>
<li title="driver_pushqv"><a href="erl_driver.html#driver_pushqv">driver_pushqv()
                </a></li>
<li title="driver_read_timer"><a href="erl_driver.html#driver_read_timer">driver_read_timer()
                </a></li>
<li title="driver_realloc"><a href="erl_driver.html#driver_realloc">driver_realloc()
                </a></li>
<li title="driver_realloc_binary"><a href="erl_driver.html#driver_realloc_binary">driver_realloc_binary()
                </a></li>
<li title="driver_select"><a href="erl_driver.html#driver_select">driver_select()
                </a></li>
<li title="driver_send_term"><a href="erl_driver.html#driver_send_term">driver_send_term()
                </a></li>
<li title="driver_set_timer"><a href="erl_driver.html#driver_set_timer">driver_set_timer()
                </a></li>
<li title="driver_sizeq"><a href="erl_driver.html#driver_sizeq">driver_sizeq()
                </a></li>
<li title="driver_system_info"><a href="erl_driver.html#driver_system_info">driver_system_info()
                </a></li>
<li title="driver_vec_to_buf"><a href="erl_driver.html#driver_vec_to_buf">driver_vec_to_buf()
                </a></li>
<li title="erl_drv_busy_msgq_limits"><a href="erl_driver.html#erl_drv_busy_msgq_limits">erl_drv_busy_msgq_limits()
                </a></li>
<li title="erl_drv_cond_broadcast"><a href="erl_driver.html#erl_drv_cond_broadcast">erl_drv_cond_broadcast()
                </a></li>
<li title="erl_drv_cond_create"><a href="erl_driver.html#erl_drv_cond_create">erl_drv_cond_create()
                </a></li>
<li title="erl_drv_cond_destroy"><a href="erl_driver.html#erl_drv_cond_destroy">erl_drv_cond_destroy()
                </a></li>
<li title="erl_drv_cond_name"><a href="erl_driver.html#erl_drv_cond_name">erl_drv_cond_name()
                </a></li>
<li title="erl_drv_cond_signal"><a href="erl_driver.html#erl_drv_cond_signal">erl_drv_cond_signal()
                </a></li>
<li title="erl_drv_cond_wait"><a href="erl_driver.html#erl_drv_cond_wait">erl_drv_cond_wait()
                </a></li>
<li title="erl_drv_consume_timeslice"><a href="erl_driver.html#erl_drv_consume_timeslice">erl_drv_consume_timeslice()
                </a></li>
<li title="erl_drv_convert_time_unit"><a href="erl_driver.html#erl_drv_convert_time_unit">erl_drv_convert_time_unit()
                </a></li>
<li title="erl_drv_equal_tids"><a href="erl_driver.html#erl_drv_equal_tids">erl_drv_equal_tids()
                </a></li>
<li title="erl_drv_getenv"><a href="erl_driver.html#erl_drv_getenv">erl_drv_getenv()
                </a></li>
<li title="erl_drv_init_ack"><a href="erl_driver.html#erl_drv_init_ack">erl_drv_init_ack()
                </a></li>
<li title="erl_drv_monotonic_time"><a href="erl_driver.html#erl_drv_monotonic_time">erl_drv_monotonic_time()
                </a></li>
<li title="erl_drv_mutex_create"><a href="erl_driver.html#erl_drv_mutex_create">erl_drv_mutex_create()
                </a></li>
<li title="erl_drv_mutex_destroy"><a href="erl_driver.html#erl_drv_mutex_destroy">erl_drv_mutex_destroy()
                </a></li>
<li title="erl_drv_mutex_lock"><a href="erl_driver.html#erl_drv_mutex_lock">erl_drv_mutex_lock()
                </a></li>
<li title="erl_drv_mutex_name"><a href="erl_driver.html#erl_drv_mutex_name">erl_drv_mutex_name()
                </a></li>
<li title="erl_drv_mutex_trylock"><a href="erl_driver.html#erl_drv_mutex_trylock">erl_drv_mutex_trylock()
                </a></li>
<li title="erl_drv_mutex_unlock"><a href="erl_driver.html#erl_drv_mutex_unlock">erl_drv_mutex_unlock()
                </a></li>
<li title="erl_drv_output_term"><a href="erl_driver.html#erl_drv_output_term">erl_drv_output_term()
                </a></li>
<li title="erl_drv_putenv"><a href="erl_driver.html#erl_drv_putenv">erl_drv_putenv()
                </a></li>
<li title="erl_drv_rwlock_create"><a href="erl_driver.html#erl_drv_rwlock_create">erl_drv_rwlock_create()
                </a></li>
<li title="erl_drv_rwlock_destroy"><a href="erl_driver.html#erl_drv_rwlock_destroy">erl_drv_rwlock_destroy()
                </a></li>
<li title="erl_drv_rwlock_name"><a href="erl_driver.html#erl_drv_rwlock_name">erl_drv_rwlock_name()
                </a></li>
<li title="erl_drv_rwlock_rlock"><a href="erl_driver.html#erl_drv_rwlock_rlock">erl_drv_rwlock_rlock()
                </a></li>
<li title="erl_drv_rwlock_runlock"><a href="erl_driver.html#erl_drv_rwlock_runlock">erl_drv_rwlock_runlock()
                </a></li>
<li title="erl_drv_rwlock_rwlock"><a href="erl_driver.html#erl_drv_rwlock_rwlock">erl_drv_rwlock_rwlock()
                </a></li>
<li title="erl_drv_rwlock_rwunlock"><a href="erl_driver.html#erl_drv_rwlock_rwunlock">erl_drv_rwlock_rwunlock()
                </a></li>
<li title="erl_drv_rwlock_tryrlock"><a href="erl_driver.html#erl_drv_rwlock_tryrlock">erl_drv_rwlock_tryrlock()
                </a></li>
<li title="erl_drv_rwlock_tryrwlock"><a href="erl_driver.html#erl_drv_rwlock_tryrwlock">erl_drv_rwlock_tryrwlock()
                </a></li>
<li title="erl_drv_send_term"><a href="erl_driver.html#erl_drv_send_term">erl_drv_send_term()
                </a></li>
<li title="erl_drv_set_os_pid"><a href="erl_driver.html#erl_drv_set_os_pid">erl_drv_set_os_pid()
                </a></li>
<li title="erl_drv_thread_create"><a href="erl_driver.html#erl_drv_thread_create">erl_drv_thread_create()
                </a></li>
<li title="erl_drv_thread_exit"><a href="erl_driver.html#erl_drv_thread_exit">erl_drv_thread_exit()
                </a></li>
<li title="erl_drv_thread_join"><a href="erl_driver.html#erl_drv_thread_join">erl_drv_thread_join()
                </a></li>
<li title="erl_drv_thread_name"><a href="erl_driver.html#erl_drv_thread_name">erl_drv_thread_name()
                </a></li>
<li title="erl_drv_thread_opts_create"><a href="erl_driver.html#erl_drv_thread_opts_create">erl_drv_thread_opts_create()
                </a></li>
<li title="erl_drv_thread_opts_destroy"><a href="erl_driver.html#erl_drv_thread_opts_destroy">erl_drv_thread_opts_destroy()
                </a></li>
<li title="erl_drv_thread_self"><a href="erl_driver.html#erl_drv_thread_self">erl_drv_thread_self()
                </a></li>
<li title="erl_drv_time_offset"><a href="erl_driver.html#erl_drv_time_offset">erl_drv_time_offset()
                </a></li>
<li title="erl_drv_tsd_get"><a href="erl_driver.html#erl_drv_tsd_get">erl_drv_tsd_get()
                </a></li>
<li title="erl_drv_tsd_key_create"><a href="erl_driver.html#erl_drv_tsd_key_create">erl_drv_tsd_key_create()
                </a></li>
<li title="erl_drv_tsd_key_destroy"><a href="erl_driver.html#erl_drv_tsd_key_destroy">erl_drv_tsd_key_destroy()
                </a></li>
<li title="erl_drv_tsd_set"><a href="erl_driver.html#erl_drv_tsd_set">erl_drv_tsd_set()
                </a></li>
<li title="erl_errno_id"><a href="erl_driver.html#erl_errno_id">erl_errno_id()
                </a></li>
<li title="remove_driver_entry"><a href="erl_driver.html#remove_driver_entry">remove_driver_entry()
                </a></li>
<li title="set_busy_port"><a href="erl_driver.html#set_busy_port">set_busy_port()
                </a></li>
<li title="set_port_control_flags"><a href="erl_driver.html#set_port_control_flags">set_port_control_flags()
                </a></li>
</ul>
</li>
<li title="driver_entry"><a href="driver_entry.html">driver_entry</a></li>
<li title="erts_alloc"><a href="erts_alloc.html">erts_alloc</a></li>
<li id="no" title="erl_nif " expanded="false">erl_nif<ul>
<li><a href="erl_nif.html">
                  Top of manual page
                </a></li>
    <li title="enif_alloc"><a href="erl_nif.html#enif_alloc">enif_alloc()
                </a></li>
<li title="enif_alloc_binary"><a href="erl_nif.html#enif_alloc_binary">enif_alloc_binary()
                </a></li>
<li title="enif_alloc_env"><a href="erl_nif.html#enif_alloc_env">enif_alloc_env()
                </a></li>
<li title="enif_alloc_resource"><a href="erl_nif.html#enif_alloc_resource">enif_alloc_resource()
                </a></li>
<li title="enif_binary_to_term"><a href="erl_nif.html#enif_binary_to_term">enif_binary_to_term()
                </a></li>
<li title="enif_clear_env"><a href="erl_nif.html#enif_clear_env">enif_clear_env()
                </a></li>
<li title="enif_compare"><a href="erl_nif.html#enif_compare">enif_compare()
                </a></li>
<li title="enif_compare_monitors"><a href="erl_nif.html#enif_compare_monitors">enif_compare_monitors()
                </a></li>
<li title="enif_cond_broadcast"><a href="erl_nif.html#enif_cond_broadcast">enif_cond_broadcast()
                </a></li>
<li title="enif_cond_create"><a href="erl_nif.html#enif_cond_create">enif_cond_create()
                </a></li>
<li title="enif_cond_destroy"><a href="erl_nif.html#enif_cond_destroy">enif_cond_destroy()
                </a></li>
<li title="enif_cond_signal"><a href="erl_nif.html#enif_cond_signal">enif_cond_signal()
                </a></li>
<li title="enif_cond_wait"><a href="erl_nif.html#enif_cond_wait">enif_cond_wait()
                </a></li>
<li title="enif_consume_timeslice"><a href="erl_nif.html#enif_consume_timeslice">enif_consume_timeslice()
                </a></li>
<li title="enif_convert_time_unit"><a href="erl_nif.html#enif_convert_time_unit">enif_convert_time_unit()
                </a></li>
<li title="enif_cpu_time"><a href="erl_nif.html#enif_cpu_time">enif_cpu_time()
                </a></li>
<li title="enif_demonitor_process"><a href="erl_nif.html#enif_demonitor_process">enif_demonitor_process()
                </a></li>
<li title="enif_equal_tids"><a href="erl_nif.html#enif_equal_tids">enif_equal_tids()
                </a></li>
<li title="enif_free"><a href="erl_nif.html#enif_free">enif_free()
                </a></li>
<li title="enif_free_env"><a href="erl_nif.html#enif_free_env">enif_free_env()
                </a></li>
<li title="enif_free_iovec"><a href="erl_nif.html#enif_free_iovec">enif_free_iovec()
                </a></li>
<li title="enif_get_atom"><a href="erl_nif.html#enif_get_atom">enif_get_atom()
                </a></li>
<li title="enif_get_atom_length"><a href="erl_nif.html#enif_get_atom_length">enif_get_atom_length()
                </a></li>
<li title="enif_get_double"><a href="erl_nif.html#enif_get_double">enif_get_double()
                </a></li>
<li title="enif_get_int"><a href="erl_nif.html#enif_get_int">enif_get_int()
                </a></li>
<li title="enif_get_int64"><a href="erl_nif.html#enif_get_int64">enif_get_int64()
                </a></li>
<li title="enif_get_list_cell"><a href="erl_nif.html#enif_get_list_cell">enif_get_list_cell()
                </a></li>
<li title="enif_get_list_length"><a href="erl_nif.html#enif_get_list_length">enif_get_list_length()
                </a></li>
<li title="enif_get_local_pid"><a href="erl_nif.html#enif_get_local_pid">enif_get_local_pid()
                </a></li>
<li title="enif_get_local_port"><a href="erl_nif.html#enif_get_local_port">enif_get_local_port()
                </a></li>
<li title="enif_get_long"><a href="erl_nif.html#enif_get_long">enif_get_long()
                </a></li>
<li title="enif_get_map_size"><a href="erl_nif.html#enif_get_map_size">enif_get_map_size()
                </a></li>
<li title="enif_get_map_value"><a href="erl_nif.html#enif_get_map_value">enif_get_map_value()
                </a></li>
<li title="enif_get_resource"><a href="erl_nif.html#enif_get_resource">enif_get_resource()
                </a></li>
<li title="enif_get_string"><a href="erl_nif.html#enif_get_string">enif_get_string()
                </a></li>
<li title="enif_get_tuple"><a href="erl_nif.html#enif_get_tuple">enif_get_tuple()
                </a></li>
<li title="enif_get_uint"><a href="erl_nif.html#enif_get_uint">enif_get_uint()
                </a></li>
<li title="enif_get_uint64"><a href="erl_nif.html#enif_get_uint64">enif_get_uint64()
                </a></li>
<li title="enif_get_ulong"><a href="erl_nif.html#enif_get_ulong">enif_get_ulong()
                </a></li>
<li title="enif_getenv"><a href="erl_nif.html#enif_getenv">enif_getenv()
                </a></li>
<li title="enif_has_pending_exception"><a href="erl_nif.html#enif_has_pending_exception">enif_has_pending_exception()
                </a></li>
<li title="enif_hash"><a href="erl_nif.html#enif_hash">enif_hash()
                </a></li>
<li title="enif_inspect_binary"><a href="erl_nif.html#enif_inspect_binary">enif_inspect_binary()
                </a></li>
<li title="enif_inspect_iolist_as_binary"><a href="erl_nif.html#enif_inspect_iolist_as_binary">enif_inspect_iolist_as_binary()
                </a></li>
<li title="enif_inspect_iovec"><a href="erl_nif.html#enif_inspect_iovec">enif_inspect_iovec()
                </a></li>
<li title="enif_ioq_create"><a href="erl_nif.html#enif_ioq_create">enif_ioq_create()
                </a></li>
<li title="enif_ioq_deq"><a href="erl_nif.html#enif_ioq_deq">enif_ioq_deq()
                </a></li>
<li title="enif_ioq_destroy"><a href="erl_nif.html#enif_ioq_destroy">enif_ioq_destroy()
                </a></li>
<li title="enif_ioq_enq_binary"><a href="erl_nif.html#enif_ioq_enq_binary">enif_ioq_enq_binary()
                </a></li>
<li title="enif_ioq_enqv"><a href="erl_nif.html#enif_ioq_enqv">enif_ioq_enqv()
                </a></li>
<li title="enif_ioq_peek"><a href="erl_nif.html#enif_ioq_peek">enif_ioq_peek()
                </a></li>
<li title="enif_ioq_size"><a href="erl_nif.html#enif_ioq_size">enif_ioq_size()
                </a></li>
<li title="enif_is_atom"><a href="erl_nif.html#enif_is_atom">enif_is_atom()
                </a></li>
<li title="enif_is_binary"><a href="erl_nif.html#enif_is_binary">enif_is_binary()
                </a></li>
<li title="enif_is_current_process_alive"><a href="erl_nif.html#enif_is_current_process_alive">enif_is_current_process_alive()
                </a></li>
<li title="enif_is_empty_list"><a href="erl_nif.html#enif_is_empty_list">enif_is_empty_list()
                </a></li>
<li title="enif_is_exception"><a href="erl_nif.html#enif_is_exception">enif_is_exception()
                </a></li>
<li title="enif_is_fun"><a href="erl_nif.html#enif_is_fun">enif_is_fun()
                </a></li>
<li title="enif_is_identical"><a href="erl_nif.html#enif_is_identical">enif_is_identical()
                </a></li>
<li title="enif_is_list"><a href="erl_nif.html#enif_is_list">enif_is_list()
                </a></li>
<li title="enif_is_map"><a href="erl_nif.html#enif_is_map">enif_is_map()
                </a></li>
<li title="enif_is_number"><a href="erl_nif.html#enif_is_number">enif_is_number()
                </a></li>
<li title="enif_is_pid"><a href="erl_nif.html#enif_is_pid">enif_is_pid()
                </a></li>
<li title="enif_is_port"><a href="erl_nif.html#enif_is_port">enif_is_port()
                </a></li>
<li title="enif_is_port_alive"><a href="erl_nif.html#enif_is_port_alive">enif_is_port_alive()
                </a></li>
<li title="enif_is_process_alive"><a href="erl_nif.html#enif_is_process_alive">enif_is_process_alive()
                </a></li>
<li title="enif_is_ref"><a href="erl_nif.html#enif_is_ref">enif_is_ref()
                </a></li>
<li title="enif_is_tuple"><a href="erl_nif.html#enif_is_tuple">enif_is_tuple()
                </a></li>
<li title="enif_keep_resource"><a href="erl_nif.html#enif_keep_resource">enif_keep_resource()
                </a></li>
<li title="enif_make_atom"><a href="erl_nif.html#enif_make_atom">enif_make_atom()
                </a></li>
<li title="enif_make_atom_len"><a href="erl_nif.html#enif_make_atom_len">enif_make_atom_len()
                </a></li>
<li title="enif_make_badarg"><a href="erl_nif.html#enif_make_badarg">enif_make_badarg()
                </a></li>
<li title="enif_make_binary"><a href="erl_nif.html#enif_make_binary">enif_make_binary()
                </a></li>
<li title="enif_make_copy"><a href="erl_nif.html#enif_make_copy">enif_make_copy()
                </a></li>
<li title="enif_make_double"><a href="erl_nif.html#enif_make_double">enif_make_double()
                </a></li>
<li title="enif_make_existing_atom"><a href="erl_nif.html#enif_make_existing_atom">enif_make_existing_atom()
                </a></li>
<li title="enif_make_existing_atom_len"><a href="erl_nif.html#enif_make_existing_atom_len">enif_make_existing_atom_len()
                </a></li>
<li title="enif_make_int"><a href="erl_nif.html#enif_make_int">enif_make_int()
                </a></li>
<li title="enif_make_int64"><a href="erl_nif.html#enif_make_int64">enif_make_int64()
                </a></li>
<li title="enif_make_list"><a href="erl_nif.html#enif_make_list">enif_make_list()
                </a></li>
<li title="enif_make_list1"><a href="erl_nif.html#enif_make_list1">enif_make_list1()
                </a></li>
<li title="enif_make_list2"><a href="erl_nif.html#enif_make_list2">enif_make_list2()
                </a></li>
<li title="enif_make_list3"><a href="erl_nif.html#enif_make_list3">enif_make_list3()
                </a></li>
<li title="enif_make_list4"><a href="erl_nif.html#enif_make_list4">enif_make_list4()
                </a></li>
<li title="enif_make_list5"><a href="erl_nif.html#enif_make_list5">enif_make_list5()
                </a></li>
<li title="enif_make_list6"><a href="erl_nif.html#enif_make_list6">enif_make_list6()
                </a></li>
<li title="enif_make_list7"><a href="erl_nif.html#enif_make_list7">enif_make_list7()
                </a></li>
<li title="enif_make_list8"><a href="erl_nif.html#enif_make_list8">enif_make_list8()
                </a></li>
<li title="enif_make_list9"><a href="erl_nif.html#enif_make_list9">enif_make_list9()
                </a></li>
<li title="enif_make_list_cell"><a href="erl_nif.html#enif_make_list_cell">enif_make_list_cell()
                </a></li>
<li title="enif_make_list_from_array"><a href="erl_nif.html#enif_make_list_from_array">enif_make_list_from_array()
                </a></li>
<li title="enif_make_long"><a href="erl_nif.html#enif_make_long">enif_make_long()
                </a></li>
<li title="enif_make_map_put"><a href="erl_nif.html#enif_make_map_put">enif_make_map_put()
                </a></li>
<li title="enif_make_map_remove"><a href="erl_nif.html#enif_make_map_remove">enif_make_map_remove()
                </a></li>
<li title="enif_make_map_update"><a href="erl_nif.html#enif_make_map_update">enif_make_map_update()
                </a></li>
<li title="enif_make_new_binary"><a href="erl_nif.html#enif_make_new_binary">enif_make_new_binary()
                </a></li>
<li title="enif_make_new_map"><a href="erl_nif.html#enif_make_new_map">enif_make_new_map()
                </a></li>
<li title="enif_make_pid"><a href="erl_nif.html#enif_make_pid">enif_make_pid()
                </a></li>
<li title="enif_make_ref"><a href="erl_nif.html#enif_make_ref">enif_make_ref()
                </a></li>
<li title="enif_make_resource"><a href="erl_nif.html#enif_make_resource">enif_make_resource()
                </a></li>
<li title="enif_make_resource_binary"><a href="erl_nif.html#enif_make_resource_binary">enif_make_resource_binary()
                </a></li>
<li title="enif_make_reverse_list"><a href="erl_nif.html#enif_make_reverse_list">enif_make_reverse_list()
                </a></li>
<li title="enif_make_string"><a href="erl_nif.html#enif_make_string">enif_make_string()
                </a></li>
<li title="enif_make_string_len"><a href="erl_nif.html#enif_make_string_len">enif_make_string_len()
                </a></li>
<li title="enif_make_sub_binary"><a href="erl_nif.html#enif_make_sub_binary">enif_make_sub_binary()
                </a></li>
<li title="enif_make_tuple"><a href="erl_nif.html#enif_make_tuple">enif_make_tuple()
                </a></li>
<li title="enif_make_tuple1"><a href="erl_nif.html#enif_make_tuple1">enif_make_tuple1()
                </a></li>
<li title="enif_make_tuple2"><a href="erl_nif.html#enif_make_tuple2">enif_make_tuple2()
                </a></li>
<li title="enif_make_tuple3"><a href="erl_nif.html#enif_make_tuple3">enif_make_tuple3()
                </a></li>
<li title="enif_make_tuple4"><a href="erl_nif.html#enif_make_tuple4">enif_make_tuple4()
                </a></li>
<li title="enif_make_tuple5"><a href="erl_nif.html#enif_make_tuple5">enif_make_tuple5()
                </a></li>
<li title="enif_make_tuple6"><a href="erl_nif.html#enif_make_tuple6">enif_make_tuple6()
                </a></li>
<li title="enif_make_tuple7"><a href="erl_nif.html#enif_make_tuple7">enif_make_tuple7()
                </a></li>
<li title="enif_make_tuple8"><a href="erl_nif.html#enif_make_tuple8">enif_make_tuple8()
                </a></li>
<li title="enif_make_tuple9"><a href="erl_nif.html#enif_make_tuple9">enif_make_tuple9()
                </a></li>
<li title="enif_make_tuple_from_array"><a href="erl_nif.html#enif_make_tuple_from_array">enif_make_tuple_from_array()
                </a></li>
<li title="enif_make_uint"><a href="erl_nif.html#enif_make_uint">enif_make_uint()
                </a></li>
<li title="enif_make_uint64"><a href="erl_nif.html#enif_make_uint64">enif_make_uint64()
                </a></li>
<li title="enif_make_ulong"><a href="erl_nif.html#enif_make_ulong">enif_make_ulong()
                </a></li>
<li title="enif_make_unique_integer"><a href="erl_nif.html#enif_make_unique_integer">enif_make_unique_integer()
                </a></li>
<li title="enif_map_iterator_create"><a href="erl_nif.html#enif_map_iterator_create">enif_map_iterator_create()
                </a></li>
<li title="enif_map_iterator_destroy"><a href="erl_nif.html#enif_map_iterator_destroy">enif_map_iterator_destroy()
                </a></li>
<li title="enif_map_iterator_get_pair"><a href="erl_nif.html#enif_map_iterator_get_pair">enif_map_iterator_get_pair()
                </a></li>
<li title="enif_map_iterator_is_head"><a href="erl_nif.html#enif_map_iterator_is_head">enif_map_iterator_is_head()
                </a></li>
<li title="enif_map_iterator_is_tail"><a href="erl_nif.html#enif_map_iterator_is_tail">enif_map_iterator_is_tail()
                </a></li>
<li title="enif_map_iterator_next"><a href="erl_nif.html#enif_map_iterator_next">enif_map_iterator_next()
                </a></li>
<li title="enif_map_iterator_prev"><a href="erl_nif.html#enif_map_iterator_prev">enif_map_iterator_prev()
                </a></li>
<li title="enif_monitor_process"><a href="erl_nif.html#enif_monitor_process">enif_monitor_process()
                </a></li>
<li title="enif_monotonic_time"><a href="erl_nif.html#enif_monotonic_time">enif_monotonic_time()
                </a></li>
<li title="enif_mutex_create"><a href="erl_nif.html#enif_mutex_create">enif_mutex_create()
                </a></li>
<li title="enif_mutex_destroy"><a href="erl_nif.html#enif_mutex_destroy">enif_mutex_destroy()
                </a></li>
<li title="enif_mutex_lock"><a href="erl_nif.html#enif_mutex_lock">enif_mutex_lock()
                </a></li>
<li title="enif_mutex_trylock"><a href="erl_nif.html#enif_mutex_trylock">enif_mutex_trylock()
                </a></li>
<li title="enif_mutex_unlock"><a href="erl_nif.html#enif_mutex_unlock">enif_mutex_unlock()
                </a></li>
<li title="enif_now_time"><a href="erl_nif.html#enif_now_time">enif_now_time()
                </a></li>
<li title="enif_open_resource_type"><a href="erl_nif.html#enif_open_resource_type">enif_open_resource_type()
                </a></li>
<li title="enif_open_resource_type_x"><a href="erl_nif.html#enif_open_resource_type_x">enif_open_resource_type_x()
                </a></li>
<li title="enif_port_command"><a href="erl_nif.html#enif_port_command">enif_port_command()
                </a></li>
<li title="enif_priv_data"><a href="erl_nif.html#enif_priv_data">enif_priv_data()
                </a></li>
<li title="enif_raise_exception"><a href="erl_nif.html#enif_raise_exception">enif_raise_exception()
                </a></li>
<li title="enif_realloc"><a href="erl_nif.html#enif_realloc">enif_realloc()
                </a></li>
<li title="enif_realloc_binary"><a href="erl_nif.html#enif_realloc_binary">enif_realloc_binary()
                </a></li>
<li title="enif_release_binary"><a href="erl_nif.html#enif_release_binary">enif_release_binary()
                </a></li>
<li title="enif_release_resource"><a href="erl_nif.html#enif_release_resource">enif_release_resource()
                </a></li>
<li title="enif_rwlock_create"><a href="erl_nif.html#enif_rwlock_create">enif_rwlock_create()
                </a></li>
<li title="enif_rwlock_destroy"><a href="erl_nif.html#enif_rwlock_destroy">enif_rwlock_destroy()
                </a></li>
<li title="enif_rwlock_rlock"><a href="erl_nif.html#enif_rwlock_rlock">enif_rwlock_rlock()
                </a></li>
<li title="enif_rwlock_runlock"><a href="erl_nif.html#enif_rwlock_runlock">enif_rwlock_runlock()
                </a></li>
<li title="enif_rwlock_rwlock"><a href="erl_nif.html#enif_rwlock_rwlock">enif_rwlock_rwlock()
                </a></li>
<li title="enif_rwlock_rwunlock"><a href="erl_nif.html#enif_rwlock_rwunlock">enif_rwlock_rwunlock()
                </a></li>
<li title="enif_rwlock_tryrlock"><a href="erl_nif.html#enif_rwlock_tryrlock">enif_rwlock_tryrlock()
                </a></li>
<li title="enif_rwlock_tryrwlock"><a href="erl_nif.html#enif_rwlock_tryrwlock">enif_rwlock_tryrwlock()
                </a></li>
<li title="enif_schedule_nif"><a href="erl_nif.html#enif_schedule_nif">enif_schedule_nif()
                </a></li>
<li title="enif_select"><a href="erl_nif.html#enif_select">enif_select()
                </a></li>
<li title="enif_self"><a href="erl_nif.html#enif_self">enif_self()
                </a></li>
<li title="enif_send"><a href="erl_nif.html#enif_send">enif_send()
                </a></li>
<li title="enif_sizeof_resource"><a href="erl_nif.html#enif_sizeof_resource">enif_sizeof_resource()
                </a></li>
<li title="enif_snprintf"><a href="erl_nif.html#enif_snprintf">enif_snprintf()
                </a></li>
<li title="enif_system_info"><a href="erl_nif.html#enif_system_info">enif_system_info()
                </a></li>
<li title="enif_term_to_binary"><a href="erl_nif.html#enif_term_to_binary">enif_term_to_binary()
                </a></li>
<li title="enif_thread_create"><a href="erl_nif.html#enif_thread_create">enif_thread_create()
                </a></li>
<li title="enif_thread_exit"><a href="erl_nif.html#enif_thread_exit">enif_thread_exit()
                </a></li>
<li title="enif_thread_join"><a href="erl_nif.html#enif_thread_join">enif_thread_join()
                </a></li>
<li title="enif_thread_opts_create"><a href="erl_nif.html#enif_thread_opts_create">enif_thread_opts_create()
                </a></li>
<li title="enif_thread_opts_destroy"><a href="erl_nif.html#enif_thread_opts_destroy">enif_thread_opts_destroy()
                </a></li>
<li title="enif_thread_self"><a href="erl_nif.html#enif_thread_self">enif_thread_self()
                </a></li>
<li title="enif_thread_type"><a href="erl_nif.html#enif_thread_type">enif_thread_type()
                </a></li>
<li title="enif_time_offset"><a href="erl_nif.html#enif_time_offset">enif_time_offset()
                </a></li>
<li title="enif_tsd_get"><a href="erl_nif.html#enif_tsd_get">enif_tsd_get()
                </a></li>
<li title="enif_tsd_key_create"><a href="erl_nif.html#enif_tsd_key_create">enif_tsd_key_create()
                </a></li>
<li title="enif_tsd_key_destroy"><a href="erl_nif.html#enif_tsd_key_destroy">enif_tsd_key_destroy()
                </a></li>
<li title="enif_tsd_set"><a href="erl_nif.html#enif_tsd_set">enif_tsd_set()
                </a></li>
<li title="enif_whereis_pid"><a href="erl_nif.html#enif_whereis_pid">enif_whereis_pid()
                </a></li>
<li title="enif_whereis_port"><a href="erl_nif.html#enif_whereis_port">enif_whereis_port()
                </a></li>
</ul>
</li>
<li id="no" title="erl_tracer " expanded="false">erl_tracer<ul>
<li><a href="erl_tracer.html">
                  Top of manual page
                </a></li>
    <li title="Module:enabled-3"><a href="erl_tracer.html#Module:enabled-3">Module:enabled/3</a></li>
    <li title="Module:enabled_call-3"><a href="erl_tracer.html#Module:enabled_call-3">Module:enabled_call/3</a></li>
    <li title="Module:enabled_garbage_collection-3"><a href="erl_tracer.html#Module:enabled_garbage_collection-3">Module:enabled_garbage_collection/3</a></li>
    <li title="Module:enabled_ports-3"><a href="erl_tracer.html#Module:enabled_ports-3">Module:enabled_ports/3</a></li>
    <li title="Module:enabled_procs-3"><a href="erl_tracer.html#Module:enabled_procs-3">Module:enabled_procs/3</a></li>
    <li title="Module:enabled_receive-3"><a href="erl_tracer.html#Module:enabled_receive-3">Module:enabled_receive/3</a></li>
    <li title="Module:enabled_running_ports-3"><a href="erl_tracer.html#Module:enabled_running_ports-3">Module:enabled_running_ports/3</a></li>
    <li title="Module:enabled_running_procs-3"><a href="erl_tracer.html#Module:enabled_running_procs-3">Module:enabled_running_procs/3</a></li>
    <li title="Module:enabled_send-3"><a href="erl_tracer.html#Module:enabled_send-3">Module:enabled_send/3</a></li>
    <li title="Module:trace-5"><a href="erl_tracer.html#Module:trace-5">Module:trace/5</a></li>
    <li title="Module:trace_call-5"><a href="erl_tracer.html#Module:trace_call-5">Module:trace_call/5</a></li>
    <li title="Module:trace_garbage_collection-5"><a href="erl_tracer.html#Module:trace_garbage_collection-5">Module:trace_garbage_collection/5</a></li>
    <li title="Module:trace_ports-5"><a href="erl_tracer.html#Module:trace_ports-5">Module:trace_ports/5</a></li>
    <li title="Module:trace_procs-5"><a href="erl_tracer.html#Module:trace_procs-5">Module:trace_procs/5</a></li>
    <li title="Module:trace_receive-5"><a href="erl_tracer.html#Module:trace_receive-5">Module:trace_receive/5</a></li>
    <li title="Module:trace_running_ports-5"><a href="erl_tracer.html#Module:trace_running_ports-5">Module:trace_running_ports/5</a></li>
    <li title="Module:trace_running_procs-5"><a href="erl_tracer.html#Module:trace_running_procs-5">Module:trace_running_procs/5</a></li>
    <li title="Module:trace_send-5"><a href="erl_tracer.html#Module:trace_send-5">Module:trace_send/5</a></li>
    </ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>erl_driver</h1></center>
  
  <h3><a name="c-library" href="#c-library">C Library</a></h3>
<div class="REFBODY c-library-body">erl_driver</div>
  <h3><a name="library-summary" href="#library-summary">Library Summary</a></h3>
<div class="REFBODY library-summary-body">API functions for an Erlang driver.</div>
  <h3><a name="description" href="#description">Description</a></h3>
<div class="REFBODY description-body"><p>
    <p>An Erlang driver is a library containing a set of native driver
      callback functions that the Erlang Virtual Machine calls when certain
      events occur. There can be multiple instances of a driver, each
      instance is associated with an Erlang port.</p>

    <a name="WARNING"></a>
    <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
      <p><strong>Use this functionality with extreme care.</strong></p>
      <p>A driver callback is executed as a direct extension of the
        native code of the VM. Execution is not made in a safe environment.
        The VM <strong>cannot</strong> provide the same services as provided when
        executing Erlang code, such as pre-emptive scheduling or memory
        protection. If the driver callback function does not behave well,
        the whole VM will misbehave.</p>
      <ul>
        <li>
          <p>A driver callback that crash will crash the whole VM.</p>
        </li>
        <li>
          <p>An erroneously implemented driver callback can cause a VM
            internal state inconsistency, which can cause a crash of the VM,
            or miscellaneous misbehaviors of the VM at any point after the
            call to the driver callback.</p>
        </li>
        <li>
          <p>A driver callback doing
            <span class="bold_code bc-17"><a href="#lengthy_work">lengthy work</a></span> before
            returning degrades responsiveness of the VM and can cause
            miscellaneous strange behaviors. Such strange behaviors
            include, but are not limited to, extreme memory usage and bad
            load balancing between schedulers. Strange behaviors that can
            occur because of lengthy work can also vary between Erlang/OTP
            releases.</p>
        </li>
      </ul>
    </p></div>
</div>

    <p>As from ERTS 5.5.3 the driver interface has been extended
      (see <span class="bold_code bc-15"><a href="driver_entry.html#extended_marker"><span class="code">extended marker</span></a></span>). The extended interface introduces
      <span class="bold_code bc-17"><a href="#version_management">version management</a></span>,
      the possibility to pass capability flags (see
      <span class="bold_code bc-15"><a href="driver_entry.html#driver_flags"><span class="code">driver_flags</span></a></span>) to the runtime system at driver
      initialization, and some new driver API functions.</p>

    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>As from ERTS 5.9 old drivers must be recompiled
        and use the extended interface. They must also be adjusted to the
        <span class="bold_code bc-17"><a href="#rewrites_for_64_bits">64-bit capable driver interface</a></span>.</p>
    </p></div>
</div>

    <p>The driver calls back to the emulator, using the API
      functions declared in <span class="code">erl_driver.h</span>. They are used for
      outputting data from the driver, using timers, and so on.</p>

    <p>Each driver instance is associated with a port. Every port
      has a port owner process. Communication with the port is normally
      done through the port owner process. Most of the functions take
      the <span class="code">port</span> handle as an argument. This identifies the driver
      instance. Notice that this port handle must be stored by the driver,
      it is not given when the driver is called from the emulator (see
      <span class="bold_code bc-15"><a href="driver_entry.html#emulator"><span class="code">driver_entry</span></a></span>).</p>

    <p>Some of the functions take a parameter of type
      <span class="code">ErlDrvBinary</span>, a driver binary. It is to be both
      allocated and freed by the caller. Using a binary directly avoids
      one extra copying of data.</p>

    <p>Many of the output functions have a "header buffer", with
      <span class="code">hbuf</span> and <span class="code">hlen</span> parameters. This buffer is sent as a
      list before the binary (or list, depending on port mode) that is
      sent. This is convenient when matching on messages received from
      the port. (Although in the latest Erlang versions there is
      the binary syntax, which enables you to match on the beginning of
      a binary.)</p>
    <p><a name="smp_support"></a>In the runtime system with
      SMP support, drivers are locked either on driver level
      or port level (driver instance level). By default
      driver level locking will be used, that is, only one emulator thread
      will execute code in the driver at a time. If port level locking
      is used, multiple emulator threads can execute code in the driver
      at the same time. Only one thread at a time will call
      driver callbacks corresponding to the same port, though.
      To enable port level locking, set the <span class="code">ERL_DRV_FLAG_USE_PORT_LOCKING</span>
      <span class="bold_code bc-15"><a href="driver_entry.html#driver_flags">driver flag</a></span> in
      the <span class="bold_code bc-19"><a href="driver_entry.html"><span class="code">driver_entry</span></a></span>
      used by the driver. When port level locking is used,
      the driver writer is responsible for synchronizing all accesses
      to data shared by the ports (driver instances).</p>

    <p>Most drivers written before the runtime system with SMP
      support existed can run in the runtime system
      with SMP support, without being rewritten, if driver
      level locking is used.</p>

    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>It is assumed that drivers do not access other drivers. If
        drivers access each other, they must provide their own
        mechanism for thread-safe synchronization. Such "inter-driver
        communication" is strongly discouraged.</p>
    </p></div>
</div>

    <p>Previously, in the runtime system without SMP support,
      specific driver callbacks were always called from the same
      thread. This is <strong>not</strong> the case in the runtime system
      with SMP support. Regardless of locking scheme used, calls
      to driver callbacks can be made from different threads. For example,
      two consecutive calls to exactly the same callback for exactly
      the same port can be made from two different threads. This
      is for <strong>most</strong> drivers not a problem, but it can be.
      Drivers that depend on all callbacks that are called in the
      same thread, <strong>must</strong> be rewritten before they are used
      in the runtime system with SMP support.</p>

    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>Regardless of locking scheme used, calls to driver
        callbacks can be made from different threads.</p>
    </p></div>
</div>

    <p>Most functions in this API are <strong>not</strong> thread-safe, that is,
      they <strong>cannot</strong> be called from any thread. Functions
      that are not documented as thread-safe can only be called from
      driver callbacks or function calls descending from a driver
      callback call. Notice that driver callbacks can be called from
      different threads. This, however, is not a problem for any
      function in this API, as the emulator has control over
      these threads.</p>

    <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
      <p>Functions not explicitly documented as thread-safe are
        <strong>not</strong> thread safe. Also notice that some functions
        are <strong>only</strong> thread-safe when used in a runtime
        system with SMP support.</p>
      <p>A function not explicitly documented as thread-safe can, at
        some point in time, have a thread-safe implementation in the
        runtime system. Such an implementation can however change to
        a thread <strong>unsafe</strong> implementation at any time <strong>without
        any notice</strong>.</p>
      <p><strong>Only use functions explicitly documented as thread-safe
        from arbitrary threads.</strong></p>
    </p></div>
</div>

    <p><a name="lengthy_work"></a>
      As mentioned in the <span class="bold_code bc-17"><a href="#WARNING">warning</a></span> text at
      the beginning of this section, it is of vital importance that a driver
      callback returns relatively fast. It is difficult to give an exact
      maximum amount of time that a driver callback is allowed to work, but
      usually a well-behaving driver callback is to return within 1 millisecond.
      This can be achieved using different approaches.
      If you have full control over the code to execute in the driver
      callback, the best approach is to divide the work into multiple chunks of
      work, and trigger multiple calls to the
      <span class="bold_code bc-15"><a href="driver_entry.html#timeout">time-out callback</a></span> using
      zero time-outs. Function <span class="bold_code bc-17"><a href="#erl_drv_consume_timeslice"><span class="code">erl_drv_consume_timeslice</span></a></span> can be useful to
      determine when to trigger such time-out callback calls. However, sometimes
      it cannot be implemented this way, for example when calling
      third-party libraries. In this case, you typically want to dispatch the
      work to another thread. Information about thread primitives is provided
      below.</p>
  </p></div>

  <h3><a name="id210826">Functionality</a></h3>
<div class="REFBODY rb-3">
    
    <p>All functions that a driver needs to do with Erlang are
      performed through driver API functions. Functions exist
      for the following functionality:</p>

    <dl>
      <dt><strong>Timer functions</strong></dt>
      <dd>
        <p>Control the timer that a driver can use. The timer has the
          emulator call the <span class="bold_code bc-15"><a href="driver_entry.html#timeout"><span class="code">timeout</span></a></span> entry function after a specified time.
          Only one timer is available for each driver instance.</p>
      </dd>
      <dt><strong>Queue handling</strong></dt>
      <dd>
        <p>Every driver instance has an associated queue. This queue is a
          <span class="code">SysIOVec</span>, which works as a buffer. It is mostly used for
          the driver to buffer data that is to be written to a device,
          it is a byte stream. If the port owner process closes the
          driver, and the queue is not empty, the driver is not
          closed. This enables the driver to flush its buffers before
          closing.</p>
        <p>The queue can be manipulated from any threads if
          a port data lock is used. For more information, see
          <span class="bold_code bc-17"><a href="#ErlDrvPDL"><span class="code">ErlDrvPDL</span></a></span>.</p>
      </dd>
      <dt><strong>Output functions</strong></dt>
      <dd>
        <p>With these functions, the driver sends data back to the emulator.
          The data is received as messages by the port owner process, see
          <span class="bold_code bc-18"><a href="../apps/erlang/open_port/2.html"><span class="code">erlang:open_port/2</span></a></span>. The vector function and the
          function taking a driver binary are faster, as they avoid
          copying the data buffer. There is also a fast way of sending
          terms from the driver, without going through the binary term
          format.</p>
</dd>
      <dt><strong>Failure</strong></dt>
      <dd>
        <p>The driver can exit and signal errors up to Erlang. This is
          only for severe errors, when the driver cannot possibly keep
          open.</p>
      </dd>
      <dt><strong>Asynchronous calls</strong></dt>
      <dd>
        <p>Erlang/OTP R7B and later versions have provision for
          asynchronous function calls, using a thread pool provided by
          Erlang. There is also a select call, which can be used for
          asynchronous drivers.</p>
      </dd>
      <dt><strong><a name="multi_threading"></a>Multi-threading</strong></dt>
      <dd>
        <p>A POSIX thread like API for multi-threading is provided. The
          Erlang driver thread API only provides a subset of the functionality
          provided by the POSIX thread API. The subset provided is
          more or less the basic functionality needed for multi-threaded
          programming:</p>
        <ul>
          <li><span class="bold_code bc-17"><a href="#ErlDrvTid">Threads</a></span></li>
          <li><span class="bold_code bc-17"><a href="#ErlDrvMutex">Mutexes</a></span></li>
          <li><span class="bold_code bc-17"><a href="#ErlDrvCond">Condition variables</a></span></li>
          <li><span class="bold_code bc-17"><a href="#ErlDrvRWLock">Read/write locks</a></span></li>
          <li><span class="bold_code bc-17"><a href="#ErlDrvTSDKey">Thread-specific data</a></span></li>
        </ul>
        <p>The Erlang driver thread API can be used in conjunction with
          the POSIX thread API on UN-ices and with the Windows native thread
          API on Windows. The Erlang driver thread API has the advantage of
          being portable, but there can exist situations where you want to
          use functionality from the POSIX thread API or the Windows
          native thread API.</p>
        <p>The Erlang driver thread API only returns error codes when it is
          reasonable to recover from an error condition. If it is not reasonable
          to recover from an error condition, the whole runtime system is
          terminated. For example, if a create mutex operation fails, an error
          code is returned, but if a lock operation on a mutex fails, the
          whole runtime system is terminated.</p>
        <p>Notice that there is no "condition variable wait with time-out" in
          the Erlang driver thread API. This because of issues with
          <span class="code">pthread_cond_timedwait</span>. When the system clock suddenly
          is changed, it is not always guaranteed that you will wake up from
          the call as expected. An Erlang runtime system must be able to
          cope with sudden changes of the system clock. Therefore, we have
          omitted it from the Erlang driver thread API. In the Erlang driver
          case, time-outs can and are to be handled with the timer functionality
          of the Erlang driver API.</p>
        <p>In order for the Erlang driver thread API to function, thread
          support must be enabled in the runtime system. An Erlang driver
          can check if thread support is enabled by use of
          <span class="bold_code bc-17"><a href="#driver_system_info"><span class="code">driver_system_info</span></a></span>.
          Notice that some functions in the Erlang driver API are thread-safe
          only when the runtime system has SMP support, also this
          information can be retrieved through
          <span class="bold_code bc-17"><a href="#driver_system_info"><span class="code">driver_system_info</span></a></span>.
          Also notice that many functions in the Erlang driver API are
          <strong>not</strong> thread-safe, regardless of whether SMP support is
          enabled or not. If a function is not documented as thread-safe, it
          is <strong>not</strong> thread-safe.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>When executing in an emulator thread, it is
            <strong>very important</strong> that you unlock <strong>all</strong> locks you
            have locked before letting the thread out of your control;
            otherwise you are <strong>very likely</strong> to deadlock the whole
            emulator.</p>
          <p>If you need to use thread-specific data in an emulator
            thread, only have the thread-specific data set while the thread is
            under your control, and clear the thread-specific data before
            you let the thread out of your control.</p>
        </p></div>
</div>
        <p>In the future, debug functionality will probably be
          integrated with the Erlang driver thread API. All functions
          that create entities take a <span class="code">name</span> argument. Currently
          the <span class="code">name</span> argument is unused, but it will be used when
          the debug functionality is implemented. If you name all
          entities created well, the debug functionality will be able
          to give you better error reports.</p>
      </dd>
      <dt><strong>Adding/removing drivers</strong></dt>
      <dd>
        <p>A driver can add and later remove drivers.</p>
      </dd>
      <dt><strong>Monitoring processes</strong></dt>
      <dd>
        <p>A driver can monitor a process that does not own a port.</p>
      </dd>
      <dt><strong><a name="version_management"></a>Version management</strong></dt>
      <dd>
        <p>Version management is enabled for drivers that have set the
          <span class="bold_code bc-15"><a href="driver_entry.html#extended_marker"><span class="code">extended_marker</span></a></span> field of their
          <span class="bold_code bc-19"><a href="driver_entry.html"><span class="code">driver_entry</span></a></span>
          to <span class="code">ERL_DRV_EXTENDED_MARKER</span>. <span class="code">erl_driver.h</span> defines:</p>
        <ul>
          <li>
            <p><span class="code">ERL_DRV_EXTENDED_MARKER</span></p>
          </li>
          <li>
            <p><span class="code">ERL_DRV_EXTENDED_MAJOR_VERSION</span>, which is incremented when
              driver incompatible changes are made to the Erlang runtime
              system. Normally it suffices to recompile drivers when
              <span class="code">ERL_DRV_EXTENDED_MAJOR_VERSION</span> has changed, but it
              can, under rare circumstances, mean that drivers must
              be slightly modified. If so, this will of course be
              documented.</p>
          </li>
          <li>
            <p><span class="code">ERL_DRV_EXTENDED_MINOR_VERSION</span>, which is incremented when
              new features are added. The runtime system uses the minor version
              of the driver to determine what features to use.</p>
          </li>
        </ul>
        <p>The runtime system normally refuses to load a driver if the major
          versions differ, or if the major versions are equal and the
          minor version used by the driver is greater than the one used
          by the runtime system. Old drivers with lower major versions
          are however allowed after a bump of the major version during
          a transition period of two major releases. Such old drivers can,
          however, fail if deprecated features are used.</p>
        <p>The emulator refuses to load a driver that does not use
          the extended driver interface, to allow for 64-bit capable drivers,
          as incompatible type changes for the callbacks
          <span class="bold_code bc-15"><a href="driver_entry.html#output"><span class="code">output</span></a></span>,
          <span class="bold_code bc-15"><a href="driver_entry.html#control"><span class="code">control</span></a></span>, and
          <span class="bold_code bc-15"><a href="driver_entry.html#call"><span class="code">call</span></a></span>
          were introduced in Erlang/OTP R15B. A driver written
          with the old types would compile with warnings and when
          called return garbage sizes to the emulator, causing it
          to read random memory and create huge incorrect result blobs.</p>
        <p>Therefore it is not enough to only recompile drivers written with
          version management for pre R15B types; the types must be changed
          in the driver suggesting other rewrites, especially regarding size
          variables. <strong>Investigate all warnings when recompiling.</strong></p>
        <p>Also, the API driver functions <span class="code">driver_output*</span> and
          <span class="code">driver_vec_to_buf</span>, <span class="code">driver_alloc/realloc*</span>, and the
          <span class="code">driver_*</span> queue functions were changed to have
          larger length arguments and return values. This is a
          lesser problem, as code that passes smaller types
          gets them auto-converted in the calls, and as long as
          the driver does not handle sizes that overflow an <span class="code">int</span>,
          all will work as before.</p>
      </dd>
      <dt><strong><a name="time_measurement"></a>Time measurement</strong></dt>
      <dd>
        <p>Support for time measurement in drivers:</p>
        <ul>
          <li><span class="bold_code bc-17"><a href="#ErlDrvTime"><span class="code">ErlDrvTime</span></a></span></li>
          <li><span class="bold_code bc-17"><a href="#ErlDrvTimeUnit"><span class="code">ErlDrvTimeUnit</span></a></span></li>
          <li><span class="bold_code bc-17"><a href="#erl_drv_monotonic_time"><span class="code">erl_drv_monotonic_time</span></a></span></li>
          <li><span class="bold_code bc-17"><a href="#erl_drv_time_offset"><span class="code">erl_drv_time_offset</span></a></span></li>
          <li><span class="bold_code bc-17"><a href="#erl_drv_convert_time_unit"><span class="code">erl_drv_convert_time_unit</span></a></span></li>
        </ul>
      </dd>
    </dl>
  </div>

  <h3>
<a name="rewrites_for_64_bits"></a><a name="id211343">Rewrites for 64-Bit Driver Interface</a>
</h3>
<div class="REFBODY rb-3">
    
    
    <p>ERTS 5.9 introduced two new integer types,
      <span class="bold_code bc-17"><a href="#ErlDrvSizeT"><span class="code">ErlDrvSizeT</span></a></span> and
      <span class="bold_code bc-17"><a href="#ErlDrvSSizeT"><span class="code">ErlDrvSSizeT</span></a></span>,
      which can hold 64-bit sizes if necessary.</p>

    <p>To not update a driver and only recompile, it probably works
      when building for a 32-bit machine creating a false sense of security.
      Hopefully that will generate many important warnings.
      But when recompiling the same driver later on for a 64-bit machine,
      there <strong>will</strong> be warnings and almost certainly crashes.
      So it is a <strong>bad</strong> idea to postpone updating the driver and
      not fixing the warnings.</p>

    <p>When recompiling with <span class="code">gcc</span>, use flag <span class="code">-Wstrict-prototypes</span>
      to get better warnings. Try to find a similar flag if you use
      another compiler.</p>

    <p>The following is a checklist for rewriting a pre ERTS 5.9 driver,
      most important first:</p>

    <dl>
      <dt><strong>Return types for driver callbacks</strong></dt>
      <dd>
	<p>Rrewrite driver callback
	  <span class="bold_code bc-15"><a href="driver_entry.html#control"><span class="code">control</span></a></span>
	  to use return type <span class="code">ErlDrvSSizeT</span> instead of <span class="code">int</span>.</p>
	<p>Rewrite driver callback
	  <span class="bold_code bc-15"><a href="driver_entry.html#call"><span class="code">call</span></a></span>
	  to use return type <span class="code">ErlDrvSSizeT</span> instead of <span class="code">int</span>.</p>
	<div class="note">
<div class="label">Note</div>
<div class="content"><p>
	  <p>These changes are essential not to crash the emulator
	    or worse cause malfunction.
	    Without them a driver can return garbage in the high 32 bits
	    to the emulator, causing it to build a huge result from random
	    bytes, either crashing on memory allocation or succeeding with
	    a random result from the driver call.</p>
	</p></div>
</div>
      </dd>
      <dt><strong>Arguments to driver callbacks</strong></dt>
      <dd>
	<p>Driver callback
	  <span class="bold_code bc-15"><a href="driver_entry.html#output"><span class="code">output</span></a></span>
	  now gets <span class="code">ErlDrvSizeT</span> as 3rd argument instead
	  of previously <span class="code">int</span>.</p>
	<p>Driver callback
	  <span class="bold_code bc-15"><a href="driver_entry.html#control"><span class="code">control</span></a></span>
	  now gets <span class="code">ErlDrvSizeT</span> as 4th and 6th arguments instead
	  of previously <span class="code">int</span>.</p>
	<p>Driver callback
	  <span class="bold_code bc-15"><a href="driver_entry.html#call"><span class="code">call</span></a></span>
	  now gets <span class="code">ErlDrvSizeT</span> as 4th and 6th arguments instead
	  of previously <span class="code">int</span>.</p>
	<p>Sane compiler's calling conventions probably make these changes
	  necessary only for a driver to handle data chunks that require
	  64-bit size fields (mostly larger than 2 GB, as that is what
	  an <span class="code">int</span> of 32 bits can hold). But it is possible to think
	  of non-sane calling conventions that would make the driver
	  callbacks mix up the arguments causing malfunction.</p>
	<div class="note">
<div class="label">Note</div>
<div class="content"><p>
	  <p>The argument type change is from signed to unsigned. This
	    can cause problems for, for example, loop termination conditions or
	    error conditions if you only change the types all over the place.
          </p>
	</p></div>
</div>
      </dd>
      <dt><strong>Larger <span class="code">size</span> field in <span class="code">ErlIOVec</span></strong></dt>
      <dd>
	<p>The <span class="code">size</span> field in
	  <span class="bold_code bc-17"><a href="#ErlIOVec"><span class="code">ErlIOVec</span></a></span>
	  has been changed to <span class="code">ErlDrvSizeT</span> from <span class="code">int</span>.
	  Check all code that use that field.</p>
	<p>Automatic type-casting probably makes these changes necessary only
	  for a driver that encounters sizes &gt; 32 bits.</p>
	<div class="note">
<div class="label">Note</div>
<div class="content"><p>
	  <p>The <span class="code">size</span> field changed from signed to unsigned. This
	    can cause problems for, for example, loop termination conditions or
	    error conditions if you only change the types all over the place.
          </p>
	</p></div>
</div>
      </dd>
      <dt><strong>Arguments and return values in the driver API</strong></dt>
      <dd>
	<p>Many driver API functions have changed argument type
	  and/or return value to <span class="code">ErlDrvSizeT</span> from mostly <span class="code">int</span>.
	  Automatic type-casting probably makes these changes necessary only
	  for a driver that encounters sizes &gt; 32 bits.</p>
	<dl>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_output"><span class="code">driver_output</span></a></span></strong></dt>
	  <dd>3rd argument</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_output2"><span class="code">driver_output2</span></a></span></strong></dt>
	  <dd>3rd and 5th arguments</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_output_binary"><span class="code">driver_output_binary</span></a></span></strong></dt>
	  <dd>3rd, 5th, and 6th arguments</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_outputv"><span class="code">driver_outputv</span></a></span></strong></dt>
	  <dd>3rd and 5th arguments</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_vec_to_buf"><span class="code">driver_vec_to_buf</span></a></span></strong></dt>
	  <dd>3rd argument and return value</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_alloc"><span class="code">driver_alloc</span></a></span></strong></dt>
	  <dd>1st argument</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_realloc"><span class="code">driver_realloc</span></a></span></strong></dt>
	  <dd>2nd argument</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_alloc_binary"><span class="code">driver_alloc_binary</span></a></span></strong></dt>
	  <dd>1st argument</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_realloc_binary"><span class="code">driver_realloc_binary</span></a></span></strong></dt>
	  <dd>2nd argument</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_enq"><span class="code">driver_enq</span></a></span></strong></dt>
	  <dd>3rd argument</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_pushq"><span class="code">driver_pushq</span></a></span></strong></dt>
	  <dd>3rd argument</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_deq"><span class="code">driver_deq</span></a></span></strong></dt>
	  <dd>2nd argument and return value</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_sizeq"><span class="code">driver_sizeq</span></a></span></strong></dt>
	  <dd>Return value</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_enq_bin"><span class="code">driver_enq_bin</span></a></span></strong></dt>
	  <dd>3rd and 4th arguments</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_pushq_bin"><span class="code">driver_pushq_bin</span></a></span></strong></dt>
	  <dd>3rd and 4th arguments</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_enqv"><span class="code">driver_enqv</span></a></span></strong></dt>
	  <dd>3rd argument</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_pushqv"><span class="code">driver_pushqv</span></a></span></strong></dt>
	  <dd>3rd argument</dd>
	  <dt><strong><span class="bold_code bc-17"><a href="#driver_peekqv"><span class="code">driver_peekqv</span></a></span></strong></dt>
	  <dd>Return value</dd>
	</dl>
	<div class="note">
<div class="label">Note</div>
<div class="content"><p>
	  <p>This is a change from signed to unsigned. This can cause
	    problems for, for example, loop termination conditions and error
	    conditions if you only change the types all over the place.</p>
	</p></div>
</div>
      </dd>
    </dl>
  </div>

  <h3><a name="id211865">Data Types</a></h3>
<div class="REFBODY rb-3">
    
    <dl>
      <dt><strong><a name="ErlDrvSizeT"></a><span class="code">ErlDrvSizeT</span></strong></dt>
      <dd>
        <p>An unsigned integer type to be used as <span class="code">size_t</span>.</p>
      </dd>
      <dt><strong><a name="ErlDrvSSizeT"></a><span class="code">ErlDrvSSizeT</span></strong></dt>
      <dd>
        <p>A signed integer type, the size of <span class="code">ErlDrvSizeT</span>.</p>
      </dd>
      <dt><strong><a name="ErlDrvSysInfo"></a><span class="code">ErlDrvSysInfo</span></strong></dt>
      <dd>
        <div class="example"><pre>typedef struct ErlDrvSysInfo {
   int driver_major_version;
   int driver_minor_version;
   char *erts_version;
   char *otp_release;
   int thread_support;
   int smp_support;
   int async_threads;
   int scheduler_threads;
   int nif_major_version;
   int nif_minor_version;
   int dirty_scheduler_support;
} ErlDrvSysInfo;</pre></div>
        <p>The <span class="code">ErlDrvSysInfo</span> structure is used for storage of
          information about the Erlang runtime system.
          <span class="bold_code bc-17"><a href="#driver_system_info"><span class="code">driver_system_info</span></a></span>
          writes the system information when passed a reference to
          a <span class="code">ErlDrvSysInfo</span> structure. The fields in the structure
          are as follows:</p>
        <dl>
          <dt><strong><span class="code">driver_major_version</span></strong></dt>
          <dd>
            <p>The value of <span class="bold_code bc-17"><a href="#version_management"><span class="code">ERL_DRV_EXTENDED_MAJOR_VERSION</span></a></span>
              when the runtime system was compiled. This value is the same
              as the value of <span class="bold_code bc-17"><a href="#version_management"><span class="code">ERL_DRV_EXTENDED_MAJOR_VERSION</span></a></span>
              used when compiling the driver; otherwise the runtime system
              would have refused to load the driver.</p>
          </dd>
          <dt><strong><span class="code">driver_minor_version</span></strong></dt>
          <dd>
            <p>The value of <span class="bold_code bc-17"><a href="#version_management"><span class="code">ERL_DRV_EXTENDED_MINOR_VERSION</span></a></span>
              when the runtime system was compiled. This value can differ
              from the value of <span class="bold_code bc-17"><a href="#version_management"><span class="code">ERL_DRV_EXTENDED_MINOR_VERSION</span></a></span>
              used when compiling the driver.</p>
          </dd>
          <dt><strong><span class="code">erts_version</span></strong></dt>
          <dd>
            <p>A string containing the version number of the runtime system
              (the same as returned by
              <span class="bold_code bc-15"><a href="erlang.html#system_info_version"><span class="code">erlang:system_info(version)</span></a></span>).</p>
          </dd>
          <dt><strong><span class="code">otp_release</span></strong></dt>
          <dd>
            <p>A string containing the OTP release number
              (the same as returned by
              <span class="bold_code bc-15"><a href="erlang.html#system_info_otp_release"><span class="code">erlang:system_info(otp_release)</span></a></span>).</p>
          </dd>
          <dt><strong><span class="code">thread_support</span></strong></dt>
          <dd>
            <p>A value <span class="code">!= 0</span> if the runtime system has thread support;
              otherwise <span class="code">0</span>.</p>
          </dd>
          <dt><strong><span class="code">smp_support</span></strong></dt>
          <dd>
            <p>A value <span class="code">!= 0</span> if the runtime system has SMP support;
              otherwise <span class="code">0</span>.</p>
          </dd>
          <dt><strong><span class="code">async_threads</span></strong></dt>
          <dd>
            <p>The number of async threads in the async thread pool used by
              <span class="bold_code bc-17"><a href="#driver_async"><span class="code">driver_async</span></a></span>
              (the same as returned by
              <span class="bold_code bc-15"><a href="erlang.html#system_info_thread_pool_size"><span class="code">erlang:system_info(thread_pool_size)</span></a></span>).</p>
          </dd>
          <dt><strong><span class="code">scheduler_threads</span></strong></dt>
          <dd>
            <p>The number of scheduler threads used by the runtime system
              (the same as returned by
              <span class="bold_code bc-15"><a href="erlang.html#system_info_schedulers"><span class="code">erlang:system_info(schedulers)</span></a></span>).</p>
          </dd>
          <dt><strong><span class="code">nif_major_version</span></strong></dt>
          <dd>
            <p>The value of <span class="code">ERL_NIF_MAJOR_VERSION</span> when the runtime
              system was compiled.</p>
          </dd>
          <dt><strong><span class="code">nif_minor_version</span></strong></dt>
            <dd>
              <p>The value of <span class="code">ERL_NIF_MINOR_VERSION</span> when the runtime
                system was compiled.</p>
          </dd>
          <dt><strong><span class="code">dirty_scheduler_support</span></strong></dt>
          <dd>
            <p>A value <span class="code">!= 0</span> if the runtime system has support for dirty
              scheduler threads; otherwise <span class="code">0</span>.</p>
          </dd>
        </dl>
      </dd>
      <dt><strong><a name="ErlDrvBinary"></a><span class="code">ErlDrvBinary</span></strong></dt>
      <dd>
        <div class="example"><pre>typedef struct ErlDrvBinary {
   ErlDrvSint orig_size;
   char orig_bytes[];
} ErlDrvBinary;</pre></div>
        <p>The <span class="code">ErlDrvBinary</span> structure is a binary, as sent
          between the emulator and the driver. All binaries are
          reference counted; when <span class="code">driver_binary_free</span> is called,
          the reference count is decremented, when it reaches zero,
          the binary is deallocated. <span class="code">orig_size</span> is the binary size
          and <span class="code">orig_bytes</span> is the buffer.
          <span class="code">ErlDrvBinary</span> has not a fixed size, its size is
          <span class="code">orig_size + 2 * sizeof(int)</span>.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>The <span class="code">refc</span> field has been removed. The reference count of
            an <span class="code">ErlDrvBinary</span> is now stored elsewhere. The
            reference count of an <span class="code">ErlDrvBinary</span> can be accessed through
            <span class="bold_code bc-17"><a href="#driver_binary_get_refc"><span class="code">driver_binary_get_refc</span></a></span>,
            <span class="bold_code bc-17"><a href="#driver_binary_inc_refc"><span class="code">driver_binary_inc_refc</span></a></span>, and
            <span class="bold_code bc-17"><a href="#driver_binary_dec_refc"><span class="code">driver_binary_dec_refc</span></a></span>.</p>
        </p></div>
</div>
        <p>Some driver calls, such as <span class="code">driver_enq_binary</span>,
          increment the driver reference count, and others, such as
          <span class="code">driver_deq</span> decrement it.</p>
        <p>Using a driver binary instead of a normal buffer is often
          faster, as the emulator needs not to copy the data,
          only the pointer is used.</p>
        <p>A driver binary allocated in the driver, with
          <span class="code">driver_alloc_binary</span>, is to be freed in the driver
          (unless otherwise stated)
          with <span class="code">driver_free_binary</span>. (Notice that this does not
          necessarily deallocate it, if the driver is still referred
          in the emulator, the ref-count will not go to zero.)</p>
        <p>Driver binaries are used in the <span class="code">driver_output2</span> and
          <span class="code">driver_outputv</span> calls, and in the queue. Also the
          driver callback <span class="bold_code bc-15"><a href="driver_entry.html#outputv"><span class="code">outputv</span></a></span> uses driver binaries.</p>
        <p>If the driver for some reason wants to keep a
          driver binary around, for example in a static variable, the
          reference count is to be incremented, and the binary can later
          be freed in the <span class="bold_code bc-15"><a href="driver_entry.html#stop"><span class="code">stop</span></a></span> callback, with <span class="code">driver_free_binary</span>.</p>
        <p>Notice that as a driver binary is shared by the driver and
          the emulator. A binary received from the emulator or sent to
          the emulator must not be changed by the driver.</p>
        <p>Since ERTS 5.5 (Erlang/OTP R11B), <span class="code">orig_bytes</span> is
          guaranteed to be properly aligned for storage of an array of
          doubles (usually 8-byte aligned).</p>
      </dd>
      <dt><strong><span class="code">ErlDrvData</span></strong></dt>
      <dd>
        <p>A handle to driver-specific data,
          passed to the driver callbacks. It is a pointer, and is
          most often type cast to a specific pointer in the driver.</p>
      </dd>
      <dt><strong><span class="code">SysIOVec</span></strong></dt>
      <dd>
        <p>A system I/O vector, as used by <span class="code">writev</span> on
          Unix and <span class="code">WSASend</span> on Win32. It is used in
          <span class="code">ErlIOVec</span>.</p>
      </dd>
      <dt><strong><a name="ErlIOVec"></a><span class="code">ErlIOVec</span></strong></dt>
      <dd>
        <div class="example"><pre>typedef struct ErlIOVec {
  int vsize;
  ErlDrvSizeT size;
  SysIOVec* iov;
  ErlDrvBinary** binv;
} ErlIOVec;</pre></div>
        <p>The I/O vector used by the emulator and drivers is a list
          of binaries, with a <span class="code">SysIOVec</span> pointing to the buffers
          of the binaries. It is used in <span class="code">driver_outputv</span> and the
          <span class="bold_code bc-15"><a href="driver_entry.html#outputv"><span class="code">outputv</span></a></span>
          driver callback. Also, the driver queue is an
          <span class="code">ErlIOVec</span>.</p>
      </dd>
      <dt><strong><span class="code">ErlDrvMonitor</span></strong></dt>
      <dd>
        <p>When a driver creates a monitor for a process, a
          <span class="code">ErlDrvMonitor</span> is filled in. This is an opaque
          data type that can be assigned to, but not compared without
          using the supplied compare function (that is, it behaves like
          a struct).</p>
        <p>The driver writer is to provide the memory for storing the
          monitor when calling <span class="bold_code bc-17"><a href="#driver_monitor_process"><span class="code">driver_monitor_process</span></a></span>. The
          address of the data is not stored outside of the driver, so
          <span class="code">ErlDrvMonitor</span> can be used as any other data, it
          can be copied, moved in memory, forgotten, and so on.</p>
      </dd>
      <dt><strong><a name="ErlDrvNowData"></a><span class="code">ErlDrvNowData</span></strong></dt>
      <dd>
        <p>The <span class="code">ErlDrvNowData</span> structure holds a time stamp
          consisting of three values measured from some arbitrary
          point in the past. The three structure members are:</p>
        <dl>
          <dt><strong><span class="code">megasecs</span></strong></dt>
          <dd>The number of whole megaseconds elapsed since the arbitrary
            point in time</dd>
          <dt><strong><span class="code">secs</span></strong></dt>
          <dd>The number of whole seconds elapsed since the arbitrary
            point in time</dd>
          <dt><strong><span class="code">microsecs</span></strong></dt>
          <dd>The number of whole microseconds elapsed since the arbitrary
            point in time</dd>
        </dl>
      </dd>
      <dt><strong><a name="ErlDrvPDL"></a><span class="code">ErlDrvPDL</span></strong></dt>
      <dd>
        <p>If certain port-specific data must be accessed from other
          threads than those calling the driver callbacks, a port data lock
          can be used to synchronize the operations on the data.
          Currently, the only port-specific data that the emulator
          associates with the port data lock is the driver queue.</p>
        <p>Normally a driver instance has no port data lock. If
          the driver instance wants to use a port data lock, it must
          create the port data lock by calling
          <span class="bold_code bc-17"><a href="#driver_pdl_create"><span class="code">driver_pdl_create</span></a></span>.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>Once the port data lock has been created, every
            access to data associated with the port data lock must be done
            while the port data lock is locked. The port data lock is
            locked and unlocked by
            <span class="bold_code bc-17"><a href="#driver_pdl_lock"><span class="code">driver_pdl_lock</span></a></span>, and
            <span class="bold_code bc-17"><a href="#driver_pdl_unlock"><span class="code">driver_pdl_unlock</span></a></span>, respectively.</p>
        </p></div>
</div>
        <p>A port data lock is reference counted, and when the reference
          count reaches zero, it is destroyed. The emulator at
          least increments the reference count once when the lock is
          created and decrements it once the port associated with
          the lock terminates. The emulator also increments the
          reference count when an async job is enqueued and decrements
          it when an async job has been invoked.
          Also, the driver is responsible for ensuring that
          the reference count does not reach zero before the last use
          of the lock by the driver has been made. The reference count
          can be read, incremented, and decremented by
          <span class="bold_code bc-17"><a href="#driver_pdl_get_refc"><span class="code">driver_pdl_get_refc</span></a></span>,
          <span class="bold_code bc-17"><a href="#driver_pdl_inc_refc"><span class="code">driver_pdl_inc_refc</span></a></span>, and
          <span class="bold_code bc-17"><a href="#driver_pdl_dec_refc"><span class="code">driver_pdl_dec_refc</span></a></span>, respectively.</p>
      </dd>
      <dt><strong><a name="ErlDrvTid"></a><span class="code">ErlDrvTid</span></strong></dt>
      <dd>
        <p>Thread identifier.</p>
	<p>See also <span class="bold_code bc-17"><a href="#erl_drv_thread_create"><span class="code">erl_drv_thread_create</span></a></span>,
	   <span class="bold_code bc-17"><a href="#erl_drv_thread_exit"><span class="code">erl_drv_thread_exit</span></a></span>,
	   <span class="bold_code bc-17"><a href="#erl_drv_thread_join"><span class="code">erl_drv_thread_join</span></a></span>,
	   <span class="bold_code bc-17"><a href="#erl_drv_thread_self"><span class="code">erl_drv_thread_self</span></a></span>, and
	   <span class="bold_code bc-17"><a href="#erl_drv_equal_tids"><span class="code">erl_drv_equal_tids</span></a></span>.</p>
      </dd>
      <dt><strong><a name="ErlDrvThreadOpts"></a><span class="code">ErlDrvThreadOpts</span></strong></dt>
      <dd>
        <div class="example"><pre>int suggested_stack_size;</pre></div>
        <p>Thread options structure passed to
	  <span class="bold_code bc-17"><a href="#erl_drv_thread_create"><span class="code">erl_drv_thread_create</span></a></span>.
	    The following fields exists:</p>
        <dl>
          <dt><strong><span class="code">suggested_stack_size</span></strong></dt>
          <dd>A suggestion, in kilowords, on how large a stack to use.
            A value &lt; 0 means default size.
	  </dd>
        </dl>
	<p>See also <span class="bold_code bc-17"><a href="#erl_drv_thread_opts_create"><span class="code">erl_drv_thread_opts_create</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_thread_opts_destroy"><span class="code">erl_drv_thread_opts_destroy</span></a></span>, and
	  <span class="bold_code bc-17"><a href="#erl_drv_thread_create"><span class="code">erl_drv_thread_create</span></a></span>.</p>
      </dd>
      <dt><strong><a name="ErlDrvMutex"></a><span class="code">ErlDrvMutex</span></strong></dt>
      <dd>
        <p>Mutual exclusion lock. Used for synchronizing access to shared data.
	   Only one thread at a time can lock a mutex.</p>
	<p>See also <span class="bold_code bc-17"><a href="#erl_drv_mutex_create"><span class="code">erl_drv_mutex_create</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_mutex_destroy"><span class="code">erl_drv_mutex_destroy</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_mutex_lock"><span class="code">erl_drv_mutex_lock</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_mutex_trylock"><span class="code">erl_drv_mutex_trylock</span></a></span>, and
	  <span class="bold_code bc-17"><a href="#erl_drv_mutex_unlock"><span class="code">erl_drv_mutex_unlock</span></a></span>.</p>
      </dd>
      <dt><strong><a name="ErlDrvCond"></a><span class="code">ErlDrvCond</span></strong></dt>
      <dd>
        <p>Condition variable. Used when threads must wait for a specific
	  condition to appear before continuing execution. Condition variables
	  must be used with associated mutexes.</p>
	<p>See also <span class="bold_code bc-17"><a href="#erl_drv_cond_create"><span class="code">erl_drv_cond_create</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_cond_destroy"><span class="code">erl_drv_cond_destroy</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_cond_signal"><span class="code">erl_drv_cond_signal</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_cond_broadcast"><span class="code">erl_drv_cond_broadcast</span></a></span>, and
	  <span class="bold_code bc-17"><a href="#erl_drv_cond_wait"><span class="code">erl_drv_cond_wait</span></a></span>.</p>
      </dd>
      <dt><strong><a name="ErlDrvRWLock"></a><span class="code">ErlDrvRWLock</span></strong></dt>
      <dd>
        <p>Read/write lock. Used to allow multiple threads to read shared data
	  while only allowing one thread to write the same data. Multiple
	  threads can read lock an rwlock at the same time, while only
	  one thread can read/write lock an rwlock at a time.</p>
	<p>See also <span class="bold_code bc-17"><a href="#erl_drv_rwlock_create"><span class="code">erl_drv_rwlock_create</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_rwlock_destroy"><span class="code">erl_drv_rwlock_destroy</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_rwlock_rlock"><span class="code">erl_drv_rwlock_rlock</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_rwlock_tryrlock"><span class="code">erl_drv_rwlock_tryrlock</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_rwlock_runlock"><span class="code">erl_drv_rwlock_runlock</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_rwlock_rwlock"><span class="code">erl_drv_rwlock_rwlock</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_rwlock_tryrwlock"><span class="code">erl_drv_rwlock_tryrwlock</span></a></span>, and
	  <span class="bold_code bc-17"><a href="#erl_drv_rwlock_rwunlock"><span class="code">erl_drv_rwlock_rwunlock</span></a></span>.</p>
      </dd>
      <dt><strong><a name="ErlDrvTSDKey"></a><span class="code">ErlDrvTSDKey</span></strong></dt>
      <dd>
        <p>Key that thread-specific data can be associated with.</p>
	<p>See also <span class="bold_code bc-17"><a href="#erl_drv_tsd_key_create"><span class="code">erl_drv_tsd_key_create</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_tsd_key_destroy"><span class="code">erl_drv_tsd_key_destroy</span></a></span>,
	  <span class="bold_code bc-17"><a href="#erl_drv_tsd_set"><span class="code">erl_drv_tsd_set</span></a></span>, and
	  <span class="bold_code bc-17"><a href="#erl_drv_tsd_get"><span class="code">erl_drv_tsd_get</span></a></span>.</p>
      </dd>
      <dt><strong><a name="ErlDrvTime"></a><span class="code">ErlDrvTime</span></strong></dt>
      <dd>
        <p>A signed 64-bit integer type for time representation.</p>
      </dd>
      <dt><strong><a name="ErlDrvTimeUnit"></a><span class="code">ErlDrvTimeUnit</span></strong></dt>
      <dd>
        <p>An enumeration of time units supported by the driver API:</p>
        <dl>
	  <dt><strong><span class="code">ERL_DRV_SEC</span></strong></dt>
	  <dd>Seconds</dd>
	  <dt><strong><span class="code">ERL_DRV_MSEC</span></strong></dt>
	  <dd>Milliseconds</dd>
	  <dt><strong><span class="code">ERL_DRV_USEC</span></strong></dt>
	  <dd>Microseconds</dd>
	  <dt><strong><span class="code">ERL_DRV_NSEC</span></strong></dt>
	  <dd>Nanoseconds</dd>
        </dl>
      </dd>
    </dl>
  </div>

  <h3><a name="exports" href="#exports">Exports</a></h3>
<div class="exports-body">
    <p><a name="add_driver_entry"><span class="bold_code bc-7">void add_driver_entry(ErlDrvEntry
        *de)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="add_driver_entry"></a>
        <p>Adds a driver entry to the list of drivers known by Erlang.
          The <span class="bold_code bc-15"><a href="driver_entry.html#init"><span class="code">init</span></a></span>
          function of parameter <span class="code">de</span> is called.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>To use this function for adding drivers residing in
            dynamically loaded code is dangerous. If the driver code
            for the added driver resides in the same dynamically
            loaded module (that is, <span class="code">.so</span> file) as a normal
            dynamically loaded driver (loaded with the <span class="code">erl_ddll</span>
            interface), the caller is to call
            <span class="bold_code bc-17"><a href="#driver_lock_driver"><span class="code">driver_lock_driver</span></a></span> before
            adding driver entries.</p>
          <p><strong>Use of this function is generally deprecated.</strong></p>
        </p></div>
</div>
      </p></div>

    <p><a name="driver_alloc"><span class="bold_code bc-7">void *driver_alloc(ErlDrvSizeT size)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_alloc"></a>
        <p>Allocates a memory block of the size specified
          in <span class="code">size</span>, and returns it. This fails only on out of
          memory, in which case <span class="code">NULL</span> is returned. (This is most
          often a wrapper for <span class="code">malloc</span>).</p>
        <p>Memory allocated must be explicitly freed with a corresponding
          call to <span class="bold_code bc-17"><a href="#driver_free"><span class="code">driver_free</span></a></span>
          (unless otherwise stated).</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="driver_alloc_binary"><span class="bold_code bc-7">ErlDrvBinary *driver_alloc_binary(ErlDrvSizeT size)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_alloc_binary"></a>
        <p>Allocates a driver binary with a memory block
          of at least <span class="code">size</span> bytes, and returns a pointer to it,
          or <span class="code">NULL</span> on failure (out of memory). When a driver binary has
          been sent to the emulator, it must not be changed. Every
          allocated binary is to be freed by a corresponding call to
          <span class="bold_code bc-17"><a href="#driver_free_binary"><span class="code">driver_free_binary</span></a></span> (unless otherwise stated).</p>
        <p>Notice that a driver binary has an internal reference counter.
          This means that calling <span class="code">driver_free_binary</span>, it may not
          actually dispose of it. If it is sent to the emulator, it can
          be referenced there.</p>
        <p>The driver binary has a field, <span class="code">orig_bytes</span>, which
          marks the start of the data in the binary.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="driver_async"><span class="bold_code bc-7">long driver_async(ErlDrvPort port, unsigned
        int* key, void (*async_invoke)(void*), void* async_data, void
        (*async_free)(void*))</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_async"></a>
        <p>Performs an asynchronous call. The function
          <span class="code">async_invoke</span> is invoked in a thread separate from the
          emulator thread. This enables the driver to perform
          time-consuming, blocking operations without blocking the
          emulator.</p>
        <p>The async thread pool size can be set with command-line argument
          <span class="bold_code bc-15"><a href="erl.html#async_thread_pool_size"><span class="code">+A</span></a></span>
          in <span class="bold_code bc-19"><a href="erl.html"><span class="code">erl(1)</span></a></span>.
          If an async thread pool is unavailable, the call is made
          synchronously in the thread calling <span class="code">driver_async</span>. The
          current number of async threads in the async thread pool can be
          retrieved through <span class="bold_code bc-17"><a href="#driver_system_info"><span class="code">driver_system_info</span></a></span>.</p>
        <p>If a thread pool is available, a thread is used.
          If argument <span class="code">key</span> is <span class="code">NULL</span>, the threads from the
          pool are used in a round-robin way, each call to
          <span class="code">driver_async</span> uses the next thread in the pool. With
          argument <span class="code">key</span> set, this behavior is changed. The two
          same values of <span class="code">*key</span> always get the same thread.</p>
        <p>To ensure that a driver instance always uses the same
          thread, the following call can be used:</p>
        <div class="example"><pre>unsigned int myKey = driver_async_port_key(myPort);

r = driver_async(myPort, &amp;myKey, myData, myFunc);    </pre></div>
        <p>It is enough to initialize <span class="code">myKey</span> once for each
          driver instance.</p>
        <p>If a thread is already working, the calls are
          queued up and executed in order. Using the same thread for
          each driver instance ensures that the calls are made in sequence.</p>
        <p>The <span class="code">async_data</span> is the argument to the functions
          <span class="code">async_invoke</span> and <span class="code">async_free</span>. It is typically a
          pointer to a structure containing a pipe or event that
          can be used to signal that the async operation completed.
          The data is to be freed in <span class="code">async_free</span>.</p>
        <p>When the async operation is done,
          <span class="bold_code bc-15"><a href="driver_entry.html#ready_async"><span class="code">ready_async</span></a></span> driver
          entry function is called. If <span class="code">ready_async</span> is <span class="code">NULL</span> in
          the driver entry, the <span class="code">async_free</span> function is called
          instead.</p>
        <p>The return value is <span class="code">-1</span> if the <span class="code">driver_async</span> call
          fails.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>As from ERTS 5.5.4.3 the default stack size for
            threads in the async-thread pool is 16 kilowords,
            that is, 64 kilobyte on 32-bit architectures.
            This small default size has been chosen because the
            amount of async-threads can be quite large. The
            default stack size is enough for drivers delivered
            with Erlang/OTP, but is possibly not sufficiently large
            for other dynamically linked-in drivers that use the
            <span class="code">driver_async</span> functionality. A suggested stack size
            for threads in the async-thread pool can be configured
            through command-line argument
            <span class="bold_code bc-15"><a href="erl.html#async_thread_stack_size"><span class="code">+a</span></a></span>
            in <span class="bold_code bc-19"><a href="erl.html"><span class="code">erl(1)</span></a></span>.</p>
        </p></div>
</div>
      </p></div>

    <p><a name="driver_async_port_key"><span class="bold_code bc-7">unsigned int driver_async_port_key(ErlDrvPort
        port)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_async_port_key"></a>
        <p>Calculates a key for later use in <span class="bold_code bc-17"><a href="#driver_async"><span class="code">driver_async</span></a></span>. The keys are
          evenly distributed so that a fair mapping between port IDs
          and async thread IDs is achieved.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>Before Erlang/OTP R16, the port ID could be used as a key
            with proper casting, but after the rewrite of the port
            subsystem, this is no longer the case. With this function, you
            can achieve the same distribution based on port IDs as before
            Erlang/OTP R16.</p>
        </p></div>
</div>
      </p></div>

    <p><a name="driver_binary_dec_refc"><span class="bold_code bc-7">long driver_binary_dec_refc(ErlDrvBinary *bin)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_binary_dec_refc"></a>
        <p>Decrements the reference count on <span class="code">bin</span> and returns
          the reference count reached after the decrement.</p>
        <p>This function is thread-safe.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>The reference count of driver binary is normally to be decremented
            by calling <span class="bold_code bc-17"><a href="#driver_free_binary"><span class="code">driver_free_binary</span></a></span>.</p>
          <p><span class="code">driver_binary_dec_refc</span> does <strong>not</strong> free
            the binary if the reference count reaches zero. <strong>Only</strong>
            use <span class="code">driver_binary_dec_refc</span> when you are sure
            <strong>not</strong> to reach a reference count of zero.</p>
        </p></div>
</div>
      </p></div>

    <p><a name="driver_binary_get_refc"><span class="bold_code bc-7">long driver_binary_get_refc(ErlDrvBinary *bin)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_binary_get_refc"></a>
        <p>Returns the current reference count on <span class="code">bin</span>.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="driver_binary_inc_refc"><span class="bold_code bc-7">long driver_binary_inc_refc(ErlDrvBinary *bin)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_binary_inc_refc"></a>
        <p>Increments the reference count on <span class="code">bin</span> and returns
          the reference count reached after the increment.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="driver_caller"><span class="bold_code bc-7">ErlDrvTermData driver_caller(ErlDrvPort
        port)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_caller"></a>
        <p>Returns the process ID of the process that
          made the current call to the driver. The process ID can be used with
          <span class="bold_code bc-17"><a href="#driver_send_term"><span class="code">driver_send_term</span></a></span>
          to send back data to the caller.
          <span class="code">driver_caller</span> only returns valid data
          when currently executing in one of the following driver callbacks:</p>
        <dl>
          <dt><strong><span class="bold_code bc-15"><a href="driver_entry.html#start"><span class="code">start</span></a></span></strong></dt>
          <dd>Called from <span class="bold_code bc-18"><a href="../apps/erlang/open_port/2.html"><span class="code">erlang:open_port/2</span></a></span>.</dd>
          <dt><strong><span class="bold_code bc-15"><a href="driver_entry.html#output"><span class="code">output</span></a></span></strong></dt>
          <dd>Called from <span class="bold_code bc-18"><a href="../apps/erlang/send/2.html"><span class="code">erlang:send/2</span></a></span> and
            <span class="bold_code bc-18"><a href="../apps/erlang/port_command/2.html"><span class="code">erlang:port_command/2</span></a></span>.</dd>
          <dt><strong><span class="bold_code bc-15"><a href="driver_entry.html#outputv"><span class="code">outputv</span></a></span></strong></dt>
          <dd>Called from <span class="bold_code bc-18"><a href="../apps/erlang/send/2.html"><span class="code">erlang:send/2</span></a></span> and
            <span class="bold_code bc-18"><a href="../apps/erlang/port_command/2.html"><span class="code">erlang:port_command/2</span></a></span>.</dd>
          <dt><strong><span class="bold_code bc-15"><a href="driver_entry.html#control"><span class="code">control</span></a></span></strong></dt>
          <dd>Called from <span class="bold_code bc-18"><a href="../apps/erlang/port_control/3.html"><span class="code">erlang:port_control/3</span></a></span>.</dd>
          <dt><strong><span class="bold_code bc-15"><a href="driver_entry.html#call"><span class="code">call</span></a></span></strong></dt>
          <dd>Called from <span class="bold_code bc-18"><a href="../apps/erlang/port_call/3.html"><span class="code">erlang:port_call/3</span></a></span>.</dd>
        </dl>
        <p>Notice that this function is <strong>not</strong> thread-safe, not
          even when the emulator with SMP support is used.</p>
      </p></div>

    <p><a name="driver_cancel_timer"><span class="bold_code bc-7">int driver_cancel_timer(ErlDrvPort port)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_cancel_timer"></a>
        <p>Cancels a timer set with
          <span class="bold_code bc-17"><a href="#driver_set_timer"><span class="code">driver_set_timer</span></a></span>.</p>
        <p>The return value is <span class="code">0</span>.</p>
      </p></div>

    <p><a name="driver_compare_monitors"><span class="bold_code bc-7">int driver_compare_monitors(const ErlDrvMonitor
        *monitor1, const ErlDrvMonitor *monitor2)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_compare_monitors"></a>
        <p>Compares two <span class="code">ErlDrvMonitor</span>s.
          Can also be used to imply some artificial order on monitors,
          for whatever reason.</p>
        <p>Returns <span class="code">0</span> if <span class="code">monitor1</span> and <span class="code">monitor2</span> are equal,
          &lt; <span class="code">0</span> if <span class="code">monitor1</span> &lt; <span class="code">monitor2</span>, and
          &gt; <span class="code">0</span> if <span class="code">monitor1</span> &gt; <span class="code">monitor2</span>.</p>
      </p></div>

    <p><a name="driver_connected"><span class="bold_code bc-7">ErlDrvTermData driver_connected(ErlDrvPort
        port)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_connected"></a>
        <p>Returns the port owner process.</p>
        <p>Notice that this function is <strong>not</strong> thread-safe, not
          even when the emulator with SMP support is used.</p>
      </p></div>

    <p><a name="driver_create_port"><span class="bold_code bc-7">ErlDrvPort driver_create_port(ErlDrvPort port,
        ErlDrvTermData owner_pid, char* name,
        ErlDrvData drv_data)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <p>Creates a new port executing the same driver
          code as the port creating the new port.</p>
        <dl>
          <dt><strong><span class="code">port</span></strong></dt>
          <dd>The port handle of the port (driver instance) creating
            the new port.</dd>
          <dt><strong><span class="code">owner_pid</span></strong></dt>
          <dd>The process ID of the Erlang process to become
            owner of the new port. This process will be linked
            to the new port. You usually want to use
            <span class="code">driver_caller(port)</span> as <span class="code">owner_pid</span>.</dd>
          <dt><strong><span class="code">name</span></strong></dt>
          <dd>The port name of the new port. You usually want to
            use the same port name as the driver name
            (<span class="bold_code bc-15"><a href="driver_entry.html#driver_name"><span class="code">driver_name</span></a></span> field of the
            <span class="bold_code bc-19"><a href="driver_entry.html"><span class="code">driver_entry</span></a></span>).
          </dd>
          <dt><strong><span class="code">drv_data</span></strong></dt>
          <dd>The driver-defined handle that is passed in later
            calls to driver callbacks. Notice that the
            <span class="bold_code bc-15"><a href="driver_entry.html#start">driver start callback</a></span> is not called for this new driver instance.
            The driver-defined handle is normally created in the
            <span class="bold_code bc-15"><a href="driver_entry.html#start">driver start callback</a></span>
            when a port is created through
            <span class="bold_code bc-15"><a href="erlang.html#open_port-2"><span class="code">erlang:open_port/2</span></a></span>.
          </dd>
        </dl>
        <p>The caller of <span class="code">driver_create_port</span> is allowed to
          manipulate the newly created port when <span class="code">driver_create_port</span>
          has returned. When
          <span class="bold_code bc-17"><a href="#smp_support">port level locking</a></span>
          is used, the creating port is only allowed to
          manipulate the newly created port until the current driver
          callback, which was called by the emulator, returns.</p>
      </p></div>

    <p><a name="driver_demonitor_process"><span class="bold_code bc-7">int driver_demonitor_process(ErlDrvPort port,
        const ErlDrvMonitor *monitor)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_demonitor_process"></a>
        <p>Cancels a monitor created earlier.</p>
        <p>Returns <span class="code">0</span> if a monitor was removed and &gt; 0 if the monitor
          no longer exists.</p>
      </p></div>

    <p><a name="driver_deq"><span class="bold_code bc-7">ErlDrvSizeT driver_deq(ErlDrvPort port,
        ErlDrvSizeT size)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_deq"></a>
        <p>Dequeues data by moving the head pointer
          forward in the driver queue by <span class="code">size</span> bytes. The data
          in the queue is deallocated.</p>
        <p>Returns the number of bytes remaining in the queue on success,
          otherwise <span class="code">-1</span>.</p>
        <p>This function can be called from any thread if a
          <span class="bold_code bc-17"><a href="#ErlDrvPDL">port data lock</a></span>
          associated with the <span class="code">port</span> is locked by the calling
          thread during the call.</p>
      </p></div>

    <p><a name="driver_enq"><span class="bold_code bc-7">int driver_enq(ErlDrvPort port, char* buf,
        ErlDrvSizeT len)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_enq"></a>
        <p>Enqueues data in the driver queue. The data in
          <span class="code">buf</span> is copied (<span class="code">len</span> bytes) and placed at the
          end of the driver queue. The driver queue is normally used
          in a FIFO way.</p>
        <p>The driver queue is available to queue output from the
          emulator to the driver (data from the driver to the emulator
          is queued by the emulator in normal Erlang message
          queues). This can be useful if the driver must wait for
          slow devices, and so on, and wants to yield back to the
          emulator. The driver queue is implemented as an <span class="code">ErlIOVec</span>.</p>
        <p>When the queue contains data, the driver does not close until
          the queue is empty.</p>
        <p>The return value is <span class="code">0</span>.</p>
        <p>This function can be called from any thread if a
          <span class="bold_code bc-17"><a href="#ErlDrvPDL">port data lock</a></span>
          associated with the <span class="code">port</span> is locked by the calling
          thread during the call.</p>
      </p></div>

    <p><a name="driver_enq_bin"><span class="bold_code bc-7">int driver_enq_bin(ErlDrvPort port,
        ErlDrvBinary *bin, ErlDrvSizeT offset, ErlDrvSizeT len)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_enq_bin"></a>
        <p>Enqueues a driver binary in the driver
          queue. The data in <span class="code">bin</span> at <span class="code">offset</span> with length
          <span class="code">len</span> is placed at the end of the queue. This function
          is most often faster than
          <span class="bold_code bc-17"><a href="#driver_enq"><span class="code">driver_enq</span></a></span>,
          because no data must be copied.</p>
        <p>This function can be called from any thread if a
          <span class="bold_code bc-17"><a href="#ErlDrvPDL">port data lock</a></span>
          associated with the <span class="code">port</span> is locked by the calling
          thread during the call.</p>
        <p>The return value is <span class="code">0</span>.</p>
      </p></div>

    <p><a name="driver_enqv"><span class="bold_code bc-7">int driver_enqv(ErlDrvPort port, ErlIOVec *ev,
        ErlDrvSizeT skip)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_enqv"></a>
        <p>Enqueues the data in <span class="code">ev</span>, skipping the
          first <span class="code">skip</span> bytes of it, at the end of the driver
          queue. It is faster than
          <span class="bold_code bc-17"><a href="#driver_enq"><span class="code">driver_enq</span></a></span>,
          because no data must be copied.</p>
        <p>The return value is <span class="code">0</span>.</p>
        <p>This function can be called from any thread if a
          <span class="bold_code bc-17"><a href="#ErlDrvPDL">port data lock</a></span>
          associated with the <span class="code">port</span> is locked by the calling
          thread during the call.</p>
      </p></div>

    <p><a name="driver_failure"><span class="bold_code bc-7">int driver_failure(ErlDrvPort port, int
        error)</span></a><br><a name="driver_failure_atom"><span class="bold_code bc-7">int driver_failure_atom(ErlDrvPort port, char
        *string)</span></a><br><a name="driver_failure_posix"><span class="bold_code bc-7">int driver_failure_posix(ErlDrvPort port, int
        error)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_failure_atom"></a>
        <a name="driver_failure_posix"></a>
        <a name="driver_failure"></a>
        <p>Signals to Erlang that the driver has
          encountered an error and is to be closed. The port is
          closed and the tuple <span class="code">{'EXIT', error, Err}</span> is sent to
          the port owner process, where error is an error atom
          (<span class="code">driver_failure_atom</span> and
          <span class="code">driver_failure_posix</span>) or an integer
          (<span class="code">driver_failure</span>).</p>
        <p>The driver is to fail only when in severe error situations,
          when the driver cannot possibly keep open, for example,
          buffer allocation gets out of memory. For normal errors
          it is more appropriate to send error codes with
          <span class="bold_code bc-17"><a href="#driver_output"><span class="code">driver_output</span></a></span>.</p>
        <p>The return value is <span class="code">0</span>.</p>
      </p></div>

    <p><a name="driver_failure_eof"><span class="bold_code bc-7">int driver_failure_eof(ErlDrvPort
        port)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_failure_eof"></a>
        <p>Signals to Erlang that the driver has
          encountered an EOF and is to be closed, unless the port was
          opened with option <span class="code">eof</span>, in which case <span class="code">eof</span> is sent
          to the port. Otherwise the port is closed and an
          <span class="code">'EXIT'</span> message is sent to the port owner process.</p>
        <p>The return value is <span class="code">0</span>.</p>
      </p></div>

    <p><a name="driver_free"><span class="bold_code bc-7">void driver_free(void *ptr)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_free"></a>
        <p>Frees the memory pointed to by <span class="code">ptr</span>. The
          memory is to have been allocated with
          <span class="code">driver_alloc</span>. All allocated memory is to be
          deallocated, only once. There is no garbage collection in
          drivers.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="driver_free_binary"><span class="bold_code bc-7">void driver_free_binary(ErlDrvBinary *bin)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_free_binary"></a>
        <p>Frees a driver binary <span class="code">bin</span>, allocated previously with
        <span class="bold_code bc-17"><a href="#driver_alloc_binary"><span class="code">driver_alloc_binary</span></a></span>. As binaries
          in Erlang are reference counted, the binary can still be around.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="driver_get_monitored_process"><span class="bold_code bc-7">ErlDrvTermData driver_get_monitored_process(ErlDrvPort port, const
        ErlDrvMonitor *monitor)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_get_monitored_process"></a>
        <p>Returns the process ID associated with a living
          monitor. It can be used in the
          <span class="bold_code bc-15"><a href="driver_entry.html#process_exit"><span class="code">process_exit</span></a></span> callback to
          get the process identification for the exiting process.</p>
        <p>Returns <span class="code">driver_term_nil</span> if the monitor no longer exists.</p>
      </p></div>

    <p><a name="driver_get_now"><span class="bold_code bc-7">int driver_get_now(ErlDrvNowData *now)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_get_now"></a>
	<div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p><strong>This function is deprecated. Do not use it.</strong> Use
            <span class="bold_code bc-17"><a href="#erl_drv_monotonic_time"><span class="code">erl_drv_monotonic_time</span></a></span> (perhaps in combination with
            <span class="bold_code bc-17"><a href="#erl_drv_time_offset"><span class="code">erl_drv_time_offset</span></a></span>) instead.</p>
        </p></div>
</div>
        <p>Reads a time stamp into the memory pointed to by
          parameter <span class="code">now</span>. For information about specific fields, see
          <span class="bold_code bc-17"><a href="#ErlDrvNowData"><span class="code">ErlDrvNowData</span></a></span>.</p>
        <p>The return value is <span class="code">0</span>, unless the <span class="code">now</span> pointer is
          invalid, in which case it is &lt; <span class="code">0</span>.</p>
      </p></div>

    <p><a name="driver_lock_driver"><span class="bold_code bc-7">int driver_lock_driver(ErlDrvPort
        port)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_lock_driver"></a>
        <p>Locks the driver used by the port <span class="code">port</span>
          in memory for the rest of the emulator process'
          lifetime. After this call, the driver behaves as one of Erlang's
          statically linked-in drivers.</p>
      </p></div>

    <p><a name="driver_mk_atom"><span class="bold_code bc-7">ErlDrvTermData driver_mk_atom(char*
        string)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_mk_atom"></a>
        <p>Returns an atom given a name
          <span class="code">string</span>. The atom is created and does not change, so the
          return value can be saved and reused, which is faster than
          looking up the atom several times.</p>
        <p>Notice that this function is <strong>not</strong> thread-safe, not
          even when the emulator with SMP support is used.</p>
      </p></div>

    <p><a name="driver_mk_port"><span class="bold_code bc-7">ErlDrvTermData driver_mk_port(ErlDrvPort
        port)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_mk_port"></a>
        <p>Converts a port handle to the Erlang term format, usable in
          <span class="bold_code bc-17"><a href="#erl_drv_output_term"><span class="code">erl_drv_output_term</span></a></span> and 
          <span class="bold_code bc-17"><a href="#erl_drv_send_term"><span class="code">erl_drv_send_term</span></a></span>.</p>
        <p>Notice that this function is <strong>not</strong> thread-safe, not
          even when the emulator with SMP support is used.</p>
      </p></div>

    <p><a name="driver_monitor_process"><span class="bold_code bc-7">int driver_monitor_process(ErlDrvPort port,
        ErlDrvTermData process, ErlDrvMonitor *monitor)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_monitor_process"></a>
        <p>Starts monitoring a process from a driver. When a process is
          monitored, a process exit results in a call to the provided
          <span class="bold_code bc-15"><a href="driver_entry.html#process_exit"><span class="code">process_exit</span></a></span> callback
          in the <span class="bold_code bc-19"><a href="driver_entry.html"><span class="code">ErlDrvEntry</span></a></span>
          structure. The <span class="code">ErlDrvMonitor</span> structure is filled in, for later
          removal or compare.</p>
        <p>Parameter <span class="code">process</span> is to be the return value of an
          earlier call to <span class="bold_code bc-17"><a href="#driver_caller"><span class="code">driver_caller</span></a></span> or
          <span class="bold_code bc-17"><a href="#driver_connected"><span class="code">driver_connected</span></a></span>
          call.</p>
        <p>Returns <span class="code">0</span> on success, &lt; 0 if no callback is
          provided, and &gt; 0 if the process is no longer alive.</p>
      </p></div>

    <p><a name="driver_output"><span class="bold_code bc-7">int driver_output(ErlDrvPort port, char *buf,
        ErlDrvSizeT len)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_output"></a>
        <p>Sends data from the driver up to the emulator. The data is received
          as terms or binary data, depending on how the driver port was
          opened.</p>
        <p>The data is queued in the port owner process' message
          queue. Notice that this does not yield to the emulator (as
          the driver and the emulator run in the same thread).</p>
        <p>Parameter <span class="code">buf</span> points to the data to send, and
          <span class="code">len</span> is the number of bytes.</p>
        <p>The return value for all output functions is <span class="code">0</span> for normal use.
          If the driver is used for distribution, it can fail and return
          <span class="code">-1</span>.</p>
      </p></div>

    <p><a name="driver_output_binary"><span class="bold_code bc-7">int driver_output_binary(ErlDrvPort port, char
        *hbuf, ErlDrvSizeT hlen, ErlDrvBinary* bin, ErlDrvSizeT offset,
        ErlDrvSizeT len)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_output_binary"></a>
        <p>Sends data to a port owner process from a
          driver binary. It has a header buffer (<span class="code">hbuf</span>
          and <span class="code">hlen</span>) just like
          <span class="bold_code bc-17"><a href="#driver_output2"><span class="code">driver_output2</span></a></span>.
          Parameter <span class="code">hbuf</span> can be <span class="code">NULL</span>.</p>
        <p>Parameter <span class="code">offset</span> is an offset into the binary and
          <span class="code">len</span> is the number of bytes to send.</p>
        <p>Driver binaries are created with
          <span class="bold_code bc-17"><a href="#driver_alloc_binary"><span class="code">driver_alloc_binary</span></a></span>.</p>
        <p>The data in the header is sent as a list and the binary as
          an Erlang binary in the tail of the list.</p>
        <p>For example, if <span class="code">hlen</span> is <span class="code">2</span>, the port owner process
          receives <span class="code">[H1, H2 | &lt;&lt;T&gt;&gt;]</span>.</p>
        <p>The return value is <span class="code">0</span> for normal use.</p>
        <p>Notice that, using the binary syntax in Erlang, the driver
          application can match the header directly from the binary,
          so the header can be put in the binary, and <span class="code">hlen</span> can be set
          to <span class="code">0</span>.</p>
      </p></div>

    <p><a name="driver_output_term"><span class="bold_code bc-7">int driver_output_term(ErlDrvPort port,
        ErlDrvTermData* term, int n)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_output_term"></a>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p><strong>This function is deprecated.</strong>
            Use <span class="bold_code bc-17"><a href="#erl_drv_send_term"><span class="code">erl_drv_output_term</span></a></span>instead.</p>
        </p></div>
</div>
        <p>Parameters <span class="code">term</span> and <span class="code">n</span> work as in
          <span class="bold_code bc-17"><a href="#erl_drv_output_term"><span class="code">erl_drv_output_term</span></a></span>.</p>
        <p>Notice that this function is <strong>not</strong> thread-safe, not
          even when the emulator with SMP support is used.</p>
      </p></div>

    <p><a name="driver_output2"><span class="bold_code bc-7">int driver_output2(ErlDrvPort port, char *hbuf,
        ErlDrvSizeT hlen, char *buf, ErlDrvSizeT len)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_output2"></a>
        <p>First sends <span class="code">hbuf</span>
          (length in <span class="code">hlen</span>) data as a list, regardless of port
          settings. Then sends <span class="code">buf</span> as a binary or list.
          For example, if <span class="code">hlen</span> is <span class="code">3</span>, the port owner process
          receives <span class="code">[H1, H2, H3 | T]</span>.</p>
        <p>The point of sending data as a list header, is to facilitate
          matching on the data received.</p>
        <p>The return value is <span class="code">0</span> for normal use.</p>
      </p></div>

    <p><a name="driver_outputv"><span class="bold_code bc-7">int driver_outputv(ErlDrvPort port, char* hbuf,
        ErlDrvSizeT hlen, ErlIOVec *ev, ErlDrvSizeT skip)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_outputv"></a>
        <p>Sends data from an I/O vector, <span class="code">ev</span>, to
          the port owner process. It has a header buffer (<span class="code">hbuf</span>
          and <span class="code">hlen</span>), just like <span class="bold_code bc-17"><a href="#driver_output2"><span class="code">driver_output2</span></a></span>.</p>
        <p>Parameter <span class="code">skip</span> is a number of bytes to skip of
          the <span class="code">ev</span> vector from the head.</p>
        <p>You get vectors of <span class="code">ErlIOVec</span> type from the driver
          queue (see below), and the
          <span class="bold_code bc-15"><a href="driver_entry.html#outputv"><span class="code">outputv</span></a></span>
          driver entry function. You can also make them yourself, if you want to
          send several <span class="code">ErlDrvBinary</span> buffers at once. Often
          it is faster to use
          <span class="bold_code bc-17"><a href="#driver_output"><span class="code">driver_output</span></a></span> or
          <span class="bold_code bc-17"><a href="#driver_output_binary"></a></span>.</p>
        <p>For example, if <span class="code">hlen</span> is <span class="code">2</span> and <span class="code">ev</span> points to an
          array of three binaries, the port owner process receives
          <span class="code">[H1, H2, &lt;&lt;B1&gt;&gt;, &lt;&lt;B2&gt;&gt; | &lt;&lt;B3&gt;&gt;]</span>.</p>
        <p>The return value is <span class="code">0</span> for normal use.</p>
        <p>The comment for <span class="code">driver_output_binary</span> also applies for
          <span class="code">driver_outputv</span>.</p>
      </p></div>

    <p><a name="driver_pdl_create"><span class="bold_code bc-7">ErlDrvPDL driver_pdl_create(ErlDrvPort port)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_pdl_create"></a>
        <p>Creates a port data lock associated with the <span class="code">port</span>.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>Once a port data lock has been created, it must be locked during
            all operations on the driver queue of the <span class="code">port</span>.</p>
        </p></div>
</div>
        <p>Returns a newly created port data lock on success,
          otherwise <span class="code">NULL</span>. The function fails
          if <span class="code">port</span> is invalid or if a port data lock already has
          been associated with the <span class="code">port</span>.</p>
      </p></div>

    <p><a name="driver_pdl_dec_refc"><span class="bold_code bc-7">long driver_pdl_dec_refc(ErlDrvPDL
        pdl)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_pdl_dec_refc"></a>
        <p>Decrements the reference count of
          the port data lock passed as argument (<span class="code">pdl</span>).</p>
        <p>The current reference count after the decrement has
          been performed is returned.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="driver_pdl_get_refc"><span class="bold_code bc-7">long driver_pdl_get_refc(ErlDrvPDL pdl)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_pdl_get_refc"></a>
        <p>Returns the current reference count of
          the port data lock passed as argument (<span class="code">pdl</span>).</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="driver_pdl_inc_refc"><span class="bold_code bc-7">long driver_pdl_inc_refc(ErlDrvPDL pdl)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_pdl_inc_refc"></a>
        <p>Increments the reference count of
          the port data lock passed as argument (<span class="code">pdl</span>).</p>
        <p>The current reference count after the increment has
          been performed is returned.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="driver_pdl_lock"><span class="bold_code bc-7">void driver_pdl_lock(ErlDrvPDL pdl)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_pdl_lock"></a>
        <p>Locks the port data lock passed as argument (<span class="code">pdl</span>).</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="driver_pdl_unlock"><span class="bold_code bc-7">void driver_pdl_unlock(ErlDrvPDL pdl)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_pdl_unlock"></a>
        <p>Unlocks the port data lock passed as argument (<span class="code">pdl</span>).</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="driver_peekq"><span class="bold_code bc-7">SysIOVec *driver_peekq(ErlDrvPort port, int
        *vlen)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_peekq"></a>
        <p>Retrieves the driver queue as a pointer to an
          array of <span class="code">SysIOVec</span>s. It also returns the number of
          elements in <span class="code">vlen</span>. This is one of two ways to get data
          out of the queue.</p>
        <p>Nothing is removed from the queue by this function, that must be done
          with <span class="bold_code bc-17"><a href="#driver_deq"><span class="code">driver_deq</span></a></span>.</p>
        <p>The returned array is suitable to use with the Unix system
          call <span class="code">writev</span>.</p>
        <p>This function can be called from any thread if a
          <span class="bold_code bc-17"><a href="#ErlDrvPDL">port data lock</a></span>
          associated with the <span class="code">port</span> is locked by the calling
          thread during the call.</p>
      </p></div>

    <p><a name="driver_peekqv"><span class="bold_code bc-7">ErlDrvSizeT driver_peekqv(ErlDrvPort port,
        ErlIOVec *ev)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_peekqv"></a>
        <p>Retrieves the driver queue into a supplied
	  <span class="code">ErlIOVec</span> <span class="code">ev</span>. It also returns the queue size.
	  This is one of two ways to get data out of the queue.</p>
	<p>If <span class="code">ev</span> is <span class="code">NULL</span>, all ones that is <span class="code">-1</span> type cast to
	  <span class="code">ErlDrvSizeT</span> are returned.</p>
        <p>Nothing is removed from the queue by this function, that must be done
          with <span class="bold_code bc-17"><a href="#driver_deq"><span class="code">driver_deq</span></a></span>.</p>
        <p>This function can be called from any thread if a
          <span class="bold_code bc-17"><a href="#ErlDrvPDL">port data lock</a></span>
          associated with the <span class="code">port</span> is locked by the calling
          thread during the call.</p>
      </p></div>

    <p><a name="driver_pushq"><span class="bold_code bc-7">int driver_pushq(ErlDrvPort port, char* buf,
        ErlDrvSizeT len)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_pushq"></a>
        <p>Puts data at the head of the driver queue. The
          data in <span class="code">buf</span> is copied (<span class="code">len</span> bytes) and placed
          at the beginning of the queue.</p>
        <p>The return value is <span class="code">0</span>.</p>
        <p>This function can be called from any thread if a
          <span class="bold_code bc-17"><a href="#ErlDrvPDL">port data lock</a></span>
          associated with the <span class="code">port</span> is locked by the calling
          thread during the call.</p>
      </p></div>

    <p><a name="driver_pushq_bin"><span class="bold_code bc-7">int driver_pushq_bin(ErlDrvPort port,
        ErlDrvBinary *bin, ErlDrvSizeT offset, ErlDrvSizeT len)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_pushq_bin"></a>
        <p>Puts data in the binary <span class="code">bin</span>, at
          <span class="code">offset</span> with length <span class="code">len</span> at the head of the
          driver queue. It is most often faster than
          <span class="bold_code bc-17"><a href="#driver_pushq"><span class="code">driver_pushq</span></a></span>,
          because no data must be copied.</p>
        <p>This function can be called from any thread if a
          <span class="bold_code bc-17"><a href="#ErlDrvPDL">port data lock</a></span>
          associated with the <span class="code">port</span> is locked by the calling
          thread during the call.</p>
        <p>The return value is <span class="code">0</span>.</p>
      </p></div>

    <p><a name="driver_pushqv"><span class="bold_code bc-7">int driver_pushqv(ErlDrvPort port, ErlIOVec
        *ev, ErlDrvSizeT skip)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_pushqv"></a>
        <p>Puts the data in <span class="code">ev</span>, skipping the first
          <span class="code">skip</span> bytes of it, at the head of the driver queue.
          It is faster than
          <span class="bold_code bc-17"><a href="#driver_pushq"><span class="code">driver_pushq</span></a></span>,
          because no data must be copied.</p>
        <p>The return value is <span class="code">0</span>.</p>
        <p>This function can be called from any thread if a
          <span class="bold_code bc-17"><a href="#ErlDrvPDL">port data lock</a></span>
          associated with the <span class="code">port</span> is locked by the calling
          thread during the call.</p>
      </p></div>

    <p><a name="driver_read_timer"><span class="bold_code bc-7">int driver_read_timer(ErlDrvPort port, unsigned
        long *time_left)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_read_timer"></a>
        <p>Reads the current time of a timer, and places
          the result in <span class="code">time_left</span>. This is the time in
          milliseconds, before the time-out occurs.</p>
        <p>The return value is <span class="code">0</span>.</p>
      </p></div>

    <p><a name="driver_realloc"><span class="bold_code bc-7">void *driver_realloc(void *ptr, ErlDrvSizeT size)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_realloc"></a>
        <p>Resizes a memory block, either in place, or by
          allocating a new block, copying the data, and freeing the old
          block. A pointer is returned to the reallocated memory. On
          failure (out of memory), <span class="code">NULL</span> is returned. (This is
          most often a wrapper for <span class="code">realloc</span>.)</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="driver_realloc_binary"><span class="bold_code bc-7">ErlDrvBinary *driver_realloc_binary(ErlDrvBinary *bin, ErlDrvSizeT size)
        </span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_realloc_binary"></a>
        <p>Resizes a driver binary, while keeping the data.</p>
        <p>Returns the resized driver binary on success. Returns <span class="code">NULL</span>
          on failure (out of memory).</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="driver_select"><span class="bold_code bc-7">int driver_select(ErlDrvPort port, ErlDrvEvent
        event, int mode, int on)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_select"></a>
        <p>This function is used by drivers to provide the emulator with
          events to check for. This enables the emulator to call the driver
          when something has occurred asynchronously.</p>
        <p>Parameter <span class="code">event</span> identifies an OS-specific event object.
          On Unix systems, the functions <span class="code">select</span>/<span class="code">poll</span> are used.
          The event object must be a socket or pipe (or other object that
          <span class="code">select</span>/<span class="code">poll</span> can use).
          On Windows, the Win32 API function <span class="code">WaitForMultipleObjects</span>
          is used. This places other restrictions on the event object;
          see the Win32 SDK documentation.</p>
        <p>Parameter <span class="code">on</span> is to be <span class="code">1</span> for setting events
          and <span class="code">0</span> for clearing them.</p>
        <p>Parameter <span class="code">mode</span> is a bitwise OR combination of
          <span class="code">ERL_DRV_READ</span>, <span class="code">ERL_DRV_WRITE</span>, and <span class="code">ERL_DRV_USE</span>.
          The first two specify whether to wait for read events and/or write
          events. A fired read event calls
          <span class="bold_code bc-15"><a href="driver_entry.html#ready_input"><span class="code">ready_input</span></a></span> and a fired write event calls
          <span class="bold_code bc-15"><a href="driver_entry.html#ready_output"><span class="code">ready_output</span></a></span>.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>Some OS (Windows) do not differentiate between read and write
            events. The callback for a fired event then only depends on the
            value of <span class="code">mode</span>.</p>
        </p></div>
</div>
        <p><span class="code">ERL_DRV_USE</span> specifies if we are using the event object or
          if we want to close it.
          On an emulator with SMP support, it is not safe to clear all events
          and then close the event object after <span class="code">driver_select</span> has
          returned. Another thread can still be using the event object
          internally. To safely close an event object, call
          <span class="code">driver_select</span> with <span class="code">ERL_DRV_USE</span> and <span class="code">on==0</span>, which
          clears all events and then either calls
	  <span class="bold_code bc-15"><a href="driver_entry.html#stop_select"><span class="code">stop_select</span></a></span>
	  or schedules it to be called when it is safe to close the event
          object. <span class="code">ERL_DRV_USE</span> is to be set together with the first event
          for an event object. It is harmless to set <span class="code">ERL_DRV_USE</span>
          even if it already has been done. Clearing all events but keeping
          <span class="code">ERL_DRV_USE</span> set indicates that we are using the event
          object and probably will set events for it again.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p><span class="code">ERL_DRV_USE</span> was added in Erlang/OTP R13. Old drivers still
            work as before, but it is recommended to update them to use
            <span class="code">ERL_DRV_USE</span> and <span class="code">stop_select</span> to ensure that event
            objects are closed in a safe way.</p>
        </p></div>
</div>
        <p>The return value is <span class="code">0</span>, unless
          <span class="code">ready_input</span>/<span class="code">ready_output</span> is <span class="code">NULL</span>, in which case
          it is <span class="code">-1</span>.</p>
      </p></div>

    <p><a name="driver_send_term"><span class="bold_code bc-7">int driver_send_term(ErlDrvPort port,
        ErlDrvTermData receiver, ErlDrvTermData* term, int n)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_send_term"></a>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p><strong>This function is deprecated.</strong>
            Use <span class="bold_code bc-17"><a href="#erl_drv_send_term"><span class="code">erl_drv_send_term</span></a></span> instead.</p>
        </p></div>
</div>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>The parameters of this function
            cannot be properly checked by the runtime system when
            executed by arbitrary threads. This can cause the
            function not to fail when it should.</p>
        </p></div>
</div>
        <p>Parameters <span class="code">term</span> and <span class="code">n</span> work as in
          <span class="bold_code bc-17"><a href="#erl_drv_output_term"><span class="code">erl_drv_output_term</span></a></span>.</p>
        <p>This function is only thread-safe when the emulator with SMP
          support is used.</p>
      </p></div>

    <p><a name="driver_set_timer"><span class="bold_code bc-7">int driver_set_timer(ErlDrvPort port, unsigned
        long time)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_set_timer"></a>
        <p>Sets a timer on the driver, which will count
          down and call the driver when it is timed out. Parameter
          <span class="code">time</span> is the time in milliseconds before the timer expires.</p>
        <p>When the timer reaches <span class="code">0</span> and expires, the driver entry
          function <span class="bold_code bc-15"><a href="driver_entry.html#timeout"><span class="code">timeout</span></a></span> is called.</p>
        <p>Notice that only one timer exists on each driver instance;
          setting a new timer replaces an older one.</p>
        <p>Return value is <span class="code">0</span>, unless the <span class="code">timeout</span>
          driver function is <span class="code">NULL</span>, in which case it is <span class="code">-1</span>.</p>
      </p></div>

    <p><a name="driver_sizeq"><span class="bold_code bc-7">ErlDrvSizeT driver_sizeq(ErlDrvPort port)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_sizeq"></a>
        <p>Returns the number of bytes currently in the driver queue.</p>
        <p>This function can be called from any thread if a
          <span class="bold_code bc-17"><a href="#ErlDrvPDL">port data lock</a></span>
          associated with the <span class="code">port</span> is locked by the calling
          thread during the call.</p>
      </p></div>

    <p><a name="driver_system_info"><span class="bold_code bc-7">void driver_system_info(ErlDrvSysInfo
        *sys_info_ptr, size_t size)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_system_info"></a>
        <p>Writes information about the Erlang runtime system into the
          <span class="bold_code bc-17"><a href="#ErlDrvSysInfo"><span class="code">ErlDrvSysInfo</span></a></span>
          structure referred to by the first argument. The second
          argument is to be the size of the
          <span class="bold_code bc-17"><a href="#ErlDrvSysInfo"><span class="code">ErlDrvSysInfo</span></a></span>
          structure, that is, <span class="code">sizeof(ErlDrvSysInfo)</span>.</p>
        <p>For information about specific fields, see
          <span class="bold_code bc-17"><a href="#ErlDrvSysInfo"><span class="code">ErlDrvSysInfo</span></a></span>.</p>
      </p></div>

    <p><a name="driver_vec_to_buf"><span class="bold_code bc-7">ErlDrvSizeT driver_vec_to_buf(ErlIOVec *ev,
        char *buf, ErlDrvSizeT len)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="driver_vec_to_buf"></a>
        <p>Collects several segments of data, referenced
          by <span class="code">ev</span>, by copying them in order to the buffer
          <span class="code">buf</span>, of the size <span class="code">len</span>.</p>
        <p>If the data is to be sent from the driver to the port owner
          process, it is faster to use
          <span class="bold_code bc-17"><a href="#driver_outputv"><span class="code">driver_outputv</span></a></span>.</p>
        <p>The return value is the space left in the buffer, that is, if
          <span class="code">ev</span> contains less than <span class="code">len</span> bytes it is the
          difference, and if <span class="code">ev</span> contains <span class="code">len</span> bytes or more,
          it is <span class="code">0</span>. This is faster if there is more than one header byte,
          as the binary syntax can construct integers directly from
          the binary.</p>
      </p></div>

    <p><a name="erl_drv_busy_msgq_limits"><span class="bold_code bc-7">void erl_drv_busy_msgq_limits(ErlDrvPort port,
        ErlDrvSizeT *low, ErlDrvSizeT *high)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_busy_msgq_limits"></a>
        <p>Sets and gets limits that will be used for controlling the
          busy state of the port message queue.</p>
        <p>The port message queue is set into a busy
          state when the amount of command data queued on the
          message queue reaches the <span class="code">high</span> limit. The port
          message queue is set into a not busy state when the
          amount of command data queued on the message queue falls
          below the <span class="code">low</span> limit. Command data is in this
          context data passed to the port using either
          <span class="code">Port ! {Owner, {command, Data}}</span> or
          <span class="code">port_command/[2,3]</span>. Notice that these limits
          only concerns command data that have not yet reached the
          port. The <span class="bold_code bc-17"><a href="#set_busy_port">busy port</a></span>
          feature can be used for data that has reached the port.</p>
        <p>Valid limits are values in the range
          <span class="code">[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]</span>.
          Limits are automatically adjusted to be sane. That is,
          the system adjusts values so that the low limit used is
          lower than or equal to the high limit used. By default the high
          limit is 8 kB and the low limit is 4 kB.</p>
        <p>By passing a pointer to an integer variable containing
          the value <span class="code">ERL_DRV_BUSY_MSGQ_READ_ONLY</span>, the currently used
          limit is read and written back to the integer variable.
          A new limit can be set by passing a pointer to an integer
          variable containing a valid limit. The passed value is
          written to the internal limit. The internal limit is then
          adjusted. After this the adjusted limit is written
          back to the integer variable from which the new value was
          read. Values are in bytes.</p>
        <p>The busy message queue feature can be disabled either
          by setting the <span class="code">ERL_DRV_FLAG_NO_BUSY_MSGQ</span>
          <span class="bold_code bc-15"><a href="driver_entry.html#driver_flags">driver flag</a></span>
          in the <span class="bold_code bc-19"><a href="driver_entry.html"><span class="code">driver_entry</span></a></span>
          used by the driver, or by calling this function with
          <span class="code">ERL_DRV_BUSY_MSGQ_DISABLED</span> as a limit (either low or
          high). When this feature has been disabled, it cannot be
          enabled again. When reading the limits, both are
          <span class="code">ERL_DRV_BUSY_MSGQ_DISABLED</span> if this
          feature has been disabled.</p>
        <p>Processes sending command data to the port are suspended
          if either the port is busy or if the port message queue is
          busy. Suspended processes are resumed when neither the
          port or the port message queue is busy.</p>
        <p>For information about busy port functionality, see
          <span class="bold_code bc-17"><a href="#set_busy_port"><span class="code">set_busy_port</span></a></span>.</p>
      </p></div>

    <p><a name="erl_drv_cond_broadcast"><span class="bold_code bc-7">void erl_drv_cond_broadcast(ErlDrvCond
        *cnd)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_cond_broadcast"></a>
        <p>Broadcasts on a condition variable. That is, if
          other threads are waiting on the condition variable being
          broadcast on, <strong>all</strong> of them are woken.</p>
        <p><span class="code">cnd</span> is a pointer to a condition variable to broadcast on.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_cond_create"><span class="bold_code bc-7">ErlDrvCond *erl_drv_cond_create(char
        *name)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_cond_create"></a>
        <p>Creates a condition variable and returns a pointer to it.</p> 
        <p><span class="code">name</span> is a string identifying the created condition variable.
          It is used to identify the condition variable in planned
          future debug functionality.</p>
        <p>Returns <span class="code">NULL</span> on failure. The driver
          creating the condition variable is responsible for
          destroying it before the driver is unloaded.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_cond_destroy"><span class="bold_code bc-7">void erl_drv_cond_destroy(ErlDrvCond
        *cnd)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_cond_destroy"></a>
        <p>Destroys a condition variable previously created by
          <span class="bold_code bc-17"><a href="#erl_drv_cond_create"><span class="code">erl_drv_cond_create</span></a></span>.</p>
        <p><span class="code">cnd</span> is a pointer to a condition variable to destroy.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_cond_name"><span class="bold_code bc-7">char *erl_drv_cond_name(ErlDrvCond
        *cnd)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_cnd_name"></a>
        <p>Returns a pointer to the name of the condition.</p>
        <p><span class="code">cnd</span> is a  pointer to an initialized condition.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>This function is intended for debugging purposes only.</p>
        </p></div>
</div>
      </p></div>

    <p><a name="erl_drv_cond_signal"><span class="bold_code bc-7">void erl_drv_cond_signal(ErlDrvCond
        *cnd)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_cond_signal"></a>
        <p>Signals on a condition variable. That is, if
          other threads are waiting on the condition variable being
          signaled, <strong>one</strong> of them is woken.</p>
        <p><span class="code">cnd</span> is a pointer to a condition variable to signal on.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_cond_wait"><span class="bold_code bc-7">void erl_drv_cond_wait(ErlDrvCond *cnd,
        ErlDrvMutex *mtx)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_cond_wait"></a>
        <p>Waits on a condition variable. The calling
          thread is blocked until another thread wakes it by signaling
          or broadcasting on the condition variable. Before the calling
          thread is blocked, it unlocks the mutex passed as argument.
          When the calling thread is woken, it locks the same mutex before
          returning. That is, the mutex currently must be locked by
          the calling thread when calling this function.</p>
        <p><span class="code">cnd</span> is a pointer to a condition variable to wait on.
          <span class="code">mtx</span> is a pointer to a mutex to unlock while waiting.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p><span class="code">erl_drv_cond_wait</span> can return even if
            no one has signaled or broadcast on the condition
            variable. Code calling <span class="code">erl_drv_cond_wait</span> is
            always to be prepared for <span class="code">erl_drv_cond_wait</span>
            returning even if the condition that the thread was
            waiting for has not occurred. That is, when returning from
            <span class="code">erl_drv_cond_wait</span>, always check if the condition
            has occurred, and if not call <span class="code">erl_drv_cond_wait</span>  again.</p>
        </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_consume_timeslice"><span class="bold_code bc-7">int erl_drv_consume_timeslice(ErlDrvPort port,
        int percent)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_consume_timeslice"></a>
        <p>Gives the runtime system a hint about how much CPU time the current
          driver callback call has consumed since the last hint, or since the
          the start of the callback if no previous hint has been given.</p>
        <dl>
          <dt><strong><span class="code">port</span></strong></dt>
          <dd>Port handle of the executing port.</dd>
          <dt><strong><span class="code">percent</span></strong></dt>
          <dd>Approximate consumed fraction of a full
            time-slice in percent.</dd>
        </dl>
        <p>The time is specified as a fraction, in percent, of a full time-slice
          that a port is allowed to execute before it is to surrender the
          CPU to other runnable ports or processes. Valid range is
          <span class="code">[1, 100]</span>. The scheduling time-slice is not an exact entity,
          but can usually be approximated to about 1 millisecond.</p>
        <p>Notice that it is up to the runtime system to determine if and
          how to use this information. Implementations on some platforms
          can use other means to determine the consumed fraction
          of the time-slice. Lengthy driver callbacks should, regardless of
          this, frequently call this function to determine if it is allowed
          to continue execution or not.</p>
        <p>This function returns a non-zero value
          if the time-slice has been exhausted, and zero if the callback is
          allowed to continue execution. If a non-zero value is
          returned, the driver callback is to return as soon as possible in
          order for the port to be able to yield.</p>
        <p>This function is provided to better support co-operative scheduling,
          improve system responsiveness, and to make it easier to prevent
          misbehaviors of the VM because of a port monopolizing a scheduler
          thread. It can be used when dividing lengthy work into some repeated
          driver callback calls, without the need to use threads.</p>
        <p>See also the important <span class="bold_code bc-17"><a href="#WARNING">warning</a></span>
          text at the beginning of this manual page.</p>
      </p></div>

    <p><a name="erl_drv_convert_time_unit"><span class="bold_code bc-7">ErlDrvTime erl_drv_convert_time_unit(ErlDrvTime
        val, ErlDrvTimeUnit from, ErlDrvTimeUnit to)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_convert_time_unit"></a>
        <p>Converts the <span class="code">val</span> value of time unit <span class="code">from</span> to
          the corresponding value of time unit <span class="code">to</span>. The result is
          rounded using the floor function.</p>
        <dl>
          <dt><strong><span class="code">val</span></strong></dt>
          <dd>Value to convert time unit for.</dd>
          <dt><strong><span class="code">from</span></strong></dt>
          <dd>Time unit of <span class="code">val</span>.</dd>
          <dt><strong><span class="code">to</span></strong></dt>
          <dd>Time unit of returned value.</dd>
        </dl>
        <p>Returns <span class="code">ERL_DRV_TIME_ERROR</span> if called with an invalid
          time unit argument.</p>
        <p>See also <span class="bold_code bc-17"><a href="#ErlDrvTime"><span class="code">ErlDrvTime</span></a></span> and
          <span class="bold_code bc-17"><a href="#ErlDrvTimeUnit"><span class="code">ErlDrvTimeUnit</span></a></span>.</p>
      </p></div>

    <p><a name="erl_drv_equal_tids"><span class="bold_code bc-7">int erl_drv_equal_tids(ErlDrvTid tid1,
        ErlDrvTid tid2)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_equal_tids"></a>
        <p>Compares two thread identifiers, <span class="code">tid1</span> and <span class="code">tid2</span>,
          for equality.</p>
        <p>Returns <span class="code">0</span> it they are not equal, and a value not equal to
          <span class="code">0</span> if they are equal.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>A thread identifier can be reused very quickly after
            a thread has terminated. Therefore, if a thread
            corresponding to one of the involved thread identifiers
            has terminated since the thread identifier was saved,
            the result of <span class="code">erl_drv_equal_tids</span> does possibly not give
            the expected result.</p>
        </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_getenv"><span class="bold_code bc-7">int erl_drv_getenv(const char *key, char
        *value, size_t *value_size)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_getenv"></a>
        <p>Retrieves the value of an environment variable.</p>
        <dl>
          <dt><strong><span class="code">key</span></strong></dt>
          <dd>A <span class="code">NULL</span>-terminated string containing the
            name of the environment variable.</dd>
          <dt><strong><span class="code">value</span></strong></dt>
          <dd>A pointer to an output buffer.</dd>
          <dt><strong><span class="code">value_size</span></strong></dt>
          <dd>A pointer to an integer. The integer is used both for
            passing input and output sizes (see below).</dd>
        </dl>
        <p>When this function is called, <span class="code">*value_size</span> is to contain the
          size of the <span class="code">value</span> buffer.</p>
        <p>On success, <span class="code">0</span> is returned,
          the value of the environment variable has been written to
          the <span class="code">value</span> buffer, and <span class="code">*value_size</span> contains the
          string length (excluding the terminating <span class="code">NULL</span> character) of
          the value written to the <span class="code">value</span> buffer.</p>
        <p>On failure, that is, no such environment variable was found,
          a value &lt; <span class="code">0</span> is returned. When the size of the <span class="code">value</span>
          buffer is too small, a value &gt; <span class="code">0</span> is returned and
          <span class="code">*value_size</span> has been set to the buffer size needed.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>Do <strong>not</strong> use libc's <span class="code">getenv</span> or similar C library
            interfaces from a driver.</p>
        </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_init_ack"><span class="bold_code bc-7">void erl_drv_init_ack(ErlDrvPort port,
        ErlDrvData res)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_init_ack"></a>
        <p>Acknowledges the start of the port.</p>
        <dl>
          <dt><strong><span class="code">port</span></strong></dt>
          <dd>The port handle of the port (driver instance)
            doing the acknowledgment.
	  </dd>
          <dt><strong><span class="code">res</span></strong></dt>
          <dd>The result of the port initialization. Can be the same
            values as the return value of <span class="bold_code bc-15"><a href="driver_entry.html#start"><span class="code">start</span></a></span>, that is, any of the error codes or the
            <span class="code">ErlDrvData</span> that is to be used for this port.
          </dd>
        </dl>
        <p>When this function is called the initiating <span class="code">erlang:open_port</span>
          call is returned as if the <span class="bold_code bc-15"><a href="driver_entry.html#start"><span class="code">start</span></a></span> function had just been called. It can only be
          used when flag <span class="bold_code bc-15"><a href="driver_entry.html#driver_flags"><span class="code">ERL_DRV_FLAG_USE_INIT_ACK</span></a></span>
          has been set on the linked-in driver.</p>
      </p></div>

    <p><a name="erl_drv_monotonic_time"><span class="bold_code bc-7">ErlDrvTime erl_drv_monotonic_time(ErlDrvTimeUnit time_unit)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_monotonic_time"></a>
        <p>Returns <span class="bold_code bc-15"><a href="../apps/erts/time_correction.html#Erlang_Monotonic_Time">Erlang monotonic time</a></span>. Notice that negative values are
          not uncommon.</p>
        <p><span class="code">time_unit</span> is time unit of returned value.</p>
        <p>Returns <span class="code">ERL_DRV_TIME_ERROR</span> if called with an invalid
          time unit argument, or if called from a thread that is not a
          scheduler thread.</p>
        <p>See also <span class="bold_code bc-17"><a href="#ErlDrvTime"><span class="code">ErlDrvTime</span></a></span>
          and <span class="bold_code bc-17"><a href="#ErlDrvTimeUnit"><span class="code">ErlDrvTimeUnit</span></a></span>.</p>
      </p></div>

    <p><a name="erl_drv_mutex_create"><span class="bold_code bc-7">ErlDrvMutex *erl_drv_mutex_create(char
        *name)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_mutex_create"></a>
        <p>Creates a mutex and returns a pointer to it.</p>
        <p><span class="code">name</span> is a string identifying the created mutex. It is used
          to identify the mutex in planned future debug functionality.</p>
        <p>Returns <span class="code">NULL</span> on failure. The driver creating the mutex is
          responsible for destroying it before the driver is unloaded.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_mutex_destroy"><span class="bold_code bc-7">void erl_drv_mutex_destroy(ErlDrvMutex
        *mtx)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_mutex_destroy"></a>
        <p>Destroys a mutex previously created by
          <span class="bold_code bc-17"><a href="#erl_drv_mutex_create"><span class="code">erl_drv_mutex_create</span></a></span>.
          The mutex must be in an unlocked state before it is destroyed.</p>
        <p><span class="code">mtx</span> is a pointer to a mutex to destroy.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_mutex_lock"><span class="bold_code bc-7">void erl_drv_mutex_lock(ErlDrvMutex
        *mtx)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_mutex_lock"></a>
        <p>Locks a mutex. The calling thread is blocked until the mutex has
          been locked. A thread that has currently locked the mutex
          <strong>cannot</strong> lock the same mutex again.</p>
        <p><span class="code">mtx</span> is a pointer to a mutex to lock.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>If you leave a mutex locked in an emulator thread
            when you let the thread out of your control, you will
            <strong>very likely</strong> deadlock the whole emulator.</p>
        </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_mutex_name"><span class="bold_code bc-7">char *erl_drv_mutex_name(ErlDrvMutex
        *mtx)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_mutex_name"></a>
        <p>Returns a pointer to the mutex name.</p>
        <p><span class="code">mtx</span> is a pointer to an initialized mutex.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>This function is intended for debugging purposes only.</p>
        </p></div>
</div>
      </p></div>

    <p><a name="erl_drv_mutex_trylock"><span class="bold_code bc-7">int erl_drv_mutex_trylock(ErlDrvMutex
        *mtx)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_mutex_trylock"></a>
        <p>Tries to lock a mutex. A thread that has currently locked the mutex
          <strong>cannot</strong> try to lock the same mutex again.</p>
        <p><span class="code">mtx</span> is a pointer to a mutex to try to lock.</p>
        <p>Returns <span class="code">0</span> on success, otherwise <span class="code">EBUSY</span>.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>If you leave a mutex locked in an emulator thread
            when you let the thread out of your control, you will
            <strong>very likely</strong> deadlock the whole emulator.</p>
        </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_mutex_unlock"><span class="bold_code bc-7">void erl_drv_mutex_unlock(ErlDrvMutex
        *mtx)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_mutex_unlock"></a>
        <p>Unlocks a mutex. The mutex currently must be
          locked by the calling thread.</p>
        <p><span class="code">mtx</span> is a pointer to a mutex to unlock.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_output_term"><span class="bold_code bc-7">int erl_drv_output_term(ErlDrvTermData port,
        ErlDrvTermData* term, int n)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_output_term"></a>
        <p>Sends data in the special driver term
          format to the port owner process. This is a fast way to
          deliver term data from a driver. It needs no binary
          conversion, so the port owner process receives data as
          normal Erlang terms. The <span class="bold_code bc-17"><a href="#erl_drv_send_term"><span class="code">erl_drv_send_term</span></a></span>
          functions can be used for sending to any process
          on the local node.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>Parameter <span class="code">port</span> is <strong>not</strong>
            an ordinary port handle, but a port handle converted using
            <span class="bold_code bc-17"><a href="#driver_mk_port"><span class="code">driver_mk_port</span></a></span>.</p>
        </p></div>
</div>
        <p>Parameter <span class="code">term</span> points to an array of
          <span class="code">ErlDrvTermData</span> with <span class="code">n</span> elements. This array
          contains terms described in the driver term format. Every
          term consists of 1-4 elements in the array. The
          first term has a term type and then arguments.
          Parameter <span class="code">port</span> specifies the sending port.</p>
        <p>Tuples, maps, and lists (except strings, see below)
          are built in reverse polish notation, so that to build a
          tuple, the elements are specified first, and then the tuple
          term, with a count. Likewise for lists and maps.</p>
        <ul>
          <li>
            <p>A tuple must be specified with the number of elements. (The
              elements precede the <span class="code">ERL_DRV_TUPLE</span> term.)</p>
          </li>
          <li>
            <p>A map must be specified with the number of key-value pairs
              <span class="code">N</span>. The key-value pairs must precede the <span class="code">ERL_DRV_MAP</span>
              in this order: <span class="code">key1,value1,key2,value2,...,keyN,valueN</span>.
              Duplicate keys are not allowed.</p>
          </li>
          <li>
            <p>A list must be specified with the number of elements,
              including the tail, which is the last term preceding
              <span class="code">ERL_DRV_LIST</span>.</p>
          </li>
        </ul>
        <p>The special term <span class="code">ERL_DRV_STRING_CONS</span> is used to
          "splice" in a string in a list, a string specified this way is
          not a list in itself, but the elements are elements of the
          surrounding list.</p>
        <div class="example"><pre>
Term type            Arguments
---------            ---------
ERL_DRV_NIL
ERL_DRV_ATOM         ErlDrvTermData atom (from driver_mk_atom(char *string))
ERL_DRV_INT          ErlDrvSInt integer
ERL_DRV_UINT         ErlDrvUInt integer
ERL_DRV_INT64        ErlDrvSInt64 *integer_ptr
ERL_DRV_UINT64       ErlDrvUInt64 *integer_ptr
ERL_DRV_PORT         ErlDrvTermData port (from driver_mk_port(ErlDrvPort port))
ERL_DRV_BINARY       ErlDrvBinary *bin, ErlDrvUInt len, ErlDrvUInt offset
ERL_DRV_BUF2BINARY   char *buf, ErlDrvUInt len
ERL_DRV_STRING       char *str, int len
ERL_DRV_TUPLE        int sz
ERL_DRV_LIST         int sz
ERL_DRV_PID          ErlDrvTermData pid (from driver_connected(ErlDrvPort port)
                     or driver_caller(ErlDrvPort port))
ERL_DRV_STRING_CONS  char *str, int len
ERL_DRV_FLOAT        double *dbl
ERL_DRV_EXT2TERM     char *buf, ErlDrvUInt len
ERL_DRV_MAP          int sz</pre></div>
	<p>The unsigned integer data type <span class="code">ErlDrvUInt</span> and the
	  signed integer data type <span class="code">ErlDrvSInt</span> are 64 bits wide
	  on a 64-bit runtime system and 32 bits wide on a 32-bit
	  runtime system. They were introduced in ERTS 5.6
	  and replaced some of the <span class="code">int</span> arguments in the list above.</p>
	<p>The unsigned integer data type <span class="code">ErlDrvUInt64</span> and the
	  signed integer data type <span class="code">ErlDrvSInt64</span> are always 64 bits
	  wide. They were introduced in ERTS 5.7.4.</p>
	<p>To build the tuple <span class="code">{tcp, Port, [100 | Binary]}</span>, the
	  following call can be made.</p>
	<div class="example"><pre>ErlDrvBinary* bin = ...
ErlDrvPort port = ...
ErlDrvTermData spec[] = {
    ERL_DRV_ATOM, driver_mk_atom("tcp"),
    ERL_DRV_PORT, driver_mk_port(drvport),
        ERL_DRV_INT, 100,
        ERL_DRV_BINARY, bin, 50, 0,
        ERL_DRV_LIST, 2,
    ERL_DRV_TUPLE, 3,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </pre></div>
        <p>Here <span class="code">bin</span> is a driver binary of length at least 50 and
          <span class="code">drvport</span> is a port handle. Notice that <span class="code">ERL_DRV_LIST</span>
          comes after the elements of the list, likewise
          <span class="code">ERL_DRV_TUPLE</span>.</p>
        <p>The <span class="code">ERL_DRV_STRING_CONS</span> term is a way to construct
          strings. It works differently from how <span class="code">ERL_DRV_STRING</span>
          works. <span class="code">ERL_DRV_STRING_CONS</span> builds a string list in
          reverse order (as opposed to how <span class="code">ERL_DRV_LIST</span>
          works), concatenating the strings added to a list. The tail
          must be specified before <span class="code">ERL_DRV_STRING_CONS</span>.</p>
        <p><span class="code">ERL_DRV_STRING</span> constructs a string, and ends
          it. (So it is the same as <span class="code">ERL_DRV_NIL</span> followed by
          <span class="code">ERL_DRV_STRING_CONS</span>.)</p>
        <div class="example"><pre>/* to send [x, "abc", y] to the port: */
ErlDrvTermData spec[] = {
    ERL_DRV_ATOM, driver_mk_atom("x"),
    ERL_DRV_STRING, (ErlDrvTermData)"abc", 3,
    ERL_DRV_ATOM, driver_mk_atom("y"),
    ERL_DRV_NIL,
    ERL_DRV_LIST, 4
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </pre></div>
        <div class="example"><pre>/* to send "abc123" to the port: */
ErlDrvTermData spec[] = {
    ERL_DRV_NIL,        /* with STRING_CONS, the tail comes first */
    ERL_DRV_STRING_CONS, (ErlDrvTermData)"123", 3,
    ERL_DRV_STRING_CONS, (ErlDrvTermData)"abc", 3,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </pre></div>
	<p>The <span class="code">ERL_DRV_EXT2TERM</span> term type is used for passing a
	  term encoded with the
	  <span class="bold_code bc-19"><a href="../apps/erts/erl_ext_dist.html">external format</a></span>,
	  that is, a term that has been encoded by
	  <span class="bold_code bc-15"><a href="erlang.html#term_to_binary-2"><span class="code">erlang:term_to_binary</span></a></span>,
	  <span class="bold_code bc-18"><a href="ei.html"><span class="code">erl_interface:ei(3)</span></a></span>,
	  and so on.
	  For example, if <span class="code">binp</span> is a pointer to an <span class="code">ErlDrvBinary</span>
	  that contains term <span class="code">{17, 4711}</span> encoded with the
	  <span class="bold_code bc-19"><a href="../apps/erts/erl_ext_dist.html">external format</a></span>,
	  and you want to wrap it in a two-tuple with the tag <span class="code">my_tag</span>,
	  that is, <span class="code">{my_tag, {17, 4711}}</span>, you can do as follows:</p>
	<div class="example"><pre>ErlDrvTermData spec[] = {
        ERL_DRV_ATOM, driver_mk_atom("my_tag"),
        ERL_DRV_EXT2TERM, (ErlDrvTermData) binp-&gt;orig_bytes, binp-&gt;orig_size
    ERL_DRV_TUPLE, 2,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </pre></div>
        <p>To build the map <span class="code">#{key1 =&gt; 100, key2 =&gt; {200, 300}}</span>, the
          following call can be made.</p>
        <div class="example"><pre>ErlDrvPort port = ...
ErlDrvTermData spec[] = {
    ERL_DRV_ATOM, driver_mk_atom("key1"),
        ERL_DRV_INT, 100,
    ERL_DRV_ATOM, driver_mk_atom("key2"),
        ERL_DRV_INT, 200,
        ERL_DRV_INT, 300,
    ERL_DRV_TUPLE, 2,
    ERL_DRV_MAP, 2
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));    </pre></div>
        <p>If you want to pass a binary and do not already have the content
          of the binary in an <span class="code">ErlDrvBinary</span>, you can benefit from using
          <span class="code">ERL_DRV_BUF2BINARY</span> instead of creating an <span class="code">ErlDrvBinary</span>
          through <span class="bold_code bc-17"><a href="#driver_alloc_binary"><span class="code">driver_alloc_binary</span></a></span> and then pass the binary through
          <span class="code">ERL_DRV_BINARY</span>. The runtime system often allocates
          binaries smarter if <span class="code">ERL_DRV_BUF2BINARY</span> is used.
          However, if the content of the binary to pass already resides in
          an <span class="code">ErlDrvBinary</span>, it is normally better to pass the binary using
          <span class="code">ERL_DRV_BINARY</span> and the <span class="code">ErlDrvBinary</span> in question.</p>
        <p>The <span class="code">ERL_DRV_UINT</span>, <span class="code">ERL_DRV_BUF2BINARY</span>, and
          <span class="code">ERL_DRV_EXT2TERM</span> term types were introduced in
          ERTS 5.6.</p>
        <p>This function is only thread-safe when the emulator with SMP
          support is used.</p>
      </p></div>

    <p><a name="erl_drv_putenv"><span class="bold_code bc-7">int erl_drv_putenv(const char *key, char
        *value)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_putenv"></a>
        <p>Sets the value of an environment variable.</p>
        <p><span class="code">key</span> is a <span class="code">NULL</span>-terminated string containing the
          name of the environment variable.</p>
        <p><span class="code">value</span> is a <span class="code">NULL</span>-terminated string containing the
          new value of the environment variable.</p>
        <p>Returns <span class="code">0</span> on success, otherwise a value <span class="code">!= 0</span>.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>The result of passing the empty string (<span class="code">""</span>) as a value
            is platform-dependent. On some platforms the variable value
            is set to the empty string, on others the
            environment variable is removed.</p>
        </p></div>
</div>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>Do <strong>not</strong> use libc's <span class="code">putenv</span> or similar C library
            interfaces from a driver.</p>
        </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_rwlock_create"><span class="bold_code bc-7">ErlDrvRWLock *erl_drv_rwlock_create(char
        *name)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_rwlock_create"></a>
        <p>Creates an rwlock and returns a pointer to it.</p>
        <p><span class="code">name</span> is a string identifying the created rwlock.
          It is used to identify the rwlock in planned future
          debug functionality.</p>
        <p>Returns <span class="code">NULL</span> on failure. The driver creating the rwlock
          is responsible for destroying it before the driver is unloaded.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_rwlock_destroy"><span class="bold_code bc-7">void erl_drv_rwlock_destroy(ErlDrvRWLock
        *rwlck)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_rwlock_destroy"></a>
        <p>Destroys an rwlock previously created by
          <span class="bold_code bc-17"><a href="#erl_drv_rwlock_create"><span class="code">erl_drv_rwlock_create</span></a></span>.
          The rwlock must be in an unlocked state before it is destroyed.</p>
        <p><span class="code">rwlck</span> is a pointer to an rwlock to destroy.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_rwlock_name"><span class="bold_code bc-7">char *erl_drv_rwlock_name(ErlDrvRWLock
        *rwlck)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_rwlock_name"></a>
        <p>Returns a pointer to the name of the rwlock.</p>
        <p><span class="code">rwlck</span> is a pointer to an initialized rwlock.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>This function is intended for debugging purposes only.</p>
        </p></div>
</div>
      </p></div>

    <p><a name="erl_drv_rwlock_rlock"><span class="bold_code bc-7">void erl_drv_rwlock_rlock(ErlDrvRWLock
        *rwlck)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_rwlock_rlock"></a>
        <p>Read locks an rwlock. The calling thread is
          blocked until the rwlock has been read locked. A thread
          that currently has read or read/write locked the rwlock
          <strong>cannot</strong> lock the same rwlock again.</p>
        <p><span class="code">rwlck</span> is a pointer to the rwlock to read lock.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>If you leave an rwlock locked in an emulator thread
            when you let the thread out of your control, you will
            <strong>very likely</strong> deadlock the whole emulator.</p>
        </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_rwlock_runlock"><span class="bold_code bc-7">void erl_drv_rwlock_runlock(ErlDrvRWLock
        *rwlck)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_rwlock_runlock"></a>
        <p>Read unlocks an rwlock. The rwlock currently must
          be read locked by the calling thread.</p>
        <p><span class="code">rwlck</span> is a pointer to an rwlock to read unlock.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_rwlock_rwlock"><span class="bold_code bc-7">void erl_drv_rwlock_rwlock(ErlDrvRWLock
        *rwlck)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_rwlock_rwlock"></a>
        <p>Read/write locks an rwlock. The calling thread
          is blocked until the rwlock has been read/write locked.
          A thread that currently has read or read/write locked the
          rwlock <strong>cannot</strong> lock the same rwlock again.</p>
        <p><span class="code">rwlck</span> is a pointer to an rwlock to read/write lock.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>If you leave an rwlock locked in an emulator thread
            when you let the thread out of your control, you will
            <strong>very likely</strong> deadlock the whole emulator.</p>
          </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_rwlock_rwunlock"><span class="bold_code bc-7">void erl_drv_rwlock_rwunlock(ErlDrvRWLock
        *rwlck)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_rwlock_rwunlock"></a>
        <p>Read/write unlocks an rwlock. The rwlock currently must be
          read/write locked by the calling thread.</p>
        <p><span class="code">rwlck</span> is a pointer to an rwlock to read/write unlock.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_rwlock_tryrlock"><span class="bold_code bc-7">int erl_drv_rwlock_tryrlock(ErlDrvRWLock
        *rwlck)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_rwlock_tryrlock"></a>
        <p>Tries to read lock an rwlock.</p>
        <p><span class="code">rwlck</span> is a pointer to an rwlock to try to read lock.</p>
        <p>Returns <span class="code">0</span> on success, otherwise <span class="code">EBUSY</span>.
          A thread that currently has read or read/write locked the
          rwlock <strong>cannot</strong> try to lock the same rwlock again.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>If you leave an rwlock locked in an emulator thread
            when you let the thread out of your control, you will
            <strong>very likely</strong> deadlock the whole emulator.</p>
        </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_rwlock_tryrwlock"><span class="bold_code bc-7">int erl_drv_rwlock_tryrwlock(ErlDrvRWLock
        *rwlck)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_rwlock_tryrwlock"></a>
        <p>Tries to read/write lock an rwlock.
          A thread that currently has read or read/write locked the
          rwlock <strong>cannot</strong> try to lock the same rwlock again.</p>
        <p><span class="code">rwlck</span>is pointer to an rwlock to try to read/write lock.</p>
        <p>Returns <span class="code">0</span> on success, otherwise <span class="code">EBUSY</span>.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>If you leave an rwlock locked in an emulator thread
            when you let the thread out of your control, you will
            <strong>very likely</strong> deadlock the whole emulator.</p>
        </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_send_term"><span class="bold_code bc-7">int erl_drv_send_term(ErlDrvTermData port,
        ErlDrvTermData receiver, ErlDrvTermData* term, int n)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_send_term"></a>
        <p>This function is the only way for a driver to send data to
          <strong>other</strong> processes than the port owner process. Parameter
          <span class="code">receiver</span> specifies the process to receive the data.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>Parameter <span class="code">port</span> is <strong>not</strong> an ordinary port handle, but
            a port handle converted using
            <span class="bold_code bc-17"><a href="#driver_mk_port"><span class="code">driver_mk_port</span></a></span>.</p>
        </p></div>
</div>
        <p>Parameters <span class="code">port</span>, <span class="code">term</span>, and <span class="code">n</span> work as in
          <span class="bold_code bc-17"><a href="#erl_drv_output_term"><span class="code">erl_drv_output_term</span></a></span>.</p>
        <p>This function is only thread-safe when the emulator with SMP
          support is used.</p>
      </p></div>

    <p><a name="erl_drv_set_os_pid"><span class="bold_code bc-7">void erl_drv_set_os_pid(ErlDrvPort port,
        ErlDrvSInt pid)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_set_os_pid"></a>
        <p>Sets the <span class="code">os_pid</span> seen when doing
          <span class="bold_code bc-18"><a href="../apps/erlang/port_info/2.html"><span class="code">erlang:port_info/2</span></a></span> on this port.</p>
        <p><span class="code">port</span> is the port handle of the port (driver instance) to set
          the pid on. <span class="code">pid</span>is the pid to set.</p>
      </p></div>

    <p><a name="erl_drv_thread_create"><span class="bold_code bc-7">int erl_drv_thread_create(char *name, ErlDrvTid
        *tid, void * (*func)(void *), void *arg, ErlDrvThreadOpts
        *opts)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_thread_create"></a>
        <p>Creates a new thread.</p>
        <dl>
          <dt><strong><span class="code">name</span></strong></dt>
          <dd>A string identifying the created thread. It is used to
            identify the thread in planned future debug functionality.
          </dd>
          <dt><strong><span class="code">tid</span></strong></dt>
          <dd>A pointer to a thread identifier variable.</dd>
          <dt><strong><span class="code">func</span></strong></dt>
          <dd>A pointer to a function to execute in the created thread.</dd>
          <dt><strong><span class="code">arg</span></strong></dt>
          <dd>A pointer to argument to the <span class="code">func</span> function.</dd>
          <dt><strong><span class="code">opts</span></strong></dt>
          <dd>A pointer to thread options to use or <span class="code">NULL</span>.</dd>
        </dl>
        <p>Returns <span class="code">0</span> on success,
          otherwise an <span class="code">errno</span> value is returned to indicate the error.
          The newly created thread begins executing in the function pointed
          to by <span class="code">func</span>, and <span class="code">func</span> is passed <span class="code">arg</span> as
          argument. When <span class="code">erl_drv_thread_create</span> returns, the thread
          identifier of the newly created thread is available in
          <span class="code">*tid</span>. <span class="code">opts</span> can be either a <span class="code">NULL</span> pointer, or a
          pointer to an
          <span class="bold_code bc-17"><a href="#ErlDrvThreadOpts"><span class="code">ErlDrvThreadOpts</span></a></span>
          structure. If <span class="code">opts</span> is a <span class="code">NULL</span> pointer, default options
          are used, otherwise the passed options are used.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>You are not allowed to allocate the
            <span class="bold_code bc-17"><a href="#ErlDrvThreadOpts"><span class="code">ErlDrvThreadOpts</span></a></span> structure by yourself.
            It must be allocated and initialized by
            <span class="bold_code bc-17"><a href="#erl_drv_thread_opts_create"><span class="code">erl_drv_thread_opts_create</span></a></span>.</p>
        </p></div>
</div>
        <p>The created thread terminates either when <span class="code">func</span> returns or if
          <span class="bold_code bc-17"><a href="#erl_drv_thread_exit"><span class="code">erl_drv_thread_exit</span></a></span>
          is called by the thread. The exit value of the thread is either
          returned from <span class="code">func</span> or passed as argument to
          <span class="bold_code bc-17"><a href="#erl_drv_thread_exit"><span class="code">erl_drv_thread_exit</span></a></span>.
          The driver creating the thread is responsible for joining the
          thread, through <span class="bold_code bc-17"><a href="#erl_drv_thread_join"><span class="code">erl_drv_thread_join</span></a></span>,
          before the driver is unloaded. "Detached" threads cannot be created,
          that is, threads that do not need to be joined.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>All created threads must be joined by the driver before
            it is unloaded. If the driver fails to join all threads
            created before it is unloaded, the runtime system
            most likely crashes when the driver code is unloaded.</p>
        </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_thread_exit"><span class="bold_code bc-7">void erl_drv_thread_exit(void
        *exit_value)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_thread_exit"></a>
        <p>Terminates the calling thread with the exit value passed as
          argument. <span class="code">exit_value</span> is a pointer to an exit value or
          <span class="code">NULL</span>.</p>
        <p>You are only allowed to terminate threads created with
          <span class="bold_code bc-17"><a href="#erl_drv_thread_create"><span class="code">erl_drv_thread_create</span></a></span>.</p>
        <p>The exit value can later be retrieved by another thread through
          <span class="bold_code bc-17"><a href="#erl_drv_thread_join"><span class="code">erl_drv_thread_join</span></a></span>.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_thread_join"><span class="bold_code bc-7">int erl_drv_thread_join(ErlDrvTid tid, void
        **exit_value)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_thread_join"></a>
        <p>Joins the calling thread with another thread, that is,
          the calling thread is blocked until the thread identified by
          <span class="code">tid</span> has terminated.</p>
        <p><span class="code">tid</span> is the thread identifier of the thread to join.
          <span class="code">exit_value</span> is a pointer to a pointer to an exit value,
          or <span class="code">NULL</span>.</p>
        <p>Returns <span class="code">0</span> on success, otherwise an <span class="code">errno</span>
          value is returned to indicate the error.</p>
        <p>A thread can only be joined once. The behavior of joining
          more than once is undefined, an emulator crash is likely. If
          <span class="code">exit_value == NULL</span>, the exit value of the terminated thread
          is ignored, otherwise the exit value of the terminated thread
          is stored at <span class="code">*exit_value</span>.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_thread_name"><span class="bold_code bc-7">char *erl_drv_thread_name(ErlDrvTid
        tid)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_rwlock_name"></a>
        <p>Returns a pointer to the name of the thread.</p>
        <p><span class="code">tid</span> is a thread identifier.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>This function is intended for debugging purposes only.</p>
        </p></div>
</div>
      </p></div>

    <p><a name="erl_drv_thread_opts_create"><span class="bold_code bc-7">ErlDrvThreadOpts *erl_drv_thread_opts_create(char *name)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_thread_opts_create"></a>
        <p>Allocates and initializes a thread option structure.</p>
        <p><span class="code">name</span> is a string identifying the created thread options.
          It is used to identify the thread options in planned future debug
          functionality.</p>
        <p>Returns <span class="code">NULL</span> on failure. A thread option
          structure is used for passing options to
          <span class="bold_code bc-17"><a href="#erl_drv_thread_create"><span class="code">erl_drv_thread_create</span></a></span>.
          If the structure is not modified before it is passed to
          <span class="bold_code bc-17"><a href="#erl_drv_thread_create"><span class="code">erl_drv_thread_create</span></a></span>,
          the default values are used.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>You are not allowed to allocate the
            <span class="bold_code bc-17"><a href="#ErlDrvThreadOpts"><span class="code">ErlDrvThreadOpts</span></a></span>
            structure by yourself. It must be allocated and initialized by
            <span class="code">erl_drv_thread_opts_create</span>.</p>
          </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_thread_opts_destroy"><span class="bold_code bc-7">void erl_drv_thread_opts_destroy(ErlDrvThreadOpts *opts)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_thread_opts_destroy"></a>
        <p>Destroys thread options previously created by
          <span class="bold_code bc-17"><a href="#erl_drv_thread_opts_create"><span class="code">erl_drv_thread_opts_create</span></a></span>.</p>
        <p><span class="code">opts</span> is a pointer to thread options to destroy.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_thread_self"><span class="bold_code bc-7">ErlDrvTid erl_drv_thread_self(void)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_thread_self"></a>
        <p>Returns the thread identifier of the calling thread.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_time_offset"><span class="bold_code bc-7">ErlDrvTime erl_drv_time_offset(ErlDrvTimeUnit
        time_unit)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_time_offset"></a>
        <p>Returns the current time offset between
          <span class="bold_code bc-15"><a href="../apps/erts/time_correction.html#Erlang_Monotonic_Time">Erlang monotonic time</a></span> and
          <span class="bold_code bc-15"><a href="../apps/erts/time_correction.html#Erlang_System_Time">Erlang system time</a></span>
          converted into the <span class="code">time_unit</span> passed as argument.</p>
        <p><span class="code">time_unit</span> is time unit of returned value.</p>
        <p>Returns <span class="code">ERL_DRV_TIME_ERROR</span> if called with an invalid
          time unit argument, or if called from a thread that is not a
          scheduler thread.</p>
        <p>See also <span class="bold_code bc-17"><a href="#ErlDrvTime"><span class="code">ErlDrvTime</span></a></span> and
          <span class="bold_code bc-17"><a href="#ErlDrvTimeUnit"><span class="code">ErlDrvTimeUnit</span></a></span>.</p>
      </p></div>

    <p><a name="erl_drv_tsd_get"><span class="bold_code bc-7">void *erl_drv_tsd_get(ErlDrvTSDKey
        key)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_tsd_get"></a>
        <p>Returns the thread-specific data
          associated with <span class="code">key</span> for the calling thread.</p>
        <p><span class="code">key</span> is a thread-specific data key.</p>
        <p>Returns <span class="code">NULL</span> if no data has been associated
          with <span class="code">key</span> for the calling thread.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_tsd_key_create"><span class="bold_code bc-7">int erl_drv_tsd_key_create(char *name,
        ErlDrvTSDKey *key)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_tsd_key_create"></a>
        <p>Creates a thread-specific data key.</p>
        <p><span class="code">name</span> is a string identifying the created key. It is used
          to identify the key in planned future debug functionality.</p>
        <p><span class="code">key</span> is a pointer to a thread-specific data key variable.</p>
        <p>Returns <span class="code">0</span> on success, otherwise an <span class="code">errno</span> value is
          returned to indicate the error. The driver creating the key is
          responsible for destroying it before the driver is unloaded.</p>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_tsd_key_destroy"><span class="bold_code bc-7">void erl_drv_tsd_key_destroy(ErlDrvTSDKey
        key)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_tsd_key_destroy"></a>
        <p>Destroys a thread-specific data key previously created by
          <span class="bold_code bc-17"><a href="#erl_drv_tsd_key_create"><span class="code">erl_drv_tsd_key_create</span></a></span>.
          All thread-specific data using this key in all threads
          must be cleared (see <span class="bold_code bc-17"><a href="#erl_drv_tsd_set"><span class="code">erl_drv_tsd_set</span></a></span>)
	  before the call to <span class="code">erl_drv_tsd_key_destroy</span>.</p>
        <p><span class="code">key</span> is a thread-specific data key to destroy.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>A destroyed key is very likely to be reused soon.
            Therefore, if you fail to clear the thread-specific
            data using this key in a thread before destroying
            the key, you will <strong>very likely</strong> get unexpected
            errors in other parts of the system.</p>
        </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_drv_tsd_set"><span class="bold_code bc-7">void erl_drv_tsd_set(ErlDrvTSDKey key, void
        *data)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_drv_tsd_set"></a>
        <p>Sets thread-specific data associated with
          <span class="code">key</span> for the calling thread. You are only allowed to set
          thread-specific data for threads while they are fully under your
          control. For example, if you set thread-specific data in a thread
          calling a driver callback function, it must be cleared, that is,
          set to <span class="code">NULL</span>, before returning from the driver callback
          function.</p>
        <p><span class="code">key</span> is a thread-specific data key.</p>
        <p><span class="code">data</span> is a pointer to data to associate with <span class="code">key</span>
          in the calling thread.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>If you fail to clear thread-specific data in an
            emulator thread before letting it out of your control,
            you might never be able to clear this data with
            later unexpected errors in other parts of the system as
            a result.</p>
        </p></div>
</div>
        <p>This function is thread-safe.</p>
      </p></div>

    <p><a name="erl_errno_id"><span class="bold_code bc-7">char *erl_errno_id(int error)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="erl_errno_id"></a>
        <p>Returns the atom name of the Erlang error,
          given the error number in <span class="code">error</span>. The error atoms are
          <span class="code">einval</span>, <span class="code">enoent</span>, and so on. It can be used to make
          error terms from the driver.</p>
      </p></div>

    <p><a name="remove_driver_entry"><span class="bold_code bc-7">int remove_driver_entry(ErlDrvEntry
        *de)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="remove_driver_entry"></a>
        <p>Removes a driver entry <span class="code">de</span> previously added with
          <span class="bold_code bc-17"><a href="#add_driver_entry"><span class="code">add_driver_entry</span></a></span>.</p>
        <p>Driver entries added by the <span class="code">erl_ddll</span> Erlang interface
          cannot be removed by using this interface.</p>
      </p></div>

    <p><a name="set_busy_port"><span class="bold_code bc-7">void set_busy_port(ErlDrvPort port, int
        on)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="set_busy_port"></a>
        <p>Sets and unsets the busy state of the port. If
          <span class="code">on</span> is non-zero, the port is set to busy. If it is zero,
          the port is set to not busy. You typically want to combine
          this feature with the <span class="bold_code bc-17"><a href="#erl_drv_busy_msgq_limits">busy port message queue</a></span> functionality.</p>
        <p>Processes sending command data to the port are suspended
          if either the port or the port message queue
          is busy. Suspended processes are resumed when neither the
          port or the port message queue is busy. Command data
          is in this context data passed to the port using either
          <span class="code">Port ! {Owner, {command, Data}}</span> or
          <span class="code">port_command/[2,3]</span>.</p>
        <p>If the <span class="bold_code bc-15"><a href="driver_entry.html#driver_flags">ERL_DRV_FLAG_SOFT_BUSY</a></span> has been set in the
          <span class="bold_code bc-19"><a href="driver_entry.html"><span class="code">driver_entry</span></a></span>,
          data can be forced into the driver through
          <span class="bold_code bc-15"><a href="erlang.html#port_command-3"><span class="code">erlang:port_command(Port, Data, [force])</span></a></span>
          even if the driver has signaled that it is busy.</p>
        <p>For information about busy port message queue functionality, see
          <span class="bold_code bc-17"><a href="#erl_drv_busy_msgq_limits"><span class="code">erl_drv_busy_msgq_limits</span></a></span>.</p>
      </p></div>

    <p><a name="set_port_control_flags"><span class="bold_code bc-7">void set_port_control_flags(ErlDrvPort port,
        int flags)</span></a><br></p>
<div class="REFBODY rb-7"><p>
        <a name="set_port_control_flags"></a>
        <p>Sets flags for how the <span class="bold_code bc-15"><a href="driver_entry.html#control"><span class="code">control</span></a></span> driver entry
          function will return data to the port owner process.
          (The <span class="code">control</span> function is called from
          <span class="bold_code bc-18"><a href="../apps/erlang/port_control/3.html"><span class="code">erlang:port_control/3</span></a></span>.)</p>
        <p>Currently there are only two meaningful values for
          <span class="code">flags</span>: <span class="code">0</span> means that data is returned in a list,
          and <span class="code">PORT_CONTROL_FLAG_BINARY</span> means data is returned as
          a binary from <span class="code">control</span>.</p>
      </p></div>
  </div>

  <h3><a name="id220198">See Also</a></h3>
<div class="REFBODY rb-3">
    
    <p><span class="bold_code bc-19"><a href="driver_entry.html"><span class="code">driver_entry(3)</span></a></span>,
      <span class="bold_code bc-19"><a href="erlang.html"><span class="code">erlang(3)</span></a></span>,
      <span class="bold_code bc-18"><a href="erl_ddll.html"><span class="code">erl_ddll(3)</span></a></span>,
      section <span class="bold_code bc-19"><a href="../apps/erts/alt_dist.html">How to Implement an Alternative Carrier for the Erlang Distribution&gt;</a></span> in the User's Guide</p>
  </div>
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2018 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../js/';</script><script type="text/javascript" src="../js/highlight.js"></script>
</body>
</html>
