<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Transactions and Other Access Contexts</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<div class="erlang-logo-wrapper"><a href="../../index.html"><img alt="Erlang Logo" src="../../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Mnesia</p>
<p class="section-subtitle">User's Guide</p>
<p class="section-version">Version 4.15.3</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="index.html">Reference Manual</a></li>
<li><a href="release_notes.html">Release Notes</a></li>
<li><a href="mnesia.pdf">PDF</a></li>
<li><a href="../../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="Mnesia_chap1.html">
              Top of chapter
            </a></li>
<li title="Scope"><a href="Mnesia_chap1.html#id62375">Scope</a></li>
<li title="Prerequisites"><a href="Mnesia_chap1.html#id68304">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="Mnesia" expanded="false">Mnesia<ul>
<li><a href="Mnesia_overview.html">
              Top of chapter
            </a></li>
<li title="Mnesia Database Management System (DBMS)"><a href="Mnesia_overview.html#id63848">Mnesia Database Management System (DBMS)</a></li>
</ul>
</li>
<li id="no" title="Getting Started" expanded="false">Getting Started<ul>
<li><a href="Mnesia_chap2.html">
              Top of chapter
            </a></li>
<li title="Starting Mnesia for the First Time"><a href="Mnesia_chap2.html#id63845">Starting Mnesia for the First Time</a></li>
<li title="Example"><a href="Mnesia_chap2.html#id64170">Example</a></li>
</ul>
</li>
<li id="no" title="Build a Mnesia Database" expanded="false">Build a Mnesia Database<ul>
<li><a href="Mnesia_chap3.html">
              Top of chapter
            </a></li>
<li title="Define a Schema"><a href="Mnesia_chap3.html#id71529">Define a Schema</a></li>
<li title="Data Model"><a href="Mnesia_chap3.html#id67512">Data Model</a></li>
<li title="Start Mnesia"><a href="Mnesia_chap3.html#id67574">Start Mnesia</a></li>
<li title="Create Tables"><a href="Mnesia_chap3.html#id72086">Create Tables</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Transactions and Other Access Contexts" expanded="true">Transactions and Other Access Contexts<ul>
<li><a href="Mnesia_chap4.html">
              Top of chapter
            </a></li>
<li title="Transaction Properties"><a href="Mnesia_chap4.html#id77330">Transaction Properties</a></li>
<li title="Locking"><a href="Mnesia_chap4.html#id77591">Locking</a></li>
<li title="Dirty Operations"><a href="Mnesia_chap4.html#id78164">Dirty Operations</a></li>
<li title="Record Names versus Table Names"><a href="Mnesia_chap4.html#id78627">Record Names versus Table Names</a></li>
<li title="Activity Concept and Various Access Contexts"><a href="Mnesia_chap4.html#id78726">Activity Concept and Various Access Contexts</a></li>
<li title="Nested Transactions"><a href="Mnesia_chap4.html#id79264">Nested Transactions</a></li>
<li title="Pattern Matching"><a href="Mnesia_chap4.html#id79355">Pattern Matching</a></li>
<li title="Iteration"><a href="Mnesia_chap4.html#id79824">Iteration</a></li>
</ul>
</li>
<li id="no" title="Miscellaneous Mnesia Features" expanded="false">Miscellaneous Mnesia Features<ul>
<li><a href="Mnesia_chap5.html">
              Top of chapter
            </a></li>
<li title="Indexing"><a href="Mnesia_chap5.html#id80248">Indexing</a></li>
<li title="Distribution and Fault Tolerance"><a href="Mnesia_chap5.html#id80387">Distribution and Fault Tolerance</a></li>
<li title="Table Fragmentation"><a href="Mnesia_chap5.html#id80547">Table Fragmentation</a></li>
<li title="Local Content Tables"><a href="Mnesia_chap5.html#id81540">Local Content Tables</a></li>
<li title="Disc-Less Nodes"><a href="Mnesia_chap5.html#id81566">Disc-Less Nodes</a></li>
<li title="More about Schema Management"><a href="Mnesia_chap5.html#id81788">More about Schema Management</a></li>
<li title="Mnesia Event Handling"><a href="Mnesia_chap5.html#id82090">Mnesia Event Handling</a></li>
<li title="Debugging Mnesia Applications"><a href="Mnesia_chap5.html#id82860">Debugging Mnesia Applications</a></li>
<li title="Concurrent Processes in Mnesia"><a href="Mnesia_chap5.html#id83008">Concurrent Processes in Mnesia</a></li>
<li title="Prototyping"><a href="Mnesia_chap5.html#id83060">Prototyping</a></li>
<li title="Object-Based Programming with Mnesia"><a href="Mnesia_chap5.html#id83201">Object-Based Programming with Mnesia</a></li>
</ul>
</li>
<li id="no" title="Mnesia System Information" expanded="false">Mnesia System Information<ul>
<li><a href="Mnesia_chap7.html">
              Top of chapter
            </a></li>
<li title="Database Configuration Data"><a href="Mnesia_chap7.html#id83533">Database Configuration Data</a></li>
<li title="Core Dumps"><a href="Mnesia_chap7.html#id83578">Core Dumps</a></li>
<li title="Dumping Tables"><a href="Mnesia_chap7.html#id83610">Dumping Tables</a></li>
<li title="Checkpoints"><a href="Mnesia_chap7.html#id83658">Checkpoints</a></li>
<li title="Startup Files, Log File, and Data Files"><a href="Mnesia_chap7.html#id83919">Startup Files, Log File, and Data Files</a></li>
<li title="Loading Tables at Startup"><a href="Mnesia_chap7.html#id84432">Loading Tables at Startup</a></li>
<li title="Recovery from Communication Failure"><a href="Mnesia_chap7.html#id84652">Recovery from Communication Failure</a></li>
<li title="Recovery of Transactions"><a href="Mnesia_chap7.html#id84836">Recovery of Transactions</a></li>
<li title="Backup, Restore, Fallback, and Disaster Recovery"><a href="Mnesia_chap7.html#id85020">Backup, Restore, Fallback, and Disaster Recovery</a></li>
</ul>
</li>
<li id="no" title="Combine Mnesia with SNMP" expanded="false">Combine Mnesia with SNMP<ul>
<li><a href="Mnesia_chap8.html">
              Top of chapter
            </a></li>
<li title="Combine Mnesia and SNMP"><a href="Mnesia_chap8.html#id85982">Combine Mnesia and SNMP</a></li>
</ul>
</li>
<li id="no" title="Appendix A: Backup Callback Interface" expanded="false">Appendix A: Backup Callback Interface<ul>
<li><a href="Mnesia_App_A.html">
              Top of chapter
            </a></li>
<li title="mnesia_backup Callback Behavior"><a href="Mnesia_App_A.html#id86092">mnesia_backup Callback Behavior</a></li>
</ul>
</li>
<li id="no" title="Appendix B: Activity Access Callback Interface" expanded="false">Appendix B: Activity Access Callback Interface<ul>
<li><a href="Mnesia_App_B.html">
              Top of chapter
            </a></li>
<li title="mnesia_access Callback Behavior"><a href="Mnesia_App_B.html#id86213">mnesia_access Callback Behavior</a></li>
</ul>
</li>
<li id="no" title="Appendix C: Fragmented Table Hashing Callback Interface" expanded="false">Appendix C: Fragmented Table Hashing Callback Interface<ul>
<li><a href="Mnesia_App_C.html">
              Top of chapter
            </a></li>
<li title="mnesia_frag_hash Callback Behavior"><a href="Mnesia_App_C.html#id86357">mnesia_frag_hash Callback Behavior</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>5Â Transactions and Other Access Contexts</h1>
  
  <p>This section describes the <span class="code">Mnesia</span> transaction system and
    the transaction properties that make <span class="code">Mnesia</span> a fault-tolerant,
    distributed Database Management System (DBMS).</p>
  <p>This section also describes the locking functions,
    including table locks and sticky locks, as well as alternative
    functions that bypass the transaction system in favor of improved
    speed and reduced overhead. These functions are called "dirty
    operations". The use of nested transactions is also described.
    The following topics are included:</p>
  <ul>
    <li>Transaction properties, which include atomicity,
      consistency, isolation, and durability</li>
    <li>Locking</li>
    <li>Dirty operations</li>
    <li>Record names versus table names</li>
    <li>Activity concept and various access contexts</li>
    <li>Nested transactions</li>
    <li>Pattern matching</li>
    <li>Iteration</li>
  </ul>

  <h3>
<a name="trans_prop"></a><a name="id77330">5.1Â 
        Transaction Properties</a>
</h3>
    
    
    <p>Transactions are important when designing fault-tolerant,
      distributed systems. A <span class="code">Mnesia</span> transaction is a mechanism
      by which a series of database operations can be executed as one
      functional block. The functional block that is run as a
      transaction is called a Functional Object (Fun), and this code can
      read, write, and delete <span class="code">Mnesia</span> records. The Fun is evaluated
      as a transaction that either commits or terminates. If a transaction
      succeeds in executing the Fun, it replicates the action on all nodes
      involved, or terminates if an error occurs.</p>
    <p>The following example shows a transaction that raises the
      salary of certain employee numbers:</p>
<div class="example"><pre>raise(Eno, Raise) -&gt;
    F = fun() -&gt;
                [E] = mnesia:read(employee, Eno, write),
                Salary = E#employee.salary + Raise,
                New = E#employee{salary = Salary},
                mnesia:write(New)
        end,
    mnesia:transaction(F).</pre></div>    <p>The function <span class="code">raise/2</span> contains a Fun
      made up of four code lines. This Fun is called by the statement
      <span class="code">mnesia:transaction(F)</span> and returns a value.</p>
    <p>The <span class="code">Mnesia</span> transaction system facilitates the construction of
      reliable, distributed systems by providing the following important
      properties:</p>
    <ul>
      <li>The transaction handler ensures that a Fun, which is placed
       inside a transaction, does not interfere with operations embedded
       in other transactions when it executes a series of operations on
       tables.  
      </li>
      <li>The transaction handler ensures that either all operations
       in the transaction are performed successfully on all nodes
       atomically, or the transaction fails without permanent effect on
       any node.
      </li>
      <li>The <span class="code">Mnesia</span> transactions have four important properties,
       called <strong>A</strong>tomicity,
       <strong>C</strong>onsistency, <strong>I</strong>solation, and
       <strong>D</strong>urability (ACID). These properties are
       described in the following sections.</li>
    </ul>

    <h4>Atomicity</h4>
      
      <p>Atomicity means that database changes that are
        executed by a transaction take effect on all nodes involved, or
        on none of the nodes. That is, the transaction either
        succeeds entirely, or it fails entirely.</p>
      <p>Atomicity is important when it is needed to write
        atomically more than one record in the same
        transaction. The function <span class="code">raise/2</span>, shown in the previous
        example, writes one record only. The function <span class="code">insert_emp/3</span>,
        shown in the program listing in
        <span class="bold_code bc-15"><a href="Mnesia_chap2.html#getting_started">Getting Started</a></span>, writes the record
        <span class="code">employee</span> as well as employee relations, such as
        <span class="code">at_dep</span> and <span class="code">in_proj</span>, into the database. If this
        latter code is run inside a transaction, the transaction
        handler ensures that the transaction either succeeds completely,
        or not at all.</p>
      <p><span class="code">Mnesia</span> is a distributed DBMS where data can be replicated
        on several nodes. In many applications, it is important that a
        series of write operations are performed atomically inside a
        transaction. The atomicity property ensures that a transaction
        takes effect on all nodes, or none.</p>
    

    <h4>Consistency</h4>
      
      <p>The consistency property ensures that
        a transaction always leaves the DBMS in a consistent state. For
        example, <span class="code">Mnesia</span> ensures that no inconsistencies occur if
        Erlang, <span class="code">Mnesia</span>, or the computer crashes while a write
        operation is in progress.</p>
    

    <h4>Isolation</h4>
      
      <p>The isolation property ensures that
        transactions that execute on different nodes in a network, and
        access and manipulate the same data records, do not interfere
        with each other. The isolation property makes it possible to
        execute the function <span class="code">raise/2</span> concurrently. A classical
        problem in concurrency control theory is the "lost update
        problem".</p>
      <p>The isolation property is in particular useful if the following
        circumstances occur where an employee (with employee number
        123) and two processes (P1 and P2) are concurrently trying to
        raise the salary for the employee:</p>
      <ul>
        <li>
<strong>Step 1:</strong> The initial value of the employees salary
        is, for example, 5. Process P1 starts to execute, reads the
        employee record, and adds 2 to the salary.</li>
        <li>
<strong>Step 2:</strong> Process P1 is for some reason pre-empted
        and process P2 has the opportunity to run.</li>
        <li>
<strong>Step 3:</strong> Process P2 reads the record, adds 3 to
        the salary, and finally writes a new employee record with
        the salary set to 8.</li>
        <li>
<strong>Step 4:</strong> Process P1 starts to run again and
        writes its employee record with salary set to 7, thus
        effectively overwriting and undoing the work performed by
        process P2. The update performed by P2 is lost.</li>
      </ul>
      <p>A transaction system makes it possible to execute two or more
        processes concurrently that manipulate the same record.
        The programmer does not need to check that the
        updates are synchronous; this is overseen by the
        transaction handler. All programs accessing the database through
        the transaction system can be written as if they had sole access
        to the data.</p>
    

    <h4>Durability</h4>
      
      <p>The durability property ensures that
        changes made to the DBMS by a transaction are permanent. Once a
        transaction is committed, all changes made to the database are
        durable, that is, they are written safely to disc and do not
        become corrupted and do not disappear.</p>
      <div class="note">
<div class="label">Note</div>
<div class="content"><p>
        <p>The described durability feature does not entirely apply to
          situations where <span class="code">Mnesia</span> is configured as a "pure"
          primary memory database.</p>
      </p></div>
</div>
    
  

  <h3><a name="id77591">5.2Â 
        Locking</a></h3>
    
    <p>Different transaction managers employ different strategies to
      satisfy the isolation property. <span class="code">Mnesia</span> uses the standard
      technique of two phase locking. That is, locks are set on records
      before they are read or written. <span class="code">Mnesia</span> uses the following
      lock types:</p>
    <ul>
      <li>
<strong>Read locks</strong>. A read lock is set on one replica of
       a record before it can be read.
      </li>
      <li>
<strong>Write locks</strong>. Whenever a transaction writes to a
       record, write locks are first set on all replicas of that
       particular record.
      </li>
      <li>
<strong>Read table locks</strong>. If a transaction traverses an
       entire table in search for a record that satisfies some
       particular property, it is most inefficient to set read locks on
       the records one by one. It is also memory consuming, as
       the read locks themselves can take up considerable space if the
       table is large. Therefore, <span class="code">Mnesia</span> can set a read lock
       on an entire table.
      </li>
      <li>
<strong>Write table locks</strong>. If a transaction writes many
       records to one table, a write lock can be set on the entire table.
      </li>
      <li>
<strong>Sticky locks</strong>. These are write locks that stay in
       place at a node after the transaction that initiated the lock
       has terminated.</li>
    </ul>
    <p><span class="code">Mnesia</span> employs a strategy whereby functions, such as
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#read-1">mnesia:read/1</a></span>
      acquire the necessary locks dynamically as
      the transactions execute. <span class="code">Mnesia</span> automatically sets and
      releases the locks and the programmer does not need to code these
      operations.</p>
    <p>Deadlocks can occur when concurrent processes set and release
      locks on the same records. <span class="code">Mnesia</span> employs a "wait-die"
      strategy to resolve
      these situations. If <span class="code">Mnesia</span> suspects that a deadlock can
      occur when a transaction tries to set a lock, the transaction is
      forced to release all its locks and sleep for a while. The Fun
      in the transaction is evaluated once more.</p>
    <p>It is therefore important that the code inside the Fun given to
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#transaction-2"><span class="code">mnesia:transaction/1</span></a></span>
      is pure. Some strange results can
      occur if, for example, messages are sent by the transaction
      Fun. The following example illustrates this situation:</p>
<div class="example"><pre>bad_raise(Eno, Raise) -&gt;
    F = fun() -&gt;
                [E] = mnesia:read({employee, Eno}),
                Salary = E#employee.salary + Raise,
                New = E#employee{salary = Salary},
                io:format("Trying to write ... ~n", []),
                mnesia:write(New)
        end,
    mnesia:transaction(F).</pre></div>    <p>This transaction can write the text <span class="code">"Trying to write ... "</span>
      1000 times to the terminal. However, <span class="code">Mnesia</span> guarantees
      that each transaction will eventually run. As a result,
      <span class="code">Mnesia</span> is not only deadlock free, but also livelock free.</p>
    <p>The <span class="code">Mnesia</span> programmer cannot prioritize one particular
      transaction to execute before other transactions that are waiting
      to execute. As a result, the <span class="code">Mnesia</span> DBMS transaction system is
      not suitable for hard real-time applications. However, <span class="code">Mnesia</span>
      contains other features that have real-time properties.</p>
    <p><span class="code">Mnesia</span> dynamically sets and releases locks as transactions
      execute. It is therefore dangerous to execute code with
      transaction side-effects. In particular, a <span class="code">receive</span>
      statement inside a transaction can lead to a situation where the
      transaction hangs and never returns, which in turn can cause locks
      not to release. This situation can bring the whole system to a
      standstill, as other transactions that execute in other
      processes, or on other nodes, are forced to wait for the defective
      transaction.</p>
    <p>If a transaction terminates abnormally, <span class="code">Mnesia</span>
      automatically releases the locks held by the transaction.</p>
    <p>Up to now, examples of a number of functions that can be used
      inside a transaction have been shown. The following list shows
      the <strong>simplest</strong> <span class="code">Mnesia</span> functions that work with
      transactions. Notice that these functions must be embedded in a
      transaction. If no enclosing transaction (or other enclosing
      <span class="code">Mnesia</span> activity) exists, they all fail.</p>
    <ul>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#transaction-2">mnesia:transaction(Fun) -&gt; {aborted, Reason} |{atomic, Value}</a></span>
       executes one transaction with the
       functional object <span class="code">Fun</span> as the single parameter.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#read-1">mnesia:read({Tab, Key}) -&gt; transaction abort | RecordList</a></span>
       reads all records with <span class="code">Key</span>
       as key from table <span class="code">Tab</span>. This function has the same semantics
       regardless of the location of <span class="code">Table</span>. If the table is of
       type <span class="code">bag</span>, <span class="code">read({Tab, Key})</span> can return an arbitrarily
       long list. If the table is of type <span class="code">set</span>, the list is
       either of length one or <span class="code">[]</span>.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#wread-1">mnesia:wread({Tab, Key}) -&gt; transaction abort | RecordList</a></span>
       behaves the same way as the
       previously listed function <span class="code">read/1</span>, except that it
       acquires a write lock instead of a read lock. To execute a
       transaction that reads a record, modifies the record, and then
       writes the record, it is slightly more efficient to set the
       write lock immediately. When a <span class="bold_code bc-15"><a href="../../man/mnesia.html#read-1">mnesia:read/1</a></span>
       is issued, followed by a
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#write-1">mnesia:write/1</a></span>
       the first read lock must be upgraded to a write lock when the
       write operation is executed.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#write-1">mnesia:write(Record) -&gt; transaction abort | ok</a></span>
       writes a record into the database. Argument
       <span class="code">Record</span> is an instance of a record. The function returns
       <span class="code">ok</span>, or terminates the transaction if an error occurs.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#delete-1">mnesia:delete({Tab, Key}) -&gt; transaction abort | ok</a></span>
       deletes all records with the given key.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#delete_object-1">mnesia:delete_object(Record) -&gt; transaction abort | ok</a></span>
       deletes records with the OID <span class="code">Record</span>. Use this function to
       delete only some records in a table of type <span class="code">bag</span>.</li>
    </ul>

    <h4>Sticky Locks</h4>
      
      <p>As previously stated, the locking strategy used by <span class="code">Mnesia</span>
        is to lock one record when reading a record, and lock all replicas
        of a record when writing a record. However, some
        applications use <span class="code">Mnesia</span> mainly for its fault-tolerant
        qualities. These applications can be configured with one
        node doing all the heavy work, and a standby node that is ready
        to take over if the main node fails. Such applications can
        benefit from using sticky locks instead of the normal locking
        scheme.</p>
      <p>A sticky lock is a lock that stays in place at a node, after
        the transaction that first acquired the lock has terminated. To
        illustrate this, assume that the following transaction is
        executed:</p>
      <div class="example"><pre>        F = fun() -&gt;
              mnesia:write(#foo{a = kalle})
            end,
        mnesia:transaction(F).</pre></div>
      <p>The <span class="code">foo</span> table is replicated on the two nodes <span class="code">N1</span>
        and <span class="code">N2</span>.</p>
      <p>Normal locking requires the following:</p>
      <ul>
        <li>One network RPC (two messages) to acquire the write lock
        </li>
        <li>Three network messages to execute the two-phase commit
         protocol
        </li>
      </ul>
      <p>If sticky locks are used, the code must first be changed as
        follows:</p>
      <div class="example"><pre>        F = fun() -&gt;
              mnesia:s_write(#foo{a = kalle})
            end,
        mnesia:transaction(F).</pre></div>
      <p>This code uses the function
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#s_write-1">s_write/1</a></span>
        instead of the function
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#write-1">write/1</a></span>
        The function <span class="code">s_write/1</span> sets a
        sticky lock instead of a normal lock. If the table is not
        replicated, sticky locks have no special effect. If the table is
        replicated, and a sticky lock is set on node <span class="code">N1</span>, this
        lock then sticks to node <span class="code">N1</span>. The next time you try to
        set a sticky lock on the same record at node <span class="code">N1</span>,
        <span class="code">Mnesia</span> detects that the lock is already set and do no
        network operation to acquire the lock.</p>
      <p>It is more efficient to set a local lock than it is to set
        a networked lock. Sticky locks can therefore benefit an
        application that uses a replicated table and perform most of the
        work on only one of the nodes.</p>
      <p>If a record is stuck at node <span class="code">N1</span> and you try to set a
        sticky lock for the record on node <span class="code">N2</span>, the record must be
        unstuck. This operation is expensive and reduces performance.
        The unsticking is done automatically if you issue <span class="code">s_write/1</span>
        requests at <span class="code">N2</span>.</p>
    

    <h4>Table Locks</h4>
      
      <p><span class="code">Mnesia</span> supports read and write locks on whole tables as a
        complement to the normal locks on single records. As previously
        stated, <span class="code">Mnesia</span> sets and releases locks automatically, and
        the programmer does not need to code these operations. However,
        transactions that read and write many records in a
        specific table execute more efficiently if the
        transaction is started by setting a table lock on this table. This
        blocks other concurrent transactions from the table. The
        following two functions are used to set explicit table locks for
        read and write operations:</p>
      <ul>
        <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#read_lock_table-1">mnesia:read_lock_table(Tab)</a></span>
         sets a read lock on table <span class="code">Tab</span>.</li>
        <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#write_lock_table-1">mnesia:write_lock_table(Tab)</a></span>
         sets a write lock on table <span class="code">Tab</span>.</li>
      </ul>
      <p>Alternative syntax for acquisition of table locks is as
        follows:</p>
      <div class="example"><pre>        mnesia:lock({table, Tab}, read)
        mnesia:lock({table, Tab}, write)</pre></div>
      <p>The matching operations in <span class="code">Mnesia</span> can either lock the
        entire table or only a single record (when the key is bound in
        the pattern).</p>
    

    <h4>Global Locks</h4>
      
      <p>Write locks are normally acquired on all nodes where a
        replica of the table resides (and is active). Read locks are
        acquired on one node (the local one if a local
        replica exists).</p>
      <p>The function
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#lock-2">mnesia:lock/2</a></span>
        is intended to support table locks (as mentioned previously)
        but also for situations when locks need to be
        acquired regardless of how tables have been replicated:</p>
      <div class="example"><pre>        mnesia:lock({global, GlobalKey, Nodes}, LockKind)

        LockKind ::= read | write | ...</pre></div>
      <p>The lock is acquired on <span class="code">LockItem</span> on all nodes in the
        node list.</p>
    
  

  <h3><a name="id78164">5.3Â 
        Dirty Operations</a></h3>
    
    <p>In many applications, the overhead of processing a transaction
      can result in a loss of performance. Dirty operation are short
      cuts that bypass much of the processing and increase the speed
      of the transaction.</p>
    <p>Dirty operation are often useful, for example, in a
      datagram routing application
      where <span class="code">Mnesia</span> stores the routing table, and it is time
      consuming to start a whole transaction every time a packet is
      received. <span class="code">Mnesia</span> has therefore functions that manipulate
      tables without using transactions. This alternative
      to processing is known as a dirty operation. However, notice the
      trade-off in avoiding the overhead of transaction processing:</p>
    <ul>
      <li>The atomicity and the isolation properties of <span class="code">Mnesia</span>
       are lost.
      </li>
      <li>The isolation property is compromised, because other
       Erlang processes, which use transaction to manipulate the data,
       do not get the benefit of isolation if dirty operations
       simultaneously are used to read and write records from the same
       table.
      </li>
    </ul>
    <p>The major advantage of dirty operations is that they execute
      much faster than equivalent operations that are processed as
      functional objects within a transaction.</p>
    <p>Dirty operations
      are written to disc if they are performed on a table of type
      <span class="code">disc_copies</span> or type <span class="code">disc_only_copies</span>. <span class="code">Mnesia</span>
      also ensures that all replicas of a table are updated if a
      dirty write operation is performed on a table.</p>
    <p>A dirty operation ensures a certain level of consistency.
      For example, dirty operations cannot return
      garbled records. Hence, each individual read or write operation
      is performed in an atomic manner.</p>
    <p>All dirty functions execute a call to <span class="code">exit({aborted, Reason})</span>
      on failure. Even if the following functions are
      executed inside a transaction no locks are acquired. The
      following functions are available:</p>
    <ul>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_read-1">mnesia:dirty_read({Tab, Key})</a></span>
       reads one or more records from <span class="code">Mnesia</span>.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_write-1">mnesia:dirty_write(Record)</a></span>
       writes the record <span class="code">Record</span>.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_delete-1">mnesia:dirty_delete({Tab, Key})</a></span>
       deletes one or more records with key <span class="code">Key</span>.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_delete_object-1">mnesia:dirty_delete_object(Record)</a></span>
       is the dirty operation alternative to the function
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#delete_object-1">delete_object/1</a></span>.
      </li>
      <li>
        <p><span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_first-1">mnesia:dirty_first(Tab)</a></span>
          returns the "first" key in table <span class="code">Tab</span>.</p>
        <p>Records in <span class="code">set</span> or <span class="code">bag</span> tables are not sorted.
          However, there is a record order that is unknown to the user.
          This means that a table can be traversed by this function
          with the function
          <span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_next-2">mnesia:dirty_next/2</a></span>.</p>
        <p>If there are no records in the table, this function
          returns the atom <span class="code">'$end_of_table'</span>. It is not
          recommended to use this atom as the key for any user
          records.</p>
      </li>
      <li>
<p><span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_next-2">mnesia:dirty_next(Tab, Key)</a></span>
       returns the "next" key in table <span class="code">Tab</span>. This function makes it
       possible to traverse a table and perform some operation on all
       records in the table. When the end of the table is reached, the
       special key <span class="code">'$end_of_table'</span> is returned. Otherwise, the
       function returns a key that can be used to read the actual
       record.</p>
       <p>The behavior is undefined if any process performs a write
       operation on the table while traversing the table with the
       function
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_next-2">dirty_next/2</a></span>
       This is because <span class="code">write</span>
       operations on a <span class="code">Mnesia</span> table can lead to internal
       reorganizations of the table itself. This is an implementation
       detail, but remember that the dirty functions are low-level
       functions.</p>
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_last-1">mnesia:dirty_last(Tab)</a></span>
       works exactly like
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_first-1">mnesia:dirty_first/1</a></span>
       but returns the last object in
       Erlang term order for the table type <span class="code">ordered_set</span>. For
       all other table types, <span class="code">mnesia:dirty_first/1</span> and 
       <span class="code">mnesia:dirty_last/1</span> are synonyms.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_prev-2">mnesia:dirty_prev(Tab, Key)</a></span>
       works exactly like
       <span class="code">mnesia:dirty_next/2</span> but returns the previous object in
       Erlang term order for the table type <span class="code">ordered_set</span>. For
       all other table types, <span class="code">mnesia:dirty_next/2</span> and
       <span class="code">mnesia:dirty_prev/2</span> are synonyms.
      </li>
      <li>
        <p><span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_slot-2">mnesia:dirty_slot(Tab, Slot)</a></span>
          returns the list of records that are associated with <span class="code">Slot</span>
          in a table. It can be used to traverse a table in a manner
          similar to the function <span class="code">dirty_next/2</span>. A table has a
          number of slots that range from zero to some unknown upper
          bound. The function <span class="code">dirty_slot/2</span> returns the special
          atom <span class="code">'$end_of_table'</span> when the end of the table is
          reached.</p>
        <p>The behavior of this function is undefined if the
          table is written on while being
          traversed. The function
          <span class="bold_code bc-15"><a href="../../man/mnesia.html#read_lock_table-1">mnesia:read_lock_table(Tab)</a></span>
          can be used to ensure that no transaction-protected writes
          are performed during the iteration.</p>
      </li>
      <li>
<p><span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_update_counter-2">mnesia:dirty_update_counter({Tab,Key}, Val)</a></span>.
          Counters are positive integers with a value greater than or
          equal to zero. Updating a counter adds <span class="code">Val</span> and the
          counter where <span class="code">Val</span> is a positive or negative integer.</p>
        <p><span class="code">Mnesia</span> has no special counter records. However, records
          of the form <span class="code">{TabName, Key, Integer}</span> can be used as
          counters, and can be persistent.</p>
        <p>Transaction-protected updates of counter records are not
          possible.</p>
        <p>There are two significant differences when using this
          function instead of reading the record, performing the
          arithmetic, and writing the record:</p>
        <ul>
          <li>It is much more efficient.
          </li>
          <li>The funcion
           <span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_update_counter-2">dirty_update_counter/2</a></span>
           is performed as an atomic operation although it is not protected
           by a transaction. Therfore no table update is lost if two
           processes simultaneously execute the function
          <span class="code">dirty_update_counter/2</span>.
          </li>
        </ul>
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_match_object-2">mnesia:dirty_match_object(Pat)</a></span>
       is the dirty equivalent of
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#match_object-1">mnesia:match_object/1</a></span>.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_select-2">mnesia:dirty_select(Tab, Pat)</a></span>
       is the dirty equivalent of
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#select-2">mnesia:select/2</a></span>.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_index_match_object-2">mnesia:dirty_index_match_object(Pat, Pos)</a></span>
       is the dirty equivalent of
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#index_match_object-2">mnesia:index_match_object/2</a></span>.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_index_read-3">mnesia:dirty_index_read(Tab, SecondaryKey, Pos)</a></span>
       is the dirty equivalent of
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#index_read-3">mnesia:index_read/3</a></span>.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_all_keys-1">mnesia:dirty_all_keys(Tab)</a></span>
       is the dirty equivalent of <span class="bold_code bc-15"><a href="../../man/mnesia.html#all_keys-1">mnesia:all_keys/1</a></span>.
      </li>
    </ul>
  

  <h3>
<a name="recordnames_tablenames"></a><a name="id78627">5.4Â 
        Record Names versus Table Names</a>
</h3>
    
    
    <p>In <span class="code">Mnesia</span>, all records in a table must have the same name.
      All the records must be instances of the same
      record type. The record name, however, does not necessarily have
      to be the same as the table name, although this is the case in
      most of the examples in this User's Guide. If a table is created
      without property <span class="code">record_name</span>, the following code ensures
      that all records in the tables have the same name as the table:</p>
    <div class="example"><pre>      mnesia:create_table(subscriber, [])</pre></div>
    <p>However, if the table is created with an explicit record name
      as argument, as shown in the following example, subscriber records
      can be stored in both of the tables regardless of the table
      names:</p>
    <div class="example"><pre>      TabDef = [{record_name, subscriber}],
      mnesia:create_table(my_subscriber, TabDef),
      mnesia:create_table(your_subscriber, TabDef).</pre></div>
    <p>To access such tables, simplified access functions
      (as described earlier) cannot be used. For example,
      writing a subscriber record into a table requires the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#write-3">mnesia:write/3</a></span>
      instead of the simplified functions
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#write-1">mnesia:write/1</a></span>
      and
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#s_write-1">mnesia:s_write/1</a></span>:</p>
    <div class="example"><pre>      mnesia:write(subscriber, #subscriber{}, write)
      mnesia:write(my_subscriber, #subscriber{}, sticky_write)
      mnesia:write(your_subscriber, #subscriber{}, write)</pre></div>
    <p>The following simple code illustrates the
      relationship between the simplified access functions used in
      most of the examples and their more flexible counterparts:</p>
    <div class="example"><pre>      mnesia:dirty_write(Record) -&gt;
        Tab = element(1, Record),
        mnesia:dirty_write(Tab, Record).
      
      mnesia:dirty_delete({Tab, Key}) -&gt;
        mnesia:dirty_delete(Tab, Key).
      
      mnesia:dirty_delete_object(Record) -&gt;
        Tab = element(1, Record),
        mnesia:dirty_delete_object(Tab, Record) 
      
      mnesia:dirty_update_counter({Tab, Key}, Incr) -&gt;
        mnesia:dirty_update_counter(Tab, Key, Incr).
      
      mnesia:dirty_read({Tab, Key}) -&gt;
        Tab = element(1, Record),
        mnesia:dirty_read(Tab, Key).
      
      mnesia:dirty_match_object(Pattern) -&gt;
        Tab = element(1, Pattern),
        mnesia:dirty_match_object(Tab, Pattern).
      
      mnesia:dirty_index_match_object(Pattern, Attr) 
        Tab = element(1, Pattern),
        mnesia:dirty_index_match_object(Tab, Pattern, Attr).
      
      mnesia:write(Record) -&gt;
        Tab = element(1, Record),
        mnesia:write(Tab, Record, write).
      
      mnesia:s_write(Record) -&gt;
        Tab = element(1, Record),
        mnesia:write(Tab, Record, sticky_write).
      
      mnesia:delete({Tab, Key}) -&gt;
        mnesia:delete(Tab, Key, write).
      
      mnesia:s_delete({Tab, Key}) -&gt;
        mnesia:delete(Tab, Key, sticky_write).
      
      mnesia:delete_object(Record) -&gt;
        Tab = element(1, Record),
        mnesia:delete_object(Tab, Record, write).
      
      mnesia:s_delete_object(Record) -&gt;
        Tab = element(1, Record),
        mnesia:delete_object(Tab, Record, sticky_write).
      
      mnesia:read({Tab, Key}) -&gt;
        mnesia:read(Tab, Key, read).
      
      mnesia:wread({Tab, Key}) -&gt;
        mnesia:read(Tab, Key, write).
      
      mnesia:match_object(Pattern) -&gt;
        Tab = element(1, Pattern),
        mnesia:match_object(Tab, Pattern, read).
      
      mnesia:index_match_object(Pattern, Attr) -&gt;
        Tab = element(1, Pattern),
        mnesia:index_match_object(Tab, Pattern, Attr, read).</pre></div>
  

  <h3><a name="id78726">5.5Â 
        Activity Concept and Various Access Contexts</a></h3>
    
    <p>As previously described, a Functional Object (Fun) performing
      table access operations, as listed here, can be passed
      on as arguments to the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#transaction-2">mnesia:transaction/1,2,3</a></span>:
    </p>
    <ul>
      <li>
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#write-3">mnesia:write/3 (write/1, s_write/1)</a></span>
      </li>
      <li>
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#delete-3">mnesia:delete/3</a></span>
       (<span class="bold_code bc-15"><a href="../../man/mnesia.html#delete-1">mnesia:delete/1</a></span>,
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#s_delete-1">mnesia:s_delete/1</a></span>)
      </li>
      <li>
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#delete_object-3">mnesia:delete_object/3</a></span>
       (<span class="bold_code bc-15"><a href="../../man/mnesia.html#delete_object-1">mnesia:delete_object/1</a></span>,
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#s_delete_object-1">mnesia:s_delete_object/1</a></span>)
      </li>
      <li>
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#read-3">mnesia:read/3</a></span>
       (<span class="bold_code bc-15"><a href="../../man/mnesia.html#read-1">mnesia:read/1</a></span>,
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#wread-1">mnesia:wread/1</a></span>)
      </li>
      <li>
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#match_object-3">mnesia:match_object/2</a></span>
       (<span class="bold_code bc-15"><a href="../../man/mnesia.html#match_object-1">mnesia:match_object/1</a></span>)
      </li>
      <li>
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#select-2">mnesia:select/3</a></span>
       (<span class="bold_code bc-15"><a href="../../man/mnesia.html#select-2">mnesia:select/2</a></span>)
      </li>
      <li>
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#foldl-3">mnesia:foldl/3</a></span>
       (<span class="code">mnesia:foldl/4</span>,
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#foldr-3">mnesia:foldr/3</a></span>,
       <span class="code">mnesia:foldr/4</span>)
      </li>
      <li>
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#all_keys-1">mnesia:all_keys/1</a></span>
      </li>
      <li>
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#index_match_object-4">mnesia:index_match_object/4</a></span>
       (<span class="bold_code bc-15"><a href="../../man/mnesia.html#index_match_object-2">mnesia:index_match_object/2</a></span>)
      </li>
      <li>
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#index_read-3">mnesia:index_read/3</a></span>
      </li>
      <li>
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#lock-2">mnesia:lock/2</a></span>
       (<span class="bold_code bc-15"><a href="../../man/mnesia.html#read_lock_table-1">mnesia:read_lock_table/1</a></span>,
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#write_lock_table-1">mnesia:write_lock_table/1</a></span>)
      </li>
      <li>
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#table_info-2">mnesia:table_info/2</a></span>
      </li>
    </ul>
    <p>These functions are performed in a
      transaction context involving mechanisms, such as locking, logging,
      replication, checkpoints, subscriptions, and commit protocols.
      However, the same function can also be
      evaluated in other activity contexts.</p>
    <p>The following activity access contexts are currently supported:</p>
    <ul>
      <li><span class="code">transaction</span></li>
      <li><span class="code">sync_transaction</span></li>
      <li><span class="code">async_dirty</span></li>
      <li><span class="code">sync_dirty</span></li>
      <li><span class="code">ets</span></li>
    </ul>
    <p>By passing the same "fun" as argument to the function
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#sync_transaction-3">mnesia:sync_transaction(Fun [, Args])</a></span>
      it is performed
      in synced transaction context. Synced transactions wait until all
      active replicas has committed the transaction (to disc) before
      returning from the <span class="code">mnesia:sync_transaction</span> call. Using
      <span class="code">sync_transaction</span> is useful in the following cases:</p>
    <ul>
      <li>When an application executes on several nodes and wants to
       be sure that the update is performed on the remote nodes before
       a remote process is spawned or a message is sent to a remote
       process.</li>
      <li>When a combining transaction writes with "dirty_reads", that
        is, the functions <span class="code">dirty_match_object</span>, <span class="code">dirty_read</span>,
        <span class="code">dirty_index_read</span>, <span class="code">dirty_select</span>, and so on.</li>
      <li>When an application performs frequent or voluminous updates
       that can overload <span class="code">Mnesia</span> on other nodes.</li>
    </ul>
    <p>By passing the same "fun" as argument to the function
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#async_dirty-2">mnesia:async_dirty(Fun [, Args])</a></span>,
      it is performed in dirty context. The function calls are mapped to
      the corresponding dirty functions. This still involves logging,
      replication, and subscriptions but no locking,
      local transaction storage, or commit protocols are involved.
      Checkpoint retainers are updated but updated
      "dirty". Thus, they are updated asynchronously. The
      functions wait for the operation to be performed on one
      node but not the others. If the table resides locally, no waiting
      occurs.</p>
    <p>By passing the same "fun" as an argument to the function
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#sync_dirty-2">mnesia:sync_dirty(Fun [, Args])</a></span>,
      it is performed in almost the same context as the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#async_dirty-2">mnesia:async_dirty/1,2</a></span>.
      The difference is that the operations are performed
      synchronously. The caller waits for the updates to be
      performed on all active replicas. Using <span class="code">mnesia:sync_dirty/1,2</span>
      is useful in the following cases:</p>
    <ul>
      <li>When an application executes on several nodes and wants to
       be sure that the update is performed on the remote nodes before
       a remote process is spawned or a message is sent to a remote
       process.</li>
      <li>When an application performs frequent or voluminous updates
       that can overload <span class="code">Mnesia</span> on the nodes.</li>
      </ul>
    <p>To check if your code is executed within a transaction, use
       the function
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#is_transaction-0">mnesia:is_transaction/0</a></span>.
      It returns <span class="code">true</span> when called
      inside a transaction context, otherwise <span class="code">false</span>.</p>
    <p><span class="code">Mnesia</span> tables with storage type <span class="code">RAM_copies</span> and
      <span class="code">disc_copies</span> are implemented internally as
      <span class="code">ets</span> tables. Applications can access the these tables
      directly. This is only
      recommended if all options have been weighed and the possible
      outcomes are understood. By passing the earlier mentioned "fun"
      to the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#ets-2">mnesia:ets(Fun [, Args])</a></span>,
      it is performed but in a raw
      context. The operations are performed directly on the
      local <span class="code">ets</span> tables, assuming that the local storage type is
      <span class="code">RAM_copies</span> and that the table is not replicated on other
      nodes.</p>
    <p>Subscriptions are not triggered and no checkpoints are updated,
      but this operation is blindingly fast. Disc resident
      tables are not to be updated with the <span class="code">ets</span> function, as the
      disc is not updated.</p>
    <p>The Fun can also be passed as an argument to the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#activity-4">mnesia:activity/2,3,4</a></span>,
      which enables use of customized
      activity access callback modules. It can either be obtained
      directly by stating the module name as argument, or implicitly
      by use of configuration parameter <span class="code">access_module</span>. A
      customized callback module can be used for several purposes,
      such as providing triggers, integrity constraints, runtime
      statistics, or virtual tables.</p>
    <p>The callback module does not have
      to access real <span class="code">Mnesia</span> tables, it is free to do whatever
      it wants as long as the callback interface is fulfilled.</p>
    <p><span class="bold_code bc-19"><a href="Mnesia_App_B.html">Appendix B, Activity Access Callback Interface</a></span> provides the
      source code, <span class="code">mnesia_frag.erl</span>, for one alternative
      implementation. The context-sensitive function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#table_info-2">mnesia:table_info/2</a></span>
      can be used to provide virtual
      information about a table. One use of this is to perform
      <span class="code">QLC</span> queries within an activity context with a
      customized callback module. By providing table information about
      table indexes and other <span class="code">QLC</span> requirements, <span class="code">QLC</span> can
      be used as a generic query language to access virtual tables.</p>
    <p>QLC queries can be performed in all these activity
      contexts (<span class="code">transaction</span>, <span class="code">sync_transaction</span>,
      <span class="code">async_dirty</span>, <span class="code">sync_dirty</span>, and <span class="code">ets</span>). The
      <span class="code">ets</span> activity only works if the table has no indexes.</p>
    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>The function <span class="code">mnesia:dirty_*</span> always executes with
        <span class="code">async_dirty</span> semantics regardless of which activity
        access contexts that are started. It can even start contexts
        without any enclosing activity access context.</p>
    </p></div>
</div>
  

  <h3><a name="id79264">5.6Â 
        Nested Transactions</a></h3>
    
    <p>Transactions can be nested in an arbitrary fashion. A child
      transaction must run in the same process as its parent. When a
      child transaction terminates, the caller of the child transaction
      gets return value <span class="code">{aborted, Reason}</span> and any work performed
      by the child is erased. If a child transaction commits, the
      records written by the child are propagated to the parent.</p>
    <p>No locks are released when child transactions terminate. Locks
      created by a sequence of nested transactions are kept until
      the topmost transaction terminates. Furthermore, any update
      performed by a nested transaction is only propagated
      in such a manner so that the parent of the nested transaction
      sees the updates. No final commitment is done until
      the top-level transaction terminates.
      So, although a nested transaction returns <span class="code">{atomic, Val}</span>,
      if the enclosing parent transaction terminates, the entire
      nested operation terminates.</p>
    <p>The ability to have nested transaction with identical semantics
      as top-level transaction makes it easier to write
      library functions that manipulate <span class="code">Mnesia</span> tables.</p>
    <p>Consider a function that adds a subscriber to a telephony
      system:</p>
    <div class="example"><pre>
      add_subscriber(S) -&gt;
          mnesia:transaction(fun() -&gt;
              case mnesia:read( ..........</pre></div>
    <p>This function needs to be called as a transaction.
      Assume that you wish to write a function that
      both calls the function <span class="code">add_subscriber/1</span> and
      is in itself protected by the context of a transaction.
      By calling <span class="code">add_subscriber/1</span> from within
      another transaction, a nested transaction is created.</p>
    <p>Also, different activity access contexts can be mixed while
      nesting. However, the dirty ones (<span class="code">async_dirty</span>,
      <span class="code">sync_dirty</span>, and <span class="code">ets</span>) inherit the transaction
      semantics if they are called inside a transaction and thus
      grab locks and use two or three phase commit.</p>
    <p><strong>Example:</strong></p>
    <div class="example"><pre>
      add_subscriber(S) -&gt;
          mnesia:transaction(fun() -&gt;
             %% Transaction context 
             mnesia:read({some_tab, some_data}),
             mnesia:sync_dirty(fun() -&gt;
                 %% Still in a transaction context.
                 case mnesia:read( ..) ..end), end).
      add_subscriber2(S) -&gt;
          mnesia:sync_dirty(fun() -&gt;
             %% In dirty context 
             mnesia:read({some_tab, some_data}),
             mnesia:transaction(fun() -&gt;
                 %% In a transaction context.
                 case mnesia:read( ..) ..end), end).</pre></div>
  

  <h3><a name="id79355">5.7Â 
        Pattern Matching</a></h3>
    
    <a name="matching"></a>
    <p>When the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#read-3">mnesia:read/3</a></span>
      cannot be used, <span class="code">Mnesia</span>
      provides the programmer with several functions for matching
      records against a pattern. The most useful ones
      are the following:</p>
    <div class="example"><pre>      mnesia:select(Tab, MatchSpecification, LockKind) -&gt;
          transaction abort | [ObjectList]
      mnesia:select(Tab, MatchSpecification, NObjects, Lock) -&gt;  
          transaction abort | {[Object],Continuation} | '$end_of_table'
      mnesia:select(Cont) -&gt;
          transaction abort | {[Object],Continuation} | '$end_of_table'
      mnesia:match_object(Tab, Pattern, LockKind) -&gt;
          transaction abort | RecordList</pre></div>
    <p>These functions match a <span class="code">Pattern</span> against all records in
      table <span class="code">Tab</span>. In a
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#select-2">mnesia:select</a></span>
      call, <span class="code">Pattern</span> is
      a part of <span class="code">MatchSpecification</span> described in the following. It
      is not necessarily performed as an exhaustive search of the entire
      table. By using indexes and bound values in the key of the
      pattern, the actual work done by the function can be condensed
      into a few hash lookups. Using <span class="code">ordered_set</span> tables can reduce
      the search space if the keys are partially bound.</p>
    <p>The pattern provided to the functions must be a valid record,
      and the first element of the provided tuple must be the
      <span class="code">record_name</span> of the table. The special element <span class="code">'_'</span>
      matches any data structure in Erlang (also known as an Erlang
      term). The special elements <span class="code">'$&lt;number&gt;'</span>
      behave as Erlang variables, that is, they match anything,
      bind the first occurrence, and match the
      coming occurrences of that variable against the bound value.</p>
    <p>Use function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#table_info-2">mnesia:table_info(Tab, wild_pattern)</a></span>
      to obtain a basic pattern, which matches all records in a table,
      or use the default value in record creation.
      Do not make the pattern hard-coded, as this makes the code more
      vulnerable to future changes of the record definition.</p>
    <p><strong>Example:</strong></p>
    <div class="example"><pre>      Wildpattern = mnesia:table_info(employee, wild_pattern), 
      %% Or use
      Wildpattern = #employee{_ = '_'},</pre></div>
    <p>For the employee table, the wild pattern looks as follows:</p>
    <div class="example"><pre>      {employee, '_', '_', '_', '_', '_',' _'}.</pre></div>
    <p>To constrain the match, it is needed to replace some
      of the <span class="code">'_'</span> elements. The code for matching out
      all female employees looks as follows:</p>
    <div class="example"><pre>      Pat = #employee{sex = female, _ = '_'},
      F = fun() -&gt; mnesia:match_object(Pat) end,
      Females = mnesia:transaction(F).</pre></div>
    <p>The match function can also be used to check the equality of
      different attributes. For example, to find all employees with
      an employee number equal to their room number:</p>
    <div class="example"><pre>      Pat = #employee{emp_no = '$1', room_no = '$1', _ = '_'},
      F = fun() -&gt; mnesia:match_object(Pat) end,
      Odd = mnesia:transaction(F).</pre></div>
    <p>The function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#match_object-3">mnesia:match_object/3</a></span>
      lacks some important features that
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#select-2">mnesia:select/3</a></span>
      have. For example,
      <span class="code">mnesia:match_object/3</span> can only return the matching records,
      and it cannot express constraints other than equality. To find
      the names of the male employees on the second floor:</p>
<div class="example"><pre>      MatchHead = #employee{name='$1', sex=male, room_no={'$2', '_'}, _='_'},
      Guard = [{'&gt;=', '$2', 220},{'&lt;', '$2', 230}],
      Result = '$1',
      mnesia:select(employee,[{MatchHead, Guard, [Result]}])</pre></div>    <p>The function <span class="code">select</span> can be used to add more constraints
      and create output that cannot be done with
      <span class="code">mnesia:match_object/3</span>.</p>
    <p>The second argument to <span class="code">select</span> is a <span class="code">MatchSpecification</span>.
      A <span class="code">MatchSpecification</span> is a list of <span class="code">MatchFunction</span>s, where
      each <span class="code">MatchFunction</span> consists of a tuple containing
      <span class="code">{MatchHead, MatchCondition, MatchBody}</span>:</p>
    <ul>
      <li>
<span class="code">MatchHead</span> is the same pattern as used in
       <span class="code">mnesia:match_object/3</span> described earlier.</li>
      <li>
<span class="code">MatchCondition</span> is a list of extra constraints
       applied to each record.</li>
      <li>
<span class="code">MatchBody</span> constructs the return values.</li>
    </ul>
    <p>For details about the match specifications, see
      "Match Specifications in Erlang" in
      <span class="bold_code bc-18"><a href="../../apps/erts/index.html">ERTS</a></span> User's Guide.
      For more information, see the
      <span class="bold_code bc-18"><a href="../../man/ets.html">ets</a></span> and
      <span class="bold_code bc-18"><a href="../../man/dets.html">dets</a></span>
      manual pages in <span class="code">STDLIB</span>.</p>
    <p>The functions
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#select-4">select/4</a></span> and
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#select-2">select/1</a></span>
      are used to
      get a limited number of results, where <span class="code">Continuation</span>
      gets the next chunk of results. <span class="code">Mnesia</span> uses
      <span class="code">NObjects</span> as a recommendation only. Thus, more or less
      results than specified with <span class="code">NObjects</span> can be returned in
      the result list, even the empty list can be returned even
      if there are more results to collect.</p>
    <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
      <p>There is a severe performance penalty in using
        <span class="code">mnesia:select/[1|2|3|4]</span> after any modifying operation
        is done on that table in the same transaction. That is, avoid
        using
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#write-1">mnesia:write/1</a></span> or
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#delete-1">mnesia:delete/1</a></span>
        before <span class="code">mnesia:select</span> in the same transaction.</p>
    </p></div>
</div>
    <p>If the key attribute is bound in a pattern, the match operation
      is efficient. However, if the key attribute in a pattern is
      given as <span class="code">'_'</span> or <span class="code">'$1'</span>, the whole <span class="code">employee</span>
      table must be searched for records that match. Hence if the table is
      large, this can become a time-consuming operation, but it can be
      remedied with indexes (see
      <span class="bold_code bc-15"><a href="Mnesia_chap5.html#indexing">Indexing</a></span>)
      if the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#match_object-1">mnesia:match_object</a></span>
      is used.</p>
    <p>QLC queries can also be used to search <span class="code">Mnesia</span> tables. By
      using the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#table-1">mnesia:table/[1|2]</a></span>
      as the generator inside a QLC
      query, you let the query operate on a <span class="code">Mnesia</span> table.
      <span class="code">Mnesia</span>-specific options to <span class="code">mnesia:table/2</span> are
      <span class="code">{lock, Lock}</span>, <span class="code">{n_objects,Integer}</span>, and
      <span class="code">{traverse, SelMethod}</span>:</p>
    <ul>
      <li>
<span class="code">lock</span> specifies whether <span class="code">Mnesia</span> is to acquire a
       read or write lock on the table.</li>
      <li>
<span class="code">n_objects</span> specifies how many results are to be
       returned in each chunk to QLC.</li>
      <li>
<span class="code">traverse</span> specifies which function <span class="code">Mnesia</span> is
       to use to traverse the table. Default <span class="code">select</span> is used, but
       by using <span class="code">{traverse, {select, MatchSpecification}}</span> as an
       option to
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#table-1">mnesia:table/2</a></span>
       the user can specify its own view of the table.</li>
    </ul>
    <p>If no options are specified, a read lock is acquired, 100
      results are returned in each chunk, and <span class="code">select</span> is used
      to traverse the table, that is:</p>
    <div class="example"><pre>      mnesia:table(Tab) -&gt;
          mnesia:table(Tab, [{n_objects,100},{lock, read}, {traverse, select}]).</pre></div>
    <p>The function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#all_keys-1">mnesia:all_keys(Tab)</a></span>
      returns all keys in a table.</p>
  

  <h3><a name="id79824">5.8Â 
        Iteration</a></h3>
    
    <a name="iteration"></a>
    <p><span class="code">Mnesia</span> provides the following functions that iterate over all
      the records in a table:</p>
    <div class="example"><pre>      mnesia:foldl(Fun, Acc0, Tab) -&gt; NewAcc | transaction abort
      mnesia:foldr(Fun, Acc0, Tab) -&gt; NewAcc | transaction abort
      mnesia:foldl(Fun, Acc0, Tab, LockType) -&gt; NewAcc | transaction abort
      mnesia:foldr(Fun, Acc0, Tab, LockType) -&gt; NewAcc | transaction abort</pre></div>
    <p>These functions iterate over the <span class="code">Mnesia</span> table <span class="code">Tab</span>
      and apply the function <span class="code">Fun</span> to each record. <span class="code">Fun</span>
      takes two arguments, the first is a record from the
      table, and the second is the accumulator.
      <span class="code">Fun</span> returns a new accumulator.</p>
    <p>The first time <span class="code">Fun</span> is applied, <span class="code">Acc0</span> is
      the second argument. The next time <span class="code">Fun</span> is called,
      the return value from the previous call is used as the
      second argument. The term the last call to <span class="code">Fun</span> returns
      is the return value of the function
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#foldl-3">mnesia:foldl/3</a></span> or
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#foldr-3">mnesia:foldr/3</a></span>.</p>
    <p>The difference between these functions is the
      order the table is accessed for <span class="code">ordered_set</span> tables.
      For other table types the functions are equivalent.</p>
    <p><span class="code">LockType</span> specifies what type of lock that is to be
      acquired for the iteration, default is <span class="code">read</span>. If
      records are written or deleted during the iteration, a write
      lock is to be acquired.</p>
    <p>These functions can be used to find records in a table
      when it is impossible to write constraints for the function
       <span class="bold_code bc-15"><a href="../../man/mnesia.html#match_object-3">mnesia:match_object/3</a></span>,
      or when you want to perform some action on certain records.</p>
    <p>For example, finding all the employees who have a salary
      less than 10 can look as follows:</p>
    <div class="example"><pre>      find_low_salaries() -&gt;
        Constraint = 
             fun(Emp, Acc) when Emp#employee.salary &lt; 10 -&gt;
                    [Emp | Acc];
                (_, Acc) -&gt;
                    Acc
             end,
        Find = fun() -&gt; mnesia:foldl(Constraint, [], employee) end,
        mnesia:transaction(Find).</pre></div>
    <p>To raise the salary to 10 for everyone with a salary less than 10
      and return the sum of all raises:</p>
    <div class="example"><pre>      increase_low_salaries() -&gt;
         Increase = 
             fun(Emp, Acc) when Emp#employee.salary &lt; 10 -&gt;
                    OldS = Emp#employee.salary,
                    ok = mnesia:write(Emp#employee{salary = 10}),
                    Acc + 10 - OldS;
                (_, Acc) -&gt;
                    Acc
             end,
        IncLow = fun() -&gt; mnesia:foldl(Increase, 0, employee, write) end,
        mnesia:transaction(IncLow).</pre></div>
    <p>Many nice things can be done with the iterator functions but take
      some caution about performance and memory use for large tables.</p>
    <p>Call these iteration functions on nodes that contain a replica of
      the table. Each call to the function <span class="code">Fun</span> access the table
      and if the table resides on another node it generates much
      unnecessary network traffic.</p>
    <p><span class="code">Mnesia</span> also provides some functions that make it possible
      for the user to iterate over the table. The order of the iteration
      is unspecified if the table is not of type <span class="code">ordered_set</span>:</p>
    <div class="example"><pre>      mnesia:first(Tab) -&gt;  Key | transaction abort
      mnesia:last(Tab)  -&gt;  Key | transaction abort
      mnesia:next(Tab,Key)  -&gt;  Key | transaction abort
      mnesia:prev(Tab,Key)  -&gt;  Key | transaction abort
      mnesia:snmp_get_next_index(Tab,Index) -&gt; {ok, NextIndex} | endOfTable</pre></div>
    <p>The order of <span class="code">first</span>/<span class="code">last</span> and <span class="code">next</span>/<span class="code">prev</span>
      is only valid for
      <span class="code">ordered_set</span> tables, they are synonyms for other tables.
      When the end of the table is reached, the special key
      <span class="code">'$end_of_table'</span> is returned.</p>
    <p>If records are written and deleted during the traversal, use
      the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#foldl">mnesia:foldl/3</a></span> or
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#foldr">mnesia:foldr/3</a></span>
      with a <span class="code">write</span> lock. Or the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#write_lock_table-1">mnesia:write_lock_table/1</a></span>
      when using <span class="code">first</span> and <span class="code">next</span>.</p>
    <p>Writing or deleting in transaction context creates a local copy
      of each modified record. Thus, modifying each record in a large
      table uses much memory. <span class="code">Mnesia</span> compensates for every
      written or deleted record during the iteration in a transaction
      context, which can reduce the performance. If possible, avoid writing
      or deleting records in the same transaction before iterating over the
      table.</p>
    <p>In dirty context, that is, <span class="code">sync_dirty</span> or <span class="code">async_dirty</span>,
      the modified records are not stored in a local copy; instead,
      each record is updated separately. This generates much
      network traffic if the table has a replica on another node and
      has all the other drawbacks that dirty operations
      have. Especially for commands
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#first-1">mnesia:first/1</a></span> and
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#next-2">mnesia:next/2</a></span>,
      the same drawbacks as described previously for
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_first-1">mnesia:dirty_first/1</a></span>
      and
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#dirty_next-2">mnesia:dirty_next/2</a></span>
      applies, that
      is, no writing to the table is to be done during iteration.</p>
  
</div>
<div class="footer">
<hr>
<p>Copyright Â© 1997-2018 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../../js/';</script><script type="text/javascript" src="../../js/highlight.js"></script>
</body>
</html>
