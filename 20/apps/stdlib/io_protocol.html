<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- The Erlang I/O Protocol</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<div class="erlang-logo-wrapper"><a href="../../index.html"><img alt="Erlang Logo" src="../../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">STDLIB</p>
<p class="section-subtitle">User's Guide</p>
<p class="section-version">Version 3.4.4</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="index.html">Reference Manual</a></li>
<li><a href="release_notes.html">Release Notes</a></li>
<li><a href="stdlib.pdf">PDF</a></li>
<li><a href="../../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="introduction.html">
              Top of chapter
            </a></li>
<li title="Scope"><a href="introduction.html#id59653">Scope</a></li>
<li title="Prerequisites"><a href="introduction.html#id62502">Prerequisites</a></li>
</ul>
</li>
<li id="loadscrollpos" title="The Erlang I/O Protocol" expanded="true">The Erlang I/O Protocol<ul>
<li><a href="io_protocol.html">
              Top of chapter
            </a></li>
<li title="Protocol Basics"><a href="io_protocol.html#id62095">Protocol Basics</a></li>
<li title="Output Requests"><a href="io_protocol.html#id62793">Output Requests</a></li>
<li title="Input Requests"><a href="io_protocol.html#id63794">Input Requests</a></li>
<li title="I/O Server Modes"><a href="io_protocol.html#id66680">I/O Server Modes</a></li>
<li title="Multiple I/O Requests"><a href="io_protocol.html#id62417">Multiple I/O Requests</a></li>
<li title="Optional I/O Request"><a href="io_protocol.html#id62466">Optional I/O Request</a></li>
<li title="Unimplemented Request Types"><a href="io_protocol.html#id63688">Unimplemented Request Types</a></li>
<li title="An Annotated and Working Example I/O Server"><a href="io_protocol.html#id63716">An Annotated and Working Example I/O Server</a></li>
</ul>
</li>
<li id="no" title="Using Unicode in Erlang" expanded="false">Using Unicode in Erlang<ul>
<li><a href="unicode_usage.html">
              Top of chapter
            </a></li>
<li title="Unicode Implementation"><a href="unicode_usage.html#id64119">Unicode Implementation</a></li>
<li title="Understanding Unicode"><a href="unicode_usage.html#id67107">Understanding Unicode</a></li>
<li title="What Unicode Is"><a href="unicode_usage.html#id67208">What Unicode Is</a></li>
<li title="Areas of Unicode Support"><a href="unicode_usage.html#id65823">Areas of Unicode Support</a></li>
<li title="Standard Unicode Representation"><a href="unicode_usage.html#id66024">Standard Unicode Representation</a></li>
<li title="Basic Language Support"><a href="unicode_usage.html#id66748">Basic Language Support</a></li>
<li title="The Interactive Shell"><a href="unicode_usage.html#id66144">The Interactive Shell</a></li>
<li title="Unicode Filenames"><a href="unicode_usage.html#id66358">Unicode Filenames</a></li>
<li title="Unicode in Environment and Parameters"><a href="unicode_usage.html#id63184">Unicode in Environment and Parameters</a></li>
<li title="Unicode-Aware Modules"><a href="unicode_usage.html#id63235">Unicode-Aware Modules</a></li>
<li title="Unicode Data in Files"><a href="unicode_usage.html#id63450">Unicode Data in Files</a></li>
<li title="Summary of Options"><a href="unicode_usage.html#id70007">Summary of Options</a></li>
<li title="Recipes"><a href="unicode_usage.html#id70406">Recipes</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>2 The Erlang I/O Protocol</h1>
  

  <p>The I/O protocol in Erlang enables bi-directional communication between
    clients and servers.</p>

  <ul>
    <li>
      <p>The I/O server is a process that handles the requests and performs
      the requested task on, for example, an I/O device.</p>
    </li>
    <li>
      <p>The client is any Erlang process wishing to read or write data from/to
        the I/O device.</p>
    </li>
  </ul>

  <p>The common I/O protocol has been present in OTP since the beginning, but
    has been undocumented and has also evolved over the years. In an
    addendum to Robert Virding's rationale, the original I/O protocol is
    described. This section describes the current I/O protocol.</p>

  <p>The original I/O protocol was simple and flexible. Demands for memory
    efficiency and execution time efficiency have triggered extensions
    to the protocol over the years, making the protocol larger and somewhat
    less easy to implement than the original. It can certainly be argued that
    the current protocol is too complex, but this section describes how it
    looks today, not how it should have looked.</p>

  <p>The basic ideas from the original protocol still hold. The I/O server
    and client communicate with one single, rather simplistic protocol and no
    server state is ever present in the client. Any I/O server can be used
    together with any client code, and the client code does not need to be
    aware of the I/O device that the I/O server communicates with.</p>

  <h3><a name="id62095">2.1 
        Protocol Basics</a></h3>
    
    <p>As described in Robert's paper, I/O servers and clients communicate
      using <span class="code">io_request</span>/<span class="code">io_reply</span> tuples as follows:</p>

    <div class="example"><pre>
{io_request, From, ReplyAs, Request}
{io_reply, ReplyAs, Reply}</pre></div>

    <p>The client sends an <span class="code">io_request</span> tuple to the I/O server and the
      server eventually sends a corresponding <span class="code">io_reply</span> tuple.</p>

    <ul>
      <li>
        <p><span class="code">From</span> is the <span class="code">pid()</span> of the client, the process which
          the I/O server sends the I/O reply to.</p>
      </li>
      <li>
        <p><span class="code">ReplyAs</span> can be any datum and is returned in the
          corresponding <span class="code">io_reply</span>. The
          <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span> module monitors the
          the I/O server and uses the monitor reference as the <span class="code">ReplyAs</span>
          datum. A more complicated client can have many outstanding I/O
          requests to the same I/O server and can use different references (or
          something else) to differentiate among the incoming I/O replies.
          Element <span class="code">ReplyAs</span> is to be considered opaque by the I/O
          server.</p>
        <p>Notice that the <span class="code">pid()</span> of the I/O server is not explicitly
          present in tuple <span class="code">io_reply</span>. The reply can be sent from any
          process, not necessarily the actual I/O server.</p>
      </li>
      <li>
        <p><span class="code">Request</span> and <span class="code">Reply</span> are described below.</p>
      </li>
    </ul>

    <p>When an I/O server receives an <span class="code">io_request</span> tuple, it acts upon the
      <span class="code">Request</span> part and eventually sends an <span class="code">io_reply</span> tuple with
      the corresponding <span class="code">Reply</span> part.</p> 
  

  <h3><a name="id62793">2.2 
        Output Requests</a></h3>
    
    <p>To output characters on an I/O device, the following <span class="code">Request</span>s
      exist:</p>

    <div class="example"><pre>
{put_chars, Encoding, Characters}
{put_chars, Encoding, Module, Function, Args}</pre></div>

    <ul>
      <li>
        <p><span class="code">Encoding</span> is <span class="code">unicode</span> or <span class="code">latin1</span>, meaning that the
          characters are (in case of binaries) encoded as UTF-8 or ISO Latin-1
          (pure bytes). A well-behaved I/O server is also to return an error
	  indication if list elements contain integers &gt; 255
	  when <span class="code">Encoding</span> is set to <span class="code">latin1</span>.</p>
        <p>Notice that this does not in any way tell how characters are to be
          put on the I/O device or handled by the I/O server. Different I/O
          servers can handle the characters however they want, this only tells
          the I/O server which format the data is expected to have. In the
          <span class="code">Module</span>/<span class="code">Function</span>/<span class="code">Args</span> case, <span class="code">Encoding</span> tells
          which format the designated function produces.</p>
        <p>Notice also that byte-oriented data is simplest sent using the ISO
          Latin-1 encoding.</p>
      </li>
      <li>
        <p><span class="code">Characters</span> are the data to be put on the I/O device. If
          <span class="code">Encoding</span> is <span class="code">latin1</span>, this is an <span class="code">iolist()</span>. If
          <span class="code">Encoding</span> is <span class="code">unicode</span>, this is an Erlang standard mixed
          Unicode list (one integer in a list per character, characters in
          binaries represented as UTF-8).</p>
      </li>
      <li>
        <p><span class="code">Module</span>, <span class="code">Function</span>, and <span class="code">Args</span> denote a function
          that is called to produce the data (like
          <span class="bold_code bc-13"><a href="../../man/io_lib.html#format-2"><span class="code">io_lib:format/2</span></a></span>).
        </p>
        <p><span class="code">Args</span> is a list of arguments to the function. The function is
          to produce data in the specified <span class="code">Encoding</span>. The I/O server is
          to call the function as <span class="code">apply(Mod, Func, Args)</span> and put the
          returned data on the I/O device as if it was sent in a
          <span class="code">{put_chars, Encoding, Characters}</span> request. If the function
          returns anything else than a binary or list, or throws an exception,
          an error is to be sent back to the client.</p>
      </li>
    </ul>

    <p>The I/O server replies to the client with an <span class="code">io_reply</span> tuple, where
      element <span class="code">Reply</span> is one of:</p>

    <div class="example"><pre>
ok
{error, Error}</pre></div>

    <ul>
      <li>
<span class="code">Error</span> describes the error to the client, which can do
        whatever it wants with it. The
        <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span> module typically
        returns it "as is".</li>
    </ul>

    <p>For backward compatibility, the following <span class="code">Request</span>s are also to be
      handled by an I/O server (they are not to be present after
      Erlang/OTP R15B):</p>

    <div class="example"><pre>
{put_chars, Characters}
{put_chars, Module, Function, Args}</pre></div>

    <p>These are to behave as <span class="code">{put_chars, latin1, Characters}</span> and
      <span class="code">{put_chars, latin1, Module, Function, Args}</span>, respectively.</p>
  

  <h3><a name="id63794">2.3 
        Input Requests</a></h3>
    
    <p>To read characters from an I/O device, the following <span class="code">Request</span>s
      exist:</p>

    <div class="example"><pre>
{get_until, Encoding, Prompt, Module, Function, ExtraArgs}</pre></div>

    <ul>
      <li>
        <p><span class="code">Encoding</span> denotes how data is to be sent back to the client
          and what data is sent to the function denoted by
          <span class="code">Module</span>/<span class="code">Function</span>/<span class="code">ExtraArgs</span>. If the function
          supplied returns data as a list, the data is converted to this
          encoding. If the function supplied returns data in some other format,
          no conversion can be done, and it is up to the client-supplied
          function to return data in a proper way.</p>
        <p>If <span class="code">Encoding</span> is <span class="code">latin1</span>, lists of integers <span class="code">0..255</span>
          or binaries containing plain bytes are sent back to the client when
          possible. If <span class="code">Encoding</span> is <span class="code">unicode</span>, lists with integers
          in the whole Unicode range or binaries encoded in UTF-8 are sent to
          the client. The user-supplied function always sees lists of
          integers, never binaries, but the list can contain numbers &gt; 255
          if <span class="code">Encoding</span> is <span class="code">unicode</span>.</p>
      </li>
      <li>
        <p><span class="code">Prompt</span> is a list of characters (not mixed, no binaries) or an
          atom to be output as a prompt for input on the I/O device.
          <span class="code">Prompt</span> is often ignored by the I/O server; if set to <span class="code">''</span>,
          it is always to be ignored (and results in nothing being written to
          the I/O device).</p>
      </li>
      <li>
        <p><span class="code">Module</span>, <span class="code">Function</span>, and <span class="code">ExtraArgs</span> denote a
          function and arguments to determine when enough data is written. The
          function is to take two more arguments, the last state, and a list of
          characters. The function is to return one of:</p>
        <div class="example"><pre>
{done, Result, RestChars}
{more, Continuation}</pre></div>
        <p><span class="code">Result</span> can be any Erlang term, but if it is a <span class="code">list()</span>,
          the I/O server can convert it to a <span class="code">binary()</span> of appropriate
          format before returning it to the client, if the I/O server is set in
          binary mode (see below).</p>
        <p>The function is called with the data the I/O server finds on its I/O
          device, returning one of:</p>
        <ul>
          <li>
            <p><span class="code">{done, Result, RestChars}</span> when enough data is read. In
              this case <span class="code">Result</span> is sent to the client and <span class="code">RestChars</span>
              is kept in the I/O server as a buffer for later input.</p>
          </li>
          <li>
            <p><span class="code">{more, Continuation}</span>, which indicates that more
              characters are needed to complete the request.</p>
          </li>
        </ul>
        <p><span class="code">Continuation</span> is sent as the state in later calls to the
          function when more characters are available. When no more characters
          are available, the function must return <span class="code">{done, eof, Rest}</span>. The
          initial state is the empty list. The data when an end of file is
          reached on the IO device is the atom <span class="code">eof</span>.</p>
        <p>An emulation of the <span class="code">get_line</span> request can be (inefficiently)
          implemented using the following functions:</p>
        <div class="example"><pre>-module(demo).
-export([until_newline/3, get_line/1]).

until_newline(_ThisFar,eof,_MyStopCharacter) -&gt;
    {done,eof,[]};
until_newline(ThisFar,CharList,MyStopCharacter) -&gt;
    case
        lists:splitwith(fun(X) -&gt; X =/= MyStopCharacter end,  CharList)
    of
	{L,[]} -&gt;
            {more,ThisFar++L};
	{L2,[MyStopCharacter|Rest]} -&gt;
	    {done,ThisFar++L2++[MyStopCharacter],Rest}
    end.

get_line(IoServer) -&gt;
    IoServer ! {io_request,
                self(),
                IoServer,
                {get_until, unicode, '', ?MODULE, until_newline, [$\n]}},
    receive
        {io_reply, IoServer, Data} -&gt;
	    Data
    end.</pre></div>
        <p>Notice that the last element in the <span class="code">Request</span> tuple
          (<span class="code">[$\n]</span>) is appended to the argument list when the function is
          called. The function is to be called like
          <span class="code">apply(Module, Function, [ State, Data | ExtraArgs ])</span> by the
          I/O server.</p>
      </li>
    </ul>

    <p>A fixed number of characters is requested using the following
      <span class="code">Request</span>:</p>

    <div class="example"><pre>
{get_chars, Encoding, Prompt, N}</pre></div>

    <ul>
      <li>
        <p><span class="code">Encoding</span> and <span class="code">Prompt</span> as for <span class="code">get_until</span>.</p>
      </li>
      <li>
        <p><span class="code">N</span> is the number of characters to be read from the I/O
        device.</p>
      </li>
    </ul>

    <p>A single line (as in former example) is requested with the
      following <span class="code">Request</span>:</p>

    <div class="example"><pre>
{get_line, Encoding, Prompt}</pre></div>

    <ul>
      <li>
<span class="code">Encoding</span> and <span class="code">Prompt</span> as for <span class="code">get_until</span>.</li>
    </ul>

    <p>Clearly, <span class="code">get_chars</span> and <span class="code">get_line</span> could be implemented with
      the <span class="code">get_until</span> request (and indeed they were originally), but
      demands for efficiency have made these additions necessary.</p>

    <p>The I/O server replies to the client with an <span class="code">io_reply</span> tuple, where
      element <span class="code">Reply</span> is one of:</p>

    <div class="example"><pre>
Data
eof
{error, Error}</pre></div>

    <ul>
      <li>
        <p><span class="code">Data</span> is the characters read, in list or binary form
          (depending on the I/O server mode, see the next section).</p>
      </li>
      <li>
        <p><span class="code">eof</span> is returned when input end is reached and no more data is
          available to the client process.</p>
      </li>
      <li>
        <p><span class="code">Error</span> describes the error to the client, which can do
          whatever it wants with it. The
          <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span> module typically
          returns it as is.</p>
      </li>
    </ul>

    <p>For backward compatibility, the following <span class="code">Request</span>s are also to be
      handled by an I/O server (they are not to be present after
      Erlang/OTP R15B):</p>

    <div class="example"><pre>
{get_until, Prompt, Module, Function, ExtraArgs}
{get_chars, Prompt, N}
{get_line, Prompt}</pre></div>

    <p>These are to behave as
      <span class="code">{get_until, latin1, Prompt, Module, Function, ExtraArgs}</span>,
      <span class="code">{get_chars, latin1, Prompt, N}</span>, and
      <span class="code">{get_line, latin1, Prompt}</span>, respectively.</p>
  

  <h3><a name="id66680">2.4 
        I/O Server Modes</a></h3>
    
    <p>Demands for efficiency when reading data from an I/O server has not only
      lead to the addition of the <span class="code">get_line</span> and <span class="code">get_chars</span> requests,
      but has also added the concept of I/O server options. No options are
      mandatory to implement, but all I/O servers in the Erlang standard
      libraries honor the <span class="code">binary</span> option, which allows element
      <span class="code">Data</span> of the <span class="code">io_reply</span> tuple to be a binary instead of a list
      <strong>when possible</strong>. If the data is sent as a binary, Unicode data is
      sent in the standard Erlang Unicode format, that is, UTF-8 (notice that
      the function of the <span class="code">get_until</span> request still gets list data
      regardless of the I/O server mode).</p>

    <p>Notice that the <span class="code">get_until</span> request allows for a function with the
      data specified as always being a list. Also, the return value data from
      such a function can be of any type (as is indeed the case when an
      <span class="bold_code bc-13"><a href="../../man/io.html#fread-2"><span class="code">io:fread/2,3</span></a></span>
      request is sent to an I/O server).
      The client must be prepared for data received as
      answers to those requests to be in various forms. However, the I/O
      server is to convert the results to binaries whenever possible (that is,
      when the function supplied to <span class="code">get_until</span> returns a list). This is
      done in the example in section
      <span class="bold_code bc-17"><a href="#example_io_server">An Annotated and Working Example I/O Server</a></span>.
    </p>

    <p>An I/O server in binary mode affects the data sent to the client, so that
      it must be able to handle binary data. For convenience, the modes of an
      I/O server can be set and retrieved using the following I/O requests:</p>

    <div class="example"><pre>
{setopts, Opts}</pre></div>

    <ul>
      <li>
<span class="code">Opts</span> is a list of options in the format recognized by the
          <span class="bold_code bc-18"><a href="../../man/proplists.html"><span class="code">proplists</span></a></span> module
          (and by the I/O server).</li>
    </ul>

    <p>As an example, the I/O server for the interactive shell (in
      <span class="code">group.erl</span>) understands the following options:</p>

    <div class="example"><pre>
{binary, boolean()} (or binary/list)
{echo, boolean()}
{expand_fun, fun()}
{encoding, unicode/latin1} (or unicode/latin1)</pre></div>

    <p>Options <span class="code">binary</span> and <span class="code">encoding</span> are common for all I/O servers
      in OTP, while <span class="code">echo</span> and <span class="code">expand</span> are valid only for this I/O
      server. Option <span class="code">unicode</span> notifies how characters are put on the
      physical I/O device, that is, if the terminal itself is Unicode-aware.
      It does not affect how characters are sent in the I/O protocol, where
      each request contains encoding information for the provided or returned
      data.</p>

    <p>The I/O server is to send one of the following as <span class="code">Reply</span>:</p>

    <div class="example"><pre>
ok
{error, Error}</pre></div>

    <p>An error (preferably <span class="code">enotsup</span>) is to be expected if the option is
      not supported by the I/O server (like if an <span class="code">echo</span> option is sent in
      a <span class="code">setopts</span> request to a plain file).</p>

    <p>To retrieve options, the following request is used:</p>

    <div class="example"><pre>
getopts</pre></div>

    <p>This request asks for a complete list of all options supported by the
      I/O server as well as their current values.</p>

    <p>The I/O server replies:</p>

    <div class="example"><pre>
OptList
{error, Error}</pre></div>

    <ul>
      <li>
<span class="code">OptList</span> is a list of tuples <span class="code">{Option, Value}</span>, where
        <span class="code">Option</span> always is an atom.</li>
    </ul>
  

  <h3><a name="id62417">2.5 
        Multiple I/O Requests</a></h3>
    
    <p>The <span class="code">Request</span> element can in itself contain many <span class="code">Request</span>s
      by using the following format:</p>

    <div class="example"><pre>
{requests, Requests}</pre></div>

    <ul>
      <li>
<span class="code">Requests</span> is a list of valid <span class="code">io_request</span> tuples for the
        protocol. They must be executed in the order that they appear in
        the list. The execution is to continue until one of the requests results
        in an error or the list is consumed. The result of the last request is
        sent back to the client.</li>
    </ul>

    <p>The I/O server can, for a list of requests, send any of the following
      valid results in the reply, depending on the requests in the list:</p>

    <div class="example"><pre>
ok
{ok, Data}
{ok, Options}
{error, Error}</pre></div>
  

  <h3><a name="id62466">2.6 
        Optional I/O Request</a></h3>
    
    <p>The following I/O request is optional to implement and a client is to
      be prepared for an error return:</p>

    <div class="example"><pre>
{get_geometry, Geometry}</pre></div>

    <ul>
      <li>
<span class="code">Geometry</span> is the atom <span class="code">rows</span> or the atom
        <span class="code">columns</span>.</li>
    </ul>

    <p>The I/O server is to send the <span class="code">Reply</span> as:</p>

    <div class="example"><pre>
{ok, N}
{error, Error}</pre></div>

   <ul>
     <li>
<span class="code">N</span> is the number of character rows or columns that the I/O
       device has, if applicable to the I/O device handled by the I/O server,
       otherwise <span class="code">{error, enotsup}</span> is a good answer.</li>
    </ul>
  

  <h3><a name="id63688">2.7 
        Unimplemented Request Types</a></h3>
    
    <p>If an I/O server encounters a request that it does not recognize (that
      is, the <span class="code">io_request</span> tuple has the expected format, but the
      <span class="code">Request</span> is unknown), the I/O server is to send a valid reply with
      the error tuple:</p>

    <div class="example"><pre>
{error, request}</pre></div>

    <p>This makes it possible to extend the protocol with optional requests
      and for the clients to be somewhat backward compatible.</p>
  

  <h3><a name="id63716">2.8 
        An Annotated and Working Example I/O Server</a></h3>
    
    <a name="example_io_server"></a>
    <p>An I/O server is any process capable of handling the I/O protocol. There
      is no generic I/O server behavior, but could well be. The framework is
      simple, a process handling incoming requests, usually both I/O-requests
      and other I/O device-specific requests (positioning, closing, and so on).
    </p>

    <p>The example I/O server stores characters in an ETS table, making
      up a fairly crude RAM file.</p>

    <p>The module begins with the usual directives, a function to start the
      I/O server and a main loop handling the requests:</p>

    <div class="example"><pre>-module(ets_io_server).

-export([start_link/0, init/0, loop/1, until_newline/3, until_enough/3]).

-define(CHARS_PER_REC, 10).

-record(state, {
	  table,
	  position, % absolute
	  mode % binary | list
	 }).

start_link() -&gt;
    spawn_link(?MODULE,init,[]).

init() -&gt;
    Table = ets:new(noname,[ordered_set]),
    ?MODULE:loop(#state{table = Table, position = 0, mode=list}).

loop(State) -&gt;
    receive
	{io_request, From, ReplyAs, Request} -&gt;
	    case request(Request,State) of
		{Tag, Reply, NewState} when Tag =:= ok; Tag =:= error -&gt;
		    reply(From, ReplyAs, Reply),
		    ?MODULE:loop(NewState);
		{stop, Reply, _NewState} -&gt;
		    reply(From, ReplyAs, Reply),
		    exit(Reply)
	    end;
	%% Private message
	{From, rewind} -&gt;
	    From ! {self(), ok},
	    ?MODULE:loop(State#state{position = 0});
	_Unknown -&gt;
	    ?MODULE:loop(State)
    end.</pre></div>

    <p>The main loop receives messages from the client (which can use the
      the <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span> module to send
      requests). For each request, the function <span class="code">request/2</span> is called and a
      reply is eventually sent using function <span class="code">reply/3</span>.</p>

    <p>The "private" message <span class="code">{From, rewind}</span> results in the
      current position in the pseudo-file to be reset to <span class="code">0</span> (the beginning
      of the "file"). This is a typical example of I/O device-specific
      messages not being part of the I/O protocol. It is usually a bad idea to
      embed such private messages in <span class="code">io_request</span> tuples, as that can
      confuse the reader.</p>

    <p>First, we examine the reply function:</p>

    <div class="example"><pre>reply(From, ReplyAs, Reply) -&gt;
    From ! {io_reply, ReplyAs, Reply}.</pre></div>

    <p>It sends the <span class="code">io_reply</span> tuple back to the client, providing element
      <span class="code">ReplyAs</span> received in the request along with the result of the
      request, as described earlier.</p>

    <p>We need to handle some requests. First the requests for writing
      characters:</p>

    <div class="example"><pre>request({put_chars, Encoding, Chars}, State) -&gt;
    put_chars(unicode:characters_to_list(Chars,Encoding),State);
request({put_chars, Encoding, Module, Function, Args}, State) -&gt;
    try
	request({put_chars, Encoding, apply(Module, Function, Args)}, State)
    catch
	_:_ -&gt;
	    {error, {error,Function}, State}
    end;</pre></div>

   <p>The <span class="code">Encoding</span> says how the characters in the request are
     represented. We want to store the characters as lists in the ETS
     table, so we convert them to lists using function
     <span class="bold_code bc-13"><a href="../../man/unicode.html#characters_to_list-2"><span class="code">unicode:characters_to_list/2</span></a></span>.
     The conversion function conveniently accepts the encoding types
     <span class="code">unicode</span> and <span class="code">latin1</span>, so we can use <span class="code">Encoding</span> directly.</p>

    <p>When <span class="code">Module</span>, <span class="code">Function</span>, and <span class="code">Arguments</span> are provided,
      we apply it and do the same with the result as if the data was provided
      directly.</p>

    <p>We handle the requests for retrieving data:</p>

    <div class="example"><pre>request({get_until, Encoding, _Prompt, M, F, As}, State) -&gt;
    get_until(Encoding, M, F, As, State);
request({get_chars, Encoding, _Prompt, N}, State) -&gt;
    %% To simplify the code, get_chars is implemented using get_until
    get_until(Encoding, ?MODULE, until_enough, [N], State);
request({get_line, Encoding, _Prompt}, State) -&gt;
    %% To simplify the code, get_line is implemented using get_until
    get_until(Encoding, ?MODULE, until_newline, [$\n], State);</pre></div>

   <p>Here we have cheated a little by more or less only implementing
     <span class="code">get_until</span> and using internal helpers to implement <span class="code">get_chars</span>
      and <span class="code">get_line</span>. In production code, this can be inefficient, but
      that depends on the frequency of the different requests. Before we start
      implementing functions <span class="code">put_chars/2</span> and <span class="code">get_until/5</span>, we
      examine the few remaining requests:</p>

    <div class="example"><pre>request({get_geometry,_}, State) -&gt;
    {error, {error,enotsup}, State};
request({setopts, Opts}, State) -&gt;
    setopts(Opts, State);
request(getopts, State) -&gt;
    getopts(State);
request({requests, Reqs}, State) -&gt;
     multi_request(Reqs, {ok, ok, State});</pre></div>

    <p>Request <span class="code">get_geometry</span> has no meaning for this I/O server, so the
      reply is <span class="code">{error, enotsup}</span>. The only option we handle is
      <span class="code">binary</span>/<span class="code">list</span>, which is done in separate functions.</p>

    <p>The multi-request tag (<span class="code">requests</span>) is handled in a separate loop
      function applying the requests in the list one after another, returning
      the last result.</p>

    <p>We need to handle backward compatibility and the
      <span class="bold_code bc-18"><a href="../../man/file.html"><span class="code">file</span></a></span> module (which
      uses the old requests until backward compatibility with pre-R13 nodes is
      no longer needed). Notice that the I/O server does not work with a simple
      <span class="code">file:write/2</span> if these are not added:</p>

    <div class="example"><pre>request({put_chars,Chars}, State) -&gt;
    request({put_chars,latin1,Chars}, State);
request({put_chars,M,F,As}, State) -&gt;
    request({put_chars,latin1,M,F,As}, State);
request({get_chars,Prompt,N}, State) -&gt;
    request({get_chars,latin1,Prompt,N}, State);
request({get_line,Prompt}, State) -&gt;
    request({get_line,latin1,Prompt}, State);
request({get_until, Prompt,M,F,As}, State) -&gt;
    request({get_until,latin1,Prompt,M,F,As}, State);</pre></div>

    <p><span class="code">{error, request}</span> must be returned if the request is not
      recognized:</p>

    <div class="example"><pre>request(_Other, State) -&gt;
    {error, {error, request}, State}.</pre></div>

    <p>Next we handle the different requests, first the fairly generic
      multi-request type:</p>

    <div class="example"><pre>multi_request([R|Rs], {ok, _Res, State}) -&gt;
    multi_request(Rs, request(R, State));
multi_request([_|_], Error) -&gt;
    Error;
multi_request([], Result) -&gt;
    Result.</pre></div>

    <p>We loop through the requests one at the time, stopping when we either
      encounter an error or the list is exhausted. The last return value is
      sent back to the client (it is first returned to the main loop and then
      sent back by function <span class="code">io_reply</span>).</p>

    <p>Requests <span class="code">getopts</span> and <span class="code">setopts</span> are also simple to handle.
      We only change or read the state record:</p>

    <div class="example"><pre>setopts(Opts0,State) -&gt;
    Opts = proplists:unfold(
	     proplists:substitute_negations(
	       [{list,binary}], 
	       Opts0)),
    case check_valid_opts(Opts) of
	true -&gt;
	        case proplists:get_value(binary, Opts) of
		    true -&gt;
			{ok,ok,State#state{mode=binary}};
		    false -&gt;
			{ok,ok,State#state{mode=binary}};
		    _ -&gt;
			{ok,ok,State}
		end;
	false -&gt;
	    {error,{error,enotsup},State}
    end.
check_valid_opts([]) -&gt;
    true;
check_valid_opts([{binary,Bool}|T]) when is_boolean(Bool) -&gt;
    check_valid_opts(T);
check_valid_opts(_) -&gt;
    false.

getopts(#state{mode=M} = S) -&gt;
    {ok,[{binary, case M of
		      binary -&gt;
			  true;
		      _ -&gt;
			  false
		  end}],S}.</pre></div>

    <p>As a convention, all I/O servers handle both <span class="code">{setopts, [binary]}</span>,
      <span class="code">{setopts, [list]}</span>, and <span class="code">{setopts,[{binary, boolean()}]}</span>,
      hence the trick with <span class="code">proplists:substitute_negations/2</span> and
      <span class="code">proplists:unfold/1</span>. If invalid options are sent to us, we send
      <span class="code">{error, enotsup}</span> back to the client.</p>

    <p>Request <span class="code">getopts</span> is to return a list of <span class="code">{Option, Value}</span>
      tuples. This has the twofold function of providing both the current values
      and the available options of this I/O server. We have only one option, and
      hence return that.</p>

    <p>So far this I/O server is fairly generic (except for request
      <span class="code">rewind</span> handled in the main loop and the creation of an ETS
      table). Most I/O servers contain code similar to this one.</p>

    <p>To make the example runnable, we start implementing the reading and
      writing of the data to/from the ETS table. First function
      <span class="code">put_chars/3</span>:</p>

    <div class="example"><pre>put_chars(Chars, #state{table = T, position = P} = State) -&gt;
    R = P div ?CHARS_PER_REC,
    C = P rem ?CHARS_PER_REC,
    [ apply_update(T,U) || U &lt;- split_data(Chars, R, C) ],
    {ok, ok, State#state{position = (P + length(Chars))}}.</pre></div>

    <p>We already have the data as (Unicode) lists and therefore only split
      the list in runs of a predefined size and put each run in the table at
      the current position (and forward). Functions <span class="code">split_data/3</span> and
      <span class="code">apply_update/2</span> are implemented below.</p>

    <p>Now we want to read data from the table. Function <span class="code">get_until/5</span>
      reads data and applies the function until it says that it is done. The
      result is sent back to the client:</p>

    <div class="example"><pre>get_until(Encoding, Mod, Func, As, 
	  #state{position = P, mode = M, table = T} = State) -&gt;
    case get_loop(Mod,Func,As,T,P,[]) of
	{done,Data,_,NewP} when is_binary(Data); is_list(Data) -&gt;
	    if
		M =:= binary -&gt; 
		    {ok, 
		     unicode:characters_to_binary(Data, unicode, Encoding),
		     State#state{position = NewP}};
		true -&gt;
		    case check(Encoding, 
		               unicode:characters_to_list(Data, unicode))
                    of
			{error, _} = E -&gt;
			    {error, E, State};
			List -&gt;
			    {ok, List,
			     State#state{position = NewP}}
		    end
	    end;
	{done,Data,_,NewP} -&gt;
	    {ok, Data, State#state{position = NewP}};
	Error -&gt;
	    {error, Error, State}
    end.

get_loop(M,F,A,T,P,C) -&gt;
    {NewP,L} = get(P,T),
    case catch apply(M,F,[C,L|A]) of
	{done, List, Rest} -&gt;
	    {done, List, [], NewP - length(Rest)};
	{more, NewC} -&gt;
	    get_loop(M,F,A,T,NewP,NewC);
	_ -&gt;
	    {error,F}
    end.</pre></div>

    <p>Here we also handle the mode (<span class="code">binary</span> or <span class="code">list</span>) that can be
      set by request <span class="code">setopts</span>. By default, all OTP I/O servers send data
      back to the client as lists, but switching mode to <span class="code">binary</span> can
      increase efficiency if the I/O server handles it in an appropriate way.
      The implementation of <span class="code">get_until</span> is difficult to get efficient, as
      the supplied function is defined to take lists as arguments, but
      <span class="code">get_chars</span> and <span class="code">get_line</span> can be optimized for binary mode.
      However, this example does not optimize anything.</p>

    <p>It is important though that the returned data is of the correct type
      depending on the options set. We therefore convert the lists to binaries
      in the correct encoding <strong>if possible</strong> before returning. The
      function supplied in the <span class="code">get_until</span> request tuple can, as its final
      result return anything, so only functions returning lists can get them
      converted to binaries. If the request contains encoding tag
      <span class="code">unicode</span>, the lists can contain all Unicode code points and the
      binaries are to be in UTF-8. If the encoding tag is <span class="code">latin1</span>, the
      client is only to get characters in the range <span class="code">0..255</span>. Function
      <span class="code">check/2</span> takes care of not returning arbitrary Unicode code points
      in lists if the encoding was specified as <span class="code">latin1</span>. If the function
      does not return a list, the check cannot be performed and the result is
      that of the supplied function untouched.</p>

    <p>To manipulate the table we implement the following utility functions:</p>

    <div class="example"><pre>check(unicode, List) -&gt;
    List;
check(latin1, List) -&gt;
    try 
	[ throw(not_unicode) || X &lt;- List,
				X &gt; 255 ],
	List
    catch
	throw:_ -&gt;
	    {error,{cannot_convert, unicode, latin1}}
    end.</pre></div>

    <p>The function check provides an error tuple if Unicode code points &gt;
      255 are to be returned if the client requested <span class="code">latin1</span>.</p>

    <p>The two functions <span class="code">until_newline/3</span> and <span class="code">until_enough/3</span> are
      helpers used together with function <span class="code">get_until/5</span> to implement
      <span class="code">get_chars</span> and <span class="code">get_line</span> (inefficiently):</p>

    <div class="example"><pre>until_newline([],eof,_MyStopCharacter) -&gt;
    {done,eof,[]};
until_newline(ThisFar,eof,_MyStopCharacter) -&gt;
    {done,ThisFar,[]};
until_newline(ThisFar,CharList,MyStopCharacter) -&gt;
    case
        lists:splitwith(fun(X) -&gt; X =/= MyStopCharacter end,  CharList)
    of
	{L,[]} -&gt;
            {more,ThisFar++L};
	{L2,[MyStopCharacter|Rest]} -&gt;
	    {done,ThisFar++L2++[MyStopCharacter],Rest}
    end.

until_enough([],eof,_N) -&gt;
    {done,eof,[]};
until_enough(ThisFar,eof,_N) -&gt;
    {done,ThisFar,[]};
until_enough(ThisFar,CharList,N) 
  when length(ThisFar) + length(CharList) &gt;= N -&gt;
    {Res,Rest} = my_split(N,ThisFar ++ CharList, []),
    {done,Res,Rest};
until_enough(ThisFar,CharList,_N) -&gt;
    {more,ThisFar++CharList}.</pre></div>

    <p>As can be seen, the functions above are just the type of functions that
      are to be provided in <span class="code">get_until</span> requests.</p>

    <p>To complete the I/O server, we only need to read and write the table in
      an appropriate way:</p>

    <div class="example"><pre>get(P,Tab) -&gt;
    R = P div ?CHARS_PER_REC,
    C = P rem ?CHARS_PER_REC,
    case ets:lookup(Tab,R) of
	[] -&gt;
	    {P,eof};
	[{R,List}] -&gt;
	    case my_split(C,List,[]) of
		{_,[]} -&gt;
		    {P+length(List),eof};
		{_,Data} -&gt;
		    {P+length(Data),Data}
	    end
    end.

my_split(0,Left,Acc) -&gt;
    {lists:reverse(Acc),Left};
my_split(_,[],Acc) -&gt;
    {lists:reverse(Acc),[]};
my_split(N,[H|T],Acc) -&gt;
    my_split(N-1,T,[H|Acc]).

split_data([],_,_) -&gt;
    [];
split_data(Chars, Row, Col) -&gt;
    {This,Left} = my_split(?CHARS_PER_REC - Col, Chars, []),
    [ {Row, Col, This} | split_data(Left, Row + 1, 0) ].

apply_update(Table, {Row, Col, List}) -&gt;     
    case ets:lookup(Table,Row) of
	[] -&gt;
	    ets:insert(Table,{Row, lists:duplicate(Col,0) ++ List});
	[{Row, OldData}] -&gt;
	    {Part1,_} = my_split(Col,OldData,[]),
	    {_,Part2} = my_split(Col+length(List),OldData,[]),
	    ets:insert(Table,{Row, Part1 ++ List ++ Part2})
    end.</pre></div>

    <p>The table is read or written in chunks of <span class="code">?CHARS_PER_REC</span>,
      overwriting when necessary. The implementation is clearly not efficient,
      it is just working.</p>

    <p>This concludes the example. It is fully runnable and you can read or
      write to the I/O server by using, for example, the
      <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span> module or even the
      <span class="bold_code bc-18"><a href="../../man/file.html"><span class="code">file</span></a></span> module. It is
      as simple as that to implement a fully fledged I/O server in Erlang.</p>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2018 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../../js/';</script><script type="text/javascript" src="../../js/highlight.js"></script>
</body>
</html>
