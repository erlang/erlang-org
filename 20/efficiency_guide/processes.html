<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- Processes</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<div class="erlang-logo-wrapper"><a href="../index.html"><img alt="Erlang Logo" src="../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Efficiency Guide</p>
<p class="section-subtitle">User's Guide</p>
<p class="section-version">Version 9.3</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="../pdf/otp-system-documentation.pdf">PDF</a></li>
<li><a href="../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="introduction.html">
              Top of chapter
            </a></li>
<li title="Purpose"><a href="introduction.html#id58468">Purpose</a></li>
<li title="Prerequisites"><a href="introduction.html#id58120">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="The Seven Myths of Erlang Performance" expanded="false">The Seven Myths of Erlang Performance<ul>
<li><a href="myths.html">
              Top of chapter
            </a></li>
<li title="Myth: Tail-Recursive Functions are Much Faster
    Than Recursive Functions"><a href="myths.html#id62685">Myth: Tail-Recursive Functions are Much Faster
    Than Recursive Functions</a></li>
<li title='Myth: Operator "++" is Always Bad'><a href="myths.html#id62670">Myth: Operator "++" is Always Bad</a></li>
<li title="Myth: Strings are Slow"><a href="myths.html#id67312">Myth: Strings are Slow</a></li>
<li title="Myth: Repairing a Dets File is Very Slow"><a href="myths.html#id60597">Myth: Repairing a Dets File is Very Slow</a></li>
<li title="Myth: BEAM is a Stack-Based Byte-Code Virtual Machine
    (and Therefore Slow)"><a href="myths.html#id58187">Myth: BEAM is a Stack-Based Byte-Code Virtual Machine
    (and Therefore Slow)</a></li>
<li title='Myth: Use "_" to Speed Up Your Program When a Variable
    is Not Used'><a href="myths.html#id62091">Myth: Use "_" to Speed Up Your Program When a Variable
    is Not Used</a></li>
<li title="Myth: A NIF Always Speeds Up Your Program"><a href="myths.html#id60513">Myth: A NIF Always Speeds Up Your Program</a></li>
</ul>
</li>
<li id="no" title="Common Caveats" expanded="false">Common Caveats<ul>
<li><a href="commoncaveats.html">
              Top of chapter
            </a></li>
<li title="Timer Module"><a href="commoncaveats.html#id62244">Timer Module</a></li>
<li title="list_to_atom/1"><a href="commoncaveats.html#id62642">list_to_atom/1</a></li>
<li title="length/1"><a href="commoncaveats.html#id62873">length/1</a></li>
<li title="setelement/3"><a href="commoncaveats.html#id65199">setelement/3</a></li>
<li title="size/1"><a href="commoncaveats.html#id62577">size/1</a></li>
<li title="split_binary/2"><a href="commoncaveats.html#id64018">split_binary/2</a></li>
<li title='Operator "--"'><a href="commoncaveats.html#id67356">Operator "--"</a></li>
</ul>
</li>
<li id="no" title="Constructing and Matching Binaries" expanded="false">Constructing and Matching Binaries<ul>
<li><a href="binaryhandling.html">
              Top of chapter
            </a></li>
<li title="How Binaries are Implemented"><a href="binaryhandling.html#id66452">How Binaries are Implemented</a></li>
<li title="Constructing Binaries"><a href="binaryhandling.html#id66358">Constructing Binaries</a></li>
<li title="Matching Binaries"><a href="binaryhandling.html#id68180">Matching Binaries</a></li>
<li title="Historical Note"><a href="binaryhandling.html#id67006">Historical Note</a></li>
</ul>
</li>
<li id="no" title="List Handling" expanded="false">List Handling<ul>
<li><a href="listHandling.html">
              Top of chapter
            </a></li>
<li title="Creating a List"><a href="listHandling.html#id67073">Creating a List</a></li>
<li title="List Comprehensions"><a href="listHandling.html#id69197">List Comprehensions</a></li>
<li title="Deep and Flat Lists"><a href="listHandling.html#id69278">Deep and Flat Lists</a></li>
<li title="Recursive List Functions"><a href="listHandling.html#id69425">Recursive List Functions</a></li>
</ul>
</li>
<li id="no" title="Functions" expanded="false">Functions<ul>
<li><a href="functions.html">
              Top of chapter
            </a></li>
<li title="Pattern Matching"><a href="functions.html#id69552">Pattern Matching</a></li>
<li title="Function Calls"><a href="functions.html#id69782">Function Calls</a></li>
<li title="Memory Usage in Recursion"><a href="functions.html#id69898">Memory Usage in Recursion</a></li>
</ul>
</li>
<li id="no" title="Tables and Databases" expanded="false">Tables and Databases<ul>
<li><a href="tablesDatabases.html">
              Top of chapter
            </a></li>
<li title="Ets, Dets, and Mnesia"><a href="tablesDatabases.html#id69988">Ets, Dets, and Mnesia</a></li>
<li title="Ets-Specific"><a href="tablesDatabases.html#id70385">Ets-Specific</a></li>
<li title="Mnesia-Specific"><a href="tablesDatabases.html#id70495">Mnesia-Specific</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Processes" expanded="true">Processes<ul>
<li><a href="processes.html">
              Top of chapter
            </a></li>
<li title="Creating an Erlang Process"><a href="processes.html#id70616">Creating an Erlang Process</a></li>
<li title="Process Messages"><a href="processes.html#id70776">Process Messages</a></li>
<li title="SMP Emulator"><a href="processes.html#id70983">SMP Emulator</a></li>
</ul>
</li>
<li id="no" title="Drivers" expanded="false">Drivers<ul>
<li><a href="drivers.html">
              Top of chapter
            </a></li>
<li title="Drivers and Concurrency"><a href="drivers.html#id71079">Drivers and Concurrency</a></li>
<li title="Avoiding Copying Binaries When Calling a Driver"><a href="drivers.html#id71119">Avoiding Copying Binaries When Calling a Driver</a></li>
<li title="Returning Small Binaries from a Driver"><a href="drivers.html#id71195">Returning Small Binaries from a Driver</a></li>
<li title="Returning Large Binaries without Copying from a Driver"><a href="drivers.html#id71230">Returning Large Binaries without Copying from a Driver</a></li>
</ul>
</li>
<li id="no" title="Advanced" expanded="false">Advanced<ul>
<li><a href="advanced.html">
              Top of chapter
            </a></li>
<li title="Memory"><a href="advanced.html#id71365">Memory</a></li>
<li title="System Limits"><a href="advanced.html#id71800">System Limits</a></li>
</ul>
</li>
<li id="no" title="Profiling" expanded="false">Profiling<ul>
<li><a href="profiling.html">
              Top of chapter
            </a></li>
<li title="Do Not Guess About Performance - Profile"><a href="profiling.html#id72359">Do Not Guess About Performance - Profile</a></li>
<li title="Memory profiling"><a href="profiling.html#id72531">Memory profiling</a></li>
<li title="Large Systems"><a href="profiling.html#id72628">Large Systems</a></li>
<li title="What to Look For"><a href="profiling.html#id72691">What to Look For</a></li>
<li title="Tools"><a href="profiling.html#id72748">Tools</a></li>
<li title="Benchmarking"><a href="profiling.html#id73246">Benchmarking</a></li>
</ul>
</li>
<li id="no" title="Retired Myths" expanded="false">Retired Myths<ul>
<li><a href="retired_myths.html">
              Top of chapter
            </a></li>
<li title="Myth: Funs are Slow"><a href="retired_myths.html#id73392">Myth: Funs are Slow</a></li>
<li title="Myth: List Comprehensions are Slow"><a href="retired_myths.html#id73421">Myth: List Comprehensions are Slow</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>8 Processes</h1>
  

  <h3><a name="id70616">8.1 
        Creating an Erlang Process</a></h3>
    

    <p>An Erlang process is lightweight compared to threads and
    processes in operating systems.</p>

    <p>A newly spawned Erlang process uses 309 words of memory
    in the non-SMP emulator without HiPE support. (SMP support
    and HiPE support both add to this size.) The size can
    be found as follows:</p>

    <div class="example"><pre>
Erlang (BEAM) emulator version 5.6 [async-threads:0] [kernel-poll:false]

Eshell V5.6  (abort with ^G)
1&gt; <span class="bold_code bc-12">Fun = fun() -&gt; receive after infinity -&gt; ok end end.</span>
#Fun&lt;...&gt;
2&gt; <span class="bold_code bc-12">{_,Bytes} = process_info(spawn(Fun), memory).</span>
{memory,1232}
3&gt; <span class="bold_code bc-12">Bytes div erlang:system_info(wordsize).</span>
309</pre></div>
    
    <p>The size includes 233 words for the heap area (which includes the
    stack). The garbage collector increases the heap as needed.</p>

    <p>The main (outer) loop for a process <strong>must</strong> be tail-recursive.
    Otherwise, the stack grows until the process terminates.</p>

    <p><strong>DO NOT</strong></p>
    <div class="example"><pre>loop() -&gt; 
  receive
     {sys, Msg} -&gt;
         handle_sys_msg(Msg),
         loop();
     {From, Msg} -&gt;
          Reply = handle_msg(Msg),
          From ! Reply,
          loop()
  end,
  io:format("Message is processed~n", []).</pre></div>

    <p>The call to <span class="code">io:format/2</span> will never be executed, but a
    return address will still be pushed to the stack each time
    <span class="code">loop/0</span> is called recursively. The correct tail-recursive
    version of the function looks as follows:</p>

    <p><strong>DO</strong></p>
<div class="example"><pre>   loop() -&gt; 
      receive
         {sys, Msg} -&gt;
            handle_sys_msg(Msg),
            loop();
         {From, Msg} -&gt;
            Reply = handle_msg(Msg),
            From ! Reply,
            loop()
    end.</pre></div>

    <h4>Initial Heap Size</h4>
      

      <p>The default initial heap size of 233 words is quite conservative
      to support Erlang systems with hundreds of thousands or
      even millions of processes. The garbage collector grows and
      shrinks the heap as needed.</p>

      <p>In a system that use comparatively few processes, performance
      <strong>might</strong> be improved by increasing the minimum heap size
      using either the <span class="code">+h</span> option for
      <span class="bold_code bc-18"><a href="../man/erl.html">erl</a></span> or on a process-per-process
      basis using the <span class="code">min_heap_size</span> option for
      <span class="bold_code bc-13"><a href="../man/erlang.html#spawn_opt-4">spawn_opt/4</a></span>.</p>

      <p>The gain is twofold:</p>
      <ul>
	<li>Although the garbage collector grows the heap, it grows it
	step-by-step, which is more costly than directly establishing a
	larger heap when the process is spawned.</li>
	<li>The garbage collector can also shrink the heap if it is
	much larger than the amount of data stored on it;
	setting the minimum heap size prevents that.</li>
      </ul>

      <div class="warning">
<div class="label">Warning</div>
<div class="content"><p><p>The emulator probably uses more memory, and because garbage
      collections occur less frequently, huge binaries can be
      kept much longer.</p></p></div>
</div>

      <p>In systems with many processes, computation tasks that run
      for a short time can be spawned off into a new process with
      a higher minimum heap size. When the process is done, it sends
      the result of the computation to another process and terminates.
      If the minimum heap size is calculated properly, the process might
      not have to do any garbage collections at all.
      <strong>This optimization is not to be attempted
      without proper measurements.</strong></p>
    
  

  <h3><a name="id70776">8.2 
        Process Messages</a></h3>
    

    <p>All data in messages between Erlang processes is copied,
      except for
      <span class="bold_code bc-15"><a href="binaryhandling.html#refc_binary">refc binaries</a></span>
      on the same Erlang node.</p>

    <p>When a message is sent to a process on another Erlang node,
      it is first encoded to the Erlang External Format before
      being sent through a TCP/IP socket. The receiving Erlang node decodes
      the message and distributes it to the correct process.</p>

    <h4>Constant Pool</h4>
      

      <p>Constant Erlang terms (also called <strong>literals</strong>) are
      kept in constant pools; each loaded module has its own pool.
      The following function does not build the tuple every time
      it is called (only to have it discarded the next time the garbage
      collector was run), but the tuple is located in the module's
      constant pool:</p>

    <p><strong>DO</strong></p>
      <div class="example"><pre>days_in_month(M) -&gt;
    element(M, {31,28,31,30,31,30,31,31,30,31,30,31}).</pre></div>

      <p>But if a constant is sent to another process (or stored in
      an Ets table), it is <strong>copied</strong>.
      The reason is that the runtime system must be able
      to keep track of all references to constants to unload code
      containing constants properly. (When the code is unloaded,
      the constants are copied to the heap of the processes that refer
      to them.) The copying of constants might be eliminated in a future
      Erlang/OTP release.</p>
    

    <h4>Loss of Sharing</h4>
      

      <p>Shared subterms are <strong>not</strong> preserved in the following
      cases:</p>
      <ul>
	<li>When a term is sent to another process</li>
	<li>When a term is passed as the initial process arguments in
	the <span class="code">spawn</span> call</li>
	<li>When a term is stored in an Ets table</li>
      </ul>
      <p>That is an optimization. Most applications do not send messages
      with shared subterms.</p>

      <p>The following example shows how a shared subterm can be created:</p>

      <div class="example"><pre>kilo_byte() -&gt;
    kilo_byte(10, [42]).

kilo_byte(0, Acc) -&gt;
    Acc;
kilo_byte(N, Acc) -&gt;
    kilo_byte(N-1, [Acc|Acc]).</pre></div>

       <p><span class="code">kilo_byte/1</span> creates a deep list.
       If <span class="code">list_to_binary/1</span> is called, the deep list can be
       converted to a binary of 1024 bytes:</p>

      <div class="example"><pre>
1&gt; <span class="bold_code bc-12">byte_size(list_to_binary(efficiency_guide:kilo_byte())).</span>
1024</pre></div>

       <p>Using the <span class="code">erts_debug:size/1</span> BIF, it can be seen that the
       deep list only requires 22 words of heap space:</p>

      <div class="example"><pre>
2&gt; <span class="bold_code bc-12">erts_debug:size(efficiency_guide:kilo_byte()).</span>
22</pre></div>

       <p>Using the <span class="code">erts_debug:flat_size/1</span> BIF, the size of the
       deep list can be calculated if sharing is ignored. It becomes
       the size of the list when it has been sent to another process
       or stored in an Ets table:</p>

      <div class="example"><pre>
3&gt; <span class="bold_code bc-12">erts_debug:flat_size(efficiency_guide:kilo_byte()).</span>
4094</pre></div>

      <p>It can be verified that sharing will be lost if the data is
      inserted into an Ets table:</p>

      <div class="example"><pre>
4&gt; <span class="bold_code bc-12">T = ets:new(tab, []).</span>
#Ref&lt;0.1662103692.2407923716.214181&gt;
5&gt; <span class="bold_code bc-12">ets:insert(T, {key,efficiency_guide:kilo_byte()}).</span>
true
6&gt; <span class="bold_code bc-12">erts_debug:size(element(2, hd(ets:lookup(T, key)))).</span>
4094
7&gt; <span class="bold_code bc-12">erts_debug:flat_size(element(2, hd(ets:lookup(T, key)))).</span>
4094</pre></div>

      <p>When the data has passed through an Ets table,
      <span class="code">erts_debug:size/1</span> and <span class="code">erts_debug:flat_size/1</span>
      return the same value. Sharing has been lost.</p>

      <p>In a future Erlang/OTP release, it might be implemented a
      way to (optionally) preserve sharing.</p>
    
  

  <h3><a name="id70983">8.3 
        SMP Emulator</a></h3>
    

    <p>The SMP emulator (introduced in R11B) takes advantage of a
    multi-core or multi-CPU computer by running several Erlang scheduler
    threads (typically, the same as the number of cores). Each scheduler
    thread schedules Erlang processes in the same way as the Erlang scheduler
    in the non-SMP emulator.</p>

    <p>To gain performance by using the SMP emulator, your application
    <strong>must have more than one runnable Erlang process</strong> most of the time.
    Otherwise, the Erlang emulator can still only run one Erlang process
    at the time, but you must still pay the overhead for locking. Although
    Erlang/OTP tries to reduce the locking overhead as much as possible,
    it will never become exactly zero.</p>

    <p>Benchmarks that appear to be concurrent are often sequential.
    The estone benchmark, for example, is entirely sequential. So is
    the most common implementation of the "ring benchmark"; usually one process
    is active, while the others wait in a <span class="code">receive</span> statement.</p>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 2001-2018 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../js/';</script><script type="text/javascript" src="../js/highlight.js"></script>
</body>
</html>
