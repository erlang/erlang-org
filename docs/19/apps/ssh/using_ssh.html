<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Getting Started</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="index.html">Reference Manual</a><br><a href="release_notes.html">Release Notes</a><br><a href="ssh.pdf">PDF</a><br><a href="../../index.html">Top</a></small><p><strong>SSH</strong><br><strong>User's Guide</strong><br><small>Version 4.4.1</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="introduction.html">
              Top of chapter
            </a></li>
<li title="Scope and Purpose"><a href="introduction.html#id59760">Scope and Purpose</a></li>
<li title="Prerequisites"><a href="introduction.html#id62096">Prerequisites</a></li>
<li title="SSH Protocol Overview"><a href="introduction.html#id61901">SSH Protocol Overview</a></li>
<li title="Where to Find More Information"><a href="introduction.html#id61436">Where to Find More Information</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Getting Started" expanded="true">Getting Started<ul>
<li><a href="using_ssh.html">
              Top of chapter
            </a></li>
<li title="General Information"><a href="using_ssh.html#id61567">General Information</a></li>
<li title="Using the Erlang ssh Terminal Client"><a href="using_ssh.html#id62057">Using the Erlang ssh Terminal Client</a></li>
<li title="Running an Erlang ssh Daemon"><a href="using_ssh.html#id57316">Running an Erlang ssh Daemon</a></li>
<li title="One-Time Execution"><a href="using_ssh.html#id61310">One-Time Execution</a></li>
<li title="SFTP Server"><a href="using_ssh.html#id61366">SFTP Server</a></li>
<li title="SFTP Client"><a href="using_ssh.html#id62503">SFTP Client</a></li>
<li title="SFTP Client with TAR Compression and Encryption"><a href="using_ssh.html#id62522">SFTP Client with TAR Compression and Encryption</a></li>
<li title="Creating a Subsystem"><a href="using_ssh.html#id62554">Creating a Subsystem</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>2 Getting Started</h1>
  

  <h3><a name="id61567">2.1 
        General Information</a></h3>
    
    <p>The following examples use the utility function
    <span class="bold_code"><a href="../../man/ssh.html#start-0">ssh:start/0</a></span> to start
    all needed applications (<span class="code">crypto</span>, <span class="code">public_key</span>, and <span class="code">ssh</span>).
    All examples are run in an Erlang shell, or in a bash shell, using <strong>openssh</strong>
    to illustrate how the <span class="code">ssh</span> application can be used. The
    examples are run as the user <span class="code">otptest</span> on a local network where the
    user is authorized to log in over <span class="code">ssh</span> to the host <strong>tarlop</strong>.
    </p>
    <p>If nothing else is stated, it is presumed that the <span class="code">otptest</span> user
    has an entry in the <strong>authorized_keys</strong> file of <strong>tarlop</strong>
    (allowed to log in over <span class="code">ssh</span> without entering a password).
    Also, <strong>tarlop</strong> is a known host in the <span class="code">known_hosts</span>
    file of the user <span class="code">otptest</span>. This means that host-verification
    can be done without user-interaction.
    </p>
  

  <h3><a name="id62057">2.2 
        Using the Erlang ssh Terminal Client</a></h3>
    

    <p>The user <span class="code">otptest</span>, which has bash as default shell, uses the
    <span class="code">ssh:shell/1</span> client to connect to the <strong>openssh</strong> daemon running on a
    host called <strong>tarlop</strong>:</p>

    <div class="example"><pre>
      1&gt;  ssh:start().
      ok
      2&gt; {ok, S} = ssh:shell("tarlop").
      otptest@tarlop:&gt; pwd
      /home/otptest
      otptest@tarlop:&gt; exit
      logout
      3&gt;
    </pre></div>
  

  <h3>
<a name="Running%20an%20Erlang%20ssh%20Daemon"></a><a name="id57316">2.3 
        Running an Erlang ssh Daemon</a>
</h3>
    
    

    <p>The <span class="code">system_dir</span> option must be a directory containing a host
    key file and it defaults to <span class="code">/etc/ssh</span>. For details, see Section
    Configuration Files in <span class="bold_code"><a href="../../man/SSH_app.html">ssh(6)</a></span>.
    </p>

    <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>Normally, the <span class="code">/etc/ssh</span> directory is only readable by root.</p>
    </p></div>
</div>

    <p>The option <span class="code">user_dir</span> defaults to directory <span class="code">users ~/.ssh</span>.</p>

    <p><strong>Step 1.</strong> To run the example without root privileges,
    generate new keys and host keys:</p>

    <div class="example"><pre>
      $bash&gt; ssh-keygen -t rsa -f /tmp/ssh_daemon/ssh_host_rsa_key
      [...]
      $bash&gt; ssh-keygen -t rsa -f /tmp/otptest_user/.ssh/id_rsa
      [...]
    </pre></div>

    <p><strong>Step 2.</strong> Create the file <span class="code">/tmp/otptest_user/.ssh/authorized_keys</span>
    and add the content of <span class="code">/tmp/otptest_user/.ssh/id_rsa.pub</span>.</p>

    <p><strong>Step 3.</strong> Start the Erlang <span class="code">ssh</span> daemon:</p>

    <div class="example"><pre>
      1&gt; ssh:start().
      ok
      2&gt; {ok, Sshd} = ssh:daemon(8989, [{system_dir, "/tmp/ssh_daemon"},
                                        {user_dir, "/tmp/otptest_user/.ssh"}]).
      {ok,&lt;0.54.0&gt;}
      3&gt;
    </pre></div>

    <p><strong>Step 4.</strong> Use the <strong>openssh</strong> client from a shell to connect
    to the Erlang <span class="code">ssh</span> daemon:</p>

    <div class="example"><pre>
      $bash&gt; ssh tarlop -p 8989  -i /tmp/otptest_user/.ssh/id_rsa\
             -o UserKnownHostsFile=/tmp/otptest_user/.ssh/known_hosts
      The authenticity of host 'tarlop' can't be established.
      RSA key fingerprint is 14:81:80:50:b1:1f:57:dd:93:a8:2d:2f:dd:90:ae:a8.
      Are you sure you want to continue connecting (yes/no)? yes
      Warning: Permanently added 'tarlop' (RSA) to the list of known hosts.
      Eshell V5.10  (abort with ^G)
      1&gt;
    </pre></div>

    <p>There are two ways of shutting down an <span class="code">ssh</span> daemon,
    see <strong>Step 5a</strong> and <strong>Step 5b</strong>.</p>

    <p><strong>Step 5a.</strong> Shut down the Erlang <span class="code">ssh</span> daemon so that it
    stops the listener but leaves existing connections, started by the listener,
    operational:</p>

    <div class="example"><pre>
      3&gt; ssh:stop_listener(Sshd).
      ok
      4&gt;
    </pre></div>

    <p><strong>Step 5b.</strong> Shut down the Erlang <span class="code">ssh</span> daemon so that it
    stops the listener and all connections started by the listener:</p>

    <div class="example"><pre>
      3&gt; ssh:stop_daemon(Sshd)
      ok
      4&gt;
    </pre></div>

  

  <h3><a name="id61310">2.4 
        One-Time Execution</a></h3>
    

    <p>In the following example, the Erlang shell is the client process
    that receives the channel replies.</p>

    <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>The number of received messages in this example depends on which OS
    and which shell that is used on the machine running the <span class="code">ssh</span> daemon.
    See also <span class="bold_code"><a href="../../man/ssh_connection.html#exec-4">ssh_connection:exec/4</a></span>.
    </p></p></div>
</div>

    <p>Do a one-time execution of a remote command over <span class="code">ssh</span>:</p>

    <div class="example"><pre>
      1&gt;  ssh:start().
      ok
      2&gt; {ok, ConnectionRef} = ssh:connect("tarlop", 22, []).
      {ok,&lt;0.57.0&gt;}
      3&gt;{ok, ChannelId} =  ssh_connection:session_channel(ConnectionRef, infinity).
      {ok,0}
      4&gt; success = ssh_connection:exec(ConnectionRef, ChannelId, "pwd", infinity).
      5&gt;  flush().
      Shell got {ssh_cm,&lt;0.57.0&gt;,{data,0,0,&lt;&lt;"/home/otptest\n"&gt;&gt;}}
      Shell got {ssh_cm,&lt;0.57.0&gt;,{eof,0}}
      Shell got {ssh_cm,&lt;0.57.0&gt;,{exit_status,0,0}}
      Shell got {ssh_cm,&lt;0.57.0&gt;,{closed,0}}
      ok
      6&gt;
    </pre></div>

    <p>Notice that only the channel is closed. The connection is still up and can
    handle other channels:</p>

    <div class="example"><pre>
      6&gt; {ok, NewChannelId} =  ssh_connection:session_channel(ConnectionRef, infinity).
        {ok,1}
	...
    </pre></div>
  

  <h3><a name="id61366">2.5 
        SFTP Server</a></h3>
    

    <p>Start the Erlang <span class="code">ssh</span> daemon with the SFTP subsystem:</p>

    <div class="example"><pre>
      1&gt; ssh:start().
      ok
      2&gt; ssh:daemon(8989, [{system_dir, "/tmp/ssh_daemon"},
                           {user_dir, "/tmp/otptest_user/.ssh"},
                           {subsystems, [ssh_sftpd:subsystem_spec([{cwd, "/tmp/sftp/example"}])
                                        ]}]).
      {ok,&lt;0.54.0&gt;}
      3&gt;
    </pre></div>

    <p>Run the OpenSSH SFTP client:</p>

    <div class="example"><pre>
      $bash&gt; sftp -oPort=8989 -o IdentityFile=/tmp/otptest_user/.ssh/id_rsa\
             -o UserKnownHostsFile=/tmp/otptest_user/.ssh/known_hosts tarlop
      Connecting to tarlop...
      sftp&gt; pwd
      Remote working directory: /tmp/sftp/example
      sftp&gt;
    </pre></div>
  

  <h3><a name="id62503">2.6 
        SFTP Client</a></h3>
    

    <p>Fetch a file with the Erlang SFTP client:</p>

    <div class="example"><pre>
      1&gt; ssh:start().
      ok
      2&gt; {ok, ChannelPid, Connection} = ssh_sftp:start_channel("tarlop", []).
      {ok,&lt;0.57.0&gt;,&lt;0.51.0&gt;}
      3&gt;  ssh_sftp:read_file(ChannelPid, "/home/otptest/test.txt").
      {ok,&lt;&lt;"This is a test file\n"&gt;&gt;}
    </pre></div>
  

  <h3><a name="id62522">2.7 
        SFTP Client with TAR Compression and Encryption</a></h3>
    

    <p>Example of writing and then reading a tar file follows:</p>
    <div class="example"><pre>
      {ok,HandleWrite} = ssh_sftp:open_tar(ChannelPid, ?tar_file_name, [write]),
      ok = erl_tar:add(HandleWrite, .... ),
      ok = erl_tar:add(HandleWrite, .... ),
      ...
      ok = erl_tar:add(HandleWrite, .... ),
      ok = erl_tar:close(HandleWrite),

      %% And for reading
      {ok,HandleRead} = ssh_sftp:open_tar(ChannelPid, ?tar_file_name, [read]),
      {ok,NameValueList} = erl_tar:extract(HandleRead,[memory]),
      ok = erl_tar:close(HandleRead),
    </pre></div>

    <p>The previous write and read example can be extended with encryption and decryption as follows:</p>
    <div class="example"><pre>
%% First three parameters depending on which crypto type we select:
Key = &lt;&lt;"This is a 256 bit key. abcdefghi"&gt;&gt;,
Ivec0 = crypto:strong_rand_bytes(16),
DataSize = 1024,  % DataSize rem 16 = 0 for aes_cbc

%% Initialization of the CryptoState, in this case it is the Ivector.
InitFun = fun() -&gt; {ok, Ivec0, DataSize} end,

%% How to encrypt:
EncryptFun =
    fun(PlainBin,Ivec) -&gt;
        EncryptedBin = crypto:block_encrypt(aes_cbc256, Key, Ivec, PlainBin),
        {ok, EncryptedBin, crypto:next_iv(aes_cbc,EncryptedBin)}
    end,

%% What to do with the very last block:
CloseFun =
    fun(PlainBin, Ivec) -&gt;
        EncryptedBin = crypto:block_encrypt(aes_cbc256, Key, Ivec,
                                            pad(16,PlainBin) %% Last chunk
                                           ),
       {ok, EncryptedBin}
    end,

Cw = {InitFun,EncryptFun,CloseFun},
{ok,HandleWrite} = ssh_sftp:open_tar(ChannelPid, ?tar_file_name, [write,{crypto,Cw}]),
ok = erl_tar:add(HandleWrite, .... ),
ok = erl_tar:add(HandleWrite, .... ),
...
ok = erl_tar:add(HandleWrite, .... ),
ok = erl_tar:close(HandleWrite),

%% And for decryption (in this crypto example we could use the same InitFun
%% as for encryption):
DecryptFun =
    fun(EncryptedBin,Ivec) -&gt;
        PlainBin = crypto:block_decrypt(aes_cbc256, Key, Ivec, EncryptedBin),
       {ok, PlainBin, crypto:next_iv(aes_cbc,EncryptedBin)}
    end,

Cr = {InitFun,DecryptFun},
{ok,HandleRead} = ssh_sftp:open_tar(ChannelPid, ?tar_file_name, [read,{crypto,Cw}]),
{ok,NameValueList} = erl_tar:extract(HandleRead,[memory]),
ok = erl_tar:close(HandleRead),
    </pre></div>
  

  <h3><a name="id62554">2.8 
        Creating a Subsystem</a></h3>
    

    <p>A small <span class="code">ssh</span> subsystem that echoes N bytes can be implemented as shown
    in the following example:</p>

    <div class="example"><pre>
-module(ssh_echo_server).
-behaviour(ssh_daemon_channel).
-record(state, {
	  n,
	  id,
	  cm
	 }).
-export([init/1, handle_msg/2, handle_ssh_msg/2, terminate/2]).

init([N]) -&gt;
    {ok, #state{n = N}}.

handle_msg({ssh_channel_up, ChannelId, ConnectionManager}, State) -&gt;
    {ok, State#state{id = ChannelId,
		     cm = ConnectionManager}}.

handle_ssh_msg({ssh_cm, CM, {data, ChannelId, 0, Data}}, #state{n = N} = State) -&gt;
    M = N - size(Data),
    case M &gt; 0 of
	true -&gt;
	   ssh_connection:send(CM, ChannelId, Data),
	   {ok, State#state{n = M}};
	false -&gt;
	   &lt;&lt;SendData:N/binary, _/binary&gt;&gt; = Data,
           ssh_connection:send(CM, ChannelId, SendData),
           ssh_connection:send_eof(CM, ChannelId),
	   {stop, ChannelId, State}
    end;
handle_ssh_msg({ssh_cm, _ConnectionManager,
		{data, _ChannelId, 1, Data}}, State) -&gt;
    error_logger:format(standard_error, " ~p~n", [binary_to_list(Data)]),
    {ok, State};

handle_ssh_msg({ssh_cm, _ConnectionManager, {eof, _ChannelId}}, State) -&gt;
    {ok, State};

handle_ssh_msg({ssh_cm, _, {signal, _, _}}, State) -&gt;
    %% Ignore signals according to RFC 4254 section 6.9.
    {ok, State};

handle_ssh_msg({ssh_cm, _, {exit_signal, ChannelId, _, _Error, _}},
	       State) -&gt;
    {stop, ChannelId,  State};

handle_ssh_msg({ssh_cm, _, {exit_status, ChannelId, _Status}}, State) -&gt;
    {stop, ChannelId, State}.

terminate(_Reason, _State) -&gt;
    ok.
 </pre></div>

 <p>The subsystem can be run on the host <strong>tarlop</strong> with the generated keys,
 as described in Section <span class="bold_code"><a href="#Running%20an%20Erlang%20ssh%20Daemon">Running an Erlang ssh Daemon</a></span>:</p>

 <div class="example"><pre>
   1&gt; ssh:start().
   ok
   2&gt; ssh:daemon(8989, [{system_dir, "/tmp/ssh_daemon"},
                        {user_dir, "/tmp/otptest_user/.ssh"}
                        {subsystems, [{"echo_n", {ssh_echo_server, [10]}}]}]).
   {ok,&lt;0.54.0&gt;}
   3&gt;
 </pre></div>

 <div class="example"><pre>
   1&gt; ssh:start().
   ok
   2&gt;{ok, ConnectionRef} = ssh:connect("tarlop", 8989, [{user_dir, "/tmp/otptest_user/.ssh"}]).
    {ok,&lt;0.57.0&gt;}
   3&gt;{ok, ChannelId} = ssh_connection:session_channel(ConnectionRef, infinity).
   4&gt; success = ssh_connection:subsystem(ConnectionRef, ChannelId, "echo_n", infinity).
   5&gt; ok = ssh_connection:send(ConnectionRef, ChannelId, "0123456789", infinity).
   6&gt; flush().
   {ssh_msg, &lt;0.57.0&gt;, {data, 0, 1, "0123456789"}}
   {ssh_msg, &lt;0.57.0&gt;, {eof, 0}}
   {ssh_msg, &lt;0.57.0&gt;, {closed, 0}}
   7&gt; {error, closed} = ssh_connection:send(ConnectionRef, ChannelId, "10", infinity).
 </pre></div>
<p>See also <span class="bold_code"><a href="../../man/ssh_channel.html">ssh_channel(3)</a></span>.</p>



</div>
<div class="footer">
<hr>
<p>Copyright © 2005-2017 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
