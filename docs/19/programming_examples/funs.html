<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- Funs</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="../pdf/otp-system-documentation.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Programming Examples</strong><br><strong>User's Guide</strong><br><small>Version 8.3</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../js/flipmenu">
<li id="no" title="Records" expanded="false">Records<ul>
<li><a href="records.html">
              Top of chapter
            </a></li>
<li title="Records and Tuples"><a href="records.html#id62060">Records and Tuples</a></li>
<li title="Defining a Record"><a href="records.html#id61372">Defining a Record</a></li>
<li title="Creating a Record"><a href="records.html#id62187">Creating a Record</a></li>
<li title="Accessing a Record Field"><a href="records.html#id61956">Accessing a Record Field</a></li>
<li title="Updating a Record"><a href="records.html#id61234">Updating a Record</a></li>
<li title="Type Testing"><a href="records.html#id61655">Type Testing</a></li>
<li title="Pattern Matching"><a href="records.html#id61679">Pattern Matching</a></li>
<li title="Nested Records"><a href="records.html#id62298">Nested Records</a></li>
<li title="A Longer Example"><a href="records.html#id57545">A Longer Example</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Funs" expanded="true">Funs<ul>
<li><a href="funs.html">
              Top of chapter
            </a></li>
<li title="map"><a href="funs.html#id57608">map</a></li>
<li title="foreach"><a href="funs.html#id62147">foreach</a></li>
<li title="Syntax of Funs"><a href="funs.html#id57445">Syntax of Funs</a></li>
<li title="Variable Bindings Within a Fun"><a href="funs.html#id62701">Variable Bindings Within a Fun</a></li>
<li title="Funs and Module Lists"><a href="funs.html#id59737">Funs and Module Lists</a></li>
<li title="Funs Returning Funs"><a href="funs.html#id62978">Funs Returning Funs</a></li>
</ul>
</li>
<li id="no" title="List Comprehensions" expanded="false">List Comprehensions<ul>
<li><a href="list_comprehensions.html">
              Top of chapter
            </a></li>
<li title="Simple Examples"><a href="list_comprehensions.html#id62573">Simple Examples</a></li>
<li title="Quick Sort"><a href="list_comprehensions.html#id62640">Quick Sort</a></li>
<li title="Permutations"><a href="list_comprehensions.html#id65643">Permutations</a></li>
<li title="Pythagorean Triplets"><a href="list_comprehensions.html#id65695">Pythagorean Triplets</a></li>
<li title="Simplifications With List Comprehensions"><a href="list_comprehensions.html#id65772">Simplifications With List Comprehensions</a></li>
<li title="Variable Bindings in List Comprehensions"><a href="list_comprehensions.html#id65795">Variable Bindings in List Comprehensions</a></li>
</ul>
</li>
<li id="no" title="Bit Syntax" expanded="false">Bit Syntax<ul>
<li><a href="bit_syntax.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="bit_syntax.html#id65995">Introduction</a></li>
<li title="Lexical Note"><a href="bit_syntax.html#id66313">Lexical Note</a></li>
<li title="Segments"><a href="bit_syntax.html#id66336">Segments</a></li>
<li title="Defaults"><a href="bit_syntax.html#id66542">Defaults</a></li>
<li title="Constructing Binaries and Bitstrings"><a href="bit_syntax.html#id66602">Constructing Binaries and Bitstrings</a></li>
<li title="Matching Binaries"><a href="bit_syntax.html#id66791">Matching Binaries</a></li>
<li title="Appending to a Binary"><a href="bit_syntax.html#id66918">Appending to a Binary</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>2 Funs</h1>
  

  <h3><a name="id57608">2.1 
        map</a></h3>
    
    <p>The following function, <span class="code">double</span>, doubles every element in a list:</p>
    <div class="example"><pre>
double([H|T]) -&gt; [2*H|double(T)];
double([])    -&gt; [].</pre></div>
    <p>Hence, the argument entered as input is doubled as follows:</p>
    <div class="example"><pre>
&gt; <span class="bold_code">double([1,2,3,4]).</span>
[2,4,6,8]</pre></div>
    <p>The following function, <span class="code">add_one</span>, adds one to every
      element in a list:</p>
    <div class="example"><pre>
add_one([H|T]) -&gt; [H+1|add_one(T)];
add_one([])    -&gt; [].</pre></div>
    <p>The functions <span class="code">double</span> and <span class="code">add_one</span> have a
      similar structure. This can be used by writing a function
      <span class="code">map</span> that expresses this similarity:</p>
<div class="example"><pre>

map(F, [H|T]) -&gt; [F(H)|map(F, T)];
map(F, [])    -&gt; [].</pre></div>    <p>The functions <span class="code">double</span> and <span class="code">add_one</span> can now be expressed
    in terms of <span class="code">map</span> as follows:</p>
    <div class="example"><pre>
double(L)  -&gt; map(fun(X) -&gt; 2*X end, L).
add_one(L) -&gt; map(fun(X) -&gt; 1 + X end, L).</pre></div>
    <p><span class="code">map(F, List)</span> is a function that takes a function
      <span class="code">F</span> and a list <span class="code">L</span> as arguments and returns a new
      list, obtained by applying <span class="code">F</span> to each of
      the elements in <span class="code">L</span>.</p>
    <p>The process of abstracting out the common features of a number
      of different programs is called <strong>procedural abstraction</strong>.
      Procedural abstraction can be used to write several
      different functions that have a similar structure, but differ
      in some minor detail. This is done as follows:</p>
    <ul>
      <li>
<strong>Step 1.</strong> Write one function that represents the common features of
       these functions.</li>
      <li>
<strong>Step 2.</strong> Parameterize the difference in terms of functions that
       are passed as arguments to the common function.</li>
    </ul>
  

  <h3><a name="id62147">2.2 
        foreach</a></h3>
    
    <p>This section illustrates procedural abstraction. Initially,
    the following two examples are written as conventional
      functions.</p>
      <p>This function prints all elements of a list onto a stream:</p>
    <div class="example"><pre>
print_list(Stream, [H|T]) -&gt;
    io:format(Stream, "~p~n", [H]),
    print_list(Stream, T);
print_list(Stream, []) -&gt;
    true.</pre></div>
     <p>This function broadcasts a message to a list of processes:</p>
    <div class="example"><pre>
broadcast(Msg, [Pid|Pids]) -&gt;
    Pid ! Msg,
    broadcast(Msg, Pids);
broadcast(_, []) -&gt;
    true.</pre></div>
    <p>These two functions have a similar structure. They both
      iterate over a list and do something to each element in the list.
      The "something" is passed on as an extra argument to
      the function that does this.</p>
    <p>The function <span class="code">foreach</span> expresses this similarity:</p>
<div class="example"><pre>

foreach(F, [H|T]) -&gt;
    F(H),
    foreach(F, T);
foreach(F, []) -&gt;
    ok.</pre></div>    <p>Using the function <span class="code">foreach</span>, the function <span class="code">print_list</span> becomes:</p>
    <div class="example"><pre>
foreach(fun(H) -&gt; io:format(S, "~p~n",[H]) end, L)</pre></div>
     <p>Using the function <span class="code">foreach</span>, the function <span class="code">broadcast</span> becomes:</p>
    <div class="example"><pre>
foreach(fun(Pid) -&gt; Pid ! M end, L)</pre></div>
    <p><span class="code">foreach</span> is evaluated for its side-effect and not its
      value. <span class="code">foreach(Fun ,L)</span> calls <span class="code">Fun(X)</span> for each
      element <span class="code">X</span> in <span class="code">L</span> and the processing occurs in
      the order that the elements were defined in <span class="code">L</span>.
      <span class="code">map</span> does not define the order in which its elements are
      processed.</p>
  

  <h3><a name="id57445">2.3 
        Syntax of Funs</a></h3>
    
    <p>Funs are written with the following syntax (see <span class="bold_code"><a href="../reference_manual/expressions.html#funs">Fun Expressions</a></span> for full description):</p>
    <div class="example"><pre>
F = fun (Arg1, Arg2, ... ArgN) -&gt;
        ...
    end</pre></div>
    <p>This creates an anonymous function of <span class="code">N</span> arguments and
      binds it to the variable <span class="code">F</span>.</p>
    <p>Another function, <span class="code">FunctionName</span>, written in the same module,
    can be passed as an argument, using the following syntax:</p>
    <div class="example"><pre>
F = fun FunctionName/Arity</pre></div>
    <p>With this form of function reference, the function that is
      referred to does not need to be exported from the module.</p>
    <p>It is also possible to refer to a function defined in a different module,
      with the following syntax:</p>
    <div class="example"><pre>
F = fun Module:FunctionName/Arity</pre></div>
    <p>In this case, the function must be exported from the module in
      question.</p>
    <p>The following program illustrates the different ways of creating
      funs:</p>
<div class="example"><pre>

-module(fun_test).
-export([t1/0, t2/0]).
-import(lists, [map/2]).

t1() -&gt; map(fun(X) -&gt; 2 * X end, [1,2,3,4,5]).

t2() -&gt; map(fun double/1, [1,2,3,4,5]).

double(X) -&gt; X * 2.</pre></div>    <p>The fun <span class="code">F</span> can be evaluated with the following syntax:</p>
    <div class="example"><pre>
F(Arg1, Arg2, ..., Argn)</pre></div>
    <p>To check whether a term is a fun, use the test
      <span class="code">is_function/1</span> in a guard.</p>
      <p><strong>Example:</strong></p>
    <div class="example"><pre>
f(F, Args) when is_function(F) -&gt;
   apply(F, Args);
f(N, _) when is_integer(N) -&gt;
   N.</pre></div>
    <p>Funs are a distinct type. The BIFs <span class="code">erlang:fun_info/1,2</span> can
      be used to retrieve information about a fun, and the BIF
      <span class="code">erlang:fun_to_list/1</span> returns a textual representation of a fun.
      The <span class="code">check_process_code/2</span> BIF returns <span class="code">true</span> if the process
      contains funs that depend on the old version of a module.</p>
  

  <h3><a name="id62701">2.4 
        Variable Bindings Within a Fun</a></h3>
    
    <p>The scope rules for variables that occur in funs are as
      follows:</p>
    <ul>
      <li>All variables that occur in the head of a fun are assumed
       to be "fresh" variables.</li>
      <li>Variables that are defined before the fun, and that
       occur in function calls or guard tests within the fun, have
       the values they had outside the fun.</li>
      <li>Variables cannot be exported from a fun.</li>
    </ul>
    <p>The following examples illustrate these rules:</p>
    <div class="example"><pre>
print_list(File, List) -&gt;
    {ok, Stream} = file:open(File, write),
    foreach(fun(X) -&gt; io:format(Stream,"~p~n",[X]) end, List),
    file:close(Stream).</pre></div>
    <p>Here, the variable <span class="code">X</span>, defined in
      the head of the fun, is a new variable. The variable
      <span class="code">Stream</span>, which is used within the fun, gets its value
      from the <span class="code">file:open</span> line.</p>
    <p>As any variable that occurs in the head of a fun is
      considered a new variable, it is equally valid to write
      as follows:</p>
    <div class="example"><pre>
print_list(File, List) -&gt;
    {ok, Stream} = file:open(File, write),
    foreach(fun(File) -&gt; 
                io:format(Stream,"~p~n",[File]) 
            end, List),
    file:close(Stream).</pre></div>
    <p>Here, <span class="code">File</span> is used as the new variable
      instead of <span class="code">X</span>. This is not so wise because code in the fun
      body cannot refer to the variable <span class="code">File</span>, which is
      defined outside of the fun. Compiling this example gives
      the following diagnostic:</p>
    <div class="example"><pre>
./FileName.erl:Line: Warning: variable 'File' 
      shadowed in 'fun'</pre></div>
    <p>This indicates that the variable <span class="code">File</span>, which is defined
      inside the fun, collides with the variable <span class="code">File</span>, which is
      defined outside the fun.</p>
    <p>The rules for importing variables into a fun has the consequence
      that certain pattern matching operations must be moved into
      guard expressions and cannot be written in the head of the fun.
      For example, you might write the following code if you intend
      the first clause of <span class="code">F</span> to be evaluated when the value of
      its argument is <span class="code">Y</span>:</p>
    <div class="example"><pre>
f(...) -&gt;
    Y = ...
    map(fun(X) when X == Y -&gt;
             ;
           (_) -&gt;
             ...
        end, ...)
    ...</pre></div>
    <p>instead of writing the following code:</p>
    <div class="example"><pre>
f(...) -&gt;
    Y = ...
    map(fun(Y) -&gt;
             ;
           (_) -&gt;
             ...
        end, ...)
    ...</pre></div>
  

  <h3><a name="id59737">2.5 
        Funs and Module Lists</a></h3>
    
    <p>The following examples show a dialogue with the Erlang shell.
      All the higher order functions discussed are exported from
      the module <span class="code">lists</span>.</p>

    <h4>map</h4>
      
      <p><span class="code">map</span> takes a function of one argument and a list of terms:</p>
<div class="example"><pre>

map(F, [H|T]) -&gt; [F(H)|map(F, T)];
map(F, [])    -&gt; [].</pre></div>      <p>It returns the list obtained by applying the function
        to every argument in the list.</p>
	<p>When a new fun is defined in the shell, the value of the fun
        is printed as <span class="code">Fun#&lt;erl_eval&gt;</span>:</p>
      <div class="example"><pre>
&gt; <span class="bold_code">Double = fun(X) -&gt; 2 * X end.</span>
#Fun&lt;erl_eval.6.72228031&gt;
&gt; <span class="bold_code">lists:map(Double, [1,2,3,4,5]).</span>
[2,4,6,8,10]</pre></div>

    

    <h4>any</h4>
      
      <p><span class="code">any</span> takes a predicate <span class="code">P</span> of one argument and a
        list of terms:</p>
<div class="example"><pre>

any(Pred, [H|T]) -&gt;
    case Pred(H) of
        true  -&gt;  true;
        false -&gt;  any(Pred, T)
    end;
any(Pred, []) -&gt;
    false.</pre></div>      <p>A predicate is a function that returns <span class="code">true</span> or <span class="code">false</span>.
      <span class="code">any</span> is <span class="code">true</span> if there is a term <span class="code">X</span> in the list such that
      <span class="code">P(X)</span> is <span class="code">true</span>.</p>
      <p>A predicate <span class="code">Big(X)</span> is defined, which is <span class="code">true</span> if
        its argument is greater that 10:</p>
      <div class="example"><pre>
&gt; <span class="bold_code">Big =  fun(X) -&gt; if X &gt; 10 -&gt; true; true -&gt; false end end.</span>
#Fun&lt;erl_eval.6.72228031&gt;
&gt; <span class="bold_code">lists:any(Big, [1,2,3,4]).</span>
false
&gt; <span class="bold_code">lists:any(Big, [1,2,3,12,5]).</span>
true</pre></div>
    

    <h4>all</h4>
      
      <p><span class="code">all</span> has the same arguments as <span class="code">any</span>:</p>
<div class="example"><pre>

all(Pred, [H|T]) -&gt;
    case Pred(H) of
        true  -&gt;  all(Pred, T);
        false -&gt;  false
    end;
all(Pred, []) -&gt;
    true.</pre></div>      <p>It is <span class="code">true</span>
        if the predicate applied to all elements in the list is <span class="code">true</span>.</p>
      <div class="example"><pre>
&gt; <span class="bold_code">lists:all(Big, [1,2,3,4,12,6]).</span>   
false
&gt; <span class="bold_code">lists:all(Big, [12,13,14,15]).</span>       
true</pre></div>
    

    <h4>foreach</h4>
      
      <p><span class="code">foreach</span> takes a function of one argument and a list of
        terms:</p>
<div class="example"><pre>

foreach(F, [H|T]) -&gt;
    F(H),
    foreach(F, T);
foreach(F, []) -&gt;
    ok.</pre></div>      <p>The function is applied to each argument in the list.
        <span class="code">foreach</span> returns <span class="code">ok</span>. It is only used for its
        side-effect:</p>
      <div class="example"><pre>
&gt; <span class="bold_code">lists:foreach(fun(X) -&gt; io:format("~w~n",[X]) end, [1,2,3,4]).</span> 
1
2
3
4
ok</pre></div>
    

    <h4>foldl</h4>
      
      <p><span class="code">foldl</span> takes a function of two arguments, an
        accumulator and a list:</p>
<div class="example"><pre>

foldl(F, Accu, [Hd|Tail]) -&gt;
    foldl(F, F(Hd, Accu), Tail);
foldl(F, Accu, []) -&gt; Accu.</pre></div>      <p>The function is called with two
        arguments. The first argument is the successive elements in
        the list. The second argument is the accumulator. The function
        must return a new accumulator, which is used the next time
        the function is called.</p>
      <p>If you have a list of lists <span class="code">L = ["I","like","Erlang"]</span>,
        then you can sum the lengths of all the strings in <span class="code">L</span> as
        follows:</p>
      <div class="example"><pre>
&gt; <span class="bold_code">L = ["I","like","Erlang"].</span>
["I","like","Erlang"]
10&gt; <span class="bold_code">lists:foldl(fun(X, Sum) -&gt; length(X) + Sum end, 0, L).</span>                    
11</pre></div>
      <p><span class="code">foldl</span> works like a <span class="code">while</span> loop in an imperative
        language:</p>
      <div class="example"><pre>
L =  ["I","like","Erlang"],
Sum = 0,
while( L != []){
    Sum += length(head(L)),
    L = tail(L)
end</pre></div>
    

    <h4>mapfoldl</h4>
      
      <p><span class="code">mapfoldl</span> simultaneously maps and folds over a list:</p>
<div class="example"><pre>

mapfoldl(F, Accu0, [Hd|Tail]) -&gt;
    {R,Accu1} = F(Hd, Accu0),
    {Rs,Accu2} = mapfoldl(F, Accu1, Tail),
    {[R|Rs], Accu2};
mapfoldl(F, Accu, []) -&gt; {[], Accu}.</pre></div>      <p>The following example shows how to change all letters in
        <span class="code">L</span> to upper case and then count them.</p>
      <p>First the change to upper case:</p>
      <div class="example"><pre>
&gt; <span class="bold_code">Upcase =  fun(X) when $a =&lt; X,  X =&lt; $z -&gt; X + $A - $a;</span>
<span class="bold_code">(X) -&gt; X</span> 
<span class="bold_code">end.</span>
#Fun&lt;erl_eval.6.72228031&gt;
&gt; <span class="bold_code">Upcase_word =</span> 
<span class="bold_code">fun(X) -&gt;</span> 
<span class="bold_code">lists:map(Upcase, X)</span> 
<span class="bold_code">end.</span>
#Fun&lt;erl_eval.6.72228031&gt;
&gt; <span class="bold_code">Upcase_word("Erlang").</span>
"ERLANG"
&gt; <span class="bold_code">lists:map(Upcase_word, L).</span>
["I","LIKE","ERLANG"]</pre></div>
      <p>Now, the fold and the map can be done at the same time:</p>
      <div class="example"><pre>
&gt; <span class="bold_code">lists:mapfoldl(fun(Word, Sum) -&gt;</span>
<span class="bold_code">{Upcase_word(Word), Sum + length(Word)}</span>
<span class="bold_code">end, 0, L).</span>
{["I","LIKE","ERLANG"],11}</pre></div>
    

    <h4>filter</h4>
      
      <p><span class="code">filter</span> takes a predicate of one argument and a list
        and returns all elements in the list that satisfy
        the predicate:</p>
<div class="example"><pre>

filter(F, [H|T]) -&gt;
    case F(H) of
        true  -&gt; [H|filter(F, T)];
        false -&gt; filter(F, T)
    end;
filter(F, []) -&gt; [].</pre></div>      <div class="example"><pre>
&gt; <span class="bold_code">lists:filter(Big, [500,12,2,45,6,7]).</span>
[500,12,45]</pre></div>
      <p>Combining maps and filters enables writing of very succinct
        code. For example, to define a set difference
        function <span class="code">diff(L1, L2)</span> to be
        the difference between the lists <span class="code">L1</span> and <span class="code">L2</span>,
        the code can be written as follows:</p>
      <div class="example"><pre>
diff(L1, L2) -&gt; 
    filter(fun(X) -&gt; not member(X, L2) end, L1).</pre></div>
      <p>This gives the list of all elements in L1 that are not contained
        in L2.</p>
	<p> The AND intersection of the list <span class="code">L1</span> and <span class="code">L2</span> is
        also easily defined:</p>
      <div class="example"><pre>
intersection(L1,L2) -&gt; filter(fun(X) -&gt; member(X,L1) end, L2).</pre></div>
    

    <h4>takewhile</h4>
      
      <p><span class="code">takewhile(P, L)</span> takes elements <span class="code">X</span> from a list
        <span class="code">L</span> as long as the predicate <span class="code">P(X)</span> is true:</p>
<div class="example"><pre>

takewhile(Pred, [H|T]) -&gt;
    case Pred(H) of
        true  -&gt; [H|takewhile(Pred, T)];
        false -&gt; []
    end;
takewhile(Pred, []) -&gt;
    [].</pre></div>      <div class="example"><pre>
&gt; <span class="bold_code">lists:takewhile(Big, [200,500,45,5,3,45,6]).</span>  
[200,500,45]</pre></div>
    

    <h4>dropwhile</h4>
      
      <p><span class="code">dropwhile</span> is the complement of <span class="code">takewhile</span>:</p>
<div class="example"><pre>

dropwhile(Pred, [H|T]) -&gt;
    case Pred(H) of
        true  -&gt; dropwhile(Pred, T);
        false -&gt; [H|T]
    end;
dropwhile(Pred, []) -&gt;
    [].</pre></div>      <div class="example"><pre>
&gt; <span class="bold_code">lists:dropwhile(Big, [200,500,45,5,3,45,6]).</span>
[5,3,45,6]</pre></div>
    

    <h4>splitwith</h4>
      
      <p><span class="code">splitwith(P, L)</span> splits the list <span class="code">L</span> into the two
        sublists <span class="code">{L1, L2}</span>, where <span class="code">L = takewhile(P, L)</span>
        and <span class="code">L2 = dropwhile(P, L)</span>:</p>
<div class="example"><pre>

splitwith(Pred, L) -&gt;
    splitwith(Pred, L, []).

splitwith(Pred, [H|T], L) -&gt;
    case Pred(H) of 
        true  -&gt; splitwith(Pred, T, [H|L]);
        false -&gt; {reverse(L), [H|T]}
    end;
splitwith(Pred, [], L) -&gt;
    {reverse(L), []}.</pre></div>      <div class="example"><pre>
&gt; <span class="bold_code">lists:splitwith(Big, [200,500,45,5,3,45,6]).</span>
{[200,500,45],[5,3,45,6]}</pre></div>
    
  

  <h3><a name="id62978">2.6 
        Funs Returning Funs</a></h3>
    
    <p>So far, only functions that take
      funs as arguments have been described. More powerful
      functions, that themselves return funs, can also be written. The following
      examples illustrate these type of functions.</p>

    <h4>Simple Higher Order Functions</h4>
      
      <p><span class="code">Adder(X)</span> is a function that given <span class="code">X</span>, returns
        a new function <span class="code">G</span> such that <span class="code">G(K)</span> returns
        <span class="code">K + X</span>:</p>
      <div class="example"><pre>
&gt; <span class="bold_code">Adder = fun(X) -&gt; fun(Y) -&gt; X + Y end end.</span>
#Fun&lt;erl_eval.6.72228031&gt;
&gt; <span class="bold_code">Add6 = Adder(6).</span>
#Fun&lt;erl_eval.6.72228031&gt;
&gt; <span class="bold_code">Add6(10).</span>
16</pre></div>
    

    <h4>Infinite Lists</h4>
      
      <p>The idea is to write something like:</p>
      <div class="example"><pre>
-module(lazy).
-export([ints_from/1]).
ints_from(N) -&gt;
    fun() -&gt;
            [N|ints_from(N+1)]
    end.</pre></div>
      <p>Then proceed as follows:</p>
      <div class="example"><pre>
&gt; <span class="bold_code">XX = lazy:ints_from(1).</span>
#Fun&lt;lazy.0.29874839&gt;
&gt; <span class="bold_code">XX().</span>
[1|#Fun&lt;lazy.0.29874839&gt;]
&gt; <span class="bold_code">hd(XX()).</span>
1
&gt; <span class="bold_code">Y = tl(XX()).</span>
#Fun&lt;lazy.0.29874839&gt;
&gt; <span class="bold_code">hd(Y()).</span>
2</pre></div>
      <p>And so on. This is an example of "lazy embedding".</p>
    

    <h4>Parsing</h4>
      
      <p>The following examples show parsers of the following type:</p>
      <div class="example"><pre>
Parser(Toks) -&gt; {ok, Tree, Toks1} | fail</pre></div>
      <p><span class="code">Toks</span> is the list of tokens to be parsed. A successful
        parse returns <span class="code">{ok, Tree, Toks1}</span>.</p>
	<ul>
       <li>
<span class="code">Tree</span> is a parse tree.</li>
       <li>
<span class="code">Toks1</span> is a tail of <span class="code">Tree</span> that
        contains symbols encountered after the structure that was
        correctly parsed.</li>
     </ul>
      <p>An unsuccessful parse returns <span class="code">fail</span>.</p>
      <p>The following example illustrates a simple, functional
        parser that parses the grammar:</p>
      <div class="example"><pre>
(a | b) &amp; (c | d)</pre></div>
      <p>The following code defines a function <span class="code">pconst(X)</span> in
        the module <span class="code">funparse</span>, which returns a fun that parses a
        list of tokens:</p>
<div class="example"><pre>

pconst(X) -&gt;
    fun (T) -&gt;
       case T of
           [X|T1] -&gt; {ok, {const, X}, T1};
           _      -&gt; fail
       end
    end.</pre></div>      <p>This function can be used as follows:</p>
      <div class="example"><pre>
&gt; <span class="bold_code">P1 = funparse:pconst(a).</span>
#Fun&lt;funparse.0.22674075&gt;
&gt; <span class="bold_code">P1([a,b,c]).</span>
{ok,{const,a},[b,c]}
&gt; <span class="bold_code">P1([x,y,z]).</span>     
fail</pre></div>
      <p>Next, the two higher order functions <span class="code">pand</span>
        and <span class="code">por</span> are defined. They combine primitive parsers to produce more
        complex parsers.</p>
	<p>First <span class="code">pand</span>:</p>
<div class="example"><pre>

pand(P1, P2) -&gt;
    fun (T) -&gt;
        case P1(T) of
            {ok, R1, T1} -&gt;
                case P2(T1) of
                    {ok, R2, T2} -&gt;
                        {ok, {'and', R1, R2}};
                    fail -&gt;
                        fail
                end;
            fail -&gt;
                fail
        end
    end.</pre></div>      <p>Given a parser <span class="code">P1</span> for grammar <span class="code">G1</span>, and a parser
        <span class="code">P2</span> for grammar <span class="code">G2</span>, <span class="code">pand(P1, P2)</span> returns a
        parser for the grammar, which consists of sequences of tokens
        that satisfy <span class="code">G1</span>, followed by sequences of tokens that
        satisfy <span class="code">G2</span>.</p>
      <p><span class="code">por(P1, P2)</span> returns a parser for the language
        described by the grammar <span class="code">G1</span> or <span class="code">G2</span>:</p>
<div class="example"><pre>

por(P1, P2) -&gt;
    fun (T) -&gt;
        case P1(T) of
            {ok, R, T1} -&gt; 
                {ok, {'or',1,R}, T1};
            fail -&gt; 
                case P2(T) of
                    {ok, R1, T1} -&gt;
                        {ok, {'or',2,R1}, T1};
                    fail -&gt;
                        fail
                end
        end
    end.</pre></div>      <p>The original problem was to parse the grammar
        <span class="code">(a | b) &amp; (c | d)</span>. The following code addresses this
        problem:</p>
<div class="example"><pre>

grammar() -&gt;
    pand(
         por(pconst(a), pconst(b)),
         por(pconst(c), pconst(d))).</pre></div>      <p>The following code adds a parser interface to the grammar:</p>
<div class="example"><pre>

parse(List) -&gt;
    (grammar())(List).</pre></div>      <p>The parser can be tested as follows:</p>
      <div class="example"><pre>
&gt; <span class="bold_code">funparse:parse([a,c]).</span>
{ok,{'and',{'or',1,{const,a}},{'or',1,{const,c}}}}
&gt; <span class="bold_code">funparse:parse([a,d]).</span> 
{ok,{'and',{'or',1,{const,a}},{'or',2,{const,d}}}}
&gt; <span class="bold_code">funparse:parse([b,c]).</span>   
{ok,{'and',{'or',2,{const,b}},{'or',1,{const,c}}}}
&gt; <span class="bold_code">funparse:parse([b,d]).</span> 
{ok,{'and',{'or',2,{const,b}},{'or',2,{const,d}}}}
&gt; <span class="bold_code">funparse:parse([a,b]).</span>   
fail</pre></div>
    
  
</div>
<div class="footer">
<hr>
<p>Copyright © 2003-2017 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
