<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- The beam_makeops script</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="leftnav-tube">
<div class="erlang-logo-wrapper"><a href="../../index.html"><img alt="Erlang Logo" src="../../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Erlang Run-Time System Application (ERTS)</p>
<p class="section-subtitle">Internal Documentation</p>
<p class="section-version">Version 11.2.2.7</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="index.html">Reference Manual</a></li>
<li><a href="internal_docs.html">Internal Documentation</a></li>
<li><a href="release_notes.html">Release Notes</a></li>
<li><a href="erts.pdf">PDF</a></li>
<li><a href="../../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Carrier Migration" expanded="false">Carrier Migration<ul>
<li><a href="CarrierMigration.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="CarrierMigration.html#introduction">Introduction</a></li>
<li title="Problem"><a href="CarrierMigration.html#problem">Problem</a></li>
<li title="Solution"><a href="CarrierMigration.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Thread Progress" expanded="false">Thread Progress<ul>
<li><a href="ThreadProgress.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="ThreadProgress.html#problems">Problems</a></li>
<li title="Functionality Used to Address These Problems"><a href="ThreadProgress.html#functionality-used-to-address-these-problems">Functionality Used to Address These Problems</a></li>
<li title="Implementation of the Thread Progress Functionality"><a href="ThreadProgress.html#implementation-of-the-thread-progress-functionality">Implementation of the Thread Progress Functionality</a></li>
</ul>
</li>
<li id="no" title="Non-Blocking Code Loading" expanded="false">Non-Blocking Code Loading<ul>
<li><a href="CodeLoading.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="CodeLoading.html#introduction">Introduction</a></li>
<li title="The Load Phases"><a href="CodeLoading.html#the-load-phases">The Load Phases</a></li>
<li title="The Finishing Sequence"><a href="CodeLoading.html#the-finishing-sequence">The Finishing Sequence</a></li>
</ul>
</li>
<li id="no" title="Non-blocking trace setting" expanded="false">Non-blocking trace setting<ul>
<li><a href="Tracing.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="Tracing.html#introduction">Introduction</a></li>
<li title="Redesign of Breakpoint Wheel"><a href="Tracing.html#redesign-of-breakpoint-wheel">Redesign of Breakpoint Wheel</a></li>
<li title="Same Same but Different"><a href="Tracing.html#same-same-but-different">Same Same but Different</a></li>
<li title="Adding a new Breakpoint"><a href="Tracing.html#adding-a-new-breakpoint">Adding a new Breakpoint</a></li>
<li title="To Updating and Remove Breakpoints"><a href="Tracing.html#to-updating-and-remove-breakpoints">To Updating and Remove Breakpoints</a></li>
<li title="Global Tracing"><a href="Tracing.html#global-tracing">Global Tracing</a></li>
<li title="Future work"><a href="Tracing.html#future-work">Future work</a></li>
</ul>
</li>
<li id="no" title="Delayed Dealloc" expanded="false">Delayed Dealloc<ul>
<li><a href="DelayedDealloc.html">
              Top of chapter
            </a></li>
<li title="Problem"><a href="DelayedDealloc.html#problem">Problem</a></li>
<li title="Functionality Used to Address This problem"><a href="DelayedDealloc.html#functionality-used-to-address-this-problem">Functionality Used to Address This problem</a></li>
</ul>
</li>
<li id="loadscrollpos" title="The beam_makeops script" expanded="true">The beam_makeops script<ul>
<li><a href="beam_makeops.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="beam_makeops.html#introduction">Introduction</a></li>
<li title="An example: the move instruction"><a href="beam_makeops.html#an-example--the-move-instruction">An example: the move instruction</a></li>
<li title="Short overview of instruction loading"><a href="beam_makeops.html#short-overview-of-instruction-loading">Short overview of instruction loading</a></li>
<li title="Running beam_makeops"><a href="beam_makeops.html#running-beam_makeops">Running beam_makeops</a></li>
<li title="Syntax of .tab files"><a href="beam_makeops.html#syntax-of-.tab-files">Syntax of .tab files</a></li>
</ul>
</li>
<li id="no" title="Counting Instructions" expanded="false">Counting Instructions<ul><li><a href="CountingInstructions.html">
              Top of chapter
            </a></li></ul>
</li>
<li id="no" title="Erlang Garbage Collector" expanded="false">Erlang Garbage Collector<ul>
<li><a href="GarbageCollection.html">
              Top of chapter
            </a></li>
<li title="Overview"><a href="GarbageCollection.html#overview">Overview</a></li>
<li title="Generational Garbage Collection"><a href="GarbageCollection.html#generational-garbage-collection">Generational Garbage Collection</a></li>
<li title="The young heap"><a href="GarbageCollection.html#the-young-heap">The young heap</a></li>
<li title="Sizing the heap"><a href="GarbageCollection.html#sizing-the-heap">Sizing the heap</a></li>
<li title="Literals"><a href="GarbageCollection.html#literals">Literals</a></li>
<li title="Binary heap"><a href="GarbageCollection.html#binary-heap">Binary heap</a></li>
<li title="Messages"><a href="GarbageCollection.html#messages">Messages</a></li>
<li title="References"><a href="GarbageCollection.html#references">References</a></li>
</ul>
</li>
<li id="no" title="Process and Port Tables" expanded="false">Process and Port Tables<ul>
<li><a href="PTables.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="PTables.html#problems">Problems</a></li>
<li title="Solution"><a href="PTables.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Port Signals" expanded="false">Port Signals<ul>
<li><a href="PortSignals.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="PortSignals.html#problems">Problems</a></li>
<li title="Solution"><a href="PortSignals.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Process Management Optimizations" expanded="false">Process Management Optimizations<ul>
<li><a href="ProcessManagementOptimizations.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="ProcessManagementOptimizations.html#problems">Problems</a></li>
<li title="Solution"><a href="ProcessManagementOptimizations.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Super Carrier" expanded="false">Super Carrier<ul>
<li><a href="SuperCarrier.html">
              Top of chapter
            </a></li>
<li title="Problem"><a href="SuperCarrier.html#problem">Problem</a></li>
<li title="Solution"><a href="SuperCarrier.html#solution">Solution</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>6 The beam_makeops script</h1>


<p>
This document describes the <strong>beam_makeops</strong> script.
</p>

<h3>
<a name="Introduction"></a><span onMouseOver="document.getElementById('ghlink-introduction-idm30129').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-introduction-idm30129').style.visibility = 'hidden';"><a class="title_link" name="introduction">6.1 
          Introduction</a><span id="ghlink-introduction-idm30129" class="ghlink-after"><a href="#introduction" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
The <strong>beam_makeops</strong> Perl script is used at build-time by both the
compiler and runtime system.  Given a number of input files (all with
the extension <span class="code">.tab</span>), it will generate source files used by the
Erlang compiler and by the runtime system to load and execute BEAM
instructions.
</p>

<p>
Essentially those <span class="code">.tab</span> files define:
</p>

<ul>
<li>
<p>External generic BEAM instructions.  They are the instructions that
are known to both the compiler and the runtime system.  Generic
instructions are stable between releases.  New generic instructions
with high numbers than previous instructions can be added in major
releases.  The OTP 20 release has 159 external generic instructions.
</p>

</li>
<li>
<p>Internal generic instructions.  They are known only to the runtime
system and can be changed at any time without compatibility issues.
They are created by transformation rules (described next).
</p>

</li>
<li>
<p>Rules for transforming one or more generic instructions to other
generic instructions.  The transformation rules allow combining,
splitting, and removal of instructions, as well as shuffling operands.
Because of the transformation rules, the runtime can have many
internal generic instructions that are only known to runtime system.
</p>

</li>
<li>
<p>Specific BEAM instructions.  The specific instructions are the
instructions that are actually executed by the runtime system.  They
can be changed at any time without causing compatibility issues.
The loader translates generic instructions to specific instructions.
In general, for each generic instruction, there exists a family of
specific instructions.  The OTP 20 release has 389 specific
instructions.
</p>

</li>
<li>
<p>The implementation of specific instructions.
</p>
</li>
</ul>
<p>
Generic instructions have typed operands. Here are a few examples of
operands for <span class="code">move/2</span>:
</p>

<div class="example example-none"><pre>{move,{atom,id},{x,5}}.
{move,{x,3},{x,0}}.
{move,{x,2},{y,1}}.</pre></div>
<p>
When those instructions are loaded, the loader rewrites them
to specific instructions:
</p>

<div class="example example-none"><pre>move_cx id 5
move_xx 3 0
move_xy 2 1</pre></div>
<p>
Corresponding to each generic instruction, there is a family of
specific instructions.  The types that an instance of a specific
instruction can handle are encoded in the instruction names.  For
example, <span class="code">move_xy</span> takes an X register number as the first operand and
a Y register number as the second operand.  <span class="code">move_cx</span> takes a tagged
Erlang term as the first operand and an X register number as the
second operand.
</p>



<h3>
<a name="An-example-the-move-instruction"></a><span onMouseOver="document.getElementById('ghlink-an-example--the-move-instruction-idm30156').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-an-example--the-move-instruction-idm30156').style.visibility = 'hidden';"><a class="title_link" name="an-example--the-move-instruction">6.2 
          An example: the move instruction</a><span id="ghlink-an-example--the-move-instruction-idm30156" class="ghlink-after"><a href="#an-example--the-move-instruction" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
Using the <span class="code">move</span> instruction as an example, we will give a quick
tour to show the main features of <strong>beam_makeops</strong>.
</p>

<p>
In the <span class="code">compiler</span> application, in the file <span class="code">genop.tab</span>, there is the
following line:
</p>

<div class="example example-none"><pre>64: move/2</pre></div>
<p>
This is a definition of an external generic BEAM instruction. Most
importantly it specifices that the opcode is 64.  It also defines that
it has two operands.  The BEAM assembler will use the opcode when
creating <span class="code">.beam</span> files.  The compiler does not really need the arity,
but it will use it as an internal sanity check when assembling the
BEAM code.
</p>

<p>
Let's have a look at <span class="code">ops.tab</span> in <span class="code">erts/emulator/beam</span>, where the
specific <span class="code">move</span> instructions are defined.  Here are a few of them:
</p>

<div class="example example-none"><pre>move x x
move x y
move c x</pre></div>
<p>
Each specific instructions is defined by following the name of the
instruction with the types for each operand.  An operand type is a
single letter.  For example, <span class="code">x</span> means an X register, <span class="code">y</span>
means a Y register, and <span class="code">c</span> is a "constant" (a tagged term such as
an integer, an atom, or a literal).
</p>

<p>
Now let's look at the implementation of the <span class="code">move</span> instruction.  There
are multiple files containing implementations of instructions in the
<span class="code">erts/emulator/beam</span> directory.  The <span class="code">move</span> instruction is defined in
<span class="code">instrs.tab</span>.  It looks like this:
</p>

<div class="example example-none"><pre>move(Src, Dst) {
    $Dst = $Src;
}</pre></div>
<p>
The implementation for an instruction largely follows the C syntax,
except that the variables in the function head don't have any types.
The <span class="code">$</span> before an identifier denotes a macro expansion.  Thus,
<span class="code">$Src</span> will expand to the code to pick up the source operand for
the instruction and <span class="code">$Dst</span> to the code for the destination register.
</p>

<p>
We will look at the code for each specific instruction in turn.  To
make the code easier to understand, let's first look at the memory
layout for the instruction <span class="code">{move,{atom,id},{x,5}}</span>:
</p>

<div class="example example-none"><pre>     +--------------------+--------------------+
I -&gt; |                 40 |       &amp;&amp;lb_move_cx |
     +--------------------+--------------------+
     |                        Tagged atom 'id' |
     +--------------------+--------------------+</pre></div>
<p>
This example and all other examples in the document assumes a 64-bit
archictecture, and furthermore that pointers to C code fit in 32 bits.
</p>

<p>
<span class="code">I</span> in the BEAM virtual machine is the instruction pointer.  When BEAM
executes an instruction, <span class="code">I</span> points to the first word of the
instruction.
</p>

<p>
<span class="code">&amp;&amp;lb_move_cx</span> is the address to C code that implements <span class="code">move_cx</span>.  It
is stored in the lower 32 bits of the word.  In the upper 32 bits is
the byte offset to the X register; the register number 5 has been
multiplied by the word size size 8.
</p>

<p>
In the next word the tagged atom <span class="code">id</span> is stored.
</p>

<p>
With that background, we can look at the generated code for <span class="code">move_cx</span>
in <span class="code">beam_hot.h</span>:
</p>

<div class="example example-none"><pre>OpCase(move_cx):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  xb(BeamExtraData(I[0])) = I[1];
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}</pre></div>
<p>
We will go through each line in turn.
</p>

<ul>
<li>
<p><span class="code">OpCase(move_cx):</span> defines a label for the instruction.  The
<span class="code">OpCase()</span> macro is defined in <span class="code">beam_emu.c</span>.  It will expand this line
to <span class="code">lb_move_cx:</span>.
</p>

</li>
<li>
<p><span class="code">BeamInstr next_pf = BeamCodeAddr(I[2]);</span> fetches the pointer to
code for the next instruction to be executed.  The <span class="code">BeamCodeAddr()</span>
macro extracts the pointer from the lower 32 bits of the instruction
word.
</p>

</li>
<li>
<p><span class="code">xb(BeamExtraData(I[0])) = I[1];</span> is the expansion of <span class="code">$Dst = $Src</span>.
<span class="code">BeamExtraData()</span> is a macro that will extract the upper 32 bits from
the instruction word.  In this example, it will return 40 which is the
byte offset for X register 5.  The <span class="code">xb()</span> macro will cast a byte
pointer to an <span class="code">Eterm</span> pointer and dereference it.  The <span class="code">I[1]</span> on
the right side of the <span class="code">=</span> fetches an Erlang term (the atom <span class="code">id</span> in
this case).
</p>

</li>
<li>
<p><span class="code">I += 2</span> advances the instruction pointer to the next
instruction.
</p>

</li>
<li>
<p>In a debug-compiled emulator, <span class="code">ASSERT(VALID_INSTR(next_pf));</span> makes
sure that <span class="code">next_pf</span> is a valid instruction (that is, that it points
within the <span class="code">process_main()</span> function in <span class="code">beam_emu.c</span>).
</p>

</li>
<li>
<p><span class="code">GotoPF(next_pf);</span> transfers control to the next instruction.
</p>
</li>
</ul>
<p>
Now let's look at the implementation of <span class="code">move_xx</span>:
</p>

<div class="example example-none"><pre>OpCase(move_xx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  xb((tmp_packed1&gt;&gt;BEAM_TIGHT_SHIFT)) = xb(tmp_packed1&amp;BEAM_TIGHT_MASK);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}</pre></div>
<p>
We will go through the lines that are new or have changed compared to
<span class="code">move_cx</span>.
</p>

<ul>
<li>
<p><span class="code">Eterm tmp_packed1 = BeamExtraData(I[0]);</span> picks up both X register
numbers packed into the upper 32 bits of the instruction word.
</p>

</li>
<li>
<p><span class="code">BeamInstr next_pf = BeamCodeAddr(I[1]);</span> pre-fetches the address of
the next instruction. Note that because both X registers operands fits
into the instruction word, the next instruction is in the very next
word.
</p>

</li>
<li>
<p><span class="code">xb((tmp_packed1&gt;&gt;BEAM_TIGHT_SHIFT)) = xb(tmp_packed1&amp;BEAM_TIGHT_MASK);</span>
copies the source to the destination.  (For a 64-bit architecture,
<span class="code">BEAM_TIGHT_SHIFT</span> is 16 and <span class="code">BEAM_TIGHT_MASK</span> is <span class="code">0xFFFF</span>.)
</p>

</li>
<li>
<p><span class="code">I += 1;</span> advances the instruction pointer to the next instruction.
</p>
</li>
</ul>
<p>
<span class="code">move_xy</span> is almost identical to <span class="code">move_xx</span>.  The only difference is
the use of the <span class="code">yb()</span> macro instead of <span class="code">xb()</span> to reference the
destination register:
</p>

<div class="example example-none"><pre>OpCase(move_xy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  yb((tmp_packed1&gt;&gt;BEAM_TIGHT_SHIFT)) = xb(tmp_packed1&amp;BEAM_TIGHT_MASK);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}</pre></div>
<h4>
<a name="An-example-the-move-instruction_Transformation-rules"></a><span onMouseOver="document.getElementById('ghlink-transformation-rules-idm30264').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-transformation-rules-idm30264').style.visibility = 'hidden';"><a class="title_link" name="transformation-rules">Transformation rules</a><span id="ghlink-transformation-rules-idm30264" class="ghlink-after"><a href="#transformation-rules" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
Next let's look at how we can do some optimizations using transformation
rules.  For simple instructions such as <span class="code">move/2</span>, the instruction dispatch
overhead can be substantial.  A simple optimization is to combine common
instructions sequences to a single instruction.  One such common sequence
is multiple <span class="code">move</span> instructions moving X registers to Y registers.
</p>

<p>
Using the following rule we can combine two <span class="code">move</span> instructions
to a <span class="code">move2</span> instruction:
</p>

<div class="example example-none"><pre>move X1=x Y1=y | move X2=x Y2=y =&gt; move2 X1 Y1 X2 Y2</pre></div>
<p>
The left side of the arrow (<span class="code">=&gt;</span>) is a pattern.  If the pattern
matches, the matching instructions will be replaced by the
instructions on the right side.  Variables in a pattern must start
with an uppercase letter just as in Erlang.  A pattern variable may be
followed <span class="code">=</span> and one or more type letters to constrain the match to
one of those types.  The variables that are bound on the left side can
be used on the right side.
</p>

<p>
We will also need to define a specific instruction and an implementation:
</p>

<div class="example example-none"><pre># In ops.tab
move2 x y x y

// In instrs.tab
move2(S1, D1, S2, D2) {
    Eterm V1, V2;
    V1 = $S1;
    V2 = $S2;
    $D1 = V1;
    $D2 = V2;
}</pre></div>
<p>
When the loader has found a match and replaced the matched instructions,
it will match the new instructions against the transformation rules.
Because of that, we can define the rule for a <span class="code">move3/6</span> instruction
as follows:
</p>

<div class="example example-none"><pre>move2 X1=x Y1=y X2=x Y2=y | move X3=x Y3=y =&gt; \
      move3 X1 Y1 X2 Y2 X3 Y3</pre></div>
<p>
(A <span class="code">\</span> before a newline can be used to break a long line for readability.)
</p>

<p>
It would also be possible to define it like this:
</p>

<div class="example example-none"><pre>move X1=x Y1=y | move X2=x Y2=y | move X3=x Y3=y =&gt; \
     move3 X1 Y1 X2 Y2 X3 Y3</pre></div>
<p>
but in that case it must be defined before the rule for <span class="code">move2/4</span>
because the first matching rule will be applied.
</p>

<p>
One must be careful not to create infinite loops.  For example, if we
for some reason would want to reverse the operand order for the <span class="code">move</span>
instruction, we must not do like this:
</p>

<div class="example example-none"><pre>move Src Dst =&gt; move Dst Src</pre></div>
<p>
The loader would swap the operands forever.  To avoid the loop, we must
rename the instruction.  For example:
</p>

<div class="example example-none"><pre>move Src Dst =&gt; assign Dst Src</pre></div>
<p>
This concludes the quick tour of the features of <strong>beam_makeops</strong>.
</p>





<h3>
<a name="Short-overview-of-instruction-loading"></a><span onMouseOver="document.getElementById('ghlink-short-overview-of-instruction-loading-idm30295').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-short-overview-of-instruction-loading-idm30295').style.visibility = 'hidden';"><a class="title_link" name="short-overview-of-instruction-loading">6.3 
          Short overview of instruction loading</a><span id="ghlink-short-overview-of-instruction-loading-idm30295" class="ghlink-after"><a href="#short-overview-of-instruction-loading" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
To give some background to the rest of this document, here follows a
quick overview of how instructions are loaded.
</p>

<ul>
<li>
<p>The loader reads and decodes one instruction at a time from the BEAM
code and creates a generic instruction.  Many transformation rules
must look at multiple instructions, so the loader will
keep multiple generic instructions in a linked list.
</p>

</li>
<li>
<p>The loader tries to apply transformation rules against the
generic instructions in the linked list.  If a rule matches, the
matched instructions will be removed and replaced with new
generic instructions constructed from the right side of the
transformation.
</p>

</li>
<li>
<p>If a transformation rule matched, the loader applies the
transformation rules again.
</p>

</li>
<li>
<p>If no transformation rule match, the loader will begin rewriting
the first of generic instructions to a specific instruction.
</p>

</li>
<li>
<p>First the loader will search for a specific operation where the
types for all operands match the type for the generic instruction.
The first matching instruction will be selected.  <strong>beam_makeops</strong>
has ordered the specific instructions so that instructions with more
specific operands comes before instructions with less specific
operands.  For example, <span class="code">move_nx</span> is more specific than <span class="code">move_cx</span>.  If
the first operand is <span class="code">[]</span> (NIL), <span class="code">move_nx</span> will be selected.
</p>

</li>
<li>
<p>Given the opcode for the selected specific instruction, the loader
looks up the pointer to the C code for the instruction and stores
in the code area for the module being loaded.
</p>

</li>
<li>
<p>The loader translates each operand to a machine word and stores it
in the code area.  The operand type for the selected specific
instruction guides the translation.  For example, if the type is <span class="code">e</span>,
the value of the operand is an index into an arry of external
functions and will be translated to a pointer to the export entry for
the function to call.  If the type is <span class="code">x</span>, the number of the X
register will be multiplied by the word size to produce a byte offset.
</p>

</li>
<li>
<p>The loader runs the packing engine to pack multiple operands into a
single word.  The packing engine is controlled by a small program,
which is a string where each character is an instruction.  For
example, the code to pack the operands for <span class="code">move_xy</span> is <span class="code">"22#"</span> (on a
64-bit machine).  That program will pack the byte offsets for both
registers into the same word as the pointer to C code.
</p>
</li>
</ul>


<h3>
<a name="Running-beammakeops"></a><span onMouseOver="document.getElementById('ghlink-running-beam_makeops-idm30325').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-running-beam_makeops-idm30325').style.visibility = 'hidden';"><a class="title_link" name="running-beam_makeops">6.4 
          Running beam_makeops</a><span id="ghlink-running-beam_makeops-idm30325" class="ghlink-after"><a href="#running-beam_makeops" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
<strong>beam_makeops</strong> is found in <span class="code">$ERL_TOP/erts/emulator/utils</span>.  Options
start with a hyphen (<span class="code">-</span>).  The options are followed by the name of
the input files.  By convention, all input files have the extension
<span class="code">.tab</span>, but is not enforced by <strong>beam_makeops</strong>.
</p>

<h4>
<a name="Running-beammakeops_The-outdir-option"></a><span onMouseOver="document.getElementById('ghlink-the--outdir-option-idm30334').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-the--outdir-option-idm30334').style.visibility = 'hidden';"><a class="title_link" name="the--outdir-option">The -outdir option</a><span id="ghlink-the--outdir-option-idm30334" class="ghlink-after"><a href="#the--outdir-option" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
The option <span class="code">-outdir Directory</span> specifies the output directory for
the generated files.  Default is the current working directory.
</p>



<h4>
<a name="Running-beammakeops_Running-beammakeops-for-the-compiler"></a><span onMouseOver="document.getElementById('ghlink-running-beam_makeops-for-the-compiler-idm30339').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-running-beam_makeops-for-the-compiler-idm30339').style.visibility = 'hidden';"><a class="title_link" name="running-beam_makeops-for-the-compiler">Running beam_makeops for the compiler</a><span id="ghlink-running-beam_makeops-for-the-compiler-idm30339" class="ghlink-after"><a href="#running-beam_makeops-for-the-compiler" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
Give the option <span class="code">-compiler</span> to produce output files for the compiler.
The following files will be written to the output directory:
</p>

<ul>
<li>
<p><span class="code">beam_opcodes.erl</span> - Used primarily by <span class="code">beam_asm</span> and <span class="code">beam_diasm</span>.
</p>

</li>
<li>
<p><span class="code">beam_opcode.hrl</span> - Used by <span class="code">beam_asm</span>.  It contains tag definitions
used for encoding instruction operands.
</p>
</li>
</ul>
<p>
The input file should only contain the definition of BEAM<strong>FORMAT</strong>NUMBER
and external generic instructions.  (Everything else would be ignored.)
</p>



<h4>
<a name="Running-beammakeops_Running-beammakeops-for-the-emulator"></a><span onMouseOver="document.getElementById('ghlink-running-beam_makeops-for-the-emulator-idm30356').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-running-beam_makeops-for-the-emulator-idm30356').style.visibility = 'hidden';"><a class="title_link" name="running-beam_makeops-for-the-emulator">Running beam_makeops for the emulator</a><span id="ghlink-running-beam_makeops-for-the-emulator-idm30356" class="ghlink-after"><a href="#running-beam_makeops-for-the-emulator" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
Give the option <span class="code">-emulator</span> to produce output files for the emulator.
The following output files will be generated in the output directory.
</p>

<ul>
<li>
<p><span class="code">beam_hot.h</span>, <span class="code">beam_warm.h</span>, <span class="code">beam_cold.</span>h - Implementation of
instructions.  Included inside the <span class="code">process_main()</span> function in
<span class="code">beam_emu.c</span>.
</p>

</li>
<li>
<p><span class="code">beam_opcodes.c</span> - Defines static data used by the loader
(<span class="code">beam_load.c</span>).  Data about generic instructions, specific
instructions (including how to pack their operands), and
transformation rules are all part of this file.
</p>

</li>
<li>
<p><span class="code">beam_opcodes.h</span> - Miscellanous preprocessor definitions, mainly
used by <span class="code">beam_load.c</span> but also by <span class="code">beam_{hot,warm,cold}.h</span>.
</p>

</li>
<li>
<p><span class="code">beam_pred_funcs.h</span> - Included by <span class="code">beam_load.c</span>.  Contains defines
needed to call guard constraints in transformation rules.
</p>

</li>
<li>
<p><span class="code">beam_tr_funcs.h</span> - Included by <span class="code">beam_load.c</span>.  Contains defines
needed to call a C function to the right of a transformation rule.
</p>
</li>
</ul>
<p>
The following options can be given:
</p>

<ul>
<li>
<p><span class="code">wordsize 32|64</span> - Defines the word size.  Default is 32.
</p>

</li>
<li>
<p><span class="code">code-model Model</span> - The code model as given to <span class="code">-mcmodel</span> option
for GCC.  Default is <span class="code">unknown</span>.  If the code model is <span class="code">small</span> (and
the word size is 64 bits), <strong>beam_makeops</strong> will pack operands
into the upper 32 bits of the instruction word.
</p>

</li>
<li>
<p><span class="code">DSymbol=0|1</span> - Defines the value for a symbol.  The symbol can be
used in <span class="code">%if</span> and <span class="code">%unless</span> directives.
</p>
</li>
</ul>




<h3>
<a name="Syntax-of-tab-files"></a><span onMouseOver="document.getElementById('ghlink-syntax-of-.tab-files-idm30403').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-syntax-of-.tab-files-idm30403').style.visibility = 'hidden';"><a class="title_link" name="syntax-of-.tab-files">6.5 
          Syntax of .tab files</a><span id="ghlink-syntax-of-.tab-files-idm30403" class="ghlink-after"><a href="#syntax-of-.tab-files" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<h4>
<a name="Syntax-of-tab-files_Comments"></a><span onMouseOver="document.getElementById('ghlink-comments-idm30406').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-comments-idm30406').style.visibility = 'hidden';"><a class="title_link" name="comments">Comments</a><span id="ghlink-comments-idm30406" class="ghlink-after"><a href="#comments" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
Any line starting with <span class="code">#</span> is a comment and is ignored.
</p>

<p>
A line with <span class="code">//</span> is also a comment.  It is recommended to only
use this style of comments in files that define implementations of
instructions.
</p>

<p>
A long line can be broken into shorter lines by a placing a <span class="code">\</span> before
the newline.
</p>



<h4>
<a name="Syntax-of-tab-files_Variable-definitions"></a><span onMouseOver="document.getElementById('ghlink-variable-definitions-idm30415').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-variable-definitions-idm30415').style.visibility = 'hidden';"><a class="title_link" name="variable-definitions">Variable definitions</a><span id="ghlink-variable-definitions-idm30415" class="ghlink-after"><a href="#variable-definitions" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
A variable definition binds a variable to a Perl variable.  It is only
meaningful to add a new definition if <strong>beam_makeops</strong> is updated
at the same time to use the variable.  A variable definition looks this:
</p>

<p>
<strong>name</strong>=<strong>value</strong>[;]
</p>

<p>
where <strong>name</strong> is the name of a Perl variable in <strong>beam_makeops</strong>,
and <strong>value</strong> is the value to be given to the variable.  The line
can optionally end with a <span class="code">;</span> (to avoid messing up the
C indentation mode in Emacs).
</p>

<p>
Here follows a description of the variables that are defined.
</p>

<h5>
<a name="Syntax-of-tab-files_Variable-definitions_BEAMFORMATNUMBER"></a>BEAM_FORMAT_NUMBER</h5>



<p>
<span class="code">genop.tab</span> has the following definition:
</p>

<div class="example example-none"><pre>BEAM_FORMAT_NUMBER=0</pre></div>
<p>
It defines the version of the instruction set (which will be
included in the code header in the BEAM code).  Theoretically,
the version could be bumped, and all instructions changed.
In practice, we would have two support two instruction sets
in the runtime system for at least two releases, so it will
probably never happen in practice.
</p>



<h5>
<a name="Syntax-of-tab-files_Variable-definitions_GCREGEXP"></a>GC_REGEXP</h5>



<p>
In <span class="code">macros.tab</span>, there is a definition of <span class="code">GC_REGEXP</span>.
It will be described in <span class="bold_code bc-17"><a href="#Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file_The-GCREGEXP-definition">a later section</a></span>.
</p>





<h4>
<a name="Syntax-of-tab-files_Directives"></a><span onMouseOver="document.getElementById('ghlink-directives-idm30443').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-directives-idm30443').style.visibility = 'hidden';"><a class="title_link" name="directives">Directives</a><span id="ghlink-directives-idm30443" class="ghlink-after"><a href="#directives" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
There are directives to classify specific instructions depending
on how frequently used they are:
</p>

<ul>
<li>
<p><span class="code">%hot</span> - Implementation will be placed in <span class="code">beam_hot.h</span>. Frequently
executed instructions.
</p>

</li>
<li>
<p><span class="code">%warm</span> - Implementation will be placed in <span class="code">beam_warm.h</span>.  Binary
syntax instructions.
</p>

</li>
<li>
<p><span class="code">%cold</span> - Implementation will be placed in <span class="code">beam_cold.h</span>. Trace
instructions and infrequently used instructions.
</p>
</li>
</ul>
<p>
Default is <span class="code">%hot</span>.  The directives will be applied to declarations
of the specific instruction that follow.  Here is an example:
</p>

<div class="example example-none"><pre>%cold
is_number f? xy
%hot</pre></div>
<h5>
<a name="Syntax-of-tab-files_Directives_Conditional-compilation-directives"></a>Conditional compilation directives</h5>



<p>
The <span class="code">%if</span> directive includes a range of lines if a condition is
true.  For example:
</p>

<div class="example example-none"><pre>%if ARCH_64
i_bs_get_integer_32 x f? x
%endif</pre></div>
<p>
The specific instruction <span class="code">i_bs_get_integer_32</span> will only be defined
on a 64-bit machine.
</p>

<p>
The condition can be inverted by using <span class="code">%unless</span> instead of <span class="code">%if</span>:
</p>

<div class="example example-none"><pre>%unless NO_FPE_SIGNALS
fcheckerror p =&gt; i_fcheckerror
i_fcheckerror
fclearerror
%endif</pre></div>
<p>
It is also possible to add an <span class="code">%else</span> clause:
</p>

<div class="example example-none"><pre>%if ARCH_64
BS_SAFE_MUL(A, B, Fail, Dst) {
    Uint64 res = ($A) * ($B);
    if (res / $B != $A) {
        $Fail;
    }
    $Dst = res;
}
%else
BS_SAFE_MUL(A, B, Fail, Dst) {
    Uint64 res = (Uint64)($A) * (Uint64)($B);
    if ((res &gt;&gt; (8*sizeof(Uint))) != 0) {
        $Fail;
    }
    $Dst = res;
}
%endif</pre></div>


<h5>
<a name="Syntax-of-tab-files_Directives_Symbols-that-are-defined-in-directives"></a>Symbols that are defined in directives</h5>



<p>
The following symbols are always defined.
</p>

<ul>
<li>
<span class="code">ARCH_64</span> - is 1 for a 64-bit machine, and 0 otherwise.

</li>
<li>
<span class="code">ARCH_32</span> - is 1 for 32-bit machine, and 1 otherwise.

</li>
</ul>
<p>
The <span class="code">Makefile</span> for building the emulator currently defines the
following symbols by using the <span class="code">-D</span> option on the command line for
<strong>beam_makeops</strong>.
</p>

<ul>
<li>
<span class="code">NO_FPE_SIGNALS</span> - 1 if FPE signals are not enable in runtime system,
0 otherwise.

</li>
<li>
<span class="code">USE_VM_PROBES</span> - 1 if the runtime system is compiled to use VM probes (support for dtrace or systemtap), 0 otherwise.

</li>
</ul>




<h4>
<a name="Syntax-of-tab-files_Defining-external-generic-instructions"></a><span onMouseOver="document.getElementById('ghlink-defining-external-generic-instructions-idm30496').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-defining-external-generic-instructions-idm30496').style.visibility = 'hidden';"><a class="title_link" name="defining-external-generic-instructions">Defining external generic instructions</a><span id="ghlink-defining-external-generic-instructions-idm30496" class="ghlink-after"><a href="#defining-external-generic-instructions" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
External generic BEAM instructions are known to both the compiler and
the runtime system.  They remain stable between releases.  A new major
release may add more external generic instructions, but must not change
the semantics for a previously defined instruction.
</p>

<p>
The syntax for an external generic instruction is as follows:
</p>

<p>
<strong>opcode</strong>: [-]<strong>name</strong>/<strong>arity</strong>
</p>

<p>
<strong>opcode</strong> is an integer greater than or equal to 1.
</p>

<p>
<strong>name</strong> is an identifier starting with a lowercase letter.  <strong>arity</strong> is
an integer denoting the number of operands.
</p>

<p>
<strong>name</strong> can optionally be preceded by <span class="code">-</span> to indicate that it has been
obsoleted.  The compiler is not allowed to generate BEAM files that
use obsolete instructions and the loader will refuse to load BEAM
files that use obsolete instructions.
</p>

<p>
It only makes sense to define external generic instructions in the
file <span class="code">genop.tab</span> in <span class="code">lib/compiler/src</span>, because the compiler must
know about them in order to use them.
</p>

<p>
New instructions must be added at the end of the file, with higher
numbers than the previous instructions.
</p>



<h4>
<a name="Syntax-of-tab-files_Defining-internal-generic-instructions"></a><span onMouseOver="document.getElementById('ghlink-defining-internal-generic-instructions-idm30517').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-defining-internal-generic-instructions-idm30517').style.visibility = 'hidden';"><a class="title_link" name="defining-internal-generic-instructions">Defining internal generic instructions</a><span id="ghlink-defining-internal-generic-instructions-idm30517" class="ghlink-after"><a href="#defining-internal-generic-instructions" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
Internal generic instructions are known only to the runtime
system and can be changed at any time without compatibility issues.
</p>

<p>
There are two ways to define internal generic instructions:
</p>

<ul>
<li>
<p>Implicitly when a specific instruction is defined.  This is by far
the most common way.  Whenever a specific instruction is created,
<strong>beam_makeops</strong> automatically creates an internal generic instruction
if it does not previously exist.
</p>

</li>
<li>
<p>Explicitly.  This is necessary only when a generic instruction does
not have any corresponding specific instruction.
</p>
</li>
</ul>
<p>
The syntax for an internal generic instruction is as follows:
</p>

<p>
<strong>name</strong>/<strong>arity</strong>
</p>

<p>
<strong>name</strong> is an identifier starting with a lowercase letter.  <strong>arity</strong> is
an integer denoting the number of operands.
</p>



<h4>
<a name="Syntax-of-tab-files_About-generic-instructions-in-general"></a><span onMouseOver="document.getElementById('ghlink-about-generic-instructions-in-general-idm30535').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-about-generic-instructions-in-general-idm30535').style.visibility = 'hidden';"><a class="title_link" name="about-generic-instructions-in-general">About generic instructions in general</a><span id="ghlink-about-generic-instructions-in-general-idm30535" class="ghlink-after"><a href="#about-generic-instructions-in-general" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
Each generic instruction has an opcode.  The opcode is an integer,
greater than or equal to 1. For an external generic instruction, it
must be explicitly given <span class="code">genop.tab</span>, while internal generic
instructions are automatically numbered by <strong>beam_makeops</strong>.
</p>

<p>
The identity of a generic instruction is its name combined with its
arity.  That means that it is allowed to define two distinct generic
instructions having the same name but with different arities.  For
example:
</p>

<div class="example example-none"><pre>move_window/5
move_window/6</pre></div>
<p>
Each operand of a generic instruction is tagged with its type.  A generic
instruction can have one of the following types:
</p>

<ul>
<li>
<p><span class="code">x</span> - X register.
</p>

</li>
<li>
<p><span class="code">y</span> - Y register.
</p>

</li>
<li>
<p><span class="code">l</span> - Floating point register number.
</p>

</li>
<li>
<p><span class="code">i</span> - Tagged literal integer.
</p>

</li>
<li>
<p><span class="code">a</span> - Tagged literal atom.
</p>

</li>
<li>
<p><span class="code">n</span> - NIL (<span class="code">[]</span>, the empty list).
</p>

</li>
<li>
<p><span class="code">q</span> - Literal that don't fit in a word, that is an object stored on
the heap such as a list or tuple.  Any heap object type is supported,
even types that don't have real literals such as external references.
</p>

</li>
<li>
<p><span class="code">f</span> - Non-zero failure label.
</p>

</li>
<li>
<p><span class="code">p</span> - Zero failure label.
</p>

</li>
<li>
<p><span class="code">u</span> - Untagged integer that fits in a machine word.  It is used for many
different purposes, such as the number of live registers in <span class="code">test_heap/2</span>,
as a reference to the export for <span class="code">call_ext/2</span>, and as the flags operand for
binary syntax instructions.  When the generic instruction is translated to a
specific instruction, the type for the operand in the specific operation will
tell the loader how to treat the operand.
</p>

</li>
<li>
<p><span class="code">o</span> - Overflow.  If the value for an <span class="code">u</span> operand does not fit in a machine
word, the type of the operand will be changed to <span class="code">o</span> (with no associated
value).  Currently only used internally in the loader in the guard constraint
function <span class="code">binary_too_big()</span>.
</p>

</li>
<li>
<p><span class="code">v</span> - Arity value.  Only used internally in the loader.
</p>
</li>
</ul>


<h4>
<a name="Syntax-of-tab-files_Defining-specific-instructions"></a><span onMouseOver="document.getElementById('ghlink-defining-specific-instructions-idm30587').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-defining-specific-instructions-idm30587').style.visibility = 'hidden';"><a class="title_link" name="defining-specific-instructions">Defining specific instructions</a><span id="ghlink-defining-specific-instructions-idm30587" class="ghlink-after"><a href="#defining-specific-instructions" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
The specific instructions are known only to the runtime system and
are the instructions that are actually executed.  They can be changed
at any time without causing compatibility issues.
</p>

<p>
A specific instruction can have at most 6 operands.
</p>

<p>
A specific instruction is defined by first giving its name followed by
the types for each operand.  For example:
</p>

<div class="example example-none"><pre> move x y</pre></div>
<p>
Internally, for example in the generated code and in the output from
the BEAM disassembler, the instruction <span class="code">move x y</span> will be called <span class="code">move_xy</span>.
</p>

<p>
The name for a specific instruction is an identifier starting with a
lowercase letter.  A type is an lowercase or uppercase letter.
</p>

<p>
All specific instructions with a given name must have the same number
of operands. That is, the following is <strong>not</strong> allowed:
</p>

<div class="example example-none"><pre> move x x
 move x y x y</pre></div>
<p>
Here follows the type letters that more or less directly corresponds
to the types for generic instructions.
</p>

<ul>
<li>
<p><span class="code">x</span> - X register.  Will be loaded as a byte offset to the X register
relative to the base of X register array.  (Can be packed with other
operands.)
</p>

</li>
<li>
<p><span class="code">y</span> - Y register.  Will be loaded as a byte offset to the Y register
relative to the stack frame. (Can be packed with other operands.)
</p>

</li>
<li>
<p><span class="code">r</span> - X register 0.  An implicit operand that will not be stored in
the loaded code.
</p>

</li>
<li>
<p><span class="code">l</span> - Floating point register number.  (Can be packed with other
operands.)
</p>

</li>
<li>
<p><span class="code">i</span> - Tagged literal integer (a SMALL that will fit in one word).
</p>

</li>
<li>
<p><span class="code">a</span> - Tagged atom.
</p>

</li>
<li>
<p><span class="code">n</span> - NIL or the empty list.  (Will not be stored in the loaded code.)
</p>

</li>
<li>
<p><span class="code">q</span> - Tagged CONS or BOXED pointer.  That is, a term such as a list
or tuple.  Any heap object type is supported, even types that don't
have real literals such as external references.
</p>

</li>
<li>
<p><span class="code">f</span> - Failure label (non-zero).  The target for a branch
or call instruction.
</p>

</li>
<li>
<p><span class="code">p</span> - The 0 failure label, meaning that an exception should be raised
if the instruction fails.  (Will not be stored in the loaded code.)
</p>

</li>
<li>
<p><span class="code">c</span> - Any literal term; that is, immediate literals such as SMALL,
and CONS or BOXED pointers to literals.  (Can be used where the
operand in the generic instruction has one of the types <span class="code">i</span>, <span class="code">a</span>, <span class="code">n</span>,
or <span class="code">q</span>.)
</p>
</li>
</ul>
<p>
The types that follow do a type test of the operand at runtime; thus,
they are generally more expensive in terms of runtime than the types
described earlier.  However, those operand types are needed to avoid a
combinatorial explosion in the number of specific instructions and
overall code size of <span class="code">process_main()</span>.
</p>

<ul>
<li>
<p><span class="code">s</span> - Tagged source: X register, Y register, or a literal term.  The
tag will be tested at runtime to retrieve the value from an X
register, a Y register, or simply use the value as a tagged Erlang
term.  (Implementation note: An X register is tagged as a pid, and a Y
register as a port.  Therefore the literal term must not contain a
port or pid.)
</p>

</li>
<li>
<p><span class="code">S</span> - Tagged source register (X or Y).  The tag will be tested at
runtime to retrieve the value from an X register or a Y register.  Slighly
cheaper than <span class="code">s</span>.
</p>

</li>
<li>
<p><span class="code">d</span> - Tagged destination register (X or Y).  The tag will be tested
at runtime to set up a pointer to the destination register.  If the
instrution performs a garbarge collection, it must use the
<span class="code">$REFRESH_GEN_DEST()</span> macro to refresh the pointer before storing to
it (there are more details about that in a later section).
</p>

</li>
<li>
<p><span class="code">j</span> - A failure label (combination of <span class="code">f</span> and <span class="code">p</span>).  If the branch target 0,
an exception will be raised if instruction fails, otherwise control will be
transfered to the target address.
</p>
</li>
</ul>
<p>
The types that follows are all applied to an operand that has the <span class="code">u</span>
type.
</p>

<ul>
<li>
<p><span class="code">t</span> - An untagged integer that will fit in 12 bits (0-4096).  It can be
packed with other operands in a word.  Most often used as the number
of live registers in instructions such as <span class="code">test_heap</span>.
</p>

</li>
<li>
<p><span class="code">I</span> - An untagged integer that will fit in 32 bits.  It can be
packed with other operands in a word on a 64-bit system.
</p>

</li>
<li>
<p><span class="code">W</span> - Untagged integer or pointer.  Not possible to pack with other
operands.
</p>

</li>
<li>
<p><span class="code">e</span> - Pointer to an export entry.  Use by call instructions that call
other modules, such as <span class="code">call_ext</span>.
</p>

</li>
<li>
<p><span class="code">L</span> - A label.  Only used by the <span class="code">label/1</span> instruction.
</p>

</li>
<li>
<p><span class="code">b</span> - Pointer to BIF.  Used by instructions that BIFs, such as
<span class="code">call_bif</span>.
</p>

</li>
<li>
<p><span class="code">A</span> - A tagged arityvalue.  Used in instructions that test the arity
of a tuple.
</p>

</li>
<li>
<p><span class="code">P</span> - A byte offset into a tuple.
</p>

</li>
<li>
<p><span class="code">Q</span> - A byte offset into the stack.  Used for updating the frame
pointer register.  Can be packed with other operands.
</p>
</li>
</ul>
<p>
When the loader translates a generic instruction a specific
instruction, it will choose the most specific instruction that will
fit the types.  Consider the following two instructions:
</p>

<div class="example example-none"><pre>move c x
move n x</pre></div>
<p>
The <span class="code">c</span> operand can encode any literal value, including NIL.  The
<span class="code">n</span> operand only works for NIL.  If we have the generic instruction
<span class="code">{move,nil,{x,1}}</span>, the loader will translate it to <span class="code">move_nx 1</span>
because <span class="code">move n x</span> is more specific.  <span class="code">move_nx</span> could be slightly
faster or smaller (depending on the architecture), because the <span class="code">[]</span>
is not stored explicitly as an operand.
</p>

<h5>
<a name="Syntax-of-tab-files_Defining-specific-instructions_Syntactic-sugar-for-specific-instructions"></a>Syntactic sugar for specific instructions</h5>



<p>
It is possible to specify more than one type letter for each operand.
Here is an example:
</p>

<div class="example example-none"><pre>move cxy xy</pre></div>
<p>
This is syntactic sugar for:
</p>

<div class="example example-none"><pre>move c x
move c y
move x x
move x y
move y x
move y y</pre></div>
<p>
Note the difference between <span class="code">move c xy</span> and <span class="code">move c d</span>.  Note that <span class="code">move c xy</span>
is equivalent to the following two definitions:
</p>

<div class="example example-none"><pre>move c x
move c y</pre></div>
<p>
On the other hand, <span class="code">move c d</span> is a single instruction.  At runtime,
the <span class="code">d</span> operand will be tested to see whether it refers to an X
register or a Y register, and a pointer to the register will be set
up.
</p>



<h5>
<a name="Syntax-of-tab-files_Defining-specific-instructions_The--type-modifier"></a>The '?' type modifier</h5>



<p>
The character <span class="code">?</span> can be added to the end of an operand to indicate
that the operand will not be used every time the instruction is executed.
For example:
</p>

<div class="example example-none"><pre>allocate_heap t I t?
is_eq_exact f? x xy</pre></div>
<p>
In <span class="code">allocate_heap</span>, the last operand is the number of live registers.
It will only be used if there is not enough heap space and a garbage
collection must be performed.
</p>

<p>
In <span class="code">is_eq_exact</span>, the failure address (the first operand) will only be
used if the two register operands are not equal.
</p>

<p>
Knowing that an operand is not always used can improve how packing
is done for some instructions.
</p>

<p>
For the <span class="code">allocate_heap</span> instruction, without the <span class="code">?</span> the packing would
be done like this:
</p>

<div class="example example-none"><pre>     +--------------------+--------------------+
I -&gt; |       Stack needed | &amp;&amp;lb_allocate_heap +
     +--------------------+--------------------+
     |        Heap needed | Live registers     +
     +--------------------+--------------------+</pre></div>
<p>
"Stack needed" and "Heap needed" are always used, but they are in
different words.  Thus, at runtime the <span class="code">allocate_heap</span> instruction
must read both words from memory even though it will not always use
"Live registers".
</p>

<p>
With the <span class="code">?</span>, the operands will be packed like this:
</p>

<div class="example example-none"><pre>     +--------------------+--------------------+
I -&gt; |     Live registers | &amp;&amp;lb_allocate_heap +
     +--------------------+--------------------+
     |        Heap needed |       Stack needed +
     +--------------------+--------------------+</pre></div>
<p>
Now "Stack needed" and "Heap needed" are in the same word.
</p>





<h4>
<a name="Syntax-of-tab-files_Defining-transformation-rules"></a><span onMouseOver="document.getElementById('ghlink-defining-transformation-rules-idm30739').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-defining-transformation-rules-idm30739').style.visibility = 'hidden';"><a class="title_link" name="defining-transformation-rules">Defining transformation rules</a><span id="ghlink-defining-transformation-rules-idm30739" class="ghlink-after"><a href="#defining-transformation-rules" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
Transformation rules are used to rewrite generic instructions to other
generic instructions.  The transformations rules are applied
repeatedly until no rule match.  At that point, the first instruction
in the resulting instruction sequence will be converted to a specific
instruction and added to the code for the module being loaded.  Then
the transformation rules for the remaining instructions are run in the
same way.
</p>

<p>
A rule is recognized by its right-pointer arrow: <span class="code">=&gt;</span>.  To the left of
the arrow is one or more instruction patterns, separated by <span class="code">|</span>.  To
the right of the arrow is zero or more instructions, separated by <span class="code">|</span>.
If the instructions from the BEAM code matches the instruction
patterns on the left side, they will be replaced with instructions on
the right side (or removed if there are no instructions on the right).
</p>

<h5>
<a name="Syntax-of-tab-files_Defining-transformation-rules_Defining-instruction-patterns"></a>Defining instruction patterns</h5>



<p>
We will start looking at the patterns on the left side of the arrow.
</p>

<p>
A pattern for an instruction consists of its name, followed by a pattern
for each of its operands.  The operand patterns are separated by spaces.
</p>

<p>
The simplest possible pattern is a variable.  Just like in Erlang,
a variable must begin with an uppercase letter.  If the same variable is
used in multiple operands, the pattern will only match if the operands
are equal.  For example:
</p>

<div class="example example-none"><pre>move Same Same =&gt;</pre></div>
<p>
This pattern will match if the operands for <span class="code">move</span> are the same.  If
the pattern match, the instruction will be removed.  (That used to be an
actual rule a long time ago when the compiler would occasionally produce
instructions such as <span class="code">{move,{x,2},{x,2}}</span>.)
</p>

<p>
Variables that have been bound on the left side can be used on the
right side.  For example, this rule will rewrite all <span class="code">move</span> instructions
to <span class="code">assign</span> instructions with the operands swapped:
</p>

<div class="example example-none"><pre>move Src Dst =&gt; assign Dst Src</pre></div>
<p>
If we only want to match operands of a certain type, we can
use a type constraint.  A type constraint consists of one or more
lowercase letters, each specifying a type.  For example:
</p>

<div class="example example-none"><pre>is_integer Fail an =&gt; jump Fail</pre></div>
<p>
The second operand pattern, <span class="code">an</span>, will match if the second operand is
either an atom or NIL (the empty list).  In case of a match, the
<span class="code">is_integer/2</span> instruction will be replaced with a <span class="code">jump/1</span>
instruction.
</p>

<p>
An operand pattern can bind a variable and constrain the type at the
same time by following the variable with a <span class="code">=</span> and the constraint.
For example:
</p>

<div class="example example-none"><pre>is_eq_exact Fail=f R=xy C=q =&gt; i_is_eq_exact_literal Fail R C</pre></div>
<p>
Here the <span class="code">is_eq_exact</span> instruction is replaced with a specialized instruction
that only compares literals, but only if the first operand is a register and
the second operand is a literal.
</p>



<h5>
<a name="Syntax-of-tab-files_Defining-transformation-rules_Further-constraining-patterns"></a>Further constraining patterns</h5>



<p>
In addition to specifying a type letter, the actual value for the type can
be specified.  For example:
</p>

<div class="example example-none"><pre>move C=c x==1 =&gt; move_x1 C</pre></div>
<p>
Here the second operand of <span class="code">move</span> is constrained to be X register 1.
</p>

<p>
When specifying an atom constraint, the atom is written as it would be
in the C source code.  That is, it needs an <span class="code">am_</span> prefix, and it must
be listed in <span class="code">atom.names</span>.  For example:
</p>

<div class="example example-none"><pre>is_boolean Fail=f a==am_true =&gt;
is_boolean Fail=f a==am_false =&gt;</pre></div>
<p>
There are several constraints available for testing whether a call is to a BIF
or a function.
</p>

<p>
The constraint <span class="code">u$is_bif</span> will test whether the given operand refers to a BIF.
For example:
</p>

<div class="example example-none"><pre>call_ext u Bif=u$is_bif =&gt; call_bif Bif
call_ext u Func         =&gt; i_call_ext Func</pre></div>
<p>
The <span class="code">call_ext</span> instruction can be used to call functions written in
Erlang as well as BIFs (or more properly called SNIFs).  The
<span class="code">u$is_bif</span> constraint will match if the operand refers to a BIF (that
is, if it is listed in the file <span class="code">bif.tab</span>).  Note that <span class="code">u$is_bif</span>
should only be applied to operands that are known to contain an index
to the import table chunk in the BEAM file (such operands have the
type <span class="code">b</span> or <span class="code">e</span> in the corresponding specific instruction).  If
applied to other <span class="code">u</span> operands, it will at best return a nonsense
result.
</p>

<p>
The <span class="code">u$is_not_bif</span> constraint matches if the operand does not refer to
a BIF (not listed in <span class="code">bif.tab</span>).  For example:
</p>

<div class="example example-none"><pre>move S X0=x==0 | line Loc | call_ext_last Ar Func=u$is_not_bif D =&gt; \
     move S X0 | call_ext_last Ar Func D</pre></div>
<p>
The <span class="code">u$bif:Module:Name/Arity</span> constraint tests whether the given
operand refers to a specific BIF.  Note that <span class="code">Module:Name/Arity</span>
<strong>must</strong> be an existing BIF defined in <span class="code">bif.tab</span>, or there will
be a compilation error.  It is useful when a call to a specific BIF
should be replaced with an instruction as in this example:
</p>

<div class="example example-none"><pre>gc_bif2 Fail Live u$bif:erlang:splus/2 S1 S2 Dst =&gt; \
     gen_plus Fail Live S1 S2 Dst</pre></div>
<p>
Here the call to the GC BIF <span class="code">'+'/2</span> will be replaced with the instruction
<span class="code">gen_plus/5</span>.  Note that the same name as used in the C source code must be
used for the BIF, which in this case is <span class="code">splus</span>.  It is defined like this
in <span class="code">bit.tab</span>:
</p>

<div class="example example-none"><pre>ubif erlang:'+'/2 splus_2</pre></div>
<p>
The <span class="code">u$func:Module:Name/Arity</span> will test whether the given operand is a
a specific function.  Here is an example:
</p>

<div class="example example-none"><pre>bif1 Fail u$func:erlang:is_constant/1 Src Dst =&gt; too_old_compiler</pre></div>
<p>
<span class="code">is_constant/1</span> used to be a BIF a long time ago.  The transformation
replaces the call with the <span class="code">too_old_compiler</span> instruction which will produce
a nicer error message than the default error would be for a missing guard BIF.
</p>



<h5>
<a name="Syntax-of-tab-files_Defining-transformation-rules_Type-constraints-allowed-in-patterns"></a>Type constraints allowed in patterns</h5>



<p>
Here are all type letters that are allowed on the left side of a transformation
rule.
</p>

<ul>
<li>
<p><span class="code">u</span> - An untagged integer that fits in a machine word.
</p>

</li>
<li>
<p><span class="code">x</span> - X register.
</p>

</li>
<li>
<p><span class="code">y</span> - Y register.
</p>

</li>
<li>
<p><span class="code">l</span> - Floating point register number.
</p>

</li>
<li>
<p><span class="code">i</span> - Tagged literal integer.
</p>

</li>
<li>
<p><span class="code">a</span> - Tagged literal atom.
</p>

</li>
<li>
<p><span class="code">n</span> - NIL (<span class="code">[]</span>, the empty list).
</p>

</li>
<li>
<p><span class="code">q</span> - Literals that don't fit in a word, such as list or tuples.
</p>

</li>
<li>
<p><span class="code">f</span> - Non-zero failure label.
</p>

</li>
<li>
<p><span class="code">p</span> - The zero failure label.
</p>

</li>
<li>
<p><span class="code">j</span> - Any label.  Equivalent to <span class="code">fp</span>.
</p>

</li>
<li>
<p><span class="code">c</span> - Any literal term.  Equivalent to <span class="code">ainq</span>.
</p>

</li>
<li>
<p><span class="code">s</span> - X register, Y register, or any literal term.  Equivalent to <span class="code">xyc</span>.
</p>

</li>
<li>
<p><span class="code">d</span> - X or Y register.  Equivalent to <span class="code">xy</span>.  (In a pattern <span class="code">d</span> will
match both source and destination registers.  As an operand in a specific
instruction, it must only be used for a destination register.)
</p>

</li>
<li>
<p><span class="code">o</span> - Overflow.  An untagged integer that does not fit in a machine word.
</p>
</li>
</ul>


<h5>
<a name="Syntax-of-tab-files_Defining-transformation-rules_Guard-constraints"></a>Guard constraints</h5>



<p>
If the constraints described so far is not enough, additional
constraints can be written in C in <span class="code">beam_load.c</span> and be called as a
guard function on the left side of the transformation.  If the guard
function returns a non-zero value, the matching of the rule will
continue, otherwise the match will fail.  For example:
</p>

<div class="example example-none"><pre>ensure_map Lit=q | literal_is_map(Lit) =&gt;</pre></div>
<p>
The guard test <span class="code">literal_is_map/1</span> tests whether the given literal is a map.
If the literal is a map, the instruction is unnecessary and can be removed.
</p>

<p>
It is outside the scope for this document to describe in detail how such
guard functions are written, but for the curious here is the implementation
of <span class="code">literal_is_map()</span>:
</p>

<div class="example example-none"><pre>static int
literal_is_map(LoaderState* stp, GenOpArg Lit)
{
    Eterm term;

    ASSERT(Lit.type == TAG_q);
    term = stp-&gt;literals[Lit.val].term;
    return is_map(term);
}</pre></div>


<h5>
<a name="Syntax-of-tab-files_Defining-transformation-rules_Handling-instruction-with-variable-number-of-operands"></a>Handling instruction with variable number of operands</h5>



<p>
Some instructions, such as <span class="code">select_val/3</span>, essentially has a variable
number of operands.  Such instructions have a <span class="code">{list,[...]}</span> operand
as their last operand in the BEAM assembly code.  For example:
</p>

<div class="example example-none"><pre>{select_val,{x,0},
            {f,1},
            {list,[{atom,b},{f,4},{atom,a},{f,5}]}}.</pre></div>
<p>
The loader will convert a <span class="code">{list,[...]}</span> operand to an <span class="code">u</span> operand whose
value is the number of elements in the list, followed by each element in
the list.  The instruction above would be translated to the following
generic instruction:
</p>

<div class="example example-none"><pre>{select_val,{x,0},{f,1},{u,4},{atom,b},{f,4},{atom,a},{f,5}}</pre></div>
<p>
To match a variable number of arguments we need to use the special
operand type <span class="code">*</span> like this:
</p>

<div class="example example-none"><pre>select_val Src=aiq Fail=f Size=u List=* =&gt; \
    i_const_select_val Src Fail Size List</pre></div>
<p>
This transformation renames a <span class="code">select_val/3</span> instruction
with a constant source operand to <span class="code">i_const_select_val/3</span>.
</p>



<h5>
<a name="Syntax-of-tab-files_Defining-transformation-rules_Constructing-new-instructions-on-the-right-side"></a>Constructing new instructions on the right side</h5>



<p>
The most common operand on the right side is a variable that was bound while
matching the left side.  For example:
</p>

<div class="example example-none"><pre>trim N Remaining =&gt; i_trim N</pre></div>
<p>
An operand can also be a type letter to construct an operand of that type.
Each type has a default value.  For example, the type <span class="code">x</span> has the default
value 1023, which is the highest X register.  That makes <span class="code">x</span> on the right
side a convenient shortcut for a temporary X register.  For example:
</p>

<div class="example example-none"><pre>is_number Fail Literal=q =&gt; move Literal x | is_number Fail x</pre></div>
<p>
If the second operand for <span class="code">is_number/2</span> is a literal, it will be moved to
X register 1023.  Then <span class="code">is_number/2</span> will test whether the value stored in
X register 1023 is a number.
</p>

<p>
This kind of transformation is useful when it is rare that an operand can
be anything else but a register.  In the case of <span class="code">is_number/2</span>, the second
operand is always a register unless the compiler optimizations have been
disabled.
</p>

<p>
If the default value is not suitable, the type letter can be followed
by <span class="code">=</span> and a value.  Most types take an integer value.  The value for
an atom is written the same way as in the C source code.  For example,
the atom <span class="code">false</span> is written as <span class="code">am_false</span>.  The atom must be listed in
<span class="code">atom.names</span>.
</p>

<p>
Here is an example showing how values can be specified:
</p>

<div class="example example-none"><pre>bs_put_utf32 Fail=j Flags=u Src=s =&gt; \
    i_bs_validate_unicode Fail Src | \
    bs_put_integer Fail i=32 u=1 Flags Src</pre></div>


<h5>
<a name="Syntax-of-tab-files_Defining-transformation-rules_Type-letters-on-the-right-side"></a>Type letters on the right side</h5>



<p>
Here follows all types that are allowed to be used in operands for
instructions being constructed on the right side of a transformation
rule.
</p>

<ul>
<li>
<p><span class="code">u</span> - Construct an untagged integer.  The default value is 0.
</p>

</li>
<li>
<p><span class="code">x</span> - X register.  The default value is 1023.  That makes <span class="code">x</span> convenient to
use as a temporary X register.
</p>

</li>
<li>
<p><span class="code">y</span> - Y register.  The default value is 0.
</p>

</li>
<li>
<p><span class="code">l</span> - Floating point register number.  The default value is 0.
</p>

</li>
<li>
<p><span class="code">i</span> - Tagged literal integer.  The default value is 0.
</p>

</li>
<li>
<p><span class="code">a</span> - Tagged atom.  The default value is the empty atom (<span class="code">am_Empty</span>).
</p>

</li>
<li>
<p><span class="code">p</span> - Zero failure label.
</p>

</li>
<li>
<p><span class="code">n</span> - NIL (<span class="code">[]</span>, the empty list).
</p>
</li>
</ul>


<h5>
<a name="Syntax-of-tab-files_Defining-transformation-rules_Function-call-on-the-right-side"></a>Function call on the right side</h5>



<p>
Transformations that are not possible to describe with the rule
language as described here can be written as a C function in
<span class="code">beam_load.c</span> and called from the right side of a transformation.  The
left side of the transformation will perform the match and bind
operands to variables.  The variables can then be passed to a
generator function on the right side.  For example:
</p>

<div class="example example-none"><pre>bif2 Fail=j u$bif:erlang:element/2 Index=s Tuple=xy Dst=d =&gt; \
    gen_element(Jump, Index, Tuple, Dst)</pre></div>
<p>
This transformation rule matches a call to the BIF <span class="code">element/2</span>.
The operands will be captured and the function <span class="code">gen_element()</span> will
be called.
</p>

<p>
<span class="code">gen_element()</span> will produce one of two instructions depending
on <span class="code">Index</span>.  If <span class="code">Index</span> is an integer in the range from 1 up to
the maximum tuple size, the instruction <span class="code">i_fast_element/2</span> will
be produced, otherwise the instruction <span class="code">i_element/4</span> will be
produced.  The corresponding specific instructions are:
</p>

<div class="example example-none"><pre>i_fast_element xy j? I d
i_element xy j? s d</pre></div>
<p>
The <span class="code">i_fast_element/2</span> instruction is faster because the tuple is
already an untagged integer.  It also knows that the index is at least
1, so it does not have to test for that.  The <span class="code">i_element/4</span>
instruction will have to fetch the index from a register, test that it
is an integer, and untag the integer.
</p>

<p>
It is outside the scope of this document to describe in detail how
generator functions are written, but for the curious, here is the
implementation of <span class="code">gen_element()</span>:
</p>

<div class="example example-none"><pre>static GenOp*
gen_element(LoaderState* stp, GenOpArg Fail,
   GenOpArg Index, GenOpArg Tuple, GenOpArg Dst)
{
    GenOp* op;

    NEW_GENOP(stp, op);
    op-&gt;arity = 4;
    op-&gt;next = NULL;

    if (Index.type == TAG_i &amp;&amp; Index.val &gt; 0 &amp;&amp;
       Index.val &lt;= ERTS_MAX_TUPLE_SIZE &amp;&amp;
       (Tuple.type == TAG_x || Tuple.type == TAG_y)) {
        op-&gt;op = genop_i_fast_element_4;
        op-&gt;a[0] = Tuple;
        op-&gt;a[1] = Fail;
        op-&gt;a[2].type = TAG_u;
        op-&gt;a[2].val = Index.val;
        op-&gt;a[3] = Dst;
    } else {
        op-&gt;op = genop_i_element_4;
        op-&gt;a[0] = Tuple;
        op-&gt;a[1] = Fail;
        op-&gt;a[2] = Index;
        op-&gt;a[3] = Dst;
    }

    return op;
}</pre></div>




<h4>
<a name="Syntax-of-tab-files_Defining-the-implementation"></a><span onMouseOver="document.getElementById('ghlink-defining-the-implementation-idm30976').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-defining-the-implementation-idm30976').style.visibility = 'hidden';"><a class="title_link" name="defining-the-implementation">Defining the implementation</a><span id="ghlink-defining-the-implementation-idm30976" class="ghlink-after"><a href="#defining-the-implementation" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
The actual implementation of instructions are also defined in <span class="code">.tab</span>
files processed by <strong>beam_makeops</strong>.  For practical reasons,
instruction definitions are stored in several files, at the time of
writing in the following files:
</p>

<div class="example example-none"><pre>bif_instrs.tab
arith_instrs.tab
bs_instrs.tab
float_instrs.tab
instrs.tab
map_instrs.tab
msg_instrs.tab
select_instrs.tab
trace_instrs.tab</pre></div>
<p>
There is also a file that only contains macro definitions:
</p>

<div class="example example-none"><pre>macros.tab</pre></div>
<p>
The syntax of each file is similar to C code.  In fact, most of
the contents <strong>is</strong> C code, interspersed with macro invocations.
</p>

<p>
To allow Emacs to auto-indent the code, each file starts with the
following line:
</p>

<div class="example example-none"><pre>// -*- c -*-</pre></div>
<p>
To avoid messing up the indentation, all comments are written
as C++ style comments (<span class="code">//</span>) instead of <span class="code">#</span>.  Note that a comment
must start at the beginning of a line.
</p>

<p>
The meat of an instruction definition file are macro definitions.
We have seen this macro definition before:
</p>

<div class="example example-none"><pre>move(Src, Dst) {
    $Dst = $Src;
}</pre></div>
<p>
A macro definitions must start at the beginning of the line (no spaces
allowed), the opening curly bracket must be on the same line, and the
finishing curly bracket must be at the beginning of a line.  It is
recommended that the macro body is properly indented.
</p>

<p>
As a convention, the macro arguments in the head all start with an
uppercase letter.  In the body, the macro arguments can be expanded
by preceding them with <span class="code">$</span>.
</p>

<p>
A macro definition whose name and arity matches a family of
specific instructions is assumed to be the implementation of that
instruction.
</p>

<p>
A macro can also be invoked from within another macro.  For example,
<span class="code">move_deallocate_return/2</span> avoids repeating code by invoking
<span class="code">$deallocate_return()</span> as a macro:
</p>

<div class="example example-none"><pre>move_deallocate_return(Src, Deallocate) {
    x(0) = $Src;
    $deallocate_return($Deallocate);
}</pre></div>
<p>
Here is the definition of <span class="code">deallocate_return/1</span>:
</p>

<div class="example example-none"><pre>deallocate_return(Deallocate) {
    //| -no_next
    int words_to_pop = $Deallocate;
    SET_I((BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, words_to_pop);
    CHECK_TERM(x(0));
    DispatchReturn;
}</pre></div>
<p>
The expanded code for <span class="code">move_deallocate_return</span> will look this:
</p>

<div class="example example-none"><pre>OpCase(move_deallocate_return_cQ):
{
  x(0) = I[1];
  do {
    int words_to_pop = Qb(BeamExtraData(I[0]));
    SET_I((BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, words_to_pop);
    CHECK_TERM(x(0));
    DispatchReturn;
  } while (0);
}</pre></div>
<p>
When expanding macros, <strong>beam_makeops</strong> wraps the expansion in a
<span class="code">do</span>/<span class="code">while</span> wrapper unless <strong>beam_makeops</strong> can clearly see that no
wrapper is needed.  In this case, the wrapper is needed.
</p>

<p>
Note that arguments for macros cannot be complex expressions, because
the arguments are split on <span class="code">,</span>.  For example, the following would
not work because <strong>beam_makeops</strong> would split the expression into
two arguments:
</p>

<div class="example example-none"><pre>$deallocate_return(get_deallocation(y, $Deallocate));</pre></div>
<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Code-generation-directives"></a>Code generation directives</h5>



<p>
Within macro definitions, <span class="code">//</span> comments are in general not treated
specially.  They will be copied to the file with the generated code
along with the rest of code in the body.
</p>

<p>
However, there is an exception. Within a macro definition, a line that
starts with whitespace followed by <span class="code">//|</span> is treated specially.  The
rest of the line is assumed to contain directives to control code
generation.
</p>

<p>
Currently, two code generation directives are recognized:
</p>

<ul>
<li>
<span class="code">-no_prefetch</span>

</li>
<li>
<span class="code">-no_next</span>

</li>
</ul>
<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Code-generation-directives_The-noprefetch-directive"></a>The -no_prefetch directive</h5>



<p>
To see what <span class="code">-no_prefetch</span> does, let's first look at the default code
generation.  Here is the code generated for <span class="code">move_cx</span>:
</p>

<div class="example example-none"><pre>OpCase(move_cx):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  xb(BeamExtraData(I[0])) = I[1];
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}</pre></div>
<p>
Note that the very first thing done is to fetch the address to the
next instruction.  The reason is that it usually improves performance.
</p>

<p>
Just as a demonstration, we can add a <span class="code">-no_prefetch</span> directive to
the <span class="code">move/2</span> instruction:
</p>

<div class="example example-none"><pre>move(Src, Dst) {
    //| -no_prefetch
    $Dst = $Src;
}</pre></div>
<p>
We can see that the prefetch is no longer done:
</p>

<div class="example example-none"><pre>OpCase(move_cx):
{
  xb(BeamExtraData(I[0])) = I[1];
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}</pre></div>
<p>
When would we want to turn off the prefetch in practice?
</p>

<p>
In instructions that will not always execute the next instruction.
For example:
</p>

<div class="example example-none"><pre>is_atom(Fail, Src) {
    if (is_not_atom($Src)) {
        $FAIL($Fail);
    }
}

// From macros.tab
FAIL(Fail) {
    //| -no_prefetch
    $SET_I_REL($Fail);
    Goto(*I);
}</pre></div>
<p>
<span class="code">is_atom/2</span> may either execute the next instruction (if the second
operand is an atom) or branch to the failure label.
</p>

<p>
The generated code looks like this:
</p>

<div class="example example-none"><pre>OpCase(is_atom_fx):
{
  if (is_not_atom(xb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}</pre></div>


<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Code-generation-directives_The-nonext-directive"></a>The -no_next directive</h5>



<p>
Next we will look at when the <span class="code">-no_next</span> directive can be used.  Here
is the <span class="code">jump/1</span> instruction:
</p>

<div class="example example-none"><pre>jump(Fail) {
    $JUMP($Fail);
}

// From macros.tab
JUMP(Fail) {
    //| -no_next
    $SET_I_REL($Fail);
    Goto(*I);
}</pre></div>
<p>
The generated code looks like this:
</p>

<div class="example example-none"><pre>OpCase(jump_f):
{
  ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  Goto(*I);;
}</pre></div>
<p>
If we remove the <span class="code">-no_next</span> directive, the code would look like this:
</p>

<div class="example example-none"><pre>OpCase(jump_f):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  Goto(*I);;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}</pre></div>
<p>
In the end, the C compiler will probably optimize this code to the
same native code as the first version, but the first version is certainly
much easier to read for human readers.
</p>





<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file"></a>Macros in the macros.tab file</h5>



<p>
The file <span class="code">macros.tab</span> contains many useful macros.  When implementing
new instructions it is good practice to look through <span class="code">macros.tab</span> to
see if any of existing macros can be used rather than re-inventing
the wheel.
</p>

<p>
We will describe a few of the most useful macros here.
</p>

<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file_The-GCREGEXP-definition"></a>The GC_REGEXP definition</h5>



<p>
The following line defines a regular expression that will recognize
a call to a function that does a garbage collection:
</p>

<div class="example example-none"><pre> GC_REGEXP=erts_garbage_collect|erts_gc|GcBifFunction;</pre></div>
<p>
The purpose is that <strong>beam_makeops</strong> can verify that an instruction
that does a garbage collection and has an <span class="code">d</span> operand uses the
<span class="code">$REFRESH_GEN_DEST()</span> macro.
</p>

<p>
If you need to define a new function that does garbage collection,
you should give it the prefix <span class="code">erts_gc_</span>.  If that is not possible
you should update the regular expression so that it will match your
new function.
</p>



<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file_FAILFail"></a>FAIL(Fail)</h5>



<p>
Branch to <span class="code">$Fail</span>.  Will suppress prefetch (<span class="code">-no_prefetch</span>).  Typical use:
</p>

<div class="example example-none"><pre>is_nonempty_list(Fail, Src) {
    if (is_not_list($Src)) {
        $FAIL($Fail);
    }
}</pre></div>


<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file_JUMPFail"></a>JUMP(Fail)</h5>



<p>
Branch to <span class="code">$Fail</span>.  Suppresses generation of dispatch of the next
instruction (<span class="code">-no_next</span>).  Typical use:
</p>

<div class="example example-none"><pre>jump(Fail) {
    $JUMP($Fail);
}</pre></div>


<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file_GCTESTNeedStack-NeedHeap-Live"></a>GC_TEST(NeedStack, NeedHeap, Live)</h5>



<p>
<span class="code">$GC_TEST(NeedStack, NeedHeap, Live)</span> tests that given amount of
stack space and heap space is available.  If not it will do a
garbage collection.  Typical use:
</p>

<div class="example example-none"><pre>test_heap(Nh, Live) {
    $GC_TEST(0, $Nh, $Live);
}</pre></div>


<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file_AHNeedStack-NeedHeap-Live"></a>AH(NeedStack, NeedHeap, Live)</h5>



<p>
<span class="code">AH(NeedStack, NeedHeap, Live)</span> allocates a stack frame and
optionally additional heap space.
</p>





<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Predefined-macros-and-variables"></a>Pre-defined macros and variables</h5>



<p>
<strong>beam_makeops</strong> defines several built-in macros and pre-bound variables.
</p>

<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Predefined-macros-and-variables_The-NEXTINSTRUCTION-prebound-variable"></a>The NEXT_INSTRUCTION pre-bound variable</h5>



<p>
The NEXT_INSTRUCTION is a pre-bound variable that is available in
all instructions.  It expands to the address of the next instruction.
</p>

<p>
Here is an example:
</p>

<div class="example example-none"><pre>i_call(CallDest) {
    //| -no_next
    $SAVE_CONTINUATION_POINTER($NEXT_INSTRUCTION);
    $DISPATCH_REL($CallDest);
}</pre></div>
<p>
When calling a function, the return address is first stored in <span class="code">E[0]</span>
(using the <span class="code">$SAVE_CONTINUATION_POINTER()</span> macro), and then control is
transferred to the callee.  Here is the generated code:
</p>

<div class="example example-none"><pre>OpCase(i_call_f):
{
    ASSERT(VALID_INSTR(*(I+2)));
    *E = (BeamInstr) (I+2);;

    /* ... dispatch code intentionally left out ... */
}</pre></div>
<p>
We can see that that <span class="code">$NEXT_INSTRUCTION</span> has been expanded to <span class="code">I+2</span>.
That makes sense since the size of the <span class="code">i_call_f/1</span> instruction is
two words.
</p>



<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Predefined-macros-and-variables_The-IPADJUSTMENT-prebound-variable"></a>The IP_ADJUSTMENT pre-bound variable</h5>



<p>
<span class="code">$IP_ADJUSTMENT</span> is usually 0.  In a few combined instructions
(described below) it can be non-zero.  It is used like this
in <span class="code">macros.tab</span>:
</p>

<div class="example example-none"><pre>SET_I_REL(Offset) {
    ASSERT(VALID_INSTR(*(I + ($Offset) + $IP_ADJUSTMENT)));
    I += $Offset + $IP_ADJUSTMENT;
}</pre></div>
<p>
Avoid using <span class="code">IP_ADJUSTMENT</span> directly.  Use <span class="code">SET_I_REL()</span> or
one of the macros that invoke such as <span class="code">FAIL()</span> or <span class="code">JUMP()</span>
defined in <span class="code">macros.tab</span>.
</p>





<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Predefined-macro-functions"></a>Pre-defined macro functions</h5>



<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Predefined-macro-functions_The-IF-macro"></a>The IF() macro</h5>



<p>
<span class="code">$IF(Expr, IfTrue, IfFalse)</span> evaluates <span class="code">Expr</span>, which must be a valid
Perl expression (which for simple numeric expressions have the same
syntax as C).  If <span class="code">Expr</span> evaluates to 0, the entire <span class="code">IF()</span> expression will be
replaced with <span class="code">IfFalse</span>, otherwise it will be replaced with <span class="code">IfTrue</span>.
</p>

<p>
See the description of <span class="code">OPERAND_POSITION()</span> for an example.
</p>



<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Predefined-macro-functions_The-OPERANDPOSITION-macro"></a>The OPERAND_POSITION() macro</h5>



<p>
<span class="code">$OPERAND_POSITION(Expr)</span> returns the position for <span class="code">Expr</span>, if
<span class="code">Expr</span> is an operand that is not packed.  The first operand is
at position 1.
</p>

<p>
Returns 0 otherwise.
</p>

<p>
This macro could be used like this in order to share code:
</p>

<div class="example example-none"><pre>FAIL(Fail) {
    //| -no_prefetch
    $IF($OPERAND_POSITION($Fail) == 1 &amp;&amp; $IP_ADJUSTMENT == 0,
        goto common_jump,
        $DO_JUMP($Fail));
}

DO_JUMP(Fail) {
    $SET_I_REL($Fail);
    Goto(*I));
}

// In beam_emu.c:
common_jump:
   I += I[1];
   Goto(*I));</pre></div>




<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_The-REFRESHGENDEST-macro"></a>The $REFRESH_GEN_DEST() macro</h5>



<p>
When a specific instruction has a <span class="code">d</span> operand, early during execution
of the instruction, a pointer will be initialized to point to the X or
Y register in question.
</p>

<p>
If there is a garbage collection before the result is stored,
the stack will move and if the <span class="code">d</span> operand refered to a Y
register, the pointer will no longer be valid.  (Y registers are
stored on the stack.)
</p>

<p>
In those circumstances, <span class="code">$REFRESH_GEN_DEST()</span> must be invoked
to set up the pointer again. <strong>beam_makeops</strong> will notice
if there is a call to a function that does a garbage collection and
<span class="code">$REFRESH_GEN_DEST()</span> is not called.
</p>

<p>
Here is a complete example.  The <span class="code">new_map</span> instruction is defined
like this:
</p>

<div class="example example-none"><pre>new_map d t I</pre></div>
<p>
It is implemented like this:
</p>

<div class="example example-none"><pre>new_map(Dst, Live, N) {
    Eterm res;

    HEAVY_SWAPOUT;
    res = erts_gc_new_map(c_p, reg, $Live, $N, $NEXT_INSTRUCTION);
    HEAVY_SWAPIN;
    $REFRESH_GEN_DEST();
    $Dst = res;
    $NEXT($NEXT_INSTRUCTION+$N);
}</pre></div>
<p>
If we have forgotten the <span class="code">$REFRESH_GEN_DEST()</span> there would be a message
similar to this:
</p>

<div class="example example-none"><pre>pointer to destination register is invalid after GC -- use $REFRESH_GEN_DEST()
... from the body of new_map at beam/map_instrs.tab(30)</pre></div>


<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Combined-instructions"></a>Combined instructions</h5>



<p>
<strong>Problem</strong>: For frequently executed instructions we want to use
"fast" operands types such as <span class="code">x</span> and <span class="code">y</span>, as opposed to <span class="code">s</span> or <span class="code">S</span>.
To avoid an explosion in code size, we want to share most of the
implementation between the instructions.  Here are the specific
instructions for <span class="code">i_increment/5</span>:
</p>

<div class="example example-none"><pre>i_increment r W t d
i_increment x W t d
i_increment y W t d</pre></div>
<p>
The <span class="code">i_increment</span> instruction is implemented like this:
</p>

<div class="example example-none"><pre>i_increment(Source, IncrementVal, Live, Dst) {
    Eterm increment_reg_source = $Source;
    Eterm increment_val = $IncrementVal;
    Uint live;
    Eterm result;

    if (ERTS_LIKELY(is_small(increment_reg_val))) {
        Sint i = signed_val(increment_reg_val) + increment_val;
        if (ERTS_LIKELY(IS_SSMALL(i))) {
            $Dst = make_small(i);
            $NEXT0();
        }
    }
    live = $Live;
    HEAVY_SWAPOUT;
    reg[live] = increment_reg_val;
    reg[live+1] = make_small(increment_val);
    result = erts_gc_mixed_plus(c_p, reg, live);
    HEAVY_SWAPIN;
    ERTS_HOLE_CHECK(c_p);
    if (ERTS_LIKELY(is_value(result))) {
        $REFRESH_GEN_DEST();
        $Dst = result;
        $NEXT0();
    }
    ASSERT(c_p-&gt;freason != BADMATCH || is_value(c_p-&gt;fvalue));
    goto find_func_info;
}</pre></div>
<p>
There will be three almost identical copies of the code.  Given the
size of the code, that could be too high cost to pay.
</p>

<p>
To avoid the three copies of the code, we could use only one specific
instruction:
</p>

<div class="example example-none"><pre>i_increment S W t d</pre></div>
<p>
(The same implementation as above will work.)
</p>

<p>
That reduces the code size, but is slower because <span class="code">S</span> means that
there will be extra code to test whether the operand refers to an X
register or a Y register.
</p>

<p>
<strong>Solution</strong>: We can use "combined instructions".  Combined
instructions are combined from instruction fragments.  The
bulk of the code can be shared.
</p>

<p>
Here we will show how <span class="code">i_increment</span> can be implemented as a combined
instruction.  We will show each individual fragment first, and then
show how to connect them together.  First we will need a variable that
we can store the value fetched from the register in:
</p>

<div class="example example-none"><pre>increment.head() {
    Eterm increment_reg_val;
}</pre></div>
<p>
The name <span class="code">increment</span> is the name of the group that the fragment
belongs to.  Note that it does not need to have the same
name as the instruction.  The group name is followed by <span class="code">.</span> and
the name of the fragment.  The name <span class="code">head</span> is pre-defined.
The code in it will be placed at the beginning of a block, so
that all fragments in the group can access it.
</p>

<p>
Next we define the fragment that will pick up the value from the
register from the first operand:
</p>

<div class="example example-none"><pre>increment.fetch(Src) {
    increment_reg_val = $Src;
}</pre></div>
<p>
We call this fragment <span class="code">fetch</span>.  This fragment will be duplicated three
times, one for each value of the first operand (<span class="code">r</span>, <span class="code">x</span>, and <span class="code">y</span>).
</p>

<p>
Next we define the main part of the code that do the actual incrementing.
</p>

<div class="example example-none"><pre>increment.execute(IncrementVal, Live, Dst) {
    Eterm increment_val = $IncrementVal;
    Uint live;
    Eterm result;

    if (ERTS_LIKELY(is_small(increment_reg_val))) {
        Sint i = signed_val(increment_reg_val) + increment_val;
        if (ERTS_LIKELY(IS_SSMALL(i))) {
            $Dst = make_small(i);
            $NEXT0();
        }
    }
    live = $Live;
    HEAVY_SWAPOUT;
    reg[live] = increment_reg_val;
    reg[live+1] = make_small(increment_val);
    result = erts_gc_mixed_plus(c_p, reg, live);
    HEAVY_SWAPIN;
    ERTS_HOLE_CHECK(c_p);
    if (ERTS_LIKELY(is_value(result))) {
        $REFRESH_GEN_DEST();
        $Dst = result;
        $NEXT0();
    }
    ASSERT(c_p-&gt;freason != BADMATCH || is_value(c_p-&gt;fvalue));
    goto find_func_info;
}</pre></div>
<p>
We call this fragment <span class="code">execute</span>.  It will handle the three remaining
operands (<span class="code">W t d</span>).  There will only be one copy of this fragment.
</p>

<p>
Now that we have defined the fragments, we need to inform
<strong>beam_makeops</strong> how they should be connected:
</p>

<div class="example example-none"><pre>i_increment := increment.fetch.execute;</pre></div>
<p>
To the left of the <span class="code">:=</span> is the name of the specific instruction that
should be implemented by the fragments, in this case <span class="code">i_increment</span>.
To the right of <span class="code">:=</span> is the name of the group with the fragments,
followed by a <span class="code">.</span>.  Then the name of the fragments in the group are
listed in the order they should be executed.  Note that the <span class="code">head</span>
fragment is not listed.
</p>

<p>
The line ends in <span class="code">;</span> (to avoid messing up the indentation in Emacs).
</p>

<p>
(Note that in practice the <span class="code">:=</span> line is usually placed before the
fragments.)
</p>

<p>
The generated code looks like this:
</p>

<div class="example example-none"><pre>{
  Eterm increment_reg_val;
  OpCase(i_increment_rWtd):
  {
    increment_reg_val = r(0);
  }
  goto increment__execute;

  OpCase(i_increment_xWtd):
  {
    increment_reg_val = xb(BeamExtraData(I[0]));
  }
  goto increment__execute;

  OpCase(i_increment_yWtd):
  {
    increment_reg_val = yb(BeamExtraData(I[0]));
  }
  goto increment__execute;

  increment__execute:
  {
    // Here follows the code from increment.execute()
    .
    .
    .
}</pre></div>
<h5>
<a name="Syntax-of-tab-files_Defining-the-implementation_Combined-instructions_Some-notes-about-combined-instructions"></a>Some notes about combined instructions</h5>



<p>
The operands that are different must be at
the beginning of the instruction.  All operands in the last
fragment must have the same operands in all variants of
the specific instruction.
</p>

<p>
As an example, the following specific instructions cannot be
implemented as a combined instruction:
</p>

<div class="example example-none"><pre>i_times j? t x x d
i_times j? t x y d
i_times j? t s s d</pre></div>
<p>
We would have to change the order of the operands so that the
two operands that are different are placed first:
</p>

<div class="example example-none"><pre>i_times x x j? t d
i_times x y j? t d
i_times s s j? t d</pre></div>
<p>
We can then define:
</p>

<div class="example example-none"><pre>i_times := times.fetch.execute;

times.head {
    Eterm op1, op2;
}

times.fetch(Src1, Src2) {
    op1 = $Src1;
    op2 = $Src2;
}

times.execute(Fail, Live, Dst) {
    // Multiply op1 and op2.
    .
    .
    .
}</pre></div>
<p>
Several instructions can share a group.  As an example, the following
instructions have different names, but in the end they all create a
binary.  The last two operands are common for all of them:
</p>

<div class="example example-none"><pre>i_bs_init_fail       xy j? t? x
i_bs_init_fail_heap s I j? t? x
i_bs_init                W t? x
i_bs_init_heap         W I t? x</pre></div>
<p>
The instructions are defined like this (formatted with extra
spaces for clarity):
</p>

<div class="example example-none"><pre>i_bs_init_fail_heap := bs_init . fail_heap . verify . execute;
i_bs_init_fail      := bs_init . fail      . verify . execute;
i_bs_init           := bs_init .           .  plain . execute;
i_bs_init_heap      := bs_init .               heap . execute;</pre></div>
<p>
Note that the first two instruction have three fragments, while the
other two only have two fragments.  Here are the fragments:
</p>

<div class="example example-none"><pre>bs_init_bits.head() {
    Eterm num_bits_term;
    Uint num_bits;
    Uint alloc;
}

bs_init_bits.plain(NumBits) {
    num_bits = $NumBits;
    alloc = 0;
}

bs_init_bits.heap(NumBits, Alloc) {
    num_bits = $NumBits;
    alloc = $Alloc;
}

bs_init_bits.fail(NumBitsTerm) {
    num_bits_term = $NumBitsTerm;
    alloc = 0;
}

bs_init_bits.fail_heap(NumBitsTerm, Alloc) {
    num_bits_term = $NumBitsTerm;
    alloc = $Alloc;
}

bs_init_bits.verify(Fail) {
    // Verify the num_bits_term, fail using $FAIL
    // if there is a problem.
.
.
.
}

bs_init_bits.execute(Live, Dst) {
   // Long complicated code to a create a binary.
   .
   .
   .
}</pre></div>
<p>
The full definitions of those instructions can be found in <span class="code">bs_instrs.tab</span>.
The generated code can be found in <span class="code">beam_warm.h</span>.
</p>








</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2021 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../../js/';</script><script type="text/javascript" src="../../js/highlight.js"></script>
</body>
</html>
