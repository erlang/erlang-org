<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- megaco</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/megaco/users_guide.html">User's Guide</a><br><a href="../apps/megaco/index.html">Reference Manual</a><br><a href="../apps/megaco/release_notes.html">Release Notes</a><br><a href="../apps/megaco/megaco.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Megaco/H.248</strong><br><strong>Reference Manual</strong><br><small>Version 3.18</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li id="loadscrollpos" title="megaco " expanded="true">megaco<ul>
<li><a href="megaco.html">
                  Top of manual page
                </a></li>
<li title="start-0"><a href="megaco.html#start-0">start/0</a></li>
<li title="stop-0"><a href="megaco.html#stop-0">stop/0</a></li>
<li title="start_user-2"><a href="megaco.html#start_user-2">start_user/2</a></li>
<li title="stop_user-1"><a href="megaco.html#stop_user-1">stop_user/1</a></li>
<li title="user_info-1"><a href="megaco.html#user_info-1">user_info/1</a></li>
<li title="user_info-2"><a href="megaco.html#user_info-2">user_info/2</a></li>
<li title="update_user_info-3"><a href="megaco.html#update_user_info-3">update_user_info/3</a></li>
<li title="conn_info-1"><a href="megaco.html#conn_info-1">conn_info/1</a></li>
<li title="conn_info-2"><a href="megaco.html#conn_info-2">conn_info/2</a></li>
<li title="update_conn_info-3"><a href="megaco.html#update_conn_info-3">update_conn_info/3</a></li>
<li title="system_info-0"><a href="megaco.html#system_info-0">system_info/0</a></li>
<li title="system_info-1"><a href="megaco.html#system_info-1">system_info/1</a></li>
<li title="info-0"><a href="megaco.html#info-0">info/0</a></li>
<li title="connect-4"><a href="megaco.html#connect-4">connect/4</a></li>
<li title="connect-5"><a href="megaco.html#connect-5">connect/5</a></li>
<li title="disconnect-2"><a href="megaco.html#disconnect-2">disconnect/2</a></li>
<li title="call-3"><a href="megaco.html#call-3">call/3</a></li>
<li title="cast-3"><a href="megaco.html#cast-3">cast/3</a></li>
<li title="encode_actions-3"><a href="megaco.html#encode_actions-3">encode_actions/3</a></li>
<li title="token_tag2string-1"><a href="megaco.html#token_tag2string-1">token_tag2string/1</a></li>
<li title="token_tag2string-2"><a href="megaco.html#token_tag2string-2">token_tag2string/2</a></li>
<li title="token_tag2string-3"><a href="megaco.html#token_tag2string-3">token_tag2string/3</a></li>
<li title="cancel-2"><a href="megaco.html#cancel-2">cancel/2</a></li>
<li title="process_received_message-4"><a href="megaco.html#process_received_message-4">process_received_message/4</a></li>
<li title="process_received_message-5"><a href="megaco.html#process_received_message-5">process_received_message/5</a></li>
<li title="receive_message-4"><a href="megaco.html#receive_message-4">receive_message/4</a></li>
<li title="receive_message-5"><a href="megaco.html#receive_message-5">receive_message/5</a></li>
<li title="parse_digit_map-1"><a href="megaco.html#parse_digit_map-1">parse_digit_map/1</a></li>
<li title="eval_digit_map-1"><a href="megaco.html#eval_digit_map-1">eval_digit_map/1</a></li>
<li title="eval_digit_map-2"><a href="megaco.html#eval_digit_map-2">eval_digit_map/2</a></li>
<li title="report_digit_event-2"><a href="megaco.html#report_digit_event-2">report_digit_event/2</a></li>
<li title="test_digit_event-2"><a href="megaco.html#test_digit_event-2">test_digit_event/2</a></li>
<li title="encode_sdp-1"><a href="megaco.html#encode_sdp-1">encode_sdp/1</a></li>
<li title="decode_sdp-1"><a href="megaco.html#decode_sdp-1">decode_sdp/1</a></li>
<li title="get_sdp_record_from_PropertGroup-2"><a href="megaco.html#get_sdp_record_from_PropertGroup-2">get_sdp_record_from_PropertGroup/2</a></li>
<li title="versions1-0"><a href="megaco.html#versions1-0">versions1/0</a></li>
<li title="versions2-0"><a href="megaco.html#versions2-0">versions2/0</a></li>
<li title="print_version_info-0"><a href="megaco.html#print_version_info-0">print_version_info/0</a></li>
<li title="print_version_info-1"><a href="megaco.html#print_version_info-1">print_version_info/1</a></li>
<li title="enable_trace-2"><a href="megaco.html#enable_trace-2">enable_trace/2</a></li>
<li title="disable_trace-0"><a href="megaco.html#disable_trace-0">disable_trace/0</a></li>
<li title="set_trace-1"><a href="megaco.html#set_trace-1">set_trace/1</a></li>
<li title="get_stats-0"><a href="megaco.html#get_stats-0">get_stats/0</a></li>
<li title="get_stats-1"><a href="megaco.html#get_stats-1">get_stats/1</a></li>
<li title="get_stats-1"><a href="megaco.html#get_stats-1">get_stats/1</a></li>
<li title="get_stats-2"><a href="megaco.html#get_stats-2">get_stats/2</a></li>
<li title="reset_stats-0"><a href="megaco.html#reset_stats-0">reset_stats/0</a></li>
<li title="reset_stats-1"><a href="megaco.html#reset_stats-1">reset_stats/1</a></li>
<li title="test_request-5"><a href="megaco.html#test_request-5">test_request/5</a></li>
<li title="test_reply-5"><a href="megaco.html#test_reply-5">test_reply/5</a></li>
</ul>
</li>
<li id="no" title="megaco_edist_compress " expanded="false">megaco_edist_compress<ul>
<li><a href="megaco_edist_compress.html">
                  Top of manual page
                </a></li>
<li title="Module:encode-2"><a href="megaco_edist_compress.html#Module:encode-2">Module:encode/2</a></li>
<li title="Module:decode-2"><a href="megaco_edist_compress.html#Module:decode-2">Module:decode/2</a></li>
</ul>
</li>
<li id="no" title="megaco_encoder " expanded="false">megaco_encoder<ul>
<li><a href="megaco_encoder.html">
                  Top of manual page
                </a></li>
<li title="Module:encode_message-3"><a href="megaco_encoder.html#Module:encode_message-3">Module:encode_message/3</a></li>
<li title="Module:decode_message-3"><a href="megaco_encoder.html#Module:decode_message-3">Module:decode_message/3</a></li>
<li title="Module:decode_mini_message-3"><a href="megaco_encoder.html#Module:decode_mini_message-3">Module:decode_mini_message/3</a></li>
<li title="Module:encode_transaction-3"><a href="megaco_encoder.html#Module:encode_transaction-3">Module:encode_transaction/3</a></li>
<li title="Module:encode_action_requests-3"><a href="megaco_encoder.html#Module:encode_action_requests-3">Module:encode_action_requests/3</a></li>
<li title="Module:encode_action_reply-3"><a href="megaco_encoder.html#Module:encode_action_reply-3">Module:encode_action_reply/3</a></li>
</ul>
</li>
<li id="no" title="megaco_transport " expanded="false">megaco_transport<ul>
<li><a href="megaco_transport.html">
                  Top of manual page
                </a></li>
<li title="Module:send_message-2"><a href="megaco_transport.html#Module:send_message-2">Module:send_message/2</a></li>
<li title="Module:send_message-3"><a href="megaco_transport.html#Module:send_message-3">Module:send_message/3</a></li>
<li title="Module:resend_message-2"><a href="megaco_transport.html#Module:resend_message-2">Module:resend_message/2</a></li>
</ul>
</li>
<li id="no" title="megaco_tcp " expanded="false">megaco_tcp<ul>
<li><a href="megaco_tcp.html">
                  Top of manual page
                </a></li>
<li title="start_transport-0"><a href="megaco_tcp.html#start_transport-0">start_transport/0</a></li>
<li title="listen-2"><a href="megaco_tcp.html#listen-2">listen/2</a></li>
<li title="connect-2"><a href="megaco_tcp.html#connect-2">connect/2</a></li>
<li title="close-1"><a href="megaco_tcp.html#close-1">close/1</a></li>
<li title="socket-1"><a href="megaco_tcp.html#socket-1">socket/1</a></li>
<li title="send_message-2"><a href="megaco_tcp.html#send_message-2">send_message/2</a></li>
<li title="block-1"><a href="megaco_tcp.html#block-1">block/1</a></li>
<li title="unblock-1"><a href="megaco_tcp.html#unblock-1">unblock/1</a></li>
<li title="upgrade_receive_handle-1"><a href="megaco_tcp.html#upgrade_receive_handle-1">upgrade_receive_handle/1</a></li>
<li title="get_stats-0"><a href="megaco_tcp.html#get_stats-0">get_stats/0</a></li>
<li title="get_stats-1"><a href="megaco_tcp.html#get_stats-1">get_stats/1</a></li>
<li title="get_stats-2"><a href="megaco_tcp.html#get_stats-2">get_stats/2</a></li>
<li title="reset_stats-0"><a href="megaco_tcp.html#reset_stats-0">reset_stats/0</a></li>
<li title="reset_stats-1"><a href="megaco_tcp.html#reset_stats-1">reset_stats/1</a></li>
</ul>
</li>
<li id="no" title="megaco_udp " expanded="false">megaco_udp<ul>
<li><a href="megaco_udp.html">
                  Top of manual page
                </a></li>
<li title="start_transport-0"><a href="megaco_udp.html#start_transport-0">start_transport/0</a></li>
<li title="open-2"><a href="megaco_udp.html#open-2">open/2</a></li>
<li title="close-2"><a href="megaco_udp.html#close-2">close/2</a></li>
<li title="socket-1"><a href="megaco_udp.html#socket-1">socket/1</a></li>
<li title="create_send_handle-3"><a href="megaco_udp.html#create_send_handle-3">create_send_handle/3</a></li>
<li title="send_message-2"><a href="megaco_udp.html#send_message-2">send_message/2</a></li>
<li title="block-1"><a href="megaco_udp.html#block-1">block/1</a></li>
<li title="unblock-1"><a href="megaco_udp.html#unblock-1">unblock/1</a></li>
<li title="upgrade_receive_handle-2"><a href="megaco_udp.html#upgrade_receive_handle-2">upgrade_receive_handle/2</a></li>
<li title="get_stats-0"><a href="megaco_udp.html#get_stats-0">get_stats/0</a></li>
<li title="get_stats-1"><a href="megaco_udp.html#get_stats-1">get_stats/1</a></li>
<li title="get_stats-2"><a href="megaco_udp.html#get_stats-2">get_stats/2</a></li>
<li title="reset_stats-0"><a href="megaco_udp.html#reset_stats-0">reset_stats/0</a></li>
<li title="reset_stats-1"><a href="megaco_udp.html#reset_stats-1">reset_stats/1</a></li>
</ul>
</li>
<li id="no" title="megaco_user " expanded="false">megaco_user<ul>
<li><a href="megaco_user.html">
                  Top of manual page
                </a></li>
<li title="handle_connect-2"><a href="megaco_user.html#handle_connect-2">handle_connect/2</a></li>
<li title="handle_connect-3"><a href="megaco_user.html#handle_connect-3">handle_connect/3</a></li>
<li title="handle_disconnect-3"><a href="megaco_user.html#handle_disconnect-3">handle_disconnect/3</a></li>
<li title="handle_syntax_error-3"><a href="megaco_user.html#handle_syntax_error-3">handle_syntax_error/3</a></li>
<li title="handle_syntax_error-4"><a href="megaco_user.html#handle_syntax_error-4">handle_syntax_error/4</a></li>
<li title="handle_message_error-3"><a href="megaco_user.html#handle_message_error-3">handle_message_error/3</a></li>
<li title="handle_message_error-4"><a href="megaco_user.html#handle_message_error-4">handle_message_error/4</a></li>
<li title="handle_trans_request-3"><a href="megaco_user.html#handle_trans_request-3">handle_trans_request/3</a></li>
<li title="handle_trans_request-4"><a href="megaco_user.html#handle_trans_request-4">handle_trans_request/4</a></li>
<li title="handle_trans_long_request-3"><a href="megaco_user.html#handle_trans_long_request-3">handle_trans_long_request/3</a></li>
<li title="handle_trans_long_request-4"><a href="megaco_user.html#handle_trans_long_request-4">handle_trans_long_request/4</a></li>
<li title="handle_trans_reply-4"><a href="megaco_user.html#handle_trans_reply-4">handle_trans_reply/4</a></li>
<li title="handle_trans_reply-5"><a href="megaco_user.html#handle_trans_reply-5">handle_trans_reply/5</a></li>
<li title="handle_trans_ack-4"><a href="megaco_user.html#handle_trans_ack-4">handle_trans_ack/4</a></li>
<li title="handle_trans_ack-5"><a href="megaco_user.html#handle_trans_ack-5">handle_trans_ack/5</a></li>
<li title="handle_unexpected_trans-3"><a href="megaco_user.html#handle_unexpected_trans-3">handle_unexpected_trans/3</a></li>
<li title="handle_unexpected_trans-4"><a href="megaco_user.html#handle_unexpected_trans-4">handle_unexpected_trans/4</a></li>
<li title="handle_trans_request_abort-4"><a href="megaco_user.html#handle_trans_request_abort-4">handle_trans_request_abort/4</a></li>
<li title="handle_trans_request_abort-5"><a href="megaco_user.html#handle_trans_request_abort-5">handle_trans_request_abort/5</a></li>
<li title="handle_segment_reply-5"><a href="megaco_user.html#handle_segment_reply-5">handle_segment_reply/5</a></li>
<li title="handle_segment_reply-6"><a href="megaco_user.html#handle_segment_reply-6">handle_segment_reply/6</a></li>
</ul>
</li>
<li id="no" title="megaco_flex_scanner " expanded="false">megaco_flex_scanner<ul>
<li><a href="megaco_flex_scanner.html">
                  Top of manual page
                </a></li>
<li title="start-0"><a href="megaco_flex_scanner.html#start-0">start/0</a></li>
<li title="stop-1"><a href="megaco_flex_scanner.html#stop-1">stop/1</a></li>
<li title="is_reentrant_enabled-0"><a href="megaco_flex_scanner.html#is_reentrant_enabled-0">is_reentrant_enabled/0</a></li>
<li title="is_scanner_port-2"><a href="megaco_flex_scanner.html#is_scanner_port-2">is_scanner_port/2</a></li>
<li title="scan-2"><a href="megaco_flex_scanner.html#scan-2">scan/2</a></li>
</ul>
</li>
<li id="no" title="megaco_codec_meas " expanded="false">megaco_codec_meas<ul>
<li><a href="megaco_codec_meas.html">
                  Top of manual page
                </a></li>
<li title="start-0"><a href="megaco_codec_meas.html#start-0">start/0</a></li>
<li title="start-1"><a href="megaco_codec_meas.html#start-1">start/1</a></li>
</ul>
</li>
<li id="no" title="megaco_codec_mstone1 " expanded="false">megaco_codec_mstone1<ul>
<li><a href="megaco_codec_mstone1.html">
                  Top of manual page
                </a></li>
<li title="start-0"><a href="megaco_codec_mstone1.html#start-0">start/0</a></li>
<li title="start-1"><a href="megaco_codec_mstone1.html#start-1">start/1</a></li>
<li title="start-2"><a href="megaco_codec_mstone1.html#start-2">start/2</a></li>
<li title="start_flex-0"><a href="megaco_codec_mstone1.html#start_flex-0">start_flex/0</a></li>
<li title="start_flex-1"><a href="megaco_codec_mstone1.html#start_flex-1">start_flex/1</a></li>
<li title="start_flex-2"><a href="megaco_codec_mstone1.html#start_flex-2">start_flex/2</a></li>
<li title="start_only_drv-0"><a href="megaco_codec_mstone1.html#start_only_drv-0">start_only_drv/0</a></li>
<li title="start_only_drv-1"><a href="megaco_codec_mstone1.html#start_only_drv-1">start_only_drv/1</a></li>
<li title="start_only_drv-2"><a href="megaco_codec_mstone1.html#start_only_drv-2">start_only_drv/2</a></li>
<li title="start_no_drv-0"><a href="megaco_codec_mstone1.html#start_no_drv-0">start_no_drv/0</a></li>
<li title="start_no_drv-1"><a href="megaco_codec_mstone1.html#start_no_drv-1">start_no_drv/1</a></li>
<li title="start_no_drv-2"><a href="megaco_codec_mstone1.html#start_no_drv-2">start_no_drv/2</a></li>
</ul>
</li>
<li id="no" title="megaco_codec_mstone2 " expanded="false">megaco_codec_mstone2<ul>
<li><a href="megaco_codec_mstone2.html">
                  Top of manual page
                </a></li>
<li title="start-0"><a href="megaco_codec_mstone2.html#start-0">start/0</a></li>
<li title="start-1"><a href="megaco_codec_mstone2.html#start-1">start/1</a></li>
</ul>
</li>
<li id="no" title="megaco_codec_transform " expanded="false">megaco_codec_transform<ul>
<li><a href="megaco_codec_transform.html">
                  Top of manual page
                </a></li>
<li title="export_messages-0"><a href="megaco_codec_transform.html#export_messages-0">export_messages/0</a></li>
<li title="export_messages-1"><a href="megaco_codec_transform.html#export_messages-1">export_messages/1</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>megaco</h1></center>
  
  <h3>MODULE</h3>
<div class="REFBODY">megaco</div>
  <h3>MODULE SUMMARY</h3>
<div class="REFBODY">Main API of the Megaco application</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>Interface module for the Megaco application</p>
  </p></div>

  <h3><a name="id56589">DATA TYPES</a></h3>
<div class="REFBODY">
    
    <div class="example"><pre>
megaco_mid() = ip4Address() | ip6Address() | 
               domainName() | deviceName() | 
               mtpAddress() 
ip4Address() = #'IP4Address'{}
ip6Address() = #'IP6Address'{}
domainName() = #'DomainName'{}
deviceName() = pathName() 
pathName()   = ia5String(1..64)
mtpAddress() = octetString(2..4)

action_request() = #'ActionRequest'{}
action_reply() = #'ActionReply'{}
error_desc() = #'ErrorDescriptor'{}
transaction_reply() = #'TransactionReply'{}
segment_no() = integer()

resend_indication() = flag | boolean()

property_parm() = #'PropertyParm'{}
property_group() = [property_parm()]
property_groups() = [property_group()]

sdp() = sdp_c() | sdp_o() | sdp_s() | sdp_i() | sdp_u() | 
        sdp_e() | sdp_p() | sdp_b() | sdp_z() | sdp_k() | 
        sdp_a() | sdp_a_rtpmap() | sdp_a_ptime() | 
        sdp_t() | sdp_r() | sdp_m()
sdp_v() = #megaco_sdp_v{} (Protocol version)
sdp_o() = #megaco_sdp_o{} (Owner/creator and session identifier)
sdp_s() = #megaco_sdp_s{} (Session name)
sdp_i() = #megaco_sdp_i{} (Session information)
sdp_u() = #megaco_sdp_u{} (URI of description)
sdp_e() = #megaco_sdp_e{} (Email address)
sdp_p() = #megaco_sdp_p{} (Phone number)
sdp_c() = #megaco_sdp_c{} (Connection information)
sdp_b() = #megaco_sdp_b{} (Bandwidth information)
sdp_k() = #megaco_sdp_k{} (Encryption key)
sdp_a() = #megaco_sdp_a{} (Session attribute)
sdp_a_rtpmap() = #megaco_sdp_a_rtpmap{}
sdp_a_ptime() = #megaco_sdp_a_ptime{}
sdp_a_quality() = #megaco_sdp_a_quality{}
sdp_a_fmtp() = #megaco_sdp_a_fmtp{}
sdp_z() = #megaco_sdp_z{} (Time zone adjustment)
sdp_t() = #megaco_sdp_t{} (Time the session is active)
sdp_r() = #megaco_sdp_r{} (Repeat times)
sdp_m() = #megaco_sdp_m{} (Media name and transport address)
sdp_property_parm() = sdp() | property_parm()
sdp_property_group() = [sdp_property_parm()]
sdp_property_groups() = [sdp_property_group()]

megaco_timer() = infinity | integer() &gt;= 0 | megaco_incr_timer()
megaco_incr_timer() = #megaco_incr_timer{}
    </pre></div>
    <p>The record <span class="code">megaco_incr_timer</span> contains the following fields: </p>
    <dl>
      <dt><strong><span class="code">wait_for = integer() &gt;= 0</span></strong></dt>
      <dd>
        <p>The actual timer time.</p>
      </dd>
      <dt><strong><span class="code">factor = integer() &gt;= 0</span></strong></dt>
      <dd>
        <p>The factor when calculating the new timer time 
          (<span class="code">wait_for</span>).</p>
      </dd>
      <dt><strong><span class="code">incr = integer()</span></strong></dt>
      <dd>
        <p>The increment value when calculating the new timer time 
          (<span class="code">wait_for</span>). Note that this value <strong>can</strong> be negative
          and that a timer restart can therefor lead to a <span class="code">wait_for</span>
          value of zero! It is up to the user to be aware of the 
          consequences of a <span class="code">wait_for</span> value of zero. </p>
      </dd>
      <dt><strong><span class="code">max_retries = infinity | infinity_restartable | integer() &gt;= 0</span></strong></dt>
      <dd>
        <p>The maximum number of repetitions of the timer.</p>
        <p>There is a special case for this field. When the 
          <span class="code">max_retries</span> has the value <span class="code">infinity_restartable</span>, 
          it means that the timer is restartable as long as some 
          external event occurs (e.g. receipt of a pending 
          message for instance). But the timer will never be
          restarted "by itself", i.e. when the timer expires 
          (whatever the timeout time), so does the timer. 
          Whenever the timer is restarted, the timeout time will 
          be calculated in the usual way! Also, as mentioned 
          above, beware the consequences of setting the value to
          <span class="code">infinity</span> if <strong>incr</strong> has been set to an 
          negative value.</p>
      </dd>
    </dl>

    <a name="start"></a>
  </div>

  <h3>EXPORTS</h3>
    <p><a name="start-0"><span class="bold_code">start() -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Starts the Megaco application</p>
        <p>Users may either explicitly be registered with
          megaco:start_user/2 and/or be statically configured by
          setting the application environment variable 'users' to a
          list of {UserMid, Config} tuples. See the function
          megaco:start_user/2 for details.</p>

        <a name="stop"></a>
      </p></div>

    <p><a name="stop-0"><span class="bold_code">stop() -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Stops the Megaco application</p>

        <a name="start_user"></a>
      </p></div>

    <p><a name="start_user-2"><span class="bold_code">start_user(UserMid, Config) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">UserMid = megaco_mid()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Config  = [{user_info_item(), user_info_value()}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason  = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Initial configuration of a user</p>
        <p>Requires the megaco application to be started. A user is
          either a Media Gateway (MG) or a Media Gateway Controller
          (MGC). One Erlang node may host many users.</p>
        <p>A user is identified by its UserMid, which must be a legal
          Megaco MID.</p>
        <p>Config is a list of {Item, Value} tuples.  See
          megaco:user_info/2 about which items and values that are valid.</p>

        <a name="stop_user"></a>
      </p></div>

    <p><a name="stop_user-1"><span class="bold_code">stop_user(UserMid) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">UserMid = megaco_mid()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason  = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Delete the configuration of a user</p>
        <p>Requires that the user does not have any active connection.</p>

        <a name="user_info"></a>
      </p></div>

    <p><a name="user_info-1"><span class="bold_code">user_info(UserMid) -&gt; [{Item, Value}]</span></a><br><a name="user_info-2"><span class="bold_code">user_info(UserMid, Item) -&gt; Value | exit(Reason)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Handle  = user_info_handle()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">UserMid = megaco_mid() </span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Item    = user_info_item()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Value   = user_info_value()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason  = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Lookup user information</p>
        <p>The following Item's are valid:</p>
        <a name="ui_connections"></a>
        <dl>
          <dt><strong><span class="code">connections</span></strong></dt>
          <dd>
            <p>Lists all active connections for this user. Returns a
              list of megaco_conn_handle records.</p>
            <a name="ui_receive_handle"></a>
          </dd>

          <dt><strong><span class="code">receive_handle</span></strong></dt>
          <dd>
            <p>Construct a megaco_receive_handle record from user config</p>

            <a name="ui_trans_id"></a>
          </dd>

          <dt><strong><span class="code">trans_id</span></strong></dt>
          <dd>
            <p>Current transaction id. </p>
            <p>A positive integer or the atom 
              <span class="code">undefined_serial</span> (in case no messages has been sent).</p>

            <a name="ui_min_trans_id"></a>
          </dd>

          <dt><strong><span class="code">min_trans_id</span></strong></dt>
          <dd>
            <p>First trans id. </p>
            <p>A positive integer, defaults to 1.</p>

            <a name="ui_max_trans_id"></a>
          </dd>

          <dt><strong><span class="code">max_trans_id</span></strong></dt>
          <dd>
            <p>Last trans id. </p>
            <p>A positive integer or <span class="code">infinity</span>, 
              defaults to <span class="code">infinity</span>.</p>

            <a name="ui_request_timer"></a>
          </dd>

          <dt><strong><span class="code">request_timer</span></strong></dt>
          <dd>
            <p>Wait for reply. </p>
            <p>The timer is cancelled when a reply is received. </p>
            <p>When a pending message is received, the timer is 
              cancelled and the <span class="code">long_request_timer</span> is started instead 
              (see below). No resends will be performed from this point 
              (since we now know that the other side has received the 
              request). </p>
            <p>When the timer reaches an intermediate expire, the request
              is resent and the timer is restarted. </p>
            <p>When the timer reaches the final expire, either the function 
              <span class="code">megaco:call</span> will return with <span class="code">{error, timeout}</span>
              or the callback function <span class="code">handle_trans_reply</span> will be 
              called with <span class="code">UserReply = {error, timeout}</span> (if 
              <span class="code">megaco:cast</span> was used).</p>
            <p>A Megaco Timer (see explanation above), 
              defaults to <span class="code">#megaco_incr_timer{}</span>.</p>

            <a name="ui_long_request_timer"></a>
          </dd>

          <dt><strong><span class="code">long_request_timer</span></strong></dt>
          <dd>
            <p>Wait for reply after having received a pending message. </p>
            <p>When the timer reaches an intermediate expire, the timer 
              is restarted. </p>
            <p>When a pending message is received, and the 
              <span class="code">long_request_timer</span>  
              is <strong>not</strong> "on its final leg", the timer will be 
              restarted, and, if <span class="code">long_request_resend = true</span>, the
              request will be re-sent. </p>
            <p>A Megaco Timer (see explanation above), 
              defaults to <span class="code">60 seconds</span>.</p>

            <a name="ui_long_request_resend"></a>
          </dd>

          <dt><strong><span class="code">long_request_resend</span></strong></dt>
          <dd>
            <p>This option indicates weather the request should be 
              resent until the reply is received,
              <strong>even</strong> though a pending message has been received. </p>
            <p>Normally, after a pending message has been received, 
              the request is not resent 
              (since a pending message is an indication that the
              request has been received). But since the reply (to the 
              request) can be lost, this behaviour has its values.</p>
            <p>It is of course pointless to set this value to <strong>true</strong>
              unless the <span class="code">long_request_timer</span> (see above) is also set
              to an incremental timer (<span class="code">#megaco_incr_timer{}</span>). </p>
            <p>A <span class="code">boolean</span>, 
              defaults to <span class="code">false</span>.</p>

            <a name="ui_reply_timer"></a>
          </dd>

          <dt><strong><span class="code">reply_timer</span></strong></dt>
          <dd>
            <p>Wait for an ack. </p>
            <p>When a request is received, some info
              related to the reply is store internally (e.g. the
              binary of the reply). This info will live until either
              an ack is received or this timer expires. For instance,
              if the same request is received again (e.g. a request
              with the same transaction id), the (stored) reply will
              be (re-) sent automatically by megaco.</p>
            <p>If the timer is of type <span class="code">#megaco_incr_timer{}</span>, 
              then for each intermediate timout, the reply will be resent
              (this is valid until the ack is received or 
              the timer expires). </p>
            <p>A Megaco Timer (see explanation above), defaults to 30000.</p>

            <a name="ui_request_keep_alive_timeout"></a>
          </dd>

          <dt><strong><span class="code">request_keep_alive_timeout</span></strong></dt>
          <dd>
            <p>Specifies the timeout time for the request-keep-alive timer. </p>
            <p>This timer is started when the <strong>first</strong> reply to an asynchronous
              request (issued using the 
              <span class="bold_code"><a href="megaco.html#cast">megaco:cast/3</a></span> function)
              arrives. As long as this timer is running, replies will 
              be delivered via the 
              <span class="bold_code"><a href="megaco_user.html#trans_reply">handle_trans_reply/4,5</a></span> 
              callback function, with their "arrival number" 
              (see <span class="code">UserReply</span> of the 
              <span class="bold_code"><a href="megaco_user.html#trans_reply">handle_trans_reply/4,5</a></span> 
              callback function). </p>
            <p>Replies arriving after the timer has expired, will be 
              delivered using the 
              <span class="bold_code"><a href="megaco_user.html#unexpected_trans">handle_unexpected_trans/3,4</a></span> 
              callback function. </p>
            <p>The timeout time can have the values: 
              <span class="code">plain | integer() &gt;= 0</span>. </p>
            <p>Defaults to <span class="code">plain</span>.</p>

            <a name="ui_call_proxy_gc_timeout"></a>
          </dd>

          <dt><strong><span class="code">call_proxy_gc_timeout</span></strong></dt>
          <dd>
            <p>Timeout time for the call proxy. </p>
            <p>When a request is sent using the 
              <span class="bold_code"><a href="megaco.html#call">call/3</a></span> function, 
              a proxy process is started to handle
              all replies. When the reply has been received and delivered 
              to the user, the proxy process continue to exist for as long
              as this option specifies. Any received messages, is passed on 
              to the user via the 
              <span class="bold_code"><a href="megaco_user.html#handle_unexpected_trans">handle_unexpected_trans</a></span> 
              callback function. </p>
            <p>The timeout time is in milliseconds. A value of 0 (zero) means
              that the proxy process will exit directly after the reply has 
              been delivered. </p>
            <p>An integer &gt;= 0, defaults to 5000 (= 5 seconds).</p>

            <a name="ui_auto_ack"></a>
          </dd>

          <dt><strong><span class="code">auto_ack</span></strong></dt>
          <dd>
            <p>Automatic send transaction ack when the transaction
              reply has been received (see <span class="code">trans_ack</span> below). </p>
            <p>This is used for <strong>three-way-handshake</strong>.</p>
            <p>A <span class="code">boolean</span>, defaults to <span class="code">false</span>.</p>

            <a name="ui_trans_ack"></a>
          </dd>

          <dt><strong><span class="code">trans_ack</span></strong></dt>
          <dd>
            <p>Shall ack's be accumulated or not. </p>
            <p>This property is only valid if <span class="code">auto_ack</span> is true.</p>
            <p>If <span class="code">auto_ack</span> is true, then if <span class="code">trans_ack</span> is
              <span class="code">false</span>, ack's will be sent immediately. 
              If <span class="code">trans_ack</span> is <span class="code">true</span>, then 
              ack's will instead be sent to the transaction 
              sender process for accumulation and later sending 
              (see <span class="code">trans_ack_maxcount</span>, <span class="code">trans_req_maxcount</span>, 
              <span class="code">trans_req_maxsize</span>, <span class="code">trans_ack_maxcount</span> and 
              <span class="code">trans_timer</span>). </p>
            <p>See also <span class="bold_code"><a href="../apps/megaco/megaco_run.html#transaction_sender">transaction sender</a></span> for more info.</p>
            <p>An <span class="code">boolean</span>, defaults to <span class="code">false</span>.</p>

            <a name="ui_trans_ack_maxcount"></a>
          </dd>

          <dt><strong><span class="code">trans_ack_maxcount</span></strong></dt>
          <dd>
            <p>Maximum number of accumulated ack's. At most this many ack's
              will be accumulated by the transaction sender (if started and 
              configured to accumulate ack's).</p>
            <p>See also <span class="bold_code"><a href="../apps/megaco/megaco_run.html#transaction_sender">transaction sender</a></span> for more info. </p>
            <p>An <span class="code">integer</span>, defaults to 10.</p>

            <a name="ui_trans_req"></a>
          </dd>

          <dt><strong><span class="code">trans_req</span></strong></dt>
          <dd>
            <p>Shall requests be accumulated or not. </p>
            <p>If <span class="code">trans_req</span> is <span class="code">false</span>, then request(s)
              will be sent immediately (in its own message).</p>
            <p>If <span class="code">trans_req</span> is true, then request(s) will 
              instead be sent to the transaction sender process for 
              accumulation and later sending 
              (see <span class="code">trans_ack_maxcount</span>, <span class="code">trans_req_maxcount</span>, 
              <span class="code">trans_req_maxsize</span>, <span class="code">trans_ack_maxcount</span> and 
              <span class="code">trans_timer</span>). </p>
            <p>See also <span class="bold_code"><a href="../apps/megaco/megaco_run.html#transaction_sender">transaction sender</a></span> for more info. </p>
            <p>An <span class="code">boolean</span>, defaults to <span class="code">false</span>.</p>

            <a name="ui_trans_req_maxcount"></a>
          </dd>

          <dt><strong><span class="code">trans_req_maxcount</span></strong></dt>
          <dd>
            <p>Maximum number of accumulated requests. At most this many 
              requests will be accumulated by the transaction sender 
              (if started and configured to accumulate requests). </p>
            <p>See also <span class="bold_code"><a href="../apps/megaco/megaco_run.html#transaction_sender">transaction sender</a></span> for more info.</p>
            <p>An <span class="code">integer</span>, defaults to 10.</p>
            <a name="ui_trans_req_maxsize"></a>
          </dd>
          <dt><strong><span class="code">trans_req_maxsize</span></strong></dt>
          <dd>
            <p>Maximum size of the accumulated requests. At most this much
              requests will be accumulated by the transaction sender 
              (if started and configured to accumulate requests).</p>
            <p>See also <span class="bold_code"><a href="../apps/megaco/megaco_run.html#transaction_sender">transaction sender</a></span> for more info.</p>
            <p>An <span class="code">integer</span>, defaults to 2048.</p>

            <a name="ui_trans_timer"></a>
          </dd>

          <dt><strong><span class="code">trans_timer</span></strong></dt>
          <dd>
            <p>Transaction sender timeout time. Has two functions. First, if 
              the value is 0, then transactions will not be accumulated 
              (e.g. the transaction sender process will not be started). 
              Second, if the value is greater then 0 and <span class="code">auto_ack</span> 
              and <span class="code">trans_ack</span> are both true or 
              if <span class="code">trans_req</span> is true, 
              then transaction sender will be started and transactions 
              (which is depending on the values of <span class="code">auto_ack</span>, 
              <span class="code">trans_ack</span> and <span class="code">trans_req</span>) will be accumulated,
              for later sending. </p>
            <p>See also <span class="bold_code"><a href="../apps/megaco/megaco_run.html#transaction_sender">transaction sender</a></span> for more info. </p>
            <p>An <span class="code">integer</span>, defaults to 0.</p>

            <a name="ui_pending_timer"></a>
          </dd>

          <dt><strong><span class="code">pending_timer</span></strong></dt>
          <dd>
            <p>Automatically send pending if the timer expires before a
              transaction reply has been sent. This timer is also called 
              provisional response timer. </p>
            <p>A Megaco Timer (see explanation above), defaults to 30000.</p>

            <a name="ui_sent_pending_limit"></a>
          </dd>

          <dt><strong><span class="code">sent_pending_limit</span></strong></dt>
          <dd>
            <p>Sent pending limit (see the MGOriginatedPendingLimit
              and the MGCOriginatedPendingLimit of the megaco root package).
              This parameter specifies how many pending messages that can
              be sent (for a given received transaction request).
              When the limit is exceeded, the transaction is aborted
              (see <span class="bold_code"><a href="megaco_user.html#request_abort">handle_trans_request_abort</a></span>) and an error message 
              is sent to the other side. </p>
            <p>Note that this has no effect on the actual sending of
              pending transactions. This is either implicit (e.g. when 
              receiving a re-sent transaction request for a request which
              is being processed) or controlled by the pending_timer,
              see above. </p>
            <p>A positive integer or <span class="code">infinity</span>, 
              defaults to <span class="code">infinity</span>.</p>

            <a name="ui_recv_pending_limit"></a>
          </dd>

          <dt><strong><span class="code">recv_pending_limit</span></strong></dt>
          <dd>
            <p>Receive pending limit (see the MGOriginatedPendingLimit
              and the MGCOriginatedPendingLimit of the megaco root package).
              This parameter specifies how many pending messages that can
              be received (for a sent transaction request).
              When the limit is exceeded, the transaction is considered
              lost, and an error returned to the user (through the call-back
              function <strong>handle_trans_reply</strong>). </p>
            <p>A positive integer or <span class="code">infinity</span>, 
              defaults to <span class="code">infinity</span>. </p>

            <a name="ui_send_mod"></a>
          </dd>

          <dt><strong><span class="code">send_mod</span></strong></dt>
          <dd>
            <p>Send callback module which exports send_message/2. The
              function SendMod:send_message(SendHandle, Binary) is
              invoked when the bytes needs to be transmitted to the
              remote user. </p>
            <p>An <span class="code">atom</span>, defaults to <span class="code">megaco_tcp</span>.</p>

            <a name="ui_encoding_mod"></a>
          </dd>

          <dt><strong><span class="code">encoding_mod</span></strong></dt>
          <dd>
            <p>Encoding callback module which exports encode_message/2
              and decode_message/2. The function
              EncodingMod:encode_message(EncodingConfig,
              MegacoMessage) is invoked whenever a 'MegacoMessage'
              record needs to be translated into an Erlang binary. The
              function EncodingMod:decode_message(EncodingConfig,
              Binary) is invoked whenever an Erlang binary needs to be
              translated into a 'MegacoMessage' record. </p>
            <p>An <span class="code">atom</span>, defaults to <span class="code">megaco_pretty_text_encoder</span>.</p>

            <a name="ui_encoding_config"></a>
          </dd>

          <dt><strong><span class="code">encoding_config</span></strong></dt>
          <dd>
            <p>Encoding module config. </p>
            <p>A <span class="code">list</span>, defaults to <span class="code">[]</span>.</p>

            <a name="ui_protocol_version"></a>
          </dd>

          <dt><strong><span class="code">protocol_version</span></strong></dt>
          <dd>
            <p>Actual protocol version. </p>
            <p>An <span class="code">integer</span>, default is 1.</p>

            <a name="ui_strict_version"></a>
          </dd>

          <dt><strong><span class="code">strict_version</span></strong></dt>
          <dd>
            <p>Strict version control, i.e. when a message is received,
              verify that the version is that which was negotiated. </p>
            <p>An <span class="code">boolean</span>, default is true.</p>

            <a name="ui_reply_data"></a>
          </dd>

          <dt><strong><span class="code">reply_data</span></strong></dt>
          <dd>
            <p>Default reply data. </p>
            <p>Any term, defaults to the atom <span class="code">undefined</span>.</p>

            <a name="ui_user_mod"></a>
          </dd>

          <dt><strong><span class="code">user_mod</span></strong></dt>
          <dd>
            <p>Name of the user callback module. See the the reference
              manual for megaco_user for more info.</p>

            <a name="ui_user_args"></a>
          </dd>

          <dt><strong><span class="code">user_args</span></strong></dt>
          <dd>
            <p>List of extra arguments to the user callback
              functions. See the the reference manual for megaco_user
              for more info.</p>

            <a name="ui_threaded"></a>
          </dd>

          <dt><strong><span class="code">threaded</span></strong></dt>
          <dd>
            <p>If a received message contains several transaction requests, 
              this option indicates whether the requests should be handled
              sequentially in the same process (<span class="code">false</span>), or if each 
              request should be handled by its own process (<span class="code">true</span>
              i.e. a separate process is spawned for each request). </p>
            <p>An <span class="code">boolean</span>, defaults to <span class="code">false</span>. </p>

            <a name="ui_resend_indication"></a>
          </dd>

          <dt><strong><span class="code">resend_indication</span></strong></dt>
          <dd>
            <p>This option indicates weather the transport module
              should be told if a message send is a resend or not. </p>
            <p>If <strong>false</strong>, megaco messages are sent using the
              <span class="bold_code"><a href="megaco_transport.html#send_message">send_message</a></span> 
              function. </p>
            <p>If <strong>true</strong>, megaco message <strong>re-sends</strong> are made using the
              <span class="bold_code"><a href="megaco_transport.html#resend_message">resend_message</a></span> 
              function. The initial message send is still done using the
              <span class="bold_code"><a href="megaco_transport.html#send_message">send_message</a></span> 
              function. </p>
            <p>The special value <strong>flag</strong> instead indicates that the 
              function 
              <span class="bold_code"><a href="megaco_transport.html#send_message">send_message/3</a></span> 
              shall be used. </p>
            <p>A <span class="code">resend_indication()</span>, 
              defaults to <span class="code">false</span>.</p>

            <a name="ui_segment_reply_ind"></a>
          </dd>

          <dt><strong><span class="code">segment_reply_ind</span></strong></dt>
          <dd>
            <p>This option specifies if the user shall be notified of received
              segment replies or not. </p>
            <p>See 
              <span class="bold_code"><a href="megaco_user.html#segment_reply">handle_segment_reply</a></span> 
              callback function for more information. </p>
            <p>A <span class="code">boolean</span>, 
              defaults to <span class="code">false</span>. </p>

            <a name="ui_segment_recv_timer"></a>
          </dd>

          <dt><strong><span class="code">segment_recv_timer</span></strong></dt>
          <dd>
            <p>This timer is started when the segment indicated by the
              <span class="code">segmentation complete token</span> is received, but all 
              segments has not yet been received.</p>
            <p>When the timer finally expires, a "megaco segments not
              received" (459) error message is sent to the other side
              and the user is notified with a <span class="code">segment timeout</span> <span class="code">UserReply</span> in either the
              <span class="bold_code"><a href="megaco_user.html#trans_reply">handle_trans_reply</a></span> callback function or 
              the return value of the 
              <span class="bold_code"><a href="megaco.html#call">call</a></span> function. </p>
            <p>A Megaco Timer (see explanation above),
              defaults to <span class="code">10000</span>. </p>

            <a name="ui_segment_send"></a>
          </dd>

          <dt><strong><span class="code">segment_send</span></strong></dt>
          <dd>
            <p>Shall outgoing messages be segmented or not: </p>
            <dl>
              <dt><strong><span class="code">none</span></strong></dt>
              <dd>
                <p>Do not segment outgoing reply messages. This is useful when
                  either it is known that messages are never to large or
                  that the transport protocol can handle such things
                  on its own (e.g. TCP or SCTP).</p>
              </dd>
              <dt><strong><span class="code">integer() &gt; 0</span></strong></dt>
              <dd>
                <p>Outgoing reply messages will be segmented as needed 
                  (see <span class="code">max_pdu_size</span> below). This value, K, indicate 
                  the outstanding window, i.e. how many segments can be 
                  outstanding (not acknowledged) at any given time. </p>
              </dd>
              <dt><strong><span class="code">infinity</span></strong></dt>
              <dd>
                <p>Outgoing reply messages will be segmented as needed 
                  (see <span class="code">max_pdu_size</span> below). Segment messages 
                  are sent all at once (i.e. no acknowledgement awaited 
                  before sending the next segment). </p>
              </dd>
            </dl>
            <p>Defaults to <span class="code">none</span>. </p>

            <a name="ui_max_pdu_size"></a>
          </dd>

          <dt><strong><span class="code">max_pdu_size</span></strong></dt>
          <dd>
            <p>Max message size. If the encoded message (PDU) exceeds 
              this size, the message should be segmented, and then 
              encoded. </p>
            <p>A positive integer or <span class="code">infinity</span>,
              defaults to <span class="code">infinity</span>. </p>
          </dd>
        </dl>

        <a name="update_user_info"></a>
      </p></div>

    <p><a name="update_user_info-3"><span class="bold_code">update_user_info(UserMid, Item, Value) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">UserMid = megaco_mid() </span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Item    = user_info_item()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Value   = user_info_value()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason  = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Update information about a user</p>
        <p>Requires that the user is started. See megaco:user_info/2
          about which items and values that are valid.</p>

        <a name="conn_info"></a>
      </p></div>

    <p><a name="conn_info-1"><span class="bold_code">conn_info(ConnHandle) -&gt; [{Item, Value}]</span></a><br><a name="conn_info-2"><span class="bold_code">conn_info(ConnHandle, Item) -&gt; Value | exit(Reason)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConnHandle = #megaco_conn_handle{}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Item       = conn_info_item()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Value      = conn_info_value()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason     = {no_such_connection, ConnHandle} | term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Lookup information about an active connection</p>
        <p>Requires that the connection is active.</p>
        <a name="ci_control_pid"></a>
        <dl>

          <dt><strong><span class="code">control_pid</span></strong></dt>
          <dd>
            <p>The process identifier of the controlling process for a
              connection.</p>

            <a name="ci_send_handle"></a>
          </dd>

          <dt><strong><span class="code">send_handle</span></strong></dt>
          <dd>
            <p>Opaque send handle whose contents is internal for the
              send module. May be any term.</p>

            <a name="ci_local_mid"></a>
          </dd>

          <dt><strong><span class="code">local_mid</span></strong></dt>
          <dd>
            <p>The local mid (of the connection, i.e. the own mid). 
              <span class="code">megaco_mid()</span>.</p>

            <a name="ci_remote_mid"></a>
          </dd>

          <dt><strong><span class="code">remote_mid</span></strong></dt>
          <dd>
            <p>The remote mid (of the connection). 
              <span class="code">megaco_mid()</span>.</p>

            <a name="ci_receive_handle"></a>
          </dd>

          <dt><strong><span class="code">receive_handle</span></strong></dt>
          <dd>
            <p>Construct a megaco_receive_handle record.</p>

            <a name="ci_trans_id"></a>
          </dd>

          <dt><strong><span class="code">trans_id</span></strong></dt>
          <dd>
            <p>Next transaction id. A positive integer or the atom 
              <span class="code">undefined_serial</span> (only in case of error). </p>
            <p>Note that transaction id's are (currently) maintained 
              on a per user basis so there is no way to be sure that 
              the value returned will actually be used for a transaction 
              sent on this connection (in case a user has several 
              connections, which is not at all unlikely). </p>

            <a name="ci_max_trans_id"></a>
          </dd>

          <dt><strong><span class="code">max_trans_id</span></strong></dt>
          <dd>
            <p>Last trans id. </p>
            <p>A positive integer or <span class="code">infinity</span>, 
              defaults to <span class="code">infinity</span>.</p>

            <a name="ci_request_time"></a>
          </dd>

          <dt><strong><span class="code">request_timer</span></strong></dt>
          <dd>
            <p>Wait for reply. </p>
            <p>The timer is cancelled when a reply is received. </p>
            <p>When a pending message is received, the timer is 
              cancelled and the <span class="code">long_request_timer</span> is started instead 
              (see below). No resends will be performed from this point 
              (since we now know that the other side has received the 
              request). </p>
            <p>When the timer reaches an intermediate expire, the request
              is resent and the timer is restarted. </p>
            <p>When the timer reaches the final expire, either the function 
              <span class="code">megaco:call</span> will return with <span class="code">{error, timeout}</span>
              or the callback function <span class="code">handle_trans_reply</span> will be 
              called with <span class="code">UserReply = {error, timeout}</span> (if 
              <span class="code">megaco:cast</span> was used).</p>
            <p>A Megaco Timer (see explanation above), 
              defaults to #megaco_incr_timer{}.</p>

            <a name="ci_long_request_timer"></a>
          </dd>

          <dt><strong><span class="code">long_request_timer</span></strong></dt>
          <dd>
            <p>Wait for reply after having received a pending message. </p>
            <p>When the timer reaches an intermediate expire, the timer 
              restarted. </p>
            <p>When a pending message is received, and the 
              <span class="code">long_request_timer</span> 
              is <strong>not</strong> "on its final leg", the timer will be 
              restarted, and, if <span class="code">long_request_resend = true</span>, the
              request will be re-sent. </p>
            <p>A Megaco Timer (see explanation above), 
              defaults to <span class="code">60 seconds</span>.</p>

            <a name="ci_request_keep_alive_timeout"></a>
          </dd>

          <dt><strong><span class="code">request_keep_alive_timeout</span></strong></dt>
          <dd>
            <p>Specifies the timeout time for the request-keep-alive timer. </p>
            <p>This timer is started when the <strong>first</strong> reply to an asynchronous
              request (issued using the 
              <span class="bold_code"><a href="megaco.html#cast">megaco:cast/3</a></span> function)
              arrives. As long as this timer is running, replies will 
              be delivered via the 
              <span class="bold_code"><a href="megaco_user.html#trans_reply">handle_trans_reply/4,5</a></span> 
              callback function, with their "arrival number" 
              (see <span class="code">UserReply</span> of the 
              <span class="bold_code"><a href="megaco_user.html#trans_reply">handle_trans_reply/4,5</a></span> 
              callback function). </p>
            <p>Replies arriving after the timer has expired, will be 
              delivered using the 
              <span class="bold_code"><a href="megaco_user.html#unexpected_trans">handle_unexpected_trans/3,4</a></span> 
              callback function. </p>
            <p>The timeout time can have the values: 
              <span class="code">plain | integer() &gt;= 0</span>. </p>
            <p>Defaults to <span class="code">plain</span>.</p>

            <a name="ci_long_request_resend"></a>
          </dd>

          <dt><strong><span class="code">long_request_resend</span></strong></dt>
          <dd>
            <p>This option indicates weather the request should be 
              resent until the reply is received,
              <strong>even</strong> though a pending message has been received. </p>
            <p>Normally, after a pending message has been received, 
              the request is not resent 
              (since a pending message is an indication that the
              request has been received). But since the reply (to the 
              request) can be
              lost, this behaviour has its values.</p>
            <p>It is of course pointless to set this value to <strong>true</strong>
              unless the <span class="code">long_request_timer</span> (see above) is also set
              to an incremental timer (<span class="code">#megaco_incr_timer{}</span>). </p>
            <p>A <span class="code">boolean</span>, 
              defaults to <span class="code">false</span>.</p>

            <a name="ci_reply_timer"></a>
          </dd>

          <dt><strong><span class="code">reply_timer</span></strong></dt>
          <dd>
            <p>Wait for an ack. </p>
            <p>When a request is received, some info
              related to the reply is store internally (e.g. the
              binary of the reply). This info will live until either
              an ack is received or this timer expires. For instance,
              if the same request is received again (e.g. a request
              with the same transaction id), the (stored) reply will
              be (re-) sent automatically by megaco.</p>
            <p>If the timer is of type <span class="code">#megaco_incr_timer{}</span>, 
              then for each intermediate timout, the reply will be resent
              (this is valid until the ack is received or 
              the timer expires). </p>
            <p>A Megaco Timer (see explanation above), defaults to 30000.</p>

            <a name="ci_call_proxy_gc_timeout"></a>
          </dd>

          <dt><strong><span class="code">call_proxy_gc_timeout</span></strong></dt>
          <dd>
            <p>Timeout time for the call proxy. </p>
            <p>When a request is sent using the 
              <span class="bold_code"><a href="megaco.html#call">call/3</a></span> function, 
              a proxy process is started to handle
              all replies. When the reply has been received and delivered 
              to the user, the proxy process continue to exist for as long
              as this option specifies. Any received messages, is passed on 
              to the user via the 
              <span class="bold_code"><a href="megaco_user.html#handle_unexpected_trans">handle_unexpected_trans</a></span> 
              callback function. </p>
            <p>The timeout time is in milliseconds. A value of 0 (zero) means
              that the proxy process will exit directly after the reply has 
              been delivered. </p>
            <p>An integer &gt;= 0, defaults to 5000 (= 5 seconds).</p>
            <a name="ci_auto_ack"></a>
          </dd>

          <dt><strong><span class="code">auto_ack</span></strong></dt>
          <dd>
            <p>Automatic send transaction ack when the transaction
              reply has been received (see <span class="code">trans_ack</span> below). </p>
            <p>This is used for <strong>three-way-handshake</strong>. </p>
            <p>A <span class="code">boolean</span>, defaults to <span class="code">false</span>.</p>

            <a name="ci_trans_ack"></a>
          </dd>

          <dt><strong><span class="code">trans_ack</span></strong></dt>
          <dd>
            <p>Shall ack's be accumulated or not. </p>
            <p>This property is only valid if <span class="code">auto_ack</span> is true. </p>
            <p>If <span class="code">auto_ack</span> is true, then if <span class="code">trans_ack</span> is
              <span class="code">false</span>, ack's will be sent immediately. 
              If <span class="code">trans_ack</span> is
              <span class="code">true</span>, then ack's will instead be sent to the transaction 
              sender process for accumulation and later sending 
              (see <span class="code">trans_ack_maxcount</span>, <span class="code">trans_req_maxcount</span>, 
              <span class="code">trans_req_maxsize</span>, <span class="code">trans_ack_maxcount</span> and 
              <span class="code">trans_timer</span>). </p>
            <p>See also <span class="bold_code"><a href="../apps/megaco/megaco_run.html#transaction_sender">transaction sender</a></span> for more info. </p>
            <p>An <span class="code">boolean</span>, defaults to <span class="code">false</span>.</p>

            <a name="ci_trans_ack_maxcount"></a>
          </dd>

          <dt><strong><span class="code">trans_ack_maxcount</span></strong></dt>
          <dd>
            <p>Maximum number of accumulated ack's. At most this many ack's
              will be accumulated by the transaction sender (if started and 
              configured to accumulate ack's).</p>
            <p>See also <span class="bold_code"><a href="../apps/megaco/megaco_run.html#transaction_sender">transaction sender</a></span> for more info.</p>
            <p>An integer, defaults to 10.</p>

            <a name="ci_trans_req"></a>
          </dd>

          <dt><strong><span class="code">trans_req</span></strong></dt>
          <dd>
            <p>Shall requests be accumulated or not. </p>
            <p>If <span class="code">trans_req</span> is <span class="code">false</span>, then request(s)
              will be sent immediately (in its own message). </p>
            <p>If <span class="code">trans_req</span> is true, then request(s) will 
              instead be sent to the transaction sender process for 
              accumulation and later sending 
              (see <span class="code">trans_ack_maxcount</span>, <span class="code">trans_req_maxcount</span>, 
              <span class="code">trans_req_maxsize</span>, <span class="code">trans_ack_maxcount</span> and 
              <span class="code">trans_timer</span>). </p>
            <p>See also <span class="bold_code"><a href="../apps/megaco/megaco_run.html#transaction_sender">transaction sender</a></span> for more info. </p>
            <p>An <span class="code">boolean</span>, defaults to <span class="code">false</span>.</p>

            <a name="ci_trans_req_maxcount"></a>
          </dd>

          <dt><strong><span class="code">trans_req_maxcount</span></strong></dt>
          <dd>
            <p>Maximum number of accumulated requests. At most this many 
              requests will be accumulated by the transaction sender 
              (if started and configured to accumulate requests). </p>
            <p>See also <span class="bold_code"><a href="../apps/megaco/megaco_run.html#transaction_sender">transaction sender</a></span> for more info. </p>
            <p>An <span class="code">integer</span>, defaults to 10.</p>

            <a name="ci_trans_req_maxsize"></a>
          </dd>

          <dt><strong><span class="code">trans_req_maxsize</span></strong></dt>
          <dd>
            <p>Maximum size of the accumulated requests. At most this much
              requests will be accumulated by the transaction sender 
              (if started and configured to accumulate requests). </p>
            <p>See also <span class="bold_code"><a href="../apps/megaco/megaco_run.html#transaction_sender">transaction sender</a></span> for more info. </p>
            <p>An <span class="code">integer</span>, defaults to 2048.</p>

            <a name="ci_trans_timer"></a>
          </dd>

          <dt><strong><span class="code">trans_timer</span></strong></dt>
          <dd>
            <p>Transaction sender timeout time. Has two functions. First, if 
              the value is 0, then transactions will not be accumulated 
              (e.g. the transaction sender process will not be started). 
              Second, if the value is greater then 0 and <span class="code">auto_ack</span> 
              and <span class="code">trans_ack</span> is true or if <span class="code">trans_req</span> is true, 
              then transaction sender will be started and transactions 
              (which is depending on the values of <span class="code">auto_ack</span>, 
              <span class="code">trans_ack</span> and <span class="code">trans_req</span>) will be accumulated,
              for later sending. </p>
            <p>See also <span class="bold_code"><a href="../apps/megaco/megaco_run.html#transaction_sender">transaction sender</a></span> for more info. </p>
            <p>An <span class="code">integer</span>, defaults to 0.</p>

            <a name="ci_pending_timer"></a>
          </dd>

          <dt><strong><span class="code">pending_timer</span></strong></dt>
          <dd>
            <p>Automatic send transaction pending if the timer expires
              before a transaction reply has been sent. This timer is
              also called provisional response timer. </p>
            <p>A Megaco Timer (see explanation above), defaults to 30000.</p>

            <a name="ci_sent_pending_limit"></a>
          </dd>

          <dt><strong><span class="code">sent_pending_limit</span></strong></dt>
          <dd>
            <p>Sent pending limit (see the MGOriginatedPendingLimit
              and the MGCOriginatedPendingLimit of the megaco root package).
              This parameter specifies how many pending messages that can
              be sent (for a given received transaction request).
              When the limit is exceeded, the transaction is aborted
              (see <span class="bold_code"><a href="megaco_user.html#request_abort">handle_trans_request_abort</a></span>) and an error message 
              is sent to the other side. </p>
            <p>Note that this has no effect on the actual sending of
              pending transactions. This is either implicit (e.g. when 
              receiving a re-sent transaction request for a request which
              is being processed) or controlled by the pending_timer,
              see above. </p>
            <p>A positive integer or <span class="code">infinity</span>, 
              defaults to <span class="code">infinity</span>.</p>

            <a name="ci_recv_pending_limit"></a>
          </dd>

          <dt><strong><span class="code">recv_pending_limit</span></strong></dt>
          <dd>
            <p>Receive pending limit (see the MGOriginatedPendingLimit
              and the MGCOriginatedPendingLimit of the megaco root package).
              This parameter specifies how many pending messages that can
              be received (for a sent transaction request).
              When the limit is exceeded, the transaction is considered
              lost, and an error returned to the user (through the call-back
              function <strong>handle_trans_reply</strong>). </p>
            <p>A positive integer or <span class="code">infinity</span>, 
              defaults to <span class="code">infinity</span>.</p>

            <a name="ci_send_mod"></a>
          </dd>

          <dt><strong><span class="code">send_mod</span></strong></dt>
          <dd>
            <p>Send callback module which exports send_message/2. The
              function SendMod:send_message(SendHandle, Binary) is
              invoked when the bytes needs to be transmitted to
              the remote user. </p>
            <p>An <span class="code">atom</span>, defaults to <span class="code">megaco_tcp</span>.</p>

            <a name="ci_encoding_mod"></a>
          </dd>

          <dt><strong><span class="code">encoding_mod</span></strong></dt>
          <dd>
            <p>Encoding callback module which exports encode_message/2
              and decode_message/2. The function
              EncodingMod:encode_message(EncodingConfig, MegacoMessage)
              is invoked whenever a 'MegacoMessage' record needs to be
              translated into an Erlang binary. The function
              EncodingMod:decode_message(EncodingConfig, Binary) is
              invoked whenever an Erlang binary needs to be translated
              into a 'MegacoMessage' record. </p>
            <p>An <span class="code">atom</span>, 
              defaults to <span class="code">megaco_pretty_text_encoder</span>.</p>

            <a name="ci_encoding_confi"></a>
          </dd>

          <dt><strong><span class="code">encoding_config</span></strong></dt>
          <dd>
            <p>Encoding module config. </p>
            <p>A <span class="code">list</span>, defaults to [].</p>

            <a name="ci_protocol_version"></a>
          </dd>

          <dt><strong><span class="code">protocol_version</span></strong></dt>
          <dd>
            <p>Actual protocol version. </p>
            <p>An positive integer, Current default is 1.</p>
            <a name="ci_strict_version"></a>
          </dd>
          <dt><strong><span class="code">strict_version</span></strong></dt>
          <dd>
            <p>Strict version control, i.e. when a message is received,
              verify that the version is that which was negotiated. </p>
            <p>An <span class="code">boolean</span>, default is true.</p>
            <a name="ci_reply_data"></a>
          </dd>
          <dt><strong><span class="code">reply_data</span></strong></dt>
          <dd>
            <p>Default reply data. </p>
            <p>Any term, defaults to the atom <span class="code">undefined</span>.</p>

            <a name="ci_threaded"></a>
          </dd>

          <dt><strong><span class="code">threaded</span></strong></dt>
          <dd>
            <p>If a received message contains several transaction requests, 
              this option indicates whether the requests should be handled
              sequentially in the same process (<span class="code">false</span>), or if each 
              request should be handled by its own process (<span class="code">true</span>
              i.e. a separate process is spawned for each request). </p>
            <p>An <span class="code">boolean</span>, defaults to <span class="code">false</span>. </p>
            <a name="ci_resend_indication"></a>
          </dd>
          <dt><strong><span class="code">resend_indication</span></strong></dt>
          <dd>
            <p>This option indicates weather the transport module
              should be told if a message send is a resend or not. </p>
            <p>If <strong>false</strong>, megaco messages are sent using the
              <span class="bold_code"><a href="megaco_transport.html#send_message">send_message/2</a></span> 
              function. </p>
            <p>If <strong>true</strong>, megaco message <strong>re-sends</strong> are made using the
              <span class="bold_code"><a href="megaco_transport.html#resend_message">resend_message</a></span> 
              function. The initial message send is still done using the
              <span class="bold_code"><a href="megaco_transport.html#send_message">send_message</a></span> 
              function. </p>
            <p>The special value <strong>flag</strong> instead indicates that the 
              function 
              <span class="bold_code"><a href="megaco_transport.html#send_message">send_message/3</a></span> 
              shall be used. </p>
            <p>A <span class="code">resend_indication()</span>, 
              defaults to <span class="code">false</span>.</p>
            <a name="ci_segment_reply_ind"></a>
          </dd>

          <dt><strong><span class="code">segment_reply_ind</span></strong></dt>
          <dd>
            <p>This option specifies if the user shall be notified of received
              segment replies or not. </p>
            <p>See 
              <span class="bold_code"><a href="megaco_user.html#segment_reply">handle_segment_reply</a></span> 
              callback function for more information. </p>
            <p>A <span class="code">boolean</span>, 
              defaults to <span class="code">false</span>. </p>

            <a name="ci_segment_recv_timer"></a>
          </dd>

          <dt><strong><span class="code">segment_recv_timer</span></strong></dt>
          <dd>
            <p>This timer is started when the segment indicated by the
              <span class="code">segmentation complete token</span> (e.g. the last of the segment
              which makes up the reply) is received, but all 
              segments has not yet been received.</p>
            <p>When the timer finally expires, a "megaco segments not
              received" (459) error message is sent to the other side
              and the user is notified with a 
              <span class="code">segment timeout</span> <span class="code">UserReply</span> in either the
              <span class="bold_code"><a href="megaco_user.html#trans_reply">handle_trans_reply</a></span> 
              callback function or 
              the return value of the 
              <span class="bold_code"><a href="megaco.html#call">call</a></span> function. </p>
            <p>A Megaco Timer (see explanation above),
              defaults to <span class="code">10000</span>. </p>

            <a name="ci_segment_send"></a>
          </dd>

          <dt><strong><span class="code">segment_send</span></strong></dt>
          <dd>
            <p>Shall outgoing messages be segmented or not: </p>
            <dl>
              <dt><strong><span class="code">none</span></strong></dt>
              <dd>
                <p>Do not segment outgoing reply messages. This is useful when
                  either it is known that messages are never to large or
                  that the transport protocol can handle such things
                  on its own (e.g. TCP or SCTP).</p>
              </dd>
              <dt><strong><span class="code">integer() &gt; 0</span></strong></dt>
              <dd>
                <p>Outgoing reply messages will be segmented as needed 
                  (see <span class="code">max_pdu_size</span> below). This value, K, indicate 
                  the outstanding window, i.e. how many segments can be 
                  outstanding (not acknowledged) at any given time. </p>
              </dd>
              <dt><strong><span class="code">infinity</span></strong></dt>
              <dd>
                <p>Outgoing reply messages will be segmented as needed 
                  (see <span class="code">max_pdu_size</span> below). Segment messages 
                  are sent all at once (i.e. no acknowledgement awaited 
                  before sending the next segment). </p>
              </dd>
            </dl>
            <p>Defaults to <span class="code">none</span>. </p>
            <a name="ci_max_pdu_size"></a>
          </dd>

          <dt><strong><span class="code">max_pdu_size</span></strong></dt>
          <dd>
            <p>Max message size. If the encoded message (PDU) exceeds 
              this size, the message should be segmented, and then 
              encoded. </p>
            <p>A positive integer or <span class="code">infinity</span>,
              defaults to <span class="code">infinity</span>. </p>
          </dd>
        </dl>

        <a name="update_conn_info"></a>
      </p></div>

    <p><a name="update_conn_info-3"><span class="bold_code">update_conn_info(ConnHandle, Item, Value) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConnHandle = #megaco_conn_handle{}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Item       = conn_info_item()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Value      = conn_info_value()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason     = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Update information about an active connection</p>
        <p>Requires that the connection is activated. See
          megaco:conn_info/2 about which items and values that are
          valid.</p>

        <a name="system_info"></a>
      </p></div>

    <p><a name="system_info-0"><span class="bold_code">system_info() -&gt; [{Item, Value}] | exit(Reason)</span></a><br><a name="system_info-1"><span class="bold_code">system_info(Item) -&gt; Value | exit(Reason)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Item = system_info_item()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Lookup system information</p>
        <p>The following items are valid:</p>
        <dl>
          <dt><strong><span class="code">text_config</span></strong></dt>
          <dd>
            <p>The text encoding config.</p>
          </dd>
          <dt><strong><span class="code">connections</span></strong></dt>
          <dd>
            <p>Lists all active connections. Returns a list of
              megaco_conn_handle records.</p>
          </dd>
          <dt><strong><span class="code">users</span></strong></dt>
          <dd>
            <p>Lists all active users. Returns a list of
              megaco_mid()'s.</p>
          </dd>
          <dt><strong><span class="code">n_active_requests</span></strong></dt>
          <dd>
            <p>Returns an integer representing the number of requests
              that has originated from this Erlang node and still are
              active (and therefore consumes system resources).</p>
          </dd>
          <dt><strong><span class="code">n_active_replies</span></strong></dt>
          <dd>
            <p>Returns an integer representing the number of replies
              that has originated from this Erlang node and still are
              active (and therefore consumes system resources).</p>
          </dd>
          <dt><strong><span class="code">n_active_connections</span></strong></dt>
          <dd>
            <p>Returns an integer representing the number of active
              connections.</p>
          </dd>
        </dl>

        <a name="info"></a>
      </p></div>

    <p><a name="info-0"><span class="bold_code">info() -&gt; Info</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Info = [{Key, Value}]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function produces a list of information about the megaco 
          application. Such as users and their config, connections 
          and their config, statistics and so on.</p>

        <p>This information can be produced by the functions 
          <span class="bold_code"><a href="#user_info">user_info</a></span>, 
          <span class="bold_code"><a href="#conn_info">conn_info</a></span>, 
          <span class="bold_code"><a href="#system_info">system_info</a></span> and 
          <span class="bold_code"><a href="#get_stats">get_stats</a></span> 
          but this is a simple way to get it all at once.</p>

        <a name="connect"></a> 
      </p></div>

    <p><a name="connect-4"><span class="bold_code">connect(ReceiveHandle, RemoteMid, SendHandle, ControlPid) -&gt; {ok, ConnHandle} | {error, Reason}</span></a><br><a name="connect-5"><span class="bold_code">connect(ReceiveHandle, RemoteMid, SendHandle, ControlPid, Extra) -&gt; {ok, ConnHandle} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ReceiveHandle = #megaco_receive_handle{}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">RemoteMid     = preliminary_mid | megaco_mid()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">SendHandle    = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ControlPid    = pid()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ConnHandle    = #megaco_conn_handle{}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason        = connect_reason() | handle_connect_reason() | term()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">connect_reason() = {no_such_user, LocalMid} | {already_connected, ConnHandle} | term()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">handle_connect_error() = {connection_refused, ConnData, ErrorInfo} | term()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">LocalMid      = megaco_mid()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">ConnData      = term()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">ErrorInfo     = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Extra         = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Establish a "virtual" connection</p>
        <p>Activates a connection to a remote user. When this is done
          the connection can be used to send messages (with
          SendMod:send_message/2). The ControlPid is the identifier
          of a process that controls the connection. That process will
          be supervised and if it dies, this will be detected and the
          UserMod:handle_disconnect/2 callback function will be
          invoked. See the megaco_user module for more info about the
          callback arguments. The connection may also explicitly be
          deactivated by invoking megaco:disconnect/2.</p>
        <p>The ControlPid may be the identity of a process residing on
          another Erlang node. This is useful when you want to
          distribute a user over several Erlang nodes. In such a case
          one of the nodes has the physical connection. When a user
          residing on one of the other nodes needs to send a request
          (with megaco:call/3 or megaco:cast/3), the message will
          encoded on the originating Erlang node, and then be
          forwarded to the node with the physical connection. When the
          reply arrives, it will be forwarded back to the originator.
          The distributed connection may explicitly be deactivated by
          a local call to megaco:disconnect/2 or implicitly when
          the physical connection is deactivated (with megaco:disconnect/2,
          killing the controlling process, halting the other node, ...).</p>
        <p>The call of this function will trigger the callback
          function UserMod:handle_connect/2 to be invoked. See the
          megaco_user module for more info about the callback
          arguments.</p>
        <p>A connection may be established in several ways:</p>
        <dl>
          <dt><strong><span class="code">provisioned MID</span></strong></dt>
          <dd>
            <p>The MG may explicitly invoke megaco:connect/4 and use
              a provisioned MID of the MGC as the RemoteMid.</p>
          </dd>
          <dt><strong><span class="code">upgrade preliminary MID</span></strong></dt>
          <dd>
            <p>The MG may explicitly invoke megaco:connect/4 with the
              atom 'preliminary_mid' as a temporary MID of the MGC,
              send an intial message, the Service Change Request, to
              the MGC and then wait for an initial message, the
              Service Change Reply. When the reply arrives, the Megaco
              application will pick the MID of the MGC from the
              message header and automatically upgrade the connection
              to be a "normal" connection. By using this method of
              establishing the connection, the callback function
              UserMod:handle_connect/2 to be invoked twice. First with
              a ConnHandle with the remote_mid-field set to
              preliminary_mid, and then when the connection upgrade is
              done with the remote_mid-field set to the actual MID of
              the MGC.</p>
          </dd>
          <dt><strong><span class="code">automatic</span></strong></dt>
          <dd>
            <p>When the MGC receives its first message, the Service
              Change Request, the Megaco application will
              automatically establish the connection by using the MG
              MID found in the message header as remote mid.</p>
          </dd>
          <dt><strong><span class="code">distributed</span></strong></dt>
          <dd>
            <p>When a user (MG/MGC) is distributed over several nodes,
              it is required that the node hosting the connection
              already has activated the connection and that it is
              in the "normal" state. The RemoteMid must be a real
              Megaco MID and not a preliminary_mid.</p>
          </dd>
        </dl>
        <p>An initial megaco_receive_handle record may be obtained
          with megaco:user_info(UserMid, receive_handle)</p>
        <p>The send handle is provided by the preferred transport
          module, e.g. megaco_tcp, megaco_udp. Read the documentation
          about each transport module about the details.</p>

	<p>The connect is done in two steps: first an internal 
          <span class="code">connection setup</span> and then by calling the user 
          <span class="bold_code"><a href="megaco_user.html#connect">handle_connect</a></span> 
          callback function. The first step could result in 
          an error with <span class="code">Reason = connect_reason()</span> and the second 
          an error with <span class="code">Reason = handle_connect_reason()</span>: </p>

	<dl>
	  <dt><strong><span class="code">connect_reason()</span></strong></dt>
	  <dd>
	    <p>An error with this reason is generated by the 
              megaco application itself.</p>
	  </dd>

	  <dt><strong><span class="code">handle_connect_reason()</span></strong></dt>
	  <dd>
	    <p>An error with this reason is caused by the user 
              <span class="bold_code"><a href="megaco_user.html#connect">handle_connect</a></span> 
              callback function either returning an error 
              or an invalid value.</p>
	  </dd>

	</dl>

        <p><span class="code">Extra</span> can be any <span class="code">term()</span> 
          except the atom <span class="code">ignore_extra</span>. 
          It is passed (back) to the user via the callback function 
          <span class="bold_code"><a href="megaco_user.html#connect">handle_connect/3</a></span>. </p>

        <a name="disconnect"></a> 
      </p></div>

    <p><a name="disconnect-2"><span class="bold_code">disconnect(ConnHandle, DiscoReason) -&gt; ok | {error, ErrReason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConnHandle  = conn_handle()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">DiscoReason =  term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ErrReason   =  term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Tear down a "virtual" connection</p>
        <p>Causes the UserMod:handle_disconnect/2 callback function to
          be invoked. See the megaco_user module for more info about
          the callback arguments.</p>

        <a name="call"></a> 
      </p></div>

    <p><a name="call-3"><span class="bold_code">call(ConnHandle, Actions, Options) -&gt; {ProtocolVersion, UserReply}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConnHandle     = conn_handle()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Actions        = action_reqs() | [action_reqs()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">action_reqs()  = binary() | [action_request()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Options        = [send_option()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">send_option()  = {request_timer, megaco_timer()} | {long_request_timer, megaco_timer()} | {send_handle, term()} | {protocol_version, integer()} | {call_proxy_gc_timeout, call_proxy_gc_timeout()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ProtocolVersion = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">UserReply       = user_reply() | [user_reply()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">user_reply()    = success() | failure()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">success()       = {ok, result()} | {ok, result(), extra()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">result()        = message_result() | segment_result()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">message_result() = action_reps()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">segment_result() = segments_ok()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">failure()        = {error, reason()} | {error, reason(), extra()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">reason()         = message_reason() | segment_reason() | user_cancel_reason() | send_reason() | other_reason()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">message_reason() = error_desc()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">segment_reason() = {segment, segments_ok(), segments_err()} | {segment_timeout, missing_segments(), segments_ok(), segments_err()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">segments_ok()   = [segment_ok()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">segment_ok()    = {segment_no(), action_reps()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">segments_err()  = [segment_err()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">segment_err()   = {segment_no(), error_desc()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">missing_segments() = [segment_no()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">user_cancel_reason() = {user_cancel, reason_for_user_cancel()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">reason_for_user_cancel() = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">send_reason() = send_cancelled_reason() | send_failed_reason()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">send_cancelled_reason() = {send_message_cancelled, reason_for_send_cancel()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">reason_for_send_cancel() = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">send_failed_reason()    = {send_message_failed, reason_for_send_failure()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">reason_for_send_failure() = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">other_reason()   = {wrong_mid, WrongMid, RightMid, TR} | term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">WrongMid = mid()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">RightMid = mid()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">TR = transaction_reply()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">action_reps()    = [action_reply()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">call_proxy_gc_timeout() = integer() &gt;= 0</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">extra()          = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Sends one or more transaction request(s) and waits for the 
          reply.</p>
        <p>When sending one transaction in a message, <span class="code">Actions</span> should be 
          <span class="code">action_reqs()</span> (<span class="code">UserReply</span> will then be 
          <span class="code">user_reply()</span>). When sending several transactions in a message,
          <span class="code">Actions</span> should be <span class="code">[action_reqs()]</span> (<span class="code">UserReply</span> 
          will then be <span class="code">[user_reply()]</span>). Each element of the list is 
          part of one transaction.</p>
        <p>For some of <strong>our</strong> codecs (not binary), it is also possible 
          to pre-encode the actions, in which case <span class="code">Actions</span> will be 
          either a <span class="code">binary()</span> or <span class="code">[binary()]</span>.</p>
        <p>The function returns when the reply arrives, when the
          request timer eventually times out or when the outstanding
          requests are explicitly cancelled.</p>
        <p>The default values of the send options are obtained by
          <span class="code">megaco:conn_info(ConnHandle, Item)</span>. But the send options 
          above, may explicitly be overridden.</p>
        <p>The <span class="code">ProtocolVersion</span> version is the version actually encoded
          in the reply message.</p>
        <p>At <span class="code">success()</span>, the <span class="code">UserReply</span> contains a list of 
          'ActionReply' records possibly containing error indications.</p>
        <p>A <span class="code">message_error()</span>, indicates that the remote user has
          replied with an explicit transactionError.</p>
        <p>A <span class="code">user_cancel_error()</span>, indicates that the request has been
          canceled by the user. <span class="code">reason_for_user_cancel()</span> is the reason
          given in the call to the <span class="bold_code"><a href="#cancel">cancel</a></span>
          function. </p>
        <p>A <span class="code">send_error()</span>, indicates that the send function of the 
          megaco transport callback module failed to send the request. 
          There are two separate cases: <span class="code">send_cancelled_reason()</span> and 
          <span class="code">send_failed_reason()</span>. 
          The first is the result of the send function returning 
          <span class="code">{cancel, Reason}</span> and the second is some other kind of 
          erroneous return value. See the 
          <span class="bold_code"><a href="megaco_transport.html#send_message">send_message</a></span>
          function for more info. </p>
        <p>An <span class="code">other_error()</span>, indicates some other error such as 
          timeout.</p>

        <p>For more info about the <span class="code">extra()</span> part of the 
          result, see the 
          <span class="bold_code"><a href="megaco_user.html#extra_argument">note</a></span>
          in the user callback module documentation. </p>



        <a name="cast"></a>
      </p></div>

    <p><a name="cast-3"><span class="bold_code">cast(ConnHandle, Actions, Options) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConnHandle     = conn_handle()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Actions        = action_reqs() | [action_reqs()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">action_reqs()  = binary() | [action_request()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Options        = [send_option()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">send_option()  = {request_keep_alive_timeout, request_keep_alive_timeout()} | {request_timer, megaco_timer()} | {long_request_timer, megaco_timer()} | {send_handle, term()} | {reply_data, reply_data()} | {protocol_version, integer()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">request_keep_alive_timeout() = plain | integer() &gt;= 0</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason         =  term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Sends one or more transaction request(s) but does NOT wait for a reply</p>
        <p>When sending one transaction in a message, <span class="code">Actions</span> should be 
          <span class="code">action_reqs()</span>. When sending several transactions in a message,
          <span class="code">Actions</span> should be <span class="code">[action_reqs()]</span>. Each element of the 
          list is part of one transaction.</p>
        <p>For some of <strong>our</strong> codecs (not binary), it is also possible 
          to pre-encode the actions, in which case <span class="code">Actions</span> will be 
          either a <span class="code">binary()</span> or <span class="code">[binary()]</span>.</p>
        <p>The default values of the send options are obtained by
          megaco:conn_info(ConnHandle, Item). But the send options above,
          may explicitly be overridden.</p>
        <p>The ProtocolVersion version is the version actually encoded
          in the reply message.</p>
        <p>The callback function UserMod:handle_trans_reply/4 is invoked
          when the reply arrives, when the request timer eventually
          times out or when the outstanding requests are explicitly
          cancelled. See the megaco_user module for more info about
          the callback arguments.</p>
        <p>Given as UserData argument to UserMod:handle_trans_reply/4.</p>

        <a name="encode_actions"></a>
      </p></div>

    <p><a name="encode_actions-3"><span class="bold_code">encode_actions(ConnHandle, Actions, Options) -&gt; {ok, BinOrBins} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConnHandle     = conn_handle()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Actions        = action_reqs() | [action_reqs()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">action_reqs()  = [#'ActionRequest'{}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Options        = [send_option()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">send_option()  = {request_timer, megaco_timer()} | {long_request_timer, megaco_timer()} | {send_handle, term()} | {protocol_version, integer()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">BinOrBins      = binary() | [binary()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason         = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Encodes lists of action requests for one or more transaction 
          request(s).</p>
        <p>When encoding action requests for one transaction, 
          <span class="code">Actions</span> should be <span class="code">action_reqs()</span>. 
          When encoding action requests for several transactions,
          <span class="code">Actions</span> should be <span class="code">[action_reqs()]</span>. Each element 
          of the list is part of one transaction.</p>

        <a name="token_tag2string"></a>
      </p></div>

    <p><a name="token_tag2string-1"><span class="bold_code">token_tag2string(Tag) -&gt; Result</span></a><br><a name="token_tag2string-2"><span class="bold_code">token_tag2string(Tag, EncoderMod) -&gt; Result</span></a><br><a name="token_tag2string-3"><span class="bold_code">token_tag2string(Tag, EncoderMod, Version) -&gt; Result</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Tag = atom()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">EncoderMod = pretty | compact | encoder_module()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">encoder_module() = megaco_pretty_text_encoder | megaco_compact_text_encoder | atom()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Version = int_version() | atom_version()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int_version() = 1 | 2 | 3</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">atom_version() = v1 | v2 | v3 | prev3c | prev3b</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Result = string() | {error, Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Convert a token tag to a string</p>
        <p>If no encoder module is given, the default is used 
          (which is pretty).</p>
        <p>If no or an unknown version is given, 
          the <strong>best</strong> version is used (which is v3).</p>
        <p>If no match is found for <span class="code">Tag</span>, <span class="code">Result</span> will be the 
          empty string (<span class="code">[]</span>).</p>

        <a name="cancel"></a>
      </p></div>

    <p><a name="cancel-2"><span class="bold_code">cancel(ConnHandle, CancelReason) -&gt; ok | {error, ErrReason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConnHandle   = conn_handle()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">CancelReason =  term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ErrReason    =  term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Cancel all outstanding messages for this connection</p>
        <p>This causes outstanding megaco:call/3 requests to return.
          The callback functions UserMod:handle_reply/4 and
          UserMod:handle_trans_ack/4 are also invoked where it
          applies.  See the megaco_user module for more info about the
          callback arguments.</p>

        <a name="process_received_message"></a>
      </p></div>

    <p><a name="process_received_message-4"><span class="bold_code">process_received_message(ReceiveHandle, ControlPid, SendHandle, BinMsg) -&gt; ok</span></a><br><a name="process_received_message-5"><span class="bold_code">process_received_message(ReceiveHandle, ControlPid, SendHandle, BinMsg, Extra) -&gt; ok</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ReceiveHandle = #megaco_receive_handle{}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ControlPid    = pid()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">SendHandle    = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">BinMsg        = binary()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Extra         = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Process a received message</p>

        <p>This function is intended to be invoked by some
          transport modules when get an incoming message. Which
          transport that actually is used is up to the user to
          choose.</p>

        <p>The message is delivered as an Erlang binary and is decoded
          by the encoding module stated in the receive handle together
          with its encoding config (also in the receive
          handle). Depending of the outcome of the decoding various
          callback functions will be invoked. See megaco_user for more
          info about the callback arguments.</p>

        <p>The argument <span class="code">Extra</span> is just an opaque data structure passed to the user 
          via the callback functions in the 
          <span class="bold_code"><a href="megaco_user.html">user callback module</a></span>. 
          Note however that if <span class="code">Extra</span> has the value 
          <span class="code">extra_undefined</span> the argument will be ignored (same as if 
          <span class="code">process_received_message/4</span> had been called). 
          See the documentation for the behaviour of the callback module,
          <span class="bold_code"><a href="megaco_user.html">megaco_user</a></span>, for more info. </p> 
        <p>Note that all processing is done in the context of the calling 
          process. A transport module could call this function via one of the
          <span class="code">spawn</span> functions (e.g. <span class="code">spawn_opt</span>). See also 
          <span class="code">receive_message/4,5</span>.
          </p>
        <p>If the message cannot be decoded the following callback
          function will be invoked:</p>
        <ul>
          <li>
            <p>UserMod:handle_syntax_error/3</p>
          </li>
        </ul>
        <p>If the decoded message instead of transactions contains a
          message error, the following callback function will be
          invoked:</p>
        <ul>
          <li>
            <p>UserMod:handle_message_error/3</p>
          </li>
        </ul>
        <p>If the decoded message happens to be received before the
          connection is established, a new "virtual" connection is
          established. This is typically the case for the Media
          Gateway Controller (MGC) upon the first Service Change.
          When this occurs the following callback function will be
          invoked:</p>
        <ul>
          <li>
            <p>UserMod:handle_connect/2</p>
          </li>
        </ul>
        <p>For each transaction request in the decoded message the
          following callback function will be invoked:</p>
        <ul>
          <li>
            <p>UserMod:handle_trans_request/3</p>
          </li>
        </ul>
        <p>For each transaction reply in the decoded message the reply
          is returned to the user. Either the originating function
          megaco:call/3 will return.  Or in case the originating
          function was megaco:case/3 the following callback function
          will be invoked:</p>
        <ul>
          <li>
            <p>UserMod:handle_trans_reply/4</p>
          </li>
        </ul>
        <p>When a transaction acknowledgement is received it is
          possible that user has decided not to bother about the
          acknowledgement. But in case the return value from
          UserMod:handle_trans_request/3 indicates that the
          acknowledgement is important the following callback function
          will be invoked:</p>
        <ul>
          <li>
            <p>UserMod:handle_trans_ack/4</p>
          </li>
        </ul>
        <p>See the megaco_user module for more info about the callback
          arguments.</p>

        <a name="receive_message"></a>
      </p></div>

    <p><a name="receive_message-4"><span class="bold_code">receive_message(ReceiveHandle, ControlPid, SendHandle, BinMsg) -&gt; ok</span></a><br><a name="receive_message-5"><span class="bold_code">receive_message(ReceiveHandle, ControlPid, SendHandle, BinMsg, Extra) -&gt; ok</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ReceiveHandle = #megaco_receive_handle{}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ControlPid    = pid()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">SendHandle    = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">BinMsg        = binary()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Extra         = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Process a received message</p>
        <p>This is a callback function intended to be invoked by some
          transport modules when get an incoming message. Which
          transport that actually is used is up to the user to
          choose.</p>
        <p>In principle, this function calls the 
          <span class="code">process_received_message/4</span> function via a <span class="code">spawn</span> to
          perform the actual processing.</p>
        <p>For further information see the 
          <span class="bold_code"><a href="#process_received_message">process_received_message/4</a></span> 
          function.</p>

        <a name="parse_digit_map"></a>
      </p></div>

    <p><a name="parse_digit_map-1"><span class="bold_code">parse_digit_map(DigitMapBody) -&gt; {ok, ParsedDigitMap} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">DigitMapBody       = string()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ParsedDigitMap     = parsed_digit_map()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">parsed_digit_map() = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason             = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Parses a digit map body</p>
        <p>Parses a digit map body, represented as a list of
          characters, into a list of state transitions suited to
          be evaluated by megaco:eval_digit_map/1,2.</p>

        <a name="eval_digit_map"></a>
      </p></div>

    <p><a name="eval_digit_map-1"><span class="bold_code">eval_digit_map(DigitMap) -&gt; {ok, MatchResult} | {error, Reason}</span></a><br><a name="eval_digit_map-2"><span class="bold_code">eval_digit_map(DigitMap, Timers) -&gt; {ok, MatchResult} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">DigitMap           = #'DigitMapValue'{} | parsed_digit_map()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">parsed_digit_map() = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ParsedDigitMap     = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Timers             = ignore() | reject()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ignore()           = ignore | {ignore, digit_map_value()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">reject()           = reject | {reject, digit_map_value()} | digit_map_value()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">MatchResult        = {Kind, Letters} | {Kind, Letters, Extra}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Kind               = kind()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">kind()             = full | unambiguous</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Letters            = [letter()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">letter()           = $0..$9 | $a .. $k</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Extra              = letter()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason             = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Collect digit map letters according to the digit map.</p>
        <p>When evaluating a digit map, a state machine waits for
          timeouts and letters reported by
          megaco:report_digit_event/2. The length of the various
          timeouts are defined in the digit_map_value() record.</p>
        <p>When a complete sequence of valid events has been received,
          the result is returned as a list of letters.</p>
        <p>There are two options for handling syntax errors (that is
          when an unexpected event is received when the digit map
          evaluator is expecting some other event). The unexpected
          events may either be ignored or rejected. The latter means
          that the evaluation is aborted and an error is returned. </p>

        <a name="report_digit_event"></a>
      </p></div>

    <p><a name="report_digit_event-2"><span class="bold_code">report_digit_event(DigitMapEvalPid, Events) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">DigitMapEvalPid = pid()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Events          = Event | [Event]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Event           = letter() | pause() | cancel()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">letter()        = $0..$9 | $a .. $k | $A .. $K</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">pause()         = one_second() | ten_seconds()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">one_second()    = $s | $S</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ten_seconds()   = $l | $L</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">cancel()        = $z | $Z | cancel</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason          = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Send one or more events to the event collector process.</p>
        <p>Send one or more events to a process that is evaluating a
          digit map, that is a process that is executing
          megaco:eval_digit_map/1,2.</p>
        <p>Note that the events <span class="code">$s | $S</span>, <span class="code">l | $L</span> and
          <span class="code">$z | $Z</span> has nothing to do with the timers using
          the same characters.</p>

        <a name="test_digit_event"></a>
      </p></div>

    <p><a name="test_digit_event-2"><span class="bold_code">test_digit_event(DigitMap, Events) -&gt; {ok, Kind, Letters} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">DigitMap           = #'DigitMapValue'{} | parsed_digit_map()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">parsed_digit_map() = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ParsedDigitMap     = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Timers             = ignore() | reject()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ignore()           = ignore | {ignore, digit_map_value()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">reject()           = reject | {reject, digit_map_value()} | digit_map_value()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">DigitMapEvalPid    = pid()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Events             = Event | [Event]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Event              = letter() | pause() | cancel()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Kind               = kind()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">kind()             = full | unambiguous</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Letters            = [letter()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">letter()           = $0..$9 | $a .. $k | $A .. $K</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">pause()            = one_second() | ten_seconds()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">one_second()       = $s | $S</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ten_seconds()      = $l | $L</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">cancel    ()       = $z | $Z | cancel</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason             = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Feed digit map collector with events and return the result</p>
        <p>This function starts the evaluation of a digit map with
          megaco:eval_digit_map/1 and sends a sequence of events to it
          megaco:report_digit_event/2 in order to simplify testing of
          digit maps.</p>

        <a name="encode_sdp"></a>
      </p></div>

    <p><a name="encode_sdp-1"><span class="bold_code">encode_sdp(SDP) -&gt; {ok, PP} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">SDP = sdp_property_parm() | sdp_property_group() | sdp_property_groups() | asn1_NOVALUE</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">PP = property_parm() | property_group() | property_groups() | asn1_NOVALUE</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Encode (generate) an SDP construct.</p>
        <p>If a <span class="code">property_parm()</span> is found as part of the input
          (<span class="code">SDP</span>) then it is left unchanged.</p>
        <p>This function performs the following transformation:</p>
        <ul>
          <li>
            <p>sdp()                 -&gt; property_parm()</p>
          </li>
          <li>
            <p>sdp_property_group()  -&gt; property_group()</p>
          </li>
          <li>
            <p>sdp_property_groups() -&gt; property_groups()</p>
          </li>
        </ul>

        <a name="decode_sdp"></a>
      </p></div>

    <p><a name="decode_sdp-1"><span class="bold_code">decode_sdp(PP) -&gt; {ok, SDP} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">PP = property_parm() | property_group() | property_groups() | asn1_NOVALUE</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">SDP = sdp() | decode_sdp_property_group() | decode_sdp_property_groups() | asn1_NOVALUE</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">decode_sdp() = sdp() | {property_parm(), DecodeError}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">decode_sdp_property_group() = [decode_sdp()]</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">decode_sdp_property_groups() = [decode_sdp_property_group()]</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">DecodeError = term()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Decode (parse) a property parameter construct.</p>
        <p>When decoding <span class="code">property_group()</span> or 
          <span class="code">property_groups()</span>, 
          those property parameter constructs that cannot be decoded
          (either because of decode error or because they are unknown),
          will be returned as a two-tuple. The first element of which 
          will be the (undecoded) property parameter and the other the 
          actual reason. 
          This means that the caller of this function has to expect not 
          only sdp-records, but also this two-tuple construct.</p>
        <p>This function performs the following transformation:</p>
        <ul>
          <li>
            <p>property_parm()   -&gt; sdp()</p>
          </li>
          <li>
            <p>property_group()  -&gt; sdp_property_group()</p>
          </li>
          <li>
            <p>property_groups() -&gt; sdp_property_groups()</p>
          </li>
        </ul>

	<a name="get_sdp_record_from_PG"></a>
      </p></div>

    <p><a name="get_sdp_record_from_PropertGroup-2"><span class="bold_code">get_sdp_record_from_PropertGroup(Type, PG) -&gt; [sdp()]</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Type = v | c | m | o | a | b | t | r | z | k | s | i | u | e | p</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">PG = sdp_property_group()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Retreive all the sdp records of type <span class="code">Type</span> from the
          property group <span class="code">PG</span>.</p>

        <a name="versions1"></a>
        <a name="versions2"></a>
      </p></div>

    <p><a name="versions1-0"><span class="bold_code">versions1() -&gt; {ok, VersionInfo} | {error, Reason}</span></a><br><a name="versions2-0"><span class="bold_code">versions2() -&gt; {ok, Info} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">VersionInfo = [version_info()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">version_info() = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Utility functions used to retrieve some system and
          application info.</p>
        <p>The difference between the two functions is in how they get
          the modules to check. <span class="code">versions1</span> uses the 
          app-file and <span class="code">versions2</span> uses the function 
          <span class="code">application:get_key</span>.</p>

        <a name="print_version_info"></a>
      </p></div>

    <p><a name="print_version_info-0"><span class="bold_code">print_version_info() -&gt; void()</span></a><br><a name="print_version_info-1"><span class="bold_code">print_version_info(VersionInfo) -&gt; void()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">VersionInfo = [version_info()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">version_info() = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Utility function to produce a formated printout of the versions 
          info generated by the <span class="code">versions1</span> and <span class="code">versions2</span> 
          functions.</p>
        <p>The function print_version_info/0 uses the result of function
          version1/0 as <span class="code">VersionInfo</span>.</p>
        <p>Example: </p>
        <div class="example"><pre>
           {ok, V} = megaco:versions1(), megaco:format_versions(V). 
        </pre></div>
        <a name="enable_trace"></a>
      </p></div>

    <p><a name="enable_trace-2"><span class="bold_code">enable_trace(Level, Destination) -&gt; void()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Level       = max | min | 0 &lt;= integer() &lt;= 100</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Destination = File | Port | HandlerSpec | io</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">File        = string()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Port        = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">HandleSpec  = {HandlerFun, Data}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">HandleFun   = fun() (two arguments)</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Data        = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function is used to start megaco tracing at a given 
          <span class="code">Level</span> and direct result to the given <span class="code">Destination</span>.</p>
        <p>It starts a tracer server and then sets the proper match spec 
          (according to <span class="code">Level</span>).</p>
        <p>In the case when <span class="code">Destination</span> is <span class="code">File</span>, the printable 
          megaco trace events will be printed to the file <span class="code">File</span> using
          plain <span class="code">io:format/2</span>. </p>
        <p>In the case when <span class="code">Destination</span> is <span class="code">io</span>, the printable 
          megaco trace events will be printed on stdout using plain 
          <span class="code">io:format/2</span>. </p>
        <p>See <span class="code">dbg</span> for further information.</p>
        <a name="disable_trace"></a>
      </p></div>

    <p><a name="disable_trace-0"><span class="bold_code">disable_trace() -&gt; void()</span></a><br></p>
<div class="REFBODY"><p>
        <p>This function is used to stop megaco tracing.</p>
        <a name="set_trace"></a>
      </p></div>
    <p><a name="set_trace-1"><span class="bold_code">set_trace(Level) -&gt; void()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Level = max | min | 0 &lt;= integer() &lt;= 100</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function is used to change the megaco trace level.</p>
        <p>It is assumed that tracing has already been enabled (see 
          <span class="code">enable_trace</span> above).</p>

        <a name="stats"></a>
        <a name="get_stats"></a>
      </p></div>

    <p><a name="get_stats-0"><span class="bold_code">get_stats() -&gt; {ok, TotalStats} | {error, Reason}</span></a><br><a name="get_stats-1"><span class="bold_code">get_stats(GlobalCounter) -&gt; {ok, CounterStats} | {error, Reason}</span></a><br><a name="get_stats-1"><span class="bold_code">get_stats(ConnHandle) -&gt; {ok, ConnHandleStats} | {error, Reason}</span></a><br><a name="get_stats-2"><span class="bold_code">get_stats(ConnHandle, Counter) -&gt; {ok, integer()} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">TotalStats = [total_stats()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">total_stats() = {conn_handle(), [stats()]} | {global_counter(), integer()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">GlobalCounter = global_counter()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">GlobalCounterStats = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ConnHandle = conn_handle()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ConnHandleStats = [stats()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">stats() = {counter(), integer()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Counter = counter()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">counter() = medGwyGatewayNumTimerRecovery |  medGwyGatewayNumErrors</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">global_counter() = medGwyGatewayNumErrors</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Retreive the (SNMP) statistic counters maintained by the 
          megaco application. The global
          counters handle events that cannot be attributed to 
          a single connection (e.g. protocol errors that occur 
          before the connection has been properly setup).</p>
        <a name="reset_stats"></a>
      </p></div>

    <p><a name="reset_stats-0"><span class="bold_code">reset_stats() -&gt; void()</span></a><br><a name="reset_stats-1"><span class="bold_code">reset_stats(ConnHandle) -&gt; void()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConnHandle = conn_handle()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Reset all related (SNMP) statistics counters.</p>
        <a name="test_request"></a>
      </p></div>

    <p><a name="test_request-5"><span class="bold_code">test_request(ConnHandle, Version, EncodingMod, EncodingConfig, Actions) -&gt; {MegaMsg, EncodeRes}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConnHandle     = conn_handle()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Version        = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">EncodingMod    = atom()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">EncodingConfig = Encoding configuration</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Actions        = A list</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">MegaMsg        = #'MegacoMessage'{}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">EncodeRes      = {ok, Bin} | {error, Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Bin            = binary()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason         = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Tests if the Actions argument is correctly composed.</p>
        <p>This function is only intended for testing purposes. It's
          supposed to have a same kind of interface as the <span class="bold_code"><a href="#call">call</a></span> or <span class="bold_code"><a href="#cast">cast</a></span> functions (with the additions
          of the <span class="code">EncodingMod</span> and <span class="code">EncodingConfig</span>
          arguments). It composes a complete megaco message end
          attempts to encode it. The return value, will be a tuple of
          the composed megaco message and the encode result. </p>

        <a name="test_reply"></a>
      </p></div>

    <p><a name="test_reply-5"><span class="bold_code">test_reply(ConnHandle, Version, EncodingMod, EncodingConfig, Reply) -&gt; {MegaMsg, EncodeRes}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConnHandle     = conn_handle()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Version        = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">EncodingMod    = atom()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">EncodingConfig = A list</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reply          = actual_reply()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">MegaMsg        = #'MegacoMessage'{}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">EncodeRes      = {ok, Bin} | {error, Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Bin            = binary()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason         = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Tests if the Reply argument is correctly composed.</p>
        <p>This function is only intended for testing purposes. It's
          supposed to test the <span class="code">actual_reply()</span> return value of
          the callback functions 
          <span class="bold_code"><a href="megaco_user.html#trans_request">handle_trans_request</a></span>
          and 
          <span class="bold_code"><a href="megaco_user.html#trans_long_request">handle_trans_long_request</a></span>
          functions (with the additions of the <span class="code">EncodingMod</span> and
          <span class="code">EncodingConfig</span> arguments). It composes a complete
          megaco message end attempts to encode it. The return value,
          will be a tuple of the composed megaco message and the
          encode result.</p>
      </p></div>
  

</div>
<div class="footer">
<hr>
<p>Copyright  2000-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
