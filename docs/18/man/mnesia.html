<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- mnesia</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/mnesia/users_guide.html">User's Guide</a><br><a href="../apps/mnesia/index.html">Reference Manual</a><br><a href="../apps/mnesia/release_notes.html">Release Notes</a><br><a href="../apps/mnesia/mnesia.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Mnesia</strong><br><strong>Reference Manual</strong><br><small>Version 4.13.3</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li id="loadscrollpos" title="mnesia " expanded="true">mnesia<ul>
<li><a href="mnesia.html">
                  Top of manual page
                </a></li>
<li title="abort-1"><a href="mnesia.html#abort-1">abort/1</a></li>
<li title="activate_checkpoint-1"><a href="mnesia.html#activate_checkpoint-1">activate_checkpoint/1</a></li>
<li title="activity-2"><a href="mnesia.html#activity-2">activity/2</a></li>
<li title="activity-4"><a href="mnesia.html#activity-4">activity/4</a></li>
<li title="add_table_copy-3"><a href="mnesia.html#add_table_copy-3">add_table_copy/3</a></li>
<li title="add_table_index-2"><a href="mnesia.html#add_table_index-2">add_table_index/2</a></li>
<li title="all_keys-1"><a href="mnesia.html#all_keys-1">all_keys/1</a></li>
<li title="async_dirty-2"><a href="mnesia.html#async_dirty-2">async_dirty/2</a></li>
<li title="backup-1"><a href="mnesia.html#backup-1">backup/1</a></li>
<li title="backup_checkpoint-2"><a href="mnesia.html#backup_checkpoint-2">backup_checkpoint/2</a></li>
<li title="change_config-2"><a href="mnesia.html#change_config-2">change_config/2</a></li>
<li title="change_table_access_mode-2"><a href="mnesia.html#change_table_access_mode-2">change_table_access_mode/2</a></li>
<li title="change_table_copy_type-3"><a href="mnesia.html#change_table_copy_type-3">change_table_copy_type/3</a></li>
<li title="change_table_load_order-2"><a href="mnesia.html#change_table_load_order-2">change_table_load_order/2</a></li>
<li title="change_table_majority-2"><a href="mnesia.html#change_table_majority-2">change_table_majority/2</a></li>
<li title="clear_table-1"><a href="mnesia.html#clear_table-1">clear_table/1</a></li>
<li title="create_schema-1"><a href="mnesia.html#create_schema-1">create_schema/1</a></li>
<li title="create_table-2"><a href="mnesia.html#create_table-2">create_table/2</a></li>
<li title="deactivate_checkpoint-1"><a href="mnesia.html#deactivate_checkpoint-1">deactivate_checkpoint/1</a></li>
<li title="del_table_copy-2"><a href="mnesia.html#del_table_copy-2">del_table_copy/2</a></li>
<li title="del_table_index-2"><a href="mnesia.html#del_table_index-2">del_table_index/2</a></li>
<li title="delete-1"><a href="mnesia.html#delete-1">delete/1</a></li>
<li title="delete-3"><a href="mnesia.html#delete-3">delete/3</a></li>
<li title="delete_object-1"><a href="mnesia.html#delete_object-1">delete_object/1</a></li>
<li title="delete_object-3"><a href="mnesia.html#delete_object-3">delete_object/3</a></li>
<li title="delete_schema-1"><a href="mnesia.html#delete_schema-1">delete_schema/1</a></li>
<li title="delete_table-1"><a href="mnesia.html#delete_table-1">delete_table/1</a></li>
<li title="dirty_all_keys-1"><a href="mnesia.html#dirty_all_keys-1">dirty_all_keys/1</a></li>
<li title="dirty_delete-1"><a href="mnesia.html#dirty_delete-1">dirty_delete/1</a></li>
<li title="dirty_delete-2"><a href="mnesia.html#dirty_delete-2">dirty_delete/2</a></li>
<li title="dirty_delete_object-1"><a href="mnesia.html#dirty_delete_object-1">dirty_delete_object/1</a></li>
<li title="dirty_delete_object-2"><a href="mnesia.html#dirty_delete_object-2">dirty_delete_object/2</a></li>
<li title="dirty_first-1"><a href="mnesia.html#dirty_first-1">dirty_first/1</a></li>
<li title="dirty_index_match_object-2"><a href="mnesia.html#dirty_index_match_object-2">dirty_index_match_object/2</a></li>
<li title="dirty_index_match_object-3"><a href="mnesia.html#dirty_index_match_object-3">dirty_index_match_object/3</a></li>
<li title="dirty_index_read-3"><a href="mnesia.html#dirty_index_read-3">dirty_index_read/3</a></li>
<li title="dirty_last-1"><a href="mnesia.html#dirty_last-1">dirty_last/1</a></li>
<li title="dirty_match_object-1"><a href="mnesia.html#dirty_match_object-1">dirty_match_object/1</a></li>
<li title="dirty_match_object-2"><a href="mnesia.html#dirty_match_object-2">dirty_match_object/2</a></li>
<li title="dirty_next-2"><a href="mnesia.html#dirty_next-2">dirty_next/2</a></li>
<li title="dirty_prev-2"><a href="mnesia.html#dirty_prev-2">dirty_prev/2</a></li>
<li title="dirty_read-1"><a href="mnesia.html#dirty_read-1">dirty_read/1</a></li>
<li title="dirty_read-2"><a href="mnesia.html#dirty_read-2">dirty_read/2</a></li>
<li title="dirty_select-2"><a href="mnesia.html#dirty_select-2">dirty_select/2</a></li>
<li title="dirty_slot-2"><a href="mnesia.html#dirty_slot-2">dirty_slot/2</a></li>
<li title="dirty_update_counter-2"><a href="mnesia.html#dirty_update_counter-2">dirty_update_counter/2</a></li>
<li title="dirty_update_counter-3"><a href="mnesia.html#dirty_update_counter-3">dirty_update_counter/3</a></li>
<li title="dirty_write-1"><a href="mnesia.html#dirty_write-1">dirty_write/1</a></li>
<li title="dirty_write-2"><a href="mnesia.html#dirty_write-2">dirty_write/2</a></li>
<li title="dump_log-0"><a href="mnesia.html#dump_log-0">dump_log/0</a></li>
<li title="dump_tables-1"><a href="mnesia.html#dump_tables-1">dump_tables/1</a></li>
<li title="dump_to_textfile-1"><a href="mnesia.html#dump_to_textfile-1">dump_to_textfile/1</a></li>
<li title="error_description-1"><a href="mnesia.html#error_description-1">error_description/1</a></li>
<li title="ets-2"><a href="mnesia.html#ets-2">ets/2</a></li>
<li title="first-1"><a href="mnesia.html#first-1">first/1</a></li>
<li title="foldl-3"><a href="mnesia.html#foldl-3">foldl/3</a></li>
<li title="foldr-3"><a href="mnesia.html#foldr-3">foldr/3</a></li>
<li title="force_load_table-1"><a href="mnesia.html#force_load_table-1">force_load_table/1</a></li>
<li title="index_match_object-2"><a href="mnesia.html#index_match_object-2">index_match_object/2</a></li>
<li title="index_match_object-4"><a href="mnesia.html#index_match_object-4">index_match_object/4</a></li>
<li title="index_read-3"><a href="mnesia.html#index_read-3">index_read/3</a></li>
<li title="info-0"><a href="mnesia.html#info-0">info/0</a></li>
<li title="install_fallback-1"><a href="mnesia.html#install_fallback-1">install_fallback/1</a></li>
<li title="install_fallback-1"><a href="mnesia.html#install_fallback-1">install_fallback/1</a></li>
<li title="install_fallback-2"><a href="mnesia.html#install_fallback-2">install_fallback/2</a></li>
<li title="is_transaction-0"><a href="mnesia.html#is_transaction-0">is_transaction/0</a></li>
<li title="last-1"><a href="mnesia.html#last-1">last/1</a></li>
<li title="load_textfile-1"><a href="mnesia.html#load_textfile-1">load_textfile/1</a></li>
<li title="lock-2"><a href="mnesia.html#lock-2">lock/2</a></li>
<li title="match_object-1"><a href="mnesia.html#match_object-1">match_object/1</a></li>
<li title="match_object-3"><a href="mnesia.html#match_object-3">match_object/3</a></li>
<li title="move_table_copy-3"><a href="mnesia.html#move_table_copy-3">move_table_copy/3</a></li>
<li title="next-2"><a href="mnesia.html#next-2">next/2</a></li>
<li title="prev-2"><a href="mnesia.html#prev-2">prev/2</a></li>
<li title="read-1"><a href="mnesia.html#read-1">read/1</a></li>
<li title="read-2"><a href="mnesia.html#read-2">read/2</a></li>
<li title="read-3"><a href="mnesia.html#read-3">read/3</a></li>
<li title="read_lock_table-1"><a href="mnesia.html#read_lock_table-1">read_lock_table/1</a></li>
<li title="report_event-1"><a href="mnesia.html#report_event-1">report_event/1</a></li>
<li title="restore-2"><a href="mnesia.html#restore-2">restore/2</a></li>
<li title="s_delete-1"><a href="mnesia.html#s_delete-1">s_delete/1</a></li>
<li title="s_delete_object-1"><a href="mnesia.html#s_delete_object-1">s_delete_object/1</a></li>
<li title="s_write-1"><a href="mnesia.html#s_write-1">s_write/1</a></li>
<li title="schema-0"><a href="mnesia.html#schema-0">schema/0</a></li>
<li title="schema-1"><a href="mnesia.html#schema-1">schema/1</a></li>
<li title="select-2"><a href="mnesia.html#select-2">select/2</a></li>
<li title="select-4"><a href="mnesia.html#select-4">select/4</a></li>
<li title="select-1"><a href="mnesia.html#select-1">select/1</a></li>
<li title="set_debug_level-1"><a href="mnesia.html#set_debug_level-1">set_debug_level/1</a></li>
<li title="set_master_nodes-1"><a href="mnesia.html#set_master_nodes-1">set_master_nodes/1</a></li>
<li title="set_master_nodes-2"><a href="mnesia.html#set_master_nodes-2">set_master_nodes/2</a></li>
<li title="snmp_close_table-1"><a href="mnesia.html#snmp_close_table-1">snmp_close_table/1</a></li>
<li title="snmp_get_mnesia_key-2"><a href="mnesia.html#snmp_get_mnesia_key-2">snmp_get_mnesia_key/2</a></li>
<li title="snmp_get_next_index-2"><a href="mnesia.html#snmp_get_next_index-2">snmp_get_next_index/2</a></li>
<li title="snmp_get_row-2"><a href="mnesia.html#snmp_get_row-2">snmp_get_row/2</a></li>
<li title="snmp_open_table-2"><a href="mnesia.html#snmp_open_table-2">snmp_open_table/2</a></li>
<li title="start-0"><a href="mnesia.html#start-0">start/0</a></li>
<li title="stop-0"><a href="mnesia.html#stop-0">stop/0</a></li>
<li title="subscribe-1"><a href="mnesia.html#subscribe-1">subscribe/1</a></li>
<li title="sync_dirty-2"><a href="mnesia.html#sync_dirty-2">sync_dirty/2</a></li>
<li title="sync_log-0"><a href="mnesia.html#sync_log-0">sync_log/0</a></li>
<li title="sync_transaction-3"><a href="mnesia.html#sync_transaction-3">sync_transaction/3</a></li>
<li title="system_info-1"><a href="mnesia.html#system_info-1">system_info/1</a></li>
<li title="table-1"><a href="mnesia.html#table-1">table/1</a></li>
<li title="table_info-2"><a href="mnesia.html#table_info-2">table_info/2</a></li>
<li title="transaction-2"><a href="mnesia.html#transaction-2">transaction/2</a></li>
<li title="transform_table-4"><a href="mnesia.html#transform_table-4">transform_table/4</a></li>
<li title="transform_table-3"><a href="mnesia.html#transform_table-3">transform_table/3</a></li>
<li title="traverse_backup-4"><a href="mnesia.html#traverse_backup-4">traverse_backup/4</a></li>
<li title="uninstall_fallback-0"><a href="mnesia.html#uninstall_fallback-0">uninstall_fallback/0</a></li>
<li title="uninstall_fallback-1"><a href="mnesia.html#uninstall_fallback-1">uninstall_fallback/1</a></li>
<li title="unsubscribe-1"><a href="mnesia.html#unsubscribe-1">unsubscribe/1</a></li>
<li title="wait_for_tables-2"><a href="mnesia.html#wait_for_tables-2">wait_for_tables/2</a></li>
<li title="wread-1"><a href="mnesia.html#wread-1">wread/1</a></li>
<li title="write-1"><a href="mnesia.html#write-1">write/1</a></li>
<li title="write-3"><a href="mnesia.html#write-3">write/3</a></li>
<li title="write_lock_table-1"><a href="mnesia.html#write_lock_table-1">write_lock_table/1</a></li>
</ul>
</li>
<li id="no" title="mnesia_frag_hash " expanded="false">mnesia_frag_hash<ul>
<li><a href="mnesia_frag_hash.html">
                  Top of manual page
                </a></li>
<li title="init_state-2"><a href="mnesia_frag_hash.html#init_state-2">init_state/2</a></li>
<li title="add_frag-1"><a href="mnesia_frag_hash.html#add_frag-1">add_frag/1</a></li>
<li title="del_frag-1"><a href="mnesia_frag_hash.html#del_frag-1">del_frag/1</a></li>
<li title="key_to_frag_number-2"><a href="mnesia_frag_hash.html#key_to_frag_number-2">key_to_frag_number/2</a></li>
<li title="match_spec_to_frag_numbers-2"><a href="mnesia_frag_hash.html#match_spec_to_frag_numbers-2">match_spec_to_frag_numbers/2</a></li>
</ul>
</li>
<li id="no" title="mnesia_registry " expanded="false">mnesia_registry<ul>
<li><a href="mnesia_registry.html">
                  Top of manual page
                </a></li>
<li title="create_table-1"><a href="mnesia_registry.html#create_table-1">create_table/1</a></li>
<li title="create_table-2"><a href="mnesia_registry.html#create_table-2">create_table/2</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>mnesia</h1></center>
  
  <h3>MODULE</h3>
<div class="REFBODY">mnesia</div>
  <h3>MODULE SUMMARY</h3>
<div class="REFBODY">A distributed telecommunications DBMS</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>

    <p>The following are some of the most important and attractive
      capabilities provided by <span class="code">Mnesia</span>:</p>
    <ul>
      <li>A relational/object hybrid data model that is suitable
       for telecommunications applications.
      </li>
      <li>A DBMS query language, Query List Comprehension (QLC) as
       an add-on library.
      </li>
      <li>Persistence. Tables can be coherently kept on disc and
       in the main memory.
      </li>
      <li>Replication. Tables can be replicated at several nodes.
      </li>
      <li>Atomic transactions. A series of table manipulation
       operations can be grouped into a single atomic transaction.
      </li>
      <li>Location transparency. Programs can be written without
       knowledge of the actual data location.
      </li>
      <li>Extremely fast real-time data searches.
      </li>
      <li>Schema manipulation routines. The DBMS can be
       reconfigured at runtime without stopping the system.
      </li>
    </ul>
    <p>This Reference Manual describes the <span class="code">Mnesia</span> API. This
      includes functions that define and manipulate <span class="code">Mnesia</span>
      tables.</p>
    <p>All functions in this Reference Manual can be used in any
      combination with queries using the list comprehension notation.
      For information about the query notation, see the
      <span class="bold_code"><a href="qlc.html">qlc</a></span>
      manual page in <span class="code">STDLIB</span>.</p>
    <p>Data in <span class="code">Mnesia</span> is organized as a set of tables. Each table
      has a name that must be an atom. Each table is made up of
      Erlang records. The user is responsible for the record
      definitions. Each table also has a set of properties. The
      following are some of the properties that are associated with each
      table:</p>
    <ul>
      <li>
        <p><span class="code">type</span>. Each table can have <span class="code">set</span>,
          <span class="code">ordered_set</span>, or <span class="code">bag</span> semantics. Notice that
          currently <span class="code">ordered_set</span> is not supported for
          <span class="code">disc_only_copies</span>.</p>
        <p>If a table is of type <span class="code">set</span>, each key leads to
          either one or zero records.</p>
        <p>If a new item is inserted with the same key as an
          existing record, the old record is overwritten. However,
          if a table is of type <span class="code">bag</span>, each key can map to
          several records. All records in type <span class="code">bag</span> tables are
          unique, only the keys can be duplicated.</p>
      </li>
      <li>
        <p><span class="code">record_name</span>. All records stored in a table must
          have the same name. The records must be instances of the
          same record type.</p>
      </li>
      <li>
        <p><span class="code">ram_copies</span>. A table can be replicated on a number
          of Erlang nodes. Property <span class="code">ram_copies</span> specifies a
          list of Erlang nodes where RAM copies are kept. These
          copies can be dumped to disc at regular intervals. However,
          updates to these copies are not written to disc on a
          transaction basis.</p>
      </li>
      <li>
        <p><span class="code">disc_copies</span>. This property
          specifies a list of Erlang nodes where the table is kept in
          RAM and on disc. All updates of the table are
          performed in the actual table and are also logged to disc.
          If a table is of type <span class="code">disc_copies</span> at a certain node,
          the entire table is resident in RAM memory and on disc.
          Each transaction performed on the table is appended to a
          <span class="code">LOG</span> file and written into the RAM table.</p>
      </li>
      <li>
        <p><span class="code">disc_only_copies</span>. Some, or all, table replicas
          can be kept on disc only. These replicas are considerably
          slower than the RAM-based replicas.</p>
      </li>
      <li>
        <p><span class="code">index</span>. This is a list of attribute names, or
          integers, which specify the tuple positions on which
          <span class="code">Mnesia</span> is to build and maintain an extra index
          table.</p>
      </li>
      <li>
        <p><span class="code">local_content</span>. When an application requires
          tables whose contents are local to each node,
          <span class="code">local_content</span> tables can be used. The table name
          is known to all <span class="code">Mnesia</span> nodes, but its content is
          unique on each node. This means that access to such a table
          must be done locally. Set field <span class="code">local_content</span> to
          <span class="code">true</span> to enable the <span class="code">local_content</span>
          behavior. Default is <span class="code">false</span>.</p>
      </li>
      <li>
        <p><span class="code">majority</span>. This attribute is <span class="code">true</span> or
        <span class="code">false</span>; default is <span class="code">false</span>. When <span class="code">true</span>,
        a majority of the table replicas must be available for an
        update to succeed. Majority checking can be enabled on
        tables with mission-critical data, where it is vital to
        avoid inconsistencies because of network splits.</p>
      </li>
      <li>
        <p><span class="code">snmp</span>. Each (set-based) <span class="code">Mnesia</span> table can be
          automatically turned into a Simple Network Management
          Protocol (SNMP) ordered table as well.
          This property specifies the types of the SNMP keys.</p>
      </li>
      <li>
        <p><span class="code">attributes</span>. The names of the attributes for the
          records that are inserted in the table.</p>
      </li>
    </ul>
    <p>For information about the complete set of table properties
      and their details, see <span class="code">mnesia:create_table/2</span>.</p>
    <p>This Reference Manual uses a table of persons to illustrate
      various examples. The following record definition is assumed:</p>
    <div class="example"><pre>
-record(person, {name,
                 age = 0,
                 address = unknown,
                 salary = 0,
                 children = []}),</pre></div>
    <p>The first record attribute is the primary key, or key
      for short.</p>
    <p>The function descriptions are sorted in alphabetical order.
      It is recommended to start to read about
      <span class="code">mnesia:create_table/2</span>, <span class="code">mnesia:lock/2</span>, and
      <span class="code">mnesia:activity/4</span> before you continue and learn
      about the rest.</p>
    <p>Writing or deleting in transaction-context creates a local
      copy of each modified record during the transaction. During
      iteration, that is, <span class="code">mnesia:fold[lr]/4</span>,
      <span class="code">mnesia:next/2</span>, <span class="code">mnesia:prev/2</span>, and
      <span class="code">mnesia:snmp_get_next_index/2</span>, <span class="code">Mnesia</span>
      compensates for every written or deleted record, which can
      reduce the performance.</p>
    <p>If possible, avoid writing or deleting records in the same
      transaction before iterating over the table.</p>
  </p></div>

  <h3>EXPORTS</h3>
    <p><a name="abort-1"><span class="bold_code">abort(Reason) -&gt; transaction abort</span></a><br></p>
<div class="REFBODY"><p>
        <p>Makes the transaction silently
          return the tuple <span class="code">{aborted, Reason}</span>.
          Termination of a <span class="code">Mnesia</span> transaction means that
          an exception is thrown to an enclosing <span class="code">catch</span>.
          Thus, the expression <span class="code">catch mnesia:abort(x)</span> does
          not terminate the transaction.</p>
      </p></div>
    <p><a name="activate_checkpoint-1"><span class="bold_code">activate_checkpoint(Args) -&gt; {ok,Name,Nodes} | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="activate_checkpoint"></a>
        <p>A checkpoint is a consistent view of the system.
          A checkpoint can be activated on a set of tables.
          This checkpoint can then be traversed and
          presents a view of the system as it existed at the time when
          the checkpoint was activated, even if the tables are
          being or have been manipulated.</p>
        <p><span class="code">Args</span> is a list of the following tuples:</p>
        <ul>
          <li>
            <p><span class="code">{name,Name}</span>. <span class="code">Name</span> is the checkpoint name.
              Each checkpoint must have a name that is unique to the
              associated nodes. The name can be reused only once the
              checkpoint has been deactivated. By default, a name
              that is probably unique is generated.</p>
          </li>
          <li>
            <p><span class="code">{max,MaxTabs}</span>. <span class="code">MaxTabs</span> is a list of
              tables that are to be included in the checkpoint.
              Default is <span class="code">[]</span>. For these tables, the redundancy is
              maximized and checkpoint information is retained together
              with all replicas. The checkpoint becomes more fault
              tolerant if the tables have several replicas. When a new
              replica is added by the schema manipulation
              function <span class="code">mnesia:add_table_copy/3</span>, a retainer is
              also attached automatically.</p>
          </li>
          <li>
            <p><span class="code">{min,MinTabs}</span>. <span class="code">MinTabs</span> is a list of
              tables that are to be included in the checkpoint.
              Default is []. For these tables, the redundancy is
              minimized and the checkpoint information is only retained
              with one replica, preferably on the local node.</p>
          </li>
          <li>
            <p><span class="code">{allow_remote,Bool}</span>. <span class="code">false</span> means that
              all retainers must be local. The checkpoint cannot be
              activated if a table does not reside locally.
              <span class="code">true</span> allows retainers to be allocated on any
              node. Default is <span class="code">true</span>.</p>
          </li>
          <li>
            <p><span class="code">{ram_overrides_dump,Bool}</span>. Only applicable
              for <span class="code">ram_copies</span>. <span class="code">Bool</span> allows you to choose
              to back up the table state as it is in RAM, or as it is
              on disc. <span class="code">true</span> means that the latest committed
              records in RAM are to be included in the checkpoint.
              These are the records that the application accesses.
              <span class="code">false</span> means that the records dumped to <span class="code">DAT</span>
              files are to be included in the checkpoint. These
              records are loaded at startup. Default is <span class="code">false</span>.</p>
          </li>
        </ul>
        <p>Returns <span class="code">{ok,Name,Nodes}</span> or <span class="code">{error,Reason}</span>.
          <span class="code">Name</span> is the (possibly generated) checkpoint name.
          <span class="code">Nodes</span> are the nodes that
          are involved in the checkpoint. Only nodes that keep a
          checkpoint retainer know about the checkpoint.</p>
      </p></div>
    <p><a name="activity-2"><span class="bold_code">activity(AccessContext, Fun [, Args]) -&gt; ResultOfFun | exit(Reason)</span></a><br></p>
<div class="REFBODY"><p>
      <a name="activity_2_3"></a>
        <p>Calls <span class="code">mnesia:activity(AccessContext, Fun, Args,
          AccessMod)</span>, where <span class="code">AccessMod</span> is the default
          access callback module obtained by
          <span class="code">mnesia:system_info(access_module)</span>. <span class="code">Args</span>
          defaults to <span class="code">[]</span> (empty list).</p>
      </p></div>
    <p><a name="activity-4"><span class="bold_code">activity(AccessContext, Fun, Args, AccessMod) -&gt; ResultOfFun | exit(Reason)</span></a><br></p>
<div class="REFBODY"><p>
      <a name="activity_4"></a>
        <p>Executes the functional object <span class="code">Fun</span>
          with argument <span class="code">Args</span>.</p>
        <p>The code that executes inside the activity can
          consist of a series of table manipulation functions, which are
          performed in an <span class="code">AccessContext</span>. Currently, the following
          access contexts are supported:</p>
        <dl>
          <dt><strong><span class="code">transaction</span></strong></dt>
          <dd>
            <p>Short for <span class="code">{transaction, infinity}</span></p>
          </dd>
          <dt><strong><span class="code">{transaction, Retries}</span></strong></dt>
          <dd>
            <p>Calls <span class="code">mnesia:transaction(Fun, Args, Retries)</span>.
              Notice that the result from <span class="code">Fun</span> is
              returned if the transaction is successful (atomic),
              otherwise the function exits with an abort reason.</p>
          </dd>
          <dt><strong><span class="code">sync_transaction</span></strong></dt>
          <dd>
            <p>Short for <span class="code">{sync_transaction, infinity}</span></p>
          </dd>
          <dt><strong><span class="code">{sync_transaction, Retries}</span></strong></dt>
          <dd>
            <p>Calls <span class="code">mnesia:sync_transaction(Fun, Args, Retries)</span>.
              Notice that the result from <span class="code">Fun</span> is
              returned if the transaction is successful (atomic),
              otherwise the function exits with an abort reason.</p>
          </dd>
          <dt><strong><span class="code">async_dirty</span></strong></dt>
          <dd>
            <p>Calls <span class="code">mnesia:async_dirty(Fun, Args)</span>.</p>
          </dd>
          <dt><strong><span class="code">sync_dirty</span></strong></dt>
          <dd>
            <p>Calls <span class="code">mnesia:sync_dirty(Fun, Args)</span>.</p>
          </dd>
          <dt><strong><span class="code">ets</span></strong></dt>
          <dd>
            <p>Calls <span class="code">mnesia:ets(Fun, Args)</span>.</p>
          </dd>
        </dl>
        <p>This function (<span class="code">mnesia:activity/4</span>) differs in an
          important way from the functions <span class="code">mnesia:transaction</span>,
          <span class="code">mnesia:sync_transaction</span>,
          <span class="code">mnesia:async_dirty</span>, <span class="code">mnesia:sync_dirty</span>, and
          <span class="code">mnesia:ets</span>. Argument <span class="code">AccessMod</span>
          is the name of a callback module, which implements the
          <span class="code">mnesia_access</span> behavior.</p>
        <p><span class="code">Mnesia</span> forwards calls to the following functions:</p>
        <ul>
          <li>mnesia:lock/2 (read_lock_table/1, write_lock_table/1)
          </li>
          <li>mnesia:write/3 (write/1, s_write/1)
          </li>
          <li>mnesia:delete/3 (delete/1, s_delete/1)
          </li>
          <li>mnesia:delete_object/3 (delete_object/1, s_delete_object/1)
          </li>
          <li>mnesia:read/3 (read/1, wread/1)
          </li>
          <li>mnesia:match_object/3 (match_object/1)
          </li>
          <li>mnesia:all_keys/1
          </li>
          <li>mnesia:first/1
          </li>
          <li>mnesia:last/1
          </li>
          <li>mnesia:prev/2
          </li>
          <li>mnesia:next/2
          </li>
          <li>mnesia:index_match_object/4 (index_match_object/2)
          </li>
          <li>mnesia:index_read/3
          </li>
          <li>mnesia:table_info/2
          </li>
        </ul>
        <p>to the corresponding:</p>
        <ul>
          <li>AccessMod:lock(ActivityId, Opaque, LockItem, LockKind)
          </li>
          <li>AccessMod:write(ActivityId, Opaque, Tab, Rec, LockKind)
          </li>
          <li>AccessMod:delete(ActivityId, Opaque, Tab, Key, LockKind)
          </li>
          <li>AccessMod:delete_object(ActivityId, Opaque, Tab, RecXS,
           LockKind)
          </li>
          <li>AccessMod:read(ActivityId, Opaque, Tab, Key, LockKind)
          </li>
          <li>AccessMod:match_object(ActivityId, Opaque, Tab, Pattern,
           LockKind)
          </li>
          <li>AccessMod:all_keys(ActivityId, Opaque, Tab, LockKind)
          </li>
          <li>AccessMod:first(ActivityId, Opaque, Tab)
          </li>
          <li>AccessMod:last(ActivityId, Opaque, Tab)
          </li>
          <li>AccessMod:prev(ActivityId, Opaque, Tab, Key)
          </li>
          <li>AccessMod:next(ActivityId, Opaque, Tab, Key)
          </li>
          <li>AccessMod:index_match_object(ActivityId, Opaque, Tab,
           Pattern, Attr, LockKind)
          </li>
          <li>AccessMod:index_read(ActivityId, Opaque, Tab,
           SecondaryKey, Attr, LockKind)
          </li>
          <li>AccessMod:table_info(ActivityId, Opaque, Tab, InfoItem)
          </li>
        </ul>
        <p><span class="code">ActivityId</span> is a record that represents the identity
          of the enclosing <span class="code">Mnesia</span> activity. The first field
          (obtained with <span class="code">element(1, ActivityId)</span>) contains an
          atom, which can be interpreted as the activity type:
          <span class="code">ets</span>, <span class="code">async_dirty</span>, <span class="code">sync_dirty</span>, or
          <span class="code">tid</span>. <span class="code">tid</span> means that the activity is a
          transaction. The structure of the rest of the identity
          record is internal to <span class="code">Mnesia</span>.</p>
        <p><span class="code">Opaque</span> is an opaque data structure that is internal
          to <span class="code">Mnesia</span>.</p>
      </p></div>
    <p><a name="add_table_copy-3"><span class="bold_code">add_table_copy(Tab, Node, Type) -&gt; {aborted, R} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="add_table_copy"></a>
        <p>Makes another copy of a table at the node <span class="code">Node</span>.
          Argument <span class="code">Type</span> must be either of the atoms
          <span class="code">ram_copies</span>, <span class="code">disc_copies</span>, or
          <span class="code">disc_only_copies</span>. For example, the following call
          ensures that a disc replica of the <span class="code">person</span> table also
          exists at node <span class="code">Node</span>:</p>
        <div class="example"><pre>
mnesia:add_table_copy(person, Node, disc_copies)</pre></div>
        <p>This function can also be used to add a replica of the
          table named <span class="code">schema</span>.</p>
      </p></div>
    <p><a name="add_table_index-2"><span class="bold_code">add_table_index(Tab, AttrName) -&gt; {aborted, R} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="add_table_index"></a>
        <p>Table indexes can be used whenever the user
          wants to use frequently some other field than the key field
          to look up records. If this other field has an associated
          index, these lookups can occur in constant time
          and space. For example, if your application wishes to use
          field <span class="code">age</span> to find efficiently all persons with
          a specific age, it can be a good idea to have an index on
          field <span class="code">age</span>. This can be done with the following
          call:</p>
        <div class="example"><pre>
mnesia:add_table_index(person, age)</pre></div>
        <p>Indexes do not come for free. They occupy space that is
	  proportional to the table size, and they cause insertions
          into the table to execute slightly slower.</p>
      </p></div>
    <p><a name="all_keys-1"><span class="bold_code">all_keys(Tab) -&gt; KeyList | transaction abort</span></a><br></p>
<div class="REFBODY"><p>
      <a name="all_keys"></a>
        <p>Returns a list of all keys in the table named <span class="code">Tab</span>.
          The semantics of this function is context-sensitive.
          For more information, see <span class="code">mnesia:activity/4</span>. In
          transaction-context, it acquires a read lock on the entire
          table.</p>
      </p></div>
    <p><a name="async_dirty-2"><span class="bold_code">async_dirty(Fun, [, Args]) -&gt; ResultOfFun | exit(Reason)</span></a><br></p>
<div class="REFBODY"><p>
      <a name="async_dirty"></a>
        <p>Calls the <span class="code">Fun</span> in a context that is not protected by
          a transaction. The <span class="code">Mnesia</span> function calls performed in
          the <span class="code">Fun</span> are mapped to the corresponding dirty
          functions. This still involves logging, replication, and
          subscriptions, but there is no locking, local transaction
          storage, or commit protocols involved. Checkpoint retainers
          and indexes are updated, but they are updated dirty. As
          for normal <span class="code">mnesia:dirty_*</span> operations, the operations
          are performed semi-asynchronously. For details, see
          <span class="code">mnesia:activity/4</span> and the User's Guide.</p>
        <p>The <span class="code">Mnesia</span> tables can be manipulated without
          using transactions. This has some serious disadvantages, but
          is considerably faster, as the transaction manager is not
          involved and no locks are set. A dirty operation does,
          however, guarantee a certain level of consistency, and
          the dirty operations cannot return garbled records.
          All dirty operations provide location transparency
          to the programmer, and a program does not have to be aware
          of the whereabouts of a certain table to function.</p>
        <p>Notice that it is more than ten times more efficient to
          read records dirty than within a transaction.</p>
        <p>Depending on the application, it can be a good idea to use
          the dirty functions for certain operations. Almost all
          <span class="code">Mnesia</span> functions that can be called within
          transactions have a dirty equivalent, which is much more
          efficient.</p>
        <p>However, notice that there is a risk that the database can
          be left in an inconsistent state if dirty operations are
          used to update it. Dirty operations are only to be used
          for performance reasons when it is absolutely necessary.</p>
        <p>Notice that calling (nesting) <span class="code">mnesia:[a]sync_dirty</span>
          inside a transaction-context inherits the transaction
          semantics.</p>
      </p></div>
    <p><a name="backup-1"><span class="bold_code">backup(Opaque [, BackupMod]) -&gt; ok | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="backup"></a>
        <p>Activates a new checkpoint covering all <span class="code">Mnesia</span> tables,
          including the schema, with maximum degree of redundancy, and
          performs a backup using <span class="code">backup_checkpoint/2/3</span>. The
          default value of the backup callback module <span class="code">BackupMod</span>
          is obtained by <span class="code">mnesia:system_info(backup_module)</span>.</p>
      </p></div>
    <p><a name="backup_checkpoint-2"><span class="bold_code">backup_checkpoint(Name, Opaque [, BackupMod]) -&gt; ok | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="backup_checkpoint"></a>
        <p>The tables are backed up to external media using backup
          module <span class="code">BackupMod</span>. Tables with the local contents
          property are backed up as they exist on the current
          node. <span class="code">BackupMod</span> is the default backup callback
          module obtained by
          <span class="code">mnesia:system_info(backup_module)</span>. For information
          about the exact callback interface (the
          <span class="code">mnesia_backup behavior</span>), see the User's Guide.</p>
      </p></div>
    <p><a name="change_config-2"><span class="bold_code">change_config(Config, Value) -&gt; {error, Reason} | {ok, ReturnValue}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="change_config"></a>
        <p><span class="code">Config</span> is to be an atom of the following
          configuration parameters:</p>
        <dl>
          <dt><strong><span class="code">extra_db_nodes</span></strong></dt>
          <dd>
            <p><span class="code">Value</span> is a list of nodes that <span class="code">Mnesia</span>
              is to try to connect to. <span class="code">ReturnValue</span> is those
              nodes in <span class="code">Value</span> that <span class="code">Mnesia</span> is connected
              to.</p>
            <p>Notice that this function must only be used to connect
              to newly started RAM nodes (N.D.R.S.N.) with an empty
              schema. If, for example, this function is used after
              the network has been partitioned, it can lead to
              inconsistent tables.</p>
            <p>Notice that <span class="code">Mnesia</span> can be connected to other
              nodes than those returned in <span class="code">ReturnValue</span>.</p>
          </dd>
          <dt><strong><span class="code">dc_dump_limit</span></strong></dt>
          <dd>
            <p><span class="code">Value</span> is a number. See the description in
            <span class="bold_code"><a href="#configuration_parameters">Section
            Configuration Parameters</a></span>. <span class="code">ReturnValue</span>
            is the new value. Notice that this configuration
            parameter is not persistent. It is lost when
            <span class="code">Mnesia</span> has stopped.</p>
          </dd>
        </dl>
      </p></div>
    <p><a name="change_table_access_mode-2"><span class="bold_code">change_table_access_mode(Tab, AccessMode) -&gt; {aborted, R} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="change_table_access_mode"></a>
        <p><span class="code">AcccessMode</span> is by default the atom
          <span class="code">read_write</span> but it can also be set to the atom
          <span class="code">read_only</span>. If <span class="code">AccessMode</span> is set to
          <span class="code">read_only</span>, updates to the table cannot be
          performed. At startup, <span class="code">Mnesia</span> always loads
          <span class="code">read_only</span> tables locally regardless of when and if
          <span class="code">Mnesia</span> is terminated on other nodes.</p>
      </p></div>
    <p><a name="change_table_copy_type-3"><span class="bold_code">change_table_copy_type(Tab, Node, To) -&gt; {aborted, R} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="change_table_copy_type"></a>
        <p>For example:</p>
        <div class="example"><pre>
mnesia:change_table_copy_type(person, node(), disc_copies)</pre></div>
        <p>Transforms the <span class="code">person</span> table from a RAM table into
          a disc-based table at <span class="code">Node</span>.</p>
        <p>This function can also be used to change the storage type
          of the table named <span class="code">schema</span>. The schema table can only
          have <span class="code">ram_copies</span> or <span class="code">disc_copies</span> as the storage
          type. If the storage type of the schema is <span class="code">ram_copies</span>,
          no other table can be disc-resident on that node.</p>
      </p></div>
    <p><a name="change_table_load_order-2"><span class="bold_code">change_table_load_order(Tab, LoadOrder) -&gt; {aborted, R} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="change_table_load_order"></a>
        <p>The <span class="code">LoadOrder</span> priority is by default <span class="code">0</span> (zero)
          but can be set to any integer. The tables with the highest
          <span class="code">LoadOrder</span> priority are loaded first at startup.</p>
      </p></div>
    <p><a name="change_table_majority-2"><span class="bold_code">change_table_majority(Tab, Majority) -&gt; {aborted, R} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
        <p><span class="code">Majority</span> must be a boolean. Default is <span class="code">false</span>.
          When <span class="code">true</span>, a majority of the table replicas must be
          available for an update to succeed. When used on fragmented
          tables, <span class="code">Tab</span> must be the base table name. Directly
          changing the majority setting on individual fragments is
          not allowed.</p>
      </p></div>
    <p><a name="clear_table-1"><span class="bold_code">clear_table(Tab) -&gt; {aborted, R} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="clear_table"></a>
        <p>Deletes all entries in the table <span class="code">Tab</span>.</p>
      </p></div>
    <p><a name="create_schema-1"><span class="bold_code">create_schema(DiscNodes) -&gt; ok | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="create_schema"></a>
        <p>Creates a new database on disc. Various files are
          created in the local <span class="code">Mnesia</span> directory of each node.
          Notice that the directory must be unique for each node.
          Two nodes must never share the same directory. If possible,
          use a local disc device to improve performance.</p>
        <p><span class="code">mnesia:create_schema/1</span> fails if any of the
          Erlang nodes given as <span class="code">DiscNodes</span> are not alive, if
          <span class="code">Mnesia</span> is running on any of the nodes, or if any
          of the nodes already have a schema. Use
          <span class="code">mnesia:delete_schema/1</span> to get rid of old faulty
          schemas.</p>
        <p>Notice that only nodes with disc are to be included in
          <span class="code">DiscNodes</span>. Disc-less nodes, that is, nodes where
          all tables including the schema only resides in RAM,
          must not be included.</p>
      </p></div>
    <p><a name="create_table-2"><span class="bold_code">create_table(Name, TabDef) -&gt; {atomic, ok} | {aborted, Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="create_table"></a>
        <p>Creates a <span class="code">Mnesia</span> table called
          <span class="code">Name</span> according to argument <span class="code">TabDef</span>. This
          list must be a list of <span class="code">{Item, Value}</span> tuples,
          where the following values are allowed:</p>
        <ul>
          <li>
            <p><span class="code">{access_mode, Atom}</span>. The access mode is by
              default the atom <span class="code">read_write</span> but it can also be
              set to the atom <span class="code">read_only</span>. If <span class="code">AccessMode</span>
              is set to <span class="code">read_only</span>, updates to the table
              cannot be performed.</p>
            <p>At startup, <span class="code">Mnesia</span> always loads <span class="code">read_only</span>
              table locally regardless of when and if <span class="code">Mnesia</span> is
              terminated on other nodes. This argument returns the
              access mode of the table. The access mode can be
              <span class="code">read_only</span> or <span class="code">read_write</span>.</p>
          </li>
          <li>
            <p><span class="code">{attributes, AtomList}</span> is a list of the
              attribute names for the records that are supposed to
              populate the table. Default is <span class="code">[key, val]</span>.
              The table must at least have one extra attribute in
              addition to the key.</p>
            <p>When accessing single attributes in a record, it is
              not necessary, or even recommended, to hard code any
              attribute names as atoms. Use construct
              <span class="code">record_info(fields, RecordName)</span> instead. It can
              be used for records of type <span class="code">RecordName</span>.</p>
          </li>
          <li>
            <p><span class="code">{disc_copies, Nodelist}</span>, where
              <span class="code">Nodelist</span> is a list of the nodes where this table
              is supposed to have disc copies. If a table replica is
              of type <span class="code">disc_copies</span>, all write operations on this
              particular replica of the table are written to disc and
              to the RAM copy of the table.</p>
            <p>It is possible to have a replicated table of type
              <span class="code">disc_copies</span> on one node and another type on
              another node.  Default is <span class="code">[]</span>.</p>
          </li>
          <li>
            <p><span class="code">{disc_only_copies, Nodelist}</span>, where
              <span class="code">Nodelist</span> is a list of the nodes where this table
              is supposed to have <span class="code">disc_only_copies</span>. A disc only
              table replica is kept on disc only and unlike the other
              replica types, the contents of the replica do not
              reside in RAM. These replicas are considerably slower
              than replicas held in RAM.</p>
          </li>
          <li>
            <p><span class="code">{index, Intlist}</span>, where
              <span class="code">Intlist</span> is a list of attribute names (atoms) or
              record fields for which <span class="code">Mnesia</span> is to build and
              maintain an extra index table. The <span class="code">qlc</span> query
              compiler <strong>may</strong> be able to optimize queries
              if there are indexes available.</p>
          </li>
          <li>
            <p><span class="code">{load_order, Integer}</span>. The load order
              priority is by default <span class="code">0</span> (zero) but can be set
              to any integer. The tables with the highest load order
              priority are loaded first at startup.</p>
          </li>
          <li>
            <p><span class="code">{majority, Flag}</span>, where <span class="code">Flag</span> must be a
              boolean. If <span class="code">true</span>, any (non-dirty) update to the
              table is aborted, unless a majority of the table
              replicas are available for the commit. When used on a
              fragmented table, all fragments are given the same
              the same majority setting.</p>
          </li>
          <li>
            <p><span class="code">{ram_copies, Nodelist}</span>, where
              <span class="code">Nodelist</span> is a list of the nodes where this table
              is supposed to have RAM copies. A table replica of type
              <span class="code">ram_copies</span> is not written to disc on a per
              transaction basis. <span class="code">ram_copies</span> replicas can be
              dumped to disc with the function
              <span class="code">mnesia:dump_tables(Tabs)</span>. Default value for
              this attribute is <span class="code">[node()]</span>.</p>
          </li>
          <li>
            <p><span class="code">{record_name, Name}</span>, where <span class="code">Name</span> must
              be an atom. All records stored in the table must have
              this name as the first element. It defaults to the same
              name as the table name.</p>
          </li>
          <li>
            <p><span class="code">{snmp, SnmpStruct}</span>. For a description of
              <span class="code">SnmpStruct</span>, see <span class="code">mnesia:snmp_open_table/2</span>.
              If this attribute is present in <span class="code">ArgList</span> to
              <span class="code">mnesia:create_table/2</span>, the table is immediately
              accessible by SNMP. Therefore applications that use
              SNMP to manipulate and control the system can be
              designed easily, since <span class="code">Mnesia</span> provides a
              direct mapping between the logical tables that make up
              an SNMP control application and the physical data that
              makes up a <span class="code">Mnesia</span> table.</p>
          </li>
          <li>
            <p><span class="code">{storage_properties, [{Backend, Properties}]</span>
            forwards more properties to the back end storage.
            <span class="code">Backend</span> can currently be <span class="code">ets</span> or <span class="code">dets</span>.
            <span class="code">Properties</span> is a list of options sent to the
            back end storage during table creation. <span class="code">Properties</span>
            cannot contain properties already used by <span class="code">Mnesia</span>,
            such as <span class="code">type</span> or <span class="code">named_table</span>.</p>
            <p>For example:</p>
            <div class="example"><pre>
mnesia:create_table(table, [{ram_copies, [node()]}, {disc_only_copies, nodes()},
       {storage_properties,
        [{ets, [compressed]}, {dets, [{auto_save, 5000}]} ]}])</pre></div>
          </li>
          <li>
            <p><span class="code">{type, Type}</span>, where <span class="code">Type</span> must be
              either of the atoms <span class="code">set</span>, <span class="code">ordered_set</span>, or
              <span class="code">bag</span>. Default is <span class="code">set</span>. In a
              <span class="code">set</span>, all records have unique keys. In a
              <span class="code">bag</span>, several records can have the same key, but
              the record content is unique. If a non-unique record is
              stored, the old conflicting records are overwritten.</p>
            <p>Notice that currently <span class="code">ordered_set</span> is not
              supported for <span class="code">disc_only_copies</span>.</p>
          </li>
          <li>
            <p><span class="code">{local_content, Bool}</span>, where <span class="code">Bool</span> is
              <span class="code">true</span> or <span class="code">false</span>. Default is <span class="code">false</span>.</p>
          </li>
        </ul>
        <p>For example, the following call creates the <span class="code">person</span>
          table (defined earlier) and replicates it on two nodes:</p>
        <div class="example"><pre>
mnesia:create_table(person,
    [{ram_copies, [N1, N2]},
     {attributes, record_info(fields, person)}]).</pre></div>
        <p>If it is required that <span class="code">Mnesia</span> must build and
          maintain an extra index table on attribute <span class="code">address</span>
          of all the <span class="code">person</span> records that are inserted in the
          table, the following code would be issued:</p>
        <div class="example"><pre>
mnesia:create_table(person,
    [{ram_copies, [N1, N2]},
     {index, [address]},
     {attributes, record_info(fields, person)}]).
   </pre></div>
        <p>The specification of <span class="code">index</span> and <span class="code">attributes</span>
          can be hard-coded as <span class="code">{index, [2]}</span> and
          <span class="code">{attributes, [name, age, address, salary, children]}</span>,
          respectively.</p>
        <p><span class="code">mnesia:create_table/2</span> writes records into the
          table <span class="code">schema</span>. This function, and all other
          schema manipulation functions, are implemented with the
          normal transaction management system. This guarantees that
          schema updates are performed on all nodes in an atomic
          manner.</p>
      </p></div>
    <p><a name="deactivate_checkpoint-1"><span class="bold_code">deactivate_checkpoint(Name) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="deactivate_checkpoint"></a>
        <p>The checkpoint is automatically deactivated when some of
          the tables involved have no retainer attached to them. This
          can occur when nodes go down or when a replica is deleted.
          Checkpoints are also deactivated with this function.
          <span class="code">Name</span> is the name of an active checkpoint.</p>
      </p></div>
    <p><a name="del_table_copy-2"><span class="bold_code">del_table_copy(Tab, Node) -&gt; {aborted, R} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="del_table_copy"></a>
        <p>Deletes the replica of table <span class="code">Tab</span> at node <span class="code">Node</span>.
          When the last replica is deleted with this
          function, the table disappears entirely.</p>
        <p>This function can also be used to delete a replica of
          the table named <span class="code">schema</span>. The <span class="code">Mnesia</span> node is
          then removed. Notice that <span class="code">Mnesia</span> must be
          stopped on the node first.</p>
      </p></div>
    <p><a name="del_table_index-2"><span class="bold_code">del_table_index(Tab, AttrName) -&gt; {aborted, R} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="del_table_index"></a>
        <p>Deletes the index on attribute with name
          <span class="code">AttrName</span> in a table.</p>
      </p></div>
    <p><a name="delete-1"><span class="bold_code">delete({Tab, Key}) -&gt; transaction abort | ok</span></a><br></p>
<div class="REFBODY"><p>
      <a name="delete_2"></a>
        <p>Calls <span class="code">mnesia:delete(Tab, Key, write)</span>.</p>
      </p></div>
    <p><a name="delete-3"><span class="bold_code">delete(Tab, Key, LockKind) -&gt; transaction abort | ok</span></a><br></p>
<div class="REFBODY"><p>
      <a name="delete_3"></a>
        <p>Deletes all records in table <span class="code">Tab</span> with the key
          <span class="code">Key</span>.</p>
        <p>The semantics of this function is context-sensitive.
          For details, see <span class="code">mnesia:activity/4</span>. In
          transaction-context, it acquires a lock of type
          <span class="code">LockKind</span> in the record.
          Currently, the lock types <span class="code">write</span> and
          <span class="code">sticky_write</span> are supported.</p>
      </p></div>
    <p><a name="delete_object-1"><span class="bold_code">delete_object(Record) -&gt; transaction abort | ok</span></a><br></p>
<div class="REFBODY"><p>
      <a name="delete_object_1"></a>
        <p>Calls <span class="code">mnesia:delete_object(Tab, Record, write)</span>, where
          <span class="code">Tab</span> is <span class="code">element(1, Record)</span>.</p>
      </p></div>
    <p><a name="delete_object-3"><span class="bold_code">delete_object(Tab, Record, LockKind) -&gt; transaction abort | ok</span></a><br></p>
<div class="REFBODY"><p>
      <a name="delete_object_3"></a>
        <p>If a table is of type <span class="code">bag</span>, it can sometimes be
          needed to delete only some of the records with a certain
          key. This can be done with the function <span class="code">delete_object/3</span>.
          A complete record must be supplied to this function.</p>
        <p>The semantics of this function is context-sensitive.
          For details, see <span class="code">mnesia:activity/4</span>. In
          transaction-context, it acquires a lock of type
          <span class="code">LockKind</span> on the record.
          Currently, the lock types <span class="code">write</span> and
          <span class="code">sticky_write</span> are supported.</p>
      </p></div>
    <p><a name="delete_schema-1"><span class="bold_code">delete_schema(DiscNodes) -&gt; ok | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="delete_schema"></a>
        <p>Deletes a database created with
          <span class="code">mnesia:create_schema/1</span>.
          <span class="code">mnesia:delete_schema/1</span> fails if any of the Erlang
          nodes given as <span class="code">DiscNodes</span> are not alive, or if
          <span class="code">Mnesia</span> is running on any of the nodes.</p>
        <p>After the database is deleted, it can still be possible
          to start <span class="code">Mnesia</span> as a disc-less node. This depends
          on how configuration parameter <span class="code">schema_location</span> is
          set.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>Use this function with extreme caution, as it makes
            existing persistent data obsolete. Think twice before
            using it.</p>
        </p></div>
</div>
      </p></div>
    <p><a name="delete_table-1"><span class="bold_code">delete_table(Tab) -&gt; {aborted, Reason} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="delete_table"></a>
        <p>Permanently deletes all replicas of table <span class="code">Tab</span>.</p>
      </p></div>
    <p><a name="dirty_all_keys-1"><span class="bold_code">dirty_all_keys(Tab) -&gt; KeyList | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
      <a name="delete_all_keys"></a>
        <p>Dirty equivalent of the function <span class="code">mnesia:all_keys/1</span>.</p>
      </p></div>
    <p><a name="dirty_delete-1"><span class="bold_code">dirty_delete({Tab, Key}) -&gt; ok | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_delete"></a>
        <p>Calls <span class="code">mnesia:dirty_delete(Tab, Key)</span>.</p>
      </p></div>
    <p><a name="dirty_delete-2"><span class="bold_code">dirty_delete(Tab, Key) -&gt; ok | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
        <p>Dirty equivalent of the function <span class="code">mnesia:delete/3</span>.</p>
      </p></div>
    <p><a name="dirty_delete_object-1"><span class="bold_code">dirty_delete_object(Record)</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_delete_object_1"></a>
        <p>Calls <span class="code">mnesia:dirty_delete_object(Tab, Record)</span>,
          where <span class="code">Tab</span> is <span class="code">element(1, Record)</span>.</p>
      </p></div>
    <p><a name="dirty_delete_object-2"><span class="bold_code">dirty_delete_object(Tab, Record)</span></a><br></p>
<div class="REFBODY"><p>
        <p>Dirty equivalent of the function <span class="code">mnesia:delete_object/3</span>.</p>
      </p></div>
    <p><a name="dirty_first-1"><span class="bold_code">dirty_first(Tab) -&gt;  Key | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_first"></a>
        <p>Records in <span class="code">set</span> or <span class="code">bag</span> tables are not ordered. 
          However, there is an ordering of the records that is unknown
          to the user. Therefore, a table can be traversed by this
          function with the function <span class="code">mnesia:dirty_next/2</span>.
          </p>
        <p>If there are no records in the table, this function
          returns the atom <span class="code">'$end_of_table'</span>. It is therefore
          highly undesirable, but not disallowed, to use this atom
          as the key for any user records.</p>
      </p></div>
    <p><a name="dirty_index_match_object-2"><span class="bold_code">dirty_index_match_object(Pattern, Pos)</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_index_match_object_2"></a>
        <p>Starts
          <span class="code">mnesia:dirty_index_match_object(Tab, Pattern, Pos)</span>,
          where <span class="code">Tab</span> is <span class="code">element(1, Pattern)</span>.</p>
      </p></div>
    <p><a name="dirty_index_match_object-3"><span class="bold_code">dirty_index_match_object(Tab, Pattern, Pos)</span></a><br></p>
<div class="REFBODY"><p>
        <p>Dirty equivalent of the function
          <span class="code">mnesia:index_match_object/4</span>.</p>
      </p></div>
    <p><a name="dirty_index_read-3"><span class="bold_code">dirty_index_read(Tab, SecondaryKey, Pos)</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_index_read"></a>
        <p>Dirty equivalent of the function
          <span class="code">mnesia:index_read/3</span>.</p>
      </p></div>
    <p><a name="dirty_last-1"><span class="bold_code">dirty_last(Tab) -&gt; Key | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_last"></a>
        <p>Works exactly like <span class="code">mnesia:dirty_first/1</span> but returns
          the last object in Erlang term order for the <span class="code">ordered_set</span>
          table type. For all other table types,
          <span class="code">mnesia:dirty_first/1</span> and
          <span class="code">mnesia:dirty_last/1</span> are synonyms.</p>
      </p></div>
    <p><a name="dirty_match_object-1"><span class="bold_code">dirty_match_object(Pattern) -&gt; RecordList | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_match_object_1"></a>
        <p>Calls <span class="code">mnesia:dirty_match_object(Tab, Pattern)</span>,
          where <span class="code">Tab</span> is <span class="code">element(1, Pattern)</span>.</p>
      </p></div>
    <p><a name="dirty_match_object-2"><span class="bold_code">dirty_match_object(Tab, Pattern) -&gt; RecordList | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
        <p>Dirty equivalent of the function
          <span class="code">mnesia:match_object/3</span>.</p>
      </p></div>
    <p><a name="dirty_next-2"><span class="bold_code">dirty_next(Tab, Key) -&gt; Key | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_next"></a>
        <p>Traverses a table and
          performs operations on all records in the table.
          When the end of the table is reached, the special key
          <span class="code">'$end_of_table'</span> is returned. Otherwise, the function
          returns a key that can be used to read the actual record. The
          behavior is undefined if another Erlang process performs write
          operations on the table while it is being traversed with the
          function <span class="code">mnesia:dirty_next/2</span>.</p>
      </p></div>
    <p><a name="dirty_prev-2"><span class="bold_code">dirty_prev(Tab, Key) -&gt; Key | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_prev"></a>
        <p>Works exactly like <span class="code">mnesia:dirty_next/2</span> but returns
          the previous object in Erlang term order for the
          <span class="code">ordered_set</span> table type. For all other table types,
          <span class="code">mnesia:dirty_next/2</span> and
          <span class="code">mnesia:dirty_prev/2</span> are synonyms.</p>
      </p></div>
    <p><a name="dirty_read-1"><span class="bold_code">dirty_read({Tab, Key}) -&gt; ValueList | exit({aborted, Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_read"></a>
        <p>Calls <span class="code">mnesia:dirty_read(Tab, Key)</span>.</p>
      </p></div>
    <p><a name="dirty_read-2"><span class="bold_code">dirty_read(Tab, Key) -&gt; ValueList | exit({aborted, Reason}</span></a><br></p>
<div class="REFBODY"><p>
        <p>Dirty equivalent of the function <span class="code">mnesia:read/3</span>.</p>
      </p></div>
    <p><a name="dirty_select-2"><span class="bold_code">dirty_select(Tab, MatchSpec) -&gt; ValueList | exit({aborted, Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_select"></a>
        <p>Dirty equivalent of the function <span class="code">mnesia:select/2</span>.</p>
      </p></div>
    <p><a name="dirty_slot-2"><span class="bold_code">dirty_slot(Tab, Slot) -&gt; RecordList | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_slot"></a>
        <p>Traverses a table in a
          manner similar to the function <span class="code">mnesia:dirty_next/2</span>.
          A table has a number of slots that range from 0 (zero) to
          an unknown upper bound. The function
          <span class="code">mnesia:dirty_slot/2</span> returns the special atom
          <span class="code">'$end_of_table'</span> when the end of the table is reached.
          The behavior of this function is undefined if a write
          operation is performed on the table while it is being
          traversed.</p>
      </p></div>
    <p><a name="dirty_update_counter-2"><span class="bold_code">dirty_update_counter({Tab, Key}, Incr) -&gt; NewVal | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_update_counter"></a>
        <p>Calls <span class="code">mnesia:dirty_update_counter(Tab, Key, Incr)</span>.</p>
      </p></div>
    <p><a name="dirty_update_counter-3"><span class="bold_code">dirty_update_counter(Tab, Key, Incr) -&gt; NewVal | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
        <p><span class="code">Mnesia</span> has no special counter records. However,
          records of the form <span class="code">{Tab, Key, Integer}</span> can be used
          as (possibly disc-resident) counters when <span class="code">Tab</span> is a
          <span class="code">set</span>. This function updates a counter with a positive
          or negative number. However, counters can never become less
          than zero. There are two significant differences between
          this function and the action of first reading the record,
          performing the arithmetics, and then writing the record:</p>
        <ul>
          <li>It is much more efficient.
          </li>
          <li>
<span class="code">mnesia:dirty_update_counter/3</span> is performed
           as an atomic operation although it is not protected
           by a transaction.
          </li>
        </ul>
        <p>If two processes perform <span class="code">mnesia:dirty_update_counter/3</span>
          simultaneously, both updates take effect without the
          risk of losing one of the updates. The new value
          <span class="code">NewVal</span> of the counter is returned.</p>
        <p>If <span class="code">Key</span> do not exists, a new record is created with
          value <span class="code">Incr</span> if it is larger than 0, otherwise it is
          set to 0.</p>
      </p></div>
    <p><a name="dirty_write-1"><span class="bold_code">dirty_write(Record) -&gt; ok | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dirty_write_1"></a>
        <p>Calls <span class="code">mnesia:dirty_write(Tab, Record)</span>,
          where <span class="code">Tab</span> is <span class="code">element(1, Record)</span>.</p>
      </p></div>
    <p><a name="dirty_write-2"><span class="bold_code">dirty_write(Tab, Record) -&gt; ok | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
        <p>Dirty equivalent of the function <span class="code">mnesia:write/3</span>.</p>
      </p></div>
    <p><a name="dump_log-0"><span class="bold_code">dump_log() -&gt; dumped</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dump_log"></a>
        <p>Performs a user-initiated dump of the local log file.
          This is usually not necessary, as <span class="code">Mnesia</span> by default
          manages this automatically. See configuration parameters
          <span class="bold_code"><a href="#dump_log_time_threshold">dump_log_time_threshold</a></span>
          and
          <span class="bold_code"><a href="#dump_log_write_threshold">dump_log_write_threshold</a></span>.
          </p>
      </p></div>
    <p><a name="dump_tables-1"><span class="bold_code">dump_tables(TabList) -&gt; {atomic, ok} | {aborted, Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dump_tables"></a>
        <p>Dumps a set of <span class="code">ram_copies</span> tables
          to disc. The next time the system is started, these tables
          are initiated with the data found in the files that are the
          result of this dump. None of the tables can have
          disc-resident replicas.</p>
      </p></div>
    <p><a name="dump_to_textfile-1"><span class="bold_code">dump_to_textfile(Filename)</span></a><br></p>
<div class="REFBODY"><p>
      <a name="dump_to_textfile"></a>
        <p>Dumps all local tables of a <span class="code">Mnesia</span> system into a
          text file, which can be edited (by a normal text editor)
          and then be reloaded with
          <span class="code">mnesia:load_textfile/1</span>. Only use this function for
          educational purposes. Use other functions to deal with real
          backups.</p>
      </p></div>
    <p><a name="error_description-1"><span class="bold_code">error_description(Error) -&gt; String</span></a><br></p>
<div class="REFBODY"><p>
      <a name="error_description"></a>
        <p>All <span class="code">Mnesia</span> transactions, including all the schema
          update functions, either return value <span class="code">{atomic, Val}</span>
          or the tuple <span class="code">{aborted, Reason}</span>. <span class="code">Reason</span> can
          be either of the atoms in the following list. The
          function <span class="code">error_description/1</span> returns a descriptive
          string that describes the error.</p>
        <ul>
          <li>
<span class="code">nested_transaction</span>. Nested transactions are
           not allowed in this context.
          </li>
          <li>
<span class="code">badarg</span>. Bad or invalid argument, possibly
           bad type.
          </li>
          <li>
<span class="code">no_transaction</span>. Operation not allowed
           outside transactions.
          </li>
          <li>
<span class="code">combine_error</span>. Table options illegally
           combined.
          </li>
          <li>
<span class="code">bad_index</span>. Index already exists, or was out
           of bounds.
          </li>
          <li>
<span class="code">already_exists</span>. Schema option to be activated
           is already on.
          </li>
          <li>
<span class="code">index_exists</span>. Some operations cannot be
           performed on tables with an index.
          </li>
          <li>
<span class="code">no_exists</span>. Tried to perform operation on
           non-existing (not-alive) item.
          </li>
          <li>
<span class="code">system_limit</span>. A system limit was exhausted.
          </li>
          <li>
<span class="code">mnesia_down</span>. A transaction involves records
           on a remote node, which became unavailable before the
           transaction was completed. Records are no longer
           available elsewhere in the network.
          </li>
          <li>
<span class="code">not_a_db_node</span>. A node was mentioned that does
           not exist in the schema.
          </li>
          <li>
<span class="code">bad_type</span>. Bad type specified in argument.
          </li>
          <li>
<span class="code">node_not_running</span>. Node is not running.
          </li>
          <li>
<span class="code">truncated_binary_file</span>. Truncated binary in file.
          </li>
          <li>
<span class="code">active</span>. Some delete operations require that
           all active records are removed.
          </li>
          <li>
<span class="code">illegal</span>. Operation not supported on this
           record.
          </li>
        </ul>
        <p><span class="code">Error</span> can be <span class="code">Reason</span>,
          <span class="code">{error, Reason}</span>, or <span class="code">{aborted, Reason}</span>.
          <span class="code">Reason</span> can be an atom or a tuple with <span class="code">Reason</span>
          as an atom in the first field.</p>
        <p>The following examples illustrate a function that returns an error,
          and the method to retrieve more detailed error information:</p>
          <ul>
            <li>The function
             <span class="bold_code"><a href="#create_table-2">mnesia:create_table(bar, [{attributes, 3.14}])</a></span>
             returns the tuple <span class="code">{aborted,Reason}</span>, where <span class="code">Reason</span> is
             the tuple <span class="code">{bad_type,bar,3.14000}</span>.</li>
            <li>The function
             <span class="bold_code"><a href="#error_description-1">mnesia:error_description(Reason)</a></span>
             returns the term <span class="code">{"Bad type on some provided
             arguments",bar,3.14000}</span>, which is an error description
             suitable for display.</li>
      </ul>
      </p></div>
    <p><a name="ets-2"><span class="bold_code">ets(Fun, [, Args]) -&gt; ResultOfFun | exit(Reason)</span></a><br></p>
<div class="REFBODY"><p>
      <a name="ets"></a>
        <p>Calls the <span class="code">Fun</span> in a raw context that is not protected by
          a transaction. The <span class="code">Mnesia</span> function call is performed in
          the <span class="code">Fun</span> and performed directly on the local <span class="code">ets</span>
          tables on the assumption that the local storage type is
          <span class="code">ram_copies</span> and the tables are not replicated to other
          nodes. Subscriptions are not triggered and checkpoints are
          not updated, but it is extremely fast. This function can
          also be applied to <span class="code">disc_copies</span> tables if all
          operations are read only. For details, see
          <span class="code">mnesia:activity/4</span> and the User's Guide.</p>
        <p>Notice that calling (nesting) a <span class="code">mnesia:ets</span> inside a
          transaction-context inherits the transaction semantics.</p>
      </p></div>
    <p><a name="first-1"><span class="bold_code">first(Tab) -&gt;  Key | transaction abort</span></a><br></p>
<div class="REFBODY"><p>
      <a name="first"></a>
        <p>Records in <span class="code">set</span> or <span class="code">bag</span> tables are not ordered.
          However, there is an ordering of the records that is unknown
          to the user. A table can therefore be traversed by this
          function with the function <span class="code">mnesia:next/2</span>.</p>
        <p>If there are no records in the table, this function
          returns the atom <span class="code">'$end_of_table'</span>. It is therefore
          highly undesirable, but not disallowed, to use this atom
          as the key for any user records.</p>
      </p></div>
    <p><a name="foldl-3"><span class="bold_code">foldl(Function, Acc, Table) -&gt; NewAcc | transaction abort</span></a><br></p>
<div class="REFBODY"><p>
      <a name="foldl"></a>
        <p>Iterates over the table <span class="code">Table</span> and calls
          <span class="code">Function(Record, NewAcc)</span> for each <span class="code">Record</span> in
          the table. The term returned from <span class="code">Function</span> is used
          as the second argument in the next call to <span class="code">Function</span>.</p>
        <p><span class="code">foldl</span> returns the same term as the last call to
          <span class="code">Function</span> returned.</p>
      </p></div>
    <p><a name="foldr-3"><span class="bold_code">foldr(Function, Acc, Table) -&gt; NewAcc | transaction abort</span></a><br></p>
<div class="REFBODY"><p>
      <a name="foldr"></a>
        <p>Works exactly like <span class="code">foldl/3</span> but iterates the table
          in the opposite order for the <span class="code">ordered_set</span> table type.
          For all other table types, <span class="code">foldr/3</span> and
          <span class="code">foldl/3</span> are synonyms.</p>
      </p></div>
    <p><a name="force_load_table-1"><span class="bold_code">force_load_table(Tab) -&gt; yes | ErrorDescription</span></a><br></p>
<div class="REFBODY"><p>
      <a name="force_load_table"></a>
        <p>The <span class="code">Mnesia</span> algorithm for table load can lead to a
          situation where a table cannot be loaded. This situation
          occurs when a node is started and <span class="code">Mnesia</span> concludes, or
          suspects, that another copy of the table was active after
          this local copy became inactive because of a system crash.</p>
        <p>If this situation is not acceptable, this function can be
          used to override the strategy of the <span class="code">Mnesia</span> table
          load algorithm. This can lead to a situation where some
          transaction effects are lost with an inconsistent database as
          result, but for some applications high availability is more
          important than consistent data.</p>
      </p></div>
    <p><a name="index_match_object-2"><span class="bold_code">index_match_object(Pattern, Pos) -&gt; transaction abort | ObjList</span></a><br></p>
<div class="REFBODY"><p>
      <a name="index_match_object_2"></a>
        <p>Starts
          <span class="code">mnesia:index_match_object(Tab, Pattern, Pos, read)</span>,
          where <span class="code">Tab</span> is <span class="code">element(1, Pattern)</span>.</p>
      </p></div>
    <p><a name="index_match_object-4"><span class="bold_code">index_match_object(Tab, Pattern, Pos, LockKind) -&gt; transaction abort | ObjList</span></a><br></p>
<div class="REFBODY"><p>
      <a name="index_match_object_4"></a>
        <p>In a manner similar to the function <span class="code">mnesia:index_read/3</span>,
          any index information can be used when trying to match records.
          This function takes a pattern that obeys the same rules as the
          function <span class="code">mnesia:match_object/3</span>, except that this function
          requires the following conditions:</p>
        <ul>
          <li>
            <p>The table <span class="code">Tab</span> must have an index on
              position <span class="code">Pos</span>.</p>
          </li>
          <li>
            <p>The element in position <span class="code">Pos</span> in
              <span class="code">Pattern</span> must be bound. <span class="code">Pos</span> is
              an integer (<span class="code">#record.Field</span>) or an attribute name.</p>
          </li>
        </ul>
        <p>The two index search functions described here are
          automatically started when searching tables with <span class="code">qlc</span>
          list comprehensions and also when using the low-level
          <span class="code">mnesia:[dirty_]match_object</span> functions.</p>
        <p>The semantics of this function is context-sensitive.
          For details, see <span class="code">mnesia:activity/4</span>. In
          transaction-context, it acquires a lock of type
          <span class="code">LockKind</span> on the entire table or on a single record.
          Currently, the lock type <span class="code">read</span> is supported.</p>
      </p></div>
    <p><a name="index_read-3"><span class="bold_code">index_read(Tab, SecondaryKey, Pos) -&gt; transaction abort | RecordList</span></a><br></p>
<div class="REFBODY"><p>
      <a name="index_read"></a>
        <p>Assume that there is an index on position <span class="code">Pos</span> for a
          certain record type. This function can be used to read the
          records without knowing the actual key for the record. For
          example, with an index in position 1 of table <span class="code">person</span>,
          the call <span class="code">mnesia:index_read(person, 36, #person.age)</span>
          returns a list of all persons with age 36. <span class="code">Pos</span> can
          also be an attribute name (atom), but if the notation
          <span class="code">mnesia:index_read(person, 36, age)</span> is used, the
          field position is searched for in runtime, for each call.</p>
        <p>The semantics of this function is context-sensitive.
          For details, see <span class="code">mnesia:activity/4</span>. In
          transaction-context, it acquires a read lock on the entire
          table.</p>
      </p></div>
    <p><a name="info-0"><span class="bold_code">info() -&gt; ok</span></a><br></p>
<div class="REFBODY"><p>
      <a name="info"></a>
        <p>Prints system information on the terminal.
          This function can be used even if <span class="code">Mnesia</span> is not
          started. However, more information is displayed if
          <span class="code">Mnesia</span> is started.</p>
      </p></div>
    <p><a name="install_fallback-1"><span class="bold_code">install_fallback(Opaque) -&gt; ok | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="install_fallback_1"></a>
        <p>Calls <span class="code">mnesia:install_fallback(Opaque, Args)</span>, where
          <span class="code">Args</span> is <span class="code">[{scope, global}]</span>.</p>
      </p></div>
    <p><a name="install_fallback-1"><span class="bold_code">install_fallback(Opaque), BackupMod) -&gt; ok | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
        <p>Calls <span class="code">mnesia:install_fallback(Opaque, Args)</span>, where
          <span class="code">Args</span> is <span class="code">[{scope, global}, {module, BackupMod}]</span>.</p>
      </p></div>
    <p><a name="install_fallback-2"><span class="bold_code">install_fallback(Opaque, Args) -&gt; ok | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
        <p>Installs a backup as fallback. The fallback is used to
          restore the database at the next startup. Installation of
          fallbacks requires Erlang to be operational on all the
          involved nodes, but it does not matter if <span class="code">Mnesia</span>
          is running or not. The installation of the fallback fails
          if the local node is not one of the disc-resident nodes
          in the backup.</p>
        <p><span class="code">Args</span> is a list of the following tuples:</p>
        <ul>
          <li>
            <p><span class="code">{module, BackupMod}</span>.
              All accesses of the backup media are performed through
              a callback module named <span class="code">BackupMod</span>. Argument
              <span class="code">Opaque</span> is forwarded to the callback module,
              which can interpret it as it wishes. The default
              callback module is called <span class="code">mnesia_backup</span> and it
              interprets argument <span class="code">Opaque</span> as a local
              filename. The default for this module is also
              configurable through configuration parameter
              <span class="code">-mnesia mnesia_backup</span>.</p>
          </li>
          <li>
            <p><span class="code">{scope, Scope}</span>.
              The <span class="code">Scope</span> of a fallback is either
              <span class="code">global</span> for the entire database or <span class="code">local</span>
              for one node. By default, the installation of a fallback
              is a global operation, which either is performed on all
              nodes with a disc-resident schema or none. Which nodes
              that are disc-resident is determined from the
              schema information in the backup.</p>
            <p>If <span class="code">Scope</span> of the operation is <span class="code">local</span>,
              the fallback is only installed on the local node.</p>
          </li>
          <li>
            <p><span class="code">{mnesia_dir, AlternateDir}</span>.
              This argument is only valid if the scope of the
              installation is <span class="code">local</span>. Normally the installation
              of a fallback is targeted to the <span class="code">Mnesia</span> directory,
              as configured with configuration parameter
              <span class="code">-mnesia dir</span>. But by explicitly supplying an
              <span class="code">AlternateDir</span>, the fallback is installed there
              regardless of the <span class="code">Mnesia</span> directory configuration
              parameter setting. After installation of a fallback on
              an alternative <span class="code">Mnesia</span> directory, that directory
              is fully prepared for use as an active <span class="code">Mnesia</span>
              directory.</p>
            <p>This is a dangerous feature that must be
              used with care. By unintentional mixing of directories,
              you can easily end up with an inconsistent database, if
              the same backup is installed on more than one directory.</p>
          </li>
        </ul>
      </p></div>
    <p><a name="is_transaction-0"><span class="bold_code">is_transaction() -&gt; boolean</span></a><br></p>
<div class="REFBODY"><p>
      <a name="is_transaction"></a>
        <p>When this function is executed inside a transaction-context,
          it returns <span class="code">true</span>, otherwise <span class="code">false</span>.</p>
      </p></div>
    <p><a name="last-1"><span class="bold_code">last(Tab) -&gt; Key | transaction abort</span></a><br></p>
<div class="REFBODY"><p>
        <p>Works exactly like
          <span class="code">mnesia:first/1</span>, but returns the last object in
          Erlang term order for the <span class="code">ordered_set</span> table type.
          For all other table types, <span class="code">mnesia:first/1</span> and
          <span class="code">mnesia:last/1</span> are synonyms.</p>
      </p></div>
    <p><a name="load_textfile-1"><span class="bold_code">load_textfile(Filename)</span></a><br></p>
<div class="REFBODY"><p>
      <a name="load_textfile"></a>
        <p>Loads a series of definitions and data found in the
          text file (generated with <span class="code">mnesia:dump_to_textfile/1</span>)
          into <span class="code">Mnesia</span>. This function also starts <span class="code">Mnesia</span>
          and possibly creates a new schema. This function is
          intended for educational purposes only. It is recommended
          to use other functions to deal with real backups.</p>
      </p></div>
    <p><a name="lock-2"><span class="bold_code">lock(LockItem, LockKind) -&gt; Nodes | ok | transaction abort</span></a><br></p>
<div class="REFBODY"><p>
      <a name="lock"></a>
        <p>Write locks are normally acquired on all nodes where a
          replica of the table resides (and is active). Read locks
          are acquired on one node (the local node if a local
          replica exists). Most of the context-sensitive access
          functions acquire an implicit lock if they are started in a
          transaction-context. The granularity of a lock can either
          be a single record or an entire table.</p>
        <p>The normal use is to call the function without checking
          the return value, as it exits if it fails and the
          transaction is restarted by the transaction manager. It
          returns all the locked nodes if a write lock is acquired
          and <span class="code">ok</span> if it was a read lock.</p>
        <p>The function <span class="code">mnesia:lock/2</span> is intended to support
          explicit locking on tables, but is also intended for
          situations when locks need to be acquired regardless of
          how tables are replicated. Currently, two kinds of
          <span class="code">LockKind</span> are supported:</p>
        <dl>
          <dt><strong><span class="code">write</span></strong></dt>
          <dd>
            <p>Write locks are exclusive. This means that if one
              transaction manages to acquire a write lock on an item,
              no other transaction can acquire any kind of lock on
              the same item.</p>
          </dd>
          <dt><strong><span class="code">read</span></strong></dt>
          <dd>
            <p>Read locks can be shared. This means that if one
              transaction manages to acquire a read lock on an item,
              other transactions can also acquire a read lock on the
              same item. However, if someone has a read lock, no one
              can acquire a write lock at the same item. If someone
              has a write lock, no one can acquire either a read lock
              or a write lock at the same item.</p>
          </dd>
        </dl>
        <p>Conflicting lock requests are automatically queued if there
          is no risk of a deadlock. Otherwise the transaction must be
          terminated and executed again. <span class="code">Mnesia</span> does this
          automatically as long as the upper limit of the maximum
          <span class="code">retries</span> is not reached. For details, see
          <span class="code">mnesia:transaction/3</span>.</p>
        <p>For the sake of completeness, sticky write locks are also
          described here even if a sticky write lock is not
          supported by this function:</p>
        <dl>
          <dt><strong><span class="code">sticky_write</span></strong></dt>
          <dd>
            <p>Sticky write locks are a mechanism that can be used
              to optimize write lock acquisition. If your application
              uses replicated tables mainly for fault tolerance (as
              opposed to read access optimization purpose), sticky
              locks can be the best option available.</p>
            <p>When a sticky write lock is acquired, all nodes are
              informed which node is locked. Then,
              sticky lock requests from the same node are
              performed as a local operation without any
              communication with other nodes. The sticky lock
              lingers on the node even after the transaction
              ends. For details, see the User's Guide.</p>
          </dd>
        </dl>
        <p>Currently, this function supports two kinds of
          <span class="code">LockItem</span>:</p>
        <dl>
          <dt><strong><span class="code">{table, Tab}</span></strong></dt>
          <dd>
            <p>This acquires a lock of type <span class="code">LockKind</span> on the
              entire table <span class="code">Tab</span>.</p>
          </dd>
          <dt><strong><span class="code">{global, GlobalKey, Nodes}</span></strong></dt>
          <dd>
            <p>This acquires a lock of type <span class="code">LockKind</span> on the
              global resource <span class="code">GlobalKey</span>. The lock is acquired
              on all active nodes in the <span class="code">Nodes</span> list.</p>
          </dd>
        </dl>
        <p>Locks are released when the outermost transaction ends.</p>
        <p>The semantics of this function is context-sensitive.
          For details, see <span class="code">mnesia:activity/4</span>. In
          transaction-context, it acquires locks, otherwise it
          ignores the request.</p>
      </p></div>
    <p><a name="match_object-1"><span class="bold_code">match_object(Pattern) -&gt; transaction abort | RecList</span></a><br></p>
<div class="REFBODY"><p>
      <a name="match_object_1"></a>
        <p>Calls <span class="code">mnesia:match_object(Tab, Pattern, read)</span>, where
          <span class="code">Tab</span> is <span class="code">element(1, Pattern)</span>.</p>
      </p></div>
    <p><a name="match_object-3"><span class="bold_code">match_object(Tab, Pattern, LockKind) -&gt; transaction abort | RecList</span></a><br></p>
<div class="REFBODY"><p>
      <a name="match_object_3"></a>
        <p>Takes a pattern with "don't care" variables
          denoted as a <span class="code">'_'</span> parameter. This function returns
          a list of records that matched the pattern.
          Since the second element
          of a record in a table is considered to be the key for the
          record, the performance of this function depends on whether
          this key is bound or not.</p>
        <p>For example, the call <span class="code">mnesia:match_object(person,
          {person, '_', 36, '_', '_'}, read)</span> returns a list of
          all person records with an <span class="code">age</span> field of 36.</p>
        <p>The function <span class="code">mnesia:match_object/3</span>
          automatically uses indexes if these exist. However, no
          heuristics are performed to select the best index.</p>
        <p>The semantics of this function is context-sensitive.
          For details, see <span class="code">mnesia:activity/4</span>. In
          transaction-context, it acquires a lock of type
          <span class="code">LockKind</span> on the entire table or a single record.
          Currently, the lock type <span class="code">read</span> is supported.</p>
      </p></div>
    <p><a name="move_table_copy-3"><span class="bold_code">move_table_copy(Tab, From, To) -&gt; {aborted, Reason} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="move_table_copy"></a>
        <p>Moves the copy of table <span class="code">Tab</span> from node
          <span class="code">From</span> to node <span class="code">To</span>.</p>
        <p>The storage type is preserved. For example, a RAM table
          moved from one node remains a RAM on the new node. Other
          transactions can still read and write in
          the table while it is being moved.</p>
        <p>This function cannot be used on <span class="code">local_content</span> tables.</p>
      </p></div>
    <p><a name="next-2"><span class="bold_code">next(Tab, Key) -&gt; Key | transaction abort</span></a><br></p>
<div class="REFBODY"><p>
      <a name="next"></a>
        <p>Traverses a table and
          performs operations on all records in the table. When
          the end of the table is reached, the special key
          <span class="code">'$end_of_table'</span> is returned. Otherwise the function
          returns a key that can be used to read the actual record.</p>
      </p></div>
    <p><a name="prev-2"><span class="bold_code">prev(Tab, Key) -&gt; Key | transaction abort</span></a><br></p>
<div class="REFBODY"><p>
        <p>Works exactly like
          <span class="code">mnesia:next/2</span>, but returns the previous object in
          Erlang term order for the <span class="code">ordered_set</span> table type.
          For all other table types, <span class="code">mnesia:next/2</span> and
          <span class="code">mnesia:prev/2</span> are synonyms.</p>
      </p></div>
    <p><a name="read-1"><span class="bold_code">read({Tab, Key}) -&gt; transaction abort | RecordList</span></a><br></p>
<div class="REFBODY"><p>
      <a name="read_2"></a>
        <p>Calls function <span class="code">mnesia:read(Tab, Key, read)</span>.</p>
      </p></div>
    <p><a name="read-2"><span class="bold_code">read(Tab, Key) -&gt; transaction abort | RecordList</span></a><br></p>
<div class="REFBODY"><p>
        <p>Calls function <span class="code">mnesia:read(Tab, Key, read)</span>.</p>
      </p></div>
    <p><a name="read-3"><span class="bold_code">read(Tab, Key, LockKind) -&gt; transaction abort | RecordList</span></a><br></p>
<div class="REFBODY"><p>
      <a name="read_3"></a>
        <p>Reads all records from table <span class="code">Tab</span> with
          key <span class="code">Key</span>. This function has the same semantics
          regardless of the location of <span class="code">Tab</span>. If the table is
          of type <span class="code">bag</span>, the function
          <span class="code">mnesia:read(Tab, Key)</span> can
          return an arbitrarily long list. If the table is of type
          <span class="code">set</span>, the list is either of length 1, or <span class="code">[]</span>.</p>
        <p>The semantics of this function is context-sensitive.
          For details, see <span class="code">mnesia:activity/4</span>. In
          transaction-context, it acquires a lock of type
          <span class="code">LockKind</span>. Currently, the lock types <span class="code">read</span>,
          <span class="code">write</span>, and <span class="code">sticky_write</span> are supported.</p>
        <p>If the user wants to update the record, it is more
          efficient to use <span class="code">write/sticky_write</span> as the
          <span class="code">LockKind</span>. If majority checking is active on the
          table, it is checked as soon as a write lock is
          attempted. This can be used to end quickly if the
          majority condition is not met.</p>
      </p></div>
    <p><a name="read_lock_table-1"><span class="bold_code">read_lock_table(Tab) -&gt; ok | transaction abort</span></a><br></p>
<div class="REFBODY"><p>
      <a name="read_lock_table"></a>
        <p>Calls the function
          <span class="code">mnesia:lock({table, Tab}, read)</span>.</p>
      </p></div>
    <p><a name="report_event-1"><span class="bold_code">report_event(Event) -&gt; ok</span></a><br></p>
<div class="REFBODY"><p>
      <a name="report_event"></a>
        <p>When tracing a system of <span class="code">Mnesia</span> applications it is
          useful to be able to interleave <span class="code">Mnesia</span> own events with
          application-related events that give information about the
          application context.</p>
        <p>Whenever the application begins a
          new and demanding <span class="code">Mnesia</span> task, or if it enters a new
          interesting phase in its execution, it can be a good idea to
          use <span class="code">mnesia:report_event/1</span>. <span class="code">Event</span> can be
          any term and generates a <span class="code">{mnesia_user, Event}</span> event
          for any processes that subscribe to <span class="code">Mnesia</span> system
          events.</p>
      </p></div>
    <p><a name="restore-2"><span class="bold_code">restore(Opaque, Args) -&gt; {atomic, RestoredTabs} |{aborted, Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="restore"></a>
        <p>With this function, tables can be restored online from a
          backup without restarting <span class="code">Mnesia</span>.
          <span class="code">Opaque</span> is forwarded to the backup module.
          <span class="code">Args</span> is a list of the following tuples:</p>
        <ul>
          <li>
            <span class="code">{module,BackupMod}</span>. The backup module
              <span class="code">BackupMod</span> is used to access the backup media.
              If omitted, the default backup module is used.
          </li>
          <li>
<span class="code">{skip_tables, TabList}</span>, where <span class="code">TabList</span>
           is a list of tables that is not to be read from the
           backup.
          </li>
          <li>
<span class="code">{clear_tables, TabList}</span>, where
          <span class="code">TabList</span> is a list of tables that is to be
           cleared before the records from the backup are inserted.
           That is, all records in the tables are deleted before the
           tables are restored. Schema information about the tables
           is not cleared or read from the backup.
          </li>
          <li>
<span class="code">{keep_tables, TabList}</span>, where <span class="code">TabList</span>
           is a list of tables that is not to be cleared before the
           records from the backup are inserted. That is, the records
           in the backup are added to the records in the table.
           Schema information about the tables is not cleared or read
           from the backup.
          </li>
          <li>
<span class="code">{recreate_tables, TabList}</span>, where
           <span class="code">TabList</span> is a list of tables that is to be
           recreated before the records from the backup are inserted.
           The tables are first deleted and then created with the
           schema information from the backup. All the nodes in the
           backup need to be operational.
          </li>
          <li>
<span class="code">{default_op, Operation}</span>, where <span class="code">Operation</span>
           is either of the operations <span class="code">skip_tables</span>,
           <span class="code">clear_tables</span>, <span class="code">keep_tables</span>, or
           <span class="code">recreate_tables</span>. The default operation specifies
           which operation that is to be used on tables from the backup
           that is not specified in any of the mentioned lists. If
           omitted, operation <span class="code">clear_tables</span> is used.
          </li>
        </ul>
        <p>The affected tables are write-locked during the
          restoration. However, regardless of the lock conflicts caused
          by this, the applications can continue to do their work while
          the restoration is being performed. The restoration is
          performed as one single transaction.</p>
        <p>If the database is huge,
          it it not always possible to restore it online. In such
          cases, restore the old database by installing a
          fallback and then restart.</p>
      </p></div>
    <p><a name="s_delete-1"><span class="bold_code">s_delete({Tab, Key}) -&gt; ok | transaction abort</span></a><br></p>
<div class="REFBODY"><p>
      <a name="s_delete"></a>
        <p>Calls the function
          <span class="code">mnesia:delete(Tab, Key, sticky_write)</span></p>
      </p></div>
    <p><a name="s_delete_object-1"><span class="bold_code">s_delete_object(Record) -&gt; ok | transaction abort</span></a><br></p>
<div class="REFBODY"><p>
      <a name="s_delete_object"></a>
        <p>Calls the function
          <span class="code">mnesia:delete_object(Tab, Record, sticky_write)</span>,
          where <span class="code">Tab</span> is <span class="code">element(1, Record)</span>.</p>
      </p></div>
    <p><a name="s_write-1"><span class="bold_code">s_write(Record) -&gt; ok | transaction abort</span></a><br></p>
<div class="REFBODY"><p>
      <a name="s_write"></a>
        <p>Calls the function
          <span class="code">mnesia:write(Tab, Record, sticky_write)</span>,
          where <span class="code">Tab</span> is <span class="code">element(1, Record)</span>.</p>
      </p></div>
    <p><a name="schema-0"><span class="bold_code">schema() -&gt; ok</span></a><br></p>
<div class="REFBODY"><p>
        <p>Prints information about all table definitions on the terminal.</p>
      </p></div>
    <p><a name="schema-1"><span class="bold_code">schema(Tab) -&gt; ok</span></a><br></p>
<div class="REFBODY"><p>
        <p>Prints information about one table definition on the terminal.</p>
      </p></div>
    <p><a name="select-2"><span class="bold_code">select(Tab, MatchSpec [, Lock]) -&gt; transaction abort | [Object]</span></a><br></p>
<div class="REFBODY"><p>
      <a name="select_2_3"></a>
        <p>Matches the objects in table <span class="code">Tab</span> using a
          <span class="code">match_spec</span> as described in the
          <span class="bold_code"><a href="ets.html#select-3">ets:select/3</a></span>.
          Optionally a lock
          <span class="code">read</span> or <span class="code">write</span> can be given as the third
          argument. Default is <span class="code">read</span>. The return value depends
          on <span class="code">MatchSpec</span>.</p>
        <p>Notice that for best performance, <span class="code">select</span> is to be
          used before any modifying operations are done on that table
          in the same transaction. That is, do not use <span class="code">write</span>
          or <span class="code">delete</span> before a <span class="code">select</span>.</p>
        <p>In its simplest forms, the <span class="code">match_spec</span> look as
          follows:</p>
        <ul>
          <li><span class="code">MatchSpec = [MatchFunction]</span></li>
          <li><span class="code">MatchFunction = {MatchHead, [Guard], [Result]}</span></li>
          <li><span class="code">MatchHead = tuple() | record()</span></li>
          <li><span class="code">Guard =  {"Guardtest name", ...}</span></li>
          <li><span class="code">Result = "Term construct"</span></li>
        </ul>
        <p>For a complete description of <span class="code">select</span>, see the
          <span class="bold_code"><a href="../apps/erts/index.html">ERTS</a></span> User's Guide and the
          <span class="bold_code"><a href="ets.html">ets</a></span> manual page in
          <span class="code">STDLIB</span>.</p>
        <p>For example, to find the names of all male persons older
          than 30 in table <span class="code">Tab</span>:</p>
        <div class="example"><pre>
MatchHead = #person{name='$1', sex=male, age='$2', _='_'},
Guard = {'&gt;', '$2', 30},
Result = '$1',
mnesia:select(Tab,[{MatchHead, [Guard], [Result]}]),</pre></div>
      </p></div>
    <p><a name="select-4"><span class="bold_code">select(Tab, MatchSpec, NObjects, Lock) -&gt; transaction abort | {[Object],Cont} | '$end_of_table'</span></a><br></p>
<div class="REFBODY"><p>
      <a name="select_4"></a>
        <p>Matches the objects in table <span class="code">Tab</span> using a
          <span class="code">match_spec</span> as described in the
          <span class="bold_code"><a href="../apps/erts/index.html">ERTS</a></span> User's Guide,
          and returns a chunk of terms and a continuation.
          The wanted number of returned terms is specified by
          argument <span class="code">NObjects</span>. The lock argument can be
          <span class="code">read</span> or <span class="code">write</span>. The continuation is to be
          used as argument to <span class="code">mnesia:select/1</span>,
          if more or all answers are needed.</p>
        <p>Notice that for best performance, <span class="code">select</span> is to be
          used before any modifying operations are done on that table
          in the same transaction. That is, do not use
          <span class="code">mnesia:write</span> or <span class="code">mnesia:delete</span> before a
          <span class="code">mnesia:select</span>. For efficiency, <span class="code">NObjects</span> is
          a recommendation only and the result can contain anything
          from an empty list to all available results.</p>
      </p></div>
    <p><a name="select-1"><span class="bold_code">select(Cont) -&gt; transaction abort | {[Object],Cont} | '$end_of_table'</span></a><br></p>
<div class="REFBODY"><p>
        <p>Selects more objects with the match specification initiated
          by <span class="code">mnesia:select/4</span>.</p>
        <p>Notice that any modifying operations, that is,
          <span class="code">mnesia:write</span> or <span class="code">mnesia:delete</span>, that are done
          between the <span class="code">mnesia:select/4</span> and <span class="code">mnesia:select/1</span>
          calls are not visible in the result.</p>
      </p></div>
    <p><a name="set_debug_level-1"><span class="bold_code">set_debug_level(Level) -&gt; OldLevel</span></a><br></p>
<div class="REFBODY"><p>
      <a name="set_debug_level"></a>
        <p>Changes the internal debug level of <span class="code">Mnesia</span>.
          For details, see
          <span class="bold_code"><a href="#configuration_parameters">Section
          Configuration Parameters</a></span>.</p>
      </p></div>
    <p><a name="set_master_nodes-1"><span class="bold_code">set_master_nodes(MasterNodes) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="set_master_nodes_1"></a>
        <p>For each table <span class="code">Mnesia</span> determines its replica nodes
          (<span class="code">TabNodes</span>) and starts
          <span class="code">mnesia:set_master_nodes(Tab, TabMasterNodes)</span>. where
          <span class="code">TabMasterNodes</span> is the intersection of
          <span class="code">MasterNodes</span> and <span class="code">TabNodes</span>. For semantics, see
          <span class="code">mnesia:set_master_nodes/2</span>.</p>
      </p></div>
    <p><a name="set_master_nodes-2"><span class="bold_code">set_master_nodes(Tab, MasterNodes) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="set_master_nodes_2"></a>
        <p>If the application detects a
          communication failure (in a potentially partitioned network)
          that can have caused an inconsistent database, it can use the
          function <span class="code">mnesia:set_master_nodes(Tab, MasterNodes)</span> to
          define from which nodes each table is to be loaded.
          At startup, the <span class="code">Mnesia</span> normal table load algorithm is
          bypassed and the table is loaded from one of the master nodes
          defined for the table, regardless of when and if <span class="code">Mnesia</span>
          terminated on other nodes. <span class="code">MasterNodes</span> can only
          contain nodes where the table has a replica. If the
          <span class="code">MasterNodes</span> list is empty, the master node recovery
          mechanism for the particular table is reset, and the
          normal load mechanism is used at the next restart.</p>
        <p>The master node setting is always local. It can be
          changed regardless if <span class="code">Mnesia</span> is started or not.</p>
        <p>The database can also become inconsistent if
          configuration parameter <span class="code">max_wait_for_decision</span> is used
          or if <span class="code">mnesia:force_load_table/1</span> is used.</p>
      </p></div>
    <p><a name="snmp_close_table-1"><span class="bold_code">snmp_close_table(Tab) -&gt; {aborted, R} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
        <p>Removes the possibility for SNMP to manipulate the table.</p>
      </p></div>
    <p><a name="snmp_get_mnesia_key-2"><span class="bold_code">snmp_get_mnesia_key(Tab, RowIndex) -&gt; {ok, Key} | undefined</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Tab ::= atom()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">RowIndex ::= [integer()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Key ::= key() | {key(), key(), ...}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">key() ::= integer() | string() | [integer()]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Transforms an SNMP index to the corresponding <span class="code">Mnesia</span>
          key. If the SNMP table has multiple keys, the key is a tuple
          of the key columns.</p>
      </p></div>
    <p><a name="snmp_get_next_index-2"><span class="bold_code">snmp_get_next_index(Tab, RowIndex) -&gt; {ok, NextIndex} | endOfTable</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Tab ::= atom()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">RowIndex ::= [integer()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NextIndex ::= [integer()]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p><span class="code">RowIndex</span> can specify a non-existing row.
          Specifically, it can be the empty list. Returns the index
          of the next lexicographical row. If <span class="code">RowIndex</span> is the
          empty list, this function returns the index of the first row
          in the table.</p>
      </p></div>
    <p><a name="snmp_get_row-2"><span class="bold_code">snmp_get_row(Tab, RowIndex) -&gt; {ok, Row} | undefined</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Tab ::= atom()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">RowIndex ::= [integer()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Row ::= record(Tab)</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Reads a row by its SNMP index. This index is specified as
          an SNMP Object Identifier, a list of integers.</p>
      </p></div>
    <p><a name="snmp_open_table-2"><span class="bold_code">snmp_open_table(Tab, SnmpStruct) -&gt; {aborted, R} | {atomic, ok}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Tab ::= atom()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">SnmpStruct ::= [{key, type()}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">type() ::= type_spec() | {type_spec(), type_spec(), ...}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">type_spec() ::= fix_string | string | integer</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>A direct one-to-one mapping can be established between
          <span class="code">Mnesia</span> tables and SNMP tables. Many telecommunication
          applications are controlled and monitored by the SNMP
          protocol. This connection between <span class="code">Mnesia</span> and SNMP
          makes it simple and convenient to achieve this mapping.</p>
        <p>Argument <span class="code">SnmpStruct</span> is a list of SNMP
          information. Currently, the only information needed is
          information about the key types in the table. Multiple
          keys cannot be handled in <span class="code">Mnesia</span>, but many SNMP
          tables have multiple keys. Therefore, the following
          convention is used: if a table has multiple keys, these must
          always be stored as a tuple of the keys. Information about
          the key types is specified as a tuple of atoms describing
          the types. The only significant type is <span class="code">fix_string</span>.
          This means that a string has a fixed size.</p>
        <p>For example, the following causes table <span class="code">person</span>
          to be ordered as an SNMP table:</p>
        <div class="example"><pre>
mnesia:snmp_open_table(person, [{key, string}])</pre></div>
        <p>Consider the following schema for a table of company
          employees. Each employee is identified by department number
          and name. The other table column stores the telephone
          number:</p>
        <div class="example"><pre>
mnesia:create_table(employee,
    [{snmp, [{key, {integer, string}}]},
     {attributes, record_info(fields, employees)}]),</pre></div>
        <p>The corresponding SNMP table would have three columns:
          <span class="code">department</span>, <span class="code">name</span>, and <span class="code">telno</span>.</p>
        <p>An option is to have table columns that are not visible
          through the SNMP protocol. These columns must be the last
          columns of the table. In the previous example, the SNMP
          table could have columns <span class="code">department</span> and <span class="code">name</span>
          only. The application could then use column <span class="code">telno</span>
          internally, but it would not be visible to the SNMP
          managers.</p>
        <p>In a table monitored by SNMP, all elements must be
          integers, strings, or lists of integers.</p>
        <p>When a table is SNMP ordered, modifications are more
          expensive than usual, O(logN). Also, more memory is used.</p>
        <p>Notice that only the lexicographical SNMP ordering is
          implemented in <span class="code">Mnesia</span>, not the actual SNMP monitoring.</p>
      </p></div>
    <p><a name="start-0"><span class="bold_code">start() -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="start"></a>
        <p>The startup procedure for a set of <span class="code">Mnesia</span> nodes is a
          fairly complicated operation. A <span class="code">Mnesia</span> system consists
          of a set of nodes, with <span class="code">Mnesia</span> started locally on all
          participating nodes. Normally, each node has a directory where
          all the <span class="code">Mnesia</span> files are written. This directory is
          referred to as the <span class="code">Mnesia</span> directory. <span class="code">Mnesia</span> can
          also be started on disc-less nodes. For more information
          about disc-less nodes, see <span class="code">mnesia:create_schema/1</span>
          and the User's Guide.</p>
        <p>The set of nodes that makes up a <span class="code">Mnesia</span> system is kept
          in a schema. <span class="code">Mnesia</span> nodes can be added to or removed
          from the schema. The initial schema is normally created on
          disc with the function <span class="code">mnesia:create_schema/1</span>. On
          disc-less nodes, a tiny default schema is generated each time
          <span class="code">Mnesia</span> is started. During the startup procedure,
          <span class="code">Mnesia</span> exchanges schema information between the nodes
          to verify that the table definitions are compatible.</p>
        <p>Each schema has a unique cookie, which can be regarded as a
          unique schema identifier. The cookie must be the same on all
          nodes where <span class="code">Mnesia</span> is supposed to run. For details,
          see the User's Guide.</p>
        <p>The schema file and all other files that <span class="code">Mnesia</span>
          needs are kept in the <span class="code">Mnesia</span> directory. The
          command-line option <span class="code">-mnesia dir Dir</span> can be used to
          specify the location of this directory to the <span class="code">Mnesia</span>
          system. If no such command-line option is found, the name
          of the directory defaults to <span class="code">Mnesia.Node</span>.</p>
        <p><span class="code">application:start(mnesia)</span> can also be used.</p>
      </p></div>
    <p><a name="stop-0"><span class="bold_code">stop() -&gt; stopped</span></a><br></p>
<div class="REFBODY"><p>
      <a name="stop"></a>
        <p>Stops <span class="code">Mnesia</span> locally on the current node.</p>
        <p><span class="code">application:stop(mnesia)</span> can also be used.</p>
      </p></div>
    <p><a name="subscribe-1"><span class="bold_code">subscribe(EventCategory) -&gt; {ok, Node} | {error, Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="subscribe"></a>
        <p>Ensures that a copy of all events of type
          <span class="code">EventCategory</span> is sent to the caller. The available
          event types are described in the <span class="bold_code"><a href="../apps/mnesia/Mnesia_chap5.html#event_handling">User's Guide</a></span>.</p>
      </p></div>
    <p><a name="sync_dirty-2"><span class="bold_code">sync_dirty(Fun, [, Args]) -&gt; ResultOfFun | exit(Reason)</span></a><br></p>
<div class="REFBODY"><p>
      <a name="sync_dirty"></a>
        <p>Calls the <span class="code">Fun</span> in a context that is not protected by
          a transaction. The <span class="code">Mnesia</span> function calls performed in
          the <span class="code">Fun</span> are mapped to the corresponding dirty functions.
          It is performed in almost the same context as
          <span class="code">mnesia:async_dirty/1,2</span>. The difference is that the
          operations are performed synchronously. The caller waits for
          the updates to be performed on all active replicas before
          the <span class="code">Fun</span> returns. For details, see
          <span class="code">mnesia:activity/4</span> and the User's Guide.</p>
      </p></div>
    <p><a name="sync_log-0"><span class="bold_code">sync_log() -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY"><p>
        <p>Ensures that the local transaction log file is synced to disk.
          On a single node system, data written to disk tables since the
          last dump can be lost if there is a power outage.
          See <span class="bold_code"><a href="#dump_log-0">dump_log/0</a></span>.</p>
      </p></div>
    <p><a name="sync_transaction-3"><span class="bold_code">sync_transaction(Fun, [[, Args], Retries]) -&gt; {aborted, Reason} | {atomic, ResultOfFun}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="sync_transaction"></a>
        <p>Waits until data have been committed and
          logged to disk (if disk is used) on every involved node before
          it returns, otherwise it behaves as
          <span class="code">mnesia:transaction/[1,2,3]</span>.</p>
        <p>This functionality can be used to avoid that one process
          overloads a database on another node.</p>
      </p></div>
    <p><a name="system_info-1"><span class="bold_code">system_info(InfoKey) -&gt; Info | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
      <a name="system_info"></a>
        <p>Returns information about the <span class="code">Mnesia</span> system, such as
          transaction statistics, <span class="code">db_nodes</span>, and configuration
          parameters. The valid keys are as follows:</p>
        <ul>
          <li>
            <p><span class="code">all</span>. Returns a list of all local system
              information. Each element is a <span class="code">{InfoKey, InfoVal}</span>
              tuple.</p>
            <p>New <span class="code">InfoKey</span>s can be added and old
              undocumented <span class="code">InfoKey</span>s can be removed without
              notice.</p>
          </li>
          <li>
            <p><span class="code">access_module</span>. Returns the name of module that is
              configured to be the activity access callback module.</p>
          </li>
          <li>
            <p><span class="code">auto_repair</span>. Returns <span class="code">true</span> or <span class="code">false</span>
              to indicate if <span class="code">Mnesia</span> is configured to start the
              auto-repair facility on corrupted disc files.</p>
          </li>
          <li>
            <p><span class="code">backup_module</span>. Returns the name of the module
              that is configured to be the backup callback module.</p>
          </li>
          <li>
            <p><span class="code">checkpoints</span>. Returns a list of the names of the
              checkpoints currently active on this node.</p>
          </li>
          <li>
            <p><span class="code">event_module</span>. Returns the name of the module
              that is the event handler callback module.</p>
          </li>
          <li>
            <p><span class="code">db_nodes</span>. Returns the nodes that make up the
              persistent database. Disc-less nodes are only included
              in the list of nodes if they explicitly have been added
              to the schema, for example, with
              <span class="code">mnesia:add_table_copy/3</span>. The function can be
              started even if <span class="code">Mnesia</span> is not yet running.</p>
          </li>
          <li>
            <p><span class="code">debug</span>. Returns the current debug level of
              <span class="code">Mnesia</span>.</p>
          </li>
          <li>
            <p><span class="code">directory</span>. Returns the name of the <span class="code">Mnesia</span>
              directory. It can be called even if <span class="code">Mnesia</span> is
              not yet running.</p>
          </li>
          <li>
            <p><span class="code">dump_log_load_regulation</span>. Returns a boolean that
              tells if <span class="code">Mnesia</span> is configured to regulate the
              dumper process load.</p>
            <p>This feature is temporary and will be removed in future
              releases.</p>
          </li>
          <li>
            <p><span class="code">dump_log_time_threshold</span>. Returns the time
              threshold for transaction log dumps in milliseconds.</p>
          </li>
          <li>
            <p><span class="code">dump_log_update_in_place</span>. Returns a boolean that
              tells if <span class="code">Mnesia</span> is configured to perform the
              updates in the <span class="code">dets</span> files directly, or if the
              updates are to be performed in a copy of the <span class="code">dets</span>
              files.</p>
          </li>
          <li>
            <p><span class="code">dump_log_write_threshold</span>.
              Returns the write threshold for transaction log dumps as
              the number of writes to the transaction log.</p>
          </li>
          <li>
            <p><span class="code">extra_db_nodes</span>. Returns a list
              of extra <span class="code">db_nodes</span> to be contacted at startup.</p>
          </li>
          <li>
            <p><span class="code">fallback_activated</span>. Returns <span class="code">true</span>
              if a fallback is activated, otherwise <span class="code">false</span>.</p>
          </li>
          <li>
            <p><span class="code">held_locks</span>. Returns a list of all
              locks held by the local <span class="code">Mnesia</span> lock manager.</p>
          </li>
          <li>
            <p><span class="code">is_running</span>. Returns <span class="code">yes</span> or <span class="code">no</span> to
              indicate if <span class="code">Mnesia</span> is running. It can
              also return <span class="code">starting</span> or <span class="code">stopping</span>. Can be
              called even if <span class="code">Mnesia</span> is not yet running.</p>
          </li>
          <li>
            <p><span class="code">local_tables</span>. Returns a list
              of all tables that are configured to reside locally.</p>
          </li>
          <li>
            <p><span class="code">lock_queue</span>. Returns a list of
              all transactions that are queued for execution by the
              local lock manager.</p>
          </li>
          <li>
            <p><span class="code">log_version</span>. Returns the version
              number of the <span class="code">Mnesia</span> transaction log format.</p>
          </li>
          <li>
            <p><span class="code">master_node_tables</span>. Returns a
              list of all tables with at least one master node.</p>
          </li>
          <li>
            <p><span class="code">protocol_version</span>. Returns the version number of
              the <span class="code">Mnesia</span> inter-process communication protocol.</p>
          </li>
          <li>
            <p><span class="code">running_db_nodes</span>. Returns a list of nodes where
              <span class="code">Mnesia</span> currently is running. This function can be
              called even if <span class="code">Mnesia</span> is not yet running, but it
              then has slightly different semantics.</p>
            <p>If <span class="code">Mnesia</span> is down on the local node, the function
              returns those other <span class="code">db_nodes</span> and
              <span class="code">extra_db_nodes</span> that for the moment are
              operational.</p>
            <p>If <span class="code">Mnesia</span> is started, the function returns
              those nodes that <span class="code">Mnesia</span> on the local node is fully
              connected to. Only those nodes that <span class="code">Mnesia</span> has
              exchanged schema information with are included as
              <span class="code">running_db_nodes</span>. After the merge of schemas, the
              local <span class="code">Mnesia</span> system is fully operable and
              applications can perform access of remote replicas.
              Before the schema merge, <span class="code">Mnesia</span> only operates
              locally. Sometimes there are more nodes included in the
              <span class="code">running_db_nodes</span> list than all <span class="code">db_nodes</span>
              and <span class="code">extra_db_nodes</span> together.</p>
          </li>
          <li>
            <p><span class="code">schema_location</span>. Returns the
              initial schema location.</p>
          </li>
          <li>
            <p><span class="code">subscribers</span>. Returns a list of
              local processes currently subscribing to system events.</p>
          </li>
          <li>
            <p><span class="code">tables</span>. Returns a list of all
              locally known tables.</p>
          </li>
          <li>
            <p><span class="code">transactions</span>. Returns a list
              of all currently active local transactions.</p>
          </li>
          <li>
            <p><span class="code">transaction_failures</span>. Returns a
              number that indicates how many transactions have
              failed since <span class="code">Mnesia</span> was started.</p>
          </li>
          <li>
            <p><span class="code">transaction_commits</span>. Returns a
              number that indicates how many transactions have
              terminated successfully since <span class="code">Mnesia</span> was started.</p>
          </li>
          <li>
            <p><span class="code">transaction_restarts</span>. Returns a
              number that indicates how many transactions have been
              restarted since <span class="code">Mnesia</span> was started.</p>
          </li>
          <li>
            <p><span class="code">transaction_log_writes</span>.
              Returns a number that indicates how many write
              operations that have been performed to the transaction
              log since startup.</p>
          </li>
          <li>
            <p><span class="code">use_dir</span>. Returns a boolean that indicates if
              the <span class="code">Mnesia</span> directory is used or not. Can be
              started even if <span class="code">Mnesia</span> is not yet running.</p>
          </li>
          <li>
            <p><span class="code">version</span>. Returns the current
              version number of <span class="code">Mnesia</span>.</p>
          </li>
        </ul>
      </p></div>
    <p><a name="table-1"><span class="bold_code">table(Tab [,[Option]]) -&gt; QueryHandle</span></a><br></p>
<div class="REFBODY"><p>
      <a name="qlc_table"></a>
      <a name="table"></a>
        <p>Returns a Query List Comprehension (QLC) query handle,
          see the <span class="bold_code"><a href="qlc.html">qlc(3)</a></span>
          manual page in <span class="code">STDLIB</span>. The module <span class="code">qlc</span>
          implements a query language that can use <span class="code">Mnesia</span>
          tables as sources of data. Calling
          <span class="code">mnesia:table/1,2</span> is the means to make the
          <span class="code">mnesia</span> table <span class="code">Tab</span> usable to QLC.</p>
        <p><span class="code">Option</span> can contain <span class="code">Mnesia</span>
          options or QLC options. <span class="code">Mnesia</span> recognizes the
          following options (any other option is forwarded to
          QLC).</p>
        <ul>
          <li>
<span class="code">{lock, Lock}</span>, where <span class="code">lock</span> can be
            <span class="code">read</span> or <span class="code">write</span>. Default is <span class="code">read</span>.
          </li>
          <li>
<span class="code">{n_objects,Number}</span>, where <span class="code">n_objects</span>
            specifies (roughly) the number of objects returned
            from <span class="code">Mnesia</span> to QLC. Queries to remote tables
            can need a larger chunk to reduce network overhead.
            By default, <span class="code">100</span> objects at a time are returned.
          </li>
          <li>
<span class="code">{traverse, SelectMethod}</span>, where
            <span class="code">traverse</span> determines the method to traverse
            the whole table (if needed). The default method is
          <span class="code">select</span>.
          </li>
        </ul>
        <p>There are two alternatives for <span class="code">select</span>:</p>
        <ul>
          <li>
            <p><span class="code">select</span>. The table is traversed by calling
              <span class="code">mnesia:select/4</span> and <span class="code">mnesia:select/1</span>.
              The match specification (the second argument of
              <span class="code">select/3</span>) is assembled by QLC: simple filters
              are translated into equivalent match specifications.
              More complicated filters need to be applied to all
              objects returned by <span class="code">select/3</span> given a match
              specification that matches all objects.</p>
          </li>
          <li>
            <p><span class="code">{select, MatchSpec}</span>. As for <span class="code">select</span>,
              the table is traversed by calling <span class="code">mnesia:select/3</span>
              and <span class="code">mnesia:select/1</span>. The difference is that the
              match specification is explicitly given. This is how to
              state match specifications that cannot easily be
              expressed within the syntax provided by QLC.</p>
          </li>
        </ul>
      </p></div>
    <p><a name="table_info-2"><span class="bold_code">table_info(Tab, InfoKey) -&gt; Info | exit({aborted, Reason})</span></a><br></p>
<div class="REFBODY"><p>
      <a name="table_info"></a>
        <p>The <span class="code">table_info/2</span> function takes two arguments.
          The first is the name of a <span class="code">Mnesia</span> table.
          The second is one of the following keys:</p>
        <ul>
          <li>
            <p><span class="code">all</span>. Returns a list of all local table
              information. Each element is a
              <span class="code">{InfoKey, ItemVal}</span> tuple.</p>
            <p>New <span class="code">InfoItem</span>s can be added and old undocumented
              <span class="code">InfoItem</span>s can be removed without notice.</p>
          </li>
          <li>
            <p><span class="code">access_mode</span>. Returns the
              access mode of the table. The access mode can be
              <span class="code">read_only</span> or <span class="code">read_write</span>.</p>
          </li>
          <li>
            <p><span class="code">arity</span>. Returns the arity of
              records in the table as specified in the schema.</p>
          </li>
          <li>
            <p><span class="code">attributes</span>. Returns the table
              attribute names that are specified in the schema.</p>
          </li>
          <li>
            <p><span class="code">checkpoints</span>. Returns the names
              of the currently active checkpoints, which involve this
              table on this node.</p>
          </li>
          <li>
            <p><span class="code">cookie</span>. Returns a table cookie,
              which is a unique system-generated identifier for the
              table. The cookie is used internally to ensure that two
              different table definitions using the same table name
              cannot accidentally be intermixed. The cookie is
              generated when the table is created initially.</p>
          </li>
          <li>
            <p><span class="code">disc_copies</span>. Returns the nodes where a
              <span class="code">disc_copy</span> of the table resides according to the
              schema.</p>
          </li>
          <li>
            <p><span class="code">disc_only_copies</span>. Returns the nodes where a
              <span class="code">disc_only_copy</span> of the table resides
              according to the schema.</p>
          </li>
          <li>
            <p><span class="code">index</span>. Returns the list of
              index position integers for the table.</p>
          </li>
          <li>
            <p><span class="code">load_node</span>. Returns the name of
              the node that <span class="code">Mnesia</span> loaded the table from. The
              structure of the returned value is unspecified, but
              can be useful for debugging purposes.</p>
          </li>
          <li>
            <p><span class="code">load_order</span>. Returns the load
              order priority of the table. It is an integer and
              defaults to <span class="code">0</span> (zero).</p>
          </li>
          <li>
            <p><span class="code">load_reason</span>. Returns the
              reason of why <span class="code">Mnesia</span> decided to load the table.
              The structure of the returned value is unspecified, but
              can be useful for debugging purposes.</p>
          </li>
          <li>
            <p><span class="code">local_content</span>. Returns <span class="code">true</span> or
              <span class="code">false</span> to indicate if the table is configured to
              have locally unique content on each node.</p>
          </li>
          <li>
            <p><span class="code">master_nodes</span>. Returns the master nodes of a
              table.</p>
          </li>
          <li>
            <p><span class="code">memory</span>. Returns the number of
              words allocated to the table on this node.</p>
          </li>
          <li>
            <p><span class="code">ram_copies</span>. Returns the nodes where a
              <span class="code">ram_copy</span> of the table resides according to the
              schema.</p>
          </li>
          <li>
            <p><span class="code">record_name</span>. Returns the
              record name, common for all records in the table.</p>
          </li>
          <li>
            <p><span class="code">size</span>. Returns the number of
              records inserted in the table.</p>
          </li>
          <li>
            <p><span class="code">snmp</span>. Returns the SNMP struct. <span class="code">[]</span> means
              that the table currently has no SNMP properties.</p>
          </li>
          <li>
            <p><span class="code">storage_type</span>. Returns the local
              storage type of the table. It can be <span class="code">disc_copies</span>,
              <span class="code">ram_copies</span>, <span class="code">disc_only_copies</span>, or the atom
              <span class="code">unknown</span>. <span class="code">unknown</span> is returned for all
              tables that only reside remotely.</p>
          </li>
          <li>
            <p><span class="code">subscribers</span>. Returns a list
              of local processes currently subscribing to local table
              events that involve this table on this node.</p>
          </li>
          <li>
            <p><span class="code">type</span>. Returns the table type, which is
              <span class="code">bag</span>, <span class="code">set</span>, or <span class="code">ordered_set</span>.</p>
          </li>
          <li>
            <p><span class="code">user_properties</span>. Returns the
              user-associated table properties of the table. It is a
              list of the stored property records.</p>
          </li>
          <li>
            <p><span class="code">version</span>. Returns the current
              version of the table definition. The table version is
              incremented when the table definition is changed. The
              table definition can be incremented directly when it
              has been changed in a schema transaction, or
              when a committed table definition is merged with
              table definitions from other nodes during startup.</p>
          </li>
          <li>
            <p><span class="code">where_to_read</span>. Returns the node
              where the table can be read. If value <span class="code">nowhere</span>
              is returned, either the table is not loaded or it
              resides at a remote node that is not running.</p>
          </li>
          <li>
            <p><span class="code">where_to_write</span>. Returns a list of the nodes
              that currently hold an active replica of the table.</p>
          </li>
          <li>
            <p><span class="code">wild_pattern</span>. Returns a
              structure that can be given to the various match
              functions for a certain table. A record tuple is where
              all record fields have value <span class="code">'_'</span>.</p>
          </li>
        </ul>
      </p></div>
    <p><a name="transaction-2"><span class="bold_code">transaction(Fun [[, Args], Retries]) -&gt; {aborted, Reason} | {atomic, ResultOfFun}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="transaction"></a>
        <p>Executes the functional object <span class="code">Fun</span>
          with arguments <span class="code">Args</span> as a transaction.</p>
        <p>The code that executes inside the transaction
          can consist of a series of table manipulation functions.
          If something goes wrong inside the transaction as a result
          of a user error or a certain table not being available, the
          entire transaction is terminated and the function
          <span class="code">transaction/1</span> returns the tuple
          <span class="code">{aborted, Reason}</span>.</p>
        <p>If all is going well, <span class="code">{atomic, ResultOfFun}</span> is
          returned, where <span class="code">ResultOfFun</span> is the value of the
          last expression in <span class="code">Fun</span>.</p>
        <p>A function that adds a family to the database can be
          written as follows if there is a structure
          <span class="code">{family, Father, Mother, ChildrenList}</span>:</p>
        <div class="example"><pre>
add_family({family, F, M, Children}) -&gt;
    ChildOids = lists:map(fun oid/1, Children),
    Trans = fun() -&gt;      
        mnesia:write(F#person{children = ChildOids}, 
        mnesia:write(M#person{children = ChildOids},
        Write = fun(Child) -&gt; mnesia:write(Child) end,
        lists:foreach(Write, Children)
    end,
    mnesia:transaction(Trans).

oid(Rec) -&gt; {element(1, Rec), element(2, Rec)}.</pre></div>
        <p>This code adds a set of people to the database. Running
          this code within one transaction ensures that either the whole
          family is added to the database, or the whole transaction
          terminates. For example, if the last child is badly formatted,
          or the executing process terminates because of an
          <span class="code">'EXIT'</span> signal while executing the family code, the
          transaction terminates. Thus, the situation where half a
          family is added can never occur.</p>
        <p>It is also useful to update the database within a transaction
          if several processes concurrently update the same records.
          For example, the function <span class="code">raise(Name, Amount)</span>, which
          adds <span class="code">Amount</span> to the salary field of a person, is to
          be implemented as follows:</p>
        <div class="example"><pre>
raise(Name, Amount) -&gt;
    mnesia:transaction(fun() -&gt;
        case mnesia:wread({person, Name}) of
            [P] -&gt;
                Salary = Amount + P#person.salary,
                P2 = P#person{salary = Salary},
                mnesia:write(P2);
            _ -&gt;
                mnesia:abort("No such person")
        end
    end).</pre></div>
        <p>When this function executes within a transaction,
          several processes running on different nodes can concurrently
          execute the function <span class="code">raise/2</span> without interfering
          with each other.</p>
        <p>Since <span class="code">Mnesia</span> detects deadlocks, a transaction can be
          restarted any number of times. This function attempts a
          restart as specified in <span class="code">Retries</span>. <span class="code">Retries</span> must
          be an integer greater than 0 or the atom <span class="code">infinity</span>.
          Default is <span class="code">infinity</span>.</p>
      </p></div>
    <p><a name="transform_table-4"><span class="bold_code">transform_table(Tab, Fun, NewAttributeList, NewRecordName) -&gt; {aborted, R} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="transform_table_4"></a>
        <p>Applies argument <span class="code">Fun</span> to all
          records in the table. <span class="code">Fun</span> is a function that takes a
          record of the old type and returns a transformed record of
          the new type. Argument <span class="code">Fun</span> can also be the atom
          <span class="code">ignore</span>, which indicates that only the metadata
          about the table is updated. Use of
          <span class="code">ignore</span> is not recommended, but included
          as a possibility for the user do to an own transformation.</p>
        <p><span class="code">NewAttributeList</span> and <span class="code">NewRecordName</span>
          specify the attributes and the new record type of the
          converted table. Table name always remains unchanged. If
          <span class="code">record_name</span> is changed, only the <span class="code">Mnesia</span>
          functions that use table identifiers work, for example,
          <span class="code">mnesia:write/3</span> works, but not <span class="code">mnesia:write/1</span>.</p>
      </p></div>
    <p><a name="transform_table-3"><span class="bold_code">transform_table(Tab, Fun, NewAttributeList) -&gt; {aborted, R} | {atomic, ok}</span></a><br></p>
<div class="REFBODY"><p>
        <p>Calls <span class="code">mnesia:transform_table(Tab, Fun,
          NewAttributeList, RecName)</span>, where <span class="code">RecName</span> is
          <span class="code">mnesia:table_info(Tab, record_name)</span>.</p>
      </p></div>
    <p><a name="traverse_backup-4"><span class="bold_code">traverse_backup(Source, [SourceMod,] Target, [TargetMod,] Fun, Acc) -&gt; {ok, LastAcc} | {error, Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="traverse_backup"></a>
        <p>Iterates over a backup, either to transform it into a
          new backup, or read it. The arguments are explained briefly
          here. For details, see the User's Guide.</p>
        <ul>
          <li>
<span class="code">SourceMod</span> and <span class="code">TargetMod</span> are the names of
           the modules that actually access the backup media.
          </li>
          <li>
<span class="code">Source</span> and <span class="code">Target</span> are opaque data used
           exclusively by modules <span class="code">SourceMod</span> and <span class="code">TargetMod</span>
           to initialize the backup media.
          </li>
          <li>
<span class="code">Acc</span> is an initial accumulator value.
          </li>
          <li>
<span class="code">Fun(BackupItems, Acc)</span> is applied to each item in
           the backup. The <span class="code">Fun</span> must return a tuple
          <span class="code">{BackupItems,NewAcc}</span>, where <span class="code">BackupItems</span> is
           a list of valid backup items, and <span class="code">NewAcc</span> is a new
           accumulator value. The returned backup items are written
           in the target backup. 
          </li>
          <li>
<span class="code">LastAcc</span> is the last accumulator value. This is
           the last <span class="code">NewAcc</span> value that was returned by <span class="code">Fun</span>.
          </li>
        </ul>
      </p></div>
    <p><a name="uninstall_fallback-0"><span class="bold_code">uninstall_fallback() -&gt; ok | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="uninstall_fallback_0"></a>
        <p>Calls the function
          <span class="code">mnesia:uninstall_fallback([{scope, global}])</span>.</p>
      </p></div>
    <p><a name="uninstall_fallback-1"><span class="bold_code">uninstall_fallback(Args) -&gt; ok | {error,Reason}</span></a><br></p>
<div class="REFBODY"><p>
        <p>Deinstalls a fallback before it
          has been used to restore the database. This is normally a
          distributed operation that is either performed on all
          nodes with disc resident schema, or none. Uninstallation of
          fallbacks requires Erlang to be operational on all
          involved nodes, but it does not matter if <span class="code">Mnesia</span> is
          running or not. Which nodes that are considered as
          disc-resident nodes is determined from the schema
          information in the local fallback.</p>
        <p><span class="code">Args</span> is a list of the following tuples:</p>
        <ul>
          <li>
<span class="code">{module, BackupMod}</span>. For semantics,
           see <span class="code">mnesia:install_fallback/2</span>.
          </li>
          <li>
<span class="code">{scope, Scope}</span>. For semantics,
           see <span class="code">mnesia:install_fallback/2</span>.
          </li>
          <li>
<span class="code">{mnesia_dir, AlternateDir}</span>. For semantics,
           see <span class="code">mnesia:install_fallback/2</span>.
          </li>
        </ul>
      </p></div>
    <p><a name="unsubscribe-1"><span class="bold_code">unsubscribe(EventCategory) -&gt; {ok, Node} | {error, Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="unsubscribe"></a>
        <p>Stops sending events of type
          <span class="code">EventCategory</span> to the caller.</p>
        <p><span class="code">Node</span> is the local node.</p>
      </p></div>
    <p><a name="wait_for_tables-2"><span class="bold_code">wait_for_tables(TabList, Timeout) -&gt; ok | {timeout, BadTabList} | {error, Reason}</span></a><br></p>
<div class="REFBODY"><p>
      <a name="wait_for_tables"></a>
        <p>Some applications need to wait for certain tables to be
          accessible to do useful work. <span class="code">mnesia:wait_for_tables/2</span>
          either hangs until all tables in <span class="code">TabList</span> are accessible,
          or until <span class="code">timeout</span> is reached.</p>
      </p></div>
    <p><a name="wread-1"><span class="bold_code">wread({Tab, Key}) -&gt; transaction abort | RecordList</span></a><br></p>
<div class="REFBODY"><p>
      <a name="wread"></a>
        <p>Calls the function <span class="code">mnesia:read(Tab, Key, write)</span>.</p>
      </p></div>
    <p><a name="write-1"><span class="bold_code">write(Record) -&gt; transaction abort | ok</span></a><br></p>
<div class="REFBODY"><p>
      <a name="write_1"></a>
        <p>Calls the function <span class="code">mnesia:write(Tab, Record, write)</span>,
           where <span class="code">Tab</span> is <span class="code">element(1, Record)</span>.</p>
      </p></div>
    <p><a name="write-3"><span class="bold_code">write(Tab, Record, LockKind) -&gt; transaction abort | ok</span></a><br></p>
<div class="REFBODY"><p>
      <a name="write_3"></a>
        <p>Writes record <span class="code">Record</span> to table <span class="code">Tab</span>.</p>
        <p>The function returns <span class="code">ok</span>, or terminates if an error
          occurs. For example, the transaction terminates if no
          <span class="code">person</span> table exists.</p>
        <p>The semantics of this function is context-sensitive. For
          details, see <span class="code">mnesia:activity/4</span>. In
          transaction-context, it acquires a lock of type
          <span class="code">LockKind</span>. The lock types <span class="code">write</span> and
          <span class="code">sticky_write</span> are supported.</p>
      </p></div>
    <p><a name="write_lock_table-1"><span class="bold_code">write_lock_table(Tab) -&gt; ok | transaction abort</span></a><br></p>
<div class="REFBODY"><p>
      <a name="write_lock_table"></a>
        <p>Calls the function
          <span class="code">mnesia:lock({table, Tab}, write)</span>.</p>
      </p></div>
  

  <h3><a name="id69002">Configuration Parameters</a></h3>
<div class="REFBODY">
    
    <a name="configuration_parameters"></a>
    <p><span class="code">Mnesia</span> reads the following application configuration
      parameters:</p>
    <ul>
      <li>
        <p><span class="code">-mnesia access_module Module</span>. The name of the
          <span class="code">Mnesia</span> activity access callback module. Default is
          <span class="code">mnesia</span>.</p>
      </li>
      <li>
        <p><span class="code">-mnesia auto_repair true | false</span>. This flag
          controls if <span class="code">Mnesia</span> automatically tries to repair
          files that have not been properly closed. Default is
          <span class="code">true</span>.</p>
      </li>
      <li>
        <p><span class="code">-mnesia backup_module Module</span>. The name of the
          <span class="code">Mnesia</span> backup callback module. Default is
          <span class="code">mnesia_backup</span>.</p>
      </li>
      <li>
        <p><span class="code">-mnesia debug Level</span>. Controls the debug level
          of <span class="code">Mnesia</span>. The possible values are as follows:</p>
        <dl>
          <dt><strong><span class="code">none</span></strong></dt>
          <dd>
            <p>No trace outputs. This is the default.</p>
          </dd>
          <dt><strong><span class="code">verbose</span></strong></dt>
          <dd>
            <p>Activates tracing of important debug events. These
              events generate <span class="code">{mnesia_info, Format, Args}</span>
              system events. Processes can subscribe to these events with
              <span class="code">mnesia:subscribe/1</span>. The events are always sent to
              the <span class="code">Mnesia</span> event handler.</p>
          </dd>
          <dt><strong><span class="code">debug</span></strong></dt>
          <dd>
            <p>Activates all events at the verbose level plus full
              trace of all debug events. These debug events generate
              <span class="code">{mnesia_info, Format, Args}</span> system events.
              Processes can subscribe to these events with
              <span class="code">mnesia:subscribe/1</span>. The events are always sent to
              the <span class="code">Mnesia</span> event handler. On this debug level,
              the <span class="code">Mnesia</span> event handler starts subscribing to
              updates in the schema table.</p>
          </dd>
          <dt><strong><span class="code">trace</span></strong></dt>
          <dd>
            <p>Activates all events at the debug level. On this
              level, the <span class="code">Mnesia</span> event handler starts subscribing
              to updates on all <span class="code">Mnesia</span> tables. This level is
              intended only for debugging small toy systems, as many
              large events can be generated.</p>
          </dd>
          <dt><strong><span class="code">false</span></strong></dt>
          <dd>An alias for none.
          </dd>
          <dt><strong><span class="code">true</span></strong></dt>
          <dd>An alias for debug.
          </dd>
        </dl>
      </li>
      <li>
        <p><span class="code">-mnesia core_dir Directory</span>. The name of the
          directory where <span class="code">Mnesia</span> core files is stored, or
          false. Setting it implies that also RAM-only nodes
          generate a core file if a crash occurs.</p>
      </li>
      <li>
        <p><span class="code">-mnesia dc_dump_limit Number</span>. Controls how often
          <span class="code">disc_copies</span> tables are dumped from memory.
          Tables are dumped when 
          <span class="code">filesize(Log) &gt; (filesize(Tab)/Dc_dump_limit)</span>.
          Lower values reduce CPU overhead but increase disk space
          and startup times. Default is 4.</p>
      </li>
      <li>
        <p><span class="code">-mnesia dir Directory</span>. The name of the directory
          where all <span class="code">Mnesia</span> data is stored. The directory name
          must be unique for the current node. Two nodes must never
          share the the same <span class="code">Mnesia</span> directory. The results
          are unpredictable.</p>
      </li>
      <li>
        <p><span class="code">-mnesia dump_disc_copies_at_startup true | false</span>.
          If set to false, this disables the dumping of <span class="code">disc_copies</span>
          tables during startup while tables are being loaded. The default
          is true.</p>
      </li>
      <li>
        <p><span class="code">-mnesia dump_log_load_regulation true | false</span>.
          Controls if log dumps are to be performed as fast as
          possible, or if the dumper is to do its own load
          regulation. Default is <span class="code">false</span>.</p>
        <p>This feature is temporary and will be removed in a
          future release</p>
      </li>
      <li>
        <p><span class="code">-mnesia dump_log_update_in_place true | false</span>.
          Controls if log dumps are performed on a copy of the
          original data file, or if the log dump is performed
          on the original data file. Default is <span class="code">true</span></p>
      </li>
      <li>
        <a name="dump_log_write_threshold"></a>
        <p><span class="code">-mnesia dump_log_write_threshold Max</span>.
          <span class="code">Max</span> is an integer that specifies the maximum
          number of writes allowed to the transaction log before
          a new dump of the log is performed. Default is <span class="code">100</span>
          log writes.</p>
      </li>
      <li>
        <a name="dump_log_time_threshold"></a>
        <p><span class="code">-mnesia dump_log_time_threshold Max</span>.
          <span class="code">Max</span> is an integer that specifies the dump log
          interval in milliseconds. Default is 3 minutes. If a
          dump has not been performed within
          <span class="code">dump_log_time_threshold</span> milliseconds, a new dump
          is performed regardless of the number of writes
          performed.</p>
      </li>
      <li>
        <p><span class="code">-mnesia event_module Module</span>. The name of the
          <span class="code">Mnesia</span> event handler callback module. Default is
          <span class="code">mnesia_event</span>.</p>
      </li>
      <li>
        <p><span class="code">-mnesia extra_db_nodes Nodes</span> specifies a list of
          nodes, in addition to the ones found in the schema, with
          which <span class="code">Mnesia</span> is also to establish contact. Default
          is <span class="code">[]</span> (empty list).</p>
      </li>
      <li>
        <p><span class="code">-mnesia fallback_error_function {UserModule, UserFunc}</span>.
          Specifies a user-supplied callback function, which is
          called if a fallback is installed and <span class="code">Mnesia</span> goes
          down on another node. <span class="code">Mnesia</span> calls the function
          with one argument, the name of the dying node, for example,
          <span class="code">UserModule:UserFunc(DyingNode)</span>. <span class="code">Mnesia</span> must
          be restarted, otherwise the database can be inconsistent.
          The default behavior is to terminate <span class="code">Mnesia</span>.</p>
      </li>
      <li>
        <p><span class="code">-mnesia max_wait_for_decision Timeout</span>. Specifies
          how long <span class="code">Mnesia</span> waits for other nodes to share their
          knowledge about the outcome of an unclear transaction. By
          default, <span class="code">Timeout</span> is set to the atom <span class="code">infinity</span>.
          This implies that if <span class="code">Mnesia</span> upon startup detects
          a "heavyweight transaction" whose outcome is unclear, the
          local <span class="code">Mnesia</span> waits until <span class="code">Mnesia</span> is started
          on some (in the worst case all) of the other nodes that were
          involved in the interrupted transaction. This is a rare
          situation, but if it occurs, <span class="code">Mnesia</span> does not guess if
          the transaction on the other nodes was committed or
          terminated. <span class="code">Mnesia</span> waits until it knows the outcome
          and then acts accordingly.</p>
        <p>If <span class="code">Timeout</span> is set to an integer value in
          milliseconds, <span class="code">Mnesia</span> forces "heavyweight transactions"
          to be finished, even if the outcome of the transaction for
          the moment is unclear. After <span class="code">Timeout</span> milliseconds,
          <span class="code">Mnesia</span> commits or terminates the transaction and
          continues with the startup. This can lead to a situation
          where the transaction is committed on some nodes and
          terminated on other nodes. If the transaction is a
          schema transaction, the inconsistency can be fatal.</p>
      </li>
      <li>
        <p><span class="code">-mnesia no_table_loaders NUMBER</span>. Specifies the number
          of parallel table loaders during start. More loaders can be
          good if the network latency is high or if many tables
          contain few records. Default is <span class="code">2</span>.</p>
      </li>
      <li>
        <p><span class="code">-mnesia send_compressed Level</span>. Specifies the level of
          compression to be used when copying a table from the local
          node to another one. Default is <span class="code">0</span>.</p>
        <p><span class="code">Level</span> must be an integer in the interval
          <span class="code">[0, 9]</span>, where <span class="code">0</span> means no compression and
          <span class="code">9</span> means maximum compression. Before setting it to a
          non-zero value, ensure that the remote nodes
          understand this configuration.</p>
      </li>
      <li>
        <p><span class="code">-mnesia schema_location Loc</span>. Controls where
          <span class="code">Mnesia</span> looks for its schema. Parameter
          <span class="code">Loc</span> can be one of the following atoms:</p>
        <dl>
          <dt><strong><span class="code">disc</span></strong></dt>
          <dd>
            <p>Mandatory disc. The schema is assumed to be located
              in the <span class="code">Mnesia</span> directory. If the schema cannot
              be found, <span class="code">Mnesia</span> refuses to start. This is the
              old behavior.</p>
          </dd>
          <dt><strong><span class="code">ram</span></strong></dt>
          <dd>
            <p>Mandatory RAM. The schema resides in RAM
              only. At startup, a tiny new schema is generated. This
              default schema only contains the definition of the schema
              table and only resides on the local node. Since no other
              nodes are found in the default schema, configuration
              parameter <span class="code">extra_db_nodes</span> must be used to let the
              node share its table definitions with other nodes.</p>
            <p>Parameter <span class="code">extra_db_nodes</span> can also be
              used on disc based nodes.</p>
          </dd>
          <dt><strong><span class="code">opt_disc</span></strong></dt>
          <dd>
            <p>Optional disc. The schema can reside on disc or in
              RAM. If the schema is found on disc, <span class="code">Mnesia</span>
              starts as a disc-based node and the storage type of
              the schema table is <span class="code">disc_copies</span>. If no schema is
              found on disc, <span class="code">Mnesia</span> starts as a disc-less node
              and the storage type of the schema table is
              <span class="code">ram_copies</span>. Default value for the application
              parameter is <span class="code">opt_disc</span>.</p>
          </dd>
        </dl>
      </li>
    </ul>
    <p>First, the <span class="code">SASL</span> application parameters are checked,
      then the command-line flags are checked, and finally, the
      default value is chosen.</p>
  </div>

  <h3><a name="id91413">See Also</a></h3>
<div class="REFBODY">
    
    <p><span class="bold_code"><a href="application.html">application(3)</a></span>,
      <span class="bold_code"><a href="dets.html">dets(3)</a></span>,
      <span class="bold_code"><a href="disk_log.html">disk_log(3)</a></span>,
      <span class="bold_code"><a href="ets.html">ets(3)</a></span>,
      <span class="bold_code"><a href="mnesia_registry.html">mnesia_registry(3)</a></span>,
      <span class="bold_code"><a href="qlc.html">qlc(3)</a></span></p>
  </div>
  
</div>
<div class="footer">
<hr>
<p>Copyright  1997-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
