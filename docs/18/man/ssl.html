<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- ssl</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/ssl/users_guide.html">User's Guide</a><br><a href="../apps/ssl/index.html">Reference Manual</a><br><a href="../apps/ssl/release_notes.html">Release Notes</a><br><a href="../apps/ssl/ssl.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Secure Socket Layer </strong><br><strong>Reference Manual</strong><br><small>Version 7.3</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li title="ssl (App)"><a href="ssl_app.html">ssl (App)
                </a></li>
<li id="loadscrollpos" title="ssl " expanded="true">ssl<ul>
<li><a href="ssl.html">
                  Top of manual page
                </a></li>
<li title="cipher_suites-0"><a href="ssl.html#cipher_suites-0">cipher_suites/0</a></li>
<li title="cipher_suites-1"><a href="ssl.html#cipher_suites-1">cipher_suites/1</a></li>
<li title="clear_pem_cache-0"><a href="ssl.html#clear_pem_cache-0">clear_pem_cache/0</a></li>
<li title="connect-2"><a href="ssl.html#connect-2">connect/2</a></li>
<li title="connect-3"><a href="ssl.html#connect-3">connect/3</a></li>
<li title="connect-3"><a href="ssl.html#connect-3">connect/3</a></li>
<li title="connect-4"><a href="ssl.html#connect-4">connect/4</a></li>
<li title="close-1"><a href="ssl.html#close-1">close/1</a></li>
<li title="close-2"><a href="ssl.html#close-2">close/2</a></li>
<li title="controlling_process-2"><a href="ssl.html#controlling_process-2">controlling_process/2</a></li>
<li title="connection_information-1"><a href="ssl.html#connection_information-1">connection_information/1</a></li>
<li title="connection_information-2"><a href="ssl.html#connection_information-2">connection_information/2</a></li>
<li title="format_error-1"><a href="ssl.html#format_error-1">format_error/1</a></li>
<li title="getopts-2"><a href="ssl.html#getopts-2">getopts/2</a></li>
<li title="listen-2"><a href="ssl.html#listen-2">listen/2</a></li>
<li title="negotiated_protocol-1"><a href="ssl.html#negotiated_protocol-1">negotiated_protocol/1</a></li>
<li title="peercert-1"><a href="ssl.html#peercert-1">peercert/1</a></li>
<li title="peername-1"><a href="ssl.html#peername-1">peername/1</a></li>
<li title="prf-5"><a href="ssl.html#prf-5">prf/5</a></li>
<li title="recv-2"><a href="ssl.html#recv-2">recv/2</a></li>
<li title="recv-3"><a href="ssl.html#recv-3">recv/3</a></li>
<li title="renegotiate-1"><a href="ssl.html#renegotiate-1">renegotiate/1</a></li>
<li title="send-2"><a href="ssl.html#send-2">send/2</a></li>
<li title="setopts-2"><a href="ssl.html#setopts-2">setopts/2</a></li>
<li title="shutdown-2"><a href="ssl.html#shutdown-2">shutdown/2</a></li>
<li title="ssl_accept-1"><a href="ssl.html#ssl_accept-1">ssl_accept/1</a></li>
<li title="ssl_accept-2"><a href="ssl.html#ssl_accept-2">ssl_accept/2</a></li>
<li title="ssl_accept-2"><a href="ssl.html#ssl_accept-2">ssl_accept/2</a></li>
<li title="ssl_accept-3"><a href="ssl.html#ssl_accept-3">ssl_accept/3</a></li>
<li title="sockname-1"><a href="ssl.html#sockname-1">sockname/1</a></li>
<li title="start-0"><a href="ssl.html#start-0">start/0</a></li>
<li title="start-1"><a href="ssl.html#start-1">start/1</a></li>
<li title="stop-0"><a href="ssl.html#stop-0">stop/0</a></li>
<li title="transport_accept-1"><a href="ssl.html#transport_accept-1">transport_accept/1</a></li>
<li title="transport_accept-2"><a href="ssl.html#transport_accept-2">transport_accept/2</a></li>
<li title="versions-0"><a href="ssl.html#versions-0">versions/0</a></li>
</ul>
</li>
<li id="no" title="ssl_crl_cache " expanded="false">ssl_crl_cache<ul>
<li><a href="ssl_crl_cache.html">
                  Top of manual page
                </a></li>
<li title="delete-1"><a href="ssl_crl_cache.html#delete-1">delete/1</a></li>
<li title="insert-1"><a href="ssl_crl_cache.html#insert-1">insert/1</a></li>
<li title="insert-2"><a href="ssl_crl_cache.html#insert-2">insert/2</a></li>
</ul>
</li>
<li id="no" title="ssl_crl_cache_api " expanded="false">ssl_crl_cache_api<ul>
<li><a href="ssl_crl_cache_api.html">
                  Top of manual page
                </a></li>
<li title="fresh_crl-2"><a href="ssl_crl_cache_api.html#fresh_crl-2">fresh_crl/2</a></li>
<li title="lookup-2"><a href="ssl_crl_cache_api.html#lookup-2">lookup/2</a></li>
<li title="select-2"><a href="ssl_crl_cache_api.html#select-2">select/2</a></li>
</ul>
</li>
<li id="no" title="ssl_session_cache_api " expanded="false">ssl_session_cache_api<ul>
<li><a href="ssl_session_cache_api.html">
                  Top of manual page
                </a></li>
<li title="delete-2"><a href="ssl_session_cache_api.html#delete-2">delete/2</a></li>
<li title="foldl-3"><a href="ssl_session_cache_api.html#foldl-3">foldl/3</a></li>
<li title="init-1"><a href="ssl_session_cache_api.html#init-1">init/1</a></li>
<li title="lookup-2"><a href="ssl_session_cache_api.html#lookup-2">lookup/2</a></li>
<li title="select_session-2"><a href="ssl_session_cache_api.html#select_session-2">select_session/2</a></li>
<li title="terminate-1"><a href="ssl_session_cache_api.html#terminate-1">terminate/1</a></li>
<li title="update-3"><a href="ssl_session_cache_api.html#update-3">update/3</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>ssl</h1></center>
  
  <h3>MODULE</h3>
<div class="REFBODY">ssl</div>
  <h3>MODULE SUMMARY</h3>
<div class="REFBODY">Interface Functions for Secure Socket Layer</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>
      This module contains interface functions for the SSL/TLS protocol.
      For detailed information about the supported standards see 
      <span class="bold_code"><a href="ssl_app.html">ssl(6)</a></span>.
    </p>
  </p></div>
    
  <h3><a name="id64232">DATA TYPES</a></h3>
<div class="REFBODY">
    
    <p>The following data types are used in the functions for SSL:</p>

    <dl>

      <dt><strong><span class="code">boolean() =</span></strong></dt>
      <dd><p><span class="code">true | false</span></p></dd>

      <dt><strong><span class="code">option() =</span></strong></dt>
      <dd>
<p><span class="code">socketoption() | ssloption() | transportoption()</span></p>
      </dd>

      <dt><strong><span class="code">socketoption() =</span></strong></dt>
      <dd>
<p><span class="code">proplists:property()</span></p>
      <p>The default socket options are
      <span class="code">[{mode,list},{packet, 0},{header, 0},{active, true}]</span>.</p>
      <p>For valid options, see the
      <span class="bold_code"><a href="inet.html">inet(3)</a></span> and
      <span class="bold_code"><a href="gen_tcp.html">gen_tcp(3)</a></span> manual pages
      in Kernel.</p>
</dd>

      <dt><strong><a name="type-ssloption"></a><span class="code">ssloption() =</span></strong></dt>
      <dd>
	<p><span class="code">{verify, verify_type()}</span></p>
	<p><span class="code">| {verify_fun, {fun(), term()}}</span></p>
	<p><span class="code">| {fail_if_no_peer_cert, boolean()}</span></p>
	<p><span class="code">| {depth, integer()}</span></p>
	<p><span class="code">| {cert, public_key:der_encoded()}</span></p>
	<p><span class="code">| {certfile, path()}</span></p>
	<p><span class="code">| {key, {'RSAPrivateKey'| 'DSAPrivateKey' | 'ECPrivateKey' 
	| 'PrivateKeyInfo', public_key:der_encoded()}}</span></p>
	<p><span class="code">| {keyfile, path()}</span></p>
	<p><span class="code">| {password, string()}</span></p>
	<p><span class="code">| {cacerts, [public_key:der_encoded()]}</span></p>
	<p><span class="code">| {cacertfile, path()}</span></p>
	<p><span class="code">| {dh, public_key:der_encoded()}</span></p>
	<p><span class="code">| {dhfile, path()}</span></p>
	<p><span class="code">| {ciphers, ciphers()}</span></p>
	<p><span class="code">| {user_lookup_fun, {fun(), term()}}, {psk_identity, string()},
	{srp_identity, {string(), string()}}</span></p>
	<p><span class="code">| {reuse_sessions, boolean()}</span></p>
	<p><span class="code">| {reuse_session, fun()} {next_protocols_advertised, [binary()]}</span></p>
	<p><span class="code">| {client_preferred_next_protocols, {client | server,
	[binary()]} | {client | server, [binary()], binary()}}</span></p>
	<p><span class="code">| {log_alert, boolean()}</span></p>
	<p><span class="code">| {server_name_indication, hostname() | disable}</span></p>
	<p><span class="code">| {sni_hosts, [{hostname(), ssloptions()}]}</span></p>
	<p><span class="code">| {sni_fun, SNIfun::fun()}</span></p>
      </dd>
      
      <dt><strong><span class="code">transportoption() =</span></strong></dt>
      <dd>
<p><span class="code">{cb_info, {CallbackModule::atom(), DataTag::atom(),

      ClosedTag::atom(), ErrTag:atom()}}</span></p>
      <p>Defaults to <span class="code">{gen_tcp, tcp, tcp_closed, tcp_error}</span>. Can be used
      to customize the transport layer. The callback module must implement a
      reliable transport protocol, behave as <span class="code">gen_tcp</span>, and have functions
      corresponding to <span class="code">inet:setopts/2</span>, <span class="code">inet:getopts/2</span>,
      <span class="code">inet:peername/1</span>, <span class="code">inet:sockname/1</span>, and <span class="code">inet:port/1</span>.
      The callback <span class="code">gen_tcp</span> is treated specially and calls <span class="code">inet</span>
      directly.</p>
      <dl>
	<dt><strong><span class="code">CallbackModule =</span></strong></dt>
	<dd><p><span class="code">atom()</span></p></dd>
	<dt><strong><span class="code">DataTag =</span></strong></dt>
	<dd>
<p><span class="code">atom()</span></p>
	<p>Used in socket data message.</p>
</dd>
	<dt><strong><span class="code">ClosedTag =</span></strong></dt>
	<dd>
<p><span class="code">atom()</span></p>
	<p>Used in socket close message.</p>
</dd>
      </dl>
      </dd>

      <dt><strong><span class="code">verify_type() =</span></strong></dt>
      <dd><p><span class="code">verify_none | verify_peer</span></p></dd>

      <dt><strong><span class="code">path() =</span></strong></dt>
      <dd>
<p><span class="code">string()</span></p>
      <p>Represents a file path.</p>
</dd>

      <dt><strong><span class="code">public_key:der_encoded() =</span></strong></dt>
      <dd>
<p><span class="code">binary()</span></p>
      <p>ASN.1 DER-encoded entity as an Erlang binary.</p>
</dd>

      <dt><strong><span class="code">host() =</span></strong></dt>
      <dd><p><span class="code">hostname() | ipaddress()</span></p></dd>

      <dt><strong><span class="code">hostname() =</span></strong></dt>
      <dd><p><span class="code">string()</span></p></dd>

      <dt><strong><span class="code">ip_address() =</span></strong></dt>
      <dd><p><span class="code">{N1,N2,N3,N4} % IPv4 | {K1,K2,K3,K4,K5,K6,K7,K8} % IPv6
      </span></p></dd>

      <dt><strong><span class="code">sslsocket() =</span></strong></dt>
      <dd><p>opaque()</p></dd>

      <dt><strong><a name="type-protocol"></a><span class="code">protocol() =</span></strong></dt>
      <dd><p><span class="code">sslv3 | tlsv1 | 'tlsv1.1' | 'tlsv1.2'</span></p></dd>

      <dt><strong><span class="code">ciphers() =</span></strong></dt>
      <dd>
<p><span class="code">= [ciphersuite()] | string()</span></p>
      <p>According to old API.</p>
</dd>

      <dt><strong><span class="code">ciphersuite() =</span></strong></dt>

      <dd><p><span class="code">{key_exchange(), cipher(), MAC::hash()} |
      {key_exchange(), cipher(), MAC::hash(), PRF::hash()}</span></p></dd>

      <dt><strong><span class="code">key_exchange()=</span></strong></dt>
      <dd><p><span class="code">rsa | dhe_dss | dhe_rsa | dh_anon | psk | dhe_psk
      | rsa_psk | srp_anon | srp_dss | srp_rsa | ecdh_anon | ecdh_ecdsa
      | ecdhe_ecdsa | ecdh_rsa | ecdhe_rsa</span></p></dd>

      <dt><strong><span class="code">cipher() =</span></strong></dt>
      <dd><p><span class="code">rc4_128 | des_cbc | '3des_ede_cbc'
      | aes_128_cbc | aes_256_cbc | aes_128_gcm | aes_256_gcm</span></p></dd>

      <dt><strong><span class="code">hash() =</span></strong></dt>
      <dd><p><span class="code">md5 | sha | sha224 | sha256 | sha348 | sha512</span></p></dd>

      <dt><strong><span class="code">prf_random() =</span></strong></dt>
      <dd><p><span class="code">client_random | server_random</span></p></dd>

      <dt><strong><span class="code">srp_param_type() =</span></strong></dt>
      <dd><p><span class="code">srp_1024 | srp_1536 | srp_2048 | srp_3072
      | srp_4096 | srp_6144 | srp_8192</span></p></dd>

      <dt><strong><span class="code">SNIfun::fun()</span></strong></dt>
      <dd><p><span class="code">= fun(ServerName :: string()) -&gt; ssloptions()</span></p></dd>

    </dl>
  </div>

  <h3><a name="id62472">SSL OPTION DESCRIPTIONS - COMMON for SERVER and CLIENT</a></h3>
<div class="REFBODY">
    

    <p>The following options have the same meaning in the client and 
    the server:</p>
    
    <dl>

      <dt><strong><span class="code">{cert, public_key:der_encoded()}</span></strong></dt>
      <dd><p>The DER-encoded users certificate. If this option
      is supplied, it overrides option <span class="code">certfile</span>.</p></dd>
      
      <dt><strong><span class="code">{certfile, path()}</span></strong></dt>
      <dd><p>Path to a file containing the user certificate.</p></dd>
      
      <dt><strong><span class="code">{key, {'RSAPrivateKey'| 'DSAPrivateKey' | 'ECPrivateKey'
      |'PrivateKeyInfo', public_key:der_encoded()}}</span></strong></dt>
      <dd><p>The DER-encoded user's private key. If this option 
      is supplied, it overrides option <span class="code">keyfile</span>.</p></dd>
      
      <dt><strong><span class="code">{keyfile, path()}</span></strong></dt>
      <dd><p>Path to the file containing the user's
      private PEM-encoded key. As PEM-files can contain several
      entries, this option defaults to the same file as given by
      option <span class="code">certfile</span>.</p></dd>

      <dt><strong><span class="code">{password, string()}</span></strong></dt>
      <dd><p>String containing the user's password. Only used if the 
      private keyfile is password-protected.</p></dd>

      <dt><strong><span class="code">{ciphers, ciphers()}</span></strong></dt>
      <dd><p>Supported cipher suites. The function
      <span class="code">cipher_suites/0</span> can be used to find all ciphers that are
      supported by default. <span class="code">cipher_suites(all)</span> can be called
      to find all available cipher suites. Pre-Shared Key 
      (<span class="bold_code"><a href="http://www.ietf.org/rfc/rfc4279.txt">RFC 4279</a></span> and
      <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5487.txt">RFC 5487</a></span>), 
      Secure Remote Password 
      (<span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5054.txt">RFC 5054</a></span>), RC4 cipher suites,
      and anonymous cipher suites only work if explicitly enabled by
      this option; they are supported/enabled by the peer also.
      Anonymous cipher suites are supported for testing purposes
      only and are not be used when security matters.</p></dd>

      <dt><strong><span class="code">{secure_renegotiate, boolean()}</span></strong></dt>
      <dd>
<p>Specifies if to reject renegotiation attempt that does
      not live up to 
      <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5746.txt">RFC 5746</a></span>. 
      By default <span class="code">secure_renegotiate</span> is set to <span class="code">false</span>, 
      that is, secure renegotiation is used if possible,
      but it falls back to insecure renegotiation if the peer
      does not support 
      <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5746.txt">RFC 5746</a></span>.</p>
      </dd>

      <dt><strong><span class="code">{depth, integer()}</span></strong></dt>
      <dd><p>Maximum number of non-self-issued
      intermediate certificates that can follow the peer certificate 
      in a valid certification path. So, if depth is 0 the PEER must 
      be signed by the trusted ROOT-CA directly; if 1 the path can 
      be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, 
      ROOT-CA, and so on. The default value is 1.</p></dd>

      <dt><strong><span class="code">{verify_fun, {Verifyfun :: fun(), InitialUserState ::
      term()}}</span></strong></dt>
      <dd>
<p>The verification fun is to be defined as follows:</p>

	<div class="example"><pre>
fun(OtpCert :: #'OTPCertificate'{}, Event :: {bad_cert, Reason :: atom() | {revoked,
atom()}} |
	     {extension, #'Extension'{}}, InitialUserState :: term()) -&gt;
	{valid, UserState :: term()} | {valid_peer, UserState :: term()} |
	{fail, Reason :: term()} | {unknown, UserState :: term()}.
	</pre></div>

	<p>The verification fun is called during the X509-path
	validation when an error or an extension unknown to the SSL
	application is encountered. It is also called
	when a certificate is considered valid by the path validation
	to allow access to each certificate in the path to the user
	application. It differentiates between the peer
	certificate and the CA certificates by using <span class="code">valid_peer</span> or
	<span class="code">valid</span> as second argument to the verification fun. See the
	<span class="bold_code"><a href="../apps/public_key/public_key_records.html">public_key User's
	Guide</a></span> for definition of <span class="code">#'OTPCertificate'{}</span> and
	<span class="code">#'Extension'{}</span>.</p>

	<ul>
	  <li><p>If the verify callback fun returns <span class="code">{fail, Reason}</span>,
	  the verification process is immediately stopped, an alert is
	  sent to the peer, and the TLS/SSL handshake terminates.</p></li>
	  <li><p>If the verify callback fun returns <span class="code">{valid, UserState}</span>,
	  the verification process continues.</p></li> 
	  <li><p>If the verify callback fun always returns
	  <span class="code">{valid, UserState}</span>, the TLS/SSL handshake does not
	  terminate regarding verification failures and the connection is
	  established.</p></li>
	  <li>
<p>If called with an extension unknown to the user application,
	  return value <span class="code">{unknown, UserState}</span> is to be used.</p>

	  <p>Note that if the fun returns <span class="code">unknown</span> for an extension marked
	  as critical, validation will fail.</p>
	  </li>
	</ul>

	<p>Default option <span class="code">verify_fun</span> in <span class="code">verify_peer mode</span>:</p>

      <div class="example"><pre>
{fun(_,{bad_cert, _} = Reason, _) -&gt;
	 {fail, Reason};
    (_,{extension, _}, UserState) -&gt;
	 {unknown, UserState};
    (_, valid, UserState) -&gt;
	 {valid, UserState};
    (_, valid_peer, UserState) -&gt;
         {valid, UserState}
 end, []}
      </pre></div>

      <p>Default option <span class="code">verify_fun</span> in mode <span class="code">verify_none</span>:</p>

       <div class="example"><pre>
{fun(_,{bad_cert, _}, UserState) -&gt;
	 {valid, UserState};
    (_,{extension, #'Extension'{critical = true}}, UserState) -&gt;
	 {valid, UserState};
    (_,{extension, _}, UserState) -&gt;
	 {unknown, UserState};
    (_, valid, UserState) -&gt;
	 {valid, UserState};
    (_, valid_peer, UserState) -&gt;
         {valid, UserState}
 end, []}
      </pre></div>

      <p>The possible path validation errors are given on form
      <span class="code">{bad_cert, Reason}</span> where <span class="code">Reason</span> is:</p>

      <dl>
	<dt><strong><span class="code">unknown_ca</span></strong></dt>
	<dd>
<p>No trusted CA was found in the trusted store. The trusted CA is
	normally a so called ROOT CA, which is a self-signed certificate. Trust can
	be claimed for an intermediate CA (trusted anchor does not have to be
	self-signed according to X-509) by using option <span class="code">partial_chain</span>.</p>
	</dd>

	<dt><strong><span class="code">selfsigned_peer</span></strong></dt>
	<dd><p>The chain consisted only of one self-signed certificate.</p></dd>

	<dt><strong><span class="code">PKIX X-509-path validation error</span></strong></dt>
	<dd><p>For possible reasons, see <span class="bold_code"><a href="public_key.html#pkix_path_validation-3">public_key:pkix_path_validation/3</a></span>
	</p></dd>
      </dl>
      </dd>

      <dt><strong><span class="code">{crl_check, boolean() | peer | best_effort }</span></strong></dt>
      <dd>
	Perform CRL (Certificate Revocation List) verification
	<span class="bold_code"><a href="public_key.html#pkix_crls_validate-3">
	(public_key:pkix_crls_validate/3)</a></span> on all the certificates during the path validation
	<span class="bold_code"><a href="public_key.html#pkix_path_validation-3">(public_key:pkix_path_validation/3)
	</a></span>
	of the certificate chain. Defaults to false.
	
	<p><span class="code">peer</span> - check is only performed on
	the peer certificate.</p>

	<p><span class="code">best_effort</span> - if certificate revocation status can not be determined
	it will be accepted as valid.</p>

	<p>The CA certificates specified for the connection will be used to 
	construct the certificate chain validating the CRLs.</p>
 	
	<p>The CRLs will be fetched from a local or external cache see
	<span class="bold_code"><a href="ssl_crl_cache_api.html">ssl_crl_cache_api(3)</a></span>.</p>
      </dd>

      <dt><strong><span class="code">{crl_cache, {Module :: atom(), {DbHandle :: internal | term(), Args :: list()}}}</span></strong></dt>
      <dd>
	<p>Module defaults to ssl_crl_cache with <span class="code"> DbHandle </span> internal and an
	empty argument list. The following arguments may be specified for the internal cache.</p>
	<dl>
	  <dt><strong><span class="code">{http, timeout()}</span></strong></dt>
	  <dd>
<p>
	    Enables fetching of CRLs specified as http URIs in<span class="bold_code"><a href="../apps/public_key/public_key_records.html"> X509 certificate extensions.</a></span>
	    Requires the OTP inets application.</p>
	  </dd>	    
	</dl>    
      </dd>

      <dt><strong><span class="code">{partial_chain, fun(Chain::[DerCert]) -&gt; {trusted_ca, DerCert} |
      unknown_ca }</span></strong></dt>
      <dd><p>Claim an intermediate CA in the chain as trusted. TLS then
      performs <span class="bold_code"><a href="public_key.html#pkix_path_validation-3">public_key:pkix_path_validation/3</a></span>
      with the selected CA as trusted anchor and the rest of the chain.</p></dd>

      <dt><strong><span class="code">{versions, [protocol()]}</span></strong></dt>
      <dd><p>TLS protocol versions supported by started clients and servers.
      This option overrides the application environment option
      <span class="code">protocol_version</span>. If the environment option is not set, it defaults
      to all versions, except SSL-3.0, supported by the SSL application.
      See also <span class="bold_code"><a href="ssl_app.html">ssl(6).</a></span></p></dd>

      <dt><strong><span class="code">{hibernate_after, integer()|undefined}</span></strong></dt>
      <dd><p>When an integer-value is specified, <span class="code">ssl_connection</span>
      goes into hibernation after the specified number of milliseconds
      of inactivity, thus reducing its memory footprint. When
      <span class="code">undefined</span> is specified (this is the default), the process
      never goes into hibernation.</p></dd>

      <dt><strong><span class="code">{user_lookup_fun, {Lookupfun :: fun(), UserState :: term()}}</span></strong></dt>
      <dd>
<p>The lookup fun is to defined as follows:</p>

	<div class="example"><pre>
fun(psk, PSKIdentity ::string(), UserState :: term()) -&gt;
	{ok, SharedSecret :: binary()} | error;
fun(srp, Username :: string(), UserState :: term()) -&gt;
	{ok, {SRPParams :: srp_param_type(), Salt :: binary(), DerivedKey :: binary()}} | error.
	</pre></div>

	<p>For Pre-Shared Key (PSK) cipher suites, the lookup fun is
	called by the client and server to determine the shared
	secret. When called by the client, <span class="code">PSKIdentity</span> is set to the
	hint presented by the server or to undefined. When called by the
	server, <span class="code">PSKIdentity</span> is the identity presented by the client.</p>

	<p>For Secure Remote Password (SRP), the fun is only used by the server to
	obtain parameters that it uses to generate its session keys.
	<span class="code">DerivedKey</span> is to be derived according to
	<span class="bold_code"><a href="http://tools.ietf.org/html/rfc2945#section-3"> RFC 2945</a></span> and
	<span class="bold_code"><a href="http://tools.ietf.org/html/rfc5054#section-2.4"> RFC 5054</a></span>:
	<span class="code">crypto:sha([Salt, crypto:sha([Username, &lt;&lt;$:&gt;&gt;, Password])])</span>
	</p>
      </dd>

      <dt><strong><span class="code">{padding_check, boolean()}</span></strong></dt>
      <dd><p>Affects TLS-1.0 connections only.
      If set to <span class="code">false</span>, it disables the block cipher padding check
      to be able to interoperate with legacy software.</p></dd>

    </dl>

        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p><p>Using <span class="code">{padding_check, boolean()}</span> makes TLS
	vulnerable to the Poodle attack.</p></p></div>
</div>

  </div>
  
  <h3><a name="id63569">SSL OPTION DESCRIPTIONS - CLIENT SIDE</a></h3>
<div class="REFBODY">
    

    <p>The following options are client-specific or have a slightly different
    meaning in the client than in the server:</p>

    <dl>

      <dt><strong><span class="code">{verify, verify_type()}</span></strong></dt>
      <dd>
<p>In mode <span class="code">verify_none</span> the default behavior is to allow
      all x509-path validation errors. See also option <span class="code">verify_fun</span>.</p>
      </dd>

      <dt><strong><span class="code">{reuse_sessions, boolean()}</span></strong></dt>
      <dd><p>Specifies if the client is to try to reuse sessions
      when possible.</p></dd>

      <dt><strong><span class="code">{cacerts, [public_key:der_encoded()]}</span></strong></dt>
      <dd><p>The DER-encoded trusted certificates. If this option
      is supplied it overrides option <span class="code">cacertfile</span>.</p></dd>
      
      <dt><strong><span class="code">{cacertfile, path()}</span></strong></dt>
      <dd>
<p>Path to a file containing PEM-encoded CA certificates. The CA
      certificates are used during server authentication and when building the
      client certificate chain.</p>
    </dd>

      <dt><strong><span class="code">{alpn_advertised_protocols, [binary()]}</span></strong></dt>
      <dd>
      <p>The list of protocols supported by the client to be sent to the
      server to be used for an Application-Layer Protocol Negotiation (ALPN).
      If the server supports ALPN then it will choose a protocol from this
      list; otherwise it will fail the connection with a "no_application_protocol"
      alert. A server that does not support ALPN will ignore this value.</p>

      <p>The list of protocols must not contain an empty binary.</p>

      <p>The negotiated protocol can be retrieved using the <span class="code">negotiated_protocol/1</span> function.</p>
      </dd>

      <dt><strong><span class="code">{client_preferred_next_protocols, {Precedence :: server | client, ClientPrefs :: [binary()]}}</span><br>
      <span class="code">{client_preferred_next_protocols, {Precedence :: server | client, ClientPrefs :: [binary()], Default :: binary()}}</span></strong></dt>
	   <dd>
	   <p>Indicates that the client is to try to perform Next Protocol
	   Negotiation.</p>

	   <p>If precedence is server, the negotiated protocol is the
	   first protocol to be shown on the server advertised list, which is
	   also on the client preference list.</p>

	   <p>If precedence is client, the negotiated protocol is the
	   first protocol to be shown on the client preference list, which is
	   also on the server advertised list.</p>

	   <p>If the client does not support any of the server advertised
	   protocols or the server does not advertise any protocols, the
	   client falls back to the first protocol in its list or to the
	   default protocol (if a default is supplied). If the
	   server does not support Next Protocol Negotiation, the
	   connection terminates if no default protocol is supplied.</p>
	   </dd>

      <dt><strong><span class="code">{psk_identity, string()}</span></strong></dt>
      <dd>
<p>Specifies the identity the client presents to the server.
      The matching secret is found by calling <span class="code">user_lookup_fun</span>.</p>
      </dd>

      <dt><strong><span class="code">{srp_identity, {Username :: string(), Password :: string()}
      </span></strong></dt>
      <dd><p>Specifies the username and password to use to authenticate
      to the server.</p></dd>

      <dt><strong><span class="code">{server_name_indication, hostname()}</span></strong></dt>
      <dd><p>Can be specified when upgrading a TCP socket to a TLS
        socket to use the TLS Server Name Indication extension.</p></dd>

	<dt><strong><span class="code">{server_name_indication, disable}</span></strong></dt>
      <dd>
        <p>When starting a TLS connection without upgrade, the Server Name
        Indication extension is sent if possible. This option can be
        used to disable that behavior.</p>
      </dd>
      <dt><strong><span class="code">{fallback, boolean()}</span></strong></dt>
      <dd>
	<p> Send special cipher suite TLS_FALLBACK_SCSV to avoid undesired TLS version downgrade.
	Defaults to false</p>
	<div class="warning">
<div class="label">Warning</div>
<div class="content"><p><p>Note this option is not needed in normal TLS usage and should not be used
	to implement new clients. But legacy clients that retries connections in the following manner</p>

	<p><span class="code"> ssl:connect(Host, Port, [...{versions, ['tlsv2', 'tlsv1.1', 'tlsv1', 'sslv3']}])</span></p>
	<p><span class="code">  ssl:connect(Host, Port, [...{versions, [tlsv1.1', 'tlsv1', 'sslv3']}, {fallback, true}])</span></p>
	<p><span class="code">  ssl:connect(Host, Port, [...{versions, ['tlsv1', 'sslv3']}, {fallback, true}]) </span></p>
	<p><span class="code">  ssl:connect(Host, Port, [...{versions, ['sslv3']}, {fallback, true}]) </span></p>
	 
	 <p>may use it to avoid undesired TLS version downgrade. Note that TLS_FALLBACK_SCSV must also
	 be supported by the server for the prevention to work.
	</p></p></div>
</div>
      </dd>
    </dl>
   </div>

  <h3><a name="id60332">SSL OPTION DESCRIPTIONS - SERVER SIDE</a></h3>
<div class="REFBODY">
    

    <p>The following options are server-specific or have a slightly different
    meaning in the server than in the client:</p>

    <dl>

      <dt><strong><span class="code">{cacerts, [public_key:der_encoded()]}</span></strong></dt>
      <dd><p>The DER-encoded trusted certificates. If this option
      is supplied it overrides option <span class="code">cacertfile</span>.</p></dd>
      
      <dt><strong><span class="code">{cacertfile, path()}</span></strong></dt>
      <dd><p>Path to a file containing PEM-encoded CA
      certificates. The CA certificates are used to build the server
      certificate chain and for client authentication. The CAs are
      also used in the list of acceptable client CAs passed to the
      client when a certificate is requested. Can be omitted if there
      is no need to verify the client and if there are no
      intermediate CAs for the server certificate.</p></dd>
  
      <dt><strong><span class="code">{dh, public_key:der_encoded()}</span></strong></dt>
      <dd><p>The DER-encoded Diffie-Hellman parameters. If specified,
      it overrides option <span class="code">dhfile</span>.</p></dd>

      <dt><strong><span class="code">{dhfile, path()}</span></strong></dt>
      <dd><p>Path to a file containing PEM-encoded Diffie Hellman parameters
      to be used by the server if a cipher suite using Diffie Hellman key
      exchange is negotiated. If not specified, default parameters are used.
      </p></dd>

      <dt><strong><span class="code">{verify, verify_type()}</span></strong></dt>
      <dd><p>A server only does x509-path validation in mode <span class="code">verify_peer</span>,
      as it then sends a certificate request to the client
      (this message is not sent if the verify option is <span class="code">verify_none</span>).
      You can then also want to specify option <span class="code">fail_if_no_peer_cert</span>.
      </p></dd>

      <dt><strong><span class="code">{fail_if_no_peer_cert, boolean()}</span></strong></dt>
      <dd>
<p>Used together with <span class="code">{verify, verify_peer}</span> by an SSL server.
      If set to <span class="code">true</span>, the server fails if the client does not have
      a certificate to send, that is, sends an empty certificate. If set to
      <span class="code">false</span>, it fails only if the client sends an invalid
      certificate (an empty certificate is considered valid). Defaults to false.</p>
      </dd>

      <dt><strong><span class="code">{reuse_sessions, boolean()}</span></strong></dt>
      <dd><p>Specifies if the server is to agree to reuse sessions
      when requested by the clients. See also option <span class="code">reuse_session</span>.
      </p></dd>

      <dt><strong><span class="code">{reuse_session, fun(SuggestedSessionId,
      PeerCert, Compression, CipherSuite) -&gt; boolean()}</span></strong></dt>
      <dd><p>Enables the SSL server to have a local policy
      for deciding if a session is to be reused or not.
      Meaningful only if <span class="code">reuse_sessions</span> is set to <span class="code">true</span>.
      <span class="code">SuggestedSessionId</span> is a <span class="code">binary()</span>, <span class="code">PeerCert</span> is
      a DER-encoded certificate, <span class="code">Compression</span> is an enumeration integer,
      and <span class="code">CipherSuite</span> is of type <span class="code">ciphersuite()</span>.</p></dd>

      <dt><strong><span class="code">{alpn_preferred_protocols, [binary()]}</span></strong></dt>
      <dd>
      <p>Indicates the server will try to perform Application-Layer
      Protocol Negotiation (ALPN).</p>

      <p>The list of protocols is in order of preference. The protocol
      negotiated will be the first in the list that matches one of the
      protocols advertised by the client. If no protocol matches, the
      server will fail the connection with a "no_application_protocol" alert.</p>

      <p>The negotiated protocol can be retrieved using the <span class="code">negotiated_protocol/1</span> function.</p>
      </dd>

      <dt><strong><span class="code">{next_protocols_advertised, Protocols :: [binary()]}</span></strong></dt>
      <dd><p>List of protocols to send to the client if the client indicates that
      it supports the Next Protocol extension. The client can select a protocol
      that is not on this list. The list of protocols must not contain an empty
      binary. If the server negotiates a Next Protocol, it can be accessed
      using the <span class="code">negotiated_next_protocol/1</span> method.</p></dd>

      <dt><strong><span class="code">{psk_identity, string()}</span></strong></dt>
      <dd><p>Specifies the server identity hint, which the server presents to
      the client.</p></dd>

      <dt><strong><span class="code">{log_alert, boolean()}</span></strong></dt>
      <dd><p>If set to <span class="code">false</span>, error reports are not displayed.</p></dd>

      <dt><strong><span class="code">{honor_cipher_order, boolean()}</span></strong></dt>
      <dd><p>If set to <span class="code">true</span>, use the server preference for cipher
      selection. If set to <span class="code">false</span> (the default), use the client
      preference.</p></dd>

      <dt><strong><span class="code">{sni_hosts, [{hostname(), ssloptions()}]}</span></strong></dt>
      <dd><p>If the server receives a SNI (Server Name Indication) from the client
      matching a host listed in the <span class="code">sni_hosts</span> option, the specific options for
      that host will override previously specified options.

      The option <span class="code">sni_fun</span>, and <span class="code">sni_hosts</span> are mutually exclusive.</p></dd>

      <dt><strong><span class="code">{sni_fun, SNIfun::fun()}</span></strong></dt>
      <dd><p>If the server receives a SNI (Server Name Indication) from the client,
      the given function will be called to retrieve <span class="code">ssloptions()</span> for the indicated server.
      These options will be merged into predefined <span class="code">ssloptions()</span>.

      The function should be defined as:
        <span class="code">fun(ServerName :: string()) -&gt; ssloptions()</span>
      and can be specified as a fun or as named <span class="code">fun module:function/1</span>

      The option <span class="code">sni_fun</span>, and <span class="code">sni_hosts</span> are mutually exclusive.</p></dd>

      <dt><strong><span class="code">{client_renegotiation, boolean()}</span></strong></dt>
      <dd>In protocols that support client-initiated renegotiation, the cost
      of resources of such an operation is higher for the server than the
      client. This can act as a vector for denial of service attacks. The SSL
      application already takes measures to counter-act such attempts,
      but client-initiated renegotiation can be strictly disabled by setting
      this option to <span class="code">false</span>. The default value is <span class="code">true</span>.
      Note that disabling renegotiation can result in long-lived connections
      becoming unusable due to limits on the number of messages the underlying
      cipher suite can encipher.
      </dd>

      <dt><strong><span class="code">{honor_cipher_order, boolean()}</span></strong></dt>
      <dd>If true, use the server's preference for cipher selection. If false
      (the default), use the client's preference.
      </dd>
    </dl>
  </div>
  
  <h3><a name="id63079">General</a></h3>
<div class="REFBODY">
    
      
    <p>When an SSL socket is in active mode (the default), data from the
      socket is delivered to the owner of the socket in the form of
      messages:</p>

    <ul>
      <li><p><span class="code">{ssl, Socket, Data}</span></p></li>
      <li><p><span class="code">{ssl_closed, Socket}</span></p></li>
      <li><p><span class="code">{ssl_error, Socket, Reason}</span></p></li>
    </ul>

    <p>A <span class="code">Timeout</span> argument specifies a time-out in milliseconds. The
      default value for argument <span class="code">Timeout</span> is <span class="code">infinity</span>.</p>
  </div>
  
  <h3>EXPORTS</h3>
    <p><a name="cipher_suites-0"><span class="bold_code">cipher_suites() -&gt;</span></a><br><a name="cipher_suites-1"><span class="bold_code">cipher_suites(Type) -&gt; ciphers()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Type = erlang | openssl | all</span><br>
</div>
      </div>
<div class="REFBODY"><p><p>Returns a list of supported cipher suites.
	<span class="code">cipher_suites()</span> is equivalent to <span class="code">cipher_suites(erlang).</span>
	Type <span class="code">openssl</span> is provided for backwards compatibility with the
	old SSL, which used OpenSSL. <span class="code">cipher_suites(all)</span> returns
	all available cipher suites. The cipher suites not present
	in <span class="code">cipher_suites(erlang)</span> but included in
	<span class="code">cipher_suites(all)</span> are not used unless explicitly configured
	by the user.</p>
    </p></div>

    <p><a name="clear_pem_cache-0"><span class="bold_code">clear_pem_cache() -&gt; ok </span></a><br></p>
<div class="REFBODY"><p><p>PEM files, used by ssl API-functions, are cached. The
      cache is regularly checked to see if any cache entries should be
      invalidated, however this function provides a way to
      unconditionally clear the whole cache.
      </p>
      </p></div>
   
    <p><a name="connect-2"><span class="bold_code">connect(Socket, SslOptions) -&gt; </span></a><br><a name="connect-3"><span class="bold_code">connect(Socket, SslOptions, Timeout) -&gt; {ok, SslSocket}
	| {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Socket = socket()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">SslOptions = [ssloption()]</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Timeout = integer() | infinity</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">SslSocket = sslsocket()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p><p>Upgrades a <span class="code">gen_tcp</span>, or equivalent,
	  connected socket to an SSL socket, that is, performs the
	  client-side ssl handshake.</p>
    </p></div>

    <p><a name="connect-3"><span class="bold_code">connect(Host, Port, Options) -&gt;</span></a><br><a name="connect-4"><span class="bold_code">connect(Host, Port, Options, Timeout) -&gt;
	  {ok, SslSocket} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	  <div class="REFTYPES">
<span class="bold_code">Host = host()</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">Port = integer()</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">Options = [option()]</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">Timeout = integer() | infinity</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">SslSocket = sslsocket()</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p><p>Opens an SSL connection to <span class="code">Host</span>, <span class="code">Port</span>.</p></p></div>

    <p><a name="close-1"><span class="bold_code">close(SslSocket) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	  <div class="REFTYPES">
<span class="bold_code">SslSocket = sslsocket()</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p><p>Closes an SSL connection.</p>
      </p></div>

    <p><a name="close-2"><span class="bold_code">close(SslSocket, How) -&gt; ok | {ok, port()} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	  <div class="REFTYPES">
<span class="bold_code">SslSocket = sslsocket()</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">How =  timeout() | {NewController::pid(), timeout()} </span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p><p>Closes or downgrades an SSL connection. In the latter case the transport
      connection will be handed over to the <span class="code">NewController</span> process after receiving
      the TLS close alert from the peer. The returned transport socket will have
      the following options set: <span class="code">[{active, false}, {packet, 0}, {mode, binary}]</span></p>
      </p></div>
    
    <p><a name="controlling_process-2"><span class="bold_code">controlling_process(SslSocket, NewOwner) -&gt;
	ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	  <div class="REFTYPES">
<span class="bold_code">SslSocket = sslsocket()</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">NewOwner = pid()</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
	</div>
<div class="REFBODY"><p><p>Assigns a new controlling process to the SSL socket. A
	controlling process is the owner of an SSL socket, and receives
	all messages from the socket.</p>
      </p></div>

    <p><a name="connection_information-1"><span class="bold_code">connection_information(SslSocket) -&gt;
        {ok, Result} |  {error, Reason} </span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Item = protocol | cipher_suite | sni_hostname | atom()</span><br>
</div>
	<div class="REFBODY">Meaningful atoms, not specified above, are the ssl option names.</div>
	<div class="REFTYPES">
<span class="bold_code">Result = [{Item::atom(), Value::term()}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p><p>Returns all relevant information about the connection, ssl options that
      are undefined will be filtered out.</p>
      </p></div>

    <p><a name="connection_information-2"><span class="bold_code">connection_information(SslSocket, Items) -&gt;
        {ok, Result} |  {error, Reason} </span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Items = [Item]</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Item = protocol | cipher_suite | sni_hostname | atom()</span><br>
</div>
	<div class="REFBODY">Meaningful atoms, not specified above, are the ssl option names.</div>
	<div class="REFTYPES">
<span class="bold_code">Result = [{Item::atom(), Value::term()}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p><p>Returns the requested information items about the connection,
      if they are defined.</p>
      <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>If only undefined options are requested the
      resulting list can be empty.</p></p></div>
</div>
      </p></div>

    <p><a name="format_error-1"><span class="bold_code">format_error(Reason) -&gt; string()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Presents the error returned by an SSL function as a printable string.</p>
      </p></div>
   
    <p><a name="getopts-2"><span class="bold_code">getopts(Socket, OptionNames) -&gt;
	{ok, [socketoption()]} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">OptionNames = [atom()]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Gets the values of the specified socket options.
	</p>
      </p></div>

    <p><a name="listen-2"><span class="bold_code">listen(Port, Options) -&gt;
	{ok, ListenSocket} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Port = integer()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Options = options()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">ListenSocket = sslsocket()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Creates an SSL listen socket.</p>
      </p></div>

    <p><a name="negotiated_protocol-1"><span class="bold_code">negotiated_protocol(Socket) -&gt; {ok, Protocol} | {error, protocol_not_negotiated}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Protocol = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>
          Returns the protocol negotiated through ALPN or NPN extensions.
        </p>
      </p></div>
    
    <p><a name="peercert-1"><span class="bold_code">peercert(Socket) -&gt; {ok, Cert} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Cert = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>The peer certificate is returned as a DER-encoded binary.
	  The certificate can be decoded with
	  <span class="code">public_key:pkix_decode_cert/2</span>.</p>
      </p></div>

    <p><a name="peername-1"><span class="bold_code">peername(Socket) -&gt; {ok, {Address, Port}} |
	{error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Address = ipaddress()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Port = integer()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Returns the address and port number of the peer.</p>
      </p></div>

    <p><a name="prf-5"><span class="bold_code">prf(Socket, Secret, Label, Seed, WantedLength) -&gt; {ok, binary()} | {error, reason()}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Secret = binary() | master_secret</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Label = binary()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Seed = [binary() | prf_random()]</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">WantedLength = non_neg_integer()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Uses the Pseudo-Random Function (PRF) of a TLS session to generate
	  extra key material. It either takes user-generated values for
	  <span class="code">Secret</span> and <span class="code">Seed</span> or atoms directing it to use a specific
	  value from the session security parameters.</p>
        <p>Can only be used with TLS connections; <span class="code">{error, undefined}</span>
	  is returned for SSLv3 connections.</p>
      </p></div>
    
    <p><a name="recv-2"><span class="bold_code">recv(Socket, Length) -&gt; </span></a><br><a name="recv-3"><span class="bold_code">recv(Socket, Length, Timeout) -&gt; {ok, Data} | {error,
	Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Length = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Timeout = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Data = [char()] | binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Receives a packet from a socket in passive
          mode. A closed socket is indicated by return value
          <span class="code">{error, closed}</span>.</p>
        <p>Argument <span class="code">Length</span> is meaningful only when
          the socket is in mode <span class="code">raw</span> and denotes the number of
          bytes to read. If <span class="code">Length</span> = 0, all available bytes are
          returned. If <span class="code">Length</span> &gt; 0, exactly <span class="code">Length</span>
          bytes are returned, or an error; possibly discarding less
          than <span class="code">Length</span> bytes of data when the socket gets closed
          from the other side.</p>
        <p>Optional argument <span class="code">Timeout</span> specifies a time-out in
          milliseconds. The default value is <span class="code">infinity</span>.</p>
      </p></div>
    
    <p><a name="renegotiate-1"><span class="bold_code">renegotiate(Socket) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
      </div>
<div class="REFBODY"><p><p>Initiates a new handshake. A notable return value is
      <span class="code">{error, renegotiation_rejected}</span> indicating that the peer
      refused to go through with the renegotiation, but the connection
      is still active using the previously negotiated session.</p>
      </p></div>
    
    <p><a name="send-2"><span class="bold_code">send(Socket, Data) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Data = iodata()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Writes <span class="code">Data</span> to <span class="code">Socket</span>.</p>
        <p>A notable return value is <span class="code">{error, closed}</span> indicating that
          the socket is closed.</p>
      </p></div>

    <p><a name="setopts-2"><span class="bold_code">setopts(Socket, Options) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Options = [socketoption]()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Sets options according to <span class="code">Options</span> for socket
          <span class="code">Socket</span>.</p>
      </p></div>

    <p><a name="shutdown-2"><span class="bold_code">shutdown(Socket, How) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">How = read | write | read_write</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = reason()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Immediately closes a socket in one or two directions.</p>
        <p><span class="code">How == write</span> means closing the socket for writing,
          reading from it is still possible.</p>
        <p>To be able to handle that the peer has done a shutdown on
          the write side, option <span class="code">{exit_on_close, false}</span>
          is useful.</p>
      </p></div>
    
    <p><a name="ssl_accept-1"><span class="bold_code">ssl_accept(Socket) -&gt; </span></a><br><a name="ssl_accept-2"><span class="bold_code">ssl_accept(Socket, Timeout) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Timeout = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Performs the SSL/TLS server-side handshake.</p>
	<p><span class="code">Socket</span> is a socket as returned by
	<span class="bold_code"><a href="#transport_accept-2">ssl:transport_accept/[1,2]</a></span>
	</p>
      </p></div>

    <p><a name="ssl_accept-2"><span class="bold_code">ssl_accept(Socket, SslOptions) -&gt; </span></a><br><a name="ssl_accept-3"><span class="bold_code">ssl_accept(Socket, SslOptions, Timeout) -&gt; {ok, Socket} | ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = socket() | sslsocket() </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">SslOptions = ssloptions()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Timeout = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>If <span class="code">Socket</span> is a <span class="code">socket()</span>: upgrades a <span class="code">gen_tcp</span>,
	or equivalent, socket to an SSL socket, that is, performs
        the SSL/TLS server-side handshake and returns the SSL socket.</p>
	
	<div class="warning">
<div class="label">Warning</div>
<div class="content"><p><p>The listen socket is to be in mode <span class="code">{active, false}</span>
	before telling the client that the server is ready to upgrade
	by calling this function, else the upgrade succeeds or does not
	succeed depending on timing.</p></p></div>
</div>
	
	<p>If <span class="code">Socket</span> is an <span class="code">sslsocket()</span>: provides extra SSL/TLS
	options to those specified in
	<span class="bold_code"><a href="#listen-2">ssl:listen/2 </a></span> and then performs
	the SSL/TLS handshake.
	</p>
      </p></div>
    
    <p><a name="sockname-1"><span class="bold_code">sockname(Socket) -&gt; {ok, {Address, Port}} |
	{error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Address = ipaddress()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Port = integer()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Returns the local address and port number of socket
          <span class="code">Socket</span>.</p>
      </p></div>
    
    <p><a name="start-0"><span class="bold_code">start() -&gt; </span></a><br><a name="start-1"><span class="bold_code">start(Type) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Type = permanent | transient | temporary</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Starts the SSL application. Default type
          is <span class="code">temporary</span>.</p>
      </p></div>

    <p><a name="stop-0"><span class="bold_code">stop() -&gt; ok </span></a><br></p>
<div class="REFBODY"><p>
        <p>Stops the SSL application.</p>
      </p></div>

    <p><a name="transport_accept-1"><span class="bold_code">transport_accept(ListenSocket) -&gt;</span></a><br><a name="transport_accept-2"><span class="bold_code">transport_accept(ListenSocket, Timeout) -&gt;
	{ok, NewSocket} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ListenSocket = NewSocket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Timeout = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = reason()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Accepts an incoming connection request on a listen socket.
	<span class="code">ListenSocket</span> must be a socket returned from
	<span class="bold_code"><a href="#listen-2"> ssl:listen/2</a></span>.
	The socket returned is to be passed to
	<span class="bold_code"><a href="#ssl_accept-2"> ssl:ssl_accept[2,3]</a></span>
	to complete handshaking, that is,
	establishing the SSL/TLS connection.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>The socket returned can only be used with
	  <span class="bold_code"><a href="#ssl_accept-2"> ssl:ssl_accept[2,3]</a></span>.
	  No traffic can be sent or received before that call.</p>
        </p></div>
</div>
        <p>The accepted socket inherits the options set for
	<span class="code">ListenSocket</span> in
	<span class="bold_code"><a href="#listen-2"> ssl:listen/2</a></span>.</p>
	<p>The default
	value for <span class="code">Timeout</span> is <span class="code">infinity</span>. If
	<span class="code">Timeout</span> is specified and no connection is accepted
	within the given time, <span class="code">{error, timeout}</span> is
	returned.</p>
      </p></div>
    
    <p><a name="versions-0"><span class="bold_code">versions() -&gt; [versions_info()]</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">versions_info() = {app_vsn, string()} | {supported | available, [protocol()] </span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Returns version information relevant for the SSL
	application.</p>
	<dl>
	  <dt><strong><span class="code">app_vsn</span></strong></dt>
	  <dd>The application version of the SSL application.</dd>

	  <dt><strong><span class="code">supported</span></strong></dt>
	  <dd>TLS/SSL versions supported by default.
	  Overridden by a version option on
	  <span class="bold_code"><a href="#connect-2"> connect/[2,3,4]</a></span>,
	  <span class="bold_code"><a href="#listen-2"> listen/2</a></span>, and <span class="bold_code"><a href="#ssl_accept-2">ssl_accept/[1,2,3]</a></span>.
	  For the negotiated TLS/SSL version, see <span class="bold_code"><a href="#connection_information-1">ssl:connection_information/1
	  </a></span>.</dd>
  
	  <dt><strong><span class="code">available</span></strong></dt>
	  <dd>All TLS/SSL versions supported by the SSL application.
	  TLS 1.2 requires sufficient support from the Crypto
	  application.</dd>
	</dl>
      </p></div>
   
   

  <h3><a name="id68389">SEE ALSO</a></h3>
<div class="REFBODY">
    
    <p><span class="bold_code"><a href="inet.html">inet(3)</a></span> and
      <span class="bold_code"><a href="gen_tcp.html">gen_tcp(3)</a></span>
    </p>
  </div>

</div>
<div class="footer">
<hr>
<p>Copyright  1999-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
