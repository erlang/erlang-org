<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- erl_connect</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/erl_interface/users_guide.html">User's Guide</a><br><a href="../apps/erl_interface/index.html">Reference Manual</a><br><a href="../apps/erl_interface/release_notes.html">Release Notes</a><br><a href="../apps/erl_interface/erl_interface.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Erlang Interface</strong><br><strong>Reference Manual</strong><br><small>Version 3.8.2</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li id="no" title="ei " expanded="false">ei<ul>
<li><a href="ei.html">
                  Top of manual page
                </a></li>
<li title="ei_set_compat_rel"><a href="ei.html#ei_set_compat_rel">ei_set_compat_rel()
                </a></li>
<li title="ei_encode_version"><a href="ei.html#ei_encode_version">ei_encode_version()
                </a></li>
<li title="ei_x_encode_version"><a href="ei.html#ei_x_encode_version">ei_x_encode_version()
                </a></li>
<li title="ei_encode_long"><a href="ei.html#ei_encode_long">ei_encode_long()
                </a></li>
<li title="ei_x_encode_long"><a href="ei.html#ei_x_encode_long">ei_x_encode_long()
                </a></li>
<li title="ei_encode_ulong"><a href="ei.html#ei_encode_ulong">ei_encode_ulong()
                </a></li>
<li title="ei_x_encode_ulong"><a href="ei.html#ei_x_encode_ulong">ei_x_encode_ulong()
                </a></li>
<li title="ei_encode_longlong"><a href="ei.html#ei_encode_longlong">ei_encode_longlong()
                </a></li>
<li title="ei_x_encode_longlong"><a href="ei.html#ei_x_encode_longlong">ei_x_encode_longlong()
                </a></li>
<li title="ei_encode_ulonglong"><a href="ei.html#ei_encode_ulonglong">ei_encode_ulonglong()
                </a></li>
<li title="ei_x_encode_ulonglong"><a href="ei.html#ei_x_encode_ulonglong">ei_x_encode_ulonglong()
                </a></li>
<li title="ei_encode_bignum"><a href="ei.html#ei_encode_bignum">ei_encode_bignum()
                </a></li>
<li title="ei_x_encode_bignum"><a href="ei.html#ei_x_encode_bignum">ei_x_encode_bignum()
                </a></li>
<li title="ei_encode_double"><a href="ei.html#ei_encode_double">ei_encode_double()
                </a></li>
<li title="ei_x_encode_double"><a href="ei.html#ei_x_encode_double">ei_x_encode_double()
                </a></li>
<li title="ei_encode_boolean"><a href="ei.html#ei_encode_boolean">ei_encode_boolean()
                </a></li>
<li title="ei_x_encode_boolean"><a href="ei.html#ei_x_encode_boolean">ei_x_encode_boolean()
                </a></li>
<li title="ei_encode_char"><a href="ei.html#ei_encode_char">ei_encode_char()
                </a></li>
<li title="ei_x_encode_char"><a href="ei.html#ei_x_encode_char">ei_x_encode_char()
                </a></li>
<li title="ei_encode_string"><a href="ei.html#ei_encode_string">ei_encode_string()
                </a></li>
<li title="ei_encode_string_len"><a href="ei.html#ei_encode_string_len">ei_encode_string_len()
                </a></li>
<li title="ei_x_encode_string"><a href="ei.html#ei_x_encode_string">ei_x_encode_string()
                </a></li>
<li title="ei_x_encode_string_len"><a href="ei.html#ei_x_encode_string_len">ei_x_encode_string_len()
                </a></li>
<li title="ei_encode_atom"><a href="ei.html#ei_encode_atom">ei_encode_atom()
                </a></li>
<li title="ei_encode_atom_len"><a href="ei.html#ei_encode_atom_len">ei_encode_atom_len()
                </a></li>
<li title="ei_x_encode_atom"><a href="ei.html#ei_x_encode_atom">ei_x_encode_atom()
                </a></li>
<li title="ei_x_encode_atom_len"><a href="ei.html#ei_x_encode_atom_len">ei_x_encode_atom_len()
                </a></li>
<li title="ei_encode_atom_as"><a href="ei.html#ei_encode_atom_as">ei_encode_atom_as()
                </a></li>
<li title="ei_encode_atom_len_as"><a href="ei.html#ei_encode_atom_len_as">ei_encode_atom_len_as()
                </a></li>
<li title="ei_x_encode_atom_as"><a href="ei.html#ei_x_encode_atom_as">ei_x_encode_atom_as()
                </a></li>
<li title="ei_x_encode_atom_len_as"><a href="ei.html#ei_x_encode_atom_len_as">ei_x_encode_atom_len_as()
                </a></li>
<li title="ei_encode_binary"><a href="ei.html#ei_encode_binary">ei_encode_binary()
                </a></li>
<li title="ei_x_encode_binary"><a href="ei.html#ei_x_encode_binary">ei_x_encode_binary()
                </a></li>
<li title="ei_encode_pid"><a href="ei.html#ei_encode_pid">ei_encode_pid()
                </a></li>
<li title="ei_x_encode_pid"><a href="ei.html#ei_x_encode_pid">ei_x_encode_pid()
                </a></li>
<li title="ei_encode_fun"><a href="ei.html#ei_encode_fun">ei_encode_fun()
                </a></li>
<li title="ei_x_encode_fun"><a href="ei.html#ei_x_encode_fun">ei_x_encode_fun()
                </a></li>
<li title="ei_encode_port"><a href="ei.html#ei_encode_port">ei_encode_port()
                </a></li>
<li title="ei_x_encode_port"><a href="ei.html#ei_x_encode_port">ei_x_encode_port()
                </a></li>
<li title="ei_encode_ref"><a href="ei.html#ei_encode_ref">ei_encode_ref()
                </a></li>
<li title="ei_x_encode_ref"><a href="ei.html#ei_x_encode_ref">ei_x_encode_ref()
                </a></li>
<li title="ei_encode_term"><a href="ei.html#ei_encode_term">ei_encode_term()
                </a></li>
<li title="ei_x_encode_term"><a href="ei.html#ei_x_encode_term">ei_x_encode_term()
                </a></li>
<li title="ei_encode_trace"><a href="ei.html#ei_encode_trace">ei_encode_trace()
                </a></li>
<li title="ei_x_encode_trace"><a href="ei.html#ei_x_encode_trace">ei_x_encode_trace()
                </a></li>
<li title="ei_encode_tuple_header"><a href="ei.html#ei_encode_tuple_header">ei_encode_tuple_header()
                </a></li>
<li title="ei_x_encode_tuple_header"><a href="ei.html#ei_x_encode_tuple_header">ei_x_encode_tuple_header()
                </a></li>
<li title="ei_encode_list_header"><a href="ei.html#ei_encode_list_header">ei_encode_list_header()
                </a></li>
<li title="ei_x_encode_list_header"><a href="ei.html#ei_x_encode_list_header">ei_x_encode_list_header()
                </a></li>
<li title="ei_encode_empty_list"><a href="ei.html#ei_encode_empty_list">ei_encode_empty_list()
                </a></li>
<li title="ei_x_encode_empty_list"><a href="ei.html#ei_x_encode_empty_list">ei_x_encode_empty_list()
                </a></li>
<li title="ei_encode_map_header"><a href="ei.html#ei_encode_map_header">ei_encode_map_header()
                </a></li>
<li title="ei_x_encode_map_header"><a href="ei.html#ei_x_encode_map_header">ei_x_encode_map_header()
                </a></li>
<li title="ei_get_type"><a href="ei.html#ei_get_type">ei_get_type()
                </a></li>
<li title="ei_decode_version"><a href="ei.html#ei_decode_version">ei_decode_version()
                </a></li>
<li title="ei_decode_long"><a href="ei.html#ei_decode_long">ei_decode_long()
                </a></li>
<li title="ei_decode_ulong"><a href="ei.html#ei_decode_ulong">ei_decode_ulong()
                </a></li>
<li title="ei_decode_longlong"><a href="ei.html#ei_decode_longlong">ei_decode_longlong()
                </a></li>
<li title="ei_decode_ulonglong"><a href="ei.html#ei_decode_ulonglong">ei_decode_ulonglong()
                </a></li>
<li title="ei_decode_bignum"><a href="ei.html#ei_decode_bignum">ei_decode_bignum()
                </a></li>
<li title="ei_decode_double"><a href="ei.html#ei_decode_double">ei_decode_double()
                </a></li>
<li title="ei_decode_boolean"><a href="ei.html#ei_decode_boolean">ei_decode_boolean()
                </a></li>
<li title="ei_decode_char"><a href="ei.html#ei_decode_char">ei_decode_char()
                </a></li>
<li title="ei_decode_string"><a href="ei.html#ei_decode_string">ei_decode_string()
                </a></li>
<li title="ei_decode_atom"><a href="ei.html#ei_decode_atom">ei_decode_atom()
                </a></li>
<li title="ei_decode_atom_as"><a href="ei.html#ei_decode_atom_as">ei_decode_atom_as()
                </a></li>
<li title="ei_decode_binary"><a href="ei.html#ei_decode_binary">ei_decode_binary()
                </a></li>
<li title="ei_decode_fun"><a href="ei.html#ei_decode_fun">ei_decode_fun()
                </a></li>
<li title="free_fun"><a href="ei.html#free_fun">free_fun()
                </a></li>
<li title="ei_decode_pid"><a href="ei.html#ei_decode_pid">ei_decode_pid()
                </a></li>
<li title="ei_decode_port"><a href="ei.html#ei_decode_port">ei_decode_port()
                </a></li>
<li title="ei_decode_ref"><a href="ei.html#ei_decode_ref">ei_decode_ref()
                </a></li>
<li title="ei_decode_trace"><a href="ei.html#ei_decode_trace">ei_decode_trace()
                </a></li>
<li title="ei_decode_tuple_header"><a href="ei.html#ei_decode_tuple_header">ei_decode_tuple_header()
                </a></li>
<li title="ei_decode_list_header"><a href="ei.html#ei_decode_list_header">ei_decode_list_header()
                </a></li>
<li title="ei_decode_map_header"><a href="ei.html#ei_decode_map_header">ei_decode_map_header()
                </a></li>
<li title="ei_decode_ei_term"><a href="ei.html#ei_decode_ei_term">ei_decode_ei_term()
                </a></li>
<li title="ei_decode_term"><a href="ei.html#ei_decode_term">ei_decode_term()
                </a></li>
<li title="ei_print_term"><a href="ei.html#ei_print_term">ei_print_term()
                </a></li>
<li title="ei_s_print_term"><a href="ei.html#ei_s_print_term">ei_s_print_term()
                </a></li>
<li title="ei_x_format"><a href="ei.html#ei_x_format">ei_x_format()
                </a></li>
<li title="ei_x_format_wo_ver"><a href="ei.html#ei_x_format_wo_ver">ei_x_format_wo_ver()
                </a></li>
<li title="ei_x_new"><a href="ei.html#ei_x_new">ei_x_new()
                </a></li>
<li title="ei_x_new_with_version"><a href="ei.html#ei_x_new_with_version">ei_x_new_with_version()
                </a></li>
<li title="ei_x_free"><a href="ei.html#ei_x_free">ei_x_free()
                </a></li>
<li title="ei_x_append"><a href="ei.html#ei_x_append">ei_x_append()
                </a></li>
<li title="ei_x_append_buf"><a href="ei.html#ei_x_append_buf">ei_x_append_buf()
                </a></li>
<li title="ei_skip_term"><a href="ei.html#ei_skip_term">ei_skip_term()
                </a></li>
</ul>
</li>
<li id="no" title="ei_connect " expanded="false">ei_connect<ul>
<li><a href="ei_connect.html">
                  Top of manual page
                </a></li>
<li title="ei_connect_init"><a href="ei_connect.html#ei_connect_init">ei_connect_init()
                </a></li>
<li title="ei_connect_xinit"><a href="ei_connect.html#ei_connect_xinit">ei_connect_xinit()
                </a></li>
<li title="ei_connect"><a href="ei_connect.html#ei_connect">ei_connect()
                </a></li>
<li title="ei_xconnect"><a href="ei_connect.html#ei_xconnect">ei_xconnect()
                </a></li>
<li title="ei_connect_tmo"><a href="ei_connect.html#ei_connect_tmo">ei_connect_tmo()
                </a></li>
<li title="ei_xconnect_tmo"><a href="ei_connect.html#ei_xconnect_tmo">ei_xconnect_tmo()
                </a></li>
<li title="ei_receive"><a href="ei_connect.html#ei_receive">ei_receive()
                </a></li>
<li title="ei_receive_tmo"><a href="ei_connect.html#ei_receive_tmo">ei_receive_tmo()
                </a></li>
<li title="ei_receive_msg"><a href="ei_connect.html#ei_receive_msg">ei_receive_msg()
                </a></li>
<li title="ei_xreceive_msg"><a href="ei_connect.html#ei_xreceive_msg">ei_xreceive_msg()
                </a></li>
<li title="ei_receive_msg_tmo"><a href="ei_connect.html#ei_receive_msg_tmo">ei_receive_msg_tmo()
                </a></li>
<li title="ei_xreceive_msg_tmo"><a href="ei_connect.html#ei_xreceive_msg_tmo">ei_xreceive_msg_tmo()
                </a></li>
<li title="ei_receive_encoded"><a href="ei_connect.html#ei_receive_encoded">ei_receive_encoded()
                </a></li>
<li title="ei_receive_encoded_tmo"><a href="ei_connect.html#ei_receive_encoded_tmo">ei_receive_encoded_tmo()
                </a></li>
<li title="ei_send"><a href="ei_connect.html#ei_send">ei_send()
                </a></li>
<li title="ei_send_tmo"><a href="ei_connect.html#ei_send_tmo">ei_send_tmo()
                </a></li>
<li title="ei_send_encoded"><a href="ei_connect.html#ei_send_encoded">ei_send_encoded()
                </a></li>
<li title="ei_send_encoded_tmo"><a href="ei_connect.html#ei_send_encoded_tmo">ei_send_encoded_tmo()
                </a></li>
<li title="ei_reg_send"><a href="ei_connect.html#ei_reg_send">ei_reg_send()
                </a></li>
<li title="ei_reg_send_tmo"><a href="ei_connect.html#ei_reg_send_tmo">ei_reg_send_tmo()
                </a></li>
<li title="ei_send_reg_encoded"><a href="ei_connect.html#ei_send_reg_encoded">ei_send_reg_encoded()
                </a></li>
<li title="ei_send_reg_encoded_tmo"><a href="ei_connect.html#ei_send_reg_encoded_tmo">ei_send_reg_encoded_tmo()
                </a></li>
<li title="ei_rpc"><a href="ei_connect.html#ei_rpc">ei_rpc()
                </a></li>
<li title="ei_rpc_to"><a href="ei_connect.html#ei_rpc_to">ei_rpc_to()
                </a></li>
<li title="ei_rpc_from"><a href="ei_connect.html#ei_rpc_from">ei_rpc_from()
                </a></li>
<li title="ei_publish"><a href="ei_connect.html#ei_publish">ei_publish()
                </a></li>
<li title="ei_publish_tmo"><a href="ei_connect.html#ei_publish_tmo">ei_publish_tmo()
                </a></li>
<li title="ei_accept"><a href="ei_connect.html#ei_accept">ei_accept()
                </a></li>
<li title="ei_accept_tmo"><a href="ei_connect.html#ei_accept_tmo">ei_accept_tmo()
                </a></li>
<li title="ei_unpublish"><a href="ei_connect.html#ei_unpublish">ei_unpublish()
                </a></li>
<li title="ei_unpublish_tmo"><a href="ei_connect.html#ei_unpublish_tmo">ei_unpublish_tmo()
                </a></li>
<li title="ei_thisnodename"><a href="ei_connect.html#ei_thisnodename">ei_thisnodename()
                </a></li>
<li title="ei_thishostname"><a href="ei_connect.html#ei_thishostname">ei_thishostname()
                </a></li>
<li title="ei_thisalivename"><a href="ei_connect.html#ei_thisalivename">ei_thisalivename()
                </a></li>
<li title="ei_self"><a href="ei_connect.html#ei_self">ei_self()
                </a></li>
<li title="*ei_gethostbyname"><a href="ei_connect.html#*ei_gethostbyname">*ei_gethostbyname()
                </a></li>
<li title="*ei_gethostbyaddr"><a href="ei_connect.html#*ei_gethostbyaddr">*ei_gethostbyaddr()
                </a></li>
<li title="*ei_gethostbyname_r"><a href="ei_connect.html#*ei_gethostbyname_r">*ei_gethostbyname_r()
                </a></li>
<li title="*ei_gethostbyaddr_r"><a href="ei_connect.html#*ei_gethostbyaddr_r">*ei_gethostbyaddr_r()
                </a></li>
<li title="ei_get_tracelevel"><a href="ei_connect.html#ei_get_tracelevel">ei_get_tracelevel()
                </a></li>
<li title="ei_set_tracelevel"><a href="ei_connect.html#ei_set_tracelevel">ei_set_tracelevel()
                </a></li>
</ul>
</li>
<li id="no" title="registry " expanded="false">registry<ul>
<li><a href="registry.html">
                  Top of manual page
                </a></li>
<li title="ei_reg_open"><a href="registry.html#ei_reg_open">ei_reg_open()
                </a></li>
<li title="ei_reg_resize"><a href="registry.html#ei_reg_resize">ei_reg_resize()
                </a></li>
<li title="ei_reg_close"><a href="registry.html#ei_reg_close">ei_reg_close()
                </a></li>
<li title="ei_reg_setival"><a href="registry.html#ei_reg_setival">ei_reg_setival()
                </a></li>
<li title="ei_reg_setfval"><a href="registry.html#ei_reg_setfval">ei_reg_setfval()
                </a></li>
<li title="ei_reg_setsval"><a href="registry.html#ei_reg_setsval">ei_reg_setsval()
                </a></li>
<li title="ei_reg_setpval"><a href="registry.html#ei_reg_setpval">ei_reg_setpval()
                </a></li>
<li title="ei_reg_setval"><a href="registry.html#ei_reg_setval">ei_reg_setval()
                </a></li>
<li title="ei_reg_getival"><a href="registry.html#ei_reg_getival">ei_reg_getival()
                </a></li>
<li title="ei_reg_getfval"><a href="registry.html#ei_reg_getfval">ei_reg_getfval()
                </a></li>
<li title="ei_reg_getsval"><a href="registry.html#ei_reg_getsval">ei_reg_getsval()
                </a></li>
<li title="ei_reg_getpval"><a href="registry.html#ei_reg_getpval">ei_reg_getpval()
                </a></li>
<li title="ei_reg_getval"><a href="registry.html#ei_reg_getval">ei_reg_getval()
                </a></li>
<li title="ei_reg_markdirty"><a href="registry.html#ei_reg_markdirty">ei_reg_markdirty()
                </a></li>
<li title="ei_reg_delete"><a href="registry.html#ei_reg_delete">ei_reg_delete()
                </a></li>
<li title="ei_reg_stat"><a href="registry.html#ei_reg_stat">ei_reg_stat()
                </a></li>
<li title="ei_reg_tabstat"><a href="registry.html#ei_reg_tabstat">ei_reg_tabstat()
                </a></li>
<li title="ei_reg_dump"><a href="registry.html#ei_reg_dump">ei_reg_dump()
                </a></li>
<li title="ei_reg_restore"><a href="registry.html#ei_reg_restore">ei_reg_restore()
                </a></li>
<li title="ei_reg_purge"><a href="registry.html#ei_reg_purge">ei_reg_purge()
                </a></li>
</ul>
</li>
<li id="loadscrollpos" title="erl_connect " expanded="true">erl_connect<ul>
<li><a href="erl_connect.html">
                  Top of manual page
                </a></li>
<li title="erl_connect_init"><a href="erl_connect.html#erl_connect_init">erl_connect_init()
                </a></li>
<li title="erl_connect_xinit"><a href="erl_connect.html#erl_connect_xinit">erl_connect_xinit()
                </a></li>
<li title="erl_connect"><a href="erl_connect.html#erl_connect">erl_connect()
                </a></li>
<li title="erl_xconnect"><a href="erl_connect.html#erl_xconnect">erl_xconnect()
                </a></li>
<li title="erl_close_connection"><a href="erl_connect.html#erl_close_connection">erl_close_connection()
                </a></li>
<li title="erl_receive"><a href="erl_connect.html#erl_receive">erl_receive()
                </a></li>
<li title="erl_receive_msg"><a href="erl_connect.html#erl_receive_msg">erl_receive_msg()
                </a></li>
<li title="erl_xreceive_msg"><a href="erl_connect.html#erl_xreceive_msg">erl_xreceive_msg()
                </a></li>
<li title="erl_send"><a href="erl_connect.html#erl_send">erl_send()
                </a></li>
<li title="erl_reg_send"><a href="erl_connect.html#erl_reg_send">erl_reg_send()
                </a></li>
<li title="erl_rpc"><a href="erl_connect.html#erl_rpc">erl_rpc()
                </a></li>
<li title="erl_rpc_to"><a href="erl_connect.html#erl_rpc_to">erl_rpc_to()
                </a></li>
<li title="erl_rpc_from"><a href="erl_connect.html#erl_rpc_from">erl_rpc_from()
                </a></li>
<li title="erl_publish"><a href="erl_connect.html#erl_publish">erl_publish()
                </a></li>
<li title="erl_accept"><a href="erl_connect.html#erl_accept">erl_accept()
                </a></li>
<li title="erl_thiscookie"><a href="erl_connect.html#erl_thiscookie">erl_thiscookie()
                </a></li>
<li title="erl_thisnodename"><a href="erl_connect.html#erl_thisnodename">erl_thisnodename()
                </a></li>
<li title="erl_thishostname"><a href="erl_connect.html#erl_thishostname">erl_thishostname()
                </a></li>
<li title="erl_thisalivename"><a href="erl_connect.html#erl_thisalivename">erl_thisalivename()
                </a></li>
<li title="erl_thiscreation"><a href="erl_connect.html#erl_thiscreation">erl_thiscreation()
                </a></li>
<li title="erl_unpublish"><a href="erl_connect.html#erl_unpublish">erl_unpublish()
                </a></li>
<li title="*erl_gethostbyname"><a href="erl_connect.html#*erl_gethostbyname">*erl_gethostbyname()
                </a></li>
<li title="*erl_gethostbyaddr"><a href="erl_connect.html#*erl_gethostbyaddr">*erl_gethostbyaddr()
                </a></li>
<li title="*erl_gethostbyname_r"><a href="erl_connect.html#*erl_gethostbyname_r">*erl_gethostbyname_r()
                </a></li>
<li title="*erl_gethostbyaddr_r"><a href="erl_connect.html#*erl_gethostbyaddr_r">*erl_gethostbyaddr_r()
                </a></li>
</ul>
</li>
<li id="no" title="erl_error " expanded="false">erl_error<ul>
<li><a href="erl_error.html">
                  Top of manual page
                </a></li>
<li title="erl_err_msg"><a href="erl_error.html#erl_err_msg">erl_err_msg()
                </a></li>
<li title="erl_err_quit"><a href="erl_error.html#erl_err_quit">erl_err_quit()
                </a></li>
<li title="erl_err_ret"><a href="erl_error.html#erl_err_ret">erl_err_ret()
                </a></li>
<li title="erl_err_sys"><a href="erl_error.html#erl_err_sys">erl_err_sys()
                </a></li>
<li title=""><a href="erl_error.html#">erl_errno()
                </a></li>
</ul>
</li>
<li id="no" title="erl_eterm " expanded="false">erl_eterm<ul>
<li><a href="erl_eterm.html">
                  Top of manual page
                </a></li>
<li title="erl_cons"><a href="erl_eterm.html#erl_cons">erl_cons()
                </a></li>
<li title="erl_copy_term"><a href="erl_eterm.html#erl_copy_term">erl_copy_term()
                </a></li>
<li title="erl_element"><a href="erl_eterm.html#erl_element">erl_element()
                </a></li>
<li title="erl_init"><a href="erl_eterm.html#erl_init">erl_init()
                </a></li>
<li title="erl_hd"><a href="erl_eterm.html#erl_hd">erl_hd()
                </a></li>
<li title="erl_iolist_to_binary"><a href="erl_eterm.html#erl_iolist_to_binary">erl_iolist_to_binary()
                </a></li>
<li title="erl_iolist_to_string"><a href="erl_eterm.html#erl_iolist_to_string">erl_iolist_to_string()
                </a></li>
<li title="erl_iolist_length"><a href="erl_eterm.html#erl_iolist_length">erl_iolist_length()
                </a></li>
<li title="erl_length"><a href="erl_eterm.html#erl_length">erl_length()
                </a></li>
<li title="erl_mk_atom"><a href="erl_eterm.html#erl_mk_atom">erl_mk_atom()
                </a></li>
<li title="erl_mk_binary"><a href="erl_eterm.html#erl_mk_binary">erl_mk_binary()
                </a></li>
<li title="erl_mk_empty_list"><a href="erl_eterm.html#erl_mk_empty_list">erl_mk_empty_list()
                </a></li>
<li title="erl_mk_estring"><a href="erl_eterm.html#erl_mk_estring">erl_mk_estring()
                </a></li>
<li title="erl_mk_float"><a href="erl_eterm.html#erl_mk_float">erl_mk_float()
                </a></li>
<li title="erl_mk_int"><a href="erl_eterm.html#erl_mk_int">erl_mk_int()
                </a></li>
<li title="erl_mk_list"><a href="erl_eterm.html#erl_mk_list">erl_mk_list()
                </a></li>
<li title="erl_mk_pid"><a href="erl_eterm.html#erl_mk_pid">erl_mk_pid()
                </a></li>
<li title="erl_mk_port"><a href="erl_eterm.html#erl_mk_port">erl_mk_port()
                </a></li>
<li title="erl_mk_ref"><a href="erl_eterm.html#erl_mk_ref">erl_mk_ref()
                </a></li>
<li title="erl_mk_long_ref"><a href="erl_eterm.html#erl_mk_long_ref">erl_mk_long_ref()
                </a></li>
<li title="erl_mk_string"><a href="erl_eterm.html#erl_mk_string">erl_mk_string()
                </a></li>
<li title="erl_mk_tuple"><a href="erl_eterm.html#erl_mk_tuple">erl_mk_tuple()
                </a></li>
<li title="erl_mk_uint"><a href="erl_eterm.html#erl_mk_uint">erl_mk_uint()
                </a></li>
<li title="erl_mk_var"><a href="erl_eterm.html#erl_mk_var">erl_mk_var()
                </a></li>
<li title="erl_print_term"><a href="erl_eterm.html#erl_print_term">erl_print_term()
                </a></li>
<li title="erl_set_compat_rel"><a href="erl_eterm.html#erl_set_compat_rel">erl_set_compat_rel()
                </a></li>
<li title="erl_size"><a href="erl_eterm.html#erl_size">erl_size()
                </a></li>
<li title="erl_tl"><a href="erl_eterm.html#erl_tl">erl_tl()
                </a></li>
<li title="erl_var_content"><a href="erl_eterm.html#erl_var_content">erl_var_content()
                </a></li>
</ul>
</li>
<li id="no" title="erl_format " expanded="false">erl_format<ul>
<li><a href="erl_format.html">
                  Top of manual page
                </a></li>
<li title="erl_format"><a href="erl_format.html#erl_format">erl_format()
                </a></li>
<li title="erl_match"><a href="erl_format.html#erl_match">erl_match()
                </a></li>
</ul>
</li>
<li id="no" title="erl_global " expanded="false">erl_global<ul>
<li><a href="erl_global.html">
                  Top of manual page
                </a></li>
<li title="erl_global_names"><a href="erl_global.html#erl_global_names">erl_global_names()
                </a></li>
<li title="erl_global_register"><a href="erl_global.html#erl_global_register">erl_global_register()
                </a></li>
<li title="erl_global_unregister"><a href="erl_global.html#erl_global_unregister">erl_global_unregister()
                </a></li>
<li title="erl_global_whereis"><a href="erl_global.html#erl_global_whereis">erl_global_whereis()
                </a></li>
</ul>
</li>
<li id="no" title="erl_malloc " expanded="false">erl_malloc<ul>
<li><a href="erl_malloc.html">
                  Top of manual page
                </a></li>
<li title="erl_alloc_eterm"><a href="erl_malloc.html#erl_alloc_eterm">erl_alloc_eterm()
                </a></li>
<li title="erl_eterm_release"><a href="erl_malloc.html#erl_eterm_release">erl_eterm_release()
                </a></li>
<li title="erl_eterm_statistics"><a href="erl_malloc.html#erl_eterm_statistics">erl_eterm_statistics()
                </a></li>
<li title="erl_free_array"><a href="erl_malloc.html#erl_free_array">erl_free_array()
                </a></li>
<li title="erl_free_term"><a href="erl_malloc.html#erl_free_term">erl_free_term()
                </a></li>
<li title="erl_free_compound"><a href="erl_malloc.html#erl_free_compound">erl_free_compound()
                </a></li>
<li title="erl_malloc"><a href="erl_malloc.html#erl_malloc">erl_malloc()
                </a></li>
<li title="erl_free"><a href="erl_malloc.html#erl_free">erl_free()
                </a></li>
</ul>
</li>
<li id="no" title="erl_marshal " expanded="false">erl_marshal<ul>
<li><a href="erl_marshal.html">
                  Top of manual page
                </a></li>
<li title="erl_compare_ext"><a href="erl_marshal.html#erl_compare_ext">erl_compare_ext()
                </a></li>
<li title="erl_decode"><a href="erl_marshal.html#erl_decode">erl_decode()
                </a></li>
<li title="erl_decode_buf"><a href="erl_marshal.html#erl_decode_buf">erl_decode_buf()
                </a></li>
<li title="erl_encode"><a href="erl_marshal.html#erl_encode">erl_encode()
                </a></li>
<li title="erl_encode_buf"><a href="erl_marshal.html#erl_encode_buf">erl_encode_buf()
                </a></li>
<li title="erl_ext_size"><a href="erl_marshal.html#erl_ext_size">erl_ext_size()
                </a></li>
<li title="erl_ext_type"><a href="erl_marshal.html#erl_ext_type">erl_ext_type()
                </a></li>
<li title="erl_peek_ext"><a href="erl_marshal.html#erl_peek_ext">erl_peek_ext()
                </a></li>
<li title="erl_term_len"><a href="erl_marshal.html#erl_term_len">erl_term_len()
                </a></li>
</ul>
</li>
<li title="erl_call"><a href="erl_call.html">erl_call</a></li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>erl_connect</h1></center>
  
  <h3>C LIBRARY</h3>
<div class="REFBODY">erl_connect</div>
  <h3>LIBRARY SUMMARY</h3>
<div class="REFBODY">Communicate with Distributed Erlang</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>This module provides support for communication between distributed
      Erlang nodes and C nodes, in a manner that is transparent to Erlang
      processes.</p>
    <p>A C node appears to Erlang as a
      <strong>hidden node</strong>.
      That is, Erlang processes that know the name of the
      C node are able to communicate with it in a normal manner, but
      the node name will not appear in the listing provided by the
      Erlang function <span class="code">nodes/0</span>.</p>
  </p></div>
  <h3>EXPORTS</h3>
    <p><a name="erl_connect_init"><span class="bold_code">int erl_connect_init(number, cookie, creation)</span></a><br><a name="erl_connect_xinit"><span class="bold_code">int erl_connect_xinit(host, alive, node, addr, cookie, creation)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int number;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">char *cookie;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">short creation;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">char *host,*alive,*node;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">struct in_addr *addr;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>These functions initialize the <span class="code">erl_connect</span>
          module. In particular, they are used to identify the name of the
          C-node from which they are called. One of these functions must
          be called before any of the other functions in the erl_connect 
          module are used.</p>
        <p><span class="code">erl_connect_xinit()</span> stores for later use information about
          the node's host name <span class="code">host</span>, alive name <span class="code">alive</span>, node
          name <span class="code">node</span>, IP address <span class="code">addr</span>, cookie <span class="code">cookie</span>,
          and creation number <span class="code">creation</span>. <span class="code">erl_connect_init()</span>
          provides an alternative interface which does not require as much
          information from the caller. Instead, <span class="code">erl_connect_init()</span>
          uses <span class="code">gethostbyname()</span> to obtain default values. 
          </p>
        <p>If you use <span class="code">erl_connect_init()</span> your node will have a
          short name, i.e., it will not be fully qualified. If you need to
          use fully qualified (a.k.a. long) names, use
          <span class="code">erl_connect_xinit()</span> instead. 
          </p>
        <p><span class="code">host</span> is the name of the host on which the node is running.</p>
        <p><span class="code">alive</span> is the alivename of the node.</p>
        <p><span class="code">node</span> is the name of the node. The nodename should
          be of the form <strong>alivename@hostname</strong>.</p>
        <p><span class="code">addr</span> is the 32-bit IP address of <span class="code">host</span>.</p>
        <p><span class="code">cookie</span> is the authorization string required for access
          to the remote node. If NULL the user HOME directory is
          searched for a cookie file <span class="code">.erlang.cookie</span>. The path to
          the home directory is retrieved from the environment variable
          <span class="code">HOME</span> on Unix and from the <span class="code">HOMEDRIVE</span> and
          <span class="code">HOMEPATH</span> variables on Windows. Refer to the <span class="code">auth</span>
          module for more details.</p>
        <p><span class="code">creation</span> helps identify a particular instance of a C
          node. In particular, it can help prevent us from receiving
          messages sent to an earlier process with the same registered
          name.</p>
        <p>A C node acting as a server will be assigned a creation number
          when it calls <span class="code">erl_publish()</span>.</p>
        <p><span class="code">number</span> is used by <span class="code">erl_connect_init()</span> to
          construct the actual node name. In the second example shown
          below, <strong>"c17@a.DNS.name"</strong> will be the resulting node
          name.</p>
        <p>Example 1:</p>
        <div class="example"><pre>
struct in_addr addr;
addr = inet_addr("150.236.14.75");
if (!erl_connect_xinit("chivas",
                       "madonna",
                       "madonna@chivas.du.etx.ericsson.se",
                       &amp;addr;
                       "samplecookiestring..."),
                       0)
  erl_err_quit("&lt;ERROR&gt; when initializing !");
        </pre></div>
        <p>Example 2:</p>
        <div class="example"><pre>
if (!erl_connect_init(17, "samplecookiestring...", 0))
  erl_err_quit("&lt;ERROR&gt; when initializing !");
        </pre></div>
      </p></div>
    <p><a name="erl_connect"><span class="bold_code">int erl_connect(node)</span></a><br><a name="erl_xconnect"><span class="bold_code">int erl_xconnect(addr, alive)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">char *node, *alive;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">struct in_addr *addr;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>These functions set up a connection to an Erlang node.</p>
        <p><span class="code">erl_xconnect()</span> requires the IP address of the remote
          host and the alive name of the remote node
          to be specified. <span class="code">erl_connect()</span> provides an alternative
          interface, and determines the information from the node name
          provided.</p>
        <p><span class="code">addr</span> is the 32-bit IP address of the remote host.</p>
        <p><span class="code">alive</span> is the alivename of the remote node.</p>
        <p><span class="code">node</span> is the name of the remote node.</p>
        <p>These functions return an open file descriptor on success, or
          a negative value indicating that an error occurred --- in
          which case they will set <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">EHOSTUNREACH</span></strong></dt>
          <dd>The remote host <span class="code">node</span> is unreachable</dd>
          <dt><strong><span class="code">ENOMEM</span></strong></dt>
          <dd>No more memory available.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
        <p>Additionally, <span class="code">errno</span> values from
          <span class="code">socket</span><strong>(2)</strong> and <span class="code">connect</span><strong>(2)</strong>
          system calls may be propagated into <span class="code">erl_errno</span>.</p>
        <div class="example"><pre>
#define NODE   "madonna@chivas.du.etx.ericsson.se"
#define ALIVE  "madonna"
#define IP_ADDR "150.236.14.75"

/*** Variant 1 ***/
erl_connect( NODE );

/*** Variant 2 ***/
struct in_addr addr;
addr = inet_addr(IP_ADDR);
erl_xconnect( &amp;addr , ALIVE );
        </pre></div>
      </p></div>
    <p><a name="erl_close_connection"><span class="bold_code">int erl_close_connection(fd)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function closes an open connection to an Erlang node.</p>
        <p><span class="code">Fd</span> is a file descriptor obtained from
          <span class="code">erl_connect()</span> or <span class="code">erl_xconnect()</span>.</p>
        <p>On success, 0 is returned. If the call fails, a non-zero value
          is returned, and the reason for
          the error can be obtained with the appropriate platform-dependent
          call.</p>
      </p></div>
    <p><a name="erl_receive"><span class="bold_code">int erl_receive(fd, bufp, bufsize)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">char *bufp;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int bufsize;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function receives a message consisting of a sequence
          of bytes in the Erlang external format.</p>
        <p><span class="code">fd</span> is an open descriptor to an Erlang connection.</p>
        <p><span class="code">bufp</span> is a buffer large enough to hold the expected
          message. </p>
        <p><span class="code">bufsize</span> indicates the size of <span class="code">bufp</span>.</p>
        <p>If a <strong>tick</strong> occurs, i.e., the Erlang node on the
          other end of the connection has polled this node to see if it
          is still alive, the function will return <span class="code">ERL_TICK</span> and
          no message will be placed in the buffer. Also,
          <span class="code">erl_errno</span> will be set to <span class="code">EAGAIN</span>.</p>
        <p>On success, the message is placed in the specified buffer
          and the function returns the number of bytes actually read. On
          failure, the function returns a negative value and will set
          <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">EAGAIN</span></strong></dt>
          <dd>Temporary error: Try again.</dd>
          <dt><strong><span class="code">EMSGSIZE</span></strong></dt>
          <dd>Buffer too small.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
      </p></div>
    <p><a name="erl_receive_msg"><span class="bold_code">int erl_receive_msg(fd, bufp, bufsize, emsg)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">unsigned char *bufp;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int bufsize;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ErlMessage *emsg;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function receives the message into the specified buffer, 
          and decodes into the <span class="code">(ErlMessage *) emsg</span>.</p>
        <p><span class="code">fd</span> is an open descriptor to an Erlang connection.</p>
        <p><span class="code">bufp</span> is a buffer large enough to hold the expected message.</p>
        <p><span class="code">bufsize</span> indicates the size of <span class="code">bufp</span>.</p>
        <p><span class="code">emsg</span> is a pointer to an <span class="code">ErlMessage</span> structure,
          into which the message will be decoded. <span class="code">ErlMessage</span> is
          defined as follows:</p>
        <div class="example"><pre>
typedef struct {
  int type;
  ETERM *msg;
  ETERM *to;
  ETERM *from;
  char to_name[MAXREGLEN];
} ErlMessage;
        </pre></div>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>The definition of <span class="code">ErlMessage</span> has changed since
            earlier versions of Erl_Interface.</p>
        </p></div>
</div>
        <p><span class="code">type</span> identifies the type of message, one of 
          <span class="code">ERL_SEND</span>, <span class="code">ERL_REG_SEND</span>, <span class="code">ERL_LINK</span>,
          <span class="code">ERL_UNLINK</span> and <span class="code">ERL_EXIT</span>. 
          </p>
        <p>If <span class="code">type</span> contains <span class="code">ERL_SEND</span>
          this indicates that an ordinary send operation has taken
          place, and <span class="code">emsg-&gt;to</span> contains the Pid of the
          recipient. If <span class="code">type</span> contains <span class="code">ERL_REG_SEND</span> then a
          registered send operation took place, and <span class="code">emsg-&gt;from</span>
          contains the Pid of the sender. In both cases, the actual
          message will be in <span class="code">emsg-&gt;msg</span>.
          </p>
        <p>If <span class="code">type</span> contains one of <span class="code">ERL_LINK</span> or
          <span class="code">ERL_UNLINK</span>, then <span class="code">emsg-&gt;to</span> and <span class="code">emsg-&gt;from</span>
          contain the pids of the sender and recipient of the link or unlink.
          <span class="code">emsg-&gt;msg</span> is not used in these cases.
          </p>
        <p>If <span class="code">type</span> contains <span class="code">ERL_EXIT</span>, then this
          indicates that a link has been broken. In this case,
          <span class="code">emsg-&gt;to</span> and <span class="code">emsg-&gt;from</span> contain the pids of the
          linked processes, and <span class="code">emsg-&gt;msg</span> contains the reason for
          the exit.
          </p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>It is the caller's responsibility to release the
            memory pointed to by <span class="code">emsg-&gt;msg</span>, <span class="code">emsg-&gt;to</span> and
            <span class="code">emsg-&gt;from</span>.</p>
        </p></div>
</div>
        <p>If a <strong>tick</strong> occurs, i.e., the Erlang node on the
          other end of the connection has polled this node to see if it
          is still alive, the function will return <span class="code">ERL_TICK</span>
          indicating that the tick has been received and responded to,
          but no message will be placed in the buffer. In this case you
          should call <span class="code">erl_receive_msg()</span> again.</p>
        <p>On success, the function returns <span class="code">ERL_MSG</span> and the
          <span class="code">Emsg</span> struct will be initialized as described above, or
          <span class="code">ERL_TICK</span>, in which case no message is returned. On
          failure, the function returns <span class="code">ERL_ERROR</span> and will set
          <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">EMSGSIZE</span></strong></dt>
          <dd>Buffer too small.</dd>
          <dt><strong><span class="code">ENOMEM</span></strong></dt>
          <dd>No more memory available.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
      </p></div>
    <p><a name="erl_xreceive_msg"><span class="bold_code">int erl_xreceive_msg(fd, bufpp, bufsizep, emsg)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">unsigned char **bufpp;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int *bufsizep;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ErlMessage *emsg;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function is similar to <span class="code">erl_receive_msg</span>. The
          difference is that <span class="code">erl_xreceive_msg</span> expects the buffer to
          have been allocated by <span class="code">malloc</span>, and reallocates it if the received
          message does not fit into the original buffer. For that reason,
          both buffer and buffer length are given as pointers - their values
          may change by the call.
          </p>
        <p>On success, the function returns <span class="code">ERL_MSG</span> and the
          <span class="code">Emsg</span> struct will be initialized as described above, or
          <span class="code">ERL_TICK</span>, in which case no message is returned. On
          failure, the function returns <span class="code">ERL_ERROR</span> and will set
          <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">EMSGSIZE</span></strong></dt>
          <dd>Buffer too small.</dd>
          <dt><strong><span class="code">ENOMEM</span></strong></dt>
          <dd>No more memory available.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
      </p></div>
    <p><a name="erl_send"><span class="bold_code">int erl_send(fd, to, msg)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ETERM *to, *msg;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function sends an Erlang term to a process.</p>
        <p><span class="code">fd</span> is an open descriptor to an Erlang connection.</p>
        <p><span class="code">to</span> is an Erlang term containing the Pid of the
          intended recipient of the message.</p>
        <p><span class="code">msg</span> is the Erlang term to be sent.</p>
        <p>The function returns 1 if successful, otherwise 0 --- in
          which case it will set <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">EINVAL</span></strong></dt>
          <dd>Invalid argument: <span class="code">to</span> is not a valid Erlang pid.</dd>
          <dt><strong><span class="code">ENOMEM</span></strong></dt>
          <dd>No more memory available.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
      </p></div>
    <p><a name="erl_reg_send"><span class="bold_code">int erl_reg_send(fd, to, msg)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">char *to;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ETERM *msg;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function sends an Erlang term to a registered process.</p>
        <p><span class="code">fd</span> is an open descriptor to an Erlang connection.</p>
        <p><span class="code">to</span> is a string containing the registered name of
          the intended recipient of the message.</p>
        <p><span class="code">msg</span> is the Erlang term to be sent.</p>
        <p>The function returns 1 if successful, otherwise 0 --- in
          which case it will set <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">ENOMEM</span></strong></dt>
          <dd>No more memory available.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
      </p></div>
    <p><a name="erl_rpc"><span class="bold_code">ETERM *erl_rpc(fd, mod, fun, args)</span></a><br><a name="erl_rpc_to"><span class="bold_code">int erl_rpc_to(fd, mod, fun, args)</span></a><br><a name="erl_rpc_from"><span class="bold_code">int erl_rpc_from(fd, timeout, emsg)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd, timeout;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">char *mod, *fun;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ETERM *args;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ErlMessage *emsg;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>These functions support calling Erlang functions on remote nodes.
          <span class="code">erl_rpc_to()</span> sends an rpc request to a remote node and
          <span class="code">erl_rpc_from()</span> receives the results of such a call.
          <span class="code">erl_rpc()</span> combines the functionality of these two functions
          by sending an rpc request and waiting for the results. See also
          <span class="code">rpc:call/4</span>. </p>
        <p><span class="code">fd</span> is an open descriptor to an Erlang connection.</p>
        <p><span class="code">timeout</span> is the maximum time (in ms) to wait for
          results. Specify <span class="code">ERL_NO_TIMEOUT</span> to wait forever.
          When erl_rpc() calls erl_rpc_from(), the call will never
          timeout.</p>
        <p><span class="code">mod</span> is the name of the module containing the function
          to be run on the remote node.</p>
        <p><span class="code">fun</span> is the name of the function to run.</p>
        <p><span class="code">args</span> is an Erlang list, containing the arguments to be
          passed to the function. </p>
        <p><span class="code">emsg</span> is a message containing the result of the
          function call.</p>
        <p>The actual message returned by the rpc server
          is a 2-tuple <span class="code">{rex,Reply}</span>. If you are using
          <span class="code">erl_rpc_from()</span> in your code then this is the message you
          will need to parse. If you are using <span class="code">erl_rpc()</span> then the
          tuple itself is parsed for you, and the message returned to your
          program is the erlang term containing <span class="code">Reply</span> only. Replies
          to rpc requests are always ERL_SEND messages.
          </p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>It is the caller's responsibility to free the returned
            <span class="code">ETERM</span> structure as well as the memory pointed to by
            <span class="code">emsg-&gt;msg</span> and <span class="code">emsg-&gt;to</span>.  </p>
        </p></div>
</div>
        <p><span class="code">erl_rpc()</span> returns the remote function's return value (or
          <span class="code">NULL</span> if it failed). <span class="code">erl_rpc_to()</span> returns 0 on
          success, and a negative number on failure. <span class="code">erl_rcp_from()</span>
          returns <span class="code">ERL_MSG</span> when successful (with <span class="code">Emsg</span> now
          containing the reply tuple), and one of <span class="code">ERL_TICK</span>,
          <span class="code">ERL_TIMEOUT</span> and <span class="code">ERL_ERROR</span> otherwise. When failing,
          all three functions set <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">ENOMEM</span></strong></dt>
          <dd>No more memory available.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
          <dt><strong><span class="code">ETIMEDOUT</span></strong></dt>
          <dd>Timeout expired.</dd>
          <dt><strong><span class="code">EAGAIN</span></strong></dt>
          <dd>Temporary error: Try again.</dd>
        </dl>
      </p></div>
    <p><a name="erl_publish"><span class="bold_code">int erl_publish(port)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int port;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>These functions are used by a server process to register
          with the local name server <strong>epmd</strong>, thereby allowing
          other processes to send messages by using the registered name.
          Before calling either of these functions, the process should
          have called <span class="code">bind()</span> and <span class="code">listen()</span> on an open socket.</p>
        <p><span class="code">port</span> is the local name to register, and should be the
          same as the port number that was previously bound to the socket.</p>
        <p>To unregister with epmd, simply close the returned
          descriptor.
          </p>
        <p>On success, the functions return a descriptor connecting the
          calling process to epmd. On failure, they return -1 and set
          <span class="code">erl_errno</span> to:</p>
        <dl>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error</dd>
        </dl>
        <p>Additionally, <span class="code">errno</span> values from <span class="code">socket</span><strong>(2)</strong>
          and <span class="code">connect</span><strong>(2)</strong> system calls may be propagated
          into <span class="code">erl_errno</span>.
          </p>
      </p></div>
    <p><a name="erl_accept"><span class="bold_code">int erl_accept(listensock, conp)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int listensock;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ErlConnect *conp;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function is used by a server process to accept a
          connection from a client process.</p>
        <p><span class="code">listensock</span> is an open socket descriptor on which
          <span class="code">listen()</span> has previously been called.</p>
        <p><span class="code">conp</span> is a pointer to an <span class="code">ErlConnect</span> struct,
          described as follows:</p>
        <div class="example"><pre>
typedef struct {
  char ipadr[4];             
  char nodename[MAXNODELEN];
} ErlConnect;
        </pre></div>
        <p>On success, <span class="code">conp</span> is filled in with the address and
          node name of the connecting client and a file descriptor is
          returned. On failure, <span class="code">ERL_ERROR</span> is returned and
          <span class="code">erl_errno</span> is set to <span class="code">EIO</span>.</p>
      </p></div>
    <p><a name="erl_thiscookie"><span class="bold_code">const char *erl_thiscookie()</span></a><br><a name="erl_thisnodename"><span class="bold_code">const char *erl_thisnodename()</span></a><br><a name="erl_thishostname"><span class="bold_code">const char *erl_thishostname()</span></a><br><a name="erl_thisalivename"><span class="bold_code">const char *erl_thisalivename()</span></a><br><a name="erl_thiscreation"><span class="bold_code">short erl_thiscreation()</span></a><br></p>
<div class="REFBODY"><p>
        <p>These functions can be used to retrieve information about
          the C Node. These values are initially set with
          <span class="code">erl_connect_init()</span> or <span class="code">erl_connect_xinit()</span>.</p>
      </p></div>
    <p><a name="erl_unpublish"><span class="bold_code">int erl_unpublish(alive)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">char *alive;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
       <p>This function can be called by a process to unregister a
          specified node from epmd on the localhost. This is however usually not 
	  allowed, unless epmd was started with the -relaxed_command_check 
	  flag, which it normally isn't.</p>

	  <p>To unregister a node you have published, you should instead
	  close the descriptor that was returned by  
	  <span class="code">ei_publish()</span>.</p> 

        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>This function is deprecated and will be removed in a future 
	  release.</p>
        </p></div>
</div>
        <p><span class="code">alive</span> is the name of the node to unregister, i.e., the
          first component of the nodename, without the <span class="code">@hostname</span>.</p>
        <p>If the node was successfully unregistered from epmd, the
          function returns 0. Otherwise, it returns -1 and sets
          <span class="code">erl_errno</span> is to <span class="code">EIO</span>.</p>
      </p></div>
    <p><a name="*erl_gethostbyname"><span class="bold_code">struct hostent *erl_gethostbyname(name)</span></a><br><a name="*erl_gethostbyaddr"><span class="bold_code">struct hostent *erl_gethostbyaddr(addr, length, type)</span></a><br><a name="*erl_gethostbyname_r"><span class="bold_code">struct hostent *erl_gethostbyname_r(name, hostp, buffer, buflen, h_errnop)</span></a><br><a name="*erl_gethostbyaddr_r"><span class="bold_code">struct hostent *erl_gethostbyaddr_r(addr, length, type, hostp, buffer, buflen, h_errnop)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">const char *name;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">const char *addr;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int length;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int type;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">struct hostent *hostp;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">char *buffer;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int buflen;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int *h_errnop;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>These are convenience functions for some common name lookup functions.</p>
      </p></div>
  

  <h3><a name="id82665">Debug Information</a></h3>
<div class="REFBODY">
    
    <p>If a connection attempt fails, the following can be checked:</p>
    <ul>
      <li><span class="code">erl_errno</span></li>
      <li>that the right cookie was used</li>
      <li>that <strong>epmd</strong> is running</li>
      <li>the remote Erlang node on the other side is running the same
       version of Erlang as the <span class="code">erl_interface</span> library.</li>
    </ul>
  </div>
</div>
<div class="footer">
<hr>
<p>Copyright  1998-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
