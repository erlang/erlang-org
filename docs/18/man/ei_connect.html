<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- ei_connect</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/erl_interface/users_guide.html">User's Guide</a><br><a href="../apps/erl_interface/index.html">Reference Manual</a><br><a href="../apps/erl_interface/release_notes.html">Release Notes</a><br><a href="../apps/erl_interface/erl_interface.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Erlang Interface</strong><br><strong>Reference Manual</strong><br><small>Version 3.8.2</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li id="no" title="ei " expanded="false">ei<ul>
<li><a href="ei.html">
                  Top of manual page
                </a></li>
<li title="ei_set_compat_rel"><a href="ei.html#ei_set_compat_rel">ei_set_compat_rel()
                </a></li>
<li title="ei_encode_version"><a href="ei.html#ei_encode_version">ei_encode_version()
                </a></li>
<li title="ei_x_encode_version"><a href="ei.html#ei_x_encode_version">ei_x_encode_version()
                </a></li>
<li title="ei_encode_long"><a href="ei.html#ei_encode_long">ei_encode_long()
                </a></li>
<li title="ei_x_encode_long"><a href="ei.html#ei_x_encode_long">ei_x_encode_long()
                </a></li>
<li title="ei_encode_ulong"><a href="ei.html#ei_encode_ulong">ei_encode_ulong()
                </a></li>
<li title="ei_x_encode_ulong"><a href="ei.html#ei_x_encode_ulong">ei_x_encode_ulong()
                </a></li>
<li title="ei_encode_longlong"><a href="ei.html#ei_encode_longlong">ei_encode_longlong()
                </a></li>
<li title="ei_x_encode_longlong"><a href="ei.html#ei_x_encode_longlong">ei_x_encode_longlong()
                </a></li>
<li title="ei_encode_ulonglong"><a href="ei.html#ei_encode_ulonglong">ei_encode_ulonglong()
                </a></li>
<li title="ei_x_encode_ulonglong"><a href="ei.html#ei_x_encode_ulonglong">ei_x_encode_ulonglong()
                </a></li>
<li title="ei_encode_bignum"><a href="ei.html#ei_encode_bignum">ei_encode_bignum()
                </a></li>
<li title="ei_x_encode_bignum"><a href="ei.html#ei_x_encode_bignum">ei_x_encode_bignum()
                </a></li>
<li title="ei_encode_double"><a href="ei.html#ei_encode_double">ei_encode_double()
                </a></li>
<li title="ei_x_encode_double"><a href="ei.html#ei_x_encode_double">ei_x_encode_double()
                </a></li>
<li title="ei_encode_boolean"><a href="ei.html#ei_encode_boolean">ei_encode_boolean()
                </a></li>
<li title="ei_x_encode_boolean"><a href="ei.html#ei_x_encode_boolean">ei_x_encode_boolean()
                </a></li>
<li title="ei_encode_char"><a href="ei.html#ei_encode_char">ei_encode_char()
                </a></li>
<li title="ei_x_encode_char"><a href="ei.html#ei_x_encode_char">ei_x_encode_char()
                </a></li>
<li title="ei_encode_string"><a href="ei.html#ei_encode_string">ei_encode_string()
                </a></li>
<li title="ei_encode_string_len"><a href="ei.html#ei_encode_string_len">ei_encode_string_len()
                </a></li>
<li title="ei_x_encode_string"><a href="ei.html#ei_x_encode_string">ei_x_encode_string()
                </a></li>
<li title="ei_x_encode_string_len"><a href="ei.html#ei_x_encode_string_len">ei_x_encode_string_len()
                </a></li>
<li title="ei_encode_atom"><a href="ei.html#ei_encode_atom">ei_encode_atom()
                </a></li>
<li title="ei_encode_atom_len"><a href="ei.html#ei_encode_atom_len">ei_encode_atom_len()
                </a></li>
<li title="ei_x_encode_atom"><a href="ei.html#ei_x_encode_atom">ei_x_encode_atom()
                </a></li>
<li title="ei_x_encode_atom_len"><a href="ei.html#ei_x_encode_atom_len">ei_x_encode_atom_len()
                </a></li>
<li title="ei_encode_atom_as"><a href="ei.html#ei_encode_atom_as">ei_encode_atom_as()
                </a></li>
<li title="ei_encode_atom_len_as"><a href="ei.html#ei_encode_atom_len_as">ei_encode_atom_len_as()
                </a></li>
<li title="ei_x_encode_atom_as"><a href="ei.html#ei_x_encode_atom_as">ei_x_encode_atom_as()
                </a></li>
<li title="ei_x_encode_atom_len_as"><a href="ei.html#ei_x_encode_atom_len_as">ei_x_encode_atom_len_as()
                </a></li>
<li title="ei_encode_binary"><a href="ei.html#ei_encode_binary">ei_encode_binary()
                </a></li>
<li title="ei_x_encode_binary"><a href="ei.html#ei_x_encode_binary">ei_x_encode_binary()
                </a></li>
<li title="ei_encode_pid"><a href="ei.html#ei_encode_pid">ei_encode_pid()
                </a></li>
<li title="ei_x_encode_pid"><a href="ei.html#ei_x_encode_pid">ei_x_encode_pid()
                </a></li>
<li title="ei_encode_fun"><a href="ei.html#ei_encode_fun">ei_encode_fun()
                </a></li>
<li title="ei_x_encode_fun"><a href="ei.html#ei_x_encode_fun">ei_x_encode_fun()
                </a></li>
<li title="ei_encode_port"><a href="ei.html#ei_encode_port">ei_encode_port()
                </a></li>
<li title="ei_x_encode_port"><a href="ei.html#ei_x_encode_port">ei_x_encode_port()
                </a></li>
<li title="ei_encode_ref"><a href="ei.html#ei_encode_ref">ei_encode_ref()
                </a></li>
<li title="ei_x_encode_ref"><a href="ei.html#ei_x_encode_ref">ei_x_encode_ref()
                </a></li>
<li title="ei_encode_term"><a href="ei.html#ei_encode_term">ei_encode_term()
                </a></li>
<li title="ei_x_encode_term"><a href="ei.html#ei_x_encode_term">ei_x_encode_term()
                </a></li>
<li title="ei_encode_trace"><a href="ei.html#ei_encode_trace">ei_encode_trace()
                </a></li>
<li title="ei_x_encode_trace"><a href="ei.html#ei_x_encode_trace">ei_x_encode_trace()
                </a></li>
<li title="ei_encode_tuple_header"><a href="ei.html#ei_encode_tuple_header">ei_encode_tuple_header()
                </a></li>
<li title="ei_x_encode_tuple_header"><a href="ei.html#ei_x_encode_tuple_header">ei_x_encode_tuple_header()
                </a></li>
<li title="ei_encode_list_header"><a href="ei.html#ei_encode_list_header">ei_encode_list_header()
                </a></li>
<li title="ei_x_encode_list_header"><a href="ei.html#ei_x_encode_list_header">ei_x_encode_list_header()
                </a></li>
<li title="ei_encode_empty_list"><a href="ei.html#ei_encode_empty_list">ei_encode_empty_list()
                </a></li>
<li title="ei_x_encode_empty_list"><a href="ei.html#ei_x_encode_empty_list">ei_x_encode_empty_list()
                </a></li>
<li title="ei_encode_map_header"><a href="ei.html#ei_encode_map_header">ei_encode_map_header()
                </a></li>
<li title="ei_x_encode_map_header"><a href="ei.html#ei_x_encode_map_header">ei_x_encode_map_header()
                </a></li>
<li title="ei_get_type"><a href="ei.html#ei_get_type">ei_get_type()
                </a></li>
<li title="ei_decode_version"><a href="ei.html#ei_decode_version">ei_decode_version()
                </a></li>
<li title="ei_decode_long"><a href="ei.html#ei_decode_long">ei_decode_long()
                </a></li>
<li title="ei_decode_ulong"><a href="ei.html#ei_decode_ulong">ei_decode_ulong()
                </a></li>
<li title="ei_decode_longlong"><a href="ei.html#ei_decode_longlong">ei_decode_longlong()
                </a></li>
<li title="ei_decode_ulonglong"><a href="ei.html#ei_decode_ulonglong">ei_decode_ulonglong()
                </a></li>
<li title="ei_decode_bignum"><a href="ei.html#ei_decode_bignum">ei_decode_bignum()
                </a></li>
<li title="ei_decode_double"><a href="ei.html#ei_decode_double">ei_decode_double()
                </a></li>
<li title="ei_decode_boolean"><a href="ei.html#ei_decode_boolean">ei_decode_boolean()
                </a></li>
<li title="ei_decode_char"><a href="ei.html#ei_decode_char">ei_decode_char()
                </a></li>
<li title="ei_decode_string"><a href="ei.html#ei_decode_string">ei_decode_string()
                </a></li>
<li title="ei_decode_atom"><a href="ei.html#ei_decode_atom">ei_decode_atom()
                </a></li>
<li title="ei_decode_atom_as"><a href="ei.html#ei_decode_atom_as">ei_decode_atom_as()
                </a></li>
<li title="ei_decode_binary"><a href="ei.html#ei_decode_binary">ei_decode_binary()
                </a></li>
<li title="ei_decode_fun"><a href="ei.html#ei_decode_fun">ei_decode_fun()
                </a></li>
<li title="free_fun"><a href="ei.html#free_fun">free_fun()
                </a></li>
<li title="ei_decode_pid"><a href="ei.html#ei_decode_pid">ei_decode_pid()
                </a></li>
<li title="ei_decode_port"><a href="ei.html#ei_decode_port">ei_decode_port()
                </a></li>
<li title="ei_decode_ref"><a href="ei.html#ei_decode_ref">ei_decode_ref()
                </a></li>
<li title="ei_decode_trace"><a href="ei.html#ei_decode_trace">ei_decode_trace()
                </a></li>
<li title="ei_decode_tuple_header"><a href="ei.html#ei_decode_tuple_header">ei_decode_tuple_header()
                </a></li>
<li title="ei_decode_list_header"><a href="ei.html#ei_decode_list_header">ei_decode_list_header()
                </a></li>
<li title="ei_decode_map_header"><a href="ei.html#ei_decode_map_header">ei_decode_map_header()
                </a></li>
<li title="ei_decode_ei_term"><a href="ei.html#ei_decode_ei_term">ei_decode_ei_term()
                </a></li>
<li title="ei_decode_term"><a href="ei.html#ei_decode_term">ei_decode_term()
                </a></li>
<li title="ei_print_term"><a href="ei.html#ei_print_term">ei_print_term()
                </a></li>
<li title="ei_s_print_term"><a href="ei.html#ei_s_print_term">ei_s_print_term()
                </a></li>
<li title="ei_x_format"><a href="ei.html#ei_x_format">ei_x_format()
                </a></li>
<li title="ei_x_format_wo_ver"><a href="ei.html#ei_x_format_wo_ver">ei_x_format_wo_ver()
                </a></li>
<li title="ei_x_new"><a href="ei.html#ei_x_new">ei_x_new()
                </a></li>
<li title="ei_x_new_with_version"><a href="ei.html#ei_x_new_with_version">ei_x_new_with_version()
                </a></li>
<li title="ei_x_free"><a href="ei.html#ei_x_free">ei_x_free()
                </a></li>
<li title="ei_x_append"><a href="ei.html#ei_x_append">ei_x_append()
                </a></li>
<li title="ei_x_append_buf"><a href="ei.html#ei_x_append_buf">ei_x_append_buf()
                </a></li>
<li title="ei_skip_term"><a href="ei.html#ei_skip_term">ei_skip_term()
                </a></li>
</ul>
</li>
<li id="loadscrollpos" title="ei_connect " expanded="true">ei_connect<ul>
<li><a href="ei_connect.html">
                  Top of manual page
                </a></li>
<li title="ei_connect_init"><a href="ei_connect.html#ei_connect_init">ei_connect_init()
                </a></li>
<li title="ei_connect_xinit"><a href="ei_connect.html#ei_connect_xinit">ei_connect_xinit()
                </a></li>
<li title="ei_connect"><a href="ei_connect.html#ei_connect">ei_connect()
                </a></li>
<li title="ei_xconnect"><a href="ei_connect.html#ei_xconnect">ei_xconnect()
                </a></li>
<li title="ei_connect_tmo"><a href="ei_connect.html#ei_connect_tmo">ei_connect_tmo()
                </a></li>
<li title="ei_xconnect_tmo"><a href="ei_connect.html#ei_xconnect_tmo">ei_xconnect_tmo()
                </a></li>
<li title="ei_receive"><a href="ei_connect.html#ei_receive">ei_receive()
                </a></li>
<li title="ei_receive_tmo"><a href="ei_connect.html#ei_receive_tmo">ei_receive_tmo()
                </a></li>
<li title="ei_receive_msg"><a href="ei_connect.html#ei_receive_msg">ei_receive_msg()
                </a></li>
<li title="ei_xreceive_msg"><a href="ei_connect.html#ei_xreceive_msg">ei_xreceive_msg()
                </a></li>
<li title="ei_receive_msg_tmo"><a href="ei_connect.html#ei_receive_msg_tmo">ei_receive_msg_tmo()
                </a></li>
<li title="ei_xreceive_msg_tmo"><a href="ei_connect.html#ei_xreceive_msg_tmo">ei_xreceive_msg_tmo()
                </a></li>
<li title="ei_receive_encoded"><a href="ei_connect.html#ei_receive_encoded">ei_receive_encoded()
                </a></li>
<li title="ei_receive_encoded_tmo"><a href="ei_connect.html#ei_receive_encoded_tmo">ei_receive_encoded_tmo()
                </a></li>
<li title="ei_send"><a href="ei_connect.html#ei_send">ei_send()
                </a></li>
<li title="ei_send_tmo"><a href="ei_connect.html#ei_send_tmo">ei_send_tmo()
                </a></li>
<li title="ei_send_encoded"><a href="ei_connect.html#ei_send_encoded">ei_send_encoded()
                </a></li>
<li title="ei_send_encoded_tmo"><a href="ei_connect.html#ei_send_encoded_tmo">ei_send_encoded_tmo()
                </a></li>
<li title="ei_reg_send"><a href="ei_connect.html#ei_reg_send">ei_reg_send()
                </a></li>
<li title="ei_reg_send_tmo"><a href="ei_connect.html#ei_reg_send_tmo">ei_reg_send_tmo()
                </a></li>
<li title="ei_send_reg_encoded"><a href="ei_connect.html#ei_send_reg_encoded">ei_send_reg_encoded()
                </a></li>
<li title="ei_send_reg_encoded_tmo"><a href="ei_connect.html#ei_send_reg_encoded_tmo">ei_send_reg_encoded_tmo()
                </a></li>
<li title="ei_rpc"><a href="ei_connect.html#ei_rpc">ei_rpc()
                </a></li>
<li title="ei_rpc_to"><a href="ei_connect.html#ei_rpc_to">ei_rpc_to()
                </a></li>
<li title="ei_rpc_from"><a href="ei_connect.html#ei_rpc_from">ei_rpc_from()
                </a></li>
<li title="ei_publish"><a href="ei_connect.html#ei_publish">ei_publish()
                </a></li>
<li title="ei_publish_tmo"><a href="ei_connect.html#ei_publish_tmo">ei_publish_tmo()
                </a></li>
<li title="ei_accept"><a href="ei_connect.html#ei_accept">ei_accept()
                </a></li>
<li title="ei_accept_tmo"><a href="ei_connect.html#ei_accept_tmo">ei_accept_tmo()
                </a></li>
<li title="ei_unpublish"><a href="ei_connect.html#ei_unpublish">ei_unpublish()
                </a></li>
<li title="ei_unpublish_tmo"><a href="ei_connect.html#ei_unpublish_tmo">ei_unpublish_tmo()
                </a></li>
<li title="ei_thisnodename"><a href="ei_connect.html#ei_thisnodename">ei_thisnodename()
                </a></li>
<li title="ei_thishostname"><a href="ei_connect.html#ei_thishostname">ei_thishostname()
                </a></li>
<li title="ei_thisalivename"><a href="ei_connect.html#ei_thisalivename">ei_thisalivename()
                </a></li>
<li title="ei_self"><a href="ei_connect.html#ei_self">ei_self()
                </a></li>
<li title="*ei_gethostbyname"><a href="ei_connect.html#*ei_gethostbyname">*ei_gethostbyname()
                </a></li>
<li title="*ei_gethostbyaddr"><a href="ei_connect.html#*ei_gethostbyaddr">*ei_gethostbyaddr()
                </a></li>
<li title="*ei_gethostbyname_r"><a href="ei_connect.html#*ei_gethostbyname_r">*ei_gethostbyname_r()
                </a></li>
<li title="*ei_gethostbyaddr_r"><a href="ei_connect.html#*ei_gethostbyaddr_r">*ei_gethostbyaddr_r()
                </a></li>
<li title="ei_get_tracelevel"><a href="ei_connect.html#ei_get_tracelevel">ei_get_tracelevel()
                </a></li>
<li title="ei_set_tracelevel"><a href="ei_connect.html#ei_set_tracelevel">ei_set_tracelevel()
                </a></li>
</ul>
</li>
<li id="no" title="registry " expanded="false">registry<ul>
<li><a href="registry.html">
                  Top of manual page
                </a></li>
<li title="ei_reg_open"><a href="registry.html#ei_reg_open">ei_reg_open()
                </a></li>
<li title="ei_reg_resize"><a href="registry.html#ei_reg_resize">ei_reg_resize()
                </a></li>
<li title="ei_reg_close"><a href="registry.html#ei_reg_close">ei_reg_close()
                </a></li>
<li title="ei_reg_setival"><a href="registry.html#ei_reg_setival">ei_reg_setival()
                </a></li>
<li title="ei_reg_setfval"><a href="registry.html#ei_reg_setfval">ei_reg_setfval()
                </a></li>
<li title="ei_reg_setsval"><a href="registry.html#ei_reg_setsval">ei_reg_setsval()
                </a></li>
<li title="ei_reg_setpval"><a href="registry.html#ei_reg_setpval">ei_reg_setpval()
                </a></li>
<li title="ei_reg_setval"><a href="registry.html#ei_reg_setval">ei_reg_setval()
                </a></li>
<li title="ei_reg_getival"><a href="registry.html#ei_reg_getival">ei_reg_getival()
                </a></li>
<li title="ei_reg_getfval"><a href="registry.html#ei_reg_getfval">ei_reg_getfval()
                </a></li>
<li title="ei_reg_getsval"><a href="registry.html#ei_reg_getsval">ei_reg_getsval()
                </a></li>
<li title="ei_reg_getpval"><a href="registry.html#ei_reg_getpval">ei_reg_getpval()
                </a></li>
<li title="ei_reg_getval"><a href="registry.html#ei_reg_getval">ei_reg_getval()
                </a></li>
<li title="ei_reg_markdirty"><a href="registry.html#ei_reg_markdirty">ei_reg_markdirty()
                </a></li>
<li title="ei_reg_delete"><a href="registry.html#ei_reg_delete">ei_reg_delete()
                </a></li>
<li title="ei_reg_stat"><a href="registry.html#ei_reg_stat">ei_reg_stat()
                </a></li>
<li title="ei_reg_tabstat"><a href="registry.html#ei_reg_tabstat">ei_reg_tabstat()
                </a></li>
<li title="ei_reg_dump"><a href="registry.html#ei_reg_dump">ei_reg_dump()
                </a></li>
<li title="ei_reg_restore"><a href="registry.html#ei_reg_restore">ei_reg_restore()
                </a></li>
<li title="ei_reg_purge"><a href="registry.html#ei_reg_purge">ei_reg_purge()
                </a></li>
</ul>
</li>
<li id="no" title="erl_connect " expanded="false">erl_connect<ul>
<li><a href="erl_connect.html">
                  Top of manual page
                </a></li>
<li title="erl_connect_init"><a href="erl_connect.html#erl_connect_init">erl_connect_init()
                </a></li>
<li title="erl_connect_xinit"><a href="erl_connect.html#erl_connect_xinit">erl_connect_xinit()
                </a></li>
<li title="erl_connect"><a href="erl_connect.html#erl_connect">erl_connect()
                </a></li>
<li title="erl_xconnect"><a href="erl_connect.html#erl_xconnect">erl_xconnect()
                </a></li>
<li title="erl_close_connection"><a href="erl_connect.html#erl_close_connection">erl_close_connection()
                </a></li>
<li title="erl_receive"><a href="erl_connect.html#erl_receive">erl_receive()
                </a></li>
<li title="erl_receive_msg"><a href="erl_connect.html#erl_receive_msg">erl_receive_msg()
                </a></li>
<li title="erl_xreceive_msg"><a href="erl_connect.html#erl_xreceive_msg">erl_xreceive_msg()
                </a></li>
<li title="erl_send"><a href="erl_connect.html#erl_send">erl_send()
                </a></li>
<li title="erl_reg_send"><a href="erl_connect.html#erl_reg_send">erl_reg_send()
                </a></li>
<li title="erl_rpc"><a href="erl_connect.html#erl_rpc">erl_rpc()
                </a></li>
<li title="erl_rpc_to"><a href="erl_connect.html#erl_rpc_to">erl_rpc_to()
                </a></li>
<li title="erl_rpc_from"><a href="erl_connect.html#erl_rpc_from">erl_rpc_from()
                </a></li>
<li title="erl_publish"><a href="erl_connect.html#erl_publish">erl_publish()
                </a></li>
<li title="erl_accept"><a href="erl_connect.html#erl_accept">erl_accept()
                </a></li>
<li title="erl_thiscookie"><a href="erl_connect.html#erl_thiscookie">erl_thiscookie()
                </a></li>
<li title="erl_thisnodename"><a href="erl_connect.html#erl_thisnodename">erl_thisnodename()
                </a></li>
<li title="erl_thishostname"><a href="erl_connect.html#erl_thishostname">erl_thishostname()
                </a></li>
<li title="erl_thisalivename"><a href="erl_connect.html#erl_thisalivename">erl_thisalivename()
                </a></li>
<li title="erl_thiscreation"><a href="erl_connect.html#erl_thiscreation">erl_thiscreation()
                </a></li>
<li title="erl_unpublish"><a href="erl_connect.html#erl_unpublish">erl_unpublish()
                </a></li>
<li title="*erl_gethostbyname"><a href="erl_connect.html#*erl_gethostbyname">*erl_gethostbyname()
                </a></li>
<li title="*erl_gethostbyaddr"><a href="erl_connect.html#*erl_gethostbyaddr">*erl_gethostbyaddr()
                </a></li>
<li title="*erl_gethostbyname_r"><a href="erl_connect.html#*erl_gethostbyname_r">*erl_gethostbyname_r()
                </a></li>
<li title="*erl_gethostbyaddr_r"><a href="erl_connect.html#*erl_gethostbyaddr_r">*erl_gethostbyaddr_r()
                </a></li>
</ul>
</li>
<li id="no" title="erl_error " expanded="false">erl_error<ul>
<li><a href="erl_error.html">
                  Top of manual page
                </a></li>
<li title="erl_err_msg"><a href="erl_error.html#erl_err_msg">erl_err_msg()
                </a></li>
<li title="erl_err_quit"><a href="erl_error.html#erl_err_quit">erl_err_quit()
                </a></li>
<li title="erl_err_ret"><a href="erl_error.html#erl_err_ret">erl_err_ret()
                </a></li>
<li title="erl_err_sys"><a href="erl_error.html#erl_err_sys">erl_err_sys()
                </a></li>
<li title=""><a href="erl_error.html#">erl_errno()
                </a></li>
</ul>
</li>
<li id="no" title="erl_eterm " expanded="false">erl_eterm<ul>
<li><a href="erl_eterm.html">
                  Top of manual page
                </a></li>
<li title="erl_cons"><a href="erl_eterm.html#erl_cons">erl_cons()
                </a></li>
<li title="erl_copy_term"><a href="erl_eterm.html#erl_copy_term">erl_copy_term()
                </a></li>
<li title="erl_element"><a href="erl_eterm.html#erl_element">erl_element()
                </a></li>
<li title="erl_init"><a href="erl_eterm.html#erl_init">erl_init()
                </a></li>
<li title="erl_hd"><a href="erl_eterm.html#erl_hd">erl_hd()
                </a></li>
<li title="erl_iolist_to_binary"><a href="erl_eterm.html#erl_iolist_to_binary">erl_iolist_to_binary()
                </a></li>
<li title="erl_iolist_to_string"><a href="erl_eterm.html#erl_iolist_to_string">erl_iolist_to_string()
                </a></li>
<li title="erl_iolist_length"><a href="erl_eterm.html#erl_iolist_length">erl_iolist_length()
                </a></li>
<li title="erl_length"><a href="erl_eterm.html#erl_length">erl_length()
                </a></li>
<li title="erl_mk_atom"><a href="erl_eterm.html#erl_mk_atom">erl_mk_atom()
                </a></li>
<li title="erl_mk_binary"><a href="erl_eterm.html#erl_mk_binary">erl_mk_binary()
                </a></li>
<li title="erl_mk_empty_list"><a href="erl_eterm.html#erl_mk_empty_list">erl_mk_empty_list()
                </a></li>
<li title="erl_mk_estring"><a href="erl_eterm.html#erl_mk_estring">erl_mk_estring()
                </a></li>
<li title="erl_mk_float"><a href="erl_eterm.html#erl_mk_float">erl_mk_float()
                </a></li>
<li title="erl_mk_int"><a href="erl_eterm.html#erl_mk_int">erl_mk_int()
                </a></li>
<li title="erl_mk_list"><a href="erl_eterm.html#erl_mk_list">erl_mk_list()
                </a></li>
<li title="erl_mk_pid"><a href="erl_eterm.html#erl_mk_pid">erl_mk_pid()
                </a></li>
<li title="erl_mk_port"><a href="erl_eterm.html#erl_mk_port">erl_mk_port()
                </a></li>
<li title="erl_mk_ref"><a href="erl_eterm.html#erl_mk_ref">erl_mk_ref()
                </a></li>
<li title="erl_mk_long_ref"><a href="erl_eterm.html#erl_mk_long_ref">erl_mk_long_ref()
                </a></li>
<li title="erl_mk_string"><a href="erl_eterm.html#erl_mk_string">erl_mk_string()
                </a></li>
<li title="erl_mk_tuple"><a href="erl_eterm.html#erl_mk_tuple">erl_mk_tuple()
                </a></li>
<li title="erl_mk_uint"><a href="erl_eterm.html#erl_mk_uint">erl_mk_uint()
                </a></li>
<li title="erl_mk_var"><a href="erl_eterm.html#erl_mk_var">erl_mk_var()
                </a></li>
<li title="erl_print_term"><a href="erl_eterm.html#erl_print_term">erl_print_term()
                </a></li>
<li title="erl_set_compat_rel"><a href="erl_eterm.html#erl_set_compat_rel">erl_set_compat_rel()
                </a></li>
<li title="erl_size"><a href="erl_eterm.html#erl_size">erl_size()
                </a></li>
<li title="erl_tl"><a href="erl_eterm.html#erl_tl">erl_tl()
                </a></li>
<li title="erl_var_content"><a href="erl_eterm.html#erl_var_content">erl_var_content()
                </a></li>
</ul>
</li>
<li id="no" title="erl_format " expanded="false">erl_format<ul>
<li><a href="erl_format.html">
                  Top of manual page
                </a></li>
<li title="erl_format"><a href="erl_format.html#erl_format">erl_format()
                </a></li>
<li title="erl_match"><a href="erl_format.html#erl_match">erl_match()
                </a></li>
</ul>
</li>
<li id="no" title="erl_global " expanded="false">erl_global<ul>
<li><a href="erl_global.html">
                  Top of manual page
                </a></li>
<li title="erl_global_names"><a href="erl_global.html#erl_global_names">erl_global_names()
                </a></li>
<li title="erl_global_register"><a href="erl_global.html#erl_global_register">erl_global_register()
                </a></li>
<li title="erl_global_unregister"><a href="erl_global.html#erl_global_unregister">erl_global_unregister()
                </a></li>
<li title="erl_global_whereis"><a href="erl_global.html#erl_global_whereis">erl_global_whereis()
                </a></li>
</ul>
</li>
<li id="no" title="erl_malloc " expanded="false">erl_malloc<ul>
<li><a href="erl_malloc.html">
                  Top of manual page
                </a></li>
<li title="erl_alloc_eterm"><a href="erl_malloc.html#erl_alloc_eterm">erl_alloc_eterm()
                </a></li>
<li title="erl_eterm_release"><a href="erl_malloc.html#erl_eterm_release">erl_eterm_release()
                </a></li>
<li title="erl_eterm_statistics"><a href="erl_malloc.html#erl_eterm_statistics">erl_eterm_statistics()
                </a></li>
<li title="erl_free_array"><a href="erl_malloc.html#erl_free_array">erl_free_array()
                </a></li>
<li title="erl_free_term"><a href="erl_malloc.html#erl_free_term">erl_free_term()
                </a></li>
<li title="erl_free_compound"><a href="erl_malloc.html#erl_free_compound">erl_free_compound()
                </a></li>
<li title="erl_malloc"><a href="erl_malloc.html#erl_malloc">erl_malloc()
                </a></li>
<li title="erl_free"><a href="erl_malloc.html#erl_free">erl_free()
                </a></li>
</ul>
</li>
<li id="no" title="erl_marshal " expanded="false">erl_marshal<ul>
<li><a href="erl_marshal.html">
                  Top of manual page
                </a></li>
<li title="erl_compare_ext"><a href="erl_marshal.html#erl_compare_ext">erl_compare_ext()
                </a></li>
<li title="erl_decode"><a href="erl_marshal.html#erl_decode">erl_decode()
                </a></li>
<li title="erl_decode_buf"><a href="erl_marshal.html#erl_decode_buf">erl_decode_buf()
                </a></li>
<li title="erl_encode"><a href="erl_marshal.html#erl_encode">erl_encode()
                </a></li>
<li title="erl_encode_buf"><a href="erl_marshal.html#erl_encode_buf">erl_encode_buf()
                </a></li>
<li title="erl_ext_size"><a href="erl_marshal.html#erl_ext_size">erl_ext_size()
                </a></li>
<li title="erl_ext_type"><a href="erl_marshal.html#erl_ext_type">erl_ext_type()
                </a></li>
<li title="erl_peek_ext"><a href="erl_marshal.html#erl_peek_ext">erl_peek_ext()
                </a></li>
<li title="erl_term_len"><a href="erl_marshal.html#erl_term_len">erl_term_len()
                </a></li>
</ul>
</li>
<li title="erl_call"><a href="erl_call.html">erl_call</a></li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>ei_connect</h1></center>
  
  <h3>C LIBRARY</h3>
<div class="REFBODY">ei_connect</div>
  <h3>LIBRARY SUMMARY</h3>
<div class="REFBODY">Communicate with distributed erlang</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>This module enables C programs to communicate with erlang nodes,
      using the erlang distribution over TCP/IP.</p>
    <p>A C node appears to Erlang as a
      <strong>hidden node</strong>.
      That is, Erlang processes that know the name of the
      C node are able to communicate with it in a normal manner, but
      the node name will not appear in the listing provided by the
      Erlang function <span class="code">nodes/0</span>.</p>
    <p>The environment variable <span class="code">ERL_EPMD_PORT</span> can be used
      to indicate which logical cluster a C node belongs to.</p>
  </p></div>

  <h3><a name="id77181">Timeout functions</a></h3>
<div class="REFBODY">
    
    <p>Most functions appear in a version with the suffix
      <span class="code">_tmo</span> appended to the function name. Those function take
      an additional argument, a timeout in <strong>milliseconds</strong>. The
      semantics is this; for each communication primitive involved in
      the operation, if the primitive does not complete within the time
      specified, the function will return an error and
      <span class="code">erl_errno</span> will be set to <span class="code">ETIMEDOUT</span>. With
      communication primitive is meant an operation on the socket, like
      <span class="code">connect</span>, <span class="code">accept</span>, <span class="code">recv</span> or <span class="code">send</span>.</p>
    <p>Obviously the timeouts are for implementing fault tolerance,
      not to keep hard realtime promises. The <span class="code">_tmo</span> functions
      are for detecting non-responsive peers and to avoid blocking on
      socket operations. </p>
    <p>A timeout value of <span class="code">0</span> (zero), means that timeouts are
      disabled. Calling a <span class="code">_tmo</span>-function with the last argument as
      <span class="code">0</span> is therefore exactly the same thing as calling the
      function without the <span class="code">_tmo</span> suffix.</p>
    <p>As with all other ei functions, you are <strong>not</strong> expected
      to put the socket in non blocking mode yourself in the program. Every
      use of non blocking mode is embedded inside the timeout
      functions. The socket will always be back in blocking mode after
      the operations are completed (regardless of the result). To
      avoid problems, leave the socket options alone. Ei will handle
      any socket options that need modification.</p>
    <p>In all other senses, the <span class="code">_tmo</span> functions inherit all 
      the return values and the semantics from the functions without 
      the <span class="code">_tmo</span> suffix.</p>
  </div>
  <h3>EXPORTS</h3>
    <p><a name="ei_connect_init"><span class="bold_code">int ei_connect_init(ei_cnode* ec, const char* this_node_name, const char *cookie, short creation)</span></a><br><a name="ei_connect_xinit"><span class="bold_code">int ei_connect_xinit(ei_cnode* ec, const char *thishostname, const char *thisalivename, const char *thisnodename, Erl_IpAddr thisipaddr, const char *cookie, short creation)</span></a><br></p>
<div class="REFBODY"><p>
        <p>These function initializes the <span class="code">ec</span> structure, to
          identify the node name and cookie of the server. One of them
          has to be called before other functions that works on the
          type <span class="code">ei_cnode</span> or a file descriptor associated with a
          connection to another node are used.</p>
        <p><span class="code">ec</span> is a structure containing information about the
          C-node. It is used in other <span class="code">ei</span> functions for
          connecting and receiving data.</p>
        <p><span class="code">this_node_name</span> is the  registered name of the process
          (the name before '@').</p>
        <p><span class="code">cookie</span> is the cookie for the node.</p>
        <p><span class="code">creation</span> identifies a specific instance of a C
          node. It can help prevent the node from receiving messages
          sent to an earlier process with the same registered name.</p>
        <p><span class="code">thishostname</span> is the name of the machine we're running
          on. If long names are to be used, it should be fully
          qualified (i.e. <span class="code">durin.erix.ericsson.se</span> instead of
          <span class="code">durin</span>).</p>
        <p><span class="code">thisalivename</span> is the registered name of the process.</p>
        <p><span class="code">thisnodename</span> is the full name of the node,
          i.e. <span class="code">einode@durin</span>.</p>
        <p><span class="code">thispaddr</span> if the IP address of the host.</p>
        <p>A C node acting as a server will be assigned a creation
          number when it calls <span class="code">ei_publish()</span>.</p>
        <p>A connection is closed by simply closing the socket. Refer
          to system documentation to close the socket gracefully (when
          there are outgoing packets before close).</p>
        <p>This function return a negative value indicating that an error
          occurred.</p>
        <p>Example 1:
          </p>
        <div class="example"><pre>
int n = 0;
struct in_addr addr;
ei_cnode ec;
addr.s_addr = inet_addr("150.236.14.75");
if (ei_connect_xinit(&amp;ec,
                     "chivas",
                     "madonna",
                     "madonna@chivas.du.etx.ericsson.se",
                     &amp;addr;
                     "cookie...",
                     n++) &lt; 0) {
    fprintf(stderr,"ERROR when initializing: %d",erl_errno);
    exit(-1);
}
        </pre></div>
        <p>Example 2:
          </p>
        <div class="example"><pre>
if (ei_connect_init(&amp;ec, "madonna", "cookie...", n++) &lt; 0) {
    fprintf(stderr,"ERROR when initializing: %d",erl_errno);
    exit(-1);
}
        </pre></div>
      </p></div>
    <p><a name="ei_connect"><span class="bold_code">int ei_connect(ei_cnode* ec, char *nodename)</span></a><br><a name="ei_xconnect"><span class="bold_code">int ei_xconnect(ei_cnode* ec, Erl_IpAddr adr, char *alivename)</span></a><br></p>
<div class="REFBODY"><p>
        <p>These functions set up a connection to an Erlang node.</p>
        <p><span class="code">ei_xconnect()</span> requires the IP address of the remote
          host and the alive name of the remote node
          to be specified. <span class="code">ei_connect()</span> provides an alternative
          interface, and determines the information from the node name
          provided.</p>
        <p><span class="code">addr</span> is the 32-bit IP address of the remote host.</p>
        <p><span class="code">alive</span> is the alivename of the remote node.</p>
        <p><span class="code">node</span> is the name of the remote node.</p>
        <p>These functions return an open file descriptor on success, or
          a negative value indicating that an error occurred --- in
          which case they will set <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">EHOSTUNREACH</span></strong></dt>
          <dd>The remote host <span class="code">node</span> is unreachable</dd>
          <dt><strong><span class="code">ENOMEM</span></strong></dt>
          <dd>No more memory available.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
        <p>Additionally, <span class="code">errno</span> values from
          <span class="code">socket</span><strong>(2)</strong> and <span class="code">connect</span><strong>(2)</strong>
          system calls may be propagated into <span class="code">erl_errno</span>.</p>
        <p>Example:</p>
        <div class="example"><pre>
#define NODE   "madonna@chivas.du.etx.ericsson.se"
#define ALIVE  "madonna"
#define IP_ADDR "150.236.14.75"

/*** Variant 1 ***/
int fd = ei_connect(&amp;ec, NODE);

/*** Variant 2 ***/
struct in_addr addr;
addr.s_addr = inet_addr(IP_ADDR);
fd = ei_xconnect(&amp;ec, &amp;addr, ALIVE);
        </pre></div>
      </p></div>
    <p><a name="ei_connect_tmo"><span class="bold_code">int ei_connect_tmo(ei_cnode* ec, char *nodename, unsigned timeout_ms)</span></a><br><a name="ei_xconnect_tmo"><span class="bold_code">int ei_xconnect_tmo(ei_cnode* ec, Erl_IpAddr adr, char *alivename, unsigned timeout_ms)</span></a><br></p>
<div class="REFBODY"><p>
        <p>ei_connect and ei_xconnect with an optional timeout argument,
          see the description at the beginning of this document.</p>
      </p></div>
    <p><a name="ei_receive"><span class="bold_code">int ei_receive(int fd, unsigned char* bufp, int bufsize)</span></a><br></p>
<div class="REFBODY"><p>
        <p>This function receives a message consisting of a sequence
          of bytes in the Erlang external format.</p>
        <p><span class="code">fd</span> is an open descriptor to an Erlang connection. It
          is obtained from a previous <span class="code">ei_connect</span> or
          <span class="code">ei_accept</span>.</p>
        <p><span class="code">bufp</span> is a buffer large enough to hold the expected
          message. </p>
        <p><span class="code">bufsize</span> indicates the size of <span class="code">bufp</span>.</p>
        <p>If a <strong>tick</strong> occurs, i.e., the Erlang node on the
          other end of the connection has polled this node to see if it
          is still alive, the function will return <span class="code">ERL_TICK</span> and
          no message will be placed in the buffer. Also,
          <span class="code">erl_errno</span> will be set to <span class="code">EAGAIN</span>.</p>
        <p>On success, the message is placed in the specified buffer
          and the function returns the number of bytes actually read. On
          failure, the function returns <span class="code">ERL_ERROR</span> and will set
          <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">EAGAIN</span></strong></dt>
          <dd>Temporary error: Try again.</dd>
          <dt><strong><span class="code">EMSGSIZE</span></strong></dt>
          <dd>Buffer too small.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
      </p></div>
    <p><a name="ei_receive_tmo"><span class="bold_code">int ei_receive_tmo(int fd, unsigned char* bufp, int bufsize, unsigned timeout_ms)</span></a><br></p>
<div class="REFBODY"><p>
        <p>ei_receive with an optional timeout argument,
          see the description at the beginning of this document.</p>
      </p></div>
    <p><a name="ei_receive_msg"><span class="bold_code">int ei_receive_msg(int fd, erlang_msg* msg, ei_x_buff* x)</span></a><br><a name="ei_xreceive_msg"><span class="bold_code">int ei_xreceive_msg(int fd, erlang_msg* msg, ei_x_buff* x)</span></a><br></p>
<div class="REFBODY"><p>
        <p>These functions receives a message to the buffer in
          <span class="code">x</span>.  <span class="code">ei_xreceive_msg</span> allows the buffer in
          <span class="code">x</span> to grow, but <span class="code">ei_receive_msg</span> fails if the
          message is bigger than the preallocated buffer in <span class="code">x</span>.</p>
        <p><span class="code">fd</span> is an open descriptor to an Erlang connection.</p>
        <p><span class="code">msg</span> is a pointer to an <span class="code">erlang_msg</span> structure
          and contains information on the message received.</p>
        <p><span class="code">x</span> is buffer obtained from <span class="code">ei_x_new</span>.</p>
        <p>On success, the function returns <span class="code">ERL_MSG</span> and the
          <span class="code">msg</span> struct will be initialized. <span class="code">erlang_msg</span>
          is defined as follows:</p>
        <div class="example"><pre>
typedef struct {
    long msgtype;
    erlang_pid from;
    erlang_pid to;
    char toname[MAXATOMLEN+1];
    char cookie[MAXATOMLEN+1];
    erlang_trace token;
} erlang_msg;
        </pre></div>
        <p><span class="code">msgtype</span> identifies the type of message, and is one of
          <span class="code">ERL_SEND</span>, <span class="code">ERL_REG_SEND</span>, <span class="code">ERL_LINK</span>,
          <span class="code">ERL_UNLINK</span> and <span class="code">ERL_EXIT</span>.</p>
        <p>If <span class="code">msgtype</span> is <span class="code">ERL_SEND</span> this indicates that an
          ordinary send operation has taken place, and <span class="code">msg-&gt;to</span>
          contains the Pid of the recipient (the C-node). If
          <span class="code">type</span> is <span class="code">ERL_REG_SEND</span> then a registered send
          operation took place, and <span class="code">msg-&gt;from</span> contains the Pid
          of the sender.</p>
        <p>If <span class="code">msgtype</span> is <span class="code">ERL_LINK</span> or <span class="code">ERL_UNLINK</span>, then
          <span class="code">msg-&gt;to</span> and <span class="code">msg-&gt;from</span> contain the pids of the
          sender and recipient of the link or unlink.</p>
        <p>If <span class="code">msgtype</span> is <span class="code">ERL_EXIT</span>, then this indicates that
          a link has been broken. In this case, <span class="code">msg-&gt;to</span> and
          <span class="code">msg-&gt;from</span> contain the pids of the linked processes.</p>
        <p>The return value is the same as for <span class="code">ei_receive</span>, see
          above.</p>
      </p></div>
    <p><a name="ei_receive_msg_tmo"><span class="bold_code">int ei_receive_msg_tmo(int fd, erlang_msg* msg, ei_x_buff* x, unsigned imeout_ms)</span></a><br><a name="ei_xreceive_msg_tmo"><span class="bold_code">int ei_xreceive_msg_tmo(int fd, erlang_msg* msg, ei_x_buff* x, unsigned timeout_ms)</span></a><br></p>
<div class="REFBODY"><p>
        <p>ei_receive_msg and ei_xreceive_msg with an optional timeout argument,
          see the description at the beginning of this document.</p>
      </p></div>
    <p><a name="ei_receive_encoded"><span class="bold_code">int ei_receive_encoded(int fd, char **mbufp, int *bufsz,  erlang_msg *msg, int *msglen)</span></a><br></p>
<div class="REFBODY"><p>
        <p>This function is retained for compatibility with code
          generated by the interface compiler and with code following
          examples in the same application.</p>
        <p>In essence the function performs the same operation as
          <span class="code">ei_xreceive_msg</span>, but instead of using an ei_x_buff, the
          function expects a pointer to a character pointer
          (<span class="code">mbufp</span>), where the character pointer should point to a
          memory area allocated by <span class="code">malloc</span>. The argument
          <span class="code">bufsz</span> should be a pointer to an integer containing the
          exact size (in bytes) of the memory area. The function may
          reallocate the memory area and will in such cases put the new
          size in <span class="code">*bufsz</span> and update <span class="code">*mbufp</span>.</p>
        <p>Furthermore the function returns either ERL_TICK or the
          <span class="code">msgtype</span> field of the <span class="code">erlang_msg *msg</span>. The actual
          length of the message is put in <span class="code">*msglen</span>. On error it
          will return a value <span class="code">&lt; 0</span>.</p>
        <p>It is recommended to use ei_xreceive_msg instead when
          possible, for the sake of readability. The function will
          however be retained in the interface for compatibility and
          will <strong>not</strong> be removed not be removed in future releases
          without notice.</p>
      </p></div>
    <p><a name="ei_receive_encoded_tmo"><span class="bold_code">int ei_receive_encoded_tmo(int fd, char **mbufp, int *bufsz,  erlang_msg *msg, int *msglen, unsigned timeout_ms)</span></a><br></p>
<div class="REFBODY"><p>
        <p>ei_receive_encoded with an optional timeout argument,
          see the description at the beginning of this document.</p>
      </p></div>
    <p><a name="ei_send"><span class="bold_code">int ei_send(int fd, erlang_pid* to, char* buf, int len)</span></a><br></p>
<div class="REFBODY"><p>
        <p>This function sends an Erlang term to a process.</p>
        <p><span class="code">fd</span> is an open descriptor to an Erlang connection.</p>
        <p><span class="code">to</span> is the Pid of the intended recipient of the
          message.</p>
        <p><span class="code">buf</span> is the buffer containing the term in binary
          format.</p>
        <p><span class="code">len</span> is the length of the message in bytes.</p>
        <p>The function returns 0 if successful, otherwise -1, in the
          latter case it will set <span class="code">erl_errno</span> to <span class="code">EIO</span>.</p>
      </p></div>
    <p><a name="ei_send_tmo"><span class="bold_code">int ei_send_tmo(int fd, erlang_pid* to, char* buf, int len, unsigned timeout_ms)</span></a><br></p>
<div class="REFBODY"><p>
        <p>ei_send with an optional timeout argument,
          see the description at the beginning of this document.</p>
      </p></div>
    <p><a name="ei_send_encoded"><span class="bold_code">int ei_send_encoded(int fd, erlang_pid* to, char* buf, int len)</span></a><br></p>
<div class="REFBODY"><p>
        <p>Works exactly as ei_send, the alternative name retained for
          backward compatibility. The function will <strong>not</strong> be
          removed without notice.</p>
      </p></div>
    <p><a name="ei_send_encoded_tmo"><span class="bold_code">int ei_send_encoded_tmo(int fd, erlang_pid* to, char* buf, int len, unsigned timeout_ms)</span></a><br></p>
<div class="REFBODY"><p>
        <p>ei_send_encoded with an optional timeout argument,
          see the description at the beginning of this document.</p>
      </p></div>
    <p><a name="ei_reg_send"><span class="bold_code">int ei_reg_send(ei_cnode* ec, int fd, char* server_name, char* buf, int len)</span></a><br></p>
<div class="REFBODY"><p>
        <p>This function sends an Erlang term to a registered process.
          </p>
        <p>This function sends an Erlang term to a process.</p>
        <p><span class="code">fd</span> is an open descriptor to an Erlang connection.</p>
        <p><span class="code">server_name</span> is the registered name of the intended
          recipient.</p>
        <p><span class="code">buf</span> is the buffer containing the term in binary
          format.</p>
        <p><span class="code">len</span> is the length of the message in bytes.</p>
        <p>The function returns 0 if successful, otherwise -1, in the
          latter case it will set <span class="code">erl_errno</span> to <span class="code">EIO</span>.</p>
        <p>Example, send the atom "ok" to the process "worker":</p>
        <div class="example"><pre>
ei_x_buff x;
ei_x_new_with_version(&amp;x);
ei_x_encode_atom(&amp;x, "ok");
if (ei_reg_send(&amp;ec, fd, x.buff, x.index) &lt; 0)
    handle_error();
        </pre></div>
      </p></div>
    <p><a name="ei_reg_send_tmo"><span class="bold_code">int ei_reg_send_tmo(ei_cnode* ec, int fd, char* server_name, char* buf, int len, unsigned timeout_ms)</span></a><br></p>
<div class="REFBODY"><p>
        <p>ei_reg_send with an optional timeout argument,
          see the description at the beginning of this document.</p>
      </p></div>
    <p><a name="ei_send_reg_encoded"><span class="bold_code">int ei_send_reg_encoded(int fd, const erlang_pid *from, const char *to, const char *buf, int len)</span></a><br></p>
<div class="REFBODY"><p>
        <p>This function is retained for compatibility with code
          generated by the interface compiler and with code following
          examples in the same application.</p>
        <p>The function works as <span class="code">ei_reg_send</span> with one
          exception. Instead of taking the <span class="code">ei_cnode</span> as a first
          argument, it takes a second argument, an <span class="code">erlang_pid</span>
          which should be the process identifier of the sending process
          (in the erlang distribution protocol). </p>
        <p>A suitable <span class="code">erlang_pid</span> can be constructed from the
          <span class="code">ei_cnode</span> structure by the following example code:</p>
        <div class="example"><pre>
          ei_cnode ec;
          erlang_pid *self;
          int fd; /* the connection fd */
          ...
          self = ei_self(&amp;ec);
          self-&gt;num = fd;
        </pre></div>
      </p></div>
    <p><a name="ei_send_reg_encoded_tmo"><span class="bold_code">int ei_send_reg_encoded_tmo(int fd, const erlang_pid *from, const char *to, const char *buf, int len)</span></a><br></p>
<div class="REFBODY"><p>
        <p>ei_send_reg_encoded with an optional timeout argument,
          see the description at the beginning of this document.</p>
      </p></div>
    <p><a name="ei_rpc"><span class="bold_code">int ei_rpc(ei_cnode *ec, int fd, char *mod, char *fun, const char *argbuf, int argbuflen, ei_x_buff *x)</span></a><br><a name="ei_rpc_to"><span class="bold_code">int ei_rpc_to(ei_cnode *ec, int fd, char *mod, char *fun, const char *argbuf, int argbuflen)</span></a><br><a name="ei_rpc_from"><span class="bold_code">int ei_rpc_from(ei_cnode *ec, int fd, int timeout, erlang_msg *msg, ei_x_buff *x)</span></a><br></p>
<div class="REFBODY"><p>
        <p>These functions support calling Erlang functions on remote nodes.
          <span class="code">ei_rpc_to()</span> sends an rpc request to a remote node and
          <span class="code">ei_rpc_from()</span> receives the results of such a call.
          <span class="code">ei_rpc()</span> combines the functionality of these two functions
          by sending an rpc request and waiting for the results. See also
          <span class="code">rpc:call/4</span>. </p>
        <p><span class="code">ec</span> is the C-node structure previously initiated by a
          call to <span class="code">ei_connect_init()</span> or
          <span class="code">ei_connect_xinit()</span></p>
        <p><span class="code">fd</span> is an open descriptor to an Erlang connection.</p>
        <p><span class="code">timeout</span> is the maximum time (in ms) to wait for
          results. Specify <span class="code">ERL_NO_TIMEOUT</span> to wait forever.
          <span class="code">ei_rpc()</span> will wait infinitely for the answer,
          i.e. the call will never time out.</p>
        <p><span class="code">mod</span> is the name of the module containing the function
          to be run on the remote node.</p>
        <p><span class="code">fun</span> is the name of the function to run.</p>
        <p><span class="code">argbuf</span> is a pointer to a buffer with an encoded
          Erlang list, without a version magic number, containing the
          arguments to be passed to the function.</p>
        <p><span class="code">argbuflen</span> is the length of the buffer containing the
          encoded Erlang list.</p>
        <p><span class="code">msg</span> structure of type <span class="code">erlang_msg</span> and contains
          information on the message received. See <span class="code">ei_receive_msg()</span>
          for a description of the <span class="code">erlang_msg</span> format.</p>
        <p><span class="code">x</span> points to the dynamic buffer that receives the
          result. For for <span class="code">ei_rpc()</span> this will be the result
          without the version magic number. For <span class="code">ei_rpc_from()</span>
          the result will return a version magic number and a 2-tuple
          <span class="code">{rex,Reply}</span>.</p>
        <p><span class="code">ei_rpc()</span> returns the number of bytes in the result
          on success and -1 on failure. <span class="code">ei_rpc_from()</span> returns
          number of bytes or one of <span class="code">ERL_TICK</span>, <span class="code">ERL_TIMEOUT</span>
          and <span class="code">ERL_ERROR</span> otherwise. When failing,
          all three functions set <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
          <dt><strong><span class="code">ETIMEDOUT</span></strong></dt>
          <dd>Timeout expired.</dd>
          <dt><strong><span class="code">EAGAIN</span></strong></dt>
          <dd>Temporary error: Try again.</dd>
        </dl>
        <p>Example, check to see if an erlang process is alive:</p>
        <div class="example"><pre>
int index = 0, is_alive;
ei_x_buff args, result;

ei_x_new(&amp;result);
ei_x_new(&amp;args);
ei_x_encode_list_header(&amp;args, 1);
ei_x_encode_pid(&amp;args, &amp;check_pid);
ei_x_encode_empty_list(&amp;args);

if (ei_rpc(&amp;ec, fd, "erlang", "is_process_alive",
           args.buff, args.index, &amp;result) &lt; 0)
    handle_error();

if (ei_decode_version(result.buff, &amp;index) &lt; 0
    || ei_decode_bool(result.buff, &amp;index, &amp;is_alive) &lt; 0)
    handle_error();
        </pre></div>
      </p></div>
    <p><a name="ei_publish"><span class="bold_code">int ei_publish(ei_cnode *ec, int port)</span></a><br></p>
<div class="REFBODY"><p>
        <p>These functions are used by a server process to register
          with the local name server <strong>epmd</strong>, thereby allowing
          other processes to send messages by using the registered name.
          Before calling either of these functions, the process should
          have called <span class="code">bind()</span> and <span class="code">listen()</span> on an open socket.</p>
        <p><span class="code">ec</span> is the C-node structure.</p>
        <p><span class="code">port</span> is the local name to register, and should be the
          same as the port number that was previously bound to the socket.</p>
        <p><span class="code">addr</span> is the 32-bit IP address of the local host.</p>
        <p>To unregister with epmd, simply close the returned
          descriptor. Do not use <span class="code">ei_unpublish()</span>, which is deprecated anyway.</p>
        <p>On success, the functions return a descriptor connecting the
          calling process to epmd. On failure, they return -1 and set
          <span class="code">erl_errno</span> to <span class="code">EIO</span>.</p>
        <p>Additionally, <span class="code">errno</span> values from <span class="code">socket</span><strong>(2)</strong>
          and <span class="code">connect</span><strong>(2)</strong> system calls may be propagated
          into <span class="code">erl_errno</span>.</p>
      </p></div>
    <p><a name="ei_publish_tmo"><span class="bold_code">int ei_publish_tmo(ei_cnode *ec, int port, unsigned timeout_ms)</span></a><br></p>
<div class="REFBODY"><p>
        <p>ei_publish with an optional timeout argument,
          see the description at the beginning of this document.</p>
      </p></div>
    <p><a name="ei_accept"><span class="bold_code">int ei_accept(ei_cnode *ec, int listensock, ErlConnect *conp)</span></a><br></p>
<div class="REFBODY"><p>
        <p>This function is used by a server process to accept a
          connection from a client process.</p>
        <p><span class="code">ec</span> is the C-node structure.</p>
        <p><span class="code">listensock</span> is an open socket descriptor on which
          <span class="code">listen()</span> has previously been called.</p>
        <p><span class="code">conp</span> is a pointer to an <span class="code">ErlConnect</span> struct,
          described as follows:</p>
        <div class="example"><pre>
typedef struct {
  char ipadr[4];             
  char nodename[MAXNODELEN];
} ErlConnect;
        </pre></div>
        <p>On success, <span class="code">conp</span> is filled in with the address and
          node name of the connecting client and a file descriptor is
          returned. On failure, <span class="code">ERL_ERROR</span> is returned and
          <span class="code">erl_errno</span> is set to <span class="code">EIO</span>.</p>
      </p></div>
    <p><a name="ei_accept_tmo"><span class="bold_code">int ei_accept_tmo(ei_cnode *ec, int listensock, ErlConnect *conp, unsigned timeout_ms)</span></a><br></p>
<div class="REFBODY"><p>
        <p>ei_accept with an optional timeout argument,
          see the description at the beginning of this document.</p>
      </p></div>
    <p><a name="ei_unpublish"><span class="bold_code">int ei_unpublish(ei_cnode *ec)</span></a><br></p>
<div class="REFBODY"><p>
        <p>This function can be called by a process to unregister a
          specified node from epmd on the localhost. This is however usually not 
	  allowed, unless epmd was started with the -relaxed_command_check 
	  flag, which it normally isn't.</p>

	  <p>To unregister a node you have published, you should
	  close the descriptor that was returned by  
	  <span class="code">ei_publish()</span>.</p> 

        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>This function is deprecated and will be removed in a future 
	  release.</p>
        </p></div>
</div>
        <p><span class="code">ec</span> is the node structure of the node to unregister.</p>
        <p>If the node was successfully unregistered from epmd, the
          function returns 0. Otherwise, it returns -1 and sets
          <span class="code">erl_errno</span> is to <span class="code">EIO</span>.</p>
      </p></div>
    <p><a name="ei_unpublish_tmo"><span class="bold_code">int ei_unpublish_tmo(ei_cnode *ec, unsigned timeout_ms)</span></a><br></p>
<div class="REFBODY"><p>
        <p>ei_unpublish with an optional timeout argument,
          see the description at the beginning of this document.</p>
      </p></div>
    <p><a name="ei_thisnodename"><span class="bold_code">const char *ei_thisnodename(ei_cnode *ec)</span></a><br><a name="ei_thishostname"><span class="bold_code">const char *ei_thishostname(ei_cnode *ec)</span></a><br><a name="ei_thisalivename"><span class="bold_code">const char *ei_thisalivename(ei_cnode *ec)</span></a><br></p>
<div class="REFBODY"><p>
        <p>These functions can be used to retrieve information about
          the C Node. These values are initially set with
          <span class="code">ei_connect_init()</span> or <span class="code">ei_connect_xinit()</span>.</p>
        <p>They simply fetches the appropriate field from the <span class="code">ec</span>
          structure. Read the field directly will probably be safe for
          a long time, so these functions are not really needed.</p>
      </p></div>
    <p><a name="ei_self"><span class="bold_code">erlang_pid *ei_self(ei_cnode *ec)</span></a><br></p>
<div class="REFBODY"><p>
        <p>This function retrieves the Pid of the C-node. Every C-node
          has a (pseudo) pid used in <span class="code">ei_send_reg</span>, <span class="code">ei_rpc</span>
          and others. This is contained in a field in the <span class="code">ec</span>
          structure. It will be safe for a long time to fetch this
          field directly from the <span class="code">ei_cnode</span> structure.</p>
      </p></div>
    <p><a name="*ei_gethostbyname"><span class="bold_code">struct hostent *ei_gethostbyname(const char *name)</span></a><br><a name="*ei_gethostbyaddr"><span class="bold_code">struct hostent *ei_gethostbyaddr(const char *addr, int len, int type)</span></a><br><a name="*ei_gethostbyname_r"><span class="bold_code">struct hostent *ei_gethostbyname_r(const char *name,  struct hostent *hostp,  char *buffer,  int buflen,  int *h_errnop)</span></a><br><a name="*ei_gethostbyaddr_r"><span class="bold_code">struct hostent *ei_gethostbyaddr_r(const char *addr, int length,  int type,  struct hostent *hostp, char *buffer,   int buflen,  int *h_errnop)</span></a><br></p>
<div class="REFBODY"><p>
        <p>These are convenience functions for some common name lookup functions.</p>
      </p></div>
    <p><a name="ei_get_tracelevel"><span class="bold_code">int ei_get_tracelevel(void)</span></a><br><a name="ei_set_tracelevel"><span class="bold_code">void ei_set_tracelevel(int level)</span></a><br></p>
<div class="REFBODY"><p>
        <p>These functions are used to set tracing on the distribution. The levels are different verbosity levels. A higher level means more information.
	See also Debug Information and <span class="code">EI_TRACELEVEL</span> below. </p>
	<p> <span class="code">ei_set_tracelevel</span> and <span class="code">ei_get_tracelevel</span> are not thread safe.  </p>
      </p></div>
  

  <h3><a name="id79114">Debug Information</a></h3>
<div class="REFBODY">
    
    <p>If a connection attempt fails, the following can be checked:</p>
    <ul>
      <li><span class="code">erl_errno</span></li>
      <li>that the right cookie was used</li>
      <li>that <strong>epmd</strong> is running</li>
      <li>the remote Erlang node on the other side is running the
       same version of Erlang as the <span class="code">ei</span>
       library.</li>
      <li>the environment variable <span class="code">ERL_EPMD_PORT</span>
       is set correctly.</li>
    </ul>
    <p>The connection attempt can be traced by setting a tracelevel by either using
    <span class="code">ei_set_tracelevel</span> or by setting the environment variable <span class="code">EI_TRACELEVEL</span>.
    The different tracelevels has the following messages:</p>
    <ul>
    	<li>1: Verbose error messages</li>
    	<li>2: Above messages and verbose warning messages </li>
    	<li>3: Above messages and progress reports for connection handling</li>
    	<li>4: Above messages and progress reports for communication</li>
    	<li>5: Above messages and progress reports for data conversion</li>
    </ul>
  </div>

</div>
<div class="footer">
<hr>
<p>Copyright  1998-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
