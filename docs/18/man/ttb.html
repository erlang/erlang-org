<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- ttb</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/observer/users_guide.html">User's Guide</a><br><a href="../apps/observer/index.html">Reference Manual</a><br><a href="../apps/observer/release_notes.html">Release Notes</a><br><a href="../apps/observer/observer.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Observer</strong><br><strong>Reference Manual</strong><br><small>Version 2.1.2</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li title="Observer (App)"><a href="Observer_app.html">Observer (App)
                </a></li>
<li id="no" title="observer " expanded="false">observer<ul>
<li><a href="observer.html">
                  Top of manual page
                </a></li>
<li title="start-0"><a href="observer.html#start-0">start/0</a></li>
</ul>
</li>
<li id="loadscrollpos" title="ttb " expanded="true">ttb<ul>
<li><a href="ttb.html">
                  Top of manual page
                </a></li>
<li title="start_trace-4"><a href="ttb.html#start_trace-4">start_trace/4</a></li>
<li title="tracer-0"><a href="ttb.html#tracer-0">tracer/0</a></li>
<li title="tracer-1"><a href="ttb.html#tracer-1">tracer/1</a></li>
<li title="tracer-1"><a href="ttb.html#tracer-1">tracer/1</a></li>
<li title="tracer-2"><a href="ttb.html#tracer-2">tracer/2</a></li>
<li title="p-2"><a href="ttb.html#p-2">p/2</a></li>
<li title="-0"><a href="ttb.html#-0">/0</a></li>
<li title="list_history-0"><a href="ttb.html#list_history-0">list_history/0</a></li>
<li title="run_history-1"><a href="ttb.html#run_history-1">run_history/1</a></li>
<li title="write_config-2"><a href="ttb.html#write_config-2">write_config/2</a></li>
<li title="write_config-3"><a href="ttb.html#write_config-3">write_config/3</a></li>
<li title="run_config-1"><a href="ttb.html#run_config-1">run_config/1</a></li>
<li title="run_config-2"><a href="ttb.html#run_config-2">run_config/2</a></li>
<li title="list_config-1"><a href="ttb.html#list_config-1">list_config/1</a></li>
<li title="write_trace_info-2"><a href="ttb.html#write_trace_info-2">write_trace_info/2</a></li>
<li title="seq_trigger_ms-0"><a href="ttb.html#seq_trigger_ms-0">seq_trigger_ms/0</a></li>
<li title="seq_trigger_ms-1"><a href="ttb.html#seq_trigger_ms-1">seq_trigger_ms/1</a></li>
<li title="stop-0"><a href="ttb.html#stop-0">stop/0</a></li>
<li title="stop-1"><a href="ttb.html#stop-1">stop/1</a></li>
<li title="get_et_handler-0"><a href="ttb.html#get_et_handler-0">get_et_handler/0</a></li>
<li title="format-1"><a href="ttb.html#format-1">format/1</a></li>
<li title="format-2"><a href="ttb.html#format-2">format/2</a></li>
</ul>
</li>
<li id="no" title="etop " expanded="false">etop<ul>
<li><a href="etop.html">
                  Top of manual page
                </a></li>
<li title="start-0"><a href="etop.html#start-0">start/0</a></li>
<li title="start-1"><a href="etop.html#start-1">start/1</a></li>
<li title="help-0"><a href="etop.html#help-0">help/0</a></li>
<li title="config-2"><a href="etop.html#config-2">config/2</a></li>
<li title="dump-1"><a href="etop.html#dump-1">dump/1</a></li>
<li title="stop-0"><a href="etop.html#stop-0">stop/0</a></li>
</ul>
</li>
<li id="no" title="crashdump_viewer " expanded="false">crashdump_viewer<ul>
<li><a href="crashdump_viewer.html">
                  Top of manual page
                </a></li>
<li title="start-0"><a href="crashdump_viewer.html#start-0">start/0</a></li>
<li title="start-1"><a href="crashdump_viewer.html#start-1">start/1</a></li>
<li title="stop-0"><a href="crashdump_viewer.html#stop-0">stop/0</a></li>
</ul>
</li>
<li title="cdv"><a href="cdv.html">cdv</a></li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>ttb</h1></center>
  
  <h3>MODULE</h3>
<div class="REFBODY">ttb</div>
  <h3>MODULE SUMMARY</h3>
<div class="REFBODY">A base for building trace tools for distributed systems.</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>The Trace Tool Builder, <span class="code">ttb</span>, is a base for building trace
      tools for distributed systems.
      </p>
    <p>When using <span class="code">ttb</span>, do not use module <span class="code">dbg</span> in application
      Runtime_Tools in parallel.</p>
  </p></div>
  <h3>EXPORTS</h3>
    <p><a name="start_trace-4"><span class="bold_code">start_trace(Nodes, Patterns, FlagSpec, Opts) -&gt; Result</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Result = see p/2</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Nodes = see tracer/2</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Patterns = [tuple()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">FlagSpec = {Procs, Flags}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Proc = see p/2</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Flags = see p/2</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Opts = see tracer/2</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function is a shortcut allowing to start a trace with one command. Each
          tuple in <span class="code">Patterns</span> is converted to a list, which in turn is passed to
          <span class="code">ttb:tpl/2,3,4</span>.</p>
         <p>The call:</p>
	 <div class="example"><pre>
&gt; <span class="bold_code">ttb:start_trace([Node, OtherNode],
                  [{mod, foo, []}, {mod, bar, 2}],
                  {all, call},
                  [{file, File}, {handler,{fun myhandler/4, S}}]).</span></pre></div>
         <p> is equivalent to:</p>
	 <div class="example"><pre>
&gt; <span class="bold_code">ttb:start_trace([Node, OtherNode],
                  [{file, File}, {handler,{fun myhandler/4, S}}]),
ttb:tpl(mod, foo, []),
ttb:tpl(mod, bar, 2, []),
ttb:p(all, call).</span></pre></div>
      </p></div>

    <p><a name="tracer-0"><span class="bold_code">tracer() -&gt; Result</span></a><br></p>
<div class="REFBODY"><p>
        <p>Equivalent to <span class="code">tracer(node())</span>.</p>
      </p></div>

    <p><a name="tracer-1"><span class="bold_code">tracer(Shortcut) -&gt; Result</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Shortcut = shell | dbg</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Handy shortcuts for common tracing settings.</p>
        <p><span class="code">shell</span> is equivalent to <span class="code">tracer(node(),[{file, {local, "ttb"}}, shell])</span>.</p>
        <p><span class="code">dbg</span> is equivalent to <span class="code">tracer(node(),[{shell, only}])</span>.</p>
      </p></div>

    <p><a name="tracer-1"><span class="bold_code">tracer(Nodes) -&gt; Result</span></a><br></p>
<div class="REFBODY"><p>
        <p>Equivalent to <span class="code">tracer(Nodes,[])</span>.</p>
      </p></div>

    <p><a name="tracer-2"><span class="bold_code">tracer(Nodes,Opts) -&gt; Result</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Result = {ok, ActivatedNodes} | {error,Reason}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Nodes   = atom() | [atom()] | all | existing | new</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Opts = Opt | [Opt]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Opt = {file,Client} | {handler, FormatHandler} | {process_info,PI} |
          shell | {shell, ShellSpec} | {timer, TimerSpec} |
	  {overload_check, {MSec, Module, Function}} |
	{flush, MSec} | resume | {resume, FetchTimeout}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">TimerSpec = MSec | {MSec, StopOpts}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">MSec = FetchTimeout = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Module = Function = atom() </span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">StopOpts = see stop/2</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Client = File | {local, File}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">File = Filename | Wrap</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Filename = string()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Wrap = {wrap,Filename} | {wrap,Filename,Size,Count}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">FormatHandler = See format/2</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">PI = true | false </span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ShellSpec = true | false | only</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Starts a file trace port on all specified nodes
          and points the system tracer for sequential tracing to
          the same port.
          </p>
	<p><strong>Options:</strong></p>
	<dl>
       <dt><strong><span class="code">Filename</span></strong></dt>
       <dd><p>The specified <span class="code">Filename</span> is prefixed with the node name. 
       Default <span class="code">Filename</span> is <span class="code">ttb</span>.</p></dd>
       <dt><strong><span class="code">File={wrap,Filename,Size,Count}</span></strong></dt>
       <dd><p>Can be used if the size of the trace logs must be limited. 
       Default values are
       <span class="code">Size=128*1024</span> and <span class="code">Count=8</span>.</p></dd>
       <dt><strong><span class="code">Client</span></strong></dt>
       <dd><p>When tracing diskless nodes, <span class="code">ttb</span> must be started
          from an external "trace control node" with disk access, and
          <span class="code">Client</span> must be <span class="code">{local, File}</span>. All
          trace information is then sent to the trace control node where
          it is written to file.</p></dd>
       <dt><strong><span class="code">process_info</span></strong></dt>
       <dd><p>Indicates if process
          information is to be collected. If <span class="code">PI = true</span> (which is
          default), each process identifier <span class="code">Pid</span> is replaced by a
          tuple <span class="code">{Pid,ProcessInfo,Node}</span>, where <span class="code">ProcessInfo</span>
          is the registered process name, its globally registered name,
          or its initial function. To turn off this functionality, 
          set <span class="code">PI = false</span>.</p></dd>
       <dt><strong><span class="code">{shell, ShellSpec}</span></strong></dt>
       <dd><p>Indicates that trace messages are to be printed on the 
          console as they are received by the tracing process. This implies 
	  trace client <span class="code">{local, File}</span>. If <span class="code">ShellSpec</span>
          is <span class="code">only</span> (instead of <span class="code">true</span>), no trace logs are stored.</p></dd>
       <dt><strong><span class="code">shell</span></strong></dt>
       <dd><p>Shortcut for <span class="code">{shell, true}</span>.</p></dd>
       <dt><strong><span class="code">timer</span></strong></dt>
       <dd><p>Indicates that the trace is to be
          automatically stopped after <span class="code">MSec</span> milliseconds. <span class="code">StopOpts</span>
          are passed to command <span class="code">ttb:stop/2</span> if specified (default is <span class="code">[]</span>).
          Notice that the timing is approximate, as delays related to
          network communication are always present. The timer starts after
          <span class="code">ttb:p/2</span> is issued, so you can set up your trace patterns before.</p></dd>
       <dt><strong><span class="code">overload_check</span></strong></dt>
       <dd>
<p>Allows to enable overload
          checking on the nodes under trace. <span class="code">Module:Function(check)</span>
          is performed each <span class="code">MSec</span> millisecond. If the check returns
          <span class="code">true</span>, the tracing is disabled on a specified node.</p>
          <p><span class="code">Module:Function</span> must be able to handle at least three
          atoms: <span class="code">init</span>, <span class="code">check</span>, and <span class="code">stop</span>. <span class="code">init</span> and
          <span class="code">stop</span> allows you to initialize and clean
          up the check environment.</p>
          <p>When a node gets overloaded, it is not possible to issue <span class="code">ttb:p/2</span>
          or any command from the <span class="code">ttb:tp/2,3,4</span> family, as it would lead to
          inconsistent tracing state (different trace specifications on
          different nodes).</p>
</dd>
       <dt><strong><span class="code">flush</span></strong></dt>
       <dd><p>Periodically flushes all file trace
          port clients (see
	  <span class="bold_code"><a href="dbg.html#flush_trace_port-1">
	  <span class="code">dbg:flush_trace_port/1</span></a></span>). When enabled,
          the buffers are freed each <span class="code">MSec</span> millisecond. This option is
          not allowed with <span class="code">{file, {local, File}}</span> tracing.</p></dd>
       <dt><strong><span class="code">{resume, FetchTimeout}</span></strong></dt>
       <dd>
<p>Enables the autoresume feature.
          When enabled, remote nodes try to reconnect to the controlling node
          if they are restarted. The feature requires application Runtime_Tools
          to be started (so it has to be present in the <span class="code">.boot</span>
          scripts if the traced nodes run with embedded Erlang). If this is
          not possible, resume can be performed manually by starting
          <span class="code">Runtime_Tools</span> remotely using 
	  <span class="bold_code"><a href="rpc.html#call-4"><span class="code">rpc:call/4</span></a></span>.</p>
          <p><span class="code">ttb</span> tries to fetch all logs from a reconnecting node before
          reinitializing the trace. This must finish within <span class="code">FetchTimeout</span> 
	  milliseconds or is aborted.</p>
          <p>By default, autostart information is stored in a file named
          <span class="code">ttb_autostart.bin</span> on each node. If this is not desired
          (for example, on diskless nodes), a custom module handling autostart
          information storage and retrieval can be provided by specifying
          environment variable <span class="code">ttb_autostart_module</span> for the application
	  Runtime_Tools. The module must respond to the following API:</p>
	  <dl>
            <dt><strong><span class="code">write_config(Data) -&gt; ok</span></strong></dt>
            <dd><p>Stores the provided data for further retrieval. It is
              important to realize that the data storage used must not
              be affected by the node crash.</p></dd>
            <dt><strong><span class="code">read_config() -&gt; {ok, Data} | {error, Error}</span></strong></dt>
            <dd><p>Retrieves configuration stored with <span class="code">write_config(Data)</span>.</p></dd>
            <dt><strong><span class="code">delete_config() -&gt; ok</span></strong></dt>
            <dd>
<p>Deletes configuration stored with <span class="code">write_config(Data)</span>.
              Notice that after this call any subsequent calls to <span class="code">read_config</span>
              must return <span class="code">{error, Error}</span>.</p>
            </dd>
	  </dl>
	  <p><span class="code">resume</span> implies the default <span class="code">FetchTimeout</span>, which is
          10 seconds</p>
       </dd>
     </dl>
          
      </p></div>

    <p><a name="p-2"><span class="bold_code">p(Procs,Flags) -&gt; Return</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Return = {ok,[{Procs,MatchDesc}]}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Procs   = Process | [Process] | all | new | existing</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Process = pid() | atom() | {global,atom()}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Flags   = Flag | [Flag]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Sets the specified trace flags on the specified
          processes. Flag <span class="code">timestamp</span> is always turned on.
          </p>
        <p>See the Reference Manual for module 
	<span class="bold_code"><a href="dbg.html"><span class="code">dbg</span></a></span>
          and the possible trace flags. Parameter
          <span class="code">MatchDesc</span> is the same as returned from 
	<span class="code">dbg:p/2</span>.</p>
        <p>Processes can be specified as registered names, globally
          registered names, or process identifiers. If a registered name
          is specified, the flags are set on processes with this name on all
          active nodes.</p>
        <p>Issuing this command starts the timer for this trace if option
          <span class="code">timer</span> is specified with <span class="code">tracer/2</span>.
        </p>
      </p></div>

    <p><a name="-0"><span class="bold_code">tp, tpl, ctp, ctpl, ctpg</span></a><br></p>
<div class="REFBODY"><p>
        <p>These functions are to be used with
          trace flag <span class="code">call</span> for setting and clearing trace
          patterns. When trace flag <span class="code">call</span> is set on a process,
          function calls are traced on that process if a trace
          pattern is set for the called function. Trace patterns
          specify how to trace a function by using match
          specifications. Match specifications are described in the
          <span class="bold_code"><a href="../apps/erts/users_guide.html"><span class="code">ERTS User's Guide</span></a></span>.
          </p>
        <p>These functions are equivalent to the corresponding
          functions in module
	  <span class="bold_code"><a href="dbg.html">dbg</a></span>,
	  but all calls are stored in the
          history. The history buffer makes it easy to create configuration
          files; the same trace environment can be set up many
          times, for example, to compare two test runs. It also
          reduces the amount of typing when using <span class="code">ttb</span> from the
          Erlang shell.
          </p>
        <dl>
          <dt><strong><span class="code">tp</span></strong></dt>
          <dd><p>Sets trace patterns on global function calls.</p></dd>
          <dt><strong><span class="code">tpl</span></strong></dt>
          <dd><p>Sets trace patterns on local and global function calls.</p></dd>
          <dt><strong><span class="code">ctp</span></strong></dt>
          <dd><p>Clears trace patterns on local and global function
           calls.</p></dd>
          <dt><strong><span class="code">ctpl</span></strong></dt>
          <dd><p>Clears trace patterns on local function calls.</p></dd>
          <dt><strong><span class="code">ctpg</span></strong></dt>
          <dd><p>Clears trace patterns on global function calls.</p></dd>
        </dl>
        <p>With <span class="code">tp</span> and <span class="code">tpl</span>, one of the match specification shortcuts
          can be used (for example, <span class="code">ttb:tp(foo_module, caller)</span>).</p>
	  <p>The shortcuts are as follows:</p>
          <ul>
            <li>
<span class="code">return</span> - for <span class="code">[{'_',[],[{return_trace}]}]</span>
              (report the return value)</li>
            <li>
<span class="code">caller</span> - for <span class="code">[{'_',[],[{message,{caller}}]}]</span>
              (report the calling function)</li>
            <li>
<span class="code">{codestr, Str}</span> - for <span class="code">dbg:fun2ms/1</span> arguments
              passed as strings (example: <span class="code">"fun(_) -&gt; return_trace() end"</span>)
            </li>
          </ul>
      </p></div>

    <p><a name="list_history-0"><span class="bold_code">list_history() -&gt; History</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">History = [{N,Func,Args}]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>All calls to <span class="code">ttb</span> is stored in the history. This
          function returns the current content of the history. Any entry
          can be reexecuted with <span class="code">run_history/1</span> or stored in a
          configuration file with <span class="code">write_config/2,3</span>.</p>
      </p></div>

    <p><a name="run_history-1"><span class="bold_code">run_history(N) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">N = integer() | [integer()]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Executes the specified entry or entries from the history
          list. To list history, use <span class="code">list_history/0</span>.</p>
      </p></div>

    <p><a name="write_config-2"><span class="bold_code">write_config(ConfigFile,Config)</span></a><br></p>
<div class="REFBODY"><p>
        <p>Equivalent to <span class="code">write_config(ConfigFile,Config,[])</span>.</p>
      </p></div>

    <p><a name="write_config-3"><span class="bold_code">write_config(ConfigFile,Config,Opts) -&gt; ok | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConfigFile = string()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Config = all | [integer()] | [{Mod,Func,Args}]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Mod = atom()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Func = atom()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Args = [term()]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Opts = Opt | [Opt]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Opt = append</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Creates or extends a configuration file, which can be
          used for restoring a specific configuration later.
          </p>
        <p>The contents of the configuration file can either be fetched from
          the history or specified directly as a list of
          <span class="code">{Mod,Func,Args}</span>.
          </p>
        <p>If the complete history is to be stored in the configuration file,
          <span class="code">Config</span> must be <span class="code">all</span>. If only a selected number
          of entries from the history are to be stored, <span class="code">Config</span>
          must be a list of integers pointing out the entries to be
          stored.
          </p>
        <p>If <span class="code">Opts</span> is not specified or if it is <span class="code">[]</span>,
          <span class="code">ConfigFile</span> is deleted and a new file is created. If
          <span class="code">Opts = [append]</span>, <span class="code">ConfigFile</span> is not deleted.
          The new information is appended at the end of the file.</p>
      </p></div>

    <p><a name="run_config-1"><span class="bold_code">run_config(ConfigFile) -&gt; ok | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConfigFile = string()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Executes all entries in the specified configuration file. 
	Notice that the history of the last trace is always available 
	in file <span class="code">ttb_last_config</span>.</p>
      </p></div>

    <p><a name="run_config-2"><span class="bold_code">run_config(ConfigFile,NumList) -&gt; ok | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConfigFile = string()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">NumList = [integer()]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Executes selected entries from the specified configuration
          file. <span class="code">NumList</span> is a list of integers pointing out the
          entries to be executed.
          </p>
        <p>To list the contents of a configuration file, use
          <span class="code">list_config/1</span>.</p>
        <p>Notice that the history of the last trace is always available 
	   in file <span class="code">ttb_last_config</span>.</p>
      </p></div>

    <p><a name="list_config-1"><span class="bold_code">list_config(ConfigFile) -&gt; Config | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ConfigFile = string()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Config = [{N,Func,Args}]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Lists all entries in the specified configuration file.</p>
      </p></div>

    <p><a name="write_trace_info-2"><span class="bold_code">write_trace_info(Key,Info) -&gt; ok</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Key = term()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Info = Data | fun() -&gt; Data</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Data = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>File <span class="code">.ti</span> contains <span class="code">{Key,ValueList}</span>
          tuples. This function adds <span class="code">Data</span> to the <span class="code">ValueList</span>
          associated with <span class="code">Key</span>. All information written with this
          function is included in the call to the format handler.</p>
      </p></div>

    <p><a name="seq_trigger_ms-0"><span class="bold_code">seq_trigger_ms() -&gt; MatchSpec</span></a><br></p>
<div class="REFBODY"><p>
        <p>Equivalent to <span class="code">seq_trigger_ms(all)</span>.</p>
      </p></div>

    <p><a name="seq_trigger_ms-1"><span class="bold_code">seq_trigger_ms(Flags) -&gt; MatchSpec</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">MatchSpec = match_spec()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Flags = all | SeqTraceFlag | [SeqTraceFlag]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">SeqTraceFlag = atom()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>A match specification can turn on or off sequential
          tracing. This function returns a match specification, which
          turns on sequential tracing with the specified <span class="code">Flags</span>.
          </p>
        <p>This match specification can be specified as the last argument
          to <span class="code">tp</span> or <span class="code">tpl</span>. The activated <span class="code">Item</span>
          then becomes a <strong>trigger</strong> for sequential tracing. This
          means that if the item is called on a process with trace flag
          <span class="code">call</span> set, the process is "contaminated"
          with token <span class="code">seq_trace</span>.
          </p>
        <p>If <span class="code">Flags = all</span>, all possible flags are set.
          </p>
        <p>The possible values for <span class="code">SeqTraceFlag</span> are available in
	<span class="bold_code"><a href="seq_trace.html"><span class="code">seq_trace</span></a></span>.</p>
	 <p>For a description of the <span class="code">match_spec()</span> syntax, 
	   see section
	   <span class="bold_code"><a href="../apps/erts/match_spec.html"><span class="code">Match Specifications in Erlang</span></a></span>
	   in <span class="code">ERTS</span>, which explains the general match specification "language".
          </p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>The <strong>system tracer</strong> for sequential tracing is
            automatically initiated by <span class="code">ttb</span> when a trace port is
            started with <span class="code">ttb:tracer/0,1,2</span>.</p>
        </p></div>
</div>
        <p>An example of how to use function <span class="code">seq_trigger_ms/0,1</span> follows:</p>
        <div class="example"><pre>
(tiger@durin)5&gt; <span class="bold_code">ttb:tracer().</span>
{ok,[tiger@durin]}
(tiger@durin)6&gt; <span class="bold_code">ttb:p(all,call).</span>
{ok,{[all],[call]}}
(tiger@durin)7&gt; <span class="bold_code">ttb:tp(mod,func,ttb:seq_trigger_ms()).</span>
{ok,[{matched,1},{saved,1}]}
(tiger@durin)8&gt;</pre></div>
        <p>Whenever <span class="code">mod:func(...)</span> is called after this,
          token <span class="code">seq_trace</span> is set on the executing process.</p>
      </p></div>

    <p><a name="stop-0"><span class="bold_code">stop()</span></a><br></p>
<div class="REFBODY"><p>
        <p>Equivalent to <span class="code">stop([])</span>.</p>
      </p></div>

    <p><a name="stop-1"><span class="bold_code">stop(Opts) -&gt; stopped | {stopped, Dir}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Opts = Opt | [Opt]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Opt = nofetch | {fetch_dir, Dir} | format | {format, FormatOpts} | return_fetch_dir</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Dir = string()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">FormatOpts = see format/2</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Stops tracing on all nodes. Logs and
          trace information files are sent to the trace control
          node and stored in a directory named
          <span class="code">ttb_upload_FileName-Timestamp</span>, where <span class="code">Filename</span> is
          the one provided with <span class="code">{file, File}</span> during trace setup
          and <span class="code">Timestamp</span> is of the
          form <span class="code">yyyymmdd-hhmmss</span>. Even logs from nodes on the same
          machine as the trace control node are moved to this directory.
          The history list is saved to a file named <span class="code">ttb_last_config</span>
          for further reference (as it is no longer accessible
          through history and configuration management functions, like
          <span class="code">ttb:list_history/0</span>).
        </p>
	<p><strong>Options:</strong></p>
	<dl>
       <dt><strong><span class="code">nofetch</span></strong></dt>
       <dd><p>Indicates that trace logs are not to be
          collected after tracing is stopped.</p></dd>
       <dt><strong><span class="code">{fetch, Dir}</span></strong></dt>
       <dd><p>Allows specification of the directory
          to fetch the data to. If the directory already exists, an
          error is thrown.</p></dd>
       <dt><strong><span class="code">format</span></strong></dt>
       <dd><p>Indicates the trace logs to be formatted after tracing 
       is stopped. All logs in the fetch directory are merged.</p></dd>
       <dt><strong><span class="code">return_fetch_dir</span></strong></dt>
       <dd><p>Indicates the return value
          to be <span class="code">{stopped, Dir}</span> and not just <span class="code">stopped</span>.
          This implies <span class="code">fetch</span>.</p></dd>
     </dl>

      </p></div>

    <p><a name="get_et_handler-0"><span class="bold_code">get_et_handler()</span></a><br></p>
<div class="REFBODY"><p>
        <p>Returns the <span class="code">et</span> handler, which can be used with <span class="code">format/2</span>
          or <span class="code">tracer/2</span>.</p>
	  <p>Example: <span class="code">ttb:format(Dir, [{handler, ttb:get_et_handler()}])</span>.</p>
      </p></div>

    <p><a name="format-1"><span class="bold_code">format(File)</span></a><br></p>
<div class="REFBODY"><p>
        <p>Equivalent to <span class="code">format(File,[])</span>.</p>
      </p></div>

    <p><a name="format-2"><span class="bold_code">format(File,Options) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">File = string() | [string()]</span><br>
</div>
        <div class="REFBODY">This can be the name of a binary log, a list of such logs,
	or the name of a directory containing one or more binary logs.</div>
        <div class="REFTYPES">
<span class="bold_code">Options = Opt | [Opt]</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Opt = {out,Out} | {handler,FormatHandler} | disable_sort</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Out = standard_io | string()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">FormatHandler = {Function, InitialState}</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Function = fun(Fd,Trace,TraceInfo,State) -&gt; State</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Fd = standard_io | FileDescriptor</span><br>
</div>
        <div class="REFBODY">File descriptor of the destination file <span class="code">Out</span>.</div>
        <div class="REFTYPES">
<span class="bold_code">Trace = tuple()</span><br>
</div>
        <div class="REFBODY">The trace message. For details, see the Reference Manual for 
	module <span class="code">erlang</span>.</div>
        <div class="REFTYPES">
<span class="bold_code">TraceInfo = [{Key,ValueList}]</span><br>
</div>
        <div class="REFBODY">Includes the keys <span class="code">flags</span>, <span class="code">client</span>, and <span class="code">node</span>.
	If <span class="code">handler</span> is specified as option to the tracer function, this 
	is also included. Also, all information written with function
	<span class="code">write_trace_info/2</span> is included.</div>
      </div>
<div class="REFBODY"><p>
        <p>Reads the specified binary trace log(s). The logs are processed
          in the order of their time stamps as long as option <span class="code">disable_sort</span>
          is not specified.
        </p>
        <p>If <span class="code">FormatHandler = {Function,InitialState}</span>,
          <span class="code">Function</span> is called for each trace message.</p>
	  <p>If <span class="code">FormatHandler = get_et_handler()</span>, <span class="code">et_viewer</span> in
          application ET is used for presenting
          the trace log graphically. <span class="code">ttb</span> provides a few different
          filters that can be selected from menu <strong>Filters and scaling</strong> 
	  in the <span class="code">et_viewer</span>.</p>
	  <p>If <span class="code">FormatHandler</span> is not specified, a
          default handler is used presenting each trace message as a
          text line.
          </p>
        <p>The state returned from each call of <span class="code">Function</span> is passed to 
	  the next call, even if the next call is to format a message from another 
	  log file.
          </p>
        <p>If <span class="code">Out</span> is specified, <span class="code">FormatHandler</span> gets the
          file descriptor to <span class="code">Out</span> as the first parameter.
          </p>
        <p><span class="code">Out</span> is ignored if the <span class="code">et</span> format handler is used.
          </p>
        <p>Wrap logs can be formatted one by one or all at once. To
          format one of the wrap logs in a set, specify the exact file name.
          To format the whole set of wrap logs, specify the name
          with <span class="code">*</span> instead of the wrap count. For examples, see the
          <span class="bold_code"><a href="../apps/observer/ttb_ug.html#format"><span class="code">User's Guide</span></a></span>.
	  </p>
      </p></div>
  
</div>
<div class="footer">
<hr>
<p>Copyright Â© 2002-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
