<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Debugger</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="index.html">Reference Manual</a><br><a href="release_notes.html">Release Notes</a><br><a href="debugger.pdf">PDF</a><br><a href="../../index.html">Top</a></small><p><strong>Debugger</strong><br><strong>User's Guide</strong><br><small>Version 4.1.2</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="introduction.html">
              Top of chapter
            </a></li>
<li title="Scope"><a href="introduction.html#id56579">Scope</a></li>
<li title="Prerequisites"><a href="introduction.html#id59177">Prerequisites</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Debugger" expanded="true">Debugger<ul>
<li><a href="debugger_chapter.html">
              Top of chapter
            </a></li>
<li title="Getting Started"><a href="debugger_chapter.html#id60418">Getting Started</a></li>
<li title="Breakpoints and Break Dialog Windows"><a href="debugger_chapter.html#id59715">Breakpoints and Break Dialog Windows</a></li>
<li title="Stack Trace"><a href="debugger_chapter.html#id56850">Stack Trace</a></li>
<li title="Monitor Window"><a href="debugger_chapter.html#id56635">Monitor Window</a></li>
<li title="Interpret Modules Window"><a href="debugger_chapter.html#id61274">Interpret Modules Window</a></li>
<li title="Attach Process Window"><a href="debugger_chapter.html#id61028">Attach Process Window</a></li>
<li title="View Module Window"><a href="debugger_chapter.html#id59026">View Module Window</a></li>
<li title="Performance"><a href="debugger_chapter.html#id62662">Performance</a></li>
<li title="Code Loading Mechanism"><a href="debugger_chapter.html#id62682">Code Loading Mechanism</a></li>
<li title="Debugging Remote Nodes"><a href="debugger_chapter.html#id62696">Debugging Remote Nodes</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>2 Debugger</h1>


  <h3><a name="id60418">2.1 
        Getting Started</a></h3>
    

    <p>To use Debugger, the basic steps are as follows:</p>

    <p><strong>Step 1.</strong> Start Debugger by calling
      <span class="code">debugger:start()</span>.</p>

    <p>The <span class="bold_code"><a href="#monitor">Monitor window</a></span> is
      displayed with information about all debugged processes,
      interpreted modules, and selected options. Initially there are
      normally no debugged processes. First, it must be specified which
      modules that are to be <strong>debugged</strong> (also called
      <strong>interpreted</strong>). Proceed as follows:</p>

    <p><strong>Step 2.</strong> Select <strong>Module &gt; Interpret...</strong> in the
      Monitor window.</p>

    <p>The <span class="bold_code"><a href="#interpret">Interpret Modules window</a></span>
      is displayed.</p>

    <p><strong>Step 3.</strong> Select the appropriate modules from the Interpret
      Dialog window.</p>

    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>Only modules compiled with option <span class="code">debug_info</span> set can be
        interpreted. Non-interpretable modules are displayed within
        parenthesis in the Interpret Modules window.</p>
    </p></div>
</div>

    <p><strong>Step 4.</strong> In the Monitor window, select
      <strong>Module &gt; the module to be interpreted &gt; View</strong>.</p>

    <p>The contents of the source file is displayed in the
      <span class="bold_code"><a href="#view">View Module window</a></span>.</p>

    <p><strong>Step 5.</strong> Set the
      <span class="bold_code"><a href="#breakpoints">breakpoints</a></span>, if any.</p>

    <p><strong>Step 6.</strong> Start the program to be debugged. This is done
      the normal way from the Erlang shell.</p>

    <p>All processes executing code in interpreted modules are displayed
      in the Monitor window.</p>

    <p><strong>Step 7.</strong> To <strong>attach</strong> to one of these processes,
      double-click it, or select the process and then choose
      <strong>Process &gt; Attach</strong>. Attaching to a process opens an
      <span class="bold_code"><a href="#attach">Attach Process window</a></span> for this
      process.</p>

    <p><strong>Step 8.</strong> From the Attach Process window, you can control
      the process execution, inspect variable values, set breakpoints,
      and so on.</p>
  

  <h3><a name="id59715">2.2 
        Breakpoints and Break Dialog Windows</a></h3>
    <a name="breakpoints"></a>
    
    
    <p>Once the appropriate modules are interpreted, breakpoints can
      be set at relevant locations in the source code. Breakpoints are
      specified on a line basis. When a process reaches a breakpoint,
      it stops and waits for commands (<strong>Step</strong>, <strong>Skip</strong>,
      <strong>Continue</strong> ...) from the user.</p>

    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>When a process reaches a breakpoint, only that process is
        stopped. Other processes are not affected.</p>
    </p></div>
</div>

    <p>Breakpoints are created and deleted using the <strong>Break</strong> menu of
      either the Monitor window, View Module window, or Attach Process
      window.</p>

    <h4>Executable Lines</h4>
      

      <p>To have an effect, a breakpoint must be set at an
        <strong>executable line</strong>, which is a line of code containing an
        executable expression such as a matching or a function call.
        A blank line or a line containing a comment, function head, or
        pattern in a <span class="code">case</span> statement or <span class="code">receive</span> statement is not
        executable.</p>

      <p>In the following example, lines 2, 4, 6, 8, and 11 are
        executable lines:</p>
      <div class="example"><pre>
1: is_loaded(Module,Compiled) -&gt;
2:   case get_file(Module,Compiled) of
3:     {ok,File} -&gt;
4:       case code:which(Module) of
5:         ?TAG -&gt;
6:           {loaded,File};
7:         _ -&gt;
8:           unloaded
9:       end;
10:    false -&gt;
11:      false
12:  end.</pre></div>
    
    
    <h4>Status and Trigger Action</h4>		  
      

      <p>A breakpoint can be either <strong>active</strong> or
        <strong>inactive</strong>. Inactive breakpoints are ignored.</p>

      <p>Each breakpoint has a <strong>trigger action</strong> that specifies
        what is to happen when a process has reached it (and stopped):</p>
      <ul>
        <li>
<strong>Enable</strong> - Breakpoint is to remain active (default).
        </li>
        <li>
<strong>Disable</strong> - Breakpoint is to be made inactive.</li>
        <li>
<strong>Delete</strong> - Breakpoint is to be deleted.</li>
      </ul>
    

    <h4>Line Breakpoints</h4>
      

      <p>A line breakpoint is created at a certain line in a module.</p>

      <img alt="IMAGE MISSING" src="images/line_break_dialog.jpg"><br>
        <em>Figure
        2.1:
         
        Line Break Dialog Window</em>
      

     <p>Right-click the <strong>Module</strong> entry to open a popup menu from
       which the appropriate module can be selected.</p>

     <p>A line breakpoint can also be created (and deleted) by
       double-clicking the line when the module is displayed in
       the View Module window or Attach Process window.</p>
    

    <h4>Conditional Breakpoints</h4>
      

      <p>A conditional breakpoint is created at a certain line in
        the module, but a process reaching the breakpoint stops
        only if a specified condition is true.</p>

      <p>The condition is specified by the user as a module name
        <span class="code">CModule</span> and a function name <span class="code">CFunction</span>. When a
        process reaches the breakpoint,
        <span class="code">CModule:CFunction(Bindings)</span> is evaluated. If and
        only if this function call returns <span class="code">true</span>, the process
        stops. If the function call returns <span class="code">false</span>,
        the breakpoint is silently ignored.</p>

      <p><span class="code">Bindings</span> is a list of variable bindings. To retrieve the
        value of <span class="code">Variable</span> (given as an atom), use function
        <span class="bold_code"><a href="../../man/int.html#get_binding-2"><span class="code">int:get_binding(Variable,Bindings)</span></a></span>.
        The function returns <span class="code">unbound</span> or <span class="code">{value,Value}</span>.</p>
	
      <img alt="IMAGE MISSING" src="images/cond_break_dialog.jpg"><br>
        <em>Figure
        2.2:
         
        Conditional Break Dialog Window</em>
      

      <p>Right-click the <strong>Module</strong> entry to open a popup menu from
        which the appropriate module can be selected.</p>

      <p><strong>Example:</strong></p>

      <p>A conditional breakpoint calling
        <span class="code">c_test:c_break/1</span> is added at line 6 in module
	<span class="code">fact</span>. Each time the breakpoint is reached, the function is
	called. When <span class="code">N</span> is equal to 3, the function returns
        <span class="code">true</span> and the process stops.</p>

      <p>Extract from <span class="code">fact.erl</span>:</p>
      <div class="example"><pre>
5. fac(0) -&gt; 1;
6. fac(N) when N &gt; 0, is_integer(N) -&gt; N * fac(N-1).</pre></div>

      <p>Definition of <span class="code">c_test:c_break/1</span>:</p>
      <div class="example"><pre>
-module(c_test).
-export([c_break/1]).

c_break(Bindings) -&gt;
    case int:get_binding('N', Bindings) of
        {value, 3} -&gt;
            true;
        _ -&gt;
            false
    end.</pre></div>
    

    <h4>Function Breakpoints</h4>
      

      <p>A function breakpoint is a set of line breakpoints, one at
        the first line of each clause in the specified function.</p>

      <img alt="IMAGE MISSING" src="images/function_break_dialog.jpg"><br>
        <em>Figure
        2.3:
         
        Function Break Dialog Window</em>
      

      <p>To open a popup menu from which the appropriate module can be
        selected, right-click the <strong>Module</strong> entry.</p>

      <p>To bring up all functions of the module in the listbox,
        click the <strong>OK</strong> button (or press the <strong>Return</strong>
        or <strong>Tab</strong> key) when a module name has been specified,.</p>
    
  

  <h3><a name="id56850">2.3 
        Stack Trace</a></h3>
    <a name="stack_trace"></a>
    

    <p>The Erlang emulator keeps track of a <strong>stack trace</strong>,
      information about recent function calls. This information is
      used if an error occurs, for example:</p>
    <div class="example"><pre>
1&gt; <span class="bold_code">catch a+1.</span>
{'EXIT',{badarith,[{erlang,'+',[a,1],[]},
                   {erl_eval,do_apply,6,[{file,"erl_eval.erl"},{line,573}]},
                   {erl_eval,expr,5,[{file,"erl_eval.erl"},{line,357}]},
                   {shell,exprs,7,[{file,"shell.erl"},{line,674}]},
                   {shell,eval_exprs,7,[{file,"shell.erl"},{line,629}]},
                   {shell,eval_loop,3,[{file,"shell.erl"},{line,614}]}]}}</pre></div>

    <p>For details about the stack trace, see section
      <span class="bold_code"><a href="../../reference_manual/errors.html">Errors and Error Handling</a></span>
      in the Erlang Reference Manual.</p>

    <p>Debugger emulates the stack trace by keeping track of recently
      called interpreted functions. (The real stack trace cannot be
      used, as it shows which functions of Debugger have been
      called, rather than which interpreted functions.)</p>

    <p>This information can be used to traverse the chain of function
      calls, using the <strong>Up</strong> and <strong>Down</strong> buttons in the
      <span class="bold_code"><a href="#attach">Attach Process window</a></span>.</p>

    <p>By default, Debugger only saves information about recursive
      function calls, that is, function calls that have not yet returned
      a value (option <strong>Stack On, No Tail</strong>).</p>

    <p>Sometimes, however, it can be useful to save all calls, even
      tail-recursive calls. This is done with option
      <strong>Stack On, Tail</strong>. Notice that this option consumes more
      memory and slows down execution of interpreted functions when there
      are many tail-recursive calls.</p>

    <p>To turn off the Debugger stack trace facility, select option
      <strong>Stack Off</strong>.</p>

    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>If an error occurs, the stack trace becomes empty in this
        case.</p>
    </p></div>
</div>

    <p>For information about how to change the stack trace option, see
      section <span class="bold_code"><a href="#monitor">Monitor Window</a></span>.</p>
  

  <h3><a name="id56635">2.4 
        Monitor Window</a></h3>
    <a name="monitor"></a>
    

    <p>The Monitor window is the main window of Debugger and displays the
      following:</p>

    <ul>
      <li>
<p>A listbox containing the names of all interpreted
        modules</p>
        <p>Double-clicking a module brings up the View Module window.</p>
      </li>
      <li><p>Which options are selected</p></li>
      <li><p>Information about all debugged processes, that is, all
        processes that have been or are executing code in interpreted
        modules</p></li>
      </ul>

    <img alt="IMAGE MISSING" src="images/monitor.jpg"><br>
      <em>Figure
        2.4:
         
        Monitor Window</em>
    

    <p>The <strong>Auto Attach</strong> boxes, <strong>Stack Trace</strong> label,
      <strong>Back Trace Size</strong> label, and <strong>Strings</strong> box display
      some options set. For details about these options, see section
      <span class="bold_code"><a href="#options">Options Menu</a></span>.</p>

    <h4>Process Grid</h4>
      
      <dl>
	<dt><strong><strong>Pid</strong></strong></dt>
	<dd><p>The process identifier.</p></dd>

	<dt><strong><strong>Initial Call</strong></strong></dt>
	<dd><p>The first call to an interpreted function by this
          process. (<span class="code">Module:Function/Arity</span>)</p></dd>

	<dt><strong><strong>Name</strong></strong></dt>
	<dd><p>The registered name, if any. If a registered name is not
          displayed, it can be that Debugger received information about
          the process before the name was registered. Try selecting
          <strong>Edit &gt; Refresh</strong>.</p></dd>

	<dt><strong><strong>Status</strong></strong></dt>
	<dd>
<p>The current status, one of the following:</p>
	  <dl>
	    <dt><strong><strong>idle</strong></strong></dt>
	    <dd><p>The interpreted function call has returned a value, and
	      the process is no longer executing interpreted code.</p></dd>

	    <dt><strong><strong>running</strong></strong></dt>
	    <dd><p>The process is running.</p></dd>

	    <dt><strong><strong>waiting</strong></strong></dt>
	    <dd><p>The process is waiting in a <span class="code">receive</span>
	      statement.</p></dd>

	    <dt><strong><strong>break</strong></strong></dt>
	    <dd><p>The process is stopped at a breakpoint.</p></dd>

	    <dt><strong><strong>exit</strong></strong></dt>
	    <dd><p>The process has terminated.</p></dd>

	    <dt><strong><strong>no_conn</strong></strong></dt>
	    <dd><p>There is no connection to the node where
	      the process is located.</p></dd>
	  </dl>
	</dd>

	<dt><strong><strong>Information</strong></strong></dt>
	<dd><p>More information, if any. If the process is
	  stopped at a breakpoint, the field contains information
	  about the location <span class="code">{Module,Line}</span>. If the process has
	  terminated, the field contains the exit reason.</p></dd>
      </dl>
    

    <h4>File Menu</h4>
      

      <dl>
	<dt><strong><strong>Load Settings...</strong></strong></dt>
	<dd>
<p>Tries to load and restore Debugger settings from a file
	  previously saved using <strong>Save Settings...</strong> (see below).
	  Any errors are silently ignored.</p>
	<p>Notice that settings saved by Erlang/OTP R16B01 or later
	  cannot be read by Erlang/OTP R16B or earlier.</p>
	</dd>

	<dt><strong><strong>Save Settings...</strong></strong></dt>
	<dd>
<p>Saves Debugger settings to a file. The settings include
	  the set of interpreted files, breakpoints, and the selected
	  options. The settings can be restored in a later Debugger
	  session using <strong>Load Settings...</strong> (see above).
	  Any errors are silently ignored.</p>
	</dd>

	<dt><strong><strong>Exit</strong></strong></dt>
	<dd><p>Stops Debugger.</p></dd>
      </dl>
    

    <h4>Edit Menu</h4>
      
      <dl>
	<dt><strong><strong>Refresh</strong></strong></dt>
	<dd><p>Updates information about debugged processes. Information
	  about all terminated processes are removed from the window. All
	  Attach Process windows for terminated processes are closed.</p></dd>

	<dt><strong><strong>Kill All</strong></strong></dt>
	<dd><p>Terminates all processes listed in the window using
	  <span class="code">exit(Pid,kill)</span>.</p></dd>
      </dl>
    

    <h4>Module Menu</h4>
      
      <dl>
	<dt><strong><strong>Interpret...</strong></strong></dt>
	<dd><p>Opens the
	  <span class="bold_code"><a href="#interpret">Interpret Modules window</a></span>,
	  where new modules to be interpreted can be specified.</p></dd>

	<dt><strong><strong>Delete All</strong></strong></dt>
	<dd><p>Stops interpreting all modules. Processes executing in
	  interpreted modules terminate.</p></dd>
      </dl>

      <p>For each interpreted module, a corresponding entry is added to
        the <strong>Module</strong> menu, with the following submenu:</p>
      <dl>
	<dt><strong><strong>Delete</strong></strong></dt>
	<dd><p>Stops interpreting the selected module. Processes
	  executing in this module terminate.</p></dd>

	<dt><strong><strong>View</strong></strong></dt>
	<dd><p>Opens a
	  <span class="bold_code"><a href="#view">View Module window</a></span>, displaying the
	  contents of the selected module.</p></dd>
      </dl>
    

    <h4>Process Menu</h4>
      
      <p>The following menu items apply to the currently selected
        process, provided it is stopped at a breakpoint (for details, see
	section 
	<span class="bold_code"><a href="#attach">Attach Process window</a></span>):</p>
      <dl>
	<dt><strong><strong>Step</strong></strong></dt>
<dd></dd>
	<dt><strong><strong>Next</strong></strong></dt>
<dd></dd>
	<dt><strong><strong>Continue</strong></strong></dt>
<dd></dd>
	<dt><strong><strong>Finish</strong></strong></dt>
<dd></dd>
      </dl>

      <p>The following menu items apply to the currently selected
        process:</p>
      <dl>
	<dt><strong><strong>Attach</strong></strong></dt>
	<dd><p>Attaches to the process and open an
	  <span class="bold_code"><a href="#attach">Attach Process window</a></span>.</p></dd>

	<dt><strong><strong>Kill</strong></strong></dt>
	<dd><p>Terminates the process using <span class="code">exit(Pid,kill)</span>.</p></dd>
      </dl>
    

    <h4>Break Menu</h4>
      
      <p>The items in this menu are used to create and delete breakpoints.
        For details, see section
	<span class="bold_code"><a href="#breakpoints">Breakpoints</a></span>.</p>

      <dl>
	<dt><strong><strong>Line Break...</strong></strong></dt>
	<dd><p>Sets a line breakpoint.</p></dd>

	<dt><strong><strong>Conditional Break...</strong></strong></dt>
	<dd><p>Sets a conditional breakpoint.</p></dd>

	<dt><strong><strong>Function Break...</strong></strong></dt>
	<dd><p>Sets a function breakpoint.</p></dd>

	<dt><strong><strong>Enable All</strong></strong></dt>
	<dd><p>Enables all breakpoints.</p></dd>

	<dt><strong><strong>Disable All</strong></strong></dt>
	<dd><p>Disables all breakpoints.</p></dd>

	<dt><strong><strong>Delete All</strong></strong></dt>
	<dd><p>Removes all breakpoints.</p></dd>
      </dl>

      <p>For each breakpoint, a corresponding entry is added to the
        <strong>Break</strong> menu, from which it is possible to disable, enable,
	or delete the breakpoint, and to change its trigger action.</p>
    

    <h4>Options Menu</h4>
      <a name="options"></a>
      

      <dl>
	<dt><strong><strong>Trace Window</strong></strong></dt>
	<dd>
<p>Sets the areas to be visible in an
	  <span class="bold_code"><a href="#attach">Attach Process window</a></span>.
	  Does not affect existing Attach Process windows.</p>
	</dd>

	<dt><strong><strong>Auto Attach</strong></strong></dt>
	<dd>
<p>Sets the events a debugged process is to be attached
	  to automatically. Affects existing debugged processes.</p>
	  <ul>
	    <li><p><strong>First Call</strong> - The first time a process calls
	      a function in an interpreted module.</p></li>
	    <li><p><strong>On Exit</strong> - At process termination.</p></li>
	    <li><p><strong>On Break</strong> - When a process reaches a
	      breakpoint.</p></li>
	  </ul>
	</dd>

	<dt><strong><strong>Stack Trace</strong></strong></dt>
	<dd>
<p>Sets the stack trace option, see section
	  <span class="bold_code"><a href="#stack_trace">Stack Trace</a></span>. Does not
	    affect existing debugged processes.</p>
	  <ul>
	    <li><p><strong>Stack On, Tail</strong> - Saves information about all
	      current calls.</p></li>
	    <li><p><strong>Stack On, No Tail</strong> - Saves information about
	      current calls, discarding previous information when a tail
	      recursive call is made.</p></li>
	    <li><p><strong>Stack Off</strong> - Does not save any information about
	      current calls.</p></li>
	  </ul>
	</dd>

	<dt><strong><strong>Strings</strong></strong></dt>
	<dd>
<p>Sets the integer lists to be printed as strings.
	  Does not affect existing debugged processes.</p>
	  <ul>
	    <li>
<p><strong>Use range of +pc flag</strong> - Uses the printable
	      character range set by the <span class="code">erl(1)</span> flag
	      <span class="bold_code"><a href="../../man/erl.html#printable_character_range"><span class="code">+pc</span></a></span>.</p>
	    </li>
	  </ul>
	</dd>

	<dt><strong><strong>Back Trace Size...</strong></strong></dt>
	<dd>
<p>Sets how many call frames to be fetched when
	  inspecting the call stack from the Attach Process window.
	  Does not affect existing Attach Process windows.</p>
	</dd>
      </dl>
    

    <h4>Windows Menu</h4>
      
      <p>Contains a menu item for each open Debugger window. Selecting
        one of the items raises the corresponding window.</p>
    

    <h4>Help Menu</h4>
      
      <dl>
	<dt><strong><strong>Help</strong></strong></dt>
	<dd><p>Shows the Debugger documentation. This function requires a
	  web browser.</p></dd>
      </dl>
    
  

  <h3><a name="id61274">2.5 
        Interpret Modules Window</a></h3>
    <a name="interpret"></a>
    

    <p>The Interpret Modules window is used for selecting which modules
      to interpret. Initially, the window displays the modules (<span class="code">erl</span>
     files) and subdirectories of the current working directory.</p>

    <p>Interpretable modules are modules for which a <span class="code">.beam</span> file,
      compiled with option <span class="code">debug_info</span> set, is located in the same
      directory as the source code, or in an <span class="code">ebin</span> directory next
      to it.</p>

    <p>Modules for which these requirements are not fulfilled are
      not interpretable and are therefore displayed within parentheses.</p>

    <p>Option <span class="code">debug_info</span> causes <strong>debug information</strong> or
      <strong>abstract code</strong> to be added to the <span class="code">.beam</span> file.
      This increases the file size and makes it possible to
      reconstruct the source code. It is therefore recommended not to
      include debug information in code aimed for target systems.</p>

    <p>An example of how to compile code with debug information using
      <span class="code">erlc</span>:</p>
    <div class="example"><pre>
% erlc +debug_info module.erl</pre></div>

    <p>An example of how to compile code with debug information from
      the Erlang shell:</p>
    <div class="example"><pre>
4&gt; c(module, debug_info).</pre></div>

    <img alt="IMAGE MISSING" src="images/interpret.jpg"><br>
      <em>Figure
        2.5:
         
        Interpret Modules Window</em>
    

    <p>To browse the file hierarchy and interpret the appropriate modules,
      either select a module name and click <strong>Choose</strong> (or
      press carriage return), or double-click the module name.
      Interpreted modules have the type <span class="code">erl src</span>.</p>

    <p>To interpret all displayed modules in the chosen directory, click
      <strong>All</strong>.</p>

    <p>To close the window, click <strong>Done</strong>.</p>

    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>When Debugger is started in global mode (which is the default, see
        <span class="bold_code"><a href="../../man/debugger.html#start-0">debugger:start/0</a></span>),
        modules added (or deleted) for interpretation are added (or
        deleted) on all known Erlang nodes.</p>
    </p></div>
</div>
  

  <h3><a name="id61028">2.6 
        Attach Process Window</a></h3>
    <a name="attach"></a>
    

    <p>From an Attach Process window, you can interact with a
      debugged process. One window is opened for each process that has
      been attached to. Notice that when attaching to a process, its
      execution is automatically stopped.</p>

    <img alt="IMAGE MISSING" src="images/attach.jpg"><br>
      <em>Figure
        2.6:
         
        Attach Process Window</em>
    

    <p>The window is divided into the following five parts:</p>
    <ul>
      <li>
<p>The Code area, displaying the code being executed. The code
        is indented and each line is prefixed with its line number.
        If the process execution is stopped, the current line is
        marked with <span class="code">--&gt;</span>. An existing break point at a line
        is marked with a stop symbol. In the example shown in the
        illustration, the execution stopped at line 6, before
        the execution of <span class="code">fac/1</span>.</p>

        <p>Active breakpoints are displayed in red and inactive
          breakpoints in blue.</p>
      </li>

      <li><p>The Button area, with buttons for quick access to frequently
        used functions in the <strong>Process</strong> menu.</p></li>

      <li><p>The Evaluator area, where you can evaluate functions
        within the context of the debugged process, if that
        process execution is stopped.</p></li>

      <li>
<p>The Bindings area, displaying all variables bindings. If you
        click a variable name, the value is displayed in the Evaluator area.
	Double-click a variable name to open a window where
        the variable value can be edited. Notice however that pid,
        reference, binary, or port values cannot be edited.</p>
      </li>

      <li>
<p>The Trace area, which displays a trace output for the
        process.</p>
	<dl>
          <dt><strong><span class="code">++ (N) &lt;L&gt;</span></strong></dt>
          <dd><p>Function call, where <span class="code">N</span> is the call level and
            <span class="code">L</span> the line number.</p></dd>

          <dt><strong><span class="code">-- (N)</span></strong></dt>
          <dd>
<p>Function return value</p>.</dd>

          <dt><strong><span class="code">==&gt; Pid : Msg</span></strong></dt>
          <dd><p>The message <span class="code">Msg</span> is sent to process
            <span class="code">Pid</span>.</p></dd>

          <dt><strong><span class="code">&lt;== Msg</span></strong></dt>
          <dd><p>The message <span class="code">Msg</span> is received.</p></dd>

          <dt><strong><span class="code">++ (N) receive</span></strong></dt>
          <dd><p>Waiting in a <span class="code">receive</span>.</p></dd>

          <dt><strong><span class="code">++ (N) receive with timeout</span></strong></dt>
          <dd><p>Waiting in a <span class="code">receive...after</span>.</p></dd>
        </dl>

        <p>The Trace area also displays Back Trace, a summary of the
          current function calls on the stack.</p>
      </li>
    </ul>

    <p>Using the <strong>Options</strong> menu, you can set which areas to be
      displayed. By default, all areas except the Trace area are displayed.</p>

    <h4>File Menu</h4>
      

      <dl>
	<dt><strong><strong>Close</strong></strong></dt>
	<dd>
<p>Closes this window and detach from the process.</p>
	</dd>
      </dl>
    

    <h4>Edit Menu</h4>
      

      <dl>
	<dt><strong><strong>Go to line...</strong></strong></dt>
	<dd><p>Goes to a specified line number.</p></dd>

	<dt><strong><strong>Search...</strong></strong></dt>
	<dd><p>Searches for a specified string.</p></dd>
      </dl>
    

    <h4>Process Menu</h4>
      

      <dl>
	<dt><strong><strong>Step</strong></strong></dt> 
	<dd><p>Executes the current code line, stepping into any
	    (interpreted) function calls.</p></dd>

	<dt><strong><strong>Next</strong></strong></dt>
	<dd><p>Executes the current code line and stop at the next
	    line.</p></dd>

	<dt><strong><strong>Continue</strong></strong></dt>
	<dd><p>Continues the execution.</p></dd>

	<dt><strong><strong>Finish</strong></strong></dt>
	<dd><p>Continues the execution until the current function
	    returns.</p></dd>

	<dt><strong><strong>Skip</strong></strong></dt>
	<dd><p>Skips the current code line and stop at the next
	    line. If used on the last line in a function body,
	    the function returns <span class="code">skipped</span>.</p></dd>

	<dt><strong><strong>Time Out</strong></strong></dt>
	<dd><p>Simulates a time-out when executing a
	    <span class="code">receive...after</span> statement.</p></dd>

	<dt><strong><strong>Stop</strong></strong></dt>
	<dd><p>Stops the execution of a running process, that is, make
	    the process stop at a breakpoint. The command takes
	    effect (visibly) the next time the process receives a
	    message.</p></dd>

	<dt><strong><strong>Where</strong></strong></dt>
	<dd><p>Verifies that the current location of the execution is
	    visible in the code area.</p></dd>

	<dt><strong><strong>Kill</strong></strong></dt>
	<dd>
<p>Terminates the process using <span class="code">exit(Pid,kill)</span>.</p>
	</dd>

	<dt><strong><strong>Messages</strong></strong></dt>
	<dd><p>Inspects the message queue of the process. The queue is
	    displayed in the Evaluator area.</p></dd>

	<dt><strong><strong>Back Trace</strong></strong></dt>
	<dd>
<p>Displays the back trace of the process, a summary of
	    the current function calls on the stack, in the Trace area.
	    Requires that the Trace area is visible and that the Stack
	    Trace option is <strong>Stack On, Tail</strong> or
	    <strong>Stack On, No Tail</strong>.</p>
	</dd>

	<dt><strong><strong>Up</strong></strong></dt>
	<dd><p>Inspects the previous function call on the stack,
	    showing the location and variable bindings.</p></dd>

	<dt><strong><strong>Down</strong></strong></dt>
	<dd><p>Inspects the next function call on the stack, showing
	    the location and variable bindings.</p></dd>
      </dl>
    

    <h4>Options Menu</h4>
      

      <dl>
	<dt><strong><strong>Trace Window</strong></strong></dt>
	<dd><p>Sets which areas are to be visible. Does not affect
	    other Attach Process windows.</p></dd>

	<dt><strong><strong>Stack Trace</strong></strong></dt>
	<dd><p>Same as in the <span class="bold_code"><a href="#monitor">Monitor
	    window</a></span>, but only affects the debugged
	    process the window is attached to.</p></dd>

	<dt><strong><strong>Strings</strong></strong></dt>
	<dd><p>Same as in the <span class="bold_code"><a href="#monitor">Monitor
	    window</a></span>, but only affects the debugged
	    process the window is attached to.</p></dd>

	<dt><strong><strong>Back Trace Size...</strong></strong></dt>
	<dd><p>Sets how many call frames are to be fetched when
	    inspecting the call stack. Does not affect other Attach
	    Process windows.</p></dd>
      </dl>
    

    <h4>Break, Windows, and Help Menus</h4>
      

      <p>The <strong>Break</strong>, <strong>Windows</strong>, and <strong>Help</strong> menus
        are the same as in the
        <span class="bold_code"><a href="#monitor">Monitor Window</a></span>, except
        that the <strong>Breaks</strong> menu applies only to local
        breakpoints.</p>
    
  

  <h3><a name="id59026">2.7 
        View Module Window</a></h3>
    <a name="view"></a>
    

    <p>The View Module window displays the contents of an interpreted
      module and makes it possible to set breakpoints.</p>

    <img alt="IMAGE MISSING" src="images/view.jpg"><br>
      <em>Figure
        2.7:
         
        View Module Window</em>
    

    <p>The source code is indented and each line is prefixed with its
      line number.</p>

    <p>Clicking a line highlights it and selects it to be the target
      of the breakpoint functions available from the <strong>Break</strong> menu.
      To set a line breakpoint on a line, double-click it.
      To remove the breakpoint, double-click the line with an existing
       breakpoint.</p>

    <p>Breakpoints are marked with a stop symbol.</p>

    <h4>File and Edit Menus</h4>
      
      <p>The <strong>File</strong> and <strong>Edit</strong> menus are the same as in the
      <span class="bold_code"><a href="#attach">Attach Process Window</a></span>.</p>
    

    <h4>Break, Windows, and Help Menus</h4>
      

      <p>The <strong>Break</strong>, <strong>Windows</strong>, and <strong>Help</strong> menus
        are the same as in the
        <span class="bold_code"><a href="#monitor">Monitor Window</a></span>, except
	that the <strong>Break</strong> menu applies only to local breakpoints.</p>
    
  

  <h3><a name="id62662">2.8 
        Performance</a></h3>
    

    <p>Execution of interpreted code is naturally slower than for
      regularly compiled modules. Using Debugger also increases
      the number of processes in the system, as for each debugged
      process another process (the meta process) is created.</p>

    <p>It is also worth to keep in mind that programs with timers can
      behave differently when debugged. This is especially true when
      stopping the execution of a process (for example, at a
      breakpoint). Time-outs can then occur in other processes that
      continue execution as normal.</p>
  

  <h3><a name="id62682">2.9 
        Code Loading Mechanism</a></h3>
    

    <p>Code loading works almost as usual, except that interpreted
      modules are also stored in a database and debugged processes
      use only this stored code. Reinterpreting an interpreted
      module results in the new version being stored as well, but
      does not affect existing processes executing an older version
      of the code. This means that the code replacement mechanism of
      Erlang does not work for debugged processes.</p>
  

  <h3><a name="id62696">2.10 
        Debugging Remote Nodes</a></h3>
    

    <p>By using
      <span class="bold_code"><a href="../../man/debugger.html#start-1">debugger:start/1</a></span>,
      you can specify if Debugger is to be started in local or global
      mode:</p>
    <div class="example"><pre>
debugger:start(local | global)</pre></div>

    <p>If no argument is provided, Debugger starts in global mode.</p>

    <p>In local mode, code is interpreted only at the current node.
      In global mode, code is interpreted at all known nodes. Processes
      at other nodes executing interpreted code are automatically
      displayed in the Monitor window and can be attached to like any other
      debugged process.</p>

    <p>It is possible, but definitely not recommended, to start Debugger
      in global mode on more than one node in a network, as the nodes
      interfere with each other, leading to inconsistent behavior.</p>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
