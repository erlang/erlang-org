<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Build a Mnesia Database</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="index.html">Reference Manual</a><br><a href="release_notes.html">Release Notes</a><br><a href="mnesia.pdf">PDF</a><br><a href="../../index.html">Top</a></small><p><strong>Mnesia</strong><br><strong>User's Guide</strong><br><small>Version 4.13.3</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="Mnesia_chap1.html">
              Top of chapter
            </a></li>
<li title="Scope"><a href="Mnesia_chap1.html#id62970">Scope</a></li>
<li title="Prerequisites"><a href="Mnesia_chap1.html#id61618">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="Mnesia" expanded="false">Mnesia<ul>
<li><a href="Mnesia_overview.html">
              Top of chapter
            </a></li>
<li title="Mnesia Database Management System (DBMS)"><a href="Mnesia_overview.html#id56828">Mnesia Database Management System (DBMS)</a></li>
</ul>
</li>
<li id="no" title="Getting Started" expanded="false">Getting Started<ul>
<li><a href="Mnesia_chap2.html">
              Top of chapter
            </a></li>
<li title="Starting Mnesia for the First Time"><a href="Mnesia_chap2.html#id61789">Starting Mnesia for the First Time</a></li>
<li title="Example"><a href="Mnesia_chap2.html#id66273">Example</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Build a Mnesia Database" expanded="true">Build a Mnesia Database<ul>
<li><a href="Mnesia_chap3.html">
              Top of chapter
            </a></li>
<li title="Define a Schema"><a href="Mnesia_chap3.html#id66909">Define a Schema</a></li>
<li title="Data Model"><a href="Mnesia_chap3.html#id70360">Data Model</a></li>
<li title="Start Mnesia"><a href="Mnesia_chap3.html#id70422">Start Mnesia</a></li>
<li title="Create Tables"><a href="Mnesia_chap3.html#id75532">Create Tables</a></li>
</ul>
</li>
<li id="no" title="Transactions and Other Access Contexts" expanded="false">Transactions and Other Access Contexts<ul>
<li><a href="Mnesia_chap4.html">
              Top of chapter
            </a></li>
<li title="Transaction Properties"><a href="Mnesia_chap4.html#id76135">Transaction Properties</a></li>
<li title="Locking"><a href="Mnesia_chap4.html#id76396">Locking</a></li>
<li title="Dirty Operations"><a href="Mnesia_chap4.html#id76969">Dirty Operations</a></li>
<li title="Record Names versus Table Names"><a href="Mnesia_chap4.html#id77432">Record Names versus Table Names</a></li>
<li title="Activity Concept and Various Access Contexts"><a href="Mnesia_chap4.html#id77531">Activity Concept and Various Access Contexts</a></li>
<li title="Nested Transactions"><a href="Mnesia_chap4.html#id78070">Nested Transactions</a></li>
<li title="Pattern Matching"><a href="Mnesia_chap4.html#id78160">Pattern Matching</a></li>
<li title="Iteration"><a href="Mnesia_chap4.html#id78629">Iteration</a></li>
</ul>
</li>
<li id="no" title="Miscellaneous Mnesia Features" expanded="false">Miscellaneous Mnesia Features<ul>
<li><a href="Mnesia_chap5.html">
              Top of chapter
            </a></li>
<li title="Indexing"><a href="Mnesia_chap5.html#id79053">Indexing</a></li>
<li title="Distribution and Fault Tolerance"><a href="Mnesia_chap5.html#id79192">Distribution and Fault Tolerance</a></li>
<li title="Table Fragmentation"><a href="Mnesia_chap5.html#id79352">Table Fragmentation</a></li>
<li title="Local Content Tables"><a href="Mnesia_chap5.html#id80361">Local Content Tables</a></li>
<li title="Disc-Less Nodes"><a href="Mnesia_chap5.html#id80388">Disc-Less Nodes</a></li>
<li title="More about Schema Management"><a href="Mnesia_chap5.html#id80610">More about Schema Management</a></li>
<li title="Mnesia Event Handling"><a href="Mnesia_chap5.html#id80912">Mnesia Event Handling</a></li>
<li title="Debugging Mnesia Applications"><a href="Mnesia_chap5.html#id81682">Debugging Mnesia Applications</a></li>
<li title="Concurrent Processes in Mnesia"><a href="Mnesia_chap5.html#id81830">Concurrent Processes in Mnesia</a></li>
<li title="Prototyping"><a href="Mnesia_chap5.html#id81882">Prototyping</a></li>
<li title="Object-Based Programming with Mnesia"><a href="Mnesia_chap5.html#id82022">Object-Based Programming with Mnesia</a></li>
</ul>
</li>
<li id="no" title="Mnesia System Information" expanded="false">Mnesia System Information<ul>
<li><a href="Mnesia_chap7.html">
              Top of chapter
            </a></li>
<li title="Database Configuration Data"><a href="Mnesia_chap7.html#id82354">Database Configuration Data</a></li>
<li title="Core Dumps"><a href="Mnesia_chap7.html#id82399">Core Dumps</a></li>
<li title="Dumping Tables"><a href="Mnesia_chap7.html#id82431">Dumping Tables</a></li>
<li title="Checkpoints"><a href="Mnesia_chap7.html#id82479">Checkpoints</a></li>
<li title="Startup Files, Log File, and Data Files"><a href="Mnesia_chap7.html#id82740">Startup Files, Log File, and Data Files</a></li>
<li title="Loading Tables at Startup"><a href="Mnesia_chap7.html#id83254">Loading Tables at Startup</a></li>
<li title="Recovery from Communication Failure"><a href="Mnesia_chap7.html#id83474">Recovery from Communication Failure</a></li>
<li title="Recovery of Transactions"><a href="Mnesia_chap7.html#id83657">Recovery of Transactions</a></li>
<li title="Backup, Restore, Fallback, and Disaster Recovery"><a href="Mnesia_chap7.html#id83842">Backup, Restore, Fallback, and Disaster Recovery</a></li>
</ul>
</li>
<li id="no" title="Combine Mnesia with SNMP" expanded="false">Combine Mnesia with SNMP<ul>
<li><a href="Mnesia_chap8.html">
              Top of chapter
            </a></li>
<li title="Combine Mnesia and SNMP"><a href="Mnesia_chap8.html#id84804">Combine Mnesia and SNMP</a></li>
</ul>
</li>
<li id="no" title="Appendix A: Backup Callback Interface" expanded="false">Appendix A: Backup Callback Interface<ul>
<li><a href="Mnesia_App_A.html">
              Top of chapter
            </a></li>
<li title="mnesia_backup Callback Behavior"><a href="Mnesia_App_A.html#id84928">mnesia_backup Callback Behavior</a></li>
</ul>
</li>
<li id="no" title="Appendix B: Activity Access Callback Interface" expanded="false">Appendix B: Activity Access Callback Interface<ul>
<li><a href="Mnesia_App_B.html">
              Top of chapter
            </a></li>
<li title="mnesia_access Callback Behavior"><a href="Mnesia_App_B.html#id85049">mnesia_access Callback Behavior</a></li>
</ul>
</li>
<li id="no" title="Appendix C: Fragmented Table Hashing Callback Interface" expanded="false">Appendix C: Fragmented Table Hashing Callback Interface<ul>
<li><a href="Mnesia_App_C.html">
              Top of chapter
            </a></li>
<li title="mnesia_frag_hash Callback Behavior"><a href="Mnesia_App_C.html#id85192">mnesia_frag_hash Callback Behavior</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>4 Build a Mnesia Database</h1>
  
  <p>This section describes the basic steps when designing a
    <span class="code">Mnesia</span> database and the programming constructs that make different
    solutions available to the programmer. The following topics are
    included:</p>
  <ul>
    <li>Define a schema</li>
    <li>Data model</li>
    <li>Start <span class="code">Mnesia</span>
</li>
    <li>Create tables</li>
  </ul>

  <h3><a name="id66909">4.1 
        Define a Schema</a></h3>
    <a name="def_schema"></a>
    
    <p>The configuration of a <span class="code">Mnesia</span> system is described in a
      schema. The schema is a special table that includes information
      such as the table names and the storage type of each table
      (that is, whether a table is to be stored in RAM,
      on disc, or on both, as well as its location).</p>
    <p>Unlike data tables, information in schema tables can only be
      accessed and modified by using the schema-related functions
      described in this section.</p>
    <p><span class="code">Mnesia</span> has various functions for defining the
      database schema. Tables can be moved or deleted, and the
      table layout can be reconfigured.</p>
    <p>An important aspect of these functions is that the system can access
      a table while it is being reconfigured. For example, it is possible
      to move a
      table and simultaneously perform write operations to the same
      table. This feature is essential for applications that require
      continuous service.</p>
    <p>This section describes the functions available for schema management,
      all which return either of the following tuples:</p>
    <ul>
      <li>
<span class="code">{atomic, ok}</span> if successful</li>
      <li>
<span class="code">{aborted, Reason}</span> if unsuccessful</li>
    </ul>

    <h4>Schema Functions</h4>
      
    <p>The schema functions are as follows:</p>
      <ul>
        <li>
<span class="bold_code"><a href="../../man/mnesia.html#create_schema-1">mnesia:create_schema(NodeList)</a></span>
         initializes a new, empty schema. This is a mandatory requirement
         before <span class="code">Mnesia</span> can be started. <span class="code">Mnesia</span> is a truly
         distributed DBMS and the schema is a system table that is
         replicated on all nodes in a <span class="code">Mnesia</span> system.
         This function fails if a schema is already present on any of
         the nodes in <span class="code">NodeList</span>. The function requires <span class="code">Mnesia</span>
         to be stopped on the all
         <span class="code">db_nodes</span> contained in parameter <span class="code">NodeList</span>.
         Applications call this function only once, as
         it is usually a one-time activity to initialize a new database.
        </li>
        <li>
<span class="bold_code"><a href="../../man/mnesia.html#delete_schema-1">mnesia:delete_schema(DiscNodeList)</a></span>
         erases any old schemas on the nodes in
         <span class="code">DiscNodeList</span>. It also removes all old tables together
         with all data. This function requires <span class="code">Mnesia</span> to be stopped
         on all <span class="code">db_nodes</span>.
        </li>
        <li>
<span class="bold_code"><a href="../../man/mnesia.html#delete_table-1">mnesia:delete_table(Tab)</a></span>
         permanently deletes all replicas of table <span class="code">Tab</span>.
        </li>
        <li>
<span class="bold_code"><a href="../../man/mnesia.html#clear_table-1">mnesia:clear_table(Tab)</a></span>
         permanently deletes all entries in table <span class="code">Tab</span>.
        </li>
        <li>
<span class="bold_code"><a href="../../man/mnesia.html#move_table_copy-3">mnesia:move_table_copy(Tab, From, To)</a></span>
         moves the copy of table <span class="code">Tab</span> from node
         <span class="code">From</span> to node <span class="code">To</span>. The table storage type
         <span class="code">{type}</span> is preserved, so if a RAM table is moved from
         one node to another, it remains a RAM table on the new
         node. Other transactions can still perform read
         and write operation to the table while it is being moved.
        </li>
        <li>
<span class="bold_code"><a href="../../man/mnesia.html#add_table_copy-3">mnesia:add_table_copy(Tab, Node, Type)</a></span>
         creates a replica of table <span class="code">Tab</span> at node
         <span class="code">Node</span>. Argument <span class="code">Type</span> must be either of the
         atoms <span class="code">ram_copies</span>, <span class="code">disc_copies</span>, or
         <span class="code">disc_only_copies</span>. If you add a copy of the system
         table <span class="code">schema</span> to a node, you want the <span class="code">Mnesia</span>
         schema to reside there as well. This action
         extends the set of nodes that comprise this particular
         <span class="code">Mnesia</span> system.
        </li>
        <li>
<span class="bold_code"><a href="../../man/mnesia.html#del_table_copy-2">mnesia:del_table_copy(Tab, Node)</a></span>
         deletes the replica of table <span class="code">Tab</span> at node <span class="code">Node</span>.
         When the last replica of a table is removed, the table is
         deleted.
        </li>
        <li>
          <p><span class="bold_code"><a href="../../man/mnesia.html#transform_table-4">mnesia:transform_table(Tab, Fun, NewAttributeList, NewRecordName)</a></span>
            changes the format on all records in table
            <span class="code">Tab</span>. It applies argument <span class="code">Fun</span> to all
            records in the table. <span class="code">Fun</span> must be a function that
            takes a record of the old type, and returns the record of the
            new type. The table key must not be changed.</p>
          <p><strong>Example:</strong></p>
          <div class="example"><pre>
-record(old, {key, val}).
-record(new, {key, val, extra}).

Transformer =
   fun(X) when record(X, old) -&gt;
      #new{key = X#old.key,
           val = X#old.val,
           extra = 42}
   end,
{atomic, ok} = mnesia:transform_table(foo, Transformer,
                                      record_info(fields, new),
                                      new),
</pre></div>
            <p>Argument <span class="code">Fun</span> can also be the atom
            <span class="code">ignore</span>, which indicates that only the metadata about
            the table is updated. Use of <span class="code">ignore</span> is not recommended
            (as it creates inconsistencies between the metadata and the
            actual data) but it is included as a possibility for the user
            do to an own (offline) transform.</p>
        </li>
        <li>
<span class="code">change_table_copy_type(Tab, Node, ToType)</span>
         changes the storage type of a table. For example, a
         RAM table is changed to a <span class="code">disc_table</span> at the node specified
         as <span class="code">Node</span>.</li>
      </ul>
    
  

  <h3><a name="id70360">4.2 
        Data Model</a></h3>
    
    <p>The data model employed by <span class="code">Mnesia</span> is an extended
      relational data model. Data is organized as a set of
      tables and relations between different data records can
      be modeled as more tables describing the relationships.
      Each table contains instances of Erlang records.
      The records are represented as Erlang tuples.</p>
    <p>Each Object Identifier (OID) is made up of a table name and a key.
      For example, if an employee record is represented by the tuple
      <span class="code">{employee, 104732, klacke, 7, male, 98108, {221, 015}}</span>,
      this record has an OID, which is the tuple
      <span class="code">{employee, 104732}</span>.</p>
    <p>Thus, each table is made up of records, where the first element
      is a record name and the second element of the table is a key,
      which identifies the particular record in that table. The
      combination of the table name and a key is an arity two tuple
      <span class="code">{Tab, Key}</span> called the OID. For more information about
      the relationship beween the record name and the table name, see
      <span class="bold_code"><a href="Mnesia_chap4.html#recordnames_tablenames">Record Names versus Table Names</a></span>.
    </p>
    <p>What makes the <span class="code">Mnesia</span> data model an extended relational model
      is the ability to store arbitrary Erlang terms in the attribute
      fields. One attribute value can, for example, be a whole tree of
      OIDs leading to other terms in other tables. This type
      of record is difficult to model in traditional relational DBMSs.</p>
  

  <h3><a name="id70422">4.3 
        Start Mnesia</a></h3>
    <a name="start_mnesia"></a>
    
    <p>Before starting <span class="code">Mnesia</span>, the following must be done:
      </p>
    <ul>
      <li>An empty schema must be initialized on all the
       participating nodes.</li>
      <li>The Erlang system must be started.</li>
      <li>Nodes with disc database schema must be defined and
       implemented with the function
       <span class="bold_code"><a href="../../man/mnesia.html#create_schema-1">mnesia:create_schema(NodeList)</a></span>.</li>
    </ul>
    <p>When running a distributed system with two or more
      participating nodes, the function
      <span class="bold_code"><a href="../../man/mnesia.html#start-0">mnesia:start()</a></span>
      must be executed on each participating node. This would typically
      be part of the boot script in an embedded environment.
      In a test environment or an interactive environment,
      <span class="code">mnesia:start()</span> can also be used either from the
      Erlang shell or another program.
      </p>

    <h4>Initialize a Schema and Start Mnesia</h4>
      
      <p>Let us use the example database <span class="code">Company</span>, described in
        <span class="bold_code"><a href="Mnesia_chap2.html#getting_started">Getting Started</a></span> to
        illustrate how to run a database on two separate nodes,
        called <span class="code">a@gin</span> and <span class="code">b@skeppet</span>. Each of these
        nodes must have a <span class="code">Mnesia</span> directory and an
        initialized schema before <span class="code">Mnesia</span> can be started. There are
        two ways to specify the <span class="code">Mnesia</span> directory to be used:</p>
      <ul>
        <li>
          <p>Specify the <span class="code">Mnesia</span> directory by providing an application
            parameter either when starting the Erlang shell or in the
            application script. Previously, the following example was used
            to create the directory for the <span class="code">Company</span> database:</p>
          <div class="example"><pre>
%<span class="bold_code">erl -mnesia dir '"/ldisc/scratch/Mnesia.Company"'</span>
          </pre></div>
        </li>
        <li>If no command-line flag is entered, the <span class="code">Mnesia</span>
         directory becomes the current working directory on the node
         where the Erlang shell is started.</li>
      </ul>
      <p>To start the <span class="code">Company</span> database and get it running on the two
        specified nodes, enter the following commands:</p>
      <ul>
        <li>
          <p>On the node <span class="code">a@gin</span>:</p>
          <div class="example"><pre>
 gin %<span class="bold_code">erl -sname a  -mnesia dir '"/ldisc/scratch/Mnesia.company"'</span></pre></div>
        </li>
        <li>
<p>On the node <span class="code">b@skeppet</span>:</p>
          <div class="example"><pre>
skeppet %<span class="bold_code">erl -sname b -mnesia dir '"/ldisc/scratch/Mnesia.company"'</span></pre></div>
        </li>
        <li>
          <p>On one of the two nodes:</p>
          <div class="example"><pre>
(a@gin)1&gt;<span class="bold_code">mnesia:create_schema([a@gin, b@skeppet]).</span></pre></div>
        </li>
        <li>The function
          <span class="bold_code"><a href="../../man/mnesia.html#start-0">mnesia:start()</a></span>
          is called on both nodes.
        </li>
        <li>
<p>To initialize the database, execute the following
          code on one of the two nodes:</p>
<div class="example"><pre>


dist_init() -&gt;
    mnesia:create_table(employee,
                         [{ram_copies, [a@gin, b@skeppet]},
                          {attributes, record_info(fields,
						   employee)}]),
    mnesia:create_table(dept,
                         [{ram_copies, [a@gin, b@skeppet]},
                          {attributes, record_info(fields, dept)}]),
    mnesia:create_table(project,
                         [{ram_copies, [a@gin, b@skeppet]},
                          {attributes, record_info(fields, project)}]),
    mnesia:create_table(manager, [{type, bag}, 
                                  {ram_copies, [a@gin, b@skeppet]},
                                  {attributes, record_info(fields,
							   manager)}]),
    mnesia:create_table(at_dep,
                         [{ram_copies, [a@gin, b@skeppet]},
                          {attributes, record_info(fields, at_dep)}]),
    mnesia:create_table(in_proj,
                        [{type, bag}, 
                         {ram_copies, [a@gin, b@skeppet]},
                         {attributes, record_info(fields, in_proj)}]).</pre></div>        </li>
      </ul>
      <p>As illustrated, the two directories reside on different nodes,
        because <span class="code">/ldisc/scratch</span> (the "local" disc) exists on
        the two different nodes.</p>
      <p>By executing these commands, two Erlang nodes are configured to
        run the <span class="code">Company</span> database, and therefore, initialize the
        database. This is required only once when setting up. The next time
        the system is started,
        <span class="bold_code"><a href="../../man/mnesia.html#start-0">mnesia:start()</a></span>
        is called
        on both nodes, to initialize the system from disc.</p>
      <p>In a system of <span class="code">Mnesia</span> nodes, every node is aware of the
        current location of all tables. In this example, data is
        replicated on both nodes and functions that manipulate the
        data in the tables can be executed on either of the two nodes.
        Code that manipulate <span class="code">Mnesia</span> data behaves identically
        regardless of where the data resides.</p>
      <p>The function <span class="bold_code"><a href="../../man/mnesia.html#stop-0">mnesia:stop()</a></span>
        stops <span class="code">Mnesia</span> on the node
        where the function is executed. The functions <span class="code">mnesia:start/0</span>
        and <span class="code">mnesia:stop/0</span> work on the "local" <span class="code">Mnesia</span> system.
        No functions start or stop a set of nodes.</p>
    

    <h4>Startup Procedure</h4>
      
      <p>Start <span class="code">Mnesia</span> by calling the following function:</p>
      <div class="example"><pre>
          mnesia:start().</pre></div>
      <p>This function initiates the DBMS locally.</p>
      <p>The choice of configuration alters the location and load
        order of the tables. The alternatives are as follows:</p>
      <ul>
        <li>Tables that are only stored locally are initialized
         from the local <span class="code">Mnesia</span> directory.
        </li>
        <li>Replicated tables that reside locally
         as well as somewhere else are either initiated from disc or
         by copying the entire table from the other node, depending on
         which of the different replicas are the most recent. <span class="code">Mnesia</span>
         determines which of the tables are the most recent.
        </li>
        <li>Tables that reside on remote nodes are available to other
         nodes as soon as they are loaded.</li>
      </ul>
      <p>Table initialization is asynchronous. The function
        call <span class="bold_code"><a href="../../man/mnesia.html#start-0">mnesia:start()</a></span>
        returns the atom <span class="code">ok</span> and
        then starts to initialize the different tables. Depending on
        the size of the database, this can take some time, and the
        application programmer must wait for the tables that the
        application needs before they can be used. This is achieved by
        using the function
        <span class="bold_code"><a href="../../man/mnesia.html#wait_for_tables-2">mnesia:wait_for_tables(TabList, Timeout)</a></span>,
        which suspends the caller until all tables
        specified in <span class="code">TabList</span> are properly initiated.</p>
      <p>A problem can arise if a replicated table on one node is
        initiated, but <span class="code">Mnesia</span> deduces that another (remote)
        replica is more recent than the replica existing on the
        local node, and the initialization procedure does not proceed.
        In this situation, a call to
        <span class="bold_code"><a href="../../man/mnesia.html#wait_for_tables-2">mnesia:wait_for_tables/2</a></span>,
        suspends the caller until the
        remote node has initialized the table from its local disc and
        the node has copied the table over the network to the local node.</p>
      <p>However, this procedure can be time-consuming, the shortcut function
        <span class="bold_code"><a href="../../man/mnesia.html#force_load_table-1">mnesia:force_load_table(Tab)</a></span>
        loads all the tables from disc at a faster rate. The function forces
        tables to be loaded from disc regardless of the network
        situation.</p>
      <p>Thus, it can be assumed that if an application wants to use
        tables <span class="code">a</span> and <span class="code">b</span>, the application must perform
        some action similar to following before it can use the tables:</p>
      <div class="example"><pre>
          case mnesia:wait_for_tables([a, b], 20000) of
            {timeout,   RemainingTabs} -&gt;
              panic(RemainingTabs);
            ok -&gt;
              synced
          end.</pre></div>
      <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
        <p>When tables are forcefully loaded from the local disc,
          all operations that were performed on the replicated table
          while the local node was down, and the remote replica was
          alive, are lost. This can cause the database to become
          inconsistent.</p>
      </p></div>
</div>
      <p>If the startup procedure fails, the function
        <span class="bold_code"><a href="../../man/mnesia.html#start-0">mnesia:start()</a></span>
        returns the cryptic tuple
        <span class="code">{error,{shutdown, {mnesia_sup,start,[normal,[]]}}}</span>.
        To get more information about the start failure, use
        command-line arguments <span class="code">-boot start_sasl</span> as argument to
        the <span class="code">erl</span> script.</p>
    
  

  <h3><a name="id75532">4.4 
        Create Tables</a></h3>
    <a name="create_tables"></a>
    
    <p>The function
      <span class="bold_code"><a href="../../man/mnesia.html#create_table-2">mnesia:create_table(Name, ArgList)</a></span>
      creates tables. When executing this function, it returns one of
      the following responses:</p>
    <ul>
      <li>
<span class="code">{atomic, ok}</span> if the function executes successfully
      </li>
      <li>
<span class="code">{aborted, Reason}</span> if the function fails
      </li>
    </ul>
    <p>The function arguments are as follows:</p>
    <ul>
      <li>
<span class="code">Name</span> is the name of the table. It is
       usually the same name as the name of the records that
       constitute the table. For details, see <span class="code">record_name</span>.
      </li>
      <li>
        <p><span class="code">ArgList</span> is a list of <span class="code">{Key,Value}</span> tuples.
          The following arguments are valid:</p>
        <ul>
          <li>
            <p><span class="code">{type, Type}</span>, where <span class="code">Type</span> must be either of
              the atoms <span class="code">set</span>, <span class="code">ordered_set</span>, or <span class="code">bag</span>.
              Default is <span class="code">set</span>.</p>
            <p>Notice that currently <span class="code">ordered_set</span> is not
              supported for <span class="code">disc_only_copies</span> tables.</p>
            <p>A table of type
              <span class="code">set</span> or <span class="code">ordered_set</span> has either zero or
              one record per key, whereas a table of type <span class="code">bag</span> can
              have an arbitrary number of records per key. The key for
              each record is always the first attribute of the record.</p>
            <p>The following example illustrates the difference between
              type <span class="code">set</span> and <span class="code">bag</span>:</p>
            <div class="example"><pre>
 f() -&gt;
    F = fun() -&gt;
          mnesia:write({foo, 1, 2}),
          mnesia:write({foo, 1, 3}),
          mnesia:read({foo, 1})
        end,
    mnesia:transaction(F).</pre></div>
            <p>This transaction returns the list <span class="code">[{foo,1,3}]</span> if
              table <span class="code">foo</span> is of type <span class="code">set</span>. However, the list
              <span class="code">[{foo,1,2}, {foo,1,3}]</span> is returned if the table is
              of type <span class="code">bag</span>.</p>
            <p><span class="code">Mnesia</span> tables can never contain
              duplicates of the same record in the same table. Duplicate
              records have attributes with the same contents and key.</p>
          </li>
          <li>
            <p><span class="code">{disc_copies, NodeList}</span>, where <span class="code">NodeList</span> is a
              list of the nodes where this table is to reside on disc.</p>
            <p>Write operations to a table replica of type
              <span class="code">disc_copies</span> write data to the disc copy and
              to the RAM copy of the table.</p>
            <p>It is possible to have a
              replicated table of type <span class="code">disc_copies</span> on one node, and
              the same table stored as a different type on another node.
              Default is <span class="code">[]</span>. This arrangement is
              desirable if the following operational
              characteristics are required:</p>
            <ul>
              <li>Read operations must be fast and performed in RAM.</li>
              <li>All write operations must be written to persistent
               storage.</li>
            </ul>
            <p>A write operation on a <span class="code">disc_copies</span> table
              replica is performed in two steps. First the write
              operation is appended to a log file, then the actual
              operation is performed in RAM.</p>
          </li>
          <li>
            <p><span class="code">{ram_copies, NodeList}</span>, where <span class="code">NodeList</span> is a
              list of the nodes where this table is stored in RAM.
              Default is <span class="code">[node()]</span>. If the default value is used
              to create a table, it is located on the local node only.</p>
            <p>Table replicas of type
              <span class="code">ram_copies</span> can be dumped to disc with the function
              <span class="bold_code"><a href="../../man/mnesia.html#dump_tables-1">mnesia:dump_tables(TabList)</a></span>.</p>
          </li>
          <li>
<span class="code">{disc_only_copies, NodeList}</span>. These table
           replicas are stored on disc only and are therefore slower to
           access. However, a disc-only replica consumes less memory than
           a table replica of the other two storage types.
          </li>
          <li>
<p><span class="code">{index, AttributeNameList}</span>, where
           <span class="code">AttributeNameList</span> is a list of atoms specifying the
           names of the attributes <span class="code">Mnesia</span> is to build and maintain.
           An index table exists for every element in the list. The first
           field of a <span class="code">Mnesia</span> record is the key and thus need no
           extra index.</p>
           <p>The first field of a record is the second element of the
           tuple, which is the representation of the record.</p>
          </li>
          <li>
<p><span class="code">{snmp, SnmpStruct}</span>. <span class="code">SnmpStruct</span> is
           described in the
           <span class="bold_code"><a href="../../apps/snmp/index.html">SNMP</a></span> User's Guide.
           Basically, if this attribute is present in <span class="code">ArgList</span> of
           <span class="bold_code"><a href="../../man/mnesia.html#create_table-2">mnesia:create_table/2</a></span>,
           the table is immediately accessible the SNMP.</p>
           <p>It is easy to design applications that use SNMP to
           manipulate and control the system. <span class="code">Mnesia</span> provides a
           direct mapping between the logical tables that make up an SNMP
           control application and the physical data that makes up a
           <span class="code">Mnesia</span> table. The default value is <span class="code">[]</span>.</p>
          </li>
          <li>
<span class="code">{local_content, true}</span>. When an application needs a
           table whose contents is to be locally unique on each node,
           <span class="code">local_content</span> tables can be used. The name of the
           table is known to all <span class="code">Mnesia</span> nodes, but its contents is
           unique for each node. Access to this type of table must be
           done locally.</li>
          <li>
            <p><span class="code">{attributes, AtomList}</span> is a list of the attribute
              names for the records that are supposed to populate the
              table. Default is the list <span class="code">[key, val]</span>. The
              table must at least have one extra attribute besides the
              key. When accessing single attributes in a record, it is not
              recommended to hard code the attribute names as atoms. Use
              the construct <span class="code">record_info(fields, record_name)</span>
              instead.</p>
            <p>The expression
              <span class="code">record_info(fields, record_name)</span> is processed by the
              Erlang preprocessor and returns a list of the
              record field names. With the record definition
              <span class="code">-record(foo, {x,y,z}).</span>, the expression
              <span class="code">record_info(fields,foo)</span> is expanded to the list
              <span class="code">[x,y,z]</span>. It is therefore possible for you to provide
              the attribute names or to use the <span class="code">record_info/2</span>
              notation.</p>
            <p>It is recommended to use the <span class="code">record_info/2</span> notation,
              as it becomes easier to maintain the program and the program
              becomes more robust with regards to future record changes.</p>
          </li>
          <li>
            <p><span class="code">{record_name, Atom}</span> specifies the common name of
              all records stored in the table. All records stored in
              the table must have this name as their first element.
              <span class="code">record_name</span> defaults to the name of the table.
              For more information, see
              <span class="bold_code"><a href="Mnesia_chap4.html#recordnames_tablenames">Record Names versus Table Names</a></span>.</p>
          </li>
        </ul>
      </li>
    </ul>
    <p>As an example, consider the following record definition:</p>
    <div class="example"><pre>
      -record(funky, {x, y}).</pre></div>
    <p>The following call would create a table that is replicated on two
      nodes, has an extra index on attribute <span class="code">y</span>, and is of type
      <span class="code">bag</span>.</p>
    <div class="example"><pre>
      mnesia:create_table(funky, [{disc_copies, [N1, N2]}, {index,
      [y]}, {type, bag}, {attributes, record_info(fields, funky)}]).</pre></div>
    <p>Whereas a call to the following default code values would return
      a table with a RAM copy on the local node, no extra indexes, and the
      attributes defaulted to the list <span class="code">[key,val]</span>.</p>
    <div class="example"><pre>
mnesia:create_table(stuff, [])</pre></div>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
