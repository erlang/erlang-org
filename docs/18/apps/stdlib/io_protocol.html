<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- The Erlang I/O-protocol</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="index.html">Reference Manual</a><br><a href="release_notes.html">Release Notes</a><br><a href="stdlib.pdf">PDF</a><br><a href="../../index.html">Top</a></small><p><strong>STDLIB</strong><br><strong>User's Guide</strong><br><small>Version 2.8</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="loadscrollpos" title="The Erlang I/O-protocol" expanded="true">The Erlang I/O-protocol<ul>
<li><a href="io_protocol.html">
              Top of chapter
            </a></li>
<li title="Protocol Basics"><a href="io_protocol.html#id65264">Protocol Basics</a></li>
<li title="Output Requests"><a href="io_protocol.html#id56691">Output Requests</a></li>
<li title="Input Requests"><a href="io_protocol.html#id59193">Input Requests</a></li>
<li title="I/O-server Modes"><a href="io_protocol.html#id62352">I/O-server Modes</a></li>
<li title="Multiple I/O Requests"><a href="io_protocol.html#id60723">Multiple I/O Requests</a></li>
<li title="Optional I/O Requests"><a href="io_protocol.html#id61935">Optional I/O Requests</a></li>
<li title="Unimplemented Request Types"><a href="io_protocol.html#id56612">Unimplemented Request Types</a></li>
<li title="An Annotated and Working Example I/O Server"><a href="io_protocol.html#id56644">An Annotated and Working Example I/O Server</a></li>
</ul>
</li>
<li id="no" title="Using Unicode in Erlang" expanded="false">Using Unicode in Erlang<ul>
<li><a href="unicode_usage.html">
              Top of chapter
            </a></li>
<li title="Unicode Implementation"><a href="unicode_usage.html#id61067">Unicode Implementation</a></li>
<li title="Understanding Unicode"><a href="unicode_usage.html#id60451">Understanding Unicode</a></li>
<li title="What Unicode Is"><a href="unicode_usage.html#id60504">What Unicode Is</a></li>
<li title="Areas of Unicode Support"><a href="unicode_usage.html#id60651">Areas of Unicode Support</a></li>
<li title="Standard Unicode Representation"><a href="unicode_usage.html#id62530">Standard Unicode Representation</a></li>
<li title="Basic Language Support"><a href="unicode_usage.html#id62637">Basic Language Support</a></li>
<li title="The Interactive Shell"><a href="unicode_usage.html#id65129">The Interactive Shell</a></li>
<li title="Unicode File Names"><a href="unicode_usage.html#id64295">Unicode File Names</a></li>
<li title="Unicode in Environment and Parameters"><a href="unicode_usage.html#id61215">Unicode in Environment and Parameters</a></li>
<li title="Unicode-aware Modules"><a href="unicode_usage.html#id61272">Unicode-aware Modules</a></li>
<li title="Unicode Data in Files"><a href="unicode_usage.html#id61482">Unicode Data in Files</a></li>
<li title="Summary of Options"><a href="unicode_usage.html#id61625">Summary of Options</a></li>
<li title="Recipes"><a href="unicode_usage.html#id67857">Recipes</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>1 The Erlang I/O-protocol</h1>
  


<p>The I/O-protocol in Erlang specifies a way for a client to communicate
with an I/O server and vice versa. The I/O server is a process that handles
the requests and performs the requested task on e.g. an IO device. The
client is any Erlang process wishing to read or write data from/to the
IO device.</p> 

<p>The common I/O-protocol has been present in OTP since the
beginning, but has been fairly undocumented and has also somewhat
evolved over the years. In an addendum to Robert Virdings rationale
the original I/O-protocol is described. This document describes the
current I/O-protocol.</p>

<p>The original I/O-protocol was simple and flexible. Demands for spacial
and execution time efficiency has triggered extensions to the protocol
over the years, making the protocol larger and somewhat less easy to
implement than the original. It can certainly be argued that the
current protocol is too complex, but this text describes how it looks
today, not how it should have looked.</p>

<p>The basic ideas from the original protocol still hold. The I/O server
and client communicate with one single, rather simplistic protocol and
no server state is ever present in the client. Any I/O server can be
used together with any client code and client code need not be aware
of the actual IO device the I/O server communicates with.</p>

<h3><a name="id65264">1.1 
        Protocol Basics</a></h3>


<p>As described in Robert's paper, I/O servers and clients communicate using
<span class="code">io_request</span>/<span class="code">io_reply</span> tuples as follows:</p>

<p><strong>{io_request, From, ReplyAs, Request}</strong><br>
<strong>{io_reply, ReplyAs, Reply}</strong></p>

<p>The client sends an <span class="code">io_request</span> tuple to the I/O server and
the server eventually sends a corresponding <span class="code">io_reply</span> tuple.</p>

<ul>
<li>
<span class="code">From</span> is the <span class="code">pid()</span> of the client, the process which
the I/O server sends the IO reply to.</li>

<li>
<span class="code">ReplyAs</span> can be any datum and is returned in the corresponding
<span class="code">io_reply</span>. The <span class="bold_code"><a href="../../man/io.html">io</a></span> module monitors
the I/O server, and uses the monitor reference as the <span class="code">ReplyAs</span> datum.
A more complicated client
could have several outstanding I/O requests to the same I/O server and
would then use different references (or something else) to differentiate among
the incoming IO replies. The <span class="code">ReplyAs</span> element should be considered
opaque by the I/O server. Note that the <span class="code">pid()</span> of the I/O server is not
explicitly present in the <span class="code">io_reply</span> tuple. The reply can be sent from any
process, not necessarily the actual I/O server. The <span class="code">ReplyAs</span> element is
the only thing that connects one I/O request with an I/O-reply.</li>

<li>
<span class="code">Request</span> and <span class="code">Reply</span> are described below.</li>
</ul>

<p>When an I/O server receives an <span class="code">io_request</span> tuple, it acts upon the actual
<span class="code">Request</span> part and eventually sends an <span class="code">io_reply</span> tuple with the corresponding
<span class="code">Reply</span> part.</p> 

<h3><a name="id56691">1.2 
        Output Requests</a></h3>


<p>To output characters on an IO device, the following <span class="code">Request</span>s exist:</p>

<p>
<strong>{put_chars, Encoding, Characters}</strong><br>
<strong>{put_chars, Encoding, Module, Function, Args}</strong>
</p>
<ul>
<li>
<span class="code">Encoding</span> is either <span class="code">unicode</span> or <span class="code">latin1</span>, meaning that the
  characters are (in case of binaries) encoded as either UTF-8 or
  ISO-latin-1 (pure bytes). A well behaved I/O server should also
  return error if list elements contain integers &gt; 255 when
  <span class="code">Encoding</span> is set to <span class="code">latin1</span>. Note that this does not in any way tell
  how characters should be put on the actual IO device or how the
  I/O server should handle them. Different I/O servers may handle the
  characters however they want, this simply tells the I/O server which
  format the data is expected to have. In the <span class="code">Module</span>/<span class="code">Function</span>/<span class="code">Args</span>
  case, <span class="code">Encoding</span> tells which format the designated function
  produces. Note that byte-oriented data is simplest sent using the ISO-latin-1
  encoding.</li>

<li>Characters are the data to be put on the IO device. If <span class="code">Encoding</span> is
  <span class="code">latin1</span>, this is an <span class="code">iolist()</span>. If <span class="code">Encoding</span> is <span class="code">unicode</span>, this is an
  Erlang standard mixed Unicode list (one integer in a list per
  character, characters in binaries represented as UTF-8).</li>

<li>
<span class="code">Module</span>, <span class="code">Function</span>, and <span class="code">Args</span> denote a function which will be called to
  produce the data (like <span class="code">io_lib:format/2</span>). <span class="code">Args</span> is a list of arguments
  to the function. The function should produce data in the given
  <span class="code">Encoding</span>. The I/O server should call the function as
  <span class="code">apply(Mod, Func, Args)</span> and will put the returned data on the IO device as if it was sent
  in a <span class="code">{put_chars, Encoding, Characters}</span> request. If the function
  returns anything else than a binary or list or throws an exception,
  an error should be sent back to the client.</li>
</ul>

<p>The I/O server replies to the client with an <span class="code">io_reply</span> tuple where the <span class="code">Reply</span>
element is one of:</p>
<p>
<strong>ok</strong><br>
<strong>{error, Error}</strong>
</p>

<ul>
<li>
<span class="code">Error</span> describes the error to the client, which may do whatever
  it wants with it. The Erlang <span class="bold_code"><a href="../../man/io.html">io</a></span>
  module typically returns it as is.</li>
</ul>

<p>For backward compatibility the following <span class="code">Request</span>s should also be
handled by an I/O server (these requests should not be present after
R15B of OTP):</p>
<p>
<strong>{put_chars, Characters}</strong><br>
<strong>{put_chars, Module, Function, Args}</strong>
</p>

<p>These should behave as <span class="code">{put_chars, latin1, Characters}</span> and
<span class="code">{put_chars, latin1, Module, Function, Args}</span> respectively. </p>

<h3><a name="id59193">1.3 
        Input Requests</a></h3>


<p>To read characters from an IO device, the following <span class="code">Request</span>s exist:</p>

<p><strong>{get_until, Encoding, Prompt, Module, Function, ExtraArgs}</strong></p>

<ul>
<li>
<span class="code">Encoding</span> denotes how data is to be sent back to the client and
  what data is sent to the function denoted by
  <span class="code">Module</span>/<span class="code">Function</span>/<span class="code">ExtraArgs</span>. If the function supplied returns data as a
  list, the data is converted to this encoding. If however the
  function supplied returns data in some other format, no conversion
  can be done and it is up to the client supplied function to return
  data in a proper way. If <span class="code">Encoding</span> is <span class="code">latin1</span>, lists of integers
  0..255 or binaries containing plain bytes are sent back to the
  client when possible; if <span class="code">Encoding</span> is <span class="code">unicode</span>, lists with integers in
  the whole Unicode range or binaries encoded in UTF-8 are sent to the
  client. The user supplied function will always see lists of integers, never
  binaries, but the list may contain numbers &gt; 255 if the <span class="code">Encoding</span> is
  <span class="code">unicode</span>.</li>

<li>
<span class="code">Prompt</span> is a list of characters (not mixed, no binaries) or an atom
  to be output as a prompt for input on the IO device. <span class="code">Prompt</span> is
  often ignored by the I/O server and if set to <span class="code">''</span> it should always
  be ignored (and result in nothing being written to the IO device).</li>

<li>
<p><span class="code">Module</span>, <span class="code">Function</span>, and <span class="code">ExtraArgs</span> denote a function and arguments to
  determine when enough data is written. The function should take two
  additional arguments, the last state, and a list of characters. The
  function should return one of:</p>
<p>
<strong>{done, Result, RestChars}</strong><br>
<strong>{more, Continuation}</strong>
</p>
  <p>The <span class="code">Result</span> can be any Erlang term, but if it is a <span class="code">list()</span>, the
  I/O server may convert it to a <span class="code">binary()</span> of appropriate format before
  returning it to the client, if the I/O server is set in binary mode (see
  below).</p>

  <p>The function will be called with the data the I/O server finds on
  its IO device, returning <span class="code">{done, Result, RestChars}</span> when enough data is
  read (in which case <span class="code">Result</span> is sent to the client and <span class="code">RestChars</span> is
  kept in the I/O server as a buffer for subsequent input) or
  <span class="code">{more, Continuation}</span>, indicating that more characters are needed to
  complete the request. The <span class="code">Continuation</span> will be sent as the state in
  subsequent calls to the function when more characters are
  available. When no more characters are available, the function
  shall return <span class="code">{done, eof, Rest}</span>.
  The initial state is the empty list and the data when an
  end of file is reached on the IO device is the atom <span class="code">eof</span>. An emulation
  of the <span class="code">get_line</span> request could be (inefficiently) implemented using
  the following functions:</p>
<div class="example"><pre>
-module(demo).
-export([until_newline/3, get_line/1]).

until_newline(_ThisFar,eof,_MyStopCharacter) -&gt;
    {done,eof,[]};
until_newline(ThisFar,CharList,MyStopCharacter) -&gt;
    case
        lists:splitwith(fun(X) -&gt; X =/= MyStopCharacter end,  CharList)
    of
	{L,[]} -&gt;
            {more,ThisFar++L};
	{L2,[MyStopCharacter|Rest]} -&gt;
	    {done,ThisFar++L2++[MyStopCharacter],Rest}
    end.

get_line(IoServer) -&gt;
    IoServer ! {io_request,
                self(),
                IoServer,
                {get_until, unicode, '', ?MODULE, until_newline, [$\n]}},
    receive
        {io_reply, IoServer, Data} -&gt;
	    Data
    end.
</pre></div>
 <p>Note especially that the last element in the <span class="code">Request</span> tuple (<span class="code">[$\n]</span>)
  is appended to the argument list when the function is called. The
  function should be called like 
  <span class="code">apply(Module, Function, [ State, Data | ExtraArgs ])</span> by the I/O server</p>
</li>
</ul>

<p>A fixed number of characters is requested using this <span class="code">Request</span>:</p>
<p>
<strong>{get_chars, Encoding, Prompt, N}</strong>
</p>

<ul>
<li>
<span class="code">Encoding</span> and <span class="code">Prompt</span> as for <span class="code">get_until</span>.</li>

<li>
<span class="code">N</span> is the number of characters to be read from the IO device.</li>
</ul>

<p>A single line (like in the example above) is requested with this <span class="code">Request</span>:</p>
<p>
<strong>{get_line, Encoding, Prompt}</strong>
</p>

<ul>
<li>
<span class="code">Encoding</span> and <span class="code">Prompt</span> as above.</li>
</ul>

<p>Obviously, the <span class="code">get_chars</span> and <span class="code">get_line</span> could be implemented with the
<span class="code">get_until</span> request (and indeed they were originally), but demands for
efficiency has made these additions necessary.</p>

<p>The I/O server replies to the client with an <span class="code">io_reply</span> tuple where the <span class="code">Reply</span>
element is one of:</p>
<p>
<strong>Data</strong><br>
<strong>eof</strong><br>
<strong>{error, Error}</strong>
</p>

<ul>
<li>
<span class="code">Data</span> is the characters read, in either list or binary form
  (depending on the I/O server mode, see below).</li>
<li>
<span class="code">Error</span> describes the error to the client, which may do whatever it
  wants with it. The Erlang <span class="bold_code"><a href="../../man/io.html">io</a></span>
  module typically returns it as is.</li>
<li>
<span class="code">eof</span> is returned when input end is reached and no more data is
available to the client process.</li>
</ul>

<p>For backward compatibility the following <span class="code">Request</span>s should also be
handled by an I/O server (these reqeusts should not be present after
R15B of OTP):</p>

<p>
<strong>{get_until, Prompt, Module, Function, ExtraArgs}</strong><br>
<strong>{get_chars, Prompt, N}</strong><br>
<strong>{get_line, Prompt}</strong><br>
</p>

<p>These should behave as <span class="code">{get_until, latin1, Prompt, Module, Function,
ExtraArgs}</span>, <span class="code">{get_chars, latin1, Prompt, N}</span> and <span class="code">{get_line, latin1,
Prompt}</span> respectively.</p>

<h3><a name="id62352">1.4 
        I/O-server Modes</a></h3>


<p>Demands for efficiency when reading data from an I/O server has not
only lead to the addition of the <span class="code">get_line</span> and <span class="code">get_chars</span> requests, but
has also added the concept of I/O server options. No options are
mandatory to implement, but all I/O servers in the Erlang standard
libraries honor the <span class="code">binary</span> option, which allows the <span class="code">Data</span> element of the
<span class="code">io_reply</span> tuple to be a binary instead of a list <strong>when possible</strong>. 
If the data is sent as a binary, Unicode data will be sent in the 
standard Erlang Unicode
format, i.e. UTF-8 (note that the function of the <span class="code">get_until</span> request still gets
list data regardless of the I/O server mode).</p>

<p>Note that i.e. the <span class="code">get_until</span> request allows for a function with the data specified as always being a list. Also the return value data from such a function can be of any type (as is indeed the case when an <span class="code">io:fread</span> request is sent to an I/O server). The client has to be prepared for data received as answers to those requests to be in a variety of forms, but the I/O server should convert the results to binaries whenever possible (i.e. when the function supplied to <span class="code">get_until</span> actually returns a list). The example shown later in this text does just that.</p>

<p>An I/O-server in binary mode will affect the data sent to the client,
so that it has to be able to handle binary data. For convenience, it
is possible to set and retrieve the modes of an I/O server using the
following I/O requests:</p>

<p>
<strong>{setopts, Opts}</strong>
</p>


<ul>
<li>
<span class="code">Opts</span> is a list of options in the format recognized by <span class="bold_code"><a href="../../man/proplists.html">proplists</a></span> (and
  of course by the I/O server itself).</li>
</ul>
<p>As an example, the I/O server for the interactive shell (in <span class="code">group.erl</span>)
understands the following options:</p>
<p>
<strong>{binary, boolean()}</strong> (or <strong>binary</strong>/<strong>list</strong>)<br>
<strong>{echo, boolean()}</strong><br>
<strong>{expand_fun, fun()}</strong><br>
<strong>{encoding, unicode/latin1}</strong> (or <strong>unicode</strong>/<strong>latin1</strong>)
</p>

<p>- of which the <span class="code">binary</span> and <span class="code">encoding</span> options are common for all
I/O servers in OTP, while <span class="code">echo</span> and <span class="code">expand</span> are valid only for this
I/O server. It is worth noting that the <span class="code">unicode</span> option notifies how
characters are actually put on the physical IO device, i.e. if the
terminal per se is Unicode aware, it does not affect how characters
are sent in the I/O-protocol, where each request contains encoding
information for the provided or returned data.</p>

<p>The I/O server should send one of the following as <span class="code">Reply</span>:</p>
<p>
<strong>ok</strong><br>
<strong>{error, Error}</strong>
</p>

<p>An error (preferably <span class="code">enotsup</span>) is to be expected if the option is
not supported by the I/O server (like if an <span class="code">echo</span> option is sent in a
<span class="code">setopts</span> request to a plain file).</p>

<p>To retrieve options, this request is used:</p>
<p>
<strong>getopts</strong>
</p>

<p>The <span class="code">getopts</span> request asks for a complete list of all options
supported by the I/O server as well as their current values.</p>

<p>The I/O server replies:</p>
<p>
<strong>OptList</strong><br>
<strong>{error, Error}</strong>
</p>

<ul>
<li>
<span class="code">OptList</span> is a list of tuples <span class="code">{Option, Value}</span> where <span class="code">Option</span> is always
  an atom.</li>
</ul>

<h3><a name="id60723">1.5 
        Multiple I/O Requests</a></h3>


<p>The <span class="code">Request</span> element can in itself contain several <span class="code">Request</span>s by using
the following format:</p>
<p>
<strong>{requests, Requests}</strong>
</p>
<ul>
<li>
<span class="code">Requests</span> is a list of valid <span class="code">io_request</span> tuples for the protocol, they
  shall be executed in the order in which they appear in the list and
  the execution should continue until one of the requests result in an
  error or the list is consumed. The result of the last request is
  sent back to the client.</li>
</ul>

<p>The I/O server can for a list of requests send any of the valid results in
the reply:</p>

<p>
<strong>ok</strong><br>
<strong>{ok, Data}</strong><br>
<strong>{ok, Options}</strong><br>
<strong>{error, Error}</strong>
</p>
<p>- depending on the actual requests in the list.</p>

<h3><a name="id61935">1.6 
        Optional I/O Requests</a></h3>


<p>The following I/O request is optional to implement and a client
should be prepared for an error return:</p>
<p>
<strong>{get_geometry, Geometry}</strong>
</p>
<ul>
<li>
<span class="code">Geometry</span> is either the atom <span class="code">rows</span> or the atom <span class="code">columns</span>.</li>
</ul>
<p>The I/O server should send the <span class="code">Reply</span> as:</p>
<p>
<strong>{ok, N}</strong><br>
<strong>{error, Error}</strong>
</p>

<ul>
<li>
<span class="code">N</span> is the number of character rows or columns the IO device has, if
  applicable to the IO device the I/O server handles, otherwise <span class="code">{error,
  enotsup}</span> is a good answer.</li>
</ul>

<h3><a name="id56612">1.7 
        Unimplemented Request Types</a></h3>


<p>If an I/O server encounters a request it does not recognize (i.e. the
<span class="code">io_request</span> tuple is in the expected format, but the actual <span class="code">Request</span> is
unknown), the I/O server should send a valid reply with the error tuple:</p>
<p>
<strong>{error, request}</strong>
</p>

<p>This makes it possible to extend the protocol with optional requests
and for the clients to be somewhat backwards compatible.</p>

<h3><a name="id56644">1.8 
        An Annotated and Working Example I/O Server</a></h3>


<p>An I/O server is any process capable of handling the I/O protocol. There is
no generic I/O server behavior, but could well be. The framework is
simple enough, a process handling incoming requests, usually both
I/O-requests and other IO device-specific requests (for i.e. positioning,
closing etc.).</p>

<p>Our example I/O server stores characters in an ETS table, making up a
fairly crude ram-file (it is probably not useful, but working).</p>

<p>The module begins with the usual directives, a function to start the
I/O server and a main loop handling the requests:</p> 

<div class="example"><pre>
-module(ets_io_server).

-export([start_link/0, init/0, loop/1, until_newline/3, until_enough/3]).

-define(CHARS_PER_REC, 10).

-record(state, {
	  table,
	  position, % absolute
	  mode % binary | list
	 }).

start_link() -&gt;
    spawn_link(?MODULE,init,[]).

init() -&gt;
    Table = ets:new(noname,[ordered_set]),
    ?MODULE:loop(#state{table = Table, position = 0, mode=list}).

loop(State) -&gt;
    receive
	{io_request, From, ReplyAs, Request} -&gt;
	    case request(Request,State) of
		{Tag, Reply, NewState} when Tag =:= ok; Tag =:= error -&gt;
		    reply(From, ReplyAs, Reply),
		    ?MODULE:loop(NewState);
		{stop, Reply, _NewState} -&gt;
		    reply(From, ReplyAs, Reply),
		    exit(Reply)
	    end;
	%% Private message
	{From, rewind} -&gt;
	    From ! {self(), ok},
	    ?MODULE:loop(State#state{position = 0});
	_Unknown -&gt;
	    ?MODULE:loop(State)
    end.
</pre></div>

<p>The main loop receives messages from the client (which might be using
the <span class="bold_code"><a href="../../man/io.html">io</a></span> module to send requests).
For each request the function
<span class="code">request/2</span> is called and a reply is eventually sent using the <span class="code">reply/3</span>
function.</p>

<p>The "private" message <span class="code">{From, rewind}</span> results in the
current position in the pseudo-file to be reset to 0 (the beginning of
the "file"). This is a typical example of IO device-specific
messages not being part of the I/O-protocol. It is usually a bad idea
to embed such private messages in <span class="code">io_request</span> tuples, as that might be
confusing to the reader.</p>

<p>Let us look at the reply function first...</p>

<div class="example"><pre>

reply(From, ReplyAs, Reply) -&gt;
    From ! {io_reply, ReplyAs, Reply}.

</pre></div>

<p>Simple enough, it sends the <span class="code">io_reply</span> tuple back to the client,
providing the <span class="code">ReplyAs</span> element received in the request along with the
result of the request, as described above.</p>

<p>Now look at the different requests we need to handle. First the
requests for writing characters:</p>

<div class="example"><pre>
request({put_chars, Encoding, Chars}, State) -&gt;
    put_chars(unicode:characters_to_list(Chars,Encoding),State);
request({put_chars, Encoding, Module, Function, Args}, State) -&gt;
    try
	request({put_chars, Encoding, apply(Module, Function, Args)}, State)
    catch
	_:_ -&gt;
	    {error, {error,Function}, State}
    end;
</pre></div>

<p>The <span class="code">Encoding</span> tells us how the characters in the request are
represented. We want to store the characters as lists in the
ETS table, so we convert them to lists using the
<span class="bold_code"><a href="../../man/unicode.html#characters_to_list-2"><span class="code">unicode:characters_to_list/2</span></a></span> function. The conversion function
conveniently accepts the encoding types <span class="code">unicode</span> or <span class="code">latin1</span>, so we can
use <span class="code">Encoding</span> directly.</p>

<p>When <span class="code">Module</span>, <span class="code">Function</span> and <span class="code">Arguments</span> are provided, we simply apply it
and do the same thing with the result as if the data was provided
directly.</p>

<p>Let us handle the requests for retrieving data too:</p>

<div class="example"><pre>
request({get_until, Encoding, _Prompt, M, F, As}, State) -&gt;
    get_until(Encoding, M, F, As, State);
request({get_chars, Encoding, _Prompt, N}, State) -&gt;
    %% To simplify the code, get_chars is implemented using get_until
    get_until(Encoding, ?MODULE, until_enough, [N], State);
request({get_line, Encoding, _Prompt}, State) -&gt;
    %% To simplify the code, get_line is implemented using get_until
    get_until(Encoding, ?MODULE, until_newline, [$\n], State);
</pre></div>

<p>Here we have cheated a little by more or less only implementing
<span class="code">get_until</span> and using internal helpers to implement <span class="code">get_chars</span> and
<span class="code">get_line</span>. In production code, this might be too inefficient, but that
of course depends on the frequency of the different requests. Before
we start actually implementing the functions <span class="code">put_chars/2</span> and
<span class="code">get_until/5</span>, let us look into the few remaining requests:</p>

<div class="example"><pre>
request({get_geometry,_}, State) -&gt;
    {error, {error,enotsup}, State};
request({setopts, Opts}, State) -&gt;
    setopts(Opts, State);
request(getopts, State) -&gt;
    getopts(State);
request({requests, Reqs}, State) -&gt;
     multi_request(Reqs, {ok, ok, State});
</pre></div>

<p>The <span class="code">get_geometry</span> request has no meaning for this I/O server, so the
reply will be <span class="code">{error, enotsup}</span>. The only option we handle is the
<span class="code">binary</span>/<span class="code">list</span> option, which is done in separate functions.</p>

<p>The multi-request tag (<span class="code">requests</span>) is handled in a separate loop
function applying the requests in the list one after another,
returning the last result.</p>

<p>What is left is to handle backward compatibility and the <span class="bold_code"><a href="../../man/file.html">file</a></span> module
(which uses the old requests until backward compatibility with pre-R13
nodes is no longer needed). Note that the I/O server will not work with
a simple <span class="code">file:write/2</span> if these are not added:</p>

<div class="example"><pre>
request({put_chars,Chars}, State) -&gt;
    request({put_chars,latin1,Chars}, State);
request({put_chars,M,F,As}, State) -&gt;
    request({put_chars,latin1,M,F,As}, State);
request({get_chars,Prompt,N}, State) -&gt;
    request({get_chars,latin1,Prompt,N}, State);
request({get_line,Prompt}, State) -&gt;
    request({get_line,latin1,Prompt}, State);
request({get_until, Prompt,M,F,As}, State) -&gt;
    request({get_until,latin1,Prompt,M,F,As}, State);
</pre></div>

<p>OK, what is left now is to return <span class="code">{error, request}</span> if the request is
not recognized:</p>

<div class="example"><pre>
request(_Other, State) -&gt;
    {error, {error, request}, State}.
</pre></div>

<p>Let us move further and actually handle the different requests, first
the fairly generic multi-request type:</p>

<div class="example"><pre>
multi_request([R|Rs], {ok, _Res, State}) -&gt;
    multi_request(Rs, request(R, State));
multi_request([_|_], Error) -&gt;
    Error;
multi_request([], Result) -&gt;
    Result.
</pre></div>

<p>We loop through the requests one at the time, stopping when we either
encounter an error or the list is exhausted. The last return value is
sent back to the client (it is first returned to the main loop and then
sent back by the function <span class="code">io_reply</span>).</p>

<p>The <span class="code">getopts</span> and <span class="code">setopts</span> requests are also simple to handle, we just
change or read our state record:</p>

<div class="example"><pre>
setopts(Opts0,State) -&gt;
    Opts = proplists:unfold(
	     proplists:substitute_negations(
	       [{list,binary}], 
	       Opts0)),
    case check_valid_opts(Opts) of
	true -&gt;
	        case proplists:get_value(binary, Opts) of
		    true -&gt;
			{ok,ok,State#state{mode=binary}};
		    false -&gt;
			{ok,ok,State#state{mode=binary}};
		    _ -&gt;
			{ok,ok,State}
		end;
	false -&gt;
	    {error,{error,enotsup},State}
    end.
check_valid_opts([]) -&gt;
    true;
check_valid_opts([{binary,Bool}|T]) when is_boolean(Bool) -&gt;
    check_valid_opts(T);
check_valid_opts(_) -&gt;
    false.

getopts(#state{mode=M} = S) -&gt;
    {ok,[{binary, case M of
		      binary -&gt;
			  true;
		      _ -&gt;
			  false
		  end}],S}.
</pre></div>

<p>As a convention, all I/O servers handle both <span class="code">{setopts, [binary]}</span>,
<span class="code">{setopts, [list]}</span> and <span class="code">{setopts,[{binary, boolean()}]}</span>, hence the trick
with <span class="code">proplists:substitute_negations/2</span> and <span class="code">proplists:unfold/1</span>. If
invalid options are sent to us, we send <span class="code">{error, enotsup}</span> back to the
client.</p>

<p>The <span class="code">getopts</span> request should return a list of <span class="code">{Option, Value}</span> tuples,
which has the twofold function of providing both the current values
and the available options of this I/O server. We have only one option,
and hence return that.</p>

<p>So far our I/O server has been fairly generic (except for the <span class="code">rewind</span>
request handled in the main loop and the creation of an ETS table). 
Most I/O servers contain code similar to the one above.</p>

<p>To make the example runnable, we now start implementing the actual
reading and writing of the data to/from the ETS table. First the
<span class="code">put_chars/3</span> function:</p>

<div class="example"><pre>
put_chars(Chars, #state{table = T, position = P} = State) -&gt;
    R = P div ?CHARS_PER_REC,
    C = P rem ?CHARS_PER_REC,
    [ apply_update(T,U) || U &lt;- split_data(Chars, R, C) ],
    {ok, ok, State#state{position = (P + length(Chars))}}.
</pre></div>

<p>We already have the data as (Unicode) lists and therefore just split
the list in runs of a predefined size and put each run in the
table at the current position (and forward). The functions
<span class="code">split_data/3</span> and <span class="code">apply_update/2</span> are implemented below.</p>

<p>Now we want to read data from the table. The <span class="code">get_until/5</span> function reads
data and applies the function until it says it is done. The result is
sent back to the client:</p>

<div class="example"><pre>
get_until(Encoding, Mod, Func, As, 
	  #state{position = P, mode = M, table = T} = State) -&gt;
    case get_loop(Mod,Func,As,T,P,[]) of
	{done,Data,_,NewP} when is_binary(Data); is_list(Data) -&gt;
	    if
		M =:= binary -&gt; 
		    {ok, 
		     unicode:characters_to_binary(Data, unicode, Encoding),
		     State#state{position = NewP}};
		true -&gt;
		    case check(Encoding, 
		               unicode:characters_to_list(Data, unicode))
                    of
			{error, _} = E -&gt;
			    {error, E, State};
			List -&gt;
			    {ok, List,
			     State#state{position = NewP}}
		    end
	    end;
	{done,Data,_,NewP} -&gt;
	    {ok, Data, State#state{position = NewP}};
	Error -&gt;
	    {error, Error, State}
    end.

get_loop(M,F,A,T,P,C) -&gt;
    {NewP,L} = get(P,T),
    case catch apply(M,F,[C,L|A]) of
	{done, List, Rest} -&gt;
	    {done, List, [], NewP - length(Rest)};
	{more, NewC} -&gt;
	    get_loop(M,F,A,T,NewP,NewC);
	_ -&gt;
	    {error,F}
    end.
</pre></div>

<p>Here we also handle the mode (<span class="code">binary</span> or <span class="code">list</span>) that can be set by
the <span class="code">setopts</span> request. By default, all OTP I/O servers send data back to
the client as lists, but switching mode to <span class="code">binary</span> might increase
efficiency if the I/O server handles it in an appropriate way. The
implementation of <span class="code">get_until</span> is hard to get efficient as the supplied
function is defined to take lists as arguments, but <span class="code">get_chars</span> and
<span class="code">get_line</span> can be optimized for binary mode. This example does not
optimize anything however. It is important though that the returned
data is of the right type depending on the options set, so we convert
the lists to binaries in the correct encoding <strong>if possible</strong>
before returning. The function supplied in the <span class="code">get_until</span> request tuple may,
as its final result return anything, so only functions actually
returning lists can get them converted to binaries. If the request
contained the encoding tag <span class="code">unicode</span>, the lists can contain all Unicode
codepoints and the binaries should be in UTF-8, if the encoding tag
was <span class="code">latin1</span>, the client should only get characters in the range
0..255. The function <span class="code">check/2</span> takes care of not returning arbitrary
Unicode codepoints in lists if the encoding was given as <span class="code">latin1</span>. If
the function did not return a list, the check cannot be performed and
the result will be that of the supplied function untouched.</p>

<p>Now we are more or less done. We implement the utility functions below
to actually manipulate the table:</p>

<div class="example"><pre>
check(unicode, List) -&gt;
    List;
check(latin1, List) -&gt;
    try 
	[ throw(not_unicode) || X &lt;- List,
				X &gt; 255 ],
	List
    catch
	throw:_ -&gt;
	    {error,{cannot_convert, unicode, latin1}}
    end.
</pre></div>

<p>The function check takes care of providing an error tuple if Unicode
codepoints above 255 is to be returned if the client requested
latin1.</p>

<p>The two functions <span class="code">until_newline/3</span> and <span class="code">until_enough/3</span> are helpers used 
together with the <span class="code">get_until/5</span> function to implement <span class="code">get_chars</span> and
<span class="code">get_line</span> (inefficiently):</p>
	
<div class="example"><pre>
until_newline([],eof,_MyStopCharacter) -&gt;
    {done,eof,[]};
until_newline(ThisFar,eof,_MyStopCharacter) -&gt;
    {done,ThisFar,[]};
until_newline(ThisFar,CharList,MyStopCharacter) -&gt;
    case
        lists:splitwith(fun(X) -&gt; X =/= MyStopCharacter end,  CharList)
    of
	{L,[]} -&gt;
            {more,ThisFar++L};
	{L2,[MyStopCharacter|Rest]} -&gt;
	    {done,ThisFar++L2++[MyStopCharacter],Rest}
    end.

until_enough([],eof,_N) -&gt;
    {done,eof,[]};
until_enough(ThisFar,eof,_N) -&gt;
    {done,ThisFar,[]};
until_enough(ThisFar,CharList,N) 
  when length(ThisFar) + length(CharList) &gt;= N -&gt;
    {Res,Rest} = my_split(N,ThisFar ++ CharList, []),
    {done,Res,Rest};
until_enough(ThisFar,CharList,_N) -&gt;
    {more,ThisFar++CharList}. 
</pre></div>

<p>As can be seen, the functions above are just the type of functions
that should be provided in <span class="code">get_until</span> requests.</p>

<p>Now we only need to read and write the table in an appropriate way to
complete the I/O server:</p>

<div class="example"><pre>
get(P,Tab) -&gt;
    R = P div ?CHARS_PER_REC,
    C = P rem ?CHARS_PER_REC,
    case ets:lookup(Tab,R) of
	[] -&gt;
	    {P,eof};
	[{R,List}] -&gt;
	    case my_split(C,List,[]) of
		{_,[]} -&gt;
		    {P+length(List),eof};
		{_,Data} -&gt;
		    {P+length(Data),Data}
	    end
    end.

my_split(0,Left,Acc) -&gt;
    {lists:reverse(Acc),Left};
my_split(_,[],Acc) -&gt;
    {lists:reverse(Acc),[]};
my_split(N,[H|T],Acc) -&gt;
    my_split(N-1,T,[H|Acc]).

split_data([],_,_) -&gt;
    [];
split_data(Chars, Row, Col) -&gt;
    {This,Left} = my_split(?CHARS_PER_REC - Col, Chars, []),
    [ {Row, Col, This} | split_data(Left, Row + 1, 0) ].

apply_update(Table, {Row, Col, List}) -&gt;     
    case ets:lookup(Table,Row) of
	[] -&gt;
	    ets:insert(Table,{Row, lists:duplicate(Col,0) ++ List});
	[{Row, OldData}] -&gt;
	    {Part1,_} = my_split(Col,OldData,[]),
	    {_,Part2} = my_split(Col+length(List),OldData,[]),
	    ets:insert(Table,{Row, Part1 ++ List ++ Part2})
    end.
</pre></div>

<p>The table is read or written in chunks of <span class="code">?CHARS_PER_REC</span>, overwriting
when necessary. The implementation is obviously not efficient, it is
just working.</p>

<p>This concludes the example. It is fully runnable and you can read or
write to the I/O server by using i.e. the <span class="bold_code"><a href="../../man/io.html">io</a></span> module or even the <span class="bold_code"><a href="../../man/file.html">file</a></span>
module. It is as simple as that to implement a fully fledged I/O server
in Erlang.</p>

</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
