<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Miscellaneous Mnesia Features</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<div class="erlang-logo-wrapper"><a href="../../index.html"><img alt="Erlang Logo" src="../../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Mnesia</p>
<p class="section-subtitle">User's Guide</p>
<p class="section-version">Version 4.15.3</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="index.html">Reference Manual</a></li>
<li><a href="release_notes.html">Release Notes</a></li>
<li><a href="mnesia.pdf">PDF</a></li>
<li><a href="../../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="Mnesia_chap1.html">
              Top of chapter
            </a></li>
<li title="Scope"><a href="Mnesia_chap1.html#id62375">Scope</a></li>
<li title="Prerequisites"><a href="Mnesia_chap1.html#id68304">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="Mnesia" expanded="false">Mnesia<ul>
<li><a href="Mnesia_overview.html">
              Top of chapter
            </a></li>
<li title="Mnesia Database Management System (DBMS)"><a href="Mnesia_overview.html#id63848">Mnesia Database Management System (DBMS)</a></li>
</ul>
</li>
<li id="no" title="Getting Started" expanded="false">Getting Started<ul>
<li><a href="Mnesia_chap2.html">
              Top of chapter
            </a></li>
<li title="Starting Mnesia for the First Time"><a href="Mnesia_chap2.html#id63845">Starting Mnesia for the First Time</a></li>
<li title="Example"><a href="Mnesia_chap2.html#id64170">Example</a></li>
</ul>
</li>
<li id="no" title="Build a Mnesia Database" expanded="false">Build a Mnesia Database<ul>
<li><a href="Mnesia_chap3.html">
              Top of chapter
            </a></li>
<li title="Define a Schema"><a href="Mnesia_chap3.html#id71529">Define a Schema</a></li>
<li title="Data Model"><a href="Mnesia_chap3.html#id67512">Data Model</a></li>
<li title="Start Mnesia"><a href="Mnesia_chap3.html#id67574">Start Mnesia</a></li>
<li title="Create Tables"><a href="Mnesia_chap3.html#id72086">Create Tables</a></li>
</ul>
</li>
<li id="no" title="Transactions and Other Access Contexts" expanded="false">Transactions and Other Access Contexts<ul>
<li><a href="Mnesia_chap4.html">
              Top of chapter
            </a></li>
<li title="Transaction Properties"><a href="Mnesia_chap4.html#id77330">Transaction Properties</a></li>
<li title="Locking"><a href="Mnesia_chap4.html#id77591">Locking</a></li>
<li title="Dirty Operations"><a href="Mnesia_chap4.html#id78164">Dirty Operations</a></li>
<li title="Record Names versus Table Names"><a href="Mnesia_chap4.html#id78627">Record Names versus Table Names</a></li>
<li title="Activity Concept and Various Access Contexts"><a href="Mnesia_chap4.html#id78726">Activity Concept and Various Access Contexts</a></li>
<li title="Nested Transactions"><a href="Mnesia_chap4.html#id79264">Nested Transactions</a></li>
<li title="Pattern Matching"><a href="Mnesia_chap4.html#id79355">Pattern Matching</a></li>
<li title="Iteration"><a href="Mnesia_chap4.html#id79824">Iteration</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Miscellaneous Mnesia Features" expanded="true">Miscellaneous Mnesia Features<ul>
<li><a href="Mnesia_chap5.html">
              Top of chapter
            </a></li>
<li title="Indexing"><a href="Mnesia_chap5.html#id80248">Indexing</a></li>
<li title="Distribution and Fault Tolerance"><a href="Mnesia_chap5.html#id80387">Distribution and Fault Tolerance</a></li>
<li title="Table Fragmentation"><a href="Mnesia_chap5.html#id80547">Table Fragmentation</a></li>
<li title="Local Content Tables"><a href="Mnesia_chap5.html#id81540">Local Content Tables</a></li>
<li title="Disc-Less Nodes"><a href="Mnesia_chap5.html#id81566">Disc-Less Nodes</a></li>
<li title="More about Schema Management"><a href="Mnesia_chap5.html#id81788">More about Schema Management</a></li>
<li title="Mnesia Event Handling"><a href="Mnesia_chap5.html#id82090">Mnesia Event Handling</a></li>
<li title="Debugging Mnesia Applications"><a href="Mnesia_chap5.html#id82860">Debugging Mnesia Applications</a></li>
<li title="Concurrent Processes in Mnesia"><a href="Mnesia_chap5.html#id83008">Concurrent Processes in Mnesia</a></li>
<li title="Prototyping"><a href="Mnesia_chap5.html#id83060">Prototyping</a></li>
<li title="Object-Based Programming with Mnesia"><a href="Mnesia_chap5.html#id83201">Object-Based Programming with Mnesia</a></li>
</ul>
</li>
<li id="no" title="Mnesia System Information" expanded="false">Mnesia System Information<ul>
<li><a href="Mnesia_chap7.html">
              Top of chapter
            </a></li>
<li title="Database Configuration Data"><a href="Mnesia_chap7.html#id83533">Database Configuration Data</a></li>
<li title="Core Dumps"><a href="Mnesia_chap7.html#id83578">Core Dumps</a></li>
<li title="Dumping Tables"><a href="Mnesia_chap7.html#id83610">Dumping Tables</a></li>
<li title="Checkpoints"><a href="Mnesia_chap7.html#id83658">Checkpoints</a></li>
<li title="Startup Files, Log File, and Data Files"><a href="Mnesia_chap7.html#id83919">Startup Files, Log File, and Data Files</a></li>
<li title="Loading Tables at Startup"><a href="Mnesia_chap7.html#id84432">Loading Tables at Startup</a></li>
<li title="Recovery from Communication Failure"><a href="Mnesia_chap7.html#id84652">Recovery from Communication Failure</a></li>
<li title="Recovery of Transactions"><a href="Mnesia_chap7.html#id84836">Recovery of Transactions</a></li>
<li title="Backup, Restore, Fallback, and Disaster Recovery"><a href="Mnesia_chap7.html#id85020">Backup, Restore, Fallback, and Disaster Recovery</a></li>
</ul>
</li>
<li id="no" title="Combine Mnesia with SNMP" expanded="false">Combine Mnesia with SNMP<ul>
<li><a href="Mnesia_chap8.html">
              Top of chapter
            </a></li>
<li title="Combine Mnesia and SNMP"><a href="Mnesia_chap8.html#id85982">Combine Mnesia and SNMP</a></li>
</ul>
</li>
<li id="no" title="Appendix A: Backup Callback Interface" expanded="false">Appendix A: Backup Callback Interface<ul>
<li><a href="Mnesia_App_A.html">
              Top of chapter
            </a></li>
<li title="mnesia_backup Callback Behavior"><a href="Mnesia_App_A.html#id86092">mnesia_backup Callback Behavior</a></li>
</ul>
</li>
<li id="no" title="Appendix B: Activity Access Callback Interface" expanded="false">Appendix B: Activity Access Callback Interface<ul>
<li><a href="Mnesia_App_B.html">
              Top of chapter
            </a></li>
<li title="mnesia_access Callback Behavior"><a href="Mnesia_App_B.html#id86213">mnesia_access Callback Behavior</a></li>
</ul>
</li>
<li id="no" title="Appendix C: Fragmented Table Hashing Callback Interface" expanded="false">Appendix C: Fragmented Table Hashing Callback Interface<ul>
<li><a href="Mnesia_App_C.html">
              Top of chapter
            </a></li>
<li title="mnesia_frag_hash Callback Behavior"><a href="Mnesia_App_C.html#id86357">mnesia_frag_hash Callback Behavior</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>6 Miscellaneous Mnesia Features</h1>
  

  <p>The previous sections describe how to get started
    with <span class="code">Mnesia</span> and how to build a <span class="code">Mnesia</span> database. This
    section describes the more advanced features available
    when building a distributed, fault-tolerant <span class="code">Mnesia</span> database.
    The following topics are included:</p>
  <ul>
    <li>Indexing</li>
    <li>Distribution and fault tolerance</li>
    <li>Table fragmentation</li>
    <li>Local content tables</li>
    <li>Disc-less nodes</li>
    <li>More about schema management</li>
    <li>
<span class="code">Mnesia</span> event handling</li>
    <li>Debugging <span class="code">Mnesia</span> applications</li>
    <li>Concurrent processes in <span class="code">Mnesia</span>
</li>
    <li>Prototyping</li>
    <li>Object-based programming with <span class="code">Mnesia</span>
</li>
  </ul>

  <h3>
<a name="indexing"></a><a name="id80248">6.1 
        Indexing</a>
</h3>
    
    
    <p>Data retrieval and matching can be performed efficiently
      if the key for the record is known. Conversely, if the key is
      unknown, all records in a table must be searched. The larger the
      table, the more time consuming it becomes. To remedy this
      problem, <span class="code">Mnesia</span> indexing capabilities are used to improve
      data retrieval and matching of records.</p>
    <p>The following two functions manipulate indexes on existing
      tables:</p>
    <ul>
      <li><span class="bold_code bc-15"><a href="../../man/mnesia.html#add_table_index-2">mnesia:add_table_index(Tab, AttributeName) -&gt; {aborted, R} |{atomic, ok}</a></span></li>
      <li><span class="bold_code bc-15"><a href="../../man/mnesia.html#del_table_index-2">mnesia:del_table_index(Tab, AttributeName) -&gt; {aborted, R} |{atomic, ok}</a></span></li>
    </ul>
    <p>These functions create or delete a table index on a field
      defined by <span class="code">AttributeName</span>. To illustrate this, add an
      index to the table definition <span class="code">(employee, {emp_no, name,
      salary, sex, phone, room_no})</span>, which is the example table
      from the <span class="code">Company</span> database. The function that
      adds an index on element <span class="code">salary</span> can be expressed
      as <span class="code">mnesia:add_table_index(employee, salary)</span>.</p>
    <p>The indexing capabilities of <span class="code">Mnesia</span> are used with the
      following three functions, which retrieve and match records
      based on index entries in the database:</p>
    <ul>
      <li>
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#index_read-3">mnesia:index_read(Tab, SecondaryKey, AttributeName) -&gt; transaction abort | RecordList</a></span>
       avoids an exhaustive search of the entire table, by looking up
       <span class="code">SecondaryKey</span> in the index to find the primary keys.
      </li>
      <li>
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#index_match_object-2">mnesia:index_match_object(Pattern, AttributeName) -&gt; transaction abort | RecordList</a></span>
       avoids an exhaustive search of the entire table, by looking up
       the secondary key in the index to find the primary keys.
       The secondary key is found in field <span class="code">AttributeName</span> of
       <span class="code">Pattern</span>. The secondary key must be bound.
      </li>
      <li>
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#match_object-1">mnesia:match_object(Pattern) -&gt; transaction abort | RecordList</a></span>
       uses indexes to avoid exhaustive search of the entire table.
       Unlike the previous functions, this function can use
       any index as long as the secondary key is bound.</li>
    </ul>
    <p>These functions are further described and exemplified in
      <span class="bold_code bc-15"><a href="Mnesia_chap4.html#matching">Pattern Matching</a></span>.
    </p>
  

  <h3><a name="id80387">6.2 
        Distribution and Fault Tolerance</a></h3>
    
    <p><span class="code">Mnesia</span> is a distributed, fault-tolerant DBMS. Tables
      can be replicated on different Erlang nodes in various
      ways. The <span class="code">Mnesia</span> programmer does not need to state
      where the different tables reside, only the names of the
      different tables need to be specified in the program code. This
      is known as "location transparency" and is an important
      concept. In particular:</p>
    <ul>
      <li>
<p>A program works regardless of the data
       location. It makes no difference whether the data
       resides on the local node or on a remote node.</p>
       <p>Notice that the program runs slower if the data
         is located on a remote node.</p>
      </li>
      <li>The database can be reconfigured, and tables can be
       moved between nodes. These operations do not affect the user
       programs. 
      </li>
    </ul>
    <p>It has previously been shown that each table has a number of
      system attributes, such as <span class="code">index</span> and <span class="code">type</span>.</p>
    <p>Table attributes are specified when the table is created. For
      example, the following function creates a table with two
      RAM replicas:</p>
    <div class="example"><pre>
      mnesia:create_table(foo,
                          [{ram_copies, [N1, N2]},
                           {attributes, record_info(fields, foo)}]).</pre></div>
    <p>Tables can also have the following properties,
      where each attribute has a list of Erlang nodes as its value:</p>
    <ul>
      <li>
        <p><span class="code">ram_copies</span>. The value of the node list is a list
          of Erlang nodes, and a RAM replica of the table resides on
          each node in the list.</p>
        <p>Notice that no disc operations are performed when
          a program executes write operations to these replicas.
          However, if permanent RAM replicas are required, the
          following alternatives are available:</p>
        <ul>
          <li>The function
          <span class="bold_code bc-15"><a href="../../man/mnesia.html#dump_tables-1">mnesia:dump_tables/1</a></span>
           can be used to dump RAM table replicas to disc.
          </li>
          <li>The table replicas can be backed up, either from
           RAM, or from disc if dumped there with this function.
          </li>
        </ul>
      </li>
      <li>
<span class="code">disc_copies</span>. The value of the attribute is a list
       of Erlang nodes, and a replica of the table resides both
       in RAM and on disc on each node in the list. Write operations
       addressed to the table address both the RAM and the disc
       copy of the table. 
      </li>
      <li>
<span class="code">disc_only_copies</span>. The value of the attribute is a
       list of Erlang nodes, and a replica of the table resides
       only as a disc copy on each node in the list. The major
       disadvantage of this type of table replica is the access
       speed. The major advantage is that the table does not occupy
       space in memory.
      </li>
    </ul>
    <p>In addition, table properties can be set and changed.
      For details, see
      <span class="bold_code bc-15"><a href="Mnesia_chap3.html#def_schema">Define a Schema</a></span>.
    </p>
    <p>There are basically two reasons for using more than one table
      replica: fault tolerance and speed. Notice
      that table replication provides a solution to both of these
      system requirements.</p>
    <p>If there are two active table replicas, all information is
      still available if one replica fails. This can be an
      important property in many applications. Furthermore, if a table
      replica exists at two specific nodes, applications that execute
      at either of these nodes can read data from the table without
      accessing the network. Network operations are considerably
      slower and consume more resources than local operations.</p>
    <p>It can be advantageous to create table replicas for a
      distributed application that reads data often, but writes data
      seldom, to achieve fast read operations on the local
      node. The major disadvantage with replication is the increased
      time to write data. If a table has two replicas, every write
      operation must access both table replicas. Since one of these
      write operations must be a network operation, it is considerably
      more expensive to perform a write operation to a replicated
      table than to a non-replicated table.</p>
  

  <h3><a name="id80547">6.3 
        Table Fragmentation</a></h3>
    

    <h4>Concept</h4>
      
      <p>A concept of table fragmentation has been introduced
        to cope with large tables. The idea is to split a
        table into several manageable fragments. Each fragment is
        implemented as a first class <span class="code">Mnesia</span> table and can be
        replicated, have indexes, and so on, as any other table. But
        the tables cannot have <span class="code">local_content</span> or have the
        <span class="code">snmp</span> connection activated.</p>
      <p>To be able to access a record in a fragmented
        table, <span class="code">Mnesia</span> must determine to which fragment the
        actual record belongs. This is done by module
        <span class="code">mnesia_frag</span>, which implements the <span class="code">mnesia_access</span>
        callback behavior. It is recommended to read the
        documentation about the function
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#activity-4">mnesia:activity/4</a></span>
        to see how <span class="code">mnesia_frag</span>
        can be used as a <span class="code">mnesia_access</span> callback module.</p>
      <p>At each record access, <span class="code">mnesia_frag</span> first computes
        a hash value from the record key. Second, the name of the
        table fragment is determined from the hash value.
        Finally the actual table access is performed by the same
        functions as for non-fragmented tables. When the key is
        not known beforehand, all fragments are searched for
        matching records.</p>
      <p>Notice that in <span class="code">ordered_set</span> tables, the records
        are ordered per fragment, and the the order is undefined in
        results returned by <span class="code">select</span> and <span class="code">match_object</span>.</p>
      <p>The following code illustrates how a <span class="code">Mnesia</span> table is
        converted to be a fragmented table and how more fragments
        are added later:</p>
      <div class="example"><pre>Eshell V4.7.3.3  (abort with ^G)
(a@sam)1&gt; mnesia:start().
ok
(a@sam)2&gt; mnesia:system_info(running_db_nodes).
[b@sam,c@sam,a@sam]
(a@sam)3&gt; Tab = dictionary.
dictionary
(a@sam)4&gt; mnesia:create_table(Tab, [{ram_copies, [a@sam, b@sam]}]).
{atomic,ok}
(a@sam)5&gt; Write = fun(Keys) -&gt; [mnesia:write({Tab,K,-K}) || K &lt;- Keys], ok end.
#Fun&lt;erl_eval&gt;
(a@sam)6&gt; mnesia:activity(sync_dirty, Write, [lists:seq(1, 256)], mnesia_frag).
ok
(a@sam)7&gt; mnesia:change_table_frag(Tab, {activate, []}).
{atomic,ok}
(a@sam)8&gt; mnesia:table_info(Tab, frag_properties).
[{base_table,dictionary},
 {foreign_key,undefined},
 {n_doubles,0},
 {n_fragments,1},
 {next_n_to_split,1},
 {node_pool,[a@sam,b@sam,c@sam]}]
(a@sam)9&gt; Info = fun(Item) -&gt; mnesia:table_info(Tab, Item) end.
#Fun&lt;erl_eval&gt;
(a@sam)10&gt; Dist = mnesia:activity(sync_dirty, Info, [frag_dist], mnesia_frag).
[{c@sam,0},{a@sam,1},{b@sam,1}]
(a@sam)11&gt; mnesia:change_table_frag(Tab, {add_frag, Dist}).
{atomic,ok}
(a@sam)12&gt; Dist2 = mnesia:activity(sync_dirty, Info, [frag_dist], mnesia_frag).
[{b@sam,1},{c@sam,1},{a@sam,2}]
(a@sam)13&gt; mnesia:change_table_frag(Tab, {add_frag, Dist2}).
{atomic,ok}
(a@sam)14&gt; Dist3 = mnesia:activity(sync_dirty, Info, [frag_dist], mnesia_frag).
[{a@sam,2},{b@sam,2},{c@sam,2}]
(a@sam)15&gt; mnesia:change_table_frag(Tab, {add_frag, Dist3}).
{atomic,ok}
(a@sam)16&gt; Read = fun(Key) -&gt; mnesia:read({Tab, Key}) end.
#Fun&lt;erl_eval&gt;
(a@sam)17&gt; mnesia:activity(transaction, Read, [12], mnesia_frag).
[{dictionary,12,-12}]
(a@sam)18&gt; mnesia:activity(sync_dirty, Info, [frag_size], mnesia_frag).
[{dictionary,64},
 {dictionary_frag2,64},
 {dictionary_frag3,64},
 {dictionary_frag4,64}]
(a@sam)19&gt; </pre></div>
    

    <h4>Fragmentation Properties</h4>
      
      <p>The table property <span class="code">frag_properties</span> can be read with
        the function
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#table_info-2">mnesia:table_info(Tab, frag_properties)</a></span>.
        The fragmentation properties are a list of tagged tuples with
        arity 2. By default the list is empty, but when it is
        non-empty it triggers <span class="code">Mnesia</span> to regard the table as
        fragmented. The fragmentation properties are as follows:</p>
      <dl>
        <dt><strong><span class="code">{n_fragments, Int}</span></strong></dt>
        <dd>
          <p><span class="code">n_fragments</span> regulates how many fragments
            that the table currently has. This property can explicitly
            be set at table creation and later be changed with
            <span class="code">{add_frag, NodesOrDist}</span> or
            <span class="code">del_frag</span>. <span class="code">n_fragments</span> defaults to <span class="code">1</span>.</p>
        </dd>
        <dt><strong><span class="code">{node_pool, List}</span></strong></dt>
        <dd>
          <p>The node pool contains a list of nodes and can
            explicitly be set at table creation and later be changed
            with <span class="code">{add_node, Node}</span> or <span class="code">{del_node, Node}</span>.
            At table creation <span class="code">Mnesia</span> tries to distribute
            the replicas of each fragment evenly over all the nodes in
            the node pool. Hopefully all nodes end up with the
            same number of replicas. <span class="code">node_pool</span> defaults to the
            return value from the function
            <span class="bold_code bc-15"><a href="../../man/mnesia.html#system_info-1">mnesia:system_info(db_nodes)</a></span>.</p>
        </dd>
        <dt><strong><span class="code">{n_ram_copies, Int}</span></strong></dt>
        <dd>
          <p>Regulates how many <span class="code">ram_copies</span> replicas
            that each fragment is to have. This property can
            explicitly be set at table creation. Defaults is
            <span class="code">0</span>, but if <span class="code">n_disc_copies</span> and
            <span class="code">n_disc_only_copies</span> also are <span class="code">0</span>,
            <span class="code">n_ram_copies</span> defaults to <span class="code">1</span>.</p>
        </dd>
        <dt><strong><span class="code">{n_disc_copies, Int}</span></strong></dt>
        <dd>
          <p>Regulates how many <span class="code">disc_copies</span> replicas that
            each fragment is to have. This property can explicitly
            be set at table creation. Default is <span class="code">0</span>.</p>
        </dd>
        <dt><strong><span class="code">{n_disc_only_copies, Int}</span></strong></dt>
        <dd>
          <p>Regulates how many <span class="code">disc_only_copies</span> replicas
            that each fragment is to have. This property can
            explicitly be set at table creation. Defaults is
            <span class="code">0</span>.</p>
        </dd>
        <dt><strong><span class="code">{foreign_key, ForeignKey}</span></strong></dt>
        <dd>
          <p><span class="code">ForeignKey</span> can either be the atom
            <span class="code">undefined</span> or the tuple <span class="code">{ForeignTab, Attr}</span>,
            where <span class="code">Attr</span> denotes an attribute that is to be
            interpreted as a key in another fragmented table named
            <span class="code">ForeignTab</span>. <span class="code">Mnesia</span> ensures that the number of
            fragments in this table and in the foreign table are
            always the same.</p>
         <p>When fragments are added or deleted, <span class="code">Mnesia</span>
            automatically propagates the operation to all
            fragmented tables that have a foreign key referring to this
            table. Instead of using the record key to determine which
            fragment to access, the value of field  <span class="code">Attr</span> is
            used. This feature makes it possible to colocate records
            automatically in different tables to the same node.
            <span class="code">foreign_key</span> defaults to
            <span class="code">undefined</span>. However, if the foreign key is set to
            something else, it causes the default values of the
            other fragmentation properties to be the same values as
            the actual fragmentation properties of the foreign table.</p>
        </dd>
        <dt><strong><span class="code">{hash_module, Atom}</span></strong></dt>
        <dd>
          <p>Enables definition of an alternative hashing scheme.
            The module must implement the
            <span class="bold_code bc-19"><a href="../../man/mnesia_frag_hash.html">mnesia_frag_hash</a></span>
            callback behavior. This property can explicitly be set at
            table creation. Default is <span class="code">mnesia_frag_hash</span>.</p>
        </dd>
        <dt><strong><span class="code">{hash_state, Term}</span></strong></dt>
        <dd>
          <p>Enables a table-specific parameterization of a
            generic hash module. This property can explicitly be set
            at table creation. Default is <span class="code">undefined</span>.</p>
          <div class="example"><pre>Eshell V4.7.3.3  (abort with ^G)
(a@sam)1&gt; mnesia:start().
ok
(a@sam)2&gt; PrimProps = [{n_fragments, 7}, {node_pool, [node()]}].
[{n_fragments,7},{node_pool,[a@sam]}]
(a@sam)3&gt; mnesia:create_table(prim_dict, 
                              [{frag_properties, PrimProps},
                               {attributes,[prim_key,prim_val]}]).
{atomic,ok}
(a@sam)4&gt; SecProps = [{foreign_key, {prim_dict, sec_val}}].
[{foreign_key,{prim_dict,sec_val}}]
(a@sam)5&gt; mnesia:create_table(sec_dict, 
                              [{frag_properties, SecProps},
(a@sam)5&gt;                      {attributes, [sec_key, sec_val]}]).
{atomic,ok}
(a@sam)6&gt; Write = fun(Rec) -&gt; mnesia:write(Rec) end.
#Fun&lt;erl_eval&gt;
(a@sam)7&gt; PrimKey = 11.
11
(a@sam)8&gt; SecKey = 42.
42
(a@sam)9&gt; mnesia:activity(sync_dirty, Write,
                          [{prim_dict, PrimKey, -11}], mnesia_frag).
ok
(a@sam)10&gt; mnesia:activity(sync_dirty, Write,
                           [{sec_dict, SecKey, PrimKey}], mnesia_frag).
ok
(a@sam)11&gt; mnesia:change_table_frag(prim_dict, {add_frag, [node()]}).
{atomic,ok}
(a@sam)12&gt; SecRead = fun(PrimKey, SecKey) -&gt;
               mnesia:read({sec_dict, PrimKey}, SecKey, read) end.
#Fun&lt;erl_eval&gt;
(a@sam)13&gt; mnesia:activity(transaction, SecRead,
                           [PrimKey, SecKey], mnesia_frag).
[{sec_dict,42,11}]
(a@sam)14&gt; Info = fun(Tab, Item) -&gt; mnesia:table_info(Tab, Item) end.
#Fun&lt;erl_eval&gt;
(a@sam)15&gt; mnesia:activity(sync_dirty, Info,
                           [prim_dict, frag_size], mnesia_frag).
[{prim_dict,0},
 {prim_dict_frag2,0},
 {prim_dict_frag3,0},
 {prim_dict_frag4,1},
 {prim_dict_frag5,0},
 {prim_dict_frag6,0},
 {prim_dict_frag7,0},
 {prim_dict_frag8,0}]
(a@sam)16&gt; mnesia:activity(sync_dirty, Info,
                           [sec_dict, frag_size], mnesia_frag).
[{sec_dict,0},
 {sec_dict_frag2,0},
 {sec_dict_frag3,0},
 {sec_dict_frag4,1},
 {sec_dict_frag5,0},
 {sec_dict_frag6,0},
 {sec_dict_frag7,0},
 {sec_dict_frag8,0}]
(a@sam)17&gt;</pre></div>
        </dd>
      </dl>
    

    <h4>Management of Fragmented Tables</h4>
      
      <p>The function <span class="code">mnesia:change_table_frag(Tab, Change)</span>
        is intended to be used for reconfiguration of fragmented
        tables. Argument <span class="code">Change</span> is to have one of the
        following values:</p>
      <dl>
        <dt><strong><span class="code">{activate, FragProps}</span></strong></dt>
        <dd>
          <p>Activates the fragmentation properties of an
            existing table. <span class="code">FragProps</span> is either to contain
            <span class="code">{node_pool, Nodes}</span> or be empty.</p>
        </dd>
        <dt><strong><span class="code">deactivate</span></strong></dt>
        <dd>
          <p>Deactivates the fragmentation properties of a
            table. The number of fragments must be <span class="code">1</span>. No other
            table can refer to this table in its foreign key.</p>
        </dd>
        <dt><strong><span class="code">{add_frag, NodesOrDist}</span></strong></dt>
        <dd>
          <p>Adds a fragment to a fragmented table. All
            records in one of the old fragments are rehashed and
            about half of them are moved to the new (last)
            fragment. All other fragmented tables, which refer to this
            table in their foreign key, automatically get a new
            fragment. Also, their records are dynamically
            rehashed in the same manner as for the main table.</p>
          <p>Argument <span class="code">NodesOrDist</span> can either be a list of
            nodes or the result from the function
            <span class="bold_code bc-15"><a href="../../man/mnesia.html#table_info-2">mnesia:table_info(Tab, frag_dist)</a></span>.
            Argument <span class="code">NodesOrDist</span> is
            assumed to be a sorted list with the best nodes to
            host new replicas first in the list. The new fragment
            gets the same number of replicas as the first
            fragment (see <span class="code">n_ram_copies</span>, <span class="code">n_disc_copies</span>,
            and <span class="code">n_disc_only_copies</span>). The <span class="code">NodesOrDist</span>
            list must at least contain one element for each
            replica that needs to be allocated.</p>
        </dd>
        <dt><strong><span class="code">del_frag</span></strong></dt>
        <dd>
          <p>Deletes a fragment from a fragmented table. All
            records in the last fragment are  moved to one of the other
            fragments. All other fragmented tables, which refer to
            this table in their foreign key, automatically lose
            their last fragment. Also, their records are
            dynamically rehashed in the same manner as for the main
            table.</p>
        </dd>
        <dt><strong><span class="code">{add_node, Node}</span></strong></dt>
        <dd>
          <p>Adds a node to <span class="code">node_pool</span>. The new
            node pool affects the list returned from the function
            <span class="bold_code bc-15"><a href="../../man/mnesia.html#table_info-2">mnesia:table_info(Tab, frag_dist)</a></span>.
           </p>
        </dd>
        <dt><strong><span class="code">{del_node, Node}</span></strong></dt>
        <dd>
          <p>Deletes a node from <span class="code">node_pool</span>. The new
            node pool affects the list returned from the function
            <span class="bold_code bc-15"><a href="../../man/mnesia.html#table_info-2">mnesia:table_info(Tab, frag_dist)</a></span>.
          </p>
        </dd>
      </dl>
    

    <h4>Extensions of Existing Functions</h4>
      
      <p>The function
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#create_table-2">mnesia:create_table/2</a></span>
        creates a brand new fragmented table, by setting table
        property <span class="code">frag_properties</span> to some proper values.</p>
      <p>The function
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#delete_table-1">mnesia:delete_table/1</a></span>
        deletes a fragmented table including all its
        fragments. There must however not exist any other fragmented
        tables that refer to this table in their foreign key.</p>
      <p>The function
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#table_info-2">mnesia:table_info/2</a></span>
        now understands item <span class="code">frag_properties</span>.</p>
      <p>If the function <span class="code">mnesia:table_info/2</span> is started in
        the activity context of module <span class="code">mnesia_frag</span>,
        information of several new items can be obtained:</p>
      <dl>
        <dt><strong><span class="code">base_table</span></strong></dt>
        <dd>The name of the fragmented table</dd>
        <dt><strong><span class="code">n_fragments</span></strong></dt>
        <dd>The actual number of fragments</dd>
        <dt><strong><span class="code">node_pool</span></strong></dt>
        <dd>The pool of nodes</dd>
        <dt><strong><span class="code">n_ram_copies</span></strong></dt>
        <dd></dd>
        <dt><strong><span class="code">n_disc_copies</span></strong></dt>
        <dd></dd>
        <dt><strong><span class="code">n_disc_only_copies</span></strong></dt>
        <dd>
          <p>The number of replicas with storage type <span class="code">ram_copies</span>,
            <span class="code">disc_copies</span>, and <span class="code">disc_only_copies</span>,
            respectively. The actual values are dynamically derived
            from the first fragment. The first fragment serves as a
            protype. When the actual values need to be computed
            (for example, when adding new fragments) they are
            determined by counting the number of each replica for
            each storage type. This means that when the functions
            <span class="bold_code bc-15"><a href="../../man/mnesia.html#add_table_copy-3">mnesia:add_table_copy/3</a></span>,

            <span class="bold_code bc-15"><a href="../../man/mnesia.html#del_table_copy-2">mnesia:del_table_copy/2</a></span>,
            and
            <span class="bold_code bc-15"><a href="../../man/mnesia.html#change_table_copy_type-3">mnesia:change_table_copy_type/2</a></span> are applied on the
            first fragment, it affects the settings on
            <span class="code">n_ram_copies</span>, <span class="code">n_disc_copies</span>, and
            <span class="code">n_disc_only_copies</span>.</p>
        </dd>
        <dt><strong><span class="code">foreign_key</span></strong></dt>
        <dd>
          <p>The foreign key</p>
        </dd>
        <dt><strong><span class="code">foreigners</span></strong></dt>
        <dd>
          <p>All other tables that refer to this table in
            their foreign key</p>
        </dd>
        <dt><strong><span class="code">frag_names</span></strong></dt>
        <dd>
          <p>The names of all fragments</p>
        </dd>
        <dt><strong><span class="code">frag_dist</span></strong></dt>
        <dd>
          <p>A sorted list of <span class="code">{Node, Count}</span> tuples
            that are sorted in increasing <span class="code">Count</span> order.
            <span class="code">Count</span> is the total number of replicas that this
            fragmented table hosts on each <span class="code">Node</span>. The list
            always contains at least all nodes in
            <span class="code">node_pool</span>. Nodes that do not belong to
            <span class="code">node_pool</span> are put last in the list even if
            their <span class="code">Count</span> is lower.</p>
        </dd>
        <dt><strong><span class="code">frag_size</span></strong></dt>
        <dd>
          <p>A list of <span class="code">{Name, Size}</span> tuples, where
            <span class="code">Name</span> is a fragment <span class="code">Name</span>, and <span class="code">Size</span> is
            how many records it contains</p>
        </dd>
        <dt><strong><span class="code">frag_memory</span></strong></dt>
        <dd>
          <p>A list of <span class="code">{Name, Memory}</span> tuples, where
            <span class="code">Name</span> is a fragment <span class="code">Name</span>, and <span class="code">Memory</span> is
            how much memory it occupies</p>
        </dd>
        <dt><strong><span class="code">size</span></strong></dt>
        <dd>
          <p>Total size of all fragments</p>
        </dd>
        <dt><strong><span class="code">memory</span></strong></dt>
        <dd>
          <p>Total memory of all fragments</p>
        </dd>
      </dl>
    

    <h4>Load Balancing</h4>
      
      <p>There are several algorithms for distributing records
        in a fragmented table evenly over a
        pool of nodes. No one is best, it depends on the
        application needs. The following examples of
        situations need some attention:</p>
      <ul>
       <li>
<span class="code">permanent change of nodes</span>. When a new permanent
        <span class="code">db_node</span> is introduced or dropped, it can be time to
        change the pool of nodes and redistribute the replicas
        evenly over the new pool of nodes. It can also be time to
        add or delete a fragment before the replicas are redistributed.
       </li>
       <li>
<span class="code">size/memory threshold</span>. When the total size or
        total memory of a fragmented table (or a single
        fragment) exceeds some application-specific threshold, it
        can be time to add a new fragment dynamically to
        obtain a better distribution of records.
       </li>
       <li>
<span class="code">temporary node down</span>. When a node temporarily goes
        down, it can be time to compensate some fragments with new
        replicas to keep the desired level of
        redundancy. When the node comes up again, it can be time to
        remove the superfluous replica.
       </li>
       <li>
<span class="code">overload threshold</span>. When the load on some node
        exceeds some application-specific threshold, it can be time to
        either add or move some fragment replicas to nodes with lower
        load. Take extra care if the table has a foreign
        key relation to some other table. To avoid severe
        performance penalties, the same redistribution must be
        performed for all the related tables.
       </li>
      </ul>
      <p>Use the function
        <span class="code">mnesia:change_table_frag/2</span> to add new fragments
        and apply the usual schema manipulation functions (such as
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#add_table_copy-3">mnesia:add_table_copy/3</a></span>,
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#del_table_copy-2">mnesia:del_table_copy/2</a></span>,
        and
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#change_table_copy_type-3">mnesia:change_table_copy_type/2</a></span>)
        on each fragment to perform the actual redistribution.</p>
    
  

  <h3><a name="id81540">6.4 
        Local Content Tables</a></h3>
    
    <p>Replicated tables have the same content on all nodes where
      they are replicated. However, it is sometimes advantageous to
      have tables, but different content on different nodes.</p>
    <p>If attribute <span class="code">{local_content, true}</span> is specified when
      you create the table, the table resides on the nodes where you
      specify the table to exist, but the write operations on the
      table are only performed on the local copy.</p>
    <p>Furthermore, when the table is initialized at startup, the
      table is only initialized locally, and the table
      content is not copied from another node.</p>
  

  <h3><a name="id81566">6.5 
        Disc-Less Nodes</a></h3>
    
    <p><span class="code">Mnesia</span> can be run on nodes that do not have a disc.
      Replicas of <span class="code">disc_copies</span> or <span class="code">disc_only_copies</span> are
      not possible on such nodes. This is especially troublesome for
      the <span class="code">schema</span> table, as <span class="code">Mnesia</span> needs the schema
      to initialize itself.</p>
    <p>The schema table can, as other tables, reside on one or
      more nodes. The storage type of the schema table can either
      be <span class="code">disc_copies</span> or <span class="code">ram_copies</span>
      (but not <span class="code">disc_only_copies</span>). At
      startup, <span class="code">Mnesia</span> uses its schema to determine with which
      nodes it is to try to establish contact. If any
      other node is started already, the starting node
      merges its table definitions with the table definitions
      brought from the other nodes. This also applies to the
      definition of the schema table itself. Application
      parameter <span class="code">extra_db_nodes</span> contains a list of nodes that
      <span class="code">Mnesia</span> also is to establish contact with besides those
      found in the schema. Default is <span class="code">[]</span> (empty list).</p>
    <p>Hence, when a disc-less node needs to find the schema
      definitions from a remote node on the network, this
      information must be supplied through application parameter
      <span class="code">-mnesia extra_db_nodes NodeList</span>. Without this
      configuration parameter set, <span class="code">Mnesia</span> starts as a single
      node system. Also, the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#change_config-2">mnesia:change_config/2</a></span>
      can be used to assign a value to <span class="code">extra_db_nodes</span> and force
      a connection after <span class="code">Mnesia</span> has been started, that is,
      <span class="code">mnesia:change_config(extra_db_nodes, NodeList)</span>.</p>
    <p>Application parameter <span class="code">schema_location</span> controls where
      <span class="code">Mnesia</span> searches for its schema. The parameter can be one
      of the following atoms:</p>
    <dl>
      <dt><strong><span class="code">disc</span></strong></dt>
      <dd>
        <p>Mandatory disc. The schema is assumed to be located
          in the <span class="code">Mnesia</span> directory. If the schema cannot be found,
          <span class="code">Mnesia</span> refuses to start.</p>
      </dd>
      <dt><strong><span class="code">ram</span></strong></dt>
      <dd>
        <p>Mandatory RAM. The schema resides in RAM
          only. At startup, a tiny new schema is generated. This
          default schema contains only the definition of the schema
          table and resides on the local node only. Since no other
          nodes are found in the default schema, configuration
          parameter <span class="code">extra_db_nodes</span> must be used to let the
          node share its table definitions with other nodes. (Parameter
          <span class="code">extra_db_nodes</span> can also be used on disc-full nodes.)</p>
      </dd>
      <dt><strong><span class="code">opt_disc</span></strong></dt>
      <dd>
        <p>Optional disc. The schema can reside on either disc or
          RAM. If the schema is found on disc, <span class="code">Mnesia</span> starts as
          a disc-full node (the storage type of the schema table is
          disc_copies). If no schema is found on disc, <span class="code">Mnesia</span>
          starts as a disc-less node (the storage type of the schema
          table is <span class="code">ram_copies</span>). The default for the
          application parameter is <span class="code">opt_disc</span>.</p>
      </dd>
    </dl>
    <p>When <span class="code">schema_location</span> is set to <span class="code">opt_disc</span>, the
      function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#change_table_copy_type-3">mnesia:change_table_copy_type/3</a></span>
      can be used to change the storage type of the schema.
      This is illustrated as follows:</p>
    <div class="example"><pre>
        1&gt; mnesia:start().
        ok
        2&gt; mnesia:change_table_copy_type(schema, node(), disc_copies).
        {atomic, ok}</pre></div>
    <p>Assuming that the call to
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#start-0">mnesia:start/0</a></span> does not
      find any schema to read on the disc, <span class="code">Mnesia</span> starts
      as a disc-less node, and then change it to a node that
      use the disc to store the schema locally.</p>
  

  <h3><a name="id81788">6.6 
        More about Schema Management</a></h3>
    
    <p>Nodes can be added to and removed from a <span class="code">Mnesia</span> system.
      This can be done by adding a copy of the schema to those nodes.</p>
    <p>The functions
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#add_table_copy-3">mnesia:add_table_copy/3</a></span>
      and
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#del_table_copy-2">mnesia:del_table_copy/2</a></span>
      can be used to add and delete
      replicas of the schema table. Adding a node to the list of
      nodes where the schema is replicated affects the following:</p>
    <ul>
      <li>It allows other tables to be replicated to this node.
      </li>
      <li>It causes <span class="code">Mnesia</span> to try to contact the node at
        startup of disc-full nodes.
      </li>
    </ul>
    <p>The function call <span class="code">mnesia:del_table_copy(schema,
      mynode@host)</span> deletes node <span class="code">mynode@host</span> from the
      <span class="code">Mnesia</span> system. The call fails if <span class="code">Mnesia</span> is running
      on <span class="code">mynode@host</span>. The other <span class="code">Mnesia</span> nodes never try to
      connect to that node again. Notice that if there is a disc resident
      schema on node <span class="code">mynode@host</span>, the entire <span class="code">Mnesia</span>
      directory is to be deleted. This is done with the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#delete_schema-1">mnesia:delete_schema/1</a></span>.
      If <span class="code">Mnesia</span> is started again
      on node <span class="code">mynode@host</span> and the directory has not been
      cleared, the behavior of <span class="code">Mnesia</span> is undefined.</p>
    <p>If the storage type of the schema is <span class="code">ram_copies</span>,
      that is, a disc-less node, <span class="code">Mnesia</span>
      does not use the disc on that particular node. The disc
      use is enabled by changing the storage type of table
      <span class="code">schema</span> to <span class="code">disc_copies</span>.</p>
    <p>New schemas are created explicitly with the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#create_schema-1">mnesia:create_schema/1</a></span>
      or implicitly by starting
      <span class="code">Mnesia</span> without a disc resident schema. Whenever
      a table (including the schema table) is created, it is
      assigned its own unique cookie. The schema table is not created
      with the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#create_table-2">mnesia:create_table/2</a></span>
      as normal tables.</p>
    <p>At startup, <span class="code">Mnesia</span> connects different nodes to each other,
      then they exchange table definitions with each other, and the table
      definitions are merged. During the merge procedure, <span class="code">Mnesia</span>
      performs a sanity test to ensure that the table definitions are
      compatible with each other. If a table exists on several nodes,
      the cookie must be the same, otherwise <span class="code">Mnesia</span> shut down one
      of the nodes. This unfortunate situation occurs if a table
      has been created on two nodes independently of each other while
      they were disconnected. To solve this, one of the tables
      must be deleted (as the cookies differ, it is regarded to be two
      different tables even if they have the same name).</p>
    <p>Merging different versions of the schema table does not
      always require the cookies to be the same. If the storage
      type of the schema table is <span class="code">disc_copies</span>, the cookie is
      immutable, and all other <span class="code">db_nodes</span> must have the same
      cookie. When the schema is stored as type <span class="code">ram_copies</span>,
      its cookie can be replaced with a cookie from another node
      (<span class="code">ram_copies</span> or <span class="code">disc_copies</span>). The cookie replacement
      (during merge of the schema table definition) is performed each
      time a RAM node connects to another node.</p>
    <p>Further, the following applies:</p>
    <ul>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#system_info-1">mnesia:system_info(schema_location)</a></span>
        and
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#system_info-1">mnesia:system_info(extra_db_nodes)</a></span>
        can be used to determine the actual values of <span class="code">schema_location</span>
        and <span class="code">extra_db_nodes</span>, respectively.
      </li>
      <li>
<span class="bold_code bc-15"><a href="../../man/mnesia.html#system_info-1">mnesia:system_info(use_dir)</a></span>
        can be used to determine whether <span class="code">Mnesia</span> is actually
        using the <span class="code">Mnesia</span> directory.
      </li>
      <li>
<span class="code">use_dir</span> can be determined even before
        <span class="code">Mnesia</span> is started.
     </li>
    </ul>
    <p>The function <span class="bold_code bc-15"><a href="../../man/mnesia.html#info-0">mnesia:info/0</a></span>
      can now be used to print
      some system information even before <span class="code">Mnesia</span> is started.
      When <span class="code">Mnesia</span> is started, the function prints more
      information.</p>
    <p>Transactions that update the definition of a table
      requires that <span class="code">Mnesia</span> is started on all nodes where the
      storage type of the schema is <span class="code">disc_copies</span>. All replicas of
      the table on these nodes must also be loaded. There are a
      few exceptions to these availability rules:</p>
    <ul>
      <li>Tables can be created and new replicas can be added
        without starting all the disc-full nodes.
      </li>
      <li>New replicas can be added before all other replicas of
        the table have been loaded, provided that at least one other
        replica is active.
      </li>
    </ul>
  

  <h3>
<a name="event_handling"></a><a name="id82090">6.7 
        Mnesia Event Handling</a>
</h3>
    
    
    <p>System events and table events are the two event categories
      that <span class="code">Mnesia</span> generates in various situations.</p>
    <p>A user process can subscribe on the events generated by
      <span class="code">Mnesia</span>. The following two functions are provided:</p>
    <dl>
      <dt><strong><span class="bold_code bc-15"><a href="../../man/mnesia.html#subscribe-1">mnesia:subscribe(Event-Category)</a></span>
      </strong></dt>
      <dd>Ensures that a copy of all events of type
        <span class="code">Event-Category</span> are sent to the calling process</dd>
      <dt><strong><span class="bold_code bc-15"><a href="../../man/mnesia.html#unsubscribe-1">mnesia:unsubscribe(Event-Category)</a></span>
      </strong></dt>
      <dd>Removes the subscription on events of type
        <span class="code">Event-Category</span>
      </dd>
    </dl>
    <p><span class="code">Event-Category</span> can be either of the following:</p>
    <ul>
      <li>The atom <span class="code">system</span>
      </li>
      <li>The atom <span class="code">activity</span>
      </li>
      <li>The tuple <span class="code">{table, Tab, simple}</span>
      </li>
      <li>The tuple <span class="code">{table, Tab, detailed}</span>
      </li>
    </ul>
    <p>The old event category <span class="code">{table, Tab}</span> is the same
      event category as <span class="code">{table, Tab, simple}</span>.</p>
    <p>The subscribe functions activate a subscription
      of events. The events are delivered as messages to the process
      evaluating the function
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#subscribe-1">mnesia:subscribe/1</a></span>
      The syntax is as follows:</p>
    <ul>
      <li>
<span class="code">{mnesia_system_event, Event}</span> for system events
      </li>
      <li>
<span class="code">{mnesia_activity_event, Event}</span> for activity events
      </li>
      <li>
<span class="code">{mnesia_table_event, Event}</span> for table events
      </li>
    </ul>
    <p>The event types are described in the next sections.</p>
    <p>All system events are subscribed by the <span class="code">Mnesia</span>
      <span class="code">gen_event</span> handler. The default <span class="code">gen_event</span> handler
      is <span class="code">mnesia_event</span>, but it can be changed by using
      application parameter <span class="code">event_module</span>. The value of this
      parameter must be the name of a module implementing a complete
      handler, as specified by the
      <span class="bold_code bc-18"><a href="../../man/gen_event.html">gen_event</a></span> module
      in <span class="code">STDLIB</span>.</p>
    <p><span class="bold_code bc-15"><a href="../../man/mnesia.html#system_info-1">mnesia:system_info(subscribers)</a></span>
      and
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#table_info-2">mnesia:table_info(Tab, subscribers)</a></span>
      can be used to determine which processes are subscribed to
      various events.</p>

    <h4>System Events</h4>
      
      <p>The system events are as follows:</p>
      <dl>
        <dt><strong><span class="code">{mnesia_up, Node}</span></strong></dt>
        <dd>Mnesia is started on a node. <span class="code">Node</span> is the node
          name. By default this event is ignored.
        </dd>
        <dt><strong><span class="code">{mnesia_down, Node}</span></strong></dt>
        <dd>Mnesia is stopped on a node. <span class="code">Node</span> is the node
          name. By default this event is ignored.
        </dd>
        <dt><strong><span class="code">{mnesia_checkpoint_activated, Checkpoint}</span></strong></dt>
        <dd>A checkpoint with the name <span class="code">Checkpoint</span> is
          activated and the current node is involved in the
          checkpoint. Checkpoints can be activated explicitly with
          the function
          <span class="bold_code bc-15"><a href="../../man/mnesia.html#activate_checkpoint-1">mnesia:activate_checkpoint/1</a></span>
          or implicitly at
          backup, when adding table replicas, at internal transfer of
          data between nodes, and so on. By default this event is
          ignored.
        </dd>
        <dt><strong><span class="code">{mnesia_checkpoint_deactivated, Checkpoint}</span></strong></dt>
        <dd>A checkpoint with the name <span class="code">Checkpoint</span> is
          deactivated and the current node is involved in the
          checkpoint. Checkpoints can be deactivated explicitly with
          the function
          <span class="bold_code bc-15"><a href="../../man/mnesia.html#deactivate_checkpoint-1">mnesia:deactivate/1</a></span>
          or implicitly when the last
          replica of a table (involved in the checkpoint) becomes
          unavailable, for example, at node-down. By default this
          event is ignored.
        </dd>
        <dt><strong><span class="code">{mnesia_overload, Details}</span></strong></dt>
        <dd>
<p><span class="code">Mnesia</span> on the current node is
          overloaded and the subscriber is to take action.</p>
          <p>A typical overload situation occurs when the
            applications perform more updates on disc resident
            tables than <span class="code">Mnesia</span> can handle. Ignoring
            this kind of overload can lead to a situation where
            the disc space is exhausted (regardless of the size of
            the tables stored on disc).</p>
          <p>Each update is appended to the transaction log and
            occasionally (depending on how it
            is configured) dumped to the tables files. The
            table file storage is more compact than the transaction
            log storage, especially if the same record is updated
            repeatedly. If the thresholds for dumping the
            transaction log are reached before the previous
            dump is finished, an overload event is triggered.</p>
          <p>Another typical overload situation is when the
            transaction manager cannot commit transactions at the
            same pace as the applications perform updates of
            disc resident tables. When this occurs, the message
            queue of the transaction manager continues to grow
            until the memory is exhausted or the load
            decreases.</p>
          <p>The same problem can occur for dirty updates. The overload
            is detected locally on the current node, but its cause can
            be on another node. Application processes can cause high
            load if any table resides on another node (replicated
            or not). By default this event
            is reported to <span class="code">error_logger.</span></p>
        </dd>
        <dt><strong><span class="code">{inconsistent_database, Context, Node}</span></strong></dt>
        <dd>
<span class="code">Mnesia</span> regards the database as potential
          inconsistent and gives its applications a chance to
          recover from the inconsistency. For example, by installing a
          consistent backup as fallback and then restart the system.
          An alternative is to pick a <span class="code">MasterNode</span> from
          <span class="bold_code bc-15"><a href="../../man/mnesia.html#system_info-1">mnesia:system_info(db_nodes)</a></span>
          and invoke
          <span class="bold_code bc-15"><a href="../../man/mnesia.html#set_master_nodes-1">mnesia:set_master_node([MasterNode])</a></span>.
          By default an error is reported to <span class="code">error_logger</span>.
        </dd>
        <dt><strong><span class="code">{mnesia_fatal, Format, Args, BinaryCore}</span></strong></dt>
        <dd>
          <p><span class="code">Mnesia</span> detected a fatal error and
            terminates soon. The fault reason is explained in
            <span class="code">Format</span> and <span class="code">Args</span>, which can be given as input
            to <span class="code">io:format/2</span> or sent to <span class="code">error_logger</span>. By
            default it is sent to <span class="code">error_logger</span>.</p>
          <p><span class="code">BinaryCore</span> is a binary containing a summary of the
            <span class="code">Mnesia</span> internal state at the time when the fatal
            error was detected. By default the binary is written to a
            unique filename on the current directory. On RAM nodes, the
            core is ignored.</p>
        </dd>
        <dt><strong><span class="code">{mnesia_info, Format, Args}</span></strong></dt>
        <dd>
<span class="code">Mnesia</span> detected something that can be of
          interest when debugging the system. This is explained in
          <span class="code">Format</span> and <span class="code">Args</span>, which can appear as input
          to <span class="code">io:format/2</span> or sent to <span class="code">error_logger</span>. By
          default this event is printed with <span class="code">io:format/2</span>.
        </dd>
        <dt><strong><span class="code">{mnesia_error, Format, Args}</span></strong></dt>
        <dd>
<span class="code">Mnesia</span> has detected an error. The fault reason is
          explained in <span class="code">Format</span> and <span class="code">Args</span>, which can be
          given as input to <span class="code">io:format/2</span> or sent to
          <span class="code">error_logger</span>. By default this event is reported to
          <span class="code">error_logger</span>.
        </dd>
        <dt><strong><span class="code">{mnesia_user, Event}</span></strong></dt>
        <dd>An application started the function
          <span class="bold_code bc-15"><a href="../../man/mnesia.html#report_event-1">mnesia:report_event(Event)</a></span>.
          <span class="code">Event</span> can be
          any Erlang data structure. When tracing a system of
          <span class="code">Mnesia</span> applications, it is useful to be able to
          interleave own events of <span class="code">Mnesia</span> with application-related
          events that give information about the application context.
          Whenever the application starts with a new and demanding
          <span class="code">Mnesia</span> activity, or enters a new and interesting
          phase in its execution, it can be a good idea to use
          <span class="code">mnesia:report_event/1</span>.
        </dd>
      </dl>
    

    <h4>Activity Events</h4>
      
      <p>Currently, there is only one type of activity event:</p>
      <dl>
       <dt><strong><span class="code">{complete, ActivityID}</span></strong></dt>
       <dd>
         <p>This event occurs when a transaction that caused a modification
           to the database is completed. It is useful for determining when
           a set of table events (see the next section), caused by a given
           activity, have been sent. Once this event is received, it is
           guaranteed that no further table events with the same
           <span class="code">ActivityID</span> will be received. Notice that this event can
           still be received even if no table events with a corresponding
           <span class="code">ActivityID</span> were received, depending on
           the tables to which the receiving process is subscribed.</p>
         <p>Dirty operations always contain only one update and thus no
           activity event is sent.</p>
       </dd>
     </dl>
    

    <h4>Table Events</h4>
      
      <p>Table events are events related to table updates. There are
        two types of table events, simple and detailed.</p>
      <p>The <strong>simple table events</strong> are tuples like
        <span class="code">{Oper, Record, ActivityId}</span>, where:</p>
      <ul>
        <li>
<span class="code">Oper</span> is the operation performed.
        </li>
        <li>
<span class="code">Record</span> is the record involved in the operation.
        </li>
        <li>
<span class="code">ActivityId</span> is the identity of the transaction
          performing the operation.
        </li>
      </ul>
      <p>Notice that the record name is the table name even when
        <span class="code">record_name</span> has another setting.</p>
      <p>The table-related events that can occur are as follows:</p>
      <dl>
        <dt><strong><span class="code">{write, NewRecord, ActivityId}</span></strong></dt>
        <dd>A new record has been written. <span class="code">NewRecord</span> contains
          the new record value.
        </dd>
        <dt><strong><span class="code">{delete_object, OldRecord, ActivityId}</span></strong></dt>
        <dd>A record has possibly been deleted with
          <span class="bold_code bc-15"><a href="../../man/mnesia.html#delete_object-1">mnesia:delete_object/1</a></span>.
          <span class="code">OldRecord</span>
          contains the value of the old record, as stated as argument
          by the application. Notice that other records with the same
          key can remain in the table if it is of type <span class="code">bag</span>.
        </dd>
        <dt><strong><span class="code">{delete, {Tab, Key}, ActivityId}</span></strong></dt>
        <dd>One or more records have possibly been deleted.
          All records with the key <span class="code">Key</span> in the table
          <span class="code">Tab</span> have been deleted.
        </dd>
      </dl>
      <p>The <strong>detailed table events</strong> are tuples like
        <span class="code">{Oper, Table, Data, [OldRecs], ActivityId}</span>, where:</p>
      <ul>
        <li>
<span class="code">Oper</span> is the operation performed.
        </li>
        <li>
<span class="code">Table</span> is the table involved in the operation.
        </li>
        <li>
<span class="code">Data</span> is the record/OID written/deleted.
        </li>
        <li>
<span class="code">OldRecs</span> is the contents before the operation.
        </li>
        <li>
<span class="code">ActivityId</span> is the identity of the transaction
          performing the operation.
        </li>
      </ul>
      <p>The table-related events that can occur are as follows:</p>
      <dl>
        <dt><strong><span class="code">{write, Table, NewRecord, [OldRecords], ActivityId}</span></strong></dt>
        <dd>A new record has been written. <span class="code">NewRecord</span> contains
          the new record value and <span class="code">OldRecords</span> contains the
          records before the operation is performed. Notice that the
          new content depends on the table type.
        </dd>
        <dt><strong><span class="code">{delete, Table, What, [OldRecords], ActivityId}</span></strong></dt>
        <dd>Records have possibly been deleted. <span class="code">What</span> is
          either <span class="code">{Table, Key}</span> or a record
          <span class="code">{RecordName, Key, ...}</span> that was deleted. Notice
          that the new content depends on the table type.
        </dd>
      </dl>
    
  

  <h3><a name="id82860">6.8 
        Debugging Mnesia Applications</a></h3>
    
    <p>Debugging a <span class="code">Mnesia</span> application can be difficult
      for various reasons, primarily related
      to difficulties in understanding how the transaction
      and table load mechanisms work. Another source of
      confusion can be the semantics of nested transactions.</p>
    <p>The debug level of <span class="code">Mnesia</span> is set by calling the function
     <span class="bold_code bc-15"><a href="../../man/mnesia.html#set_debug_level-1">mnesia:set_debug_level(Level)</a></span>,
      where <span class="code">Level</span>is one of the following:</p>
    <dl>
      <dt><strong><span class="code">none</span></strong></dt>
      <dd>No trace outputs. This is the default.
      </dd>
      <dt><strong><span class="code">verbose</span></strong></dt>
      <dd>Activates tracing of important debug events. These
        events generate <span class="code">{mnesia_info, Format, Args}</span>
        system events. Processes can subscribe to these events with
        the function
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#subscribe-1">mnesia:subscribe/1</a></span>.
        The events are always sent to the <span class="code">Mnesia</span> event handler.
      </dd>
      <dt><strong><span class="code">debug</span></strong></dt>
      <dd>Activates all events at the verbose level plus
          traces of all debug events. These debug events generate
          <span class="code">{mnesia_info, Format, Args}</span> system events. Processes
          can subscribe to these events with <span class="code">mnesia:subscribe/1</span>.
          The events are always sent to the <span class="code">Mnesia</span> event handler.
          On this debug level, the <span class="code"> Mnesia</span> event handler starts
          subscribing to updates in the schema table.
      </dd>
      <dt><strong><span class="code">trace</span></strong></dt>
      <dd>Activates all events at the debug level. On this
          level, the <span class="code">Mnesia</span> event handler starts subscribing to
          updates on all <span class="code">Mnesia</span> tables. This level is intended
          only for debugging small toy systems, as many large
          events can be generated.
      </dd>
      <dt><strong><span class="code">false</span></strong></dt>
      <dd>An alias for none.
      </dd>
      <dt><strong><span class="code">true</span></strong></dt>
      <dd>An alias for debug.
      </dd>
    </dl>
    <p>The debug level of <span class="code">Mnesia</span> itself is also an application
      parameter, making it possible to start an Erlang system
      to turn on <span class="code">Mnesia</span> debug in the initial
      startup phase by using the following code:</p>
    <div class="example"><pre>
      % erl -mnesia debug verbose</pre></div>
  

  <h3><a name="id83008">6.9 
        Concurrent Processes in Mnesia</a></h3>
    
    <p>Programming concurrent Erlang systems is the subject of
      a separate book. However, it is worthwhile to draw attention to
      the following features, which permit concurrent processes to
      exist in a <span class="code">Mnesia</span> system:</p>
    <ul>
    <li>
<p>A group of functions or processes can be called within a
      transaction. A transaction can include statements that read,
      write, or delete data from the DBMS. Many such
      transactions can run concurrently, and the programmer does not
      need to explicitly synchronize the processes that manipulate
      the data.</p>
      <p>All programs accessing the database through the
      transaction system can be written as if they had sole access to
      the data. This is a desirable property, as all
      synchronization is taken care of by the transaction handler. If
      a program reads or writes data, the system ensures that no other
      program tries to manipulate the same data at the same time.</p>
    </li>
    <li>Tables can be moved or deleted, and the layout of a table
      can be reconfigured in various ways. An important aspect of
      the implementation of these functions is that user programs
      can continue to use a table while it
      is being reconfigured. For example, it is possible to move a
      table and perform write operations to the table at the same
      time. This is important for many applications that require
      continuously available services. For more information, see
      <span class="bold_code bc-15"><a href="Mnesia_chap4.html#trans_prop">Transactions and Other Access Contexts</a></span>.
    </li>
    </ul>
  

  <h3><a name="id83060">6.10 
        Prototyping</a></h3>
    
    <p>If and when you would like to start and manipulate
      <span class="code">Mnesia</span>, it is often easier to write the definitions and
      data into an ordinary text file.
      Initially, no tables and no data exist, or which
      tables are required. At the initial stages of prototyping, it
      is prudent to write all data into one file, process that
      file, and have the data in the file inserted into the database.
      <span class="code">Mnesia</span> can be initialized with data read from a text file.
      The following two functions can be used to work with text
      files.</p>
    <ul>
      <li>
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#load_textfile-1">mnesia:load_textfile(Filename)</a></span>
        loads a series of local table definitions and data found in the
        file into <span class="code">Mnesia</span>. This function also starts <span class="code">Mnesia</span>
        and possibly creates a new schema. The function operates
        on the local node only.
      </li>
      <li>
        <span class="bold_code bc-15"><a href="../../man/mnesia.html#dump_to_textfile-1">mnesia:dump_to_textfile(Filename)</a></span>
        dumps all local
        tables of a <span class="code">Mnesia</span> system into a text file, which
        can be edited (with a normal text editor) and later reloaded.
      </li>
    </ul>
    <p>These functions are much slower than the ordinary store and
      load functions of <span class="code">Mnesia</span>. However, this is mainly intended
      for minor experiments and initial prototyping. The major
      advantage of these functions is that they are easy to use.</p>
    <p>The format of the text file is as follows:</p>
    <div class="example"><pre>
      {tables, [{Typename, [Options]},
      {Typename2 ......}]}.
      
      {Typename, Attribute1, Attribute2 ....}.
      {Typename, Attribute1, Attribute2 ....}.</pre></div>
    <p><span class="code">Options</span> is a list of <span class="code">{Key,Value}</span> tuples conforming
      to the options that you can give to
      <span class="bold_code bc-15"><a href="../../man/mnesia.html#create_table-2">mnesia:create_table/2</a></span>.
    </p>
    <p>For example, to start playing with a small database for healthy
      foods, enter the following data into file <span class="code">FRUITS</span>:</p>
<div class="example"><pre>{tables,
 [{fruit, [{attributes, [name, color, taste]}]},
  {vegetable, [{attributes, [name, color, taste, price]}]}]}.


{fruit, orange, orange, sweet}.
{fruit, apple, green, sweet}.
{vegetable, carrot, orange, carrotish, 2.55}.
{vegetable, potato, yellow, none, 0.45}.</pre></div>    <p>The following session with the Erlang shell shows how
      to load the <span class="code">FRUITS</span> database:</p>
    <div class="example"><pre>
      % erl
      Erlang (BEAM) emulator version 4.9
 
      Eshell V4.9  (abort with ^G)
      1&gt; mnesia:load_textfile("FRUITS").
      New table fruit
      New table vegetable
      {atomic,ok}
      2&gt; mnesia:info().
      ---&gt; Processes holding locks &lt;--- 
      ---&gt; Processes waiting for locks &lt;--- 
      ---&gt; Pending (remote) transactions &lt;--- 
      ---&gt; Active (local) transactions &lt;---
      ---&gt; Uncertain transactions &lt;--- 
      ---&gt; Active tables &lt;--- 
      vegetable      : with 2 records occuping 299 words of mem 
      fruit          : with 2 records occuping 291 words of mem 
      schema         : with 3 records occuping 401 words of mem 
      ===&gt; System info in version "1.1", debug level = none &lt;===
      opt_disc. Directory "/var/tmp/Mnesia.nonode@nohost" is used.
      use fallback at restart = false
      running db nodes = [nonode@nohost]
      stopped db nodes = [] 
      remote           = []
      ram_copies       = [fruit,vegetable]
      disc_copies      = [schema]
      disc_only_copies = []
      [{nonode@nohost,disc_copies}] = [schema]
      [{nonode@nohost,ram_copies}] = [fruit,vegetable]
      3 transactions committed, 0 aborted, 0 restarted, 2 logged to disc
      0 held locks, 0 in queue; 0 local transactions, 0 remote
      0 transactions waits for other nodes: []
      ok
      3&gt; 
    </pre></div>
    <p>It can be seen that the DBMS was initiated from a
      regular text file.</p>
  

  <h3><a name="id83201">6.11 
        Object-Based Programming with Mnesia</a></h3>
    
    <p>The <span class="code">Company</span> database, introduced in
      <span class="bold_code bc-15"><a href="Mnesia_chap2.html#getting_started">Getting Started</a></span>,
      has three tables that store records (<span class="code">employee</span>,
      <span class="code">dept</span>, <span class="code">project</span>), and three tables that store
      relationships (<span class="code">manager</span>, <span class="code">at_dep</span>, <span class="code">in_proj</span>).
      This is a normalized data model, which has some advantages over
      a non-normalized data model.</p>
    <p>It is more efficient to do a
      generalized search in a normalized database. Some operations are
      also easier to perform on a normalized data model. For example,
      one project can easily be removed, as the following example
      illustrates:</p>
<div class="example"><pre>remove_proj(ProjName) -&gt;
    F = fun() -&gt;
                Ip = qlc:e(qlc:q([X || X &lt;- mnesia:table(in_proj),
				       X#in_proj.proj_name == ProjName]
				)),
                mnesia:delete({project, ProjName}),
                del_in_projs(Ip)
        end,
    mnesia:transaction(F).

del_in_projs([Ip|Tail]) -&gt;
    mnesia:delete_object(Ip),
    del_in_projs(Tail);
del_in_projs([]) -&gt;
    done.</pre></div>    <p>In reality, data models are seldom fully normalized. A
      realistic alternative to a normalized database model would be
      a data model that is not even in first normal form. <span class="code">Mnesia</span>
      is suitable for applications such as telecommunications,
      because it is easy to organize data in a flexible manner. A
      <span class="code">Mnesia</span> database is always organized as a set of tables.
      Each table is filled with rows, objects, and records.
      What sets <span class="code">Mnesia</span> apart is that individual fields in
      a record can contain any type of
      compound data structures. An individual field in a record can
      contain lists, tuples, functions, and even record code.</p>
    <p>Many telecommunications applications have unique requirements
      on lookup times for certain types of records. If the <span class="code">Company</span>
      database had been a part of a telecommunications system, it
      could be to minimize the lookup time of an employee
      <strong>together</strong> with a list of the projects the employee is
      working on. If this is the case, a drastically different data model
      without direct relationships can be chosen. You would then have
      only the records themselves, and different records could contain
      either direct references to other records, or contain other
      records that are not part of the <span class="code">Mnesia</span> schema.</p>
    <p>The following record definitions can be created:</p>
<div class="example"><pre>-record(employee, {emp_no,
		   name,
		   salary,
		   sex,
		   phone,
		   room_no,
		   dept,
		   projects,
		   manager}).
		   

-record(dept, {id, 
               name}).

-record(project, {name,
                  number,
                  location}).</pre></div>    <p>A record that describes an employee can look as follows:</p>
    <div class="example"><pre>
        Me = #employee{emp_no= 104732,
        name = klacke,
        salary = 7,
        sex = male,
        phone = 99586,
        room_no = {221, 015},
        dept = 'B/SFR',
        projects = [erlang, mnesia, otp],
        manager = 114872},</pre></div>
    <p>This model has only three different tables, and the employee
      records contain references to other records. The record has the
      following references:</p>
    <ul>
      <li>
<span class="code">'B/SFR'</span> refers to a <span class="code">dept</span> record.
      </li>
      <li>
<span class="code">[erlang, mnesia, otp]</span> is a list of three
       direct references to three different <span class="code">projects</span> records.
      </li>
      <li>
<span class="code">114872</span> refers to another employee record.
      </li>
    </ul>
    <p>The <span class="code">Mnesia</span> record identifiers (<span class="code">{Tab, Key}</span>) can
      also be used as references. In this case, attribute <span class="code">dept</span>
      would be set to value <span class="code">{dept, 'B/SFR'}</span> instead of
      <span class="code">'B/SFR'</span>.</p>
    <p>With this data model, some operations execute considerably
      faster than they do with the normalized data model in the
      <span class="code">Company</span> database. However, some other operations
      become much more complicated. In particular, it becomes more
      difficult to ensure that records do not contain dangling
      pointers to other non-existent, or deleted, records.</p>
    <p>The following code exemplifies a search with a non-normalized
      data model. To find all employees at department <span class="code">Dep</span> with
      a salary higher than <span class="code">Salary</span>, use the following code:</p>
<div class="example"><pre>get_emps(Salary, Dep) -&gt;
    Q = qlc:q( 
          [E || E &lt;- mnesia:table(employee),
                E#employee.salary &gt; Salary,
                E#employee.dept == Dep]
	 ),
    F = fun() -&gt; qlc:e(Q) end,
    transaction(F).</pre></div>    <p>This code is easier to write and to understand, and it
      also executes much faster.</p>
    <p>It is easy to show examples of code that executes faster if
      a non-normalized data model is used, instead of a normalized
      model. The main reason is that fewer tables are required.
      Therefore, data from different tables can more easily be
      combined in join operations. In the previous example, the
      function <span class="code">get_emps/2</span> is transformed from a join operation
      into a simple query, which consists of a selection and a
      projection on one single table.</p>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2018 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../../js/';</script><script type="text/javascript" src="../../js/highlight.js"></script>
</body>
</html>
