<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- Overview</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<div class="erlang-logo-wrapper"><a href="../index.html"><img alt="Erlang Logo" src="../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Interoperability Tutorial</p>
<p class="section-subtitle">User's Guide</p>
<p class="section-version">Version 9.3</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="../pdf/otp-system-documentation.pdf">PDF</a></li>
<li><a href="../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="introduction.html">
              Top of chapter
            </a></li>
<li title="Purpose"><a href="introduction.html#id65051">Purpose</a></li>
<li title="Prerequisites"><a href="introduction.html#id58095">Prerequisites</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Overview" expanded="true">Overview<ul>
<li><a href="overview.html">
              Top of chapter
            </a></li>
<li title="Built-In Mechanisms"><a href="overview.html#id62085">Built-In Mechanisms</a></li>
<li title="C and Java Libraries"><a href="overview.html#id62195">C and Java Libraries</a></li>
<li title="Standard Protocols"><a href="overview.html#id58248">Standard Protocols</a></li>
<li title="IC"><a href="overview.html#id62423">IC</a></li>
<li title="Old Applications"><a href="overview.html#id62469">Old Applications</a></li>
</ul>
</li>
<li id="no" title="Problem Example" expanded="false">Problem Example<ul>
<li><a href="example.html">
              Top of chapter
            </a></li>
<li title="Description"><a href="example.html#id60544">Description</a></li>
</ul>
</li>
<li id="no" title="Ports" expanded="false">Ports<ul>
<li><a href="c_port.html">
              Top of chapter
            </a></li>
<li title="Erlang Program"><a href="c_port.html#id64037">Erlang Program</a></li>
<li title="C Program"><a href="c_port.html#id65115">C Program</a></li>
<li title="Running the Example"><a href="c_port.html#id65192">Running the Example</a></li>
</ul>
</li>
<li id="no" title="Erl_Interface" expanded="false">Erl_Interface<ul>
<li><a href="erl_interface.html">
              Top of chapter
            </a></li>
<li title="Erlang Program"><a href="erl_interface.html#id64439">Erlang Program</a></li>
<li title="C Program"><a href="erl_interface.html#id64570">C Program</a></li>
<li title="Running the Example"><a href="erl_interface.html#id65840">Running the Example</a></li>
</ul>
</li>
<li id="no" title="Port Drivers" expanded="false">Port Drivers<ul>
<li><a href="c_portdriver.html">
              Top of chapter
            </a></li>
<li title="Erlang Program"><a href="c_portdriver.html#id66062">Erlang Program</a></li>
<li title="C Driver"><a href="c_portdriver.html#id66207">C Driver</a></li>
<li title="Running the Example"><a href="c_portdriver.html#id66302">Running the Example</a></li>
</ul>
</li>
<li id="no" title="C Nodes" expanded="false">C Nodes<ul>
<li><a href="cnode.html">
              Top of chapter
            </a></li>
<li title="Erlang Program"><a href="cnode.html#id66431">Erlang Program</a></li>
<li title="C Program"><a href="cnode.html#id66511">C Program</a></li>
<li title="Running the Example"><a href="cnode.html#id66889">Running the Example</a></li>
</ul>
</li>
<li id="no" title="NIFs" expanded="false">NIFs<ul>
<li><a href="nif.html">
              Top of chapter
            </a></li>
<li title="Erlang Program"><a href="nif.html#id67233">Erlang Program</a></li>
<li title="NIF Library Code"><a href="nif.html#id67314">NIF Library Code</a></li>
<li title="Running the Example"><a href="nif.html#id67434">Running the Example</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>2 Overview</h1>
  

  <h3><a name="id62085">2.1 
        Built-In Mechanisms</a></h3>
    
    <p>Two interoperability mechanisms are built into the Erlang
      runtime system, <strong>distributed Erlang</strong> and <strong>ports</strong>.
      A variation of ports is <strong>linked-in drivers</strong>.</p>
    <a name="dist"></a>

    <h4>Distributed Erlang</h4>
      
      <p>An Erlang runtime system is made a distributed Erlang node by
        giving it a name. A distributed Erlang node can connect to,
        and monitor, other nodes. It can also spawn processes at other
        nodes. Message passing and error handling between processes at
        different nodes are transparent. A number of useful STDLIB
        modules are available in a distributed Erlang system. For
        example, <span class="code">global</span>, which provides global name
        registration. The distribution mechanism is implemented using
        TCP/IP sockets.</p>
      <p><strong>When to use:</strong> Distributed Erlang is primarily used
        for Erlang-Erlang communication. It can also be used for
        communication between Erlang and C, if the C program is
        implemented as a C node, see
        <span class="bold_code bc-17"><a href="#cnode">C and Java Libraries</a></span>.</p>
      <p><strong>Where to read more:</strong> Distributed Erlang and some distributed
      programming techniques are described in the Erlang book.</p>
      <p>For more information, see <span class="bold_code bc-13"><a href="../getting_started/conc_prog.html#Distributed%20Programming">Distributed Programming.</a></span></p>
	<p>Relevant manual pages are the following:</p>
      <ul>
       <li>
<span class="bold_code bc-18"><a href="../man/erlang.html">erlang</a></span> manual page in ERTS
       (describes the BIFs)</li>
       <li>
<span class="bold_code bc-18"><a href="../man/global.html">global</a></span> manual page in Kernel</li>
       <li>
<span class="bold_code bc-18"><a href="../man/net_adm.html">net_adm</a></span> manual page in Kernel</li>
       <li>
<span class="bold_code bc-18"><a href="../man/pg2.html">pg2</a></span> manual page in Kernel</li>
       <li>
<span class="bold_code bc-18"><a href="../man/rpc.html">rpc</a></span> manual page in Kernel</li>
       <li>
<span class="bold_code bc-18"><a href="../man/pool.html">pool</a></span> manual page in STDLIB</li>
       <li>
<span class="bold_code bc-18"><a href="../man/slave.html">slave</a></span> manual page in STDLIB</li>
      </ul>
    

    <h4>Ports and Linked-In Drivers</h4>
      
      <p>Ports provide the basic mechanism for communication with the
        external world, from Erlang's point of view. The ports provide
        a byte-oriented interface to an external program. When a port
        is created, Erlang can communicate with it by sending and
        receiving lists of bytes (not Erlang terms). This means that
        the programmer might have to invent a suitable encoding and
        decoding scheme.</p>
      <p>The implementation of the port mechanism depends on the
        platform. For UNIX, pipes are used and the external program is
        assumed to read from standard input and write to standard
        output. The external program can be written in any programming
        language as long as it can handle the interprocess
        communication mechanism with which the port is
        implemented.</p>
      <p>The external program resides in another OS process than the
        Erlang runtime system. In some cases this is not acceptable.
        Consider, for example, drivers with very hard time
        requirements. It is therefore possible to write a program in C
        according to certain principles, and dynamically link it to
        the Erlang runtime system. This is called a <strong>linked-in
        driver</strong>.</p>
      <p><strong>When to use:</strong> Ports can be used for all kinds of
        interoperability situations where the Erlang program and the
        other program runs on the same machine. Programming is fairly
        straight-forward.</p>
      <p>Linked-in drivers involves writing certain call-back
        functions in C. This requires very good skills as the code is
        linked to the Erlang runtime system.</p>
      <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
        <p>A faulty linked-in driver causes the entire Erlang runtime
	  system to leak memory, hang, or crash.</p>
      </p></div>
</div>
      <p><strong>Where to read more:</strong> Ports are described in section
        "Miscellaneous Items" of the Erlang book. Linked-in drivers
        are described in Appendix E.</p>
      <p>The BIF <span class="code">open_port/2</span> is documented in the
        <span class="bold_code bc-18"><a href="../man/erlang.html">erlang</a></span> manual page in
	ERTS.</p>
      <p>For linked-in drivers, the programmer needs to read the
        <span class="bold_code bc-18"><a href="../man/erl_ddll.html">erl_ddll</a></span> manual
        page in Kernel.</p>
      <p><strong>Examples:</strong> Port example in <span class="bold_code bc-19"><a href="c_port.html">Ports</a></span>.</p>
    
  

  <h3><a name="id62195">2.2 
        C and Java Libraries</a></h3>
    

    <h4>Erl_Interface</h4>
      
      <p>The program at the other side of a port is often a C program.
        To help the C programmer, the Erl_Interface library
        has been developed, including the following five parts:</p>
      <ul>
        <li>
	<span class="code">erl_marshal</span>, <span class="code">erl_eterm</span>, <span class="code">erl_format</span>, and
	<span class="code">erl_malloc</span>: Handling of the Erlang external term format</li>
        <li>
	<span class="code">erl_connect</span>:
	Communication with distributed Erlang, see <span class="bold_code bc-17"><a href="#cnode">C nodes</a></span> below</li>
        <li>
	<span class="code">erl_error</span>:
	Error print routines</li>
        <li>
	<span class="code">erl_global</span>:
	Access globally registered names</li>
        <li>
	<span class="code">Registry</span>:
	Store and backup of key-value pairs</li>
      </ul>
      <p>The Erlang external term format is a representation of an
        Erlang term as a sequence of bytes, that is, a binary.
        Conversion between the two representations is done using the
        following BIFs:</p>
      <div class="example"><pre>
Binary = term_to_binary(Term)
Term = binary_to_term(Binary)</pre></div>
      <p>A port can be set to use binaries instead of lists of bytes.
        It is then not necessary to invent any encoding/decoding
        scheme. Erl_Interface functions are used for unpacking the
        binary and convert it into a struct similar to an Erlang term.
        Such a struct can be manipulated in different ways, be
        converted to the Erlang external format, and sent to
        Erlang.</p>
      <p><strong>When to use:</strong> In C code, in conjunction with Erlang binaries.</p>
      <p><strong>Where to read more:</strong> See the Erlang Interface User's
        Guide, Command Reference, and Library Reference. In Erlang/OTP
        R5B, and earlier versions, the information is part of the
        Kernel application.</p> 
    <p><strong>Examples:</strong> Erl_Interface example in
       <span class="bold_code bc-19"><a href="erl_interface.html">Erl_Interface</a></span>.</p>
    <a name="cnode"></a>

    <h4>C Nodes</h4>
      
      <p>A C program that uses the Erl_Interface functions for setting
        up a connection to, and communicating with, a distributed
        Erlang node is called a <strong>C node</strong>, or a <strong>hidden
        node</strong>. The main advantage with a C node is that the
        communication from the Erlang programmer's perspective is
        extremely easy, as the C program behaves as a distributed
        Erlang node.</p>
      <p><strong>When to use:</strong> C nodes can typically be used on device
        processors (as opposed to control processors) where C is a
        better choice than Erlang due to memory limitations or
        application characteristics, or both.</p>
      <p><strong>Where to read more:</strong> See the <span class="code">erl_connect</span> part
        of the Erl_Interface documentation. The programmer also needs
        to be familiar with TCP/IP sockets, see Sockets in <span class="bold_code bc-17"><a href="#sockets">Standard Protocols</a></span> and Distributed Erlang in <span class="bold_code bc-17"><a href="#dist">Built-In Mechanisms</a></span>.</p>
      <p><strong>Example:</strong> C node example in <span class="bold_code bc-19"><a href="cnode.html">C Nodes</a></span>.</p>
    

    <h4>Jinterface</h4>
      
      <p>In Erlang/OTP R6B, a library similar to Erl_Interface for
        Java was added called <strong>jinterface</strong>. It provides a tool
        for Java programs to communicate with Erlang nodes.</p>
    
  

  <h3><a name="id58248">2.3 
        Standard Protocols</a></h3>
    
    <p>Sometimes communication between an Erlang program and another
      program using a standard protocol is desirable. Erlang/OTP
      currently supports TCP/IP and UDP <strong>sockets</strong>: as
      follows:</p>
    <ul>
       <li>SNMP</li>
       <li>HTTP</li>
       <li>IIOP (CORBA)</li>
     </ul>
    <p>Using one of the latter three requires good knowledge about the
      protocol and is not covered by this tutorial. See the SNMP,
      Inets, and Orber applications, respectively.</p>
    <a name="sockets"></a>

    <h4>Sockets</h4>
      
      <p>Simply put, connection-oriented socket communication (TCP/IP)
        consists of an initiator socket ("server") started at a
        certain host with a certain port number. A connector socket
        ("client"), which is aware of the initiator host name and port
        number, can connect to it and data can be sent between
        them.</p>
      <p>Connection-less socket communication (UDP) consists of an
        initiator socket at a certain host with a certain port number
        and a connector socket sending data to it.</p>
      <p>For a detailed description of the socket concept, refer to a
        suitable book about network programming. A suggestion is
        <strong>UNIX Network Programming, Volume 1: Networking APIs -
        Sockets and XTI</strong> by W. Richard Stevens, ISBN:
        013490012X.</p>
      <p>In Erlang/OTP, access to TCP/IP and UDP sockets is provided
        by the modules <span class="code">gen_tcp</span> and <span class="code">gen_udp</span> in
        Kernel. Both are easy to use and do not require
        detailed knowledge about the socket concept.</p>
      <p><strong>When to use:</strong> For programs running on the same or on
        another machine than the Erlang program.</p>
      <p><strong>Where to read more:</strong> See the <span class="bold_code bc-18"><a href="../man/gen_tcp.html">gen_tcp</a></span> and the <span class="bold_code bc-18"><a href="../man/gen_udp.html">gen_udp</a></span> manual pages in
        Kernel.</p>
    
  

  <h3><a name="id62423">2.4 
        IC</a></h3>
    
    <p>IC (Erlang IDL Compiler) is an interface generator that, given
      an IDL interface specification, automatically generates stub
      code in Erlang, C, or Java. See the IC User's Guide and IC
      Reference Manual.</p>
    <p>For details, see the <span class="bold_code bc-18"><a href="../man/ic.html">ic</a></span>
      manual page in IC.</p>
  

  <h3><a name="id62469">2.5 
        Old Applications</a></h3>
    
    <p>Two old applications are of interest regarding
      interoperability. Both have been replaced by IC and are
      mentioned here for reference only:</p>
    <ul>
       <li>
<p>IG - Removed from Erlang/OTP R6B.</p>
       <p>IG (Interface Generator) automatically generated code for
         port or socket communication between an Erlang program and a
         C program, given a C header file with certain keywords.</p>
      </li>
       <li>
<p>Jive -  Removed from Erlang/OTP R7B.</p>
       <p>Jive provided a simple interface between an Erlang program
         and a Java program.</p>
      </li>
     </ul>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 2000-2018 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../js/';</script><script type="text/javascript" src="../js/highlight.js"></script>
</body>
</html>
