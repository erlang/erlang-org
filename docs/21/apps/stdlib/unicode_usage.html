<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Using Unicode in Erlang</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<div class="erlang-logo-wrapper"><a href="../../index.html"><img alt="Erlang Logo" src="../../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">STDLIB</p>
<p class="section-subtitle">User's Guide</p>
<p class="section-version">Version 3.8.2.4</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="index.html">Reference Manual</a></li>
<li><a href="release_notes.html">Release Notes</a></li>
<li><a href="stdlib.pdf">PDF</a></li>
<li><a href="../../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="introduction.html">
              Top of chapter
            </a></li>
<li title="Scope"><a href="introduction.html#scope">Scope</a></li>
<li title="Prerequisites"><a href="introduction.html#prerequisites">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="The Erlang I/O Protocol" expanded="false">The Erlang I/O Protocol<ul>
<li><a href="io_protocol.html">
              Top of chapter
            </a></li>
<li title="Protocol Basics"><a href="io_protocol.html#protocol-basics">Protocol Basics</a></li>
<li title="Output Requests"><a href="io_protocol.html#output-requests">Output Requests</a></li>
<li title="Input Requests"><a href="io_protocol.html#input-requests">Input Requests</a></li>
<li title="I/O Server Modes"><a href="io_protocol.html#i-o-server-modes">I/O Server Modes</a></li>
<li title="Multiple I/O Requests"><a href="io_protocol.html#multiple-i-o-requests">Multiple I/O Requests</a></li>
<li title="Optional I/O Request"><a href="io_protocol.html#optional-i-o-request">Optional I/O Request</a></li>
<li title="Unimplemented Request Types"><a href="io_protocol.html#unimplemented-request-types">Unimplemented Request Types</a></li>
<li title="An Annotated and Working Example I/O Server"><a href="io_protocol.html#an-annotated-and-working-example-i-o-server">An Annotated and Working Example I/O Server</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Using Unicode in Erlang" expanded="true">Using Unicode in Erlang<ul>
<li><a href="unicode_usage.html">
              Top of chapter
            </a></li>
<li title="Unicode Implementation"><a href="unicode_usage.html#unicode-implementation">Unicode Implementation</a></li>
<li title="Understanding Unicode"><a href="unicode_usage.html#understanding-unicode">Understanding Unicode</a></li>
<li title="What Unicode Is"><a href="unicode_usage.html#what-unicode-is">What Unicode Is</a></li>
<li title="Areas of Unicode Support"><a href="unicode_usage.html#areas-of-unicode-support">Areas of Unicode Support</a></li>
<li title="Standard Unicode Representation"><a href="unicode_usage.html#standard-unicode-representation">Standard Unicode Representation</a></li>
<li title="Basic Language Support"><a href="unicode_usage.html#basic-language-support">Basic Language Support</a></li>
<li title="The Interactive Shell"><a href="unicode_usage.html#the-interactive-shell">The Interactive Shell</a></li>
<li title="Unicode Filenames"><a href="unicode_usage.html#unicode-filenames">Unicode Filenames</a></li>
<li title="Unicode in Environment and Parameters"><a href="unicode_usage.html#unicode-in-environment-and-parameters">Unicode in Environment and Parameters</a></li>
<li title="Unicode-Aware Modules"><a href="unicode_usage.html#unicode-aware-modules">Unicode-Aware Modules</a></li>
<li title="Unicode Data in Files"><a href="unicode_usage.html#unicode-data-in-files">Unicode Data in Files</a></li>
<li title="Summary of Options"><a href="unicode_usage.html#summary-of-options">Summary of Options</a></li>
<li title="Recipes"><a href="unicode_usage.html#recipes">Recipes</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>3 Using Unicode in Erlang</h1>
  
  <h3><span onMouseOver="document.getElementById('ghlink-unicode-implementation-idm518').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-unicode-implementation-idm518').style.visibility = 'hidden';"><span id="ghlink-unicode-implementation-idm518" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L36" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="unicode-implementation" href="#unicode-implementation">3.1 
          Unicode Implementation</a></span></h3>
    
    <p>Implementing support for Unicode character sets is an ongoing process.
      The Erlang Enhancement Proposal (EEP) 10 outlined the basics of Unicode
      support and specified a default encoding in binaries that all
      Unicode-aware modules are to handle in the future.</p>

      <p>Here is an overview what has been done so far:</p>

      <ul>
	<li><p>The functionality described in EEP10 was implemented
	in Erlang/OTP R13A.</p></li>

	<li><p>Erlang/OTP R14B01 added support for Unicode
	filenames, but it was not complete and was by default
	disabled on platforms where no guarantee was given for the
	filename encoding.</p></li>

	<li><p>With Erlang/OTP R16A came support for UTF-8 encoded
	source code, with enhancements to many of the applications to
	support both Unicode encoded filenames and support for UTF-8
	encoded files in many circumstances. Most notable is the
	support for UTF-8 in files read by <span class="bold_code bc-13"><a href="../../man/file.html#consult-1"><span class="code">file:consult/1</span></a></span>,
	release handler support for UTF-8, and more support for
	Unicode character sets in the I/O system.</p></li>

	<li><p>In Erlang/OTP 17.0, the encoding default for Erlang
	source files was switched to UTF-8.</p></li>

	<li>
<p>In Erlang/OTP 20.0, atoms and function can contain
	Unicode characters. Module names, application names, and node
	names are still restricted to the ISO Latin-1 range.</p>
	<p>Support was added for normalizations forms in
	<span class="code">unicode</span> and the <span class="code">string</span> module now handles
	utf8-encoded binaries.</p>
</li>
      </ul>

    <p>This section outlines the current Unicode support and gives some
      recipes for working with Unicode data.</p>
  

  <h3><span onMouseOver="document.getElementById('ghlink-understanding-unicode-idm539').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-understanding-unicode-idm539').style.visibility = 'hidden';"><span id="ghlink-understanding-unicode-idm539" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L78" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="understanding-unicode" href="#understanding-unicode">3.2 
          Understanding Unicode</a></span></h3>
    
    <p>Experience with the Unicode support in Erlang has made it clear that
      understanding Unicode characters and encodings is not as easy as one
      would expect. The complexity of the field and the implications of the
      standard require thorough understanding of concepts rarely before
      thought of.</p>

    <p>Also, the Erlang implementation requires understanding of
      concepts that were never an issue for many (Erlang) programmers. To
      understand and use Unicode characters requires that you study the
      subject thoroughly, even if you are an experienced programmer.</p>

    <p>As an example, contemplate the issue of converting between upper and
      lower case letters. Reading the standard makes you realize that there is
      not a simple one to one mapping in all scripts, for example:</p>

    <ul>
      <li>
        <p>In German, the letter "ß" (sharp s) is in lower case, but the
          uppercase equivalent is "SS".</p>
      </li>
      <li>
        <p>In Greek, the letter "Σ" has two different lowercase forms,
          "ς" in word-final position and "σ" elsewhere.</p>
      </li>
      <li>
        <p>In Turkish, both dotted and dotless "i" exist in lower case and
          upper case forms.</p>
      </li>
      <li>
        <p>Cyrillic "I" has usually no lowercase form.</p>
      </li>
      <li>
        <p>Languages with no concept of upper case (or lower case).</p>
      </li>
    </ul>

    <p>So, a conversion function must know not only one character at a
    time, but possibly the whole sentence, the natural language to
    translate to, the differences in input and output string length,
    and so on.  Erlang/OTP has currently no Unicode
    <span class="code">uppercase</span>/<span class="code">lowercase</span> functionality with language
    specific handling, but publicly available libraries address these
    issues.</p>

    <p>Another example is the accented characters, where the same
    glyph has two different representations. The Swedish letter "ö" is
    one example.  The Unicode standard has a code point for it, but
    you can also write it as "o" followed by "U+0308" (Combining
    Diaeresis, with the simplified meaning that the last letter is to
    have "¨" above). They have the same glyph, user perceived
    character. They are for most purposes the same, but have different
    representations. For example, MacOS X converts all filenames to
    use Combining Diaeresis, while most other programs (including
    Erlang) try to hide that by doing the opposite when, for example,
    listing directories.  However it is done, it is usually important
    to normalize such characters to avoid confusion.
    </p>

    <p>The list of examples can be made long. One need a kind of knowledge that
      was not needed when programs only considered one or two languages. The
      complexity of human languages and scripts has certainly made this a
      challenge when constructing a universal standard. Supporting Unicode
      properly in your program will require effort.</p>
  

  <h3><span onMouseOver="document.getElementById('ghlink-what-unicode-is-idm560').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-what-unicode-is-idm560').style.visibility = 'hidden';"><span id="ghlink-what-unicode-is-idm560" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L145" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="what-unicode-is" href="#what-unicode-is">3.3 
          What Unicode Is</a></span></h3>
  
    <p>Unicode is a standard defining code points (numbers) for all known,
      living or dead, scripts. In principle, every symbol used in any
      language has a Unicode code point. Unicode code points are defined and
      published by the Unicode Consortium, which is a non-profit
      organization.</p>

    <p>Support for Unicode is increasing throughout the world of computing, as
      the benefits of one common character set are overwhelming when programs
      are used in a global environment. Along with the base of the standard,
      the code points for all the scripts, some <strong>encoding standards</strong> are
      available.</p>

    <p>It is vital to understand the difference between encodings and Unicode
      characters. Unicode characters are code points according to the Unicode
      standard, while the encodings are ways to represent such code points. An
      encoding is only a standard for representation. UTF-8 can, for example,
      be used to represent a very limited part of the Unicode character set
      (for example ISO-Latin-1) or the full Unicode range. It is only an
      encoding format.</p>

    <p>As long as all character sets were limited to 256 characters, each
      character could be stored in one single byte, so there was more or less
      only one practical encoding for the characters. Encoding each character
      in one byte was so common that the encoding was not even named. With the
      Unicode system there are much more than 256 characters, so a common way
      is needed to represent these. The common ways of representing the code
      points are the encodings. This means a whole new concept to the
      programmer, the concept of character representation, which was a
      non-issue earlier.</p>

    <p>Different operating systems and tools support different encodings. For
      example, Linux and MacOS X have chosen the UTF-8 encoding, which is
      backward compatible with 7-bit ASCII and therefore affects programs
      written in plain English the least. Windows supports a limited version
      of UTF-16, namely all the code planes where the characters can be
      stored in one single 16-bit entity, which includes most living
      languages.</p>

    <p>The following are the most widely spread encodings:</p>

    <dl>
      <dt><strong>Bytewise representation</strong></dt>
      <dd>
        <p>This is not a proper Unicode representation, but the representation
          used for characters before the Unicode standard. It can still be used
          to represent character code points in the Unicode standard with
          numbers &lt; 256, which exactly corresponds to the ISO Latin-1
          character set. In Erlang, this is commonly denoted <span class="code">latin1</span>
          encoding, which is slightly misleading as ISO Latin-1 is a
          character code range, not an encoding.</p>
      </dd>
      <dt><strong>UTF-8</strong></dt>
      <dd>
        <p>Each character is stored in one to four bytes depending on code
          point. The encoding is backward compatible with bytewise
          representation of 7-bit ASCII, as all 7-bit characters are stored in
          one single byte in UTF-8. The characters beyond code point 127 are
          stored in more bytes, letting the most significant bit in the first
          character indicate a multi-byte character. For details on the
          encoding, the RFC is publicly available.</p>
        <p>Notice that UTF-8 is <strong>not</strong> compatible with bytewise
          representation for code points from 128 through 255, so an ISO
          Latin-1 bytewise representation is generally incompatible with
          UTF-8.</p>
      </dd>
      <dt><strong>UTF-16</strong></dt>
      <dd>
        <p>This encoding has many similarities to UTF-8, but the basic
        unit is a 16-bit number. This means that all characters occupy
        at least two bytes, and some high numbers four bytes. Some
        programs, libraries, and operating systems claiming to use
        UTF-16 only allow for characters that can be stored in one
        16-bit entity, which is usually sufficient to handle living
        languages. As the basic unit is more than one byte, byte-order
        issues occur, which is why UTF-16 exists in both a big-endian
        and a little-endian variant.</p>
        <p>In Erlang, the full UTF-16 range is supported when applicable, like
          in the <span class="bold_code bc-18"><a href="../../man/unicode.html"><span class="code">unicode</span></a></span>
          module and in the bit syntax.</p>
      </dd>
      <dt><strong>UTF-32</strong></dt>
      <dd>
        <p>The most straightforward representation. Each character is stored in
          one single 32-bit number. There is no need for escapes or any
          variable number of entities for one character. All Unicode code
          points can be stored in one single 32-bit entity. As with UTF-16,
          there are byte-order issues. UTF-32 can be both big-endian and
          little-endian.</p>
      </dd>
      <dt><strong>UCS-4</strong></dt>
      <dd>
        <p>Basically the same as UTF-32, but without some Unicode semantics,
          defined by IEEE, and has little use as a separate encoding standard.
          For all normal (and possibly abnormal) use, UTF-32 and UCS-4 are
          interchangeable.</p>
      </dd>
    </dl>

    <p>Certain number ranges are unused in the Unicode standard and certain
      ranges are even deemed invalid. The most notable invalid range is
      16#D800-16#DFFF, as the UTF-16 encoding does not allow for encoding of
      these numbers. This is possibly because the UTF-16 encoding standard,
      from the beginning, was expected to be able to hold all Unicode
      characters in one 16-bit entity, but was then extended, leaving a hole
      in the Unicode range to handle backward compatibility.</p>

    <p>Code point 16#FEFF is used for Byte Order Marks (BOMs) and use of that
      character is not encouraged in other contexts. It is valid though, as
      the character "ZWNBS" (Zero Width Non Breaking Space). BOMs are used to
      identify encodings and byte order for programs where such parameters are
      not known in advance. BOMs are more seldom used than expected, but can
      become more widely spread as they provide the means for programs to make
      educated guesses about the Unicode format of a certain file.</p>
  

  <h3><span onMouseOver="document.getElementById('ghlink-areas-of-unicode-support-idm593').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-areas-of-unicode-support-idm593').style.visibility = 'hidden';"><span id="ghlink-areas-of-unicode-support-idm593" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L262" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="areas-of-unicode-support" href="#areas-of-unicode-support">3.4 
          Areas of Unicode Support</a></span></h3>
    
    <p>To support Unicode in Erlang, problems in various areas have been
      addressed. This section describes each area briefly and more
      thoroughly later in this User's Guide.</p>

    <dl>
      <dt><strong>Representation</strong></dt>
      <dd>
        <p>To handle Unicode characters in Erlang, a common representation
          in both lists and binaries is needed. EEP (10) and the subsequent
          initial implementation in Erlang/OTP R13A settled a standard
          representation of Unicode characters in Erlang.</p>
      </dd>
      <dt><strong>Manipulation</strong></dt>
      <dd>
        <p>The Unicode characters need to be processed by the Erlang
        program, which is why library functions must be able to handle
        them. In some cases functionality has been added to already
        existing interfaces (as the <span class="bold_code bc-18"><a href="../../man/string.html"><span class="code">string</span></a></span> module now can
        handle strings with any code points). In some cases new
        functionality or options have been added (as in the <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span> module, the file
        handling, the <span class="bold_code bc-18"><a href="../../man/unicode.html"><span class="code">unicode</span></a></span> module, and
        the bit syntax). Today most modules in Kernel and
        STDLIB, as well as the VM are Unicode-aware.</p>
      </dd>
      <dt><strong>File I/O</strong></dt>
      <dd>
        <p>I/O is by far the most problematic area for Unicode. A file is an
          entity where bytes are stored, and the lore of programming has been
          to treat characters and bytes as interchangeable. With Unicode
          characters, you must decide on an encoding when you want to store
          the data in a file. In Erlang, you can open a text file with an
          encoding option, so that you can read characters from it rather than
          bytes, but you can also open a file for bytewise I/O.</p>
        <p>The Erlang I/O-system has been designed (or at least used) in a way
          where you expect any I/O server to handle any string data.
          That is, however, no longer the case when working with Unicode
          characters. The Erlang programmer must now know the
          capabilities of the device where the data ends up. Also, ports in
          Erlang are byte-oriented, so an arbitrary string of (Unicode)
          characters cannot be sent to a port without first converting it to an
          encoding of choice.</p>
      </dd>
      <dt><strong>Terminal I/O</strong></dt>
      <dd>
        <p>Terminal I/O is slightly easier than file I/O. The output is meant
          for human reading and is usually Erlang syntax (for example, in the
          shell). There exists syntactic representation of any Unicode
          character without displaying the glyph (instead written as
          <span class="code">\x</span>{<span class="code">HHH</span>}). Unicode data can therefore usually be
          displayed even if the terminal as such does not support the whole
          Unicode range.</p>
      </dd>
      <dt><strong>Filenames</strong></dt>
      <dd>
        <p>Filenames can be stored as Unicode strings in different ways
          depending on the underlying operating system and file system. This
          can be handled fairly easy by a program. The problems arise when the
          file system is inconsistent in its encodings. For example, Linux
          allows files to be named with any sequence of bytes, leaving to each
          program to interpret those bytes. On systems where these
          "transparent" filenames are used, Erlang must be informed about the
          filename encoding by a startup flag. The default is bytewise
          interpretation, which is usually wrong, but allows for interpretation
          of <strong>all</strong> filenames.</p>
        <p>The concept of "raw filenames" can be used to handle wrongly encoded
          filenames if one enables Unicode filename translation (<span class="code">+fnu</span>)
          on platforms where this is not the default.</p>
      </dd>
      <dt><strong>Source code encoding</strong></dt>
      <dd>
        <p>The Erlang source code has support for the UTF-8 encoding
          and bytewise encoding. The default in Erlang/OTP R16B was bytewise
          (<span class="code">latin1</span>) encoding. It was changed to UTF-8 in Erlang/OTP 17.0.
          You can control the encoding by a comment like the following in the
          beginning of the file:</p>
        <div class="example"><pre>%% -*- coding: utf-8 -*-</pre></div>
        <p>This of course requires your editor to support UTF-8 as well. The
          same comment is also interpreted by functions like
          <span class="bold_code bc-13"><a href="../../man/file.html#consult-1"><span class="code">file:consult/1</span></a></span>,
          the release handler, and so on, so that you can have all text files
          in your source directories in UTF-8 encoding.</p>
      </dd>
      <dt><strong>The language</strong></dt>
      <dd>
        <p>Having the source code in UTF-8 also allows you to write string
          literals, function names, and atoms containing Unicode
	  characters with code points &gt; 255.
          Module names, application names, and node names are still restricted
	  to the ISO Latin-1 range. Binary literals, where you use type
          <span class="code">/utf8</span>, can also be expressed using Unicode characters &gt; 255.
          Having module names or application names using characters other than
	  7-bit ASCII can cause
          trouble on operating systems with inconsistent file naming schemes,
          and can hurt portability, so it is not recommended.</p>
        <p>EEP 40 suggests that the language is also to allow for Unicode
          characters &gt; 255 in variable names. Whether to implement that EEP
          is yet to be decided.</p>
      </dd>
    </dl>
  

  <h3><span onMouseOver="document.getElementById('ghlink-standard-unicode-representation-idm637').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-standard-unicode-representation-idm637').style.visibility = 'hidden';"><span id="ghlink-standard-unicode-representation-idm637" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L369" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="standard-unicode-representation" href="#standard-unicode-representation">3.5 
          Standard Unicode Representation</a></span></h3>
    
    <p>In Erlang, strings are lists of integers. A string was until
      Erlang/OTP R13 defined to be encoded in the ISO Latin-1 (ISO 8859-1)
      character set, which is, code point by code point, a subrange of the
      Unicode character set.</p>

    <p>The standard list encoding for strings was therefore easily extended to
      handle the whole Unicode range. A Unicode string in Erlang is a list
      containing integers, where each integer is a valid Unicode code point and
      represents one character in the Unicode character set.</p>

    <p>Erlang strings in ISO Latin-1 are a subset of Unicode strings.</p>

    <p>Only if a string contains code points &lt; 256, can it be directly
      converted to a binary by using, for example,
      <span class="bold_code bc-13"><a href="../../man/erlang.html#iolist_to_binary-1"><span class="code">erlang:iolist_to_binary/1</span></a></span>
      or can be sent directly to a port. If the string contains Unicode
      characters &gt; 255, an encoding must be decided upon and the string is to
      be converted to a binary in the preferred encoding using
      <span class="bold_code bc-13"><a href="../../man/unicode.html#characters_to_binary-1"><span class="code">unicode:characters_to_binary/1,2,3</span></a></span>.
      Strings are not generally lists of bytes, as they were before
      Erlang/OTP R13, they are lists of characters. Characters are not
      generally bytes, they are Unicode code points.</p>

    <p>Binaries are more troublesome. For performance reasons, programs often
      store textual data in binaries instead of lists, mainly because they are
      more compact (one byte per character instead of two words per character,
      as is the case with lists). Using
      <span class="bold_code bc-13"><a href="../../man/erlang.html#list_to_binary-1"><span class="code">erlang:list_to_binary/1</span></a></span>,
      an ISO Latin-1 Erlang string can be converted into a binary, effectively
      using bytewise encoding: one byte per character. This was convenient for
      those limited Erlang strings, but cannot be done for arbitrary Unicode
      lists.</p>

    <p>As the UTF-8 encoding is widely spread and provides some backward
      compatibility in the 7-bit ASCII range, it is selected as the standard
      encoding for Unicode characters in binaries for Erlang.</p>

    <p>The standard binary encoding is used whenever a library function in
      Erlang is to handle Unicode data in binaries, but is of course not
      enforced when communicating externally. Functions and bit syntax exist to
      encode and decode both UTF-8, UTF-16, and UTF-32 in binaries. However,
      library functions dealing with binaries and Unicode in general only deal
      with the default encoding.</p>

    <p>Character data can be combined from many sources, sometimes available in
      a mix of strings and binaries. Erlang has for long had the concept of
      <span class="code">iodata</span> or <span class="code">iolist</span>s, where binaries and lists can be combined
      to represent a sequence of bytes. In the same way, the Unicode-aware
      modules often allow for combinations of binaries and lists, where the
      binaries have characters encoded in UTF-8 and the lists contain such
      binaries or numbers representing Unicode code points:</p>

    <div class="example"><pre>unicode_binary() = binary() with characters encoded in UTF-8 coding standard

chardata() = charlist() | unicode_binary()

charlist() = maybe_improper_list(char() | unicode_binary() | charlist(),
  unicode_binary() | nil())</pre></div>

    <p>The module <span class="bold_code bc-18"><a href="../../man/unicode.html"><span class="code">unicode</span></a></span>
      even supports similar mixes with binaries containing other encodings than
      UTF-8, but that is a special case to allow for conversions to and from
      external data:</p>

    <div class="example"><pre>external_unicode_binary() = binary() with characters coded in a user-specified
  Unicode encoding other than UTF-8 (UTF-16 or UTF-32)

external_chardata() = external_charlist() | external_unicode_binary()

external_charlist() = maybe_improper_list(char() | external_unicode_binary() |
  external_charlist(), external_unicode_binary() | nil())</pre></div>
  

  <h3><span onMouseOver="document.getElementById('ghlink-basic-language-support-idm660').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-basic-language-support-idm660').style.visibility = 'hidden';"><span id="ghlink-basic-language-support-idm660" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L446" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="basic-language-support" href="#basic-language-support">3.6 
          Basic Language Support</a></span></h3>
    
    <p><a name="unicode_in_erlang"></a>As from Erlang/OTP R16, Erlang
    source files can be written in UTF-8 or bytewise (<span class="code">latin1</span>)
    encoding. For information about how to state the encoding of an
    Erlang source file, see the <span class="bold_code bc-13"><a href="../../man/epp.html#encoding"><span class="code">epp(3)</span></a></span> module.  As
    from Erlang/OTP R16, strings and comments can be written using
    Unicode.  As from Erlang/OTP 20, also atoms and functions can be
    written using Unicode. Modules, applications, and nodes must still be
    named using characters from the ISO Latin-1 character set.  (These
    restrictions in the language are independent of the encoding of
    the source file.)</p>

    <h4><span onMouseOver="document.getElementById('ghlink-bit-syntax-idm667').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-bit-syntax-idm667').style.visibility = 'hidden';"><span id="ghlink-bit-syntax-idm667" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L460" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="bit-syntax" href="#bit-syntax">Bit Syntax</a></span></h4>
      
      <p>The bit syntax contains types for handling binary data in the
        three main encodings. The types are named <span class="code">utf8</span>, <span class="code">utf16</span>,
        and <span class="code">utf32</span>. The <span class="code">utf16</span> and <span class="code">utf32</span> types can be in a
        big-endian or a little-endian variant:</p>

      <div class="example"><pre>&lt;&lt;Ch/utf8,_/binary&gt;&gt; = Bin1,
&lt;&lt;Ch/utf16-little,_/binary&gt;&gt; = Bin2,
Bin3 = &lt;&lt;$H/utf32-little, $e/utf32-little, $l/utf32-little, $l/utf32-little,
$o/utf32-little&gt;&gt;,</pre></div>

      <p>For convenience, literal strings can be encoded with a Unicode
        encoding in binaries using the following (or similar) syntax:</p>

      <div class="example"><pre>Bin4 = &lt;&lt;"Hello"/utf16&gt;&gt;,</pre></div>
    

    <h4><span onMouseOver="document.getElementById('ghlink-string-and-character-literals-idm678').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-string-and-character-literals-idm678').style.visibility = 'hidden';"><span id="ghlink-string-and-character-literals-idm678" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L480" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="string-and-character-literals" href="#string-and-character-literals">String and Character Literals</a></span></h4>
      
      <p>For source code, there is an extension to syntax <span class="code">\</span>OOO
        (backslash followed by three octal numbers) and <span class="code">\x</span>HH (backslash
        followed by <span class="code">x</span>, followed by two hexadecimal characters), namely
        <span class="code">\x{</span>H ...<span class="code">}</span> (backslash followed by <span class="code">x</span>, followed by
        left curly bracket, any number of hexadecimal digits, and a terminating
        right curly bracket). This allows for entering characters of any code
        point literally in a string even when the encoding of the source file
        is bytewise (<span class="code">latin1</span>).</p>

      <p>In the shell, if using a Unicode input device, or in source code
        stored in UTF-8, <span class="code">$</span> can be followed directly by a Unicode
        character producing an integer. In the following example, the code
        point of a Cyrillic <span class="code">с</span> is output:</p>

      <div class="example"><pre>
7&gt; <span class="bold_code bc-12">$с.</span>
1089</pre></div>
    

    <h4><span onMouseOver="document.getElementById('ghlink-heuristic-string-detection-idm693').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-heuristic-string-detection-idm693').style.visibility = 'hidden';"><span id="ghlink-heuristic-string-detection-idm693" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L501" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="heuristic-string-detection" href="#heuristic-string-detection">Heuristic String Detection</a></span></h4>
      
      <p>In certain output functions and in the output of return values in
        the shell, Erlang tries to detect string data in lists and binaries
        heuristically. Typically you will see heuristic detection in a
        situation like this:</p>

      <div class="example"><pre>
1&gt; <span class="bold_code bc-12">[97,98,99].</span>
"abc"
2&gt; <span class="bold_code bc-12">&lt;&lt;97,98,99&gt;&gt;.</span>
&lt;&lt;"abc"&gt;&gt;    
3&gt; <span class="bold_code bc-12">&lt;&lt;195,165,195,164,195,182&gt;&gt;.</span>
&lt;&lt;"åäö"/utf8&gt;&gt;</pre></div>

      <p>Here the shell detects lists containing printable characters or
        binaries containing printable characters in bytewise or UTF-8 encoding.
        But what is a printable character? One view is that anything the Unicode
        standard thinks is printable, is also printable according to the
        heuristic detection. The result is then that almost any list of
        integers are deemed a string, and all sorts of characters are printed,
        maybe also characters that your terminal lacks in its font set
        (resulting in some unappreciated generic output). 
        Another way is to keep it backward compatible so that only the ISO
        Latin-1 character set is used to detect a string. A third way is to let
        the user decide exactly what Unicode ranges that are to be viewed as
        characters.</p>

      <p>As from Erlang/OTP R16B you can select the ISO Latin-1 range or the
        whole Unicode range by supplying startup flag <span class="code">+pc latin1</span> or
        <span class="code">+pc unicode</span>, respectively. For backward compatibility,
        <span class="code">latin1</span> is default. This only controls how heuristic string
        detection is done. More ranges are expected to be added in the future,
        enabling tailoring of the heuristics to the language and region
        relevant to the user.</p>

      <p>The following examples show the two startup options:</p>

      <div class="example"><pre>
$ <span class="bold_code bc-12">erl +pc latin1</span>
Erlang R16B (erts-5.10.1) [source] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.10.1  (abort with ^G)  
1&gt; <span class="bold_code bc-12">[1024].</span>
[1024]
2&gt; <span class="bold_code bc-12">[1070,1085,1080,1082,1086,1076].</span>
[1070,1085,1080,1082,1086,1076]
3&gt; <span class="bold_code bc-12">[229,228,246].</span>
"åäö"
4&gt; <span class="bold_code bc-12">&lt;&lt;208,174,208,189,208,184,208,186,208,190,208,180&gt;&gt;.</span>
&lt;&lt;208,174,208,189,208,184,208,186,208,190,208,180&gt;&gt;
5&gt; <span class="bold_code bc-12">&lt;&lt;229/utf8,228/utf8,246/utf8&gt;&gt;.</span>
&lt;&lt;"åäö"/utf8&gt;&gt;</pre></div>

      <div class="example"><pre>
$ <span class="bold_code bc-12">erl +pc unicode</span>
Erlang R16B (erts-5.10.1) [source] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.10.1  (abort with ^G)  
1&gt; <span class="bold_code bc-12">[1024].</span>
"Ѐ"
2&gt; <span class="bold_code bc-12">[1070,1085,1080,1082,1086,1076].</span>
"Юникод"
3&gt; <span class="bold_code bc-12">[229,228,246].</span>
"åäö"
4&gt; <span class="bold_code bc-12">&lt;&lt;208,174,208,189,208,184,208,186,208,190,208,180&gt;&gt;.</span>
&lt;&lt;"Юникод"/utf8&gt;&gt;
5&gt; <span class="bold_code bc-12">&lt;&lt;229/utf8,228/utf8,246/utf8&gt;&gt;.</span>
&lt;&lt;"åäö"/utf8&gt;&gt;</pre></div>

      <p>In the examples, you can see that the default Erlang shell interprets
        only characters from the ISO Latin1 range as printable and only detects
        lists or binaries with those "printable" characters as containing
        string data. The valid UTF-8 binary containing the Russian word
        "Юникод", is not printed as a string. When started with all Unicode
        characters printable (<span class="code">+pc unicode</span>), the shell outputs anything
        containing printable Unicode data (in binaries, either UTF-8 or
        bytewise encoded) as string data.</p>

      <p>These heuristics are also used by
        <span class="bold_code bc-13"><a href="../../man/io.html#format-2"><span class="code">io:format/2</span></a></span>,
        <span class="bold_code bc-13"><a href="../../man/io_lib.html#format-2"><span class="code">io_lib:format/2</span></a></span>,
        and friends when modifier <span class="code">t</span> is used with <span class="code">~p</span> or
        <span class="code">~P</span>:</p>

      <div class="example"><pre>
$ <span class="bold_code bc-12">erl +pc latin1</span>
Erlang R16B (erts-5.10.1) [source] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.10.1  (abort with ^G)  
1&gt; <span class="bold_code bc-12">io:format("~tp~n",[{&lt;&lt;"åäö"&gt;&gt;, &lt;&lt;"åäö"/utf8&gt;&gt;, &lt;&lt;208,174,208,189,208,184,208,186,208,190,208,180&gt;&gt;}]).</span>
{&lt;&lt;"åäö"&gt;&gt;,&lt;&lt;"åäö"/utf8&gt;&gt;,&lt;&lt;208,174,208,189,208,184,208,186,208,190,208,180&gt;&gt;}
ok</pre></div>

      <div class="example"><pre>
$ <span class="bold_code bc-12">erl +pc unicode</span>
Erlang R16B (erts-5.10.1) [source] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.10.1  (abort with ^G)  
1&gt; <span class="bold_code bc-12">io:format("~tp~n",[{&lt;&lt;"åäö"&gt;&gt;, &lt;&lt;"åäö"/utf8&gt;&gt;, &lt;&lt;208,174,208,189,208,184,208,186,208,190,208,180&gt;&gt;}]).</span>
{&lt;&lt;"åäö"&gt;&gt;,&lt;&lt;"åäö"/utf8&gt;&gt;,&lt;&lt;"Юникод"/utf8&gt;&gt;}
ok</pre></div>

      <p>Notice that this only affects <strong>heuristic</strong> interpretation of
        lists and binaries on output. For example, the <span class="code">~ts</span> format
        sequence always outputs a valid list of characters, regardless of the
        <span class="code">+pc</span> setting, as the programmer has explicitly requested string
        output.</p>
    
  

  <h3><span onMouseOver="document.getElementById('ghlink-the-interactive-shell-idm740').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-the-interactive-shell-idm740').style.visibility = 'hidden';"><span id="ghlink-the-interactive-shell-idm740" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L612" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="the-interactive-shell" href="#the-interactive-shell">3.7 
          The Interactive Shell</a></span></h3>
    
    <p>The interactive Erlang shell, when started to a terminal or started
      using command <span class="code">werl</span> on Windows, can support Unicode input and
      output.</p>

    <p>On Windows, proper operation requires that a suitable font is
      installed and selected for the Erlang application to use. If no suitable
      font is available on your system, try installing the
      <span class="bold_code bc-20"><a href="http://dejavu-fonts.org">DejaVu fonts</a></span>, which are freely
      available, and then select that font in the Erlang shell application.</p>

    <p>On Unix-like operating systems, the terminal is to be able to handle
      UTF-8 on input and output (this is done by, for example, modern versions
      of XTerm, KDE Konsole, and the Gnome terminal)
      and your locale settings must be proper. As
      an example, a <span class="code">LANG</span> environment variable can be set as follows:</p>

    <div class="example"><pre>
$ <span class="bold_code bc-12">echo $LANG</span>
en_US.UTF-8</pre></div>

    <p>Most systems handle variable <span class="code">LC_CTYPE</span> before <span class="code">LANG</span>, so if
      that is set, it must be set to <span class="code">UTF-8</span>:</p>

    <div class="example"><pre>
$ echo <span class="bold_code bc-12">$LC_CTYPE</span>
en_US.UTF-8</pre></div>

    <p>The <span class="code">LANG</span> or <span class="code">LC_CTYPE</span> setting are to be consistent with
      what the terminal is capable of. There is no portable way for Erlang to
      ask the terminal about its UTF-8 capacity, we have to rely on the
      language and character type settings.</p>

    <p>To investigate what Erlang thinks about the terminal, the call
      <span class="bold_code bc-13"><a href="../../man/io.html#getopts-1"><span class="code">io:getopts()</span></a></span>
      can be used when the shell is started:</p>

    <div class="example"><pre>
$ <span class="bold_code bc-12">LC_CTYPE=en_US.ISO-8859-1 erl</span>
Erlang R16B (erts-5.10.1) [source] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.10.1  (abort with ^G)
1&gt; <span class="bold_code bc-12">lists:keyfind(encoding, 1, io:getopts()).</span>
{encoding,latin1}
2&gt; <span class="bold_code bc-12">q().</span>
ok
$ <span class="bold_code bc-12">LC_CTYPE=en_US.UTF-8 erl</span>
Erlang R16B (erts-5.10.1) [source] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.10.1  (abort with ^G)
1&gt; <span class="bold_code bc-12">lists:keyfind(encoding, 1, io:getopts()).</span>
{encoding,unicode}
2&gt;</pre></div>

    <p>When (finally?) everything is in order with the locale settings, fonts.
      and the terminal emulator, you have probably found a way to input
      characters in the script you desire. For testing, the simplest way is to
      add some keyboard mappings for other languages, usually done with some
      applet in your desktop environment.</p>

    <p>In a KDE environment, select <strong>KDE Control Center (Personal
      Settings)</strong> &gt; <strong>Regional and Accessibility</strong> &gt; <strong>Keyboard
      Layout</strong>.</p>

    <p>On Windows XP, select <strong>Control Panel</strong> &gt; <strong>Regional and Language
      Options</strong>, select tab <strong>Language</strong>, and click button
      <strong>Details...</strong> in the square named <strong>Text Services and Input
      Languages</strong>.</p>

    <p>Your environment
      probably provides similar means of changing the keyboard layout. Ensure
      that you have a way to switch back and forth between keyboards easily if
      you are not used to this. For example, entering commands using a Cyrillic
      character set is not easily done in the Erlang shell.</p>

    <p>Now you are set up for some Unicode input and output. The simplest thing
      to do is to enter a string in the shell:</p>

    <div class="example"><pre>
$ <span class="bold_code bc-12">erl</span>
Erlang R16B (erts-5.10.1) [source] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.10.1  (abort with ^G)
1&gt; <span class="bold_code bc-12">lists:keyfind(encoding, 1, io:getopts()).</span>
{encoding,unicode}
2&gt; <span class="bold_code bc-12">"Юникод".</span>
"Юникод"
3&gt; <span class="bold_code bc-12">io:format("~ts~n", [v(2)]).</span>
Юникод
ok
4&gt;</pre></div>

    <p>While strings can be input as Unicode characters, the language elements
      are still limited to the ISO Latin-1 character set. Only character
      constants and strings are allowed to be beyond that range:</p>

    <div class="example"><pre>
$ <span class="bold_code bc-12">erl</span>
Erlang R16B (erts-5.10.1) [source] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.10.1  (abort with ^G)
1&gt; <span class="bold_code bc-12">$ξ.</span>
958
2&gt; <span class="bold_code bc-12">Юникод.</span>
* 1: illegal character
2&gt; </pre></div>
   

  <h3>
<a name="unicode_file_names"></a><span onMouseOver="document.getElementById('ghlink-unicode-filenames-idm791').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-unicode-filenames-idm791').style.visibility = 'hidden';"><span id="ghlink-unicode-filenames-idm791" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L721" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="unicode-filenames" href="#unicode-filenames">3.8 
          Unicode Filenames</a></span>
</h3>
    
    
    <p>Most modern operating systems support Unicode filenames in some way.
      There are many different ways to do this and Erlang by default treats the
      different approaches differently:</p>

    <dl>
      <dt><strong>Mandatory Unicode file naming</strong></dt>
      <dd>
        <p>Windows and, for most common uses, MacOS X enforce Unicode support
          for filenames. All files created in the file system have names that
          can consistently be interpreted. In MacOS X, all filenames are
          retrieved in UTF-8 encoding. In Windows, each system call handling
          filenames has a special Unicode-aware variant, giving much the same
          effect. There are no filenames on these systems that are not Unicode
          filenames. So, the default behavior of the Erlang VM is to work in
          "Unicode filename translation mode". This means that a
          filename can be specified as a Unicode list, which is automatically
          translated to the proper name encoding for the underlying operating
          system and file system.</p>
        <p>Doing, for example, a
          <span class="bold_code bc-13"><a href="../../man/file.html#list_dir-1"><span class="code">file:list_dir/1</span></a></span>
          on one of these systems can return Unicode lists with code points
          &gt; 255, depending on the content of the file system.</p>
      </dd>
      <dt><strong>Transparent file naming</strong></dt>
      <dd>
        <p>Most Unix operating systems have adopted a simpler approach, namely
          that Unicode file naming is not enforced, but by convention. Those
          systems usually use UTF-8 encoding for Unicode filenames, but do not
          enforce it. On such a system, a filename containing characters with
          code points from 128 through 255 can be named as plain ISO Latin-1 or
          use UTF-8 encoding. As no consistency is enforced, the Erlang VM
          cannot do consistent translation of all filenames.</p>
        <p>By default on such systems, Erlang starts in <span class="code">utf8</span> filename
          mode if the terminal supports UTF-8, otherwise in <span class="code">latin1</span>
          mode.</p>
        <p>In <span class="code">latin1</span> mode, filenames are bytewise encoded. This allows
          for list representation of all filenames in the system. However, a
          a file named "Östersund.txt", appears in
          <span class="bold_code bc-13"><a href="../../man/file.html#list_dir-1"><span class="code">file:list_dir/1</span></a></span>
          either as "Östersund.txt" (if the filename was encoded in bytewise
          ISO Latin-1 by the program creating the file) or more probably as
          <span class="code">[195,150,115,116,101,114,115,117,110,100]</span>, which is a list
          containing UTF-8 bytes (not what you want). If you use Unicode
          filename translation on such a system, non-UTF-8 filenames are
          ignored by functions like <span class="code">file:list_dir/1</span>. They can be
          retrieved with function
          <span class="bold_code bc-13"><a href="../../man/file.html#list_dir_all-1"><span class="code">file:list_dir_all/1</span></a></span>,
          but wrongly encoded filenames appear as "raw filenames".
        </p>
      </dd>
    </dl>

    <p>The Unicode file naming support was introduced in Erlang/OTP
    R14B01.  A VM operating in Unicode filename translation mode can
    work with files having names in any language or character set (as
    long as it is supported by the underlying operating system and
    file system). The Unicode character list is used to denote
    filenames or directory names. If the file system content is
    listed, you also get Unicode lists as return value. The support
    lies in the Kernel and STDLIB modules, which is why
    most applications (that do not explicitly require the filenames
    to be in the ISO Latin-1 range) benefit from the Unicode support
    without change.</p>

    <p>On operating systems with mandatory Unicode filenames, this means that
      you more easily conform to the filenames of other (non-Erlang)
      applications. You can also process filenames that, at least on Windows,
      were inaccessible (because of having names that could not be represented
      in ISO Latin-1). Also, you avoid creating incomprehensible filenames
      on MacOS X, as the <span class="code">vfs</span> layer of the operating system accepts all
      your filenames as UTF-8 does not rewrite them.</p>

    <p>For most systems, turning on Unicode filename translation is no problem
      even if it uses transparent file naming. Very few systems have mixed
      filename encodings. A consistent UTF-8 named system works perfectly in
      Unicode filename mode. It was still, however, considered experimental in
      Erlang/OTP R14B01 and is still not the default on such systems.</p>

    <p>Unicode filename translation is turned on with switch <span class="code">+fnu</span>. On
      Linux, a VM started without explicitly stating the filename translation
      mode defaults to <span class="code">latin1</span> as the native filename encoding. On
      Windows and MacOS X, the default behavior is that of Unicode filename
      translation. Therefore
      <span class="bold_code bc-13"><a href="../../man/file.html#native_name_encoding-0"><span class="code">file:native_name_encoding/0</span></a></span>
      by default returns <span class="code">utf8</span> on those systems (Windows does not use
      UTF-8 on the file system level, but this can safely be ignored by the
      Erlang programmer). The default behavior can, as stated earlier, be
      changed using option <span class="code">+fnu</span> or <span class="code">+fnl</span> to the VM, see the
      <span class="bold_code bc-18"><a href="../../man/erl.html"><span class="code">erl</span></a></span> program. If the VM is
      started in Unicode filename translation mode,
      <span class="code">file:native_name_encoding/0</span> returns atom <span class="code">utf8</span>. Switch
      <span class="code">+fnu</span> can be followed by <span class="code">w</span>, <span class="code">i</span>, or <span class="code">e</span> to control
      how wrongly encoded filenames are to be reported.</p>

    <ul>
      <li>
        <p><span class="code">w</span> means that a warning is sent to the <span class="code">error_logger</span>
          whenever a wrongly encoded filename is "skipped" in directory
          listings. <span class="code">w</span> is the default.</p>
      </li>
      <li>
        <p><span class="code">i</span> means that wrongly encoded filenames are silently ignored.
        </p>
      </li>
      <li>
        <p><span class="code">e</span> means that the API function returns an error whenever a
          wrongly encoded filename (or directory name) is encountered.</p>
      </li>
    </ul>

    <p>Notice that
      <span class="bold_code bc-13"><a href="../../man/file.html#read_link-1"><span class="code">file:read_link/1</span></a></span>
      always returns an error if the link points to an invalid filename.</p>

    <p>In Unicode filename mode, filenames given to BIF <span class="code">open_port/2</span> with
      option <span class="code">{spawn_executable,...}</span> are also interpreted as Unicode. So
      is the parameter list specified in option <span class="code">args</span> available when
      using <span class="code">spawn_executable</span>. The UTF-8 translation of arguments can be
      avoided using binaries, see section
      <span class="bold_code bc-17"><a href="#notes-about-raw-filenames">Notes About Raw Filenames</a></span>.
    </p>

    <p>Notice that the file encoding options specified when opening a file has
      nothing to do with the filename encoding convention. You can very well
      open files containing data encoded in UTF-8, but having filenames in
      bytewise (<span class="code">latin1</span>) encoding or conversely.</p>

    <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>Erlang drivers and NIF-shared objects still cannot be named with
      names containing code points &gt; 127. This limitation will be removed in
      a future release. However, Erlang modules can, but it is definitely not a
      good idea and is still considered experimental.</p>
    </p></div>
</div>

    <h4>
<a name="notes-about-raw-filenames"></a><span onMouseOver="document.getElementById('ghlink-notes-about-raw-filenames-idm861').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-notes-about-raw-filenames-idm861').style.visibility = 'hidden';"><span id="ghlink-notes-about-raw-filenames-idm861" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L857" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="notes-about-raw-filenames" href="#notes-about-raw-filenames">Notes About Raw Filenames</a></span>
</h4>
      
      
      <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>
	Note that raw filenames <strong>not</strong> necessarily are encoded the
	same way as on the OS level.
      </p></p></div>
</div>
      <p>Raw filenames were introduced together with Unicode filename support
        in ERTS 5.8.2 (Erlang/OTP R14B01). The reason "raw
        filenames" were introduced in the system was
	to be able to represent
        filenames, specified in different encodings on the same system,
        consistently. It can seem practical to have the VM automatically
        translate a filename that is not in UTF-8 to a list of Unicode
        characters, but this would open up for both duplicate filenames and
        other inconsistent behavior.</p>

      <p>Consider a directory containing a file named "björn" in ISO
        Latin-1, while the Erlang VM is operating in Unicode filename mode (and
        therefore expects UTF-8 file naming). The ISO Latin-1 name is not valid
        UTF-8 and one can be tempted to think that automatic conversion in, for
        example,
        <span class="bold_code bc-13"><a href="../../man/file.html#list_dir-1"><span class="code">file:list_dir/1</span></a></span>
        is a good idea. But what would happen if we later tried to open the file
        and have the name as a Unicode list (magically converted from the ISO
        Latin-1 filename)? The VM converts the filename to UTF-8, as this is
        the encoding expected. Effectively this means trying to open the file
        named &lt;&lt;"björn"/utf8&gt;&gt;. This file does not exist,
        and even if it existed it would not be the same file as the one that was
        listed. We could even create two files named "björn", one
        named in UTF-8 encoding and one not. If <span class="code">file:list_dir/1</span> would
        automatically convert the ISO Latin-1 filename to a list, we would get
        two identical filenames as the result. To avoid this, we must
        differentiate between filenames that are properly encoded according to
        the Unicode file naming convention (that is, UTF-8) and filenames that
        are invalid under the encoding. By the common function
        <span class="code">file:list_dir/1</span>, the wrongly encoded filenames are ignored in
        Unicode filename translation mode, but by function
        <span class="bold_code bc-13"><a href="../../man/file.html#list_dir_all-1"><span class="code">file:list_dir_all/1</span></a></span>
        the filenames with invalid encoding are returned as "raw"
        filenames, that is, as binaries.</p> 

      <p>The <span class="code">file</span> module accepts raw filenames as input.
        <span class="code">open_port({spawn_executable, ...} ...)</span> also accepts them. As
        mentioned earlier, the arguments specified in the option list to
        <span class="code">open_port({spawn_executable, ...}  ...)</span> undergo the same
        conversion as the filenames, meaning that the executable is provided
        with arguments in UTF-8 as well. This translation is avoided
        consistently with how the filenames are treated, by giving the argument
        as a binary.</p>

      <p>To force Unicode filename translation mode on systems where this is not
        the default was considered experimental in Erlang/OTP R14B01. This was
        because the initial implementation did not ignore wrongly encoded
        filenames, so that raw filenames could spread unexpectedly throughout
        the system. As from Erlang/OTP R16B, the wrongly encoded
        filenames are only retrieved by special functions (such as
        <span class="code">file:list_dir_all/1</span>). Since the impact on existing code is
	therefore much lower it is now supported.
	Unicode filename translation is
        expected to be default in future releases.</p>

      <p>Even if you are operating without Unicode file naming translation
        automatically done by the VM, you can access and create files with
        names in UTF-8 encoding by using raw filenames encoded as UTF-8.
        Enforcing the UTF-8 encoding regardless of the mode the Erlang VM is
        started in can in some circumstances be a good idea, as the convention
        of using UTF-8 filenames is spreading.</p>
    

    <h4><span onMouseOver="document.getElementById('ghlink-notes-about-macos-x-idm882').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-notes-about-macos-x-idm882').style.visibility = 'hidden';"><span id="ghlink-notes-about-macos-x-idm882" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L927" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="notes-about-macos-x" href="#notes-about-macos-x">Notes About MacOS X</a></span></h4>
      
      <p>The <span class="code">vfs</span> layer of MacOS X enforces UTF-8 filenames in an
        aggressive way. Older versions did this by refusing to create non-UTF-8
        conforming filenames, while newer versions replace offending bytes with
        the sequence "%HH", where HH is the original character in
        hexadecimal notation. As Unicode translation is enabled by default on
        MacOS X, the only way to come up against this is to either start the VM
        with flag <span class="code">+fnl</span> or to use a raw filename in bytewise
        (<span class="code">latin1</span>) encoding. If using a raw filename, with a bytewise
        encoding containing characters from 127 through 255, to create a file,
        the file cannot be opened using the same name as the one used to create
        it. There is no remedy for this behavior, except keeping the filenames
        in the correct encoding.</p>

      <p>MacOS X reorganizes the filenames so that the representation of
        accents, and so on, uses the "combining characters". For example,
        character <span class="code">ö</span> is represented as code points <span class="code">[111,776]</span>,
        where <span class="code">111</span> is character <span class="code">o</span> and <span class="code">776</span> is the special
        accent character "Combining Diaeresis". This way of normalizing Unicode
        is otherwise very seldom used. Erlang normalizes those filenames in the
        opposite way upon retrieval, so that filenames using combining accents
        are not passed up to the Erlang application. In Erlang, filename
        "björn" is retrieved as <span class="code">[98,106,246,114,110]</span>, not as
        <span class="code">[98,106,117,776,114,110]</span>, although the file system can think
        differently. The normalization into combining accents is redone when
        accessing files, so this can usually be ignored by the Erlang
        programmer.</p>
    
  

  <h3><span onMouseOver="document.getElementById('ghlink-unicode-in-environment-and-parameters-idm896').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-unicode-in-environment-and-parameters-idm896').style.visibility = 'hidden';"><span id="ghlink-unicode-in-environment-and-parameters-idm896" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L958" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="unicode-in-environment-and-parameters" href="#unicode-in-environment-and-parameters">3.9 
          Unicode in Environment and Parameters</a></span></h3>
    
    <a name="unicode_in_environment_and_parameters"></a>
    <p>Environment variables and their interpretation are handled much in the
      same way as filenames. If Unicode filenames are enabled, environment
      variables as well as parameters to the Erlang VM are expected to be in
      Unicode.</p>

    <p>If Unicode filenames are enabled, the calls to
      <span class="bold_code bc-13"><a href="../../man/os.html#getenv-0"><span class="code">os:getenv/0,1</span></a></span>,
      <span class="bold_code bc-13"><a href="../../man/os.html#putenv-2"><span class="code">os:putenv/2</span></a></span>, and
      <span class="bold_code bc-13"><a href="../../man/os.html#unsetenv-1"><span class="code">os:unsetenv/1</span></a></span>
      handle Unicode strings. On Unix-like platforms, the built-in functions
      translate environment variables in UTF-8 to/from Unicode strings, possibly
      with code points &gt; 255. On Windows, the Unicode versions of the
      environment system API are used, and code points &gt; 255 are allowed.</p>
    <p>On Unix-like operating systems, parameters are expected to be UTF-8
      without translation if Unicode filenames are enabled.</p>
  

  <h3><span onMouseOver="document.getElementById('ghlink-unicode-aware-modules-idm908').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-unicode-aware-modules-idm908').style.visibility = 'hidden';"><span id="ghlink-unicode-aware-modules-idm908" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L978" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="unicode-aware-modules" href="#unicode-aware-modules">3.10 
          Unicode-Aware Modules</a></span></h3>
    
    <p>Most of the modules in Erlang/OTP are Unicode-unaware in the sense that
      they have no notion of Unicode and should not have. Typically they handle
      non-textual or byte-oriented data (such as <span class="code">gen_tcp</span>).</p>

    <p>Modules handling textual data (such as
      <span class="bold_code bc-18"><a href="../../man/io_lib.html"><span class="code">io_lib</span></a></span> and
      <span class="bold_code bc-18"><a href="../../man/string.html"><span class="code">string</span></a></span> are sometimes
      subject to conversion or extension to be able to handle Unicode
      characters.</p>

    <p>Fortunately, most textual data has been stored in lists and range
      checking has been sparse, so modules like <span class="code">string</span> work well for
      Unicode strings with little need for conversion or extension.</p>

    <p>Some modules are, however, changed to be explicitly Unicode-aware. These
      modules include:</p>

    <dl>
      <dt><strong><span class="code">unicode</span></strong></dt>
      <dd>
        <p>The <span class="bold_code bc-18"><a href="../../man/unicode.html"><span class="code">unicode</span></a></span>
          module is clearly Unicode-aware. It contains functions for conversion
          between different Unicode formats and some utilities for identifying
          byte order marks. Few programs handling Unicode data survive without
          this module.</p>
      </dd>
      <dt><strong><span class="code">io</span></strong></dt>
      <dd>
        <p>The <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span> module has been
          extended along with the actual I/O protocol to handle Unicode data.
          This means that many functions require binaries to be in UTF-8, and
          there are modifiers to format control sequences to allow for output
          of Unicode strings.</p>
      </dd>
      <dt><strong><span class="code">file</span>, <span class="code">group</span>, <span class="code">user</span></strong></dt>
      <dd>
        <p>I/O-servers throughout the system can handle Unicode data and have
          options for converting data upon output or input to/from the device.
          As shown earlier, the
          <span class="bold_code bc-18"><a href="../../man/shell.html"><span class="code">shell</span></a></span> module has
          support for Unicode terminals and the
          <span class="bold_code bc-18"><a href="../../man/file.html"><span class="code">file</span></a></span> module
           allows for translation to and from various Unicode formats on
           disk.</p>
         <p>Reading and writing of files with Unicode data is, however, not best
           done with the <span class="code">file</span> module, as its interface is
           byte-oriented. A file opened with a Unicode encoding (like UTF-8) is
           best read or written using the
           <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span> module.</p>
      </dd>
      <dt><strong><span class="code">re</span></strong></dt>
      <dd>
        <p>The <span class="bold_code bc-18"><a href="../../man/re.html"><span class="code">re</span></a></span> module allows
          for matching Unicode strings as a special option. As the library is
          centered on matching in binaries, the Unicode support is
          UTF-8-centered.</p>
      </dd>
      <dt><strong><span class="code">wx</span></strong></dt>
      <dd>
        <p>The graphical library <span class="bold_code bc-18"><a href="../../man/wx.html"><span class="code">wx</span></a></span>
          has extensive support for Unicode text.</p>
</dd>
    </dl>

    <p>The <span class="bold_code bc-18"><a href="../../man/string.html"><span class="code">string</span></a></span>
    module works perfectly for Unicode strings and ISO Latin-1
    strings, except the language-dependent functions <span class="bold_code bc-13"><a href="../../man/string.html#uppercase-1"><span class="code">string:uppercase/1</span></a></span>
    and <span class="bold_code bc-13"><a href="../../man/string.html#lowercase-1"><span class="code">string:lowercase/1</span></a></span>.
    These two functions can never function correctly for Unicode
    characters in their current form, as there are language and locale
    issues to consider when converting text between cases.  Converting
    case in an international environment is a large subject not yet
    addressed in OTP.</p>
  

  <h3><span onMouseOver="document.getElementById('ghlink-unicode-data-in-files-idm966').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-unicode-data-in-files-idm966').style.visibility = 'hidden';"><span id="ghlink-unicode-data-in-files-idm966" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L1056" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="unicode-data-in-files" href="#unicode-data-in-files">3.11 
          Unicode Data in Files</a></span></h3>
    
    <p>Although Erlang can handle Unicode data in many forms does not
      automatically mean that the content of any file can be Unicode text. The
      external entities, such as ports and I/O servers, are not generally
      Unicode capable.</p>

    <p>Ports are always byte-oriented, so before sending data that you are not
      sure is bytewise-encoded to a port, ensure to encode it in a proper
      Unicode encoding. Sometimes this means that only part of the data must
      be encoded as, for example, UTF-8. Some parts can be binary data (like a
      length indicator) or something else that must not undergo character
      encoding, so no automatic translation is present.</p>

    <p>I/O servers behave a little differently. The I/O servers connected to
      terminals (or <span class="code">stdout</span>) can usually cope with Unicode data
      regardless of the encoding option. This is convenient when one expects
      a modern environment but do not want to crash when writing to an archaic
      terminal or pipe.</p>

    <p>A file can have an encoding option that makes it generally usable by the
      <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span> module (for example
      <span class="code">{encoding,utf8}</span>), but is by default opened as a byte-oriented file.
      The <span class="bold_code bc-18"><a href="../../man/file.html"><span class="code">file</span></a></span> module is
      byte-oriented, so only ISO Latin-1 characters can be written using that
      module. Use the <span class="code">io</span> module if Unicode data is to be output to a
      file with other <span class="code">encoding</span> than <span class="code">latin1</span> (bytewise encoding).
      It is slightly confusing that a file opened with, for example,
      <span class="code">file:open(Name,[read,{encoding,utf8}])</span> cannot be properly read
      using <span class="code">file:read(File,N)</span>, but using the <span class="code">io</span> module to retrieve
      the Unicode data from it. The reason is that <span class="code">file:read</span> and
      <span class="code">file:write</span> (and friends) are purely byte-oriented, and should be,
      as that is the way to access files other than text files, byte by byte.
      As with ports, you can write encoded data into a file by "manually"
      converting the data to the encoding of choice (using the
      <span class="bold_code bc-18"><a href="../../man/unicode.html"><span class="code">unicode</span></a></span> module or the
      bit syntax) and then output it on a bytewise (<span class="code">latin1</span>) encoded
      file.</p>

    <p>Recommendations:</p>

    <ul>
      <li>
<p>Use the
        <span class="bold_code bc-18"><a href="../../man/file.html"><span class="code">file</span></a></span> module for
        files opened for bytewise access (<span class="code">{encoding,latin1}</span>).</p>
      </li>
      <li>
<p>Use the <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span> module
        when accessing files with any other encoding (for example
        <span class="code">{encoding,uf8}</span>).</p>
      </li>
    </ul>

    <p>Functions reading Erlang syntax from files recognize the <span class="code">coding:</span>
      comment and can therefore handle Unicode data on input. When writing
      Erlang terms to a file, you are advised to insert such comments when
      applicable:</p>

    <div class="example"><pre>
$ <span class="bold_code bc-12">erl +fna +pc unicode</span>
Erlang R16B (erts-5.10.1) [source]  [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.10.1  (abort with ^G)
1&gt; <span class="bold_code bc-12">file:write_file("test.term",&lt;&lt;"%% coding: utf-8\n[{\"Юникод\",4711}].\n"/utf8&gt;&gt;).</span>
ok
2&gt; <span class="bold_code bc-12">file:consult("test.term").</span>   
{ok,[[{"Юникод",4711}]]}</pre></div>
  

  <h3><span onMouseOver="document.getElementById('ghlink-summary-of-options-idm1007').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-summary-of-options-idm1007').style.visibility = 'hidden';"><span id="ghlink-summary-of-options-idm1007" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L1124" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="summary-of-options" href="#summary-of-options">3.12 
          Summary of Options</a></span></h3>
    
    <a name="unicode_options_summary"></a>
    <p>The Unicode support is controlled by both command-line switches, some
      standard environment variables, and the OTP version you are using. Most
      options affect mainly how Unicode data is displayed, not the
      functionality of the APIs in the standard libraries. This means that
      Erlang programs usually do not need to concern themselves with these
      options, they are more for the development environment. An Erlang program
      can be written so that it works well regardless of the type of system or
      the Unicode options that are in effect.</p>

    <p>Here follows a summary of the settings affecting Unicode:</p>

    <dl>
      <dt><strong>The <span class="code">LANG</span> and <span class="code">LC_CTYPE</span> environment variables</strong></dt>
      <dd>
        <p>The language setting in the operating system mainly affects the
          shell. The terminal (that is, the group leader) operates with
          <span class="code">{encoding, unicode}</span> only if the environment tells it that
          UTF-8 is allowed. This setting is to correspond to the terminal you
          are using.</p>
        <p>The environment can also affect filename interpretation, if Erlang
          is started with flag <span class="code">+fna</span> (which is default from
          Erlang/OTP 17.0).</p>
        <p>You can check the setting of this by calling
          <span class="bold_code bc-13"><a href="../../man/io.html#getopts-1"><span class="code">io:getopts()</span></a></span>,
          which gives you an option list containing <span class="code">{encoding,unicode}</span>
          or <span class="code">{encoding,latin1}</span>.</p>
      </dd>
      <dt><strong>The <span class="code">+pc</span> {<span class="code">unicode</span>|<span class="code">latin1</span>} flag to
        <span class="bold_code bc-18"><a href="../../man/erl.html"><span class="code">erl(1)</span></a></span></strong></dt>
      <dd>
        <p>This flag affects what is interpreted as string data when doing
          heuristic string detection in the shell and in
          <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span>/
          <span class="bold_code bc-13"><a href="../../man/io_lib.html#format-2"><span class="code">io_lib:format</span></a></span>
          with the <span class="code">"~tp"</span> and <span class="code">~tP</span> formatting instructions, as
          described earlier.</p>
        <p>You can check this option by calling
          <span class="bold_code bc-13"><a href="../../man/io.html#printable_range-0"><span class="code">io:printable_range/0</span></a></span>,
          which returns <span class="code">unicode</span> or <span class="code">latin1</span>. To be compatible with
          future (expected) extensions to the settings, rather use
          <span class="bold_code bc-13"><a href="../../man/io_lib.html#printable_list-1"><span class="code">io_lib:printable_list/1</span></a></span>
          to check if a list is printable according to the setting. That
          function takes into account new possible settings returned from
          <span class="code">io:printable_range/0</span>.</p>
      </dd>
      <dt><strong>The <span class="code">+fn</span>{<span class="code">l</span>|<span class="code">u</span>|<span class="code">a</span>}
        [{<span class="code">w</span>|<span class="code">i</span>|<span class="code">e</span>}] flag to 
        <span class="bold_code bc-18"><a href="../../man/erl.html"><span class="code">erl(1)</span></a></span></strong></dt>
      <dd>
        <p>This flag affects how the filenames are to be interpreted. On
          operating systems with transparent file naming, this must be
          specified to allow for file naming in Unicode characters (and for
          correct interpretation of filenames containing characters &gt; 255).
        </p>
        <ul>
          <li>
            <p><span class="code">+fnl</span> means bytewise interpretation of filenames, which was
              the usual way to represent ISO Latin-1 filenames before UTF-8
              file naming got widespread.</p>
          </li>
          <li>
            <p><span class="code">+fnu</span> means that filenames are encoded in UTF-8, which is
              nowadays the common scheme (although not enforced).</p>
          </li>
          <li>
            <p><span class="code">+fna</span> means that you automatically select between
              <span class="code">+fnl</span> and <span class="code">+fnu</span>, based on environment variables
              <span class="code">LANG</span> and <span class="code">LC_CTYPE</span>. This is optimistic
              heuristics indeed, nothing enforces a user to have a terminal with
              the same encoding as the file system, but this is usually the
              case. This is the default on all Unix-like operating systems,
              except MacOS X.</p>
          </li>
        </ul>
        <p>The filename translation mode can be read with function
          <span class="bold_code bc-13"><a href="../../man/file.html#native_name_encoding-0"><span class="code">file:native_name_encoding/0</span></a></span>,
          which returns <span class="code">latin1</span> (bytewise encoding) or <span class="code">utf8</span>.</p>
      </dd>
      <dt><strong><span class="bold_code bc-13"><a href="../../man/epp.html#default_encoding-0"><span class="code">epp:default_encoding/0</span></a></span></strong></dt>
      <dd>
        <p>This function returns the default encoding for Erlang source files
          (if no encoding comment is present) in the currently running release.
          In Erlang/OTP R16B, <span class="code">latin1</span> (bytewise encoding) was returned.
          As from Erlang/OTP 17.0, <span class="code">utf8</span> is returned.</p>
        <p>The encoding of each file can be specified using comments as
          described in the
          <span class="bold_code bc-13"><a href="../../man/epp.html#encoding"><span class="code">epp(3)</span></a></span> module.
        </p>
      </dd>
      <dt><strong><span class="bold_code bc-13"><a href="../../man/io.html#setopts-1"><span class="code">io:setopts/1,2</span></a></span>
        and flags <span class="code">-oldshell</span>/<span class="code">-noshell</span></strong></dt>
      <dd>
        <p>When Erlang is started with <span class="code">-oldshell</span> or <span class="code">-noshell</span>, the
          I/O server for <span class="code">standard_io</span> is by default set to bytewise
          encoding, while an interactive shell defaults to what the
          environment variables says.</p>
        <p>You can set the encoding of a file or other I/O server with function
          <span class="bold_code bc-13"><a href="../../man/io.html#setopts-1"><span class="code">io:setopts/2</span></a></span>.
          This can also be set when opening a file. Setting the terminal (or
          other <span class="code">standard_io</span> server) unconditionally to option
          <span class="code">{encoding,utf8}</span> implies that UTF-8 encoded characters are
          written to the device, regardless of how Erlang was started or the
          user's environment.</p>
        <p>Opening files with option <span class="code">encoding</span> is convenient when
          writing or reading text files in a known encoding.</p>
        <p>You can retrieve the <span class="code">encoding</span> setting for an I/O server with
          function
          <span class="bold_code bc-13"><a href="../../man/io.html#getopts-1"><span class="code">io:getopts()</span></a></span>.
        </p>
      </dd>
    </dl>
  

  <h3><span onMouseOver="document.getElementById('ghlink-recipes-idm1110').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-recipes-idm1110').style.visibility = 'hidden';"><span id="ghlink-recipes-idm1110" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L1240" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="recipes" href="#recipes">3.13 
          Recipes</a></span></h3>
    
    <p>When starting with Unicode, one often stumbles over some common issues.
      This section describes some methods of dealing with Unicode data.</p>

    <h4><span onMouseOver="document.getElementById('ghlink-byte-order-marks-idm1113').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-byte-order-marks-idm1113').style.visibility = 'hidden';"><span id="ghlink-byte-order-marks-idm1113" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L1245" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="byte-order-marks" href="#byte-order-marks">Byte Order Marks</a></span></h4>
      
      <p>A common method of identifying encoding in text files is to put a Byte
        Order Mark (BOM) first in the file. The BOM is the code point 16#FEFF
        encoded in the same way as the remaining file. If such a file is to be
        read, the first few bytes (depending on encoding) are not part of the
        text. This code outlines how to open a file that is believed to
        have a BOM, and sets the files encoding and position for further
        sequential reading (preferably using the
        <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span> module).</p>

      <p>Notice that error handling is omitted from the code:</p>

      <div class="example"><pre>open_bom_file_for_reading(File) -&gt;
    {ok,F} = file:open(File,[read,binary]),
    {ok,Bin} = file:read(F,4),
    {Type,Bytes} = unicode:bom_to_encoding(Bin),
    file:position(F,Bytes),
    io:setopts(F,[{encoding,Type}]),
    {ok,F}.</pre></div>

      <p>Function
        <span class="bold_code bc-13"><a href="../../man/unicode.html#bom_to_encoding-1"><span class="code">unicode:bom_to_encoding/1</span></a></span>
        identifies the encoding from a binary of at least four bytes. It
        returns, along with a term suitable for setting the encoding of the
        file, the byte length of the BOM, so that the file position can be set
        accordingly. Notice that function
        <span class="bold_code bc-13"><a href="../../man/file.html#position-2"><span class="code">file:position/2</span></a></span>
        always works on byte-offsets, so that the byte length of the BOM is
        needed.</p>

      <p>To open a file for writing and place the BOM first is even simpler:</p>

      <div class="example"><pre>open_bom_file_for_writing(File,Encoding) -&gt;
    {ok,F} = file:open(File,[write,binary]),
    ok = file:write(File,unicode:encoding_to_bom(Encoding)),
    io:setopts(F,[{encoding,Encoding}]),
    {ok,F}.</pre></div>

      <p>The file is in both these cases then best processed using the
        <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span> module, as the functions
        in that module can handle code points beyond the ISO Latin-1 range.</p>
    

    <h4><span onMouseOver="document.getElementById('ghlink-formatted-i-o-idm1130').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-formatted-i-o-idm1130').style.visibility = 'hidden';"><span id="ghlink-formatted-i-o-idm1130" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L1291" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="formatted-i-o" href="#formatted-i-o">Formatted I/O</a></span></h4>
      
      <p>When reading and writing to Unicode-aware entities, like a
        file opened for Unicode translation, you probably want to format text
        strings using the functions in the
        <span class="bold_code bc-18"><a href="../../man/io.html"><span class="code">io</span></a></span> module or the
        <span class="bold_code bc-18"><a href="../../man/io_lib.html"><span class="code">io_lib</span></a></span> module. For
        backward compatibility reasons, these functions do not accept any list
        as a string, but require a special <strong>translation modifier</strong> when
        working with Unicode texts. The modifier is <span class="code">t</span>. When applied to
        control character <span class="code">s</span> in a formatting string, it accepts all
        Unicode code points and expects binaries to be in UTF-8:</p>

      <div class="example"><pre>
1&gt; <span class="bold_code bc-12">io:format("~ts~n",[&lt;&lt;"åäö"/utf8&gt;&gt;]).</span>
åäö
ok
2&gt; <span class="bold_code bc-12">io:format("~s~n",[&lt;&lt;"åäö"/utf8&gt;&gt;]).</span>
Ã¥Ã¤Ã¶
ok</pre></div>

      <p>Clearly, the second <span class="code">io:format/2</span> gives undesired output, as the
        UTF-8 binary is not in <span class="code">latin1</span>. For backward compatibility, the
        non-prefixed control character <span class="code">s</span> expects bytewise-encoded ISO
        Latin-1 characters in binaries and lists containing only code points
        &lt; 256.</p>

      <p>As long as the data is always lists, modifier <span class="code">t</span> can be used for
        any string, but when binary data is involved, care must be taken to
        make the correct choice of formatting characters. A bytewise-encoded
        binary is also interpreted as a string, and printed even when using
        <span class="code">~ts</span>, but it can be mistaken for a valid UTF-8 string. Avoid
        therefore using the <span class="code">~ts</span> control if the binary contains
        bytewise-encoded characters and not UTF-8.</p>

      <p>Function
        <span class="bold_code bc-13"><a href="../../man/io_lib.html#format-2"><span class="code">io_lib:format/2</span></a></span>
        behaves similarly. It is defined to return a deep list of characters
        and the output can easily be converted to binary data for outputting on
        any device by a simple
        <span class="bold_code bc-13"><a href="../../man/erlang.html#list_to_binary-1"><span class="code">erlang:list_to_binary/1</span></a></span>.
        When the translation modifier is used, the list can, however, contain
        characters that cannot be stored in one byte. The call to
        <span class="code">erlang:list_to_binary/1</span> then fails. However, if the I/O server
        you want to communicate with is Unicode-aware, the returned list can
        still be used directly:</p>

      <div class="example"><pre>
$ <span class="bold_code bc-12">erl +pc unicode</span>
Erlang R16B (erts-5.10.1) [source] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.10.1 (abort with ^G)
1&gt; <span class="bold_code bc-12">io_lib:format("~ts~n", ["Γιούνικοντ"]).</span>
["Γιούνικοντ","\n"]
2&gt; <span class="bold_code bc-12">io:put_chars(io_lib:format("~ts~n", ["Γιούνικοντ"])).</span>
Γιούνικοντ
ok</pre></div>

      <p>The Unicode string is returned as a Unicode list, which is recognized
        as such, as the Erlang shell uses the Unicode encoding (and is started
        with all Unicode characters considered printable). The Unicode list is
        valid input to function
        <span class="bold_code bc-13"><a href="../../man/io.html#put_chars-2"><span class="code">io:put_chars/2</span></a></span>,
        so data can be output on any Unicode-capable device. If the device is a
        terminal, characters are output in format <span class="code">\x{</span>H...<span class="code">}</span> if
        encoding is <span class="code">latin1</span>. Otherwise in UTF-8 (for the non-interactive
        terminal: "oldshell" or "noshell") or whatever is suitable to show the
        character properly (for an interactive terminal: the regular shell).</p>

      <p>So, you can always send Unicode data to the <span class="code">standard_io</span> device.
        Files, however, accept only Unicode code points beyond ISO Latin-1 if
        <span class="code">encoding</span> is set to something else than <span class="code">latin1</span>.</p>
    

    <h4><span onMouseOver="document.getElementById('ghlink-heuristic-identification-of-utf-8-idm1171').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-heuristic-identification-of-utf-8-idm1171').style.visibility = 'hidden';"><span id="ghlink-heuristic-identification-of-utf-8-idm1171" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L1365" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="heuristic-identification-of-utf-8" href="#heuristic-identification-of-utf-8">Heuristic Identification of UTF-8</a></span></h4>
       
      <p>While it is strongly encouraged that the encoding of characters
        in binary data is known before processing, that is not always possible.
        On a typical Linux system, there is a mix of UTF-8 and ISO Latin-1 text
        files, and there are seldom any BOMs in the files to identify them.</p>

      <p>UTF-8 is designed so that ISO Latin-1 characters with numbers beyond
        the 7-bit ASCII range are seldom considered valid when decoded as UTF-8.
        Therefore one can usually use heuristics to determine if a file is in
        UTF-8 or if it is encoded in ISO Latin-1 (one byte per character).
        The <span class="bold_code bc-18"><a href="../../man/unicode.html"><span class="code">unicode</span></a></span>
        module can be used to determine if data can be interpreted as UTF-8:</p>

      <div class="example"><pre>heuristic_encoding_bin(Bin) when is_binary(Bin) -&gt;
    case unicode:characters_to_binary(Bin,utf8,utf8) of
	Bin -&gt;
	    utf8;
	_ -&gt;
	    latin1
    end.</pre></div>

      <p>If you do not have a complete binary of the file content, you can
        instead chunk through the file and check part by part. The return-tuple
        <span class="code">{incomplete,Decoded,Rest}</span> from function
        <span class="bold_code bc-13"><a href="../../man/unicode.html#characters_to_binary-1"><span class="code">unicode:characters_to_binary/1,2,3</span></a></span>
        comes in handy. The incomplete rest from one chunk of data read from the
        file is prepended to the next chunk and we therefore avoid the problem
        of character boundaries when reading chunks of bytes in UTF-8
        encoding:</p>

      <div class="example"><pre>heuristic_encoding_file(FileName) -&gt;
    {ok,F} = file:open(FileName,[read,binary]),
    loop_through_file(F,&lt;&lt;&gt;&gt;,file:read(F,1024)).

loop_through_file(_,&lt;&lt;&gt;&gt;,eof) -&gt;
    utf8;
loop_through_file(_,_,eof) -&gt;
    latin1;
loop_through_file(F,Acc,{ok,Bin}) when is_binary(Bin) -&gt;
    case unicode:characters_to_binary([Acc,Bin]) of
	{error,_,_} -&gt;
	    latin1;
	{incomplete,_,Rest} -&gt;
	    loop_through_file(F,Rest,file:read(F,1024));
	Res when is_binary(Res) -&gt;
	    loop_through_file(F,&lt;&lt;&gt;&gt;,file:read(F,1024))
    end.</pre></div>

      <p>Another option is to try to read the whole file in UTF-8 encoding and
        see if it fails. Here we need to read the file using function
        <span class="bold_code bc-13"><a href="../../man/io.html#get_chars-3"><span class="code">io:get_chars/3</span></a></span>,
        as we have to read characters with a code point &gt; 255:</p>

      <div class="example"><pre>heuristic_encoding_file2(FileName) -&gt;
    {ok,F} = file:open(FileName,[read,binary,{encoding,utf8}]),
    loop_through_file2(F,io:get_chars(F,'',1024)).

loop_through_file2(_,eof) -&gt;
    utf8;
loop_through_file2(_,{error,_Err}) -&gt;
    latin1;
loop_through_file2(F,Bin) when is_binary(Bin) -&gt;
    loop_through_file2(F,io:get_chars(F,'',1024)).</pre></div>
    

    <h4><span onMouseOver="document.getElementById('ghlink-lists-of-utf-8-bytes-idm1187').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-lists-of-utf-8-bytes-idm1187').style.visibility = 'hidden';"><span id="ghlink-lists-of-utf-8-bytes-idm1187" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L1434" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="lists-of-utf-8-bytes" href="#lists-of-utf-8-bytes">Lists of UTF-8 Bytes</a></span></h4>
      
      <p>For various reasons, you can sometimes have a list of UTF-8
        bytes. This is not a regular string of Unicode characters, as each list
        element does not contain one character. Instead you get the "raw" UTF-8
        encoding that you have in binaries. This is easily converted to a proper
        Unicode string by first converting byte per byte into a binary, and then
        converting the binary of UTF-8 encoded characters back to a Unicode
        string:</p>

      <div class="example"><pre>utf8_list_to_string(StrangeList) -&gt;
  unicode:characters_to_list(list_to_binary(StrangeList)).</pre></div>
    

    <h4><span onMouseOver="document.getElementById('ghlink-double-utf-8-encoding-idm1191').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-double-utf-8-encoding-idm1191').style.visibility = 'hidden';"><span id="ghlink-double-utf-8-encoding-idm1191" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/lib/stdlib/doc/src/unicode_usage.xml#L1449" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="double-utf-8-encoding" href="#double-utf-8-encoding">Double UTF-8 Encoding</a></span></h4>
      
      <p>When working with binaries, you can get the horrible "double UTF-8
        encoding", where strange characters are encoded in your binaries or
        files. In other words, you can get a UTF-8 encoded binary that for the
        second time is encoded as UTF-8. A common situation is where you read a
        file, byte by byte, but the content is already UTF-8. If you then
        convert the bytes to UTF-8, using, for example, the
        <span class="bold_code bc-18"><a href="../../man/unicode.html"><span class="code">unicode</span></a></span> module, or by
        writing to a file opened with option <span class="code">{encoding,utf8}</span>, you have
        each <strong>byte</strong> in the input file encoded as UTF-8, not each
        character of the original text (one character can have been encoded in
        many bytes). There is no real remedy for this other than to be sure of
        which data is encoded in which format, and never convert UTF-8 data
        (possibly read byte by byte from a file) into UTF-8 again.</p>

      <p>By far the most common situation where this occurs, is when you get
        lists of UTF-8 instead of proper Unicode strings, and then convert them
        to UTF-8 in a binary or on a file:</p>

      <div class="example"><pre>wrong_thing_to_do() -&gt;
  {ok,Bin} = file:read_file("an_utf8_encoded_file.txt"),
  MyList = binary_to_list(Bin), %% Wrong! It is an utf8 binary!
  {ok,C} = file:open("catastrophe.txt",[write,{encoding,utf8}]), 
  io:put_chars(C,MyList), %% Expects a Unicode string, but get UTF-8
                          %% bytes in a list!
  file:close(C). %% The file catastrophe.txt contains more or less unreadable
                 %% garbage!</pre></div>

      <p>Ensure you know what a binary contains before converting it to a
        string. If no other option exists, try heuristics:</p>

      <div class="example"><pre>if_you_can_not_know() -&gt;
  {ok,Bin} = file:read_file("maybe_utf8_encoded_file.txt"),
  MyList = case unicode:characters_to_list(Bin) of
    L when is_list(L) -&gt;
      L;
    _ -&gt;
      binary_to_list(Bin) %% The file was bytewise encoded
  end,
  %% Now we know that the list is a Unicode string, not a list of UTF-8 bytes
  {ok,G} = file:open("greatness.txt",[write,{encoding,utf8}]), 
  io:put_chars(G,MyList), %% Expects a Unicode string, which is what it gets!
  file:close(G). %% The file contains valid UTF-8 encoded Unicode characters!</pre></div>
    
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2021 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../../js/';</script><script type="text/javascript" src="../../js/highlight.js"></script>
</body>
</html>
