<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- Advanced</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<div class="erlang-logo-wrapper"><a href="../index.html"><img alt="Erlang Logo" src="../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Efficiency Guide</p>
<p class="section-subtitle">User's Guide</p>
<p class="section-version">Version 10.3.5.19</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="../pdf/otp-system-documentation.pdf">PDF</a></li>
<li><a href="../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="introduction.html">
              Top of chapter
            </a></li>
<li title="Purpose"><a href="introduction.html#purpose">Purpose</a></li>
<li title="Prerequisites"><a href="introduction.html#prerequisites">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="The Seven Myths of Erlang Performance" expanded="false">The Seven Myths of Erlang Performance<ul>
<li><a href="myths.html">
              Top of chapter
            </a></li>
<li title="Myth: Tail-Recursive Functions are Much Faster
    Than Recursive Functions"><a href="myths.html#myth--tail-recursive-functions-are-much-faster-----than-recursive-functions">Myth: Tail-Recursive Functions are Much Faster
    Than Recursive Functions</a></li>
<li title='Myth: Operator "++" is Always Bad'><a href="myths.html#myth--operator--++--is-always-bad">Myth: Operator "++" is Always Bad</a></li>
<li title="Myth: Strings are Slow"><a href="myths.html#myth--strings-are-slow">Myth: Strings are Slow</a></li>
<li title="Myth: Repairing a Dets File is Very Slow"><a href="myths.html#myth--repairing-a-dets-file-is-very-slow">Myth: Repairing a Dets File is Very Slow</a></li>
<li title="Myth: BEAM is a Stack-Based Byte-Code Virtual Machine
    (and Therefore Slow)"><a href="myths.html#myth--beam-is-a-stack-based-byte-code-virtual-machine------and-therefore-slow-">Myth: BEAM is a Stack-Based Byte-Code Virtual Machine
    (and Therefore Slow)</a></li>
<li title='Myth: Use "_" to Speed Up Your Program When a Variable
    is Not Used'><a href="myths.html#myth--use--_--to-speed-up-your-program-when-a-variable-----is-not-used">Myth: Use "_" to Speed Up Your Program When a Variable
    is Not Used</a></li>
<li title="Myth: A NIF Always Speeds Up Your Program"><a href="myths.html#myth--a-nif-always-speeds-up-your-program">Myth: A NIF Always Speeds Up Your Program</a></li>
</ul>
</li>
<li id="no" title="Common Caveats" expanded="false">Common Caveats<ul>
<li><a href="commoncaveats.html">
              Top of chapter
            </a></li>
<li title="Timer Module"><a href="commoncaveats.html#timer-module">Timer Module</a></li>
<li title="list_to_atom/1"><a href="commoncaveats.html#list_to_atom-1">list_to_atom/1</a></li>
<li title="length/1"><a href="commoncaveats.html#length-1">length/1</a></li>
<li title="setelement/3"><a href="commoncaveats.html#setelement-3">setelement/3</a></li>
<li title="size/1"><a href="commoncaveats.html#size-1">size/1</a></li>
<li title="split_binary/2"><a href="commoncaveats.html#split_binary-2">split_binary/2</a></li>
</ul>
</li>
<li id="no" title="Constructing and Matching Binaries" expanded="false">Constructing and Matching Binaries<ul>
<li><a href="binaryhandling.html">
              Top of chapter
            </a></li>
<li title="How Binaries are Implemented"><a href="binaryhandling.html#how-binaries-are-implemented">How Binaries are Implemented</a></li>
<li title="Constructing Binaries"><a href="binaryhandling.html#constructing-binaries">Constructing Binaries</a></li>
<li title="Matching Binaries"><a href="binaryhandling.html#matching-binaries">Matching Binaries</a></li>
<li title="Historical Note"><a href="binaryhandling.html#historical-note">Historical Note</a></li>
</ul>
</li>
<li id="no" title="List Handling" expanded="false">List Handling<ul>
<li><a href="listHandling.html">
              Top of chapter
            </a></li>
<li title="Creating a List"><a href="listHandling.html#creating-a-list">Creating a List</a></li>
<li title="List Comprehensions"><a href="listHandling.html#list-comprehensions">List Comprehensions</a></li>
<li title="Deep and Flat Lists"><a href="listHandling.html#deep-and-flat-lists">Deep and Flat Lists</a></li>
<li title="Recursive List Functions"><a href="listHandling.html#recursive-list-functions">Recursive List Functions</a></li>
</ul>
</li>
<li id="no" title="Functions" expanded="false">Functions<ul>
<li><a href="functions.html">
              Top of chapter
            </a></li>
<li title="Pattern Matching"><a href="functions.html#pattern-matching">Pattern Matching</a></li>
<li title="Function Calls"><a href="functions.html#function-calls">Function Calls</a></li>
<li title="Memory Usage in Recursion"><a href="functions.html#memory-usage-in-recursion">Memory Usage in Recursion</a></li>
</ul>
</li>
<li id="no" title="Tables and Databases" expanded="false">Tables and Databases<ul>
<li><a href="tablesDatabases.html">
              Top of chapter
            </a></li>
<li title="Ets, Dets, and Mnesia"><a href="tablesDatabases.html#ets,-dets,-and-mnesia">Ets, Dets, and Mnesia</a></li>
<li title="Ets-Specific"><a href="tablesDatabases.html#ets-specific">Ets-Specific</a></li>
<li title="Mnesia-Specific"><a href="tablesDatabases.html#mnesia-specific">Mnesia-Specific</a></li>
</ul>
</li>
<li id="no" title="Processes" expanded="false">Processes<ul>
<li><a href="processes.html">
              Top of chapter
            </a></li>
<li title="Creating an Erlang Process"><a href="processes.html#creating-an-erlang-process">Creating an Erlang Process</a></li>
<li title="Process Messages"><a href="processes.html#process-messages">Process Messages</a></li>
<li title="SMP Emulator"><a href="processes.html#smp-emulator">SMP Emulator</a></li>
</ul>
</li>
<li id="no" title="Drivers" expanded="false">Drivers<ul>
<li><a href="drivers.html">
              Top of chapter
            </a></li>
<li title="Drivers and Concurrency"><a href="drivers.html#drivers-and-concurrency">Drivers and Concurrency</a></li>
<li title="Avoiding Copying Binaries When Calling a Driver"><a href="drivers.html#avoiding-copying-binaries-when-calling-a-driver">Avoiding Copying Binaries When Calling a Driver</a></li>
<li title="Returning Small Binaries from a Driver"><a href="drivers.html#returning-small-binaries-from-a-driver">Returning Small Binaries from a Driver</a></li>
<li title="Returning Large Binaries without Copying from a Driver"><a href="drivers.html#returning-large-binaries-without-copying-from-a-driver">Returning Large Binaries without Copying from a Driver</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Advanced" expanded="true">Advanced<ul>
<li><a href="advanced.html">
              Top of chapter
            </a></li>
<li title="Memory"><a href="advanced.html#memory">Memory</a></li>
<li title="System Limits"><a href="advanced.html#system-limits">System Limits</a></li>
</ul>
</li>
<li id="no" title="Profiling" expanded="false">Profiling<ul>
<li><a href="profiling.html">
              Top of chapter
            </a></li>
<li title="Do Not Guess About Performance - Profile"><a href="profiling.html#do-not-guess-about-performance---profile">Do Not Guess About Performance - Profile</a></li>
<li title="Memory profiling"><a href="profiling.html#memory-profiling">Memory profiling</a></li>
<li title="Large Systems"><a href="profiling.html#large-systems">Large Systems</a></li>
<li title="What to Look For"><a href="profiling.html#what-to-look-for">What to Look For</a></li>
<li title="Tools"><a href="profiling.html#tools">Tools</a></li>
<li title="Benchmarking"><a href="profiling.html#benchmarking">Benchmarking</a></li>
</ul>
</li>
<li id="no" title="Retired Myths" expanded="false">Retired Myths<ul>
<li><a href="retired_myths.html">
              Top of chapter
            </a></li>
<li title="Myth: Funs are Slow"><a href="retired_myths.html#myth--funs-are-slow">Myth: Funs are Slow</a></li>
<li title="Myth: List Comprehensions are Slow"><a href="retired_myths.html#myth--list-comprehensions-are-slow">Myth: List Comprehensions are Slow</a></li>
<li title='Myth: List subtraction ("--" operator) is slow'><a href="retired_myths.html#myth--list-subtraction-------operator--is-slow">Myth: List subtraction ("--" operator) is slow</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>10 Advanced</h1>
  

  <h3><span onMouseOver="document.getElementById('ghlink-memory-idm964').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-memory-idm964').style.visibility = 'hidden';"><span id="ghlink-memory-idm964" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/system/doc/efficiency_guide/advanced.xml#L32" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="memory" href="#memory">10.1 
          Memory</a></span></h3>
    
    <p>A good start when programming efficiently is to know
      how much memory different data types and operations require. It is
      implementation-dependent how much memory the Erlang data types and
      other items consume, but the following table shows some figures for
      the <span class="code">erts-8.0</span> system in OTP 19.0.</p>

      <p>The unit of measurement is memory words. There exists both a
      32-bit and a 64-bit implementation. A word is therefore 4 bytes or
      8 bytes, respectively.</p>
    <div class="doc-table-wrapper">
<table class="doc-table">
<tr>
        <td align="left" valign="middle"><strong>Data Type</strong></td>
        <td align="left" valign="middle"><strong>Memory Size</strong></td>
      </tr>
<tr>
        <td align="left" valign="middle">Small integer</td>
        <td align="left" valign="middle">1 word.<br>
	On 32-bit architectures: -134217729 &lt; i &lt; 134217728
	(28 bits).<br>
	On 64-bit architectures: -576460752303423489 &lt; i &lt;
	576460752303423488 (60 bits).</td>
      </tr>
<tr>
        <td align="left" valign="middle">Large integer</td>
        <td align="left" valign="middle">3..N words.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Atom</td>
        <td align="left" valign="middle">1 word.<br>
	An atom refers into an atom table, which also consumes memory.
	The atom text is stored once for each unique atom in this table.
	The atom table is <strong>not</strong> garbage-collected.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Float</td>
        <td align="left" valign="middle">On 32-bit architectures: 4 words.<br>
	On 64-bit architectures: 3 words.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Binary</td>
        <td align="left" valign="middle">3..6 words + data (can be shared).</td>
      </tr>
<tr>
        <td align="left" valign="middle">List</td>
        <td align="left" valign="middle">1 word + 1 word per element + the size of each element.</td>
      </tr>
<tr>
        <td align="left" valign="middle">String (is the same as a list of integers)</td>
        <td align="left" valign="middle">1 word + 2 words per character.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Tuple</td>
        <td align="left" valign="middle">2 words + the size of each element.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Small Map</td>
        <td align="left" valign="middle">5 words + the size of all keys and values.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Large Map (&gt; 32 keys)</td>
        <td align="left" valign="middle">
            <span class="code">N</span> x <span class="code">F</span> words + the size of all keys and values.<br>
            <span class="code">N</span> is the number of keys in the Map.<br>
            <span class="code">F</span> is a sparsity factor that can vary between 1.6 and 1.8
            due to the probabilistic nature of the internal HAMT data structure.
        </td>
      </tr>
<tr>
        <td align="left" valign="middle">Pid</td>
        <td align="left" valign="middle">1 word for a process identifier from the current local node
	+ 5 words for a process identifier from another node.<br>
	A process identifier refers into a process table and a node table,
	which also consumes memory.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Port</td>
        <td align="left" valign="middle">1 word for a port identifier from the current local node
	+ 5 words for a port identifier from another node.<br>
	A port identifier refers into a port table and a node table,
	which also consumes memory.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Reference</td>
        <td align="left" valign="middle">On 32-bit architectures: 5 words for a reference from the
	current local node + 7 words for a reference from another
	node.<br>
	On 64-bit architectures: 4 words for a reference from the current
	local node + 6 words for a reference from another node.<br>
	A reference refers into a node table, which also consumes
	memory.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Fun</td>
        <td align="left" valign="middle">9..13 words + the size of environment.<br>
	A fun refers into a fun table, which also consumes memory.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Ets table</td>
        <td align="left" valign="middle">Initially 768 words + the size of each element (6 words +
	the size of Erlang data). The table grows when necessary.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Erlang process</td>
        <td align="left" valign="middle">338 words when spawned, including a heap of 233 words.</td>
      </tr>
</table>
<p class="doc-table-caption">Table
        10.1:
         
        Memory Size of Different Data Types</p>
</div>
  

  <h3><span onMouseOver="document.getElementById('ghlink-system-limits-idm1040').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-system-limits-idm1040').style.visibility = 'hidden';"><span id="ghlink-system-limits-idm1040" class="ghlink"><a href="https://github.com/erlang/otp/edit/maint/system/doc/efficiency_guide/advanced.xml#L143" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil"></span></a></span><a class="title_link" name="system-limits" href="#system-limits">10.2 
          System Limits</a></span></h3>
    
    <p>The Erlang language specification puts no limits on the number of
    processes, length of atoms, and so on. However, for performance and
    memory saving reasons, there will always be limits in a practical
    implementation of the Erlang language and execution environment.</p>

    <div class="doc-table-wrapper">
<table class="doc-table">
<tr>
        <td align="left" valign="middle">Processes</td>
        <td align="left" valign="middle">The maximum number of simultaneously alive Erlang processes
	is by default 262,144. This limit can be configured at startup.
	For more information, see the
	<span class="bold_code bc-13"><a href="../man/erl.html#max_processes"><span class="code">+P</span></a></span>
	command-line flag in the
	<span class="bold_code bc-18"><a href="../man/erl.html"><span class="code">erl(1)</span></a></span>
	manual page in ERTS.</td>
      </tr>
<tr>
	<td align="left" valign="middle">Known nodes</td>
	<td align="left" valign="middle">A remote node Y must be known to node X if there exists
	any pids, ports, references, or funs (Erlang data types) from Y
	on X, or if X and Y are connected. The maximum number of remote
	nodes simultaneously/ever known to a node is limited by the
	<span class="bold_code bc-17"><a href="#atoms">maximum number of atoms</a></span>
	available for node names. All data concerning remote nodes,
	except for the node name atom, are garbage-collected.</td>
      </tr>
<tr>
	<td align="left" valign="middle">Connected nodes</td>
	<td align="left" valign="middle">The maximum number of simultaneously connected nodes is
	limited by either the maximum number of simultaneously known
	remote nodes,
	<span class="bold_code bc-17"><a href="#ports">the maximum number of (Erlang) ports</a></span>
	available, or
	<span class="bold_code bc-17"><a href="#files_sockets">the maximum number of sockets</a></span>
	available.</td>
      </tr>
<tr>
	<td align="left" valign="middle">Characters in an atom</td>
	<td align="left" valign="middle">255.</td>
      </tr>
<tr>
	<td align="left" valign="middle">
<a name="atoms"></a>Atoms</td>
	<td align="left" valign="middle">By default, the maximum number of atoms is 1,048,576. This
	limit can be raised or lowered using the <span class="code">+t</span> option.</td>
      </tr>
<tr>
	<td align="left" valign="middle">Elements in a tuple</td>
	<td align="left" valign="middle">The maximum number of elements in a tuple is 16,777,215
	(24-bit unsigned integer).</td>
      </tr>
<tr>
	<td align="left" valign="middle">Size of binary</td>
	<td align="left" valign="middle">In the 32-bit implementation of Erlang, 536,870,911
	bytes is the largest binary that can be constructed or matched
	using the bit syntax. In the 64-bit implementation, the maximum
	size is 2,305,843,009,213,693,951 bytes. If the limit is
	exceeded, bit syntax construction fails with a
	<span class="code">system_limit</span> exception, while any attempt to match a
	binary that is too large fails. This limit is enforced starting
	in R11B-4.<br>
	In earlier Erlang/OTP releases, operations on too large
	binaries in general either fail or give incorrect results. In
	future releases, other operations that create binaries (such as
	<span class="code">list_to_binary/1</span>) will probably also enforce the same
	limit.</td>
      </tr>
<tr>
	<td align="left" valign="middle">Total amount of data allocated by an Erlang node</td>
	<td align="left" valign="middle">The Erlang runtime system can use the complete 32-bit
	(or 64-bit) address space, but the operating system often
	limits a single process to use less than that.</td>
      </tr>
<tr>
	<td align="left" valign="middle">Length of a node name</td>
	<td align="left" valign="middle">An Erlang node name has the form host@shortname or
	host@longname. The node name is  used as an atom within
	the system, so the maximum size of 255 holds also for the
	node name.</td>
      </tr>
<tr>
	<td align="left" valign="middle">
<a name="ports"></a>Open ports</td>
	<td align="left" valign="middle">The maximum number of simultaneously open Erlang ports is
	often by default 16,384. This limit can be configured at startup.
	For more information, see the
	<span class="bold_code bc-13"><a href="../man/erl.html#max_ports"><span class="code">+Q</span></a></span>
	command-line flag in the
	<span class="bold_code bc-18"><a href="../man/erl.html"><span class="code">erl(1)</span></a></span> manual page
	in ERTS.</td>
      </tr>
<tr>
	<td align="left" valign="middle">
<a name="files_sockets"></a>Open files and
	sockets</td>
	<td align="left" valign="middle">The maximum number of simultaneously open files and
	sockets depends on
	<span class="bold_code bc-17"><a href="#ports">the maximum number of Erlang ports</a></span>
	available, as well as on operating system-specific settings
	and limits.</td>
      </tr>
<tr>
	<td align="left" valign="middle">Number of arguments to a function or fun</td>
	<td align="left" valign="middle">255</td>
      </tr>
<tr>
        <td align="left" valign="middle">
<a name="unique_references"></a>Unique References on a Runtime System Instance</td>
        <td align="left" valign="middle">Each scheduler thread has its own set of references, and all
        other threads have a shared set of references. Each set of references
        consist of <span class="code">2⁶⁴ - 1</span> unique references. That is, the total
        amount of unique references that can be produced on a runtime
        system instance is <span class="code">(NoSchedulers + 1) × (2⁶⁴ - 1)</span>.
	<br><br>
	If a scheduler thread create a new reference each nano second,
        references will at earliest be reused after more than 584 years.
	That is, for the foreseeable future they are unique enough.</td>
      </tr>
<tr>
        <td align="left" valign="middle">
<a name="unique_integers"></a>Unique Integers on a Runtime System Instance</td>
        <td align="left" valign="middle">
	    There are two types of unique integers both created using the
            <span class="bold_code bc-13"><a href="../man/erlang.html#unique_integer-1">erlang:unique_integer()</a></span>
            BIF:
	    <br><br>
	    <strong>1.</strong> Unique integers created <strong>with</strong> the
	    <span class="code">monotonic</span> modifier consist of a set of <span class="code">2⁶⁴ - 1</span>
	    unique integers.
	    <br><br>
	    <strong>2.</strong> Unique integers created <strong>without</strong> the
	    <span class="code">monotonic</span> modifier consist of a set of <span class="code">2⁶⁴ - 1</span>
	    unique integers per scheduler thread and a set of <span class="code">2⁶⁴ - 1</span>
	    unique integers shared by other threads. That is, the total
	    amount of unique integers without the <span class="code">monotonic</span> modifier
	    is <span class="code">(NoSchedulers + 1) × (2⁶⁴ - 1)</span>.
	    <br><br>
	    If a unique integer is created each nano second, unique integers
	    will at earliest be reused after more than 584 years. That is, for
	    the foreseeable future they are unique enough.
	</td>
      </tr>
</table>
<p class="doc-table-caption">Table
        10.2:
         
        System Limits</p>
</div>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 2001-2021 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../js/';</script><script type="text/javascript" src="../js/highlight.js"></script>
</body>
</html>
