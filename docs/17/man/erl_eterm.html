<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- erl_eterm</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/erl_interface/users_guide.html">User's Guide</a><br><a href="../apps/erl_interface/index.html">Reference Manual</a><br><a href="../apps/erl_interface/release_notes.html">Release Notes</a><br><a href="../apps/erl_interface/erl_interface.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Erlang Interface</strong><br><strong>Reference Manual</strong><br><small>Version 3.7.20</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li id="no" title="ei " expanded="false">ei<ul>
<li><a href="ei.html">
                  Top of manual page
                </a></li>
<li title="ei_set_compat_rel"><a href="ei.html#ei_set_compat_rel">ei_set_compat_rel()
                </a></li>
<li title="ei_encode_version"><a href="ei.html#ei_encode_version">ei_encode_version()
                </a></li>
<li title="ei_x_encode_version"><a href="ei.html#ei_x_encode_version">ei_x_encode_version()
                </a></li>
<li title="ei_encode_long"><a href="ei.html#ei_encode_long">ei_encode_long()
                </a></li>
<li title="ei_x_encode_long"><a href="ei.html#ei_x_encode_long">ei_x_encode_long()
                </a></li>
<li title="ei_encode_ulong"><a href="ei.html#ei_encode_ulong">ei_encode_ulong()
                </a></li>
<li title="ei_x_encode_ulong"><a href="ei.html#ei_x_encode_ulong">ei_x_encode_ulong()
                </a></li>
<li title="ei_encode_longlong"><a href="ei.html#ei_encode_longlong">ei_encode_longlong()
                </a></li>
<li title="ei_x_encode_longlong"><a href="ei.html#ei_x_encode_longlong">ei_x_encode_longlong()
                </a></li>
<li title="ei_encode_ulonglong"><a href="ei.html#ei_encode_ulonglong">ei_encode_ulonglong()
                </a></li>
<li title="ei_x_encode_ulonglong"><a href="ei.html#ei_x_encode_ulonglong">ei_x_encode_ulonglong()
                </a></li>
<li title="ei_encode_bignum"><a href="ei.html#ei_encode_bignum">ei_encode_bignum()
                </a></li>
<li title="ei_x_encode_bignum"><a href="ei.html#ei_x_encode_bignum">ei_x_encode_bignum()
                </a></li>
<li title="ei_encode_double"><a href="ei.html#ei_encode_double">ei_encode_double()
                </a></li>
<li title="ei_x_encode_double"><a href="ei.html#ei_x_encode_double">ei_x_encode_double()
                </a></li>
<li title="ei_encode_boolean"><a href="ei.html#ei_encode_boolean">ei_encode_boolean()
                </a></li>
<li title="ei_x_encode_boolean"><a href="ei.html#ei_x_encode_boolean">ei_x_encode_boolean()
                </a></li>
<li title="ei_encode_char"><a href="ei.html#ei_encode_char">ei_encode_char()
                </a></li>
<li title="ei_x_encode_char"><a href="ei.html#ei_x_encode_char">ei_x_encode_char()
                </a></li>
<li title="ei_encode_string"><a href="ei.html#ei_encode_string">ei_encode_string()
                </a></li>
<li title="ei_encode_string_len"><a href="ei.html#ei_encode_string_len">ei_encode_string_len()
                </a></li>
<li title="ei_x_encode_string"><a href="ei.html#ei_x_encode_string">ei_x_encode_string()
                </a></li>
<li title="ei_x_encode_string_len"><a href="ei.html#ei_x_encode_string_len">ei_x_encode_string_len()
                </a></li>
<li title="ei_encode_atom"><a href="ei.html#ei_encode_atom">ei_encode_atom()
                </a></li>
<li title="ei_encode_atom_len"><a href="ei.html#ei_encode_atom_len">ei_encode_atom_len()
                </a></li>
<li title="ei_x_encode_atom"><a href="ei.html#ei_x_encode_atom">ei_x_encode_atom()
                </a></li>
<li title="ei_x_encode_atom_len"><a href="ei.html#ei_x_encode_atom_len">ei_x_encode_atom_len()
                </a></li>
<li title="ei_encode_atom_as"><a href="ei.html#ei_encode_atom_as">ei_encode_atom_as()
                </a></li>
<li title="ei_encode_atom_len_as"><a href="ei.html#ei_encode_atom_len_as">ei_encode_atom_len_as()
                </a></li>
<li title="ei_x_encode_atom_as"><a href="ei.html#ei_x_encode_atom_as">ei_x_encode_atom_as()
                </a></li>
<li title="ei_x_encode_atom_len_as"><a href="ei.html#ei_x_encode_atom_len_as">ei_x_encode_atom_len_as()
                </a></li>
<li title="ei_encode_binary"><a href="ei.html#ei_encode_binary">ei_encode_binary()
                </a></li>
<li title="ei_x_encode_binary"><a href="ei.html#ei_x_encode_binary">ei_x_encode_binary()
                </a></li>
<li title="ei_encode_pid"><a href="ei.html#ei_encode_pid">ei_encode_pid()
                </a></li>
<li title="ei_x_encode_pid"><a href="ei.html#ei_x_encode_pid">ei_x_encode_pid()
                </a></li>
<li title="ei_encode_fun"><a href="ei.html#ei_encode_fun">ei_encode_fun()
                </a></li>
<li title="ei_x_encode_fun"><a href="ei.html#ei_x_encode_fun">ei_x_encode_fun()
                </a></li>
<li title="ei_encode_port"><a href="ei.html#ei_encode_port">ei_encode_port()
                </a></li>
<li title="ei_x_encode_port"><a href="ei.html#ei_x_encode_port">ei_x_encode_port()
                </a></li>
<li title="ei_encode_ref"><a href="ei.html#ei_encode_ref">ei_encode_ref()
                </a></li>
<li title="ei_x_encode_ref"><a href="ei.html#ei_x_encode_ref">ei_x_encode_ref()
                </a></li>
<li title="ei_encode_term"><a href="ei.html#ei_encode_term">ei_encode_term()
                </a></li>
<li title="ei_x_encode_term"><a href="ei.html#ei_x_encode_term">ei_x_encode_term()
                </a></li>
<li title="ei_encode_trace"><a href="ei.html#ei_encode_trace">ei_encode_trace()
                </a></li>
<li title="ei_x_encode_trace"><a href="ei.html#ei_x_encode_trace">ei_x_encode_trace()
                </a></li>
<li title="ei_encode_tuple_header"><a href="ei.html#ei_encode_tuple_header">ei_encode_tuple_header()
                </a></li>
<li title="ei_x_encode_tuple_header"><a href="ei.html#ei_x_encode_tuple_header">ei_x_encode_tuple_header()
                </a></li>
<li title="ei_encode_list_header"><a href="ei.html#ei_encode_list_header">ei_encode_list_header()
                </a></li>
<li title="ei_x_encode_list_header"><a href="ei.html#ei_x_encode_list_header">ei_x_encode_list_header()
                </a></li>
<li title="ei_encode_empty_list"><a href="ei.html#ei_encode_empty_list">ei_encode_empty_list()
                </a></li>
<li title="ei_x_encode_empty_list"><a href="ei.html#ei_x_encode_empty_list">ei_x_encode_empty_list()
                </a></li>
<li title="ei_encode_map_header"><a href="ei.html#ei_encode_map_header">ei_encode_map_header()
                </a></li>
<li title="ei_x_encode_map_header"><a href="ei.html#ei_x_encode_map_header">ei_x_encode_map_header()
                </a></li>
<li title="ei_get_type"><a href="ei.html#ei_get_type">ei_get_type()
                </a></li>
<li title="ei_decode_version"><a href="ei.html#ei_decode_version">ei_decode_version()
                </a></li>
<li title="ei_decode_long"><a href="ei.html#ei_decode_long">ei_decode_long()
                </a></li>
<li title="ei_decode_ulong"><a href="ei.html#ei_decode_ulong">ei_decode_ulong()
                </a></li>
<li title="ei_decode_longlong"><a href="ei.html#ei_decode_longlong">ei_decode_longlong()
                </a></li>
<li title="ei_decode_ulonglong"><a href="ei.html#ei_decode_ulonglong">ei_decode_ulonglong()
                </a></li>
<li title="ei_decode_bignum"><a href="ei.html#ei_decode_bignum">ei_decode_bignum()
                </a></li>
<li title="ei_decode_double"><a href="ei.html#ei_decode_double">ei_decode_double()
                </a></li>
<li title="ei_decode_boolean"><a href="ei.html#ei_decode_boolean">ei_decode_boolean()
                </a></li>
<li title="ei_decode_char"><a href="ei.html#ei_decode_char">ei_decode_char()
                </a></li>
<li title="ei_decode_string"><a href="ei.html#ei_decode_string">ei_decode_string()
                </a></li>
<li title="ei_decode_atom"><a href="ei.html#ei_decode_atom">ei_decode_atom()
                </a></li>
<li title="ei_decode_atom_as"><a href="ei.html#ei_decode_atom_as">ei_decode_atom_as()
                </a></li>
<li title="ei_decode_binary"><a href="ei.html#ei_decode_binary">ei_decode_binary()
                </a></li>
<li title="ei_decode_fun"><a href="ei.html#ei_decode_fun">ei_decode_fun()
                </a></li>
<li title="free_fun"><a href="ei.html#free_fun">free_fun()
                </a></li>
<li title="ei_decode_pid"><a href="ei.html#ei_decode_pid">ei_decode_pid()
                </a></li>
<li title="ei_decode_port"><a href="ei.html#ei_decode_port">ei_decode_port()
                </a></li>
<li title="ei_decode_ref"><a href="ei.html#ei_decode_ref">ei_decode_ref()
                </a></li>
<li title="ei_decode_trace"><a href="ei.html#ei_decode_trace">ei_decode_trace()
                </a></li>
<li title="ei_decode_tuple_header"><a href="ei.html#ei_decode_tuple_header">ei_decode_tuple_header()
                </a></li>
<li title="ei_decode_list_header"><a href="ei.html#ei_decode_list_header">ei_decode_list_header()
                </a></li>
<li title="ei_decode_map_header"><a href="ei.html#ei_decode_map_header">ei_decode_map_header()
                </a></li>
<li title="ei_decode_ei_term"><a href="ei.html#ei_decode_ei_term">ei_decode_ei_term()
                </a></li>
<li title="ei_decode_term"><a href="ei.html#ei_decode_term">ei_decode_term()
                </a></li>
<li title="ei_print_term"><a href="ei.html#ei_print_term">ei_print_term()
                </a></li>
<li title="ei_s_print_term"><a href="ei.html#ei_s_print_term">ei_s_print_term()
                </a></li>
<li title="ei_x_format"><a href="ei.html#ei_x_format">ei_x_format()
                </a></li>
<li title="ei_x_format_wo_ver"><a href="ei.html#ei_x_format_wo_ver">ei_x_format_wo_ver()
                </a></li>
<li title="ei_x_new"><a href="ei.html#ei_x_new">ei_x_new()
                </a></li>
<li title="ei_x_new_with_version"><a href="ei.html#ei_x_new_with_version">ei_x_new_with_version()
                </a></li>
<li title="ei_x_free"><a href="ei.html#ei_x_free">ei_x_free()
                </a></li>
<li title="ei_x_append"><a href="ei.html#ei_x_append">ei_x_append()
                </a></li>
<li title="ei_x_append_buf"><a href="ei.html#ei_x_append_buf">ei_x_append_buf()
                </a></li>
<li title="ei_skip_term"><a href="ei.html#ei_skip_term">ei_skip_term()
                </a></li>
</ul>
</li>
<li id="no" title="ei_connect " expanded="false">ei_connect<ul>
<li><a href="ei_connect.html">
                  Top of manual page
                </a></li>
<li title="ei_connect_init"><a href="ei_connect.html#ei_connect_init">ei_connect_init()
                </a></li>
<li title="ei_connect_xinit"><a href="ei_connect.html#ei_connect_xinit">ei_connect_xinit()
                </a></li>
<li title="ei_connect"><a href="ei_connect.html#ei_connect">ei_connect()
                </a></li>
<li title="ei_xconnect"><a href="ei_connect.html#ei_xconnect">ei_xconnect()
                </a></li>
<li title="ei_connect_tmo"><a href="ei_connect.html#ei_connect_tmo">ei_connect_tmo()
                </a></li>
<li title="ei_xconnect_tmo"><a href="ei_connect.html#ei_xconnect_tmo">ei_xconnect_tmo()
                </a></li>
<li title="ei_receive"><a href="ei_connect.html#ei_receive">ei_receive()
                </a></li>
<li title="ei_receive_tmo"><a href="ei_connect.html#ei_receive_tmo">ei_receive_tmo()
                </a></li>
<li title="ei_receive_msg"><a href="ei_connect.html#ei_receive_msg">ei_receive_msg()
                </a></li>
<li title="ei_xreceive_msg"><a href="ei_connect.html#ei_xreceive_msg">ei_xreceive_msg()
                </a></li>
<li title="ei_receive_msg_tmo"><a href="ei_connect.html#ei_receive_msg_tmo">ei_receive_msg_tmo()
                </a></li>
<li title="ei_xreceive_msg_tmo"><a href="ei_connect.html#ei_xreceive_msg_tmo">ei_xreceive_msg_tmo()
                </a></li>
<li title="ei_receive_encoded"><a href="ei_connect.html#ei_receive_encoded">ei_receive_encoded()
                </a></li>
<li title="ei_receive_encoded_tmo"><a href="ei_connect.html#ei_receive_encoded_tmo">ei_receive_encoded_tmo()
                </a></li>
<li title="ei_send"><a href="ei_connect.html#ei_send">ei_send()
                </a></li>
<li title="ei_send_tmo"><a href="ei_connect.html#ei_send_tmo">ei_send_tmo()
                </a></li>
<li title="ei_send_encoded"><a href="ei_connect.html#ei_send_encoded">ei_send_encoded()
                </a></li>
<li title="ei_send_encoded_tmo"><a href="ei_connect.html#ei_send_encoded_tmo">ei_send_encoded_tmo()
                </a></li>
<li title="ei_reg_send"><a href="ei_connect.html#ei_reg_send">ei_reg_send()
                </a></li>
<li title="ei_reg_send_tmo"><a href="ei_connect.html#ei_reg_send_tmo">ei_reg_send_tmo()
                </a></li>
<li title="ei_send_reg_encoded"><a href="ei_connect.html#ei_send_reg_encoded">ei_send_reg_encoded()
                </a></li>
<li title="ei_send_reg_encoded_tmo"><a href="ei_connect.html#ei_send_reg_encoded_tmo">ei_send_reg_encoded_tmo()
                </a></li>
<li title="ei_rpc"><a href="ei_connect.html#ei_rpc">ei_rpc()
                </a></li>
<li title="ei_rpc_to"><a href="ei_connect.html#ei_rpc_to">ei_rpc_to()
                </a></li>
<li title="ei_rpc_from"><a href="ei_connect.html#ei_rpc_from">ei_rpc_from()
                </a></li>
<li title="ei_publish"><a href="ei_connect.html#ei_publish">ei_publish()
                </a></li>
<li title="ei_publish_tmo"><a href="ei_connect.html#ei_publish_tmo">ei_publish_tmo()
                </a></li>
<li title="ei_accept"><a href="ei_connect.html#ei_accept">ei_accept()
                </a></li>
<li title="ei_accept_tmo"><a href="ei_connect.html#ei_accept_tmo">ei_accept_tmo()
                </a></li>
<li title="ei_unpublish"><a href="ei_connect.html#ei_unpublish">ei_unpublish()
                </a></li>
<li title="ei_unpublish_tmo"><a href="ei_connect.html#ei_unpublish_tmo">ei_unpublish_tmo()
                </a></li>
<li title="ei_thisnodename"><a href="ei_connect.html#ei_thisnodename">ei_thisnodename()
                </a></li>
<li title="ei_thishostname"><a href="ei_connect.html#ei_thishostname">ei_thishostname()
                </a></li>
<li title="ei_thisalivename"><a href="ei_connect.html#ei_thisalivename">ei_thisalivename()
                </a></li>
<li title="ei_self"><a href="ei_connect.html#ei_self">ei_self()
                </a></li>
<li title="*ei_gethostbyname"><a href="ei_connect.html#*ei_gethostbyname">*ei_gethostbyname()
                </a></li>
<li title="*ei_gethostbyaddr"><a href="ei_connect.html#*ei_gethostbyaddr">*ei_gethostbyaddr()
                </a></li>
<li title="*ei_gethostbyname_r"><a href="ei_connect.html#*ei_gethostbyname_r">*ei_gethostbyname_r()
                </a></li>
<li title="*ei_gethostbyaddr_r"><a href="ei_connect.html#*ei_gethostbyaddr_r">*ei_gethostbyaddr_r()
                </a></li>
<li title="ei_get_tracelevel"><a href="ei_connect.html#ei_get_tracelevel">ei_get_tracelevel()
                </a></li>
<li title="ei_set_tracelevel"><a href="ei_connect.html#ei_set_tracelevel">ei_set_tracelevel()
                </a></li>
</ul>
</li>
<li id="no" title="registry " expanded="false">registry<ul>
<li><a href="registry.html">
                  Top of manual page
                </a></li>
<li title="ei_reg_open"><a href="registry.html#ei_reg_open">ei_reg_open()
                </a></li>
<li title="ei_reg_resize"><a href="registry.html#ei_reg_resize">ei_reg_resize()
                </a></li>
<li title="ei_reg_close"><a href="registry.html#ei_reg_close">ei_reg_close()
                </a></li>
<li title="ei_reg_setival"><a href="registry.html#ei_reg_setival">ei_reg_setival()
                </a></li>
<li title="ei_reg_setfval"><a href="registry.html#ei_reg_setfval">ei_reg_setfval()
                </a></li>
<li title="ei_reg_setsval"><a href="registry.html#ei_reg_setsval">ei_reg_setsval()
                </a></li>
<li title="ei_reg_setpval"><a href="registry.html#ei_reg_setpval">ei_reg_setpval()
                </a></li>
<li title="ei_reg_setval"><a href="registry.html#ei_reg_setval">ei_reg_setval()
                </a></li>
<li title="ei_reg_getival"><a href="registry.html#ei_reg_getival">ei_reg_getival()
                </a></li>
<li title="ei_reg_getfval"><a href="registry.html#ei_reg_getfval">ei_reg_getfval()
                </a></li>
<li title="ei_reg_getsval"><a href="registry.html#ei_reg_getsval">ei_reg_getsval()
                </a></li>
<li title="ei_reg_getpval"><a href="registry.html#ei_reg_getpval">ei_reg_getpval()
                </a></li>
<li title="ei_reg_getval"><a href="registry.html#ei_reg_getval">ei_reg_getval()
                </a></li>
<li title="ei_reg_markdirty"><a href="registry.html#ei_reg_markdirty">ei_reg_markdirty()
                </a></li>
<li title="ei_reg_delete"><a href="registry.html#ei_reg_delete">ei_reg_delete()
                </a></li>
<li title="ei_reg_stat"><a href="registry.html#ei_reg_stat">ei_reg_stat()
                </a></li>
<li title="ei_reg_tabstat"><a href="registry.html#ei_reg_tabstat">ei_reg_tabstat()
                </a></li>
<li title="ei_reg_dump"><a href="registry.html#ei_reg_dump">ei_reg_dump()
                </a></li>
<li title="ei_reg_restore"><a href="registry.html#ei_reg_restore">ei_reg_restore()
                </a></li>
<li title="ei_reg_purge"><a href="registry.html#ei_reg_purge">ei_reg_purge()
                </a></li>
</ul>
</li>
<li id="no" title="erl_connect " expanded="false">erl_connect<ul>
<li><a href="erl_connect.html">
                  Top of manual page
                </a></li>
<li title="erl_connect_init"><a href="erl_connect.html#erl_connect_init">erl_connect_init()
                </a></li>
<li title="erl_connect_xinit"><a href="erl_connect.html#erl_connect_xinit">erl_connect_xinit()
                </a></li>
<li title="erl_connect"><a href="erl_connect.html#erl_connect">erl_connect()
                </a></li>
<li title="erl_xconnect"><a href="erl_connect.html#erl_xconnect">erl_xconnect()
                </a></li>
<li title="erl_close_connection"><a href="erl_connect.html#erl_close_connection">erl_close_connection()
                </a></li>
<li title="erl_receive"><a href="erl_connect.html#erl_receive">erl_receive()
                </a></li>
<li title="erl_receive_msg"><a href="erl_connect.html#erl_receive_msg">erl_receive_msg()
                </a></li>
<li title="erl_xreceive_msg"><a href="erl_connect.html#erl_xreceive_msg">erl_xreceive_msg()
                </a></li>
<li title="erl_send"><a href="erl_connect.html#erl_send">erl_send()
                </a></li>
<li title="erl_reg_send"><a href="erl_connect.html#erl_reg_send">erl_reg_send()
                </a></li>
<li title="erl_rpc"><a href="erl_connect.html#erl_rpc">erl_rpc()
                </a></li>
<li title="erl_rpc_to"><a href="erl_connect.html#erl_rpc_to">erl_rpc_to()
                </a></li>
<li title="erl_rpc_from"><a href="erl_connect.html#erl_rpc_from">erl_rpc_from()
                </a></li>
<li title="erl_publish"><a href="erl_connect.html#erl_publish">erl_publish()
                </a></li>
<li title="erl_accept"><a href="erl_connect.html#erl_accept">erl_accept()
                </a></li>
<li title="erl_thiscookie"><a href="erl_connect.html#erl_thiscookie">erl_thiscookie()
                </a></li>
<li title="erl_thisnodename"><a href="erl_connect.html#erl_thisnodename">erl_thisnodename()
                </a></li>
<li title="erl_thishostname"><a href="erl_connect.html#erl_thishostname">erl_thishostname()
                </a></li>
<li title="erl_thisalivename"><a href="erl_connect.html#erl_thisalivename">erl_thisalivename()
                </a></li>
<li title="erl_thiscreation"><a href="erl_connect.html#erl_thiscreation">erl_thiscreation()
                </a></li>
<li title="erl_unpublish"><a href="erl_connect.html#erl_unpublish">erl_unpublish()
                </a></li>
<li title="*erl_gethostbyname"><a href="erl_connect.html#*erl_gethostbyname">*erl_gethostbyname()
                </a></li>
<li title="*erl_gethostbyaddr"><a href="erl_connect.html#*erl_gethostbyaddr">*erl_gethostbyaddr()
                </a></li>
<li title="*erl_gethostbyname_r"><a href="erl_connect.html#*erl_gethostbyname_r">*erl_gethostbyname_r()
                </a></li>
<li title="*erl_gethostbyaddr_r"><a href="erl_connect.html#*erl_gethostbyaddr_r">*erl_gethostbyaddr_r()
                </a></li>
</ul>
</li>
<li id="no" title="erl_error " expanded="false">erl_error<ul>
<li><a href="erl_error.html">
                  Top of manual page
                </a></li>
<li title="erl_err_msg"><a href="erl_error.html#erl_err_msg">erl_err_msg()
                </a></li>
<li title="erl_err_quit"><a href="erl_error.html#erl_err_quit">erl_err_quit()
                </a></li>
<li title="erl_err_ret"><a href="erl_error.html#erl_err_ret">erl_err_ret()
                </a></li>
<li title="erl_err_sys"><a href="erl_error.html#erl_err_sys">erl_err_sys()
                </a></li>
<li title=""><a href="erl_error.html#">erl_errno()
                </a></li>
</ul>
</li>
<li id="loadscrollpos" title="erl_eterm " expanded="true">erl_eterm<ul>
<li><a href="erl_eterm.html">
                  Top of manual page
                </a></li>
<li title="erl_cons"><a href="erl_eterm.html#erl_cons">erl_cons()
                </a></li>
<li title="erl_copy_term"><a href="erl_eterm.html#erl_copy_term">erl_copy_term()
                </a></li>
<li title="erl_element"><a href="erl_eterm.html#erl_element">erl_element()
                </a></li>
<li title="erl_init"><a href="erl_eterm.html#erl_init">erl_init()
                </a></li>
<li title="erl_hd"><a href="erl_eterm.html#erl_hd">erl_hd()
                </a></li>
<li title="erl_iolist_to_binary"><a href="erl_eterm.html#erl_iolist_to_binary">erl_iolist_to_binary()
                </a></li>
<li title="erl_iolist_to_string"><a href="erl_eterm.html#erl_iolist_to_string">erl_iolist_to_string()
                </a></li>
<li title="erl_iolist_length"><a href="erl_eterm.html#erl_iolist_length">erl_iolist_length()
                </a></li>
<li title="erl_length"><a href="erl_eterm.html#erl_length">erl_length()
                </a></li>
<li title="erl_mk_atom"><a href="erl_eterm.html#erl_mk_atom">erl_mk_atom()
                </a></li>
<li title="erl_mk_binary"><a href="erl_eterm.html#erl_mk_binary">erl_mk_binary()
                </a></li>
<li title="erl_mk_empty_list"><a href="erl_eterm.html#erl_mk_empty_list">erl_mk_empty_list()
                </a></li>
<li title="erl_mk_estring"><a href="erl_eterm.html#erl_mk_estring">erl_mk_estring()
                </a></li>
<li title="erl_mk_float"><a href="erl_eterm.html#erl_mk_float">erl_mk_float()
                </a></li>
<li title="erl_mk_int"><a href="erl_eterm.html#erl_mk_int">erl_mk_int()
                </a></li>
<li title="erl_mk_list"><a href="erl_eterm.html#erl_mk_list">erl_mk_list()
                </a></li>
<li title="erl_mk_pid"><a href="erl_eterm.html#erl_mk_pid">erl_mk_pid()
                </a></li>
<li title="erl_mk_port"><a href="erl_eterm.html#erl_mk_port">erl_mk_port()
                </a></li>
<li title="erl_mk_ref"><a href="erl_eterm.html#erl_mk_ref">erl_mk_ref()
                </a></li>
<li title="erl_mk_long_ref"><a href="erl_eterm.html#erl_mk_long_ref">erl_mk_long_ref()
                </a></li>
<li title="erl_mk_string"><a href="erl_eterm.html#erl_mk_string">erl_mk_string()
                </a></li>
<li title="erl_mk_tuple"><a href="erl_eterm.html#erl_mk_tuple">erl_mk_tuple()
                </a></li>
<li title="erl_mk_uint"><a href="erl_eterm.html#erl_mk_uint">erl_mk_uint()
                </a></li>
<li title="erl_mk_var"><a href="erl_eterm.html#erl_mk_var">erl_mk_var()
                </a></li>
<li title="erl_print_term"><a href="erl_eterm.html#erl_print_term">erl_print_term()
                </a></li>
<li title="erl_set_compat_rel"><a href="erl_eterm.html#erl_set_compat_rel">erl_set_compat_rel()
                </a></li>
<li title="erl_size"><a href="erl_eterm.html#erl_size">erl_size()
                </a></li>
<li title="erl_tl"><a href="erl_eterm.html#erl_tl">erl_tl()
                </a></li>
<li title="erl_var_content"><a href="erl_eterm.html#erl_var_content">erl_var_content()
                </a></li>
</ul>
</li>
<li id="no" title="erl_format " expanded="false">erl_format<ul>
<li><a href="erl_format.html">
                  Top of manual page
                </a></li>
<li title="erl_format"><a href="erl_format.html#erl_format">erl_format()
                </a></li>
<li title="erl_match"><a href="erl_format.html#erl_match">erl_match()
                </a></li>
</ul>
</li>
<li id="no" title="erl_global " expanded="false">erl_global<ul>
<li><a href="erl_global.html">
                  Top of manual page
                </a></li>
<li title="erl_global_names"><a href="erl_global.html#erl_global_names">erl_global_names()
                </a></li>
<li title="erl_global_register"><a href="erl_global.html#erl_global_register">erl_global_register()
                </a></li>
<li title="erl_global_unregister"><a href="erl_global.html#erl_global_unregister">erl_global_unregister()
                </a></li>
<li title="erl_global_whereis"><a href="erl_global.html#erl_global_whereis">erl_global_whereis()
                </a></li>
</ul>
</li>
<li id="no" title="erl_malloc " expanded="false">erl_malloc<ul>
<li><a href="erl_malloc.html">
                  Top of manual page
                </a></li>
<li title="erl_alloc_eterm"><a href="erl_malloc.html#erl_alloc_eterm">erl_alloc_eterm()
                </a></li>
<li title="erl_eterm_release"><a href="erl_malloc.html#erl_eterm_release">erl_eterm_release()
                </a></li>
<li title="erl_eterm_statistics"><a href="erl_malloc.html#erl_eterm_statistics">erl_eterm_statistics()
                </a></li>
<li title="erl_free_array"><a href="erl_malloc.html#erl_free_array">erl_free_array()
                </a></li>
<li title="erl_free_term"><a href="erl_malloc.html#erl_free_term">erl_free_term()
                </a></li>
<li title="erl_free_compound"><a href="erl_malloc.html#erl_free_compound">erl_free_compound()
                </a></li>
<li title="erl_malloc"><a href="erl_malloc.html#erl_malloc">erl_malloc()
                </a></li>
<li title="erl_free"><a href="erl_malloc.html#erl_free">erl_free()
                </a></li>
</ul>
</li>
<li id="no" title="erl_marshal " expanded="false">erl_marshal<ul>
<li><a href="erl_marshal.html">
                  Top of manual page
                </a></li>
<li title="erl_compare_ext"><a href="erl_marshal.html#erl_compare_ext">erl_compare_ext()
                </a></li>
<li title="erl_decode"><a href="erl_marshal.html#erl_decode">erl_decode()
                </a></li>
<li title="erl_decode_buf"><a href="erl_marshal.html#erl_decode_buf">erl_decode_buf()
                </a></li>
<li title="erl_encode"><a href="erl_marshal.html#erl_encode">erl_encode()
                </a></li>
<li title="erl_encode_buf"><a href="erl_marshal.html#erl_encode_buf">erl_encode_buf()
                </a></li>
<li title="erl_ext_size"><a href="erl_marshal.html#erl_ext_size">erl_ext_size()
                </a></li>
<li title="erl_ext_type"><a href="erl_marshal.html#erl_ext_type">erl_ext_type()
                </a></li>
<li title="erl_peek_ext"><a href="erl_marshal.html#erl_peek_ext">erl_peek_ext()
                </a></li>
<li title="erl_term_len"><a href="erl_marshal.html#erl_term_len">erl_term_len()
                </a></li>
</ul>
</li>
<li title="erl_call"><a href="erl_call.html">erl_call</a></li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>erl_eterm</h1></center>
  
  <h3>C LIBRARY</h3>
<div class="REFBODY">erl_eterm</div>
  <h3>LIBRARY SUMMARY</h3>
<div class="REFBODY">Functions for Erlang Term Construction</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>This module contains functions for creating and manipulating
      Erlang terms. </p>
    <p>An Erlang term is represented by a C structure of type
      <span class="code">ETERM</span>. Applications should not reference any fields in this
      structure directly, because it may be changed in future releases
      to provide faster and more compact term storage. Instead,
      applications should us the macros and functions provided. </p>
    <p>The following macros each take a single ETERM pointer as an
      argument. They return a non-zero value if the test is true, and 0
      otherwise:</p>
    <dl>
      <dt><strong><span class="code">ERL_IS_INTEGER(t)</span></strong></dt>
      <dd>True if <span class="code">t</span> is an integer.</dd>
      <dt><strong><span class="code">ERL_IS_UNSIGNED_INTEGER(t)</span></strong></dt>
      <dd>True if <span class="code">t</span> is an integer.</dd>
      <dt><strong><span class="code">ERL_IS_FLOAT(t)</span></strong></dt>
      <dd>True if <span class="code">t</span> is a floating point number.</dd>
      <dt><strong><span class="code">ERL_IS_ATOM(t)</span></strong></dt>
      <dd>True if <span class="code">t</span> is an atom.</dd>
      <dt><strong><span class="code">ERL_IS_PID(t)</span></strong></dt>
      <dd>True if <span class="code">t</span> is a Pid (process identifier).</dd>
      <dt><strong><span class="code">ERL_IS_PORT(t)</span></strong></dt>
      <dd>True if <span class="code">t</span> is a port.</dd>
      <dt><strong><span class="code">ERL_IS_REF(t)</span></strong></dt>
      <dd>True if <span class="code">t</span> is a reference.</dd>
      <dt><strong><span class="code">ERL_IS_TUPLE(t)</span></strong></dt>
      <dd>True if <span class="code">t</span> is a tuple.</dd>
      <dt><strong><span class="code">ERL_IS_BINARY(t)</span></strong></dt>
      <dd>True if <span class="code">t</span> is a binary.</dd>
      <dt><strong><span class="code">ERL_IS_LIST(t)</span></strong></dt>
      <dd>True if <span class="code">t</span> is a list with zero or more elements.</dd>
      <dt><strong><span class="code">ERL_IS_EMPTY_LIST(t)</span></strong></dt>
      <dd>True if <span class="code">t</span> is an empty list.</dd>
      <dt><strong><span class="code">ERL_IS_CONS(t)</span></strong></dt>
      <dd>True if <span class="code">t</span> is a list with at least one element.</dd>
    </dl>
    <p>The following macros can be used for retrieving parts of Erlang
      terms. None of these do any type checking; results are undefined
      if you pass an ETERM* containing the wrong type. For example,
      passing a tuple to ERL_ATOM_PTR() will likely result in garbage.
      </p>
    <dl>
      <dt><strong><span class="code">char *ERL_ATOM_PTR(t)</span></strong></dt>
      <dt><strong><span class="code">char *ERL_ATOM_PTR_UTF8(t)</span></strong></dt>
      <dd>A string representing atom <span class="code">t</span>.
      </dd>
      <dt><strong><span class="code">int ERL_ATOM_SIZE(t)</span></strong></dt>
      <dt><strong><span class="code">int ERL_ATOM_SIZE_UTF8(t)</span></strong></dt>
      <dd>The length (in bytes) of atom t.</dd>
      <dt><strong><span class="code">void *ERL_BIN_PTR(t)</span></strong></dt>
      <dd>A pointer to the contents of <span class="code">t</span>
</dd>
      <dt><strong><span class="code">int ERL_BIN_SIZE(t)</span></strong></dt>
      <dd>The length (in bytes) of binary object <span class="code">t</span>.</dd>
      <dt><strong><span class="code">int ERL_INT_VALUE(t)</span></strong></dt>
      <dd>The integer of <span class="code">t</span>.</dd>
      <dt><strong><span class="code">unsigned int ERL_INT_UVALUE(t)</span></strong></dt>
      <dd>The unsigned integer value of <span class="code">t</span>.</dd>
      <dt><strong><span class="code">double ERL_FLOAT_VALUE(t)</span></strong></dt>
      <dd>The floating point value of <span class="code">t</span>.</dd>
      <dt><strong><span class="code">ETERM *ERL_PID_NODE(t)</span></strong></dt>
      <dt><strong><span class="code">ETERM *ERL_PID_NODE_UTF8(t)</span></strong></dt>
      <dd>The Node in pid <span class="code">t</span>.</dd>
      <dt><strong><span class="code">int ERL_PID_NUMBER(t)</span></strong></dt>
      <dd>The sequence number in pid <span class="code">t</span>.</dd>
      <dt><strong><span class="code">int ERL_PID_SERIAL(t)</span></strong></dt>
      <dd>The serial number in pid <span class="code">t</span>.</dd>
      <dt><strong><span class="code">int ERL_PID_CREATION(t)</span></strong></dt>
      <dd>The creation number in pid <span class="code">t</span>.</dd>
      <dt><strong><span class="code">int ERL_PORT_NUMBER(t)</span></strong></dt>
      <dd>The sequence number in port <span class="code">t</span>.</dd>
      <dt><strong><span class="code">int ERL_PORT_CREATION(t)</span></strong></dt>
      <dd>The creation number in port <span class="code">t</span>.</dd>
      <dt><strong><span class="code">ETERM *ERL_PORT_NODE(t)</span></strong></dt>
      <dt><strong><span class="code">ETERM *ERL_PORT_NODE_UTF8(t)</span></strong></dt>
      <dd>The node in port <span class="code">t</span>.</dd>
      <dt><strong><span class="code">int ERL_REF_NUMBER(t)</span></strong></dt>
      <dd>The first part of the reference number in ref <span class="code">t</span>. Use
       only for compatibility.</dd>
      <dt><strong><span class="code">int ERL_REF_NUMBERS(t)</span></strong></dt>
      <dd>Pointer to the array of reference numbers in ref <span class="code">t</span>.</dd>
      <dt><strong><span class="code">int ERL_REF_LEN(t)</span></strong></dt>
      <dd>The number of used reference numbers in ref <span class="code">t</span>.</dd>
      <dt><strong><span class="code">int ERL_REF_CREATION(t)</span></strong></dt>
      <dd>The creation number in ref <span class="code">t</span>.</dd>
      <dt><strong><span class="code">int ERL_TUPLE_SIZE(t)</span></strong></dt>
      <dd>The number of elements in tuple <span class="code">t</span>.</dd>
      <dt><strong><span class="code">ETERM *ERL_CONS_HEAD(t)</span></strong></dt>
      <dd>The head element of list <span class="code">t</span>.</dd>
      <dt><strong><span class="code">ETERM *ERL_CONS_TAIL(t)</span></strong></dt>
      <dd>A List representing the tail elements of list <span class="code">t</span>.</dd>
    </dl>
  </p></div>
  <h3>EXPORTS</h3>
    <p><a name="erl_cons"><span class="bold_code">ETERM *erl_cons(head, tail)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ETERM *head;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ETERM *tail;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function concatenates two Erlang terms, prepending
          <span class="code">head</span> onto <span class="code">tail</span> and thereby creating a <span class="code">cons</span> cell.
          To make a proper list, <span class="code">tail</span> should always be a
          list or an empty list. Note that NULL is not a valid list.</p>
        <p><span class="code">head</span> is the new term to be added.</p>
        <p><span class="code">tail</span> is the existing list to which <span class="code">head</span> will
          be concatenated.</p>
        <p>The function returns a new list.</p>
        <p><span class="code">ERL_CONS_HEAD(list)</span> and <span class="code">ERL_CONS_TAIL(list)</span>
          can be used to retrieve the head and tail components
          from the list. <span class="code">erl_hd(list)</span> and <span class="code">erl_tl(list)</span> will do
          the same thing, but check that the argument really is a list.</p>
        <p>For example:</p>
        <div class="example"><pre>
ETERM *list,*anAtom,*anInt;
anAtom = erl_mk_atom("madonna");
anInt  = erl_mk_int(21);
list   = erl_mk_empty_list();
list   = erl_cons(anAtom, list);
list   = erl_cons(anInt, list);
 ... /* do some work */
erl_free_compound(list);
        </pre></div>
      </p></div>
    <p><a name="erl_copy_term"><span class="bold_code">ETERM *erl_copy_term(term)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ETERM *term;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function creates and returns a copy of the Erlang term 
          <span class="code">term</span>.</p>
      </p></div>
    <p><a name="erl_element"><span class="bold_code">ETERM *erl_element(position, tuple)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int position;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ETERM *tuple;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function extracts a specified element from an Erlang
          tuple. </p>
        <p><span class="code">position</span> specifies which element to retrieve from
          <span class="code">tuple</span>. The elements are numbered starting from 1.</p>
        <p><span class="code">tuple</span> is an Erlang term containing at least
          <span class="code">position</span> elements.</p>
        <p>The function returns a new Erlang term corresponding to the
          requested element, or NULL if <span class="code">position</span> was greater than
          the arity of <span class="code">tuple</span>.</p>
      </p></div>
    <p><a name="erl_init"><span class="bold_code">void erl_init(NULL, 0)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">void *NULL;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int 0;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <a name="erl_init"></a>
        <p>This function must be called before any of the others in 
          the <span class="code">erl_interface</span> library in order to initialize the
          library functions. The arguments must be specified as 
          <span class="code">erl_init(NULL,0)</span>.</p>
      </p></div>
    <p><a name="erl_hd"><span class="bold_code">ETERM *erl_hd(list)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ETERM *list;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Extracts the first element from a list.</p>
        <p><span class="code">list</span> is an Erlang term containing a list.</p>
        <p>The function returns an Erlang term corresponding to the
          head element in the list, or a NULL pointer if <span class="code">list</span> was
          not a list.</p>
      </p></div>
    <p><a name="erl_iolist_to_binary"><span class="bold_code">ETERM *erl_iolist_to_binary(term)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ETERM *list;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function converts an IO list to a binary term.</p>
        <p><span class="code">list</span> is an Erlang term containing a list.</p>
        <p>This function an Erlang binary term, or NULL if <span class="code">list</span>
          was not an IO list. </p>
        <p>Informally, an IO list is a deep list of characters and
          binaries which can be sent to an Erlang port. In BNF, an IO
          list is formally defined as follows: </p>
        <div class="example"><pre>
iolist ::= []
        |   Binary
        |   [iohead | iolist]
        ;
iohead ::= Binary
        |   Byte (integer in the range [0..255])
        |   iolist
        ;
        </pre></div>
      </p></div>
    <p><a name="erl_iolist_to_string"><span class="bold_code">char *erl_iolist_to_string(list)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ETERM *list;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function converts an IO list to a '\0' terminated C
          string. </p>
        <p><span class="code">list</span> is an Erlang term containing an IO list. The IO
          list must not contain the integer 0, since C strings may not
          contain this value except as a terminating marker.</p>
        <p>This function returns a pointer to a dynamically allocated
          buffer containing a string. If <span class="code">list</span> is not an IO list,
          or if <span class="code">list</span> contains the integer 0, NULL is returned. It
          is the caller's responsibility free the allocated buffer
          with <span class="code">erl_free()</span>. </p>
        <p>Refer to <span class="code">erl_iolist_to_binary()</span> for the definition of an
          IO list. </p>
      </p></div>
    <p><a name="erl_iolist_length"><span class="bold_code">int erl_iolist_length(list)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ETERM *list;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Returns the length of an IO list.
          </p>
        <p><span class="code">list</span> is an Erlang term containing an IO list. </p>
        <p>The function returns the length of <span class="code">list</span>, or -1 if
          <span class="code">list</span> is not an IO list.</p>
        <p>Refer to <span class="code">erl_iolist_to_binary()</span> for the definition of
          an IO list. </p>
      </p></div>
    <p><a name="erl_length"><span class="bold_code">int erl_length(list)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ETERM *list;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Determines the length of a proper list.</p>
        <p><span class="code">list</span> is an Erlang term containing proper list. In a
          proper list, all tails except the last point to another list
          cell, and the last tail points to an empty list.</p>
        <p>Returns -1 if <span class="code">list</span> is not a proper list.</p>
      </p></div>
    <p><a name="erl_mk_atom"><span class="bold_code">ETERM *erl_mk_atom(string)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">const char *string;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Creates an atom.</p>
        <p><span class="code">string</span> is the sequence of characters that will be
          used to create the atom.</p>
        <p>Returns an Erlang term containing an atom. Note that it is
          the callers responsibility to make sure that <span class="code">string</span>
          contains a valid name for an atom.</p>
        <p><span class="code">ERL_ATOM_PTR(atom)</span> and <span class="code">ERL_ATOM_PTR_UTF8(atom)</span>
	can be used to retrieve the atom name (as a null terminated string). <span class="code">ERL_ATOM_SIZE(atom)</span>
	and <span class="code">ERL_ATOM_SIZE_UTF8(atom)</span> returns the length of the atom name.</p>
	<div class="note">
<div class="label">Note</div>
<div class="content"><p><p>Note that the UTF8 variants were introduced in Erlang/OTP releases R16
	and the string returned by <span class="code">ERL_ATOM_PTR(atom)</span> was not null terminated on older releases.</p>
	</p></div>
</div>
      </p></div>
    <p><a name="erl_mk_binary"><span class="bold_code">ETERM *erl_mk_binary(bptr, size)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">char *bptr;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int size;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function produces an Erlang binary object from a
          buffer containing a sequence of bytes.</p>
        <p><span class="code">bptr</span> is a pointer to a buffer containing data to be converted.</p>
        <p><span class="code">size</span> indicates the length of <span class="code">bptr</span>.</p>
        <p>The function returns an Erlang binary object.</p>
        <p><span class="code">ERL_BIN_PTR(bin)</span> retrieves a pointer to
          the binary data. <span class="code">ERL_BIN_SIZE(bin)</span> retrieves the 
          size. </p>
      </p></div>
    <p><a name="erl_mk_empty_list"><span class="bold_code">ETERM *erl_mk_empty_list()</span></a><br></p>
<div class="REFBODY"><p>
        <p>This function creates and returns an empty Erlang list.
          Note that NULL is not used to represent an empty list;
          Use this function instead.</p>
      </p></div>
    <p><a name="erl_mk_estring"><span class="bold_code">ETERM *erl_mk_estring(string, len)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">char *string;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int len;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function creates a list from a sequence of bytes.</p>
        <p><span class="code">string</span> is a buffer containing a sequence of
          bytes. The buffer does not need to be zero-terminated.</p>
        <p><span class="code">len</span> is the length of <span class="code">string</span>.</p>
        <p>The function returns an Erlang list object corresponding to
          the character sequence in <span class="code">string</span>.</p>
      </p></div>
    <p><a name="erl_mk_float"><span class="bold_code">ETERM *erl_mk_float(f)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">double f;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Creates an Erlang float.</p>
        <p><span class="code">f</span> is a value to be converted to an Erlang float.</p>
        <p></p>
        <p>The function returns an Erlang float object with the value
          specified in <span class="code">f</span>.</p>
        <p><span class="code">ERL_FLOAT_VALUE(t)</span> can be used to retrieve the
          value from an Erlang float.</p>
      </p></div>
    <p><a name="erl_mk_int"><span class="bold_code">ETERM *erl_mk_int(n)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int n;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Creates an Erlang integer.</p>
        <p><span class="code">n</span> is a value to be converted to an Erlang integer.</p>
        <p></p>
        <p>The function returns an Erlang integer object with the
          value specified in <span class="code">n</span>.</p>
        <p><span class="code">ERL_INT_VALUE(t)</span> can be used to retrieve the value 
          value from an Erlang integer.</p>
      </p></div>
    <p><a name="erl_mk_list"><span class="bold_code">ETERM *erl_mk_list(array, arrsize)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ETERM **array;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int arrsize;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Creates an Erlang list from an array of Erlang terms, such
          that each element in the list corresponds to one element in
          the array. </p>
        <p><span class="code">array</span> is an array of Erlang terms.</p>
        <p><span class="code">arrsize</span> is the number of elements in <span class="code">array</span>.</p>
        <p>The function creates an Erlang list object, whose length
          <span class="code">arrsize</span> and whose elements are taken from the terms in
          <span class="code">array</span>.</p>
      </p></div>
    <p><a name="erl_mk_pid"><span class="bold_code">ETERM *erl_mk_pid(node, number, serial, creation)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">const char *node;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">unsigned int number;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">unsigned int serial;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">unsigned int creation;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function creates an Erlang process identifier. The
          resulting pid can be used by Erlang processes wishing to
          communicate with the C node.</p>
        <p><span class="code">node</span> is the name of the C node.</p>
        <p><span class="code">number</span>, <span class="code">serial</span> and <span class="code">creation</span> are
          arbitrary numbers. Note though, that these are limited in
          precision, so only the low 15, 3 and 2 bits of these numbers
          are actually used.</p>
        <p>The function returns an Erlang pid object.</p>
        <p><span class="code">ERL_PID_NODE(pid)</span>, <span class="code">ERL_PID_NUMBER(pid)</span>,
          <span class="code">ERL_PID_SERIAL(pid)</span> and <span class="code">ERL_PID_CREATION(pid)</span>
          can be used to retrieve the four values used to create the pid.</p>
      </p></div>
    <p><a name="erl_mk_port"><span class="bold_code">ETERM *erl_mk_port(node, number, creation)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">const char *node;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">unsigned int number;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">unsigned int creation;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function creates an Erlang port identifier. </p>
        <p><span class="code">node</span> is the name of the C node.</p>
        <p><span class="code">number</span> and <span class="code">creation</span> are arbitrary numbers.
          Note though, that these are limited in
          precision, so only the low 18 and 2 bits of these numbers
          are actually used.</p>
        <p>The function returns an Erlang port object.</p>
        <p><span class="code">ERL_PORT_NODE(port)</span>, <span class="code">ERL_PORT_NUMBER(port)</span>
          and <span class="code">ERL_PORT_CREATION</span> can be used to retrieve the three
          values used to create the port. </p>
      </p></div>
    <p><a name="erl_mk_ref"><span class="bold_code">ETERM *erl_mk_ref(node, number, creation)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">const char *node;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">unsigned int number;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">unsigned int creation;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function creates an old Erlang reference, with
          only 18 bits - use <span class="code">erl_mk_long_ref</span> instead.</p>
        <p><span class="code">node</span> is the name of the C node.</p>
        <p><span class="code">number</span> should be chosen uniquely for each reference
          created for a given C node.</p>
        <p><span class="code">creation</span> is an arbitrary number.</p>
        <p>Note  that <span class="code">number</span> and <span class="code">creation</span> are limited in
          precision, so only the low 18 and 2 bits of these numbers
          are actually used.
          </p>
        <p>The function returns an Erlang reference object.</p>
        <p><span class="code">ERL_REF_NODE(ref)</span>, <span class="code">ERL_REF_NUMBER(ref)</span>, and
          <span class="code">ERL_REF_CREATION(ref)</span> to retrieve the three values used
          to create the reference. </p>
      </p></div>
    <p><a name="erl_mk_long_ref"><span class="bold_code">ETERM *erl_mk_long_ref(node, n1, n2, n3, creation)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">const char *node;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">unsigned int n1, n2, n3;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">unsigned int creation;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function creates an Erlang reference, with 82 bits.</p>
        <p><span class="code">node</span> is the name of the C node.</p>
        <p><span class="code">n1</span>, <span class="code">n2</span> and <span class="code">n3</span> can be seen as one big number
          <span class="code">n1*2^64+n2*2^32+n3</span> which should be chosen uniquely for
          each reference
          created for a given C node.</p>
        <p><span class="code">creation</span> is an arbitrary number.</p>
        <p>Note that <span class="code">n3</span> and <span class="code">creation</span> are limited in
          precision, so only the low 18 and 2 bits of these numbers
          are actually used.
          </p>
        <p>The function returns an Erlang reference object.</p>
        <p><span class="code">ERL_REF_NODE(ref)</span>, <span class="code">ERL_REF_NUMBERS(ref)</span>,
          <span class="code">ERL_REF_LEN(ref)</span> and
          <span class="code">ERL_REF_CREATION(ref)</span> to retrieve the values used
          to create the reference. </p>
      </p></div>
    <p><a name="erl_mk_string"><span class="bold_code">ETERM *erl_mk_string(string)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">char *string;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function creates a list from a zero terminated string.</p>
        <p><span class="code">string</span> is the zero-terminated sequence of characters
          (i.e. a C string) from which the list will be created.</p>
        <p>The function returns an Erlang list.</p>
      </p></div>
    <p><a name="erl_mk_tuple"><span class="bold_code">ETERM *erl_mk_tuple(array, arrsize)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ETERM **array;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int arrsize;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Creates an Erlang tuple from an array of Erlang terms.</p>
        <p><span class="code">array</span> is an array of Erlang terms.</p>
        <p><span class="code">arrsize</span> is the number of elements in <span class="code">array</span>.</p>
        <p>The function creates an Erlang tuple, whose arity is
          <span class="code">size</span> and whose elements are taken from the terms in
          <span class="code">array</span>.</p>
        <p>To retrieve the size of a tuple, either use the
          <span class="code">erl_size</span> function (which checks the type of the checked
          term and works for a binary as well as for a tuple), or the
          <span class="code">ERL_TUPLE_SIZE(tuple)</span> returns the arity of a tuple.
          <span class="code">erl_size()</span> will do the same thing, but it checks that
          the argument really is a tuple.
          <span class="code">erl_element(index,tuple)</span> returns the element
          corresponding to a given position in the tuple. </p>
      </p></div>
    <p><a name="erl_mk_uint"><span class="bold_code">ETERM *erl_mk_uint(n)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">unsigned int n;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Creates an Erlang unsigned integer.</p>
        <p><span class="code">n</span> is a value to be converted to an Erlang
          unsigned integer.</p>
        <p></p>
        <p>The function returns an Erlang unsigned integer object with
          the value specified in <span class="code">n</span>.</p>
        <p><span class="code">ERL_INT_UVALUE(t)</span> can be used to retrieve the
          value from an Erlang unsigned integer.</p>
      </p></div>
    <p><a name="erl_mk_var"><span class="bold_code">ETERM *erl_mk_var(name)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">char *name;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function creates an unbound Erlang variable. The
          variable can later be bound through pattern matching or assignment.</p>
        <p><span class="code">name</span> specifies a name for the variable.</p>
        <p>The function returns an Erlang variable object with the
          name <span class="code">name</span>. </p>
      </p></div>
    <p><a name="erl_print_term"><span class="bold_code">int erl_print_term(stream, term)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">FILE *stream;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ETERM *term;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function prints the specified Erlang term to the given
          output stream.</p>
        <p><span class="code">stream</span> indicates where the function should send its
          output.</p>
        <p><span class="code">term</span> is the Erlang term to print.</p>
        <p>The function returns the number of characters written, or a
          negative value if there was an error.</p>
      </p></div>
    <p><a name="erl_set_compat_rel"><span class="bold_code">void erl_set_compat_rel(release_number)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">unsigned release_number;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <a name="erl_set_compat_rel"></a>
        <p>By default, the <span class="code">erl_interface</span> library is only guaranteed
          to be compatible with other Erlang/OTP components from the same
          release as the <span class="code">erl_interface</span> library itself. For example,
          <span class="code">erl_interface</span> from the OTP R10 release is not compatible
          with an Erlang emulator from the OTP R9 release by default.</p>
        <p>A call to <span class="code">erl_set_compat_rel(release_number)</span> sets the
          <span class="code">erl_interface</span> library in compatibility mode of release
          <span class="code">release_number</span>. Valid range of <span class="code">release_number</span>
          is [7, current release]. This makes it possible to
          communicate with Erlang/OTP components from earlier releases.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>If this function is called, it may only be called once
            directly after the call to the
            <span class="bold_code"><a href="#erl_init">erl_init()</a></span> function.</p>
        </p></div>
</div>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>You may run into trouble if this feature is used
            carelessly. Always make sure that all communicating
            components are either from the same Erlang/OTP release, or
            from release X and release Y where all components
            from release Y are in compatibility mode of release X.</p>
        </p></div>
</div>
      </p></div>
    <p><a name="erl_size"><span class="bold_code">int erl_size(term)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ETERM *term;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Returns the arity of an Erlang tuple, or the
          number of bytes in an Erlang binary object. </p>
        <p><span class="code">term</span> is an Erlang tuple or an Erlang binary object.</p>
        <p>The function returns the size of <span class="code">term</span> as described
          above, or -1 if <span class="code">term</span> is not one of the two supported
          types. </p>
      </p></div>
    <p><a name="erl_tl"><span class="bold_code">ETERM *erl_tl(list)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ETERM *list;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Extracts the tail from a list.</p>
        <p><span class="code">list</span> is an Erlang term containing a list.</p>
        <p>The function returns an Erlang list corresponding to the
          original list minus the first element, or NULL pointer if
          <span class="code">list</span> was not a list.</p>
      </p></div>
    <p><a name="erl_var_content"><span class="bold_code">ETERM *erl_var_content(term, name)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ETERM *term;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">char *name;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function returns the contents of the specified
          variable in an Erlang term. 
          </p>
        <p><span class="code">term</span> is an Erlang term. In order for this function
          to succeed, <span class="code">term</span> must be an Erlang variable with the
          specified name, or it must be an Erlang list or tuple
          containing a variable with the specified name. Other Erlang
          types cannot contain variables.</p>
        <p><span class="code">name</span> is the name of an Erlang variable.</p>
        <p>Returns the Erlang object corresponding to the value of
          <span class="code">name</span> in <span class="code">term</span>. If no variable with the name
          <span class="code">name</span> was found in <span class="code">term</span>, or if <span class="code">term</span> is
          not a valid Erlang term, NULL is returned.</p>
      </p></div>
  
</div>
<div class="footer">
<hr>
<p>Copyright  1998-2015 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
