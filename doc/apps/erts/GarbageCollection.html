<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="utf-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Erlang Garbage Collector</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script id="js3" type="text/javascript" src="../../../doc/js/topbar.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function setscrollpos() {
                var objf = document.getElementById('loadscrollpos');
                if (objf) {
                  document.getElementById("leftnav").firstChild.scrollTop = objf.offsetTop - 10;
                }
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //-->
</script><div class="topbar">
<div class="topbar-expand "><button onclick="toggleDisplay();"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" id="Capa_1" viewBox="0 0 54 54" width="24" height="24"><g><path style="fill:#000000;" d="M27,54c-0.552,0-1-0.448-1-1V8c0-0.552,0.448-1,1-1s1,0.448,1,1v45C28,53.552,27.552,54,27,54z"></path><path style="fill:#000000;" d="M11,25c-0.256,0-0.512-0.098-0.707-0.293c-0.391-0.391-0.391-1.023,0-1.414l16-16                                      c0.391-0.391,1.023-0.391,1.414,0s0.391,1.023,0,1.414l-16,16C11.512,24.902,11.256,25,11,25z"></path><path style="fill:#000000;" d="M43,25c-0.256,0-0.512-0.098-0.707-0.293l-16-16c-0.391-0.391-0.391-1.023,0-1.414                                      s1.023-0.391,1.414,0l16,16c0.391,0.391,0.391,1.023,0,1.414C43.512,24.902,43.256,25,43,25z"></path><path style="fill:#000000;" d="M43,2H11c-0.552,0-1-0.448-1-1s0.448-1,1-1h32c0.552,0,1,0.448,1,1S43.552,2,43,2z"></path></g></svg></button></div>
<div class="topbar-title"><h1 id="Erlang Garbage Collector">5 
                Erlang Garbage Collector</h1></div>
<div class="search-expand ">        <button id="docsearch-mobile">
            <svg fill="#000000" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 50 50" width="24" height="24"><path d="M 21 3 C 11.621094 3 4 10.621094 4 20 C 4 29.378906 11.621094 37 21 37 C 24.710938 37 28.140625 35.804688 30.9375 33.78125 L 44.09375 46.90625 L 46.90625 44.09375 L 33.90625 31.0625 C 36.460938 28.085938 38 24.222656 38 20 C 38 10.621094 30.378906 3 21 3 Z M 21 5 C 29.296875 5 36 11.703125 36 20 C 36 28.296875 29.296875 35 21 35 C 12.703125 35 6 28.296875 6 20 C 6 11.703125 12.703125 5 21 5 Z"/></svg>
        </button>
</div>
</div>
<aside class="hide-mobile" id="leftnav"><nav class="leftnav-tube"><div class="erlang-logo-wrapper"><a href="../../index.html"><img alt="Erlang Logo" src="../../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Erlang Run-Time System Application (ERTS)</p>
<p class="section-subtitle">Internal Documentation</p>
<p class="section-version">Version 12.1.2</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="index.html">Reference Manual</a></li>
<li><a href="internal_docs.html">Internal Documentation</a></li>
<li><a href="notes.html">Release Notes</a></li>
<li><a href="erts.pdf">PDF</a></li>
<li><a href="../../index.html">Top</a></li>
</ul>
<div id="docsearch"></div>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3 id="chapters">Chapters</h3>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="BeamAsm, the Erlang JIT" expanded="false">BeamAsm, the Erlang JIT<ul>
<li><a href="BeamAsm.html">
              Top of chapter
            </a></li>
<li title="Loading Code"><a href="BeamAsm.html#loading-code">Loading Code</a></li>
<li title="Running Erlang code"><a href="BeamAsm.html#running-erlang-code">Running Erlang code</a></li>
<li title="Running C code"><a href="BeamAsm.html#running-c-code">Running C code</a></li>
<li title="Tracing and NIF Loading"><a href="BeamAsm.html#tracing-and-nif-loading">Tracing and NIF Loading</a></li>
<li title="Description of each file"><a href="BeamAsm.html#description-of-each-file">Description of each file</a></li>
<li title="Linux perf support"><a href="BeamAsm.html#linux-perf-support">Linux perf support</a></li>
<li title="FAQ"><a href="BeamAsm.html#faq">FAQ</a></li>
</ul>
</li>
<li id="no" title="Carrier Migration" expanded="false">Carrier Migration<ul>
<li><a href="CarrierMigration.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="CarrierMigration.html#introduction">Introduction</a></li>
<li title="Problem"><a href="CarrierMigration.html#problem">Problem</a></li>
<li title="Solution"><a href="CarrierMigration.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Counting Instructions" expanded="false">Counting Instructions<ul><li><a href="CountingInstructions.html">
              Top of chapter
            </a></li></ul>
</li>
<li id="no" title="Delayed Dealloc" expanded="false">Delayed Dealloc<ul>
<li><a href="DelayedDealloc.html">
              Top of chapter
            </a></li>
<li title="Problem"><a href="DelayedDealloc.html#problem">Problem</a></li>
<li title="Functionality Used to Address This problem"><a href="DelayedDealloc.html#functionality-used-to-address-this-problem">Functionality Used to Address This problem</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Erlang Garbage Collector" expanded="true">Erlang Garbage Collector<ul>
<li><a href="GarbageCollection.html">
              Top of chapter
            </a></li>
<li title="Overview"><a href="GarbageCollection.html#overview">Overview</a></li>
<li title="Generational Garbage Collection"><a href="GarbageCollection.html#generational-garbage-collection">Generational Garbage Collection</a></li>
<li title="The young heap"><a href="GarbageCollection.html#the-young-heap">The young heap</a></li>
<li title="Sizing the heap"><a href="GarbageCollection.html#sizing-the-heap">Sizing the heap</a></li>
<li title="Literals"><a href="GarbageCollection.html#literals">Literals</a></li>
<li title="Binary heap"><a href="GarbageCollection.html#binary-heap">Binary heap</a></li>
<li title="Messages"><a href="GarbageCollection.html#messages">Messages</a></li>
<li title="References"><a href="GarbageCollection.html#references">References</a></li>
</ul>
</li>
<li id="no" title="Non-blocking code loading" expanded="false">Non-blocking code loading<ul>
<li><a href="CodeLoading.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="CodeLoading.html#introduction">Introduction</a></li>
<li title="The Load Phases"><a href="CodeLoading.html#the-load-phases">The Load Phases</a></li>
<li title="The Finishing Sequence"><a href="CodeLoading.html#the-finishing-sequence">The Finishing Sequence</a></li>
</ul>
</li>
<li id="no" title="Non-blocking trace setting" expanded="false">Non-blocking trace setting<ul>
<li><a href="Tracing.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="Tracing.html#introduction">Introduction</a></li>
<li title="Redesign of Breakpoint Wheel"><a href="Tracing.html#redesign-of-breakpoint-wheel">Redesign of Breakpoint Wheel</a></li>
<li title="Same Same but Different"><a href="Tracing.html#same-same-but-different">Same Same but Different</a></li>
<li title="Adding a new Breakpoint"><a href="Tracing.html#adding-a-new-breakpoint">Adding a new Breakpoint</a></li>
<li title="To Updating and Remove Breakpoints"><a href="Tracing.html#to-updating-and-remove-breakpoints">To Updating and Remove Breakpoints</a></li>
<li title="Global Tracing"><a href="Tracing.html#global-tracing">Global Tracing</a></li>
<li title="Future work"><a href="Tracing.html#future-work">Future work</a></li>
</ul>
</li>
<li id="no" title="Port Signals" expanded="false">Port Signals<ul>
<li><a href="PortSignals.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="PortSignals.html#problems">Problems</a></li>
<li title="Solution"><a href="PortSignals.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Process and Port Tables" expanded="false">Process and Port Tables<ul>
<li><a href="PTables.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="PTables.html#problems">Problems</a></li>
<li title="Solution"><a href="PTables.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Process Management Optimizations" expanded="false">Process Management Optimizations<ul>
<li><a href="ProcessManagementOptimizations.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="ProcessManagementOptimizations.html#problems">Problems</a></li>
<li title="Solution"><a href="ProcessManagementOptimizations.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Super Carrier" expanded="false">Super Carrier<ul>
<li><a href="SuperCarrier.html">
              Top of chapter
            </a></li>
<li title="Problem"><a href="SuperCarrier.html#problem">Problem</a></li>
<li title="Solution"><a href="SuperCarrier.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="The beam_makeops script" expanded="false">The beam_makeops script<ul>
<li><a href="beam_makeops.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="beam_makeops.html#introduction">Introduction</a></li>
<li title="An example: the move instruction"><a href="beam_makeops.html#an-example--the-move-instruction">An example: the move instruction</a></li>
<li title="Short overview of instruction loading for the interpreter"><a href="beam_makeops.html#short-overview-of-instruction-loading-for-the-interpreter">Short overview of instruction loading for the interpreter</a></li>
<li title="Short overview of instruction loading for BeamAsm"><a href="beam_makeops.html#short-overview-of-instruction-loading-for-beamasm">Short overview of instruction loading for BeamAsm</a></li>
<li title="Running beam_makeops"><a href="beam_makeops.html#running-beam_makeops">Running beam_makeops</a></li>
<li title="Syntax of .tab files"><a href="beam_makeops.html#syntax-of-.tab-files">Syntax of .tab files</a></li>
</ul>
</li>
<li id="no" title="Thread Progress" expanded="false">Thread Progress<ul>
<li><a href="ThreadProgress.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="ThreadProgress.html#problems">Problems</a></li>
<li title="Functionality Used to Address These Problems"><a href="ThreadProgress.html#functionality-used-to-address-these-problems">Functionality Used to Address These Problems</a></li>
<li title="Implementation of the Thread Progress Functionality"><a href="ThreadProgress.html#implementation-of-the-thread-progress-functionality">Implementation of the Thread Progress Functionality</a></li>
</ul>
</li>
</ul></nav></aside><div id="content">
<div class="innertube">
<h1 id="Erlang Garbage Collector">5 Erlang Garbage Collector</h1>


<p>
Erlang manages dynamic memory with a <span class="bold_code bc-20"><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">tracing garbage collector</a></span>. More precisely a per process generational semi-space copying collector using Cheney's copy collection algorithm together with a global large object space. (See C. J. Cheney in <span class="bold_code bc-17"><a href="#References">References</a></span>.)
</p>

<a name="Overview"></a><h3 id="overview" class="title-link" onMouseOver="document.getElementById('ghlink-overview-idm30912').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-overview-idm30912').style.visibility = 'hidden';">
<div class="title-name">5.1 
        Overview</div>
<div class="title-anchors"><span id="ghlink-overview-idm30912" class="ghlink-after"><a href="#overview" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
Each Erlang process has its own stack and heap which are allocated in the same memory block and grow towards each other. When the stack and the heap <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/beam_emu.c#L387">meet</a></span>, the garbage collector is triggered and memory is reclaimed. If not enough memory was reclaimed, the heap will grow.
</p>

<a name="Overview_Creating-Data"></a><h4 id="creating-data" class="title-link" onMouseOver="document.getElementById('ghlink-creating-data-idm30917').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-creating-data-idm30917').style.visibility = 'hidden';">
<div class="title-name">Creating Data</div>
<div class="title-anchors"><span id="ghlink-creating-data-idm30917" class="ghlink-after"><a href="#creating-data" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
Terms are created on the heap by evaluating expressions. There are two major types of terms: <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_term.h#L88-L97">immediate terms</a></span> which require no heap space (small integers, atoms, pids, port ids etc) and cons or <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_term.h#L106-L120">boxed terms</a></span> (tuple, big num, binaries etc) that do require heap space. Immediate terms do not need any heap space because they are embedded into the containing structure.
</p>

<p>
Let's look at an example that returns a tuple with the newly created data.
</p>

<div class="example example-none"><pre>data(Foo) -&gt;
   Cons = [42|Foo],
   Literal = {text, "hello world!"},
   {tag, Cons, Literal}.</pre></div>
<p>
In this example we first create a new cons cell with an integer and a tuple with some text. Then a tuple of size three wrapping the other values with an atom tag is created and returned.
</p>

<p>
On the heap tuples require a word size for each of its elements as well as for the header. Cons cells always require two words. Adding these things together, we get seven words for the tuples and 26 words for the cons cells. The string <span class="code">"hello world!"</span> is a list of cons cells and thus requires 24 words. The atom <span class="code">tag</span> and the integer <span class="code">42</span> do not require any additional heap memory since it is an <strong>immediate</strong>. Adding all the terms together, the heap space required in this example should be 33 words.
</p>

<p>
Compiling this code to beam assembly (<span class="code">erlc -S</span>) shows exactly what is happening.
</p>

<div class="example example-none"><pre>...
{test_heap,6,1}.
{put_list,{integer,42},{x,0},{x,1}}.
{put_tuple,3,{x,0}}.
{put,{atom,tag}}.
{put,{x,1}}.
{put,{literal,{text,"hello world!"}}}.
return.</pre></div>
<p>
Looking at the assembler code we can see three things: The heap requirement in this function turns out to be only six words, as seen by the <span class="code">{test_heap,6,1}</span> instruction. All the allocations are combined to a single instruction. The bulk of the data <span class="code">{text, "hello world!"}</span> is a <strong>literal</strong>. Literals, sometimes referred to as constants, are not allocated in the function since they are a part of the module and allocated at load time.
</p>

<p>
If there is not enough space available on the heap to satisfy the <span class="code">test_heap</span> instructions request for memory, then a garbage collection is initiated. It may happen immediately in the <span class="code">test_heap</span> instruction, or it can be delayed until a later time depending on what state the process is in. If the garbage collection is delayed, any memory needed will be allocated in heap fragments. Heap fragments are extra memory blocks that are a part of the young heap, but are not allocated in the contigious area where terms normally reside. See <span class="bold_code bc-17"><a href="#The-young-heap">The young heap</a></span> for more details.
</p>



<a name="Overview_The-collector"></a><h4 id="the-collector" class="title-link" onMouseOver="document.getElementById('ghlink-the-collector-idm30942').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-the-collector-idm30942').style.visibility = 'hidden';">
<div class="title-name">The collector</div>
<div class="title-anchors"><span id="ghlink-the-collector-idm30942" class="ghlink-after"><a href="#the-collector" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
Erlang has a copying semi-space garbage collector. This means that when doing a garbage collection, the terms are copied from one distinct area, called the <strong>from space</strong>, to a new clean area, called the <strong>to space</strong>. The collector starts by <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1980">scanning the root-set</a></span> (stack, registers, etc).
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/gc-start.png" class="doc-image"><p class="doc-image-caption">Figure
        5.1:
         
        Garbage collection: initial values</p>
</div>

<p>
It follows all the pointers from the root-set to the heap and copies each term word by word to the <strong>to space</strong>.
</p>

<p>
After the header word has been copied a <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.h#L45-L46">move marker</a></span> is destructively placed in it pointing to the term in the <strong>to space</strong>. Any other term that points to the already moved term will <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1125">see this move marker</a></span> and copy the referring pointer instead. For example, if the have the following Erlang code:
</p>

<div class="example example-none"><pre>foo(Arg) -&gt;
    T = {test, Arg},
    {wrapper, T, T, T}.</pre></div>
<p>
Only one copy of T exists on the heap and during the garbage collection only the first time T is encountered will it be copied.
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/gc-rootset-scan.png" class="doc-image"><p class="doc-image-caption">Figure
        5.2:
         
        Garbage collection: root set scan</p>
</div>

<p>
After <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1089">all terms</a></span> referenced by the root-set have been copied, the collector scans the <strong>to space</strong> and copies all terms that these terms reference. When scanning, the collector steps through each term on the <strong>to space</strong> and any term still referencing the <strong>from space</strong> is copied over to the <strong>to space</strong>. Some terms contain non-term data (the payload of a on heap binary for instance). When encountered by the collector, these values are simply skipped.
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/gc-heap-scan1.png" class="doc-image"><p class="doc-image-caption">Figure
        5.3:
         
        Garbage collection: heap scan</p>
</div>

<p>
Every term object we can reach is copied to the <strong>to space</strong> and stored on top off the <strong>scan stop</strong> line, and then the scan stop is moved to the end of the last object.
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/gc-heap-stop.png" class="doc-image"><p class="doc-image-caption">Figure
        5.4:
         
        Garbage collection: heap scan</p>
</div>

<p>
When <strong>scan stop</strong> marker <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1103">catches up</a></span> to the <strong>scan start</strong> marker, the garbage collection is done. At this point we can <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1206">deallocate</a></span> the entire <strong>from space</strong> and therefore reclaim the entire young heap.
</p>





<a name="Generational-Garbage-Collection"></a><h3 id="generational-garbage-collection" class="title-link" onMouseOver="document.getElementById('ghlink-generational-garbage-collection-idm30980').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-generational-garbage-collection-idm30980').style.visibility = 'hidden';">
<div class="title-name">5.2 
        Generational Garbage Collection</div>
<div class="title-anchors"><span id="ghlink-generational-garbage-collection-idm30980" class="ghlink-after"><a href="#generational-garbage-collection" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
In addition to the collection algorithm described above, the Erlang garbage collector also provides generational garbage collection. An additional heap, called the old heap, is used where the long lived data is stored. The original heap is called the young heap, or sometimes the allocation heap.
</p>

<p>
With this in mind we can look at the Erlang's garbage collection again. During the copy stage anything that should be copied to the young <strong>to space</strong> is instead copied to the old <strong>to space</strong> <strong>if</strong> it is <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1127">below the *high-watermark*</a></span>.
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/gc-watermark.png" class="doc-image"><p class="doc-image-caption">Figure
        5.5:
         
        Garbage collection: heap scan</p>
</div>

<p>
The <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_process.h#L1021">high-watermark</a></span> is placed where the previous garbage collection (described in <span class="bold_code bc-17"><a href="#Overview">Overview</a></span>) ended and we have introduced a new area called the old heap. When doing the normal garbage collection pass, any term that is located below the high-watermark is copied to the old <strong>to space</strong> instead of the young.
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/gc-watermark-2.png" class="doc-image"><p class="doc-image-caption">Figure
        5.6:
         
        Garbage collection: heap scan</p>
</div>

<p>
In the next garbage collection, any pointers to the old heap will be ignored and not scanned. This way the garbage collector does not have to scan the long-lived terms.
</p>

<p>
Generational garbage collection aims to increase performance at the expense of memory. This is achieved because only the young, smaller, heap is considered in most garbage collections.
</p>

<p>
The generational hypothesis predicts that most terms tend to die young (see D. Ungar in <span class="bold_code bc-17"><a href="#References">References</a></span>), and for an immutable language such as Erlang, young terms die even faster than in other languages. So for most usage patterns the data in the new heap will die very soon after it is allocated. This is good because it limits the amount of data copied to the old heap and also because the garbage collection algorithm used is proportional to the amount of live data on the heap.
</p>

<p>
One critical issue to note here is that any term on the young heap can reference terms on the old heap but <strong>no</strong> term on the old heap may refer to a term on the young heap. This is due to the nature of the copy algorithm. Anything referenced by an old heap term is not included in the reference tree, root-set and its followers, and hence is not copied. If it was, the data would be lost, fire and brimstone would rise to cover the earth. Fortunately, this comes naturally for Erlang because the terms are immutable and thus there can be no pointers modified on the old heap to point to the young heap.
</p>

<p>
To reclaim data from the old heap, both young and old heaps are included during the collection and copied to a common <strong>to space</strong>. Both the <strong>from space</strong> of the young and old heap are then deallocated and the procedure will start over from the beginning. This type of garbage collection is called a full sweep and is triggered when the size of the area under the high-watermark is larger than the size of the free area of the old heap. It can also be triggered by doing a manual call to <span class="bold_code bc-20"><a href="http://erlang.org/doc/man/erlang.html#garbage_collect-0">erlang:garbage_collect()</a></span>, or by running into the young garbage collection limit set by <span class="bold_code bc-20"><a href="http://erlang.org/doc/man/erlang.html#spawn_opt-4">spawn_opt(fun(),[{fullsweep_after, N}])</a></span> where N is the number of young garbage collections to do before forcing a garbage collection of both young and old heap.
</p>



<a name="The-young-heap"></a><h3 id="the-young-heap" class="title-link" onMouseOver="document.getElementById('ghlink-the-young-heap-idm31008').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-the-young-heap-idm31008').style.visibility = 'hidden';">
<div class="title-name">5.3 
        The young heap</div>
<div class="title-anchors"><span id="ghlink-the-young-heap-idm31008" class="ghlink-after"><a href="#the-young-heap" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
The young heap, or the allocation heap, consists of the stack and heap as described in the Overview. However, it also includes any heap fragments that are attached to the heap. All of the heap fragments are considered to be above the high-watermark and part of the young generation. Heap fragments contain terms that either did not fit on the heap, or were created by another process and then attached to the heap. For instance if the bif <span class="code">binary_to_term/1</span> created a term which does not fit on the current heap without doing a garbage collection, it will create a heap-fragment for the term and then schedule a garbage collection for later. Also if a message is sent to the process, the payload may be placed in a heap-fragment and that fragment is added to young heap when the message is matched in a receive clause.
</p>

<p>
This procedure differs from how it worked prior to Erlang/OTP 19.0. Before 19.0, only a contiguous memory block where the young heap and stack resided was considered to be part of the young heap. Heap fragments and messages were immediately copied into the young heap before they could be inspected by the Erlang program. The behaviour introduced in 19.0 is superior in many ways - most significantly it reduces the number of necessary copy operations and the root set for garbage collection.
</p>



<a name="Sizing-the-heap"></a><h3 id="sizing-the-heap" class="title-link" onMouseOver="document.getElementById('ghlink-sizing-the-heap-idm31014').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-sizing-the-heap-idm31014').style.visibility = 'hidden';">
<div class="title-name">5.4 
        Sizing the heap</div>
<div class="title-anchors"><span id="ghlink-sizing-the-heap-idm31014" class="ghlink-after"><a href="#sizing-the-heap" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
As mentioned in the Overview the size of the heap <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L247">grows</a></span> to accommodate more data. Heaps grow in two stages, first a <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L199-L208">variation of the Fibonacci sequence</a></span> is used starting at 233 words. Then at about 1 mega words the heap only <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L215-L227">grows in 20% increments</a></span>.
</p>

<p>
There are two occasions when the young heap grows:
</p>

<ul>
<li>
if the total size of the heap + message and heap fragments exceeds the current heap size.

</li>
<li>
if after a fullsweep, the total amount of live objects is greater than 75%.

</li>
</ul>
<p>
There are two occasions when the young heap is shrunk:
</p>

<ul>
<li>
if after a young collection, the total amount of live objects is less than 25% of the heap and the young heap is "big"

</li>
<li>
if after a fullsweep, the total amount of live objects is less than 25% of the heap.

</li>
</ul>
<p>
The old heap is always one step ahead in the heap growth stages than the young heap.
</p>



<a name="Literals"></a><h3 id="literals" class="title-link" onMouseOver="document.getElementById('ghlink-literals-idm31030').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-literals-idm31030').style.visibility = 'hidden';">
<div class="title-name">5.5 
        Literals</div>
<div class="title-anchors"><span id="ghlink-literals-idm31030" class="ghlink-after"><a href="#literals" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
When garbage collecting a heap (young or old) all literals are left in place and not copied. To figure out if a term should be copied or not when doing a garbage collection the following pseudo code is used:
</p>

<div class="example example-none"><pre>if (erts_is_literal(ptr) || (on_old_heap(ptr) &amp;&amp; !fullsweep)) {
  /* literal or non fullsweep - do not copy */
} else {
  copy(ptr);
}</pre></div>
<p>
The <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/global.h#L1452-L1465">`erts_is_literal`</a></span> check works differently on different architectures and operating systems.
</p>

<p>
On 64 bit systems that allow mapping of unreserved virtual memory areas (most operating systems except Windows), an area of size 1 GB (by default) is mapped and then all literals are placed within that area. Then all that has to be done to determine if something is a literal or not is <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L322-L324">two quick pointer checks</a></span>. This system relies on the fact that a memory page that has not been touched yet does not take any actual space. So even if 1 GB of virtual memory is mapped, only the memory which is actually needed for literals is allocated in ram. The size of the literal area is configurable through the +MIscs erts_alloc option.
</p>

<p>
On 32 bit systems, there is not enough virtual memory space to allocate 1 GB for just literals, so instead small 256 KB sized literal regions are created on demand and a card mark bit-array of the entire 32 bit memory space is then used to determine if a term is a literal or not. Since the total memory space is only 32 bits, the card mark bit-array is only 256 words large. On a 64 bit system the same bit-array would have to be 1 tera words large, so this technique is only viable on 32 bit systems. Doing <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L316-L319">lookups in the array</a></span> is a little more expensive then just doing the pointer checks that can be done in 64 bit systems, but not extremely so.
</p>

<p>
On 64 bit windows, on which erts_alloc cannot do unreserved virtual memory mappings, a <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L59">special tag</a></span> within the Erlang term object is used to determine if something <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L248-L252">is a literal or not</a></span>. This is very cheap, however, the tag is only available on 64 bit machines, and it is possible to do a great deal of other nice optimizations with this tag in the future (like for instance a more compact list implementation) so it is not used on operating systems where it is not needed.
</p>

<p>
This behaviour is different from how it worked prior to Erlang/OTP 19.0. Before 19.0 the literal check was done by checking if the pointer pointed to the young or old heap block. If it did not, then it was considered a literal. This lead to considerable overhead and strange memory usage scenarios, so it was removed in 19.0.
</p>



<a name="Binary-heap"></a><h3 id="binary-heap" class="title-link" onMouseOver="document.getElementById('ghlink-binary-heap-idm31045').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-binary-heap-idm31045').style.visibility = 'hidden';">
<div class="title-name">5.6 
        Binary heap</div>
<div class="title-anchors"><span id="ghlink-binary-heap-idm31045" class="ghlink-after"><a href="#binary-heap" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
The binary heap works as a large object space for binary terms that are greater than 64 bytes (from now on called off-heap binaries). The binary heap is <span class="bold_code bc-20"><a href="https://en.wikipedia.org/wiki/Reference_counting">reference counted</a></span> and a pointer to the off-heap binary is stored on the process heap. To keep track of when to decrement the reference counter of the off-heap binary, a linked list (the MSO - mark and sweep object list) containing funs and externals as well as off-heap binaries is woven through the heap. After a garbage collection is done, the <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2299">MSO list is swept</a></span> and any off-heap binary that does not have a <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2325">move marker</a></span> written into the header words has its reference <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2344-L2367">decremented and is potentially freed</a></span>.
</p>

<p>
All items in the MSO list are ordered by the time they were added to the process heap, so when doing a minor garbage collection, the MSO sweeper only has to sweep until it <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2369">encounters an off-heap binary that is on the old heap</a></span>.
</p>

<a name="Binary-heap_Virtual-Binary-heap"></a><h4 id="virtual-binary-heap" class="title-link" onMouseOver="document.getElementById('ghlink-virtual-binary-heap-idm31055').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-virtual-binary-heap-idm31055').style.visibility = 'hidden';">
<div class="title-name">Virtual Binary heap</div>
<div class="title-anchors"><span id="ghlink-virtual-binary-heap-idm31055" class="ghlink-after"><a href="#virtual-binary-heap" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
Each process has a virtual binary heap associated with it that has the size of all the current off-heap binaries that the process has references to. The virtual binary heap also has a limit and grows and shrinks depending on how off-heap binaries are used by the process. The same growth and shrink mechanisms are used for the binary heap and for the term heap, so first a Fibonacci like series and then 20% growth.
</p>

<p>
The virtual binary heap exists in order to <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/beam_emu.c#L364">trigger</a></span> garbage collections earlier when potentially there is a very large amount of off-heap binary data that could be reclaimed. This approach does not catch all problems with binary memory not being released soon enough, but it does catch a lot of them.
</p>





<a name="Messages"></a><h3 id="messages" class="title-link" onMouseOver="document.getElementById('ghlink-messages-idm31061').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-messages-idm31061').style.visibility = 'hidden';">
<div class="title-name">5.7 
        Messages</div>
<div class="title-anchors"><span id="ghlink-messages-idm31061" class="ghlink-after"><a href="#messages" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
Messages can become a part of the process heap at different times. This depends on how the process is configured.
We can configure the behaviour of each process using <span class="code">process_flag(message_queue_data, off_heap | on_heap)</span> or we can set a default for all processes at start using the option <span class="code">+hmqd</span>.
</p>

<p>
What do these different configurations do and when should we use them?
Let's start by going through what happens when one Erlang process sends a message to another.
The sending process needs to do a couple of things:
</p>

<ol>
<li>
calculate <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_message.c#L1031">how large</a></span> the message to be sent is

</li>
<li>
<span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_message.c#L1033">allocate enough space</a></span> to fit the entire message

</li>
<li>
<span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_message.c#L1040">copy</a></span> the message payload

</li>
<li>
allocate a message container with some meta data

</li>
<li>
<span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_message.c#L502">insert</a></span> the message container in the receiver process' <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_process.h#L1042">message queue</a></span>

</li>
</ol>
<p>
The process flag <span class="code">message_queue_data</span>, of the receiver process, controls the message allocating strategy of the sender process in step 2 and also how the message data is treated by the garbage collector.
</p>

<p>
The procedure above is different from how it worked prior to 19.0. Before 19.0 there was no configuration option, the behaviour was always very similar to how the <span class="code">on_heap</span> option is in 19.0.
</p>

<a name="Messages_Message-allocating-strategies"></a><h4 id="message-allocating-strategies" class="title-link" onMouseOver="document.getElementById('ghlink-message-allocating-strategies-idm31083').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-message-allocating-strategies-idm31083').style.visibility = 'hidden';">
<div class="title-name">Message allocating strategies</div>
<div class="title-anchors"><span id="ghlink-message-allocating-strategies-idm31083" class="ghlink-after"><a href="#message-allocating-strategies" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
If set to <span class="code">on_heap</span>, the sending process will first attempt to allocate the space for the message directly on the young heap block of the receiving process.
This is not always possible as it requires taking the <strong>main lock</strong> of the receiving process. The main lock is also held when the process is executing. The possibility for a lock conflict is thus likely in an intensely collaborating system.
If the sending process cannot acquire the main lock, a heap fragment is instead created for the message and the message payload is copied onto that.
With the <span class="code">off_heap</span> option the sender process always creates heap fragments for messages sent to that process.
</p>

<p>
There are a bunch of different tradeoffs that come into play when trying to figure out which of the strategies you want to use.
</p>

<p>
Using <span class="code">off_heap</span> may seem like a nice way to get a more scalable system as you get very little contention on the main locks, however, allocating a heap fragment is more expensive than allocating on the heap of the receiving process. So if it is very unlikely that contention will occur, it is more efficient to try to allocate the message directly on the receiving process' heap.
</p>

<p>
Using <span class="code">on_heap</span> will force all messages to be part of on the young heap which will increase the amount of data that the garbage collector has to move. So if a garbage collection is triggered while processing a large amount of messages, they will be copied to the young heap. This in turn will lead to that the messages will quickly be promoted to the old heap and thus increase its size. This may be good or bad depending on exactly what the process does. A large old heap means that the young heap will also be larger, which in turn means that less garbage collections will be triggered while processing the message queue. This will temporarly increase the throughput of the process at the cost of more memory usage. However, if after all the messages have been consumed the process enters a state where a lot less messages are being received. Then it may be a long time before the next fullsweep garbage collection happens and the messages that are on the old heap will be there until that happens. So while <span class="code">on_heap</span> is potentially faster than the other modes, it uses more memory for a longer time. This mode is the legacy mode which is almost how the message queue was handled before Erlang/OTP 19.0.
</p>

<p>
Which one of these strategies is best depends a lot on what the process is doing and how it interacts with other processes. So, as always, profile the application and see how it behaves with the different options.
</p>





<a name="References"></a><h3 id="references" class="title-link" onMouseOver="document.getElementById('ghlink-references-idm31097').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-references-idm31097').style.visibility = 'hidden';">
<div class="title-name">5.8 
        References</div>
<div class="title-anchors"><span id="ghlink-references-idm31097" class="ghlink-after"><a href="#references" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
C. J. Cheney. A nonrecursive list compacting algorithm. Commun. ACM, 13(11):677–678, Nov. 1970.
</p>

<p>
D. Ungar. Generation scavenging: A non-disruptive high performance storage reclamation algorithm. SIGSOFT Softw. Eng. Notes, 9(3):157–167, Apr. 1984.
</p>


</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2021 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../../js/';</script><script type="text/javascript" src="../../js/highlight.js"></script>
<script src="/assets/js/doc-search.bundle.js"></script>
</body>
</html>
