<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.38.1">
    <meta name="project" content="eunit v2.10">


<meta name="major-vsn" content="28">
<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=28&q=">
<link rel="canonical" href="https://www.erlang.org/doc/apps/eunit/chapter.html" />
    <title>EUnit - a Lightweight Unit Testing Framework for Erlang â€” eunit v2.10</title>

    <link rel="stylesheet" href="dist/html-erlang-ZK43ZOAC.css" />

    <script defer src="dist/sidebar_items-04E61EB4.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-DPJLHKSM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="eunit" />
        </a>

      <div>
        <a href="../../index.html" class="sidebar-projectName" translate="no">
eunit
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v2.10
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of eunit</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>EUnit - a Lightweight Unit Testing Framework for Erlang</h1>


      <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/eunit/doc/guides/chapter.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<p>EUnit is a unit testing framework for Erlang. It is very powerful and flexible,
is easy to use, and has small syntactical overhead.</p><ul><li><a href="chapter.html#Unit_testing">Unit testing</a></li><li><a href="chapter.html#terminology">Terminology</a></li><li><a href="chapter.html#Getting_started">Getting started</a></li><li><a href="chapter.html#EUnit_macros">EUnit macros</a></li><li><a href="chapter.html#EUnit_test_representation">EUnit test representation</a></li></ul><p>EUnit builds on ideas from the family of unit testing frameworks for Object
Oriented languages that originated with JUnit by Beck and Gamma (and Beck's
previous framework SUnit for Smalltalk). However, EUnit uses techniques more
adapted to functional and concurrent programming, and is typically less verbose
than its relatives.</p><p>Although EUnit uses many preprocessor macros, they have been designed to be as
nonintrusive as possible, and should not cause conflicts with existing code.
Adding EUnit tests to a module should thus not normally require changing
existing code. Furthermore, tests that only exercise the exported functions of a
module can always be placed in a completely separate module, avoiding any
conflicts entirely.</p><p><a href="" id="Unit_testing"></a></p><h2 id="unit-testing" class="section-heading"><a href="#unit-testing" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Unit testing</span></h2><p>Unit Testing is testing of individual program &quot;units&quot; in relative isolation.
There is no particular size requirement: a unit can be a function, a module, a
process, or even a whole application, but the most typical testing units are
individual functions or modules. In order to test a unit, you specify a set of
individual tests, set up the smallest necessary environment for being able to
run those tests (often, you don't need to do any setup at all), you run the
tests and collect the results, and finally you do any necessary cleanup so that
the test can be run again later. A Unit Testing Framework tries to help you in
each stage of this process, so that it is easy to write tests, easy to run them,
and easy to see which tests failed (so you can fix the bugs).</p><p><a href="" id="Advantages_of_unit_testing"></a></p><h3 id="advantages-of-unit-testing" class="section-heading"><a href="#advantages-of-unit-testing" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Advantages of unit testing</span></h3><ul><li><p><strong>Reduces the risks of changing the program</strong> - Most programs will be modified
during their lifetime: bugs will be fixed, features will be added,
optimizations may become necessary, or the code will need to be refactored or
cleaned up in other ways to make it easier to work with. But every change to a
working program is a risk of introducing new bugs - or reintroducing bugs that
had previously been fixed. Having a set of unit tests that you can run with
very little effort makes it easy to know that the code still works as it
should (this use is called <em>regression testing</em>; see
<a href="chapter.html#terminology">Terminology</a>). This goes a long way to reduce the
resistance to changing and refactoring code.</p></li><li><p><strong>Helps guide and speed up the development process</strong> - By focusing on getting
the code to pass the tests, the programmer can become more productive, not
overspecify or get lost in premature optimizations, and create code that is
correct from the very beginning (so-called <em>test-driven development</em>; see
<a href="chapter.html#terminology">Terminology</a>).</p></li><li><p><strong>Helps separate interface from implementation</strong> - When writing tests, the
programmer may discover dependencies (in order to get the tests to run) that
ought not to be there, and which need to be abstracted away to get a cleaner
design. This helps eliminate bad dependencies before they spread throughout
the code.</p></li><li><p><strong>Makes component integration easier</strong> - By testing in a bottom-up fashion,
beginning with the smallest program units and creating a confidence in that
they work as they should, it becomes easier to test that a higher-level
component, consisting of several such units, also behaves according to
specification (known as <em>integration testing</em>; see
<a href="chapter.html#terminology">Terminology</a>).</p></li><li><p><strong>Is self-documenting</strong> - The tests can be read as documentation, typically
showing both examples of correct and incorrect usage, along with the expected
consequences.</p></li></ul><h2 id="terminology" class="section-heading"><a href="#terminology" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Terminology</span></h2><ul><li><p><strong>Unit testing</strong> - Testing that a program unit behaves as it is supposed to do
(in itself), according to its specifications. Unit tests have an important
function as regression tests, when the program later is modified for some
reason, since they check that the program still behaves according to
specification.</p></li><li><p><strong>Regression testing</strong> - Running a set of tests after making changes to a
program, to check that the program behaves as it did before the changes
(except, of course, for any intentional changes in behaviour). Unit tests are
important as regression tests, but regression testing can involve more than
just unit testing, and may also test behaviour that might not be part of the
normal specification (such as bug-for-bug-compatibility).</p></li><li><p><strong>Integration testing</strong> - Testing that a number of individually developed
program units (assumed to already have been separately unit tested) work
together as expected. Depending on the system being developed, integration
testing may be as simple as &quot;just another level of unit testing&quot;, but might
also involve other kinds of tests (compare <em>system testing</em>).</p></li><li><p><strong>System testing</strong> - Testing that a complete system behaves according to its
specification. Specifically, system testing should not require knowing any
details about the implementation. It typically involves testing many different
aspects of the system behaviour apart from the basic functionality, such as
performance, usability, and reliability.</p></li><li><p><strong>Test-driven development</strong> - A program development technique where you
continuously write tests <em>before</em> you implement the code that is supposed to
pass those tests. This can help you focus on solving the right problems, and
not make a more complicated implementation than necessary, by letting the unit
tests determine when a program is &quot;done&quot;: if it fulfils its specifications,
there is no need to keep adding functionality.</p></li><li><p><strong>Mock object</strong> - Sometimes, testing some unit <code class="inline">A</code> (e.g., a function) requires
that it collaborates somehow with some other unit <code class="inline">B</code> (perhaps being passed as
an argument, or by reference) - but <code class="inline">B</code> has not been implemented yet. A &quot;mock
object&quot; - an object which, for the purposes of testing <code class="inline">A</code>, looks and behaves
like a real <code class="inline">B</code> - might then be used instead. (This is of course only useful
if it would be significantly more work to implement a real <code class="inline">B</code> than to create
a mock object.)</p></li><li><p><strong>Test case</strong> - A single, well-defined test, that somehow can be uniquely
identified. When executed, the test case either <em>passes</em> or <em>fails</em>; the test
report should identify exactly which test cases failed.</p></li><li><p><strong>Test suite</strong> - A collection of test cases, generally with a specific, common
target for testing, such as a single function, module, or subsystem. A test
suite may also be recursively composed by smaller test suites.</p></li></ul><p><a href="" id="Getting_started"></a></p><h2 id="getting-started" class="section-heading"><a href="#getting-started" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Getting started</span></h2><ul><li><a href="chapter.html#Including_the_EUnit_header_file">Including the EUnit header file</a></li><li><a href="chapter.html#Writing_simple_test_functions">Writing simple test functions</a></li><li><a href="chapter.html#Running_EUnit">Running EUnit</a></li><li><a href="chapter.html#Writing_test_generating_functions">Writing test generating functions</a></li><li><a href="chapter.html#An_example">An example</a></li><li><a href="chapter.html#Disabling_testing">Disabling testing</a></li><li><a href="chapter.html#Avoiding_compile-time_dependency_on_EUnit">Avoiding compile-time dependency on EUnit</a></li></ul><p><a href="" id="Including_the_EUnit_header_file"></a></p><h3 id="including-the-eunit-header-file" class="section-heading"><a href="#including-the-eunit-header-file" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Including the EUnit header file</span></h3><p>The simplest way to use EUnit in an Erlang module is to add the following line
at the beginning of the module (after the <code class="inline">-module</code> declaration, but before any
function definitions):</p><pre><code class="text">   -include_lib(&quot;eunit/include/eunit.hrl&quot;).</code></pre><p>This will have the following effect:</p><ul><li>Creates an exported function <code class="inline">test()</code> (unless testing is turned off, and the
module does not already contain a test() function), that can be used to run
all the unit tests defined in the module</li><li>Causes all functions whose names match <code class="inline">..._test()</code> or <code class="inline">..._test_()</code> to be
automatically exported from the module (unless testing is turned off, or the
<code class="inline">EUNIT_NOAUTO</code> macro is defined)</li><li>Makes all the preprocessor macros of EUnit available, to help writing tests</li></ul><p><em>Note:</em> For <code class="inline">-include_lib(...)</code> to work, the Erlang module search path <em>must</em>
contain a directory whose name ends in <code class="inline">eunit/ebin</code> (pointing to the <code class="inline">ebin</code>
subdirectory of the EUnit installation directory). If EUnit is installed as
<code class="inline">lib/eunit</code> under your Erlang/OTP system directory, its <code class="inline">ebin</code> subdirectory will
be automatically added to the search path when Erlang starts. Otherwise, you
need to add the directory explicitly, by passing a <code class="inline">-pa</code> flag to the <code class="inline">erl</code> or
<code class="inline">erlc</code> command. For example, a Makefile could contain the following action for
compiling <code class="inline">.erl</code> files:</p><pre><code class="text">   erlc -pa &quot;path/to/eunit/ebin&quot; $(ERL_COMPILE_FLAGS) -o$(EBIN) $&lt;</code></pre><p>or if you want Eunit to always be available when you run Erlang interactively,
you can add a line like the following to your <code class="inline">$HOME/.erlang</code> file:</p><pre><code class="text">   code:add_path(&quot;/path/to/eunit/ebin&quot;).</code></pre><p><a href="" id="Writing_simple_test_functions"></a></p><h3 id="writing-simple-test-functions" class="section-heading"><a href="#writing-simple-test-functions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Writing simple test functions</span></h3><p>The EUnit framework makes it extremely easy to write unit tests in Erlang. There
are a few different ways of writing them, though, so we start with the simplest:</p><p>A function with a name ending in <code class="inline">..._test()</code> is recognized by EUnit as a simple
test function - it takes no arguments, and its execution either succeeds
(returning some arbitrary value that EUnit will throw away), or fails by
throwing an exception of some kind (or by not terminating, in which case it will
be aborted after a while).</p><p>An example of a simple test function could be the following:</p><pre><code class="text">   reverse_test() -&gt; lists:reverse([1,2,3]).</code></pre><p>This just tests that the function <code class="inline">lists:reverse(List)</code> does not crash when
<code class="inline">List</code> is <code class="inline">[1,2,3]</code>. It is not a great test, but many people write simple
functions like this one to test the basic functionality of their code, and those
tests can be used directly by EUnit, without changes, as long as their function
names match.</p><p><em id="Use_exceptions_to_signal_failure">Use exceptions to signal failure</em> To
write more interesting tests, we need to make them crash (throw an exception)
when they don't get the result they expect. A simple way of doing this is to use
pattern matching with <code class="inline">=</code>, as in the following examples:</p><pre><code class="text">   reverse_nil_test() -&gt; [] = lists:reverse([]).
   reverse_one_test() -&gt; [1] = lists:reverse([1]).
   reverse_two_test() -&gt; [2,1] = lists:reverse([1,2]).</code></pre><p>If there was some bug in <a href="../../apps/stdlib/lists.html#reverse/1"><code class="inline">lists:reverse/1</code></a> that made it return something other
than <code class="inline">[2,1]</code> when it got <code class="inline">[1,2]</code> as input, then the last test above would throw
a <code class="inline">badmatch</code> error. The first two (we assume they do not get a <code class="inline">badmatch</code>) would
simply return <code class="inline">[]</code> and <code class="inline">[1]</code>, respectively, so both succeed. (Note that EUnit is
not psychic: if you write a test that returns a value, even if it is the wrong
value, EUnit will consider it a success. You must make sure that the test is
written so that it causes a crash if the result is not what it should be.)</p><p><em id="Using_assert_macros">Using assert macros</em> If you want to use Boolean
operators for your tests, the <code class="inline">assert</code> macro comes in handy (see
<a href="chapter.html#EUnit_macros">EUnit macros</a> for details):</p><pre><code class="text">   length_test() -&gt; ?assert(length([1,2,3]) =:= 3).</code></pre><p>The <code class="inline">?assert(Expression)</code> macro will evaluate <code class="inline">Expression</code>, and if that does not
evaluate to <code class="inline">true</code>, it will throw an exception; otherwise it just returns <code class="inline">ok</code>.
In the above example, the test will thus fail if the call to <code class="inline">length</code> does not
return 3.</p><p><a href="" id="Running_EUnit"></a></p><h3 id="running-eunit" class="section-heading"><a href="#running-eunit" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Running EUnit</span></h3><p>If you have added the declaration <code class="inline">-include_lib(&quot;eunit/include/eunit.hrl&quot;)</code> to
your module, as described above, you only need to compile the module, and run
the automatically exported function <code class="inline">test()</code>. For example, if your module was
named <code class="inline">m</code>, then calling <code class="inline">\m:test()</code> will run EUnit on all the tests defined in
the module. You do not need to write <code class="inline">-export</code> declarations for the test
functions. This is all done by magic.</p><p>You can also use the function <a href="eunit.html#test/1"><code class="inline">eunit:test/1</code></a> to run arbitrary tests, for example
to try out some more advanced test descriptors (see
<a href="chapter.html#EUnit_test_representation">EUnit test representation</a>). For example,
running <code class="inline">eunit:test(m)</code> does the same thing as the auto-generated function
<code class="inline">\m:test()</code>, while <code class="inline">eunit:test({inparallel, m})</code> runs the same test cases but
executes them all in parallel.</p><p><em id="Putting_tests_in_separate_modules">Putting tests in separate modules</em></p><p>If you want to separate your test code from your normal code (at least for
testing the exported functions), you can simply write the test functions in a
module named <code class="inline">m_tests</code> (note: not <code class="inline">m_test</code>), if your module is named <code class="inline">m</code>. Then,
whenever you ask EUnit to test the module <code class="inline">m</code>, it will also look for the module
<code class="inline">m_tests</code> and run those tests as well. See <code class="inline">ModuleName</code> in the section
<a href="chapter.html#primitives">Primitives</a> for details.</p><p><em id="EUnit_captures_standard_output">EUnit captures standard output</em></p><p>If your test code writes to the standard output, you may be surprised to see
that the text does not appear on the console when the tests are running. This is
because EUnit captures all standard output from test functions (this also
includes setup and cleanup functions, but not generator functions), so that it
can be included in the test report if errors occur. To bypass EUnit and print
text directly to the console while testing, you can write to the <code class="inline">user</code> output
stream, as in <code class="inline">io:format(user, &quot;~w&quot;, [Term])</code>. The recommended way of doing this
is to use the EUnit <a href="chapter.html#Debugging_macros">Debugging macros</a>, which make
it much simpler.</p><p>For checking the output produced by the unit under test, see
<a href="chapter.html#Macros_for_checking_output">Macros for checking output</a>.</p><p><a href="" id="Writing_test_generating_functions"></a></p><h3 id="writing-test-generating-functions" class="section-heading"><a href="#writing-test-generating-functions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Writing test generating functions</span></h3><p>A drawback of simple test functions is that you must write a separate function
(with a separate name) for each test case. A more compact way of writing tests
(and much more flexible, as we shall see), is to write functions that <em>return</em>
tests, instead of <em>being</em> tests.</p><p>A function with a name ending in <code class="inline">..._test_()</code> (note the final underscore) is
recognized by EUnit as a <em>test generator</em> function. Test generators return a
<em>representation</em> of a <em>set of tests</em> to be executed by EUnit.</p><p><em id="Representing_a_test_as_data">Representing a test as data</em> The most basic
representation of a test is a single fun-expression that takes no arguments. For
example, the following test generator:</p><pre><code class="text">   basic_test_() -&gt;
       fun () -&gt; ?assert(1 + 1 =:= 2) end.</code></pre><p>will have the same effect as the following simple test:</p><pre><code class="text">   simple_test() -&gt;
       ?assert(1 + 1 =:= 2).</code></pre><p>(in fact, EUnit will handle all simple tests just like it handles
fun-expressions: it will put them in a list, and run them one by one).</p><p><em id="Using_macros_to_write_tests">Using macros to write tests</em> To make tests
more compact and readable, as well as automatically add information about the
line number in the source code where a test occurred (and reduce the number of
characters you have to type), you can use the <code class="inline">_test</code> macro (note the initial
underscore character), like this:</p><pre><code class="text">   basic_test_() -&gt;
       ?_test(?assert(1 + 1 =:= 2)).</code></pre><p>The <code class="inline">_test</code> macro takes any expression (the &quot;body&quot;) as argument, and places it
within a fun-expression (along with some extra information). The body can be any
kind of test expression, just like the body of a simple test function.</p><p><em id="Underscore-prefixed_macros_create_test_objects">Underscore-prefixed macros create test objects</em> But this example can be made
even shorter! Most test macros, such as the family of <code class="inline">assert</code> macros, have a
corresponding form with an initial underscore character, which automatically
adds a <code class="inline">?_test(...)</code> wrapper. The above example can then simply be written:</p><pre><code class="text">   basic_test_() -&gt;
       ?_assert(1 + 1 =:= 2).</code></pre><p>which has exactly the same meaning (note the <code class="inline">_assert</code> instead of <code class="inline">assert</code>). You
can think of the initial underscore as signalling <em>test object</em>.</p><p><a href="" id="An_example"></a></p><h3 id="an-example" class="section-heading"><a href="#an-example" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">An example</span></h3><p>Sometimes, an example says more than a thousand words. The following small
Erlang module shows how EUnit can be used in practice.</p><pre><code class="text">   -module(fib).
   -export([fib/1]).
   -include_lib(&quot;eunit/include/eunit.hrl&quot;).

   fib(0) -&gt; 1;
   fib(1) -&gt; 1;
   fib(N) when N &gt; 1 -&gt; fib(N-1) + fib(N-2).

   fib_test_() -&gt;
       [?_assert(fib(0) =:= 1),
	?_assert(fib(1) =:= 1),
	?_assert(fib(2) =:= 2),
	?_assert(fib(3) =:= 3),
	?_assert(fib(4) =:= 5),
	?_assert(fib(5) =:= 8),
	?_assertException(error, function_clause, fib(-1)),
	?_assert(fib(31) =:= 2178309)
       ].</code></pre><p>(Author's note: When I first wrote this example, I happened to write a <code class="inline">*</code>
instead of <code class="inline">+</code> in the <code class="inline">fib</code> function. Of course, this showed up immediately when
I ran the tests.)</p><p>See <a href="chapter.html#EUnit_test_representation">EUnit test representation</a> for a full
list of all the ways you can specify test sets in EUnit.</p><p><a href="" id="Disabling_testing"></a></p><h3 id="disabling-testing" class="section-heading"><a href="#disabling-testing" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Disabling testing</span></h3><p>Testing can be turned off by defining the <code class="inline">NOTEST</code> macro when compiling, for
example as an option to <code class="inline">erlc</code>, as in:</p><pre><code class="text">   erlc -DNOTEST my_module.erl</code></pre><p>or by adding a macro definition to the code, <em>before the EUnit header file is
included</em>:</p><pre><code class="text">   -define(NOTEST, 1).</code></pre><p>(the value is not important, but should typically be 1 or <code class="inline">true</code>). Note that
unless the <code class="inline">EUNIT_NOAUTO</code> macro is defined, disabling testing will also
automatically strip all test functions from the code, except for any that are
explicitly declared as exported.</p><p>For instance, to use EUnit in your application, but with testing turned off by
default, put the following lines in a header file:</p><pre><code class="text">   -define(NOTEST, true).
   -include_lib(&quot;eunit/include/eunit.hrl&quot;).</code></pre><p>and then make sure that every module of your application includes that header
file. This means that you have a single place to modify in order to change the
default setting for testing. To override the <code class="inline">NOTEST</code> setting without modifying
the code, you can define <code class="inline">TEST</code> in a compiler option, like this:</p><pre><code class="text">   erlc -DTEST my_module.erl</code></pre><p>See <a href="chapter.html#Compilation_control_macros">Compilation control macros</a> for
details about these macros.</p><p><a href="" id="Avoiding_compile-time_dependency_on_EUnit"></a></p><h3 id="avoiding-compile-time-dependency-on-eunit" class="section-heading"><a href="#avoiding-compile-time-dependency-on-eunit" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Avoiding compile-time dependency on EUnit</span></h3><p>If you are distributing the source code for your application for other people to
compile and run, you probably want to ensure that the code compiles even if
EUnit is not available. Like the example in the previous section, you can put
the following lines in a common header file:</p><pre><code class="text">   -ifdef(TEST).
   -include_lib(&quot;eunit/include/eunit.hrl&quot;).
   -endif.</code></pre><p>and, of course, also make sure that you place all test code that uses EUnit
macros within <code class="inline">-ifdef(TEST)</code> or <code class="inline">-ifdef(EUNIT)</code> sections.</p><p><a href="" id="EUnit_macros"></a></p><h2 id="eunit-macros" class="section-heading"><a href="#eunit-macros" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">EUnit macros</span></h2><p>Although all the functionality of EUnit is available even without the use of
preprocessor macros, the EUnit header file defines a number of such macros in
order to make it as easy as possible to write unit tests as compactly as
possible and without getting too many details in the way.</p><p>Except where explicitly stated, using EUnit macros will never introduce run-time
dependencies on the EUnit library code, regardless of whether your code is
compiled with testing enabled or disabled.</p><ul><li><a href="chapter.html#Basic_macros">Basic macros</a></li><li><a href="chapter.html#Compilation_control_macros">Compilation control macros</a></li><li><a href="chapter.html#Utility_macros">Utility macros</a></li><li><a href="chapter.html#Assert_macros">Assert macros</a></li><li><a href="chapter.html#Macros_for_checking_output">Macros for checking output</a></li><li><a href="chapter.html#Macros_for_running_external_commands">Macros for running external commands</a></li><li><a href="chapter.html#Debugging_macros">Debugging macros</a></li></ul><p><a href="" id="Basic_macros"></a></p><h3 id="basic-macros" class="section-heading"><a href="#basic-macros" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Basic macros</span></h3><ul><li><strong><code class="inline">_test(Expr)</code></strong> - Turns <code class="inline">Expr</code> into a &quot;test object&quot;, by wrapping it in a
fun-expression and a source line number. Technically, this is the same as
<code class="inline">{?LINE, fun () -&gt; (Expr) end}</code>.</li></ul><p><a href="" id="Compilation_control_macros"></a></p><h3 id="compilation-control-macros" class="section-heading"><a href="#compilation-control-macros" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Compilation control macros</span></h3><ul><li><p><strong><code class="inline">EUNIT</code></strong> - This macro is always defined to <code class="inline">true</code> whenever EUnit is enabled
at compile time. This is typically used to place testing code within
conditional compilation, as in:</p><pre><code class="text">   -ifdef(EUNIT).
       % test code here
       ...
   -endif.</code></pre><p>e.g., to ensure that the code can be compiled without including the EUnit
header file, when testing is disabled. See also the macros <code class="inline">TEST</code> and
<code class="inline">NOTEST</code>.</p></li><li><p><strong><code class="inline">EUNIT_NOAUTO</code></strong> - If this macro is defined, the automatic exporting or
stripping of test functions will be disabled.</p></li><li><p><strong><code class="inline">TEST</code></strong> - This macro is always defined (to <code class="inline">true</code>, unless previously
defined by the user to have another value) whenever EUnit is enabled at
compile time. This can be used to place testing code within conditional
compilation; see also the macros <code class="inline">NOTEST</code> and <code class="inline">EUNIT</code>.</p><p>For testing code that is strictly dependent on EUnit, it may be preferable to
use the <code class="inline">EUNIT</code> macro for this purpose, while for code that uses more generic
testing conventions, using the <code class="inline">TEST</code> macro may be preferred.</p><p>The <code class="inline">TEST</code> macro can also be used to override the <code class="inline">NOTEST</code> macro. If <code class="inline">TEST</code> is
defined <em>before</em> the EUnit header file is included (even if <code class="inline">NOTEST</code> is also
defined), then the code will be compiled with EUnit enabled.</p></li><li><p><strong><code class="inline">NOTEST</code></strong> - This macro is always defined (to <code class="inline">true</code>, unless previously
defined by the user to have another value) whenever EUnit is <em>disabled</em> at
compile time. (Compare the <code class="inline">TEST</code> macro.)</p><p>This macro can also be used for conditional compilation, but is more typically
used to disable testing: If <code class="inline">NOTEST</code> is defined <em>before</em> the EUnit header file
is included, and <code class="inline">TEST</code> is <em>not</em> defined, then the code will be compiled with
EUnit disabled. See also <a href="chapter.html#Disabling_testing">Disabling testing</a>.</p></li><li><p><strong><code class="inline">NOASSERT</code></strong> - If this macro is defined, the assert macros will have no
effect, when testing is also disabled. See
<a href="chapter.html#Assert_macros">Assert macros</a>. When testing is enabled, the assert
macros are always enabled automatically and cannot be disabled.</p></li><li><p><strong><code class="inline">ASSERT</code></strong> - If this macro is defined, it overrides the NOASSERT macro,
forcing the assert macros to always be enabled regardless of other settings.</p></li><li><p><strong><code class="inline">NODEBUG</code></strong> - If this macro is defined, the debugging macros will have no
effect. See <a href="chapter.html#Debugging_macros">Debugging macros</a>. <code class="inline">NODEBUG</code> also
implies <code class="inline">NOASSERT</code>, unless testing is enabled.</p></li><li><p><strong><code class="inline">DEBUG</code></strong> - If this macro is defined, it overrides the NODEBUG macro,
forcing the debugging macros to be enabled.</p></li></ul><p><a href="" id="Utility_macros"></a></p><h3 id="utility-macros" class="section-heading"><a href="#utility-macros" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Utility macros</span></h3><p>The following macros can make tests more compact and readable:</p><ul><li><p><strong><code class="inline">LET(Var,Arg,Expr)</code></strong> - Creates a local binding <code class="inline">Var = Arg</code> in <code class="inline">Expr</code>. (This
is the same as <code class="inline">(fun(Var)-&gt;(Expr)end)(Arg)</code>.) Note that the binding is not
exported outside of <code class="inline">Expr</code>, and that within <code class="inline">Expr</code>, this binding of <code class="inline">Var</code> will
shadow any binding of <code class="inline">Var</code> in the surrounding scope.</p></li><li><p><strong><code class="inline">IF(Cond,TrueCase,FalseCase)</code></strong> - Evaluates <code class="inline">TrueCase</code> if <code class="inline">Cond</code> evaluates
to <code class="inline">true</code>, or otherwise evaluates <code class="inline">FalseCase</code> if <code class="inline">Cond</code> evaluates to <code class="inline">false</code>.
(This is the same as
<code class="inline">(case (Cond) of true-&gt;(TrueCase); false-&gt;(FalseCase) end)</code>.) Note that it is
an error if <code class="inline">Cond</code> does not yield a boolean value.</p></li></ul><p><a href="" id="Assert_macros"></a></p><h3 id="assert-macros" class="section-heading"><a href="#assert-macros" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Assert macros</span></h3><p>(Note that these macros also have corresponding forms which start with an &quot;<code class="inline">_</code>&quot;
(underscore) character, as in <code class="inline">?_assert(BoolExpr)</code>, that create a &quot;test object&quot;
instead of performing the test immediately. This is equivalent to writing
<code class="inline">?_test(assert(BoolExpr))</code>, etc.)</p><p>If the macro <code class="inline">NOASSERT</code> is defined before the EUnit header file is included,
these macros have no effect when testing is also disabled; see
<a href="chapter.html#Compilation_control_macros">Compilation control macros</a> for details.</p><ul><li><p><strong><code class="inline">assert(BoolExpr)</code></strong> - Evaluates the expression <code class="inline">BoolExpr</code>, if testing is
enabled. Unless the result is <code class="inline">true</code>, an informative exception will be
generated. If there is no exception, the result of the macro expression is the
atom <code class="inline">ok</code>, and the value of <code class="inline">BoolExpr</code> is discarded. If testing is disabled,
the macro will not generate any code except the atom <code class="inline">ok</code>, and <code class="inline">BoolExpr</code> will
not be evaluated.</p><p>Typical usage:</p><pre><code class="text">   ?assert(f(X, Y) =:= [])</code></pre><p>The <code class="inline">assert</code> macro can be used anywhere in a program, not just in unit tests,
to check pre/postconditions and invariants. For example:</p><pre><code class="text">   some_recursive_function(X, Y, Z) -&gt;
       ?assert(X + Y &gt; Z),
       ...</code></pre></li><li><p><strong><code class="inline">assertNot(BoolExpr)</code></strong> - Equivalent to <code class="inline">assert(not (BoolExpr))</code>.</p></li><li><p><strong><code class="inline">assertMatch(GuardedPattern, Expr)</code></strong> - Evaluates <code class="inline">Expr</code> and matches the
result against <code class="inline">GuardedPattern</code>, if testing is enabled. If the match fails, an
informative exception will be generated; see the <code class="inline">assert</code> macro for further
details. <code class="inline">GuardedPattern</code> can be anything that you can write on the left hand
side of the <code class="inline">-&gt;</code> symbol in a case-clause, except that it cannot contain
comma-separated guard tests.</p><p>The main reason for using <code class="inline">assertMatch</code> also for simple matches, instead of
matching with <code class="inline">=</code>, is that it produces more detailed error messages.</p><p>Examples:</p><pre><code class="text">   ?assertMatch({found, {fred, _}}, lookup(bloggs, Table))</code></pre><pre><code class="text">   ?assertMatch([X|_] when X &gt; 0, binary_to_list(B))</code></pre></li><li><p><strong><code class="inline">assertNotMatch(GuardedPattern, Expr)</code></strong> - The inverse case of assertMatch,
for convenience.</p></li><li><p><strong><code class="inline">assertEqual(Expect, Expr)</code></strong> - Evaluates the expressions <code class="inline">Expect</code> and
<code class="inline">Expr</code> and compares the results for equality, if testing is enabled. If the
values are not equal, an informative exception will be generated; see the
<code class="inline">assert</code> macro for further details.</p><p><code class="inline">assertEqual</code> is more suitable than <code class="inline">assertMatch</code> when the left-hand side is a
computed value rather than a simple pattern, and gives more details than
<code class="inline">?assert(Expect =:= Expr)</code>.</p><p>Examples:</p><pre><code class="text">   ?assertEqual(&quot;b&quot; ++ &quot;a&quot;, lists:reverse(&quot;ab&quot;))</code></pre><pre><code class="text">   ?assertEqual(foo(X), bar(Y))</code></pre></li><li><p><strong><code class="inline">assertNotEqual(Unexpected, Expr)</code></strong> - The inverse case of assertEqual, for
convenience.</p></li><li><p><strong><code class="inline">assertException(ClassPattern, TermPattern, Expr)</code></strong></p></li><li><p><strong><code class="inline">assertError(TermPattern, Expr)</code></strong></p></li><li><p><strong><code class="inline">assertExit(TermPattern, Expr)</code></strong></p></li><li><p><strong><code class="inline">assertThrow(TermPattern, Expr)</code></strong> - Evaluates <code class="inline">Expr</code>, catching any
exception and testing that it matches the expected <code class="inline">ClassPattern:TermPattern</code>.
If the match fails, or if no exception is thrown by <code class="inline">Expr</code>, an informative
exception will be generated; see the <code class="inline">assert</code> macro for further details. The
<code class="inline">assertError</code>, <code class="inline">assertExit</code>, and <code class="inline">assertThrow</code> macros, are equivalent to using
<code class="inline">assertException</code> with a <code class="inline">ClassPattern</code> of <code class="inline">error</code>, <code class="inline">exit</code>, or <code class="inline">throw</code>,
respectively.</p><p>Examples:</p><pre><code class="text">   ?assertError(badarith, X/0)</code></pre><pre><code class="text">   ?assertExit(normal, exit(normal))</code></pre><pre><code class="text">   ?assertException(throw, {not_found,_}, throw({not_found,42}))</code></pre></li></ul><p><a href="" id="Macros_for_checking_output"></a></p><h3 id="macros-for-checking-output" class="section-heading"><a href="#macros-for-checking-output" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Macros for checking output</span></h3><p>The following macro can be used within a test case to retrieve the output
written to standard output.</p><ul><li><p><strong><code class="inline">capturedOutput</code></strong> - The output captured by EUnit in the current test case,
as a string.</p><p>Examples:</p><pre><code class="text">   io:format(&quot;Hello~n&quot;),
   ?assertEqual(&quot;Hello\n&quot;, ?capturedOutput)</code></pre></li></ul><p><a href="" id="Macros_for_running_external_commands"></a></p><h3 id="macros-for-running-external-commands" class="section-heading"><a href="#macros-for-running-external-commands" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Macros for running external commands</span></h3><p>Keep in mind that external commands are highly dependent on the operating
system. You can use the standard library function <code class="inline">os:type()</code> in test generator
functions, to produce different sets of tests depending on the current operating
system.</p><p>Note: these macros introduce a run-time dependency on the EUnit library code, if
compiled with testing enabled.</p><ul><li><p><strong><code class="inline">assertCmd(CommandString)</code></strong> - Runs <code class="inline">CommandString</code> as an external command,
if testing is enabled. Unless the returned status value is 0, an informative
exception will be generated. If there is no exception, the result of the macro
expression is the atom <code class="inline">ok</code>. If testing is disabled, the macro will not
generate any code except the atom <code class="inline">ok</code>, and the command will not be executed.</p><p>Typical usage:</p><pre><code class="text">   ?assertCmd(&quot;mkdir foo&quot;)</code></pre></li><li><p><strong><code class="inline">assertCmdStatus(N, CommandString)</code></strong> - Like the <code class="inline">assertCmd(CommandString)</code>
macro, but generates an exception unless the returned status value is <code class="inline">N</code>.</p></li><li><p><strong><code class="inline">assertCmdOutput(Text, CommandString)</code></strong> - Runs <code class="inline">CommandString</code> as an
external command, if testing is enabled. Unless the output produced by the
command exactly matches the specified string <code class="inline">Text</code>, an informative exception
will be generated. (Note that the output is normalized to use a single LF
character as line break on all platforms.) If there is no exception, the
result of the macro expression is the atom <code class="inline">ok</code>. If testing is disabled, the
macro will not generate any code except the atom <code class="inline">ok</code>, and the command will
not be executed.</p></li><li><p><strong><code class="inline">cmd(CommandString)</code></strong> - Runs <code class="inline">CommandString</code> as an external command. Unless
the returned status value is 0 (indicating success), an informative exception
will be generated; otherwise, the result of the macro expression is the output
produced by the command, as a flat string. The output is normalized to use a
single LF character as line break on all platforms.</p><p>This macro is useful in the setup and cleanup sections of fixtures, e.g., for
creating and deleting files or perform similar operating system specific
tasks, to make sure that the test system is informed of any failures.</p><p>A Unix-specific example:</p><pre><code class="text">   {setup,
    fun () -&gt; ?cmd(&quot;mktemp&quot;) end,
    fun (FileName) -&gt; ?cmd(&quot;rm &quot; ++ FileName) end,
    ...}</code></pre></li></ul><p><a href="" id="Debugging_macros"></a></p><h3 id="debugging-macros" class="section-heading"><a href="#debugging-macros" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Debugging macros</span></h3><p>To help with debugging, EUnit defines several useful macros for printing
messages directly to the console (rather than to the standard output).
Furthermore, these macros all use the same basic format, which includes the file
and line number where they occur, making it possible in some development
environments (e.g., when running Erlang in an Emacs buffer) to simply click on
the message and jump directly to the corresponding line in the code.</p><p>If the macro <code class="inline">NODEBUG</code> is defined before the EUnit header file is included,
these macros have no effect; see
<a href="chapter.html#Compilation_control_macros">Compilation control macros</a> for details.</p><ul><li><p><strong><code class="inline">debugHere</code></strong> - Just prints a marker showing the current file and line
number. Note that this is an argument-less macro. The result is always <code class="inline">ok</code>.</p></li><li><p><strong><code class="inline">debugMsg(Text)</code></strong> - Outputs the message <code class="inline">Text</code> (which can be a plain
string, an IO-list, or just an atom). The result is always <code class="inline">ok</code>.</p></li><li><p><strong><code class="inline">debugFmt(FmtString, Args)</code></strong> - This formats the text like
<code class="inline">io:format(FmtString, Args)</code> and outputs it like <code class="inline">debugMsg</code>. The result is
always <code class="inline">ok</code>.</p></li><li><p><strong><code class="inline">debugVal(Expr)</code></strong> - Prints both the source code for <code class="inline">Expr</code> and its current
value. E.g., <code class="inline">?debugVal(f(X))</code> might be displayed as &quot;<code class="inline">f(X) = 42</code>&quot;. (Large
terms are truncated to the depth given by the macro <code class="inline">EUNIT_DEBUG_VAL_DEPTH</code>,
which defaults to 15 but can be overridden by the user.) The result is always
the value of <code class="inline">Expr</code>, so this macro can be wrapped around any expression to
display its value when the code is compiled with debugging enabled.</p></li><li><p><strong><code class="inline">debugVal(Expr, Depth)</code></strong> - Like <code class="inline">debugVal(Expr)</code>, but prints terms
truncated to the given depth.</p></li><li><p><strong><code class="inline">debugTime(Text,Expr)</code></strong> - Prints <code class="inline">Text</code> and the wall clock time for
evaluation of <code class="inline">Expr</code>. The result is always the value of <code class="inline">Expr</code>, so this macro
can be wrapped around any expression to show its run time when the code is
compiled with debugging enabled. For example,
<code class="inline">List1 = ?debugTime(&quot;sorting&quot;, lists:sort(List))</code> might show as
&quot;<code class="inline">sorting: 0.015 s</code>&quot;.</p></li></ul><p><a href="" id="EUnit_test_representation"></a></p><h2 id="eunit-test-representation" class="section-heading"><a href="#eunit-test-representation" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">EUnit test representation</span></h2><p>The way EUnit represents tests and test sets as data is flexible, powerful, and
concise. This section describes the representation in detail.</p><ul><li><a href="chapter.html#Simple_test_objects">Simple test objects</a></li><li><a href="chapter.html#Test_sets_and_deep_lists">Test sets and deep lists</a></li><li><a href="chapter.html#titles">Titles</a></li><li><a href="chapter.html#primitives">Primitives</a></li><li><a href="chapter.html#control">Control</a></li><li><a href="chapter.html#fixtures">Fixtures</a></li><li><a href="chapter.html#Lazy_generators">Lazy generators</a></li></ul><p><a href="" id="Simple_test_objects"></a></p><h3 id="simple-test-objects" class="section-heading"><a href="#simple-test-objects" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Simple test objects</span></h3><p>A <em>simple test object</em> is one of the following:</p><ul><li><p>A nullary functional value (i.e., a fun that takes zero arguments). Examples:</p><pre><code class="text">   fun () -&gt; ... end</code></pre><pre><code class="text">   fun some_function/0</code></pre><pre><code class="text">   fun some_module:some_function/0</code></pre></li><li><p>A tuple <code class="inline">{test, ModuleName, FunctionName}</code>, where <code class="inline">ModuleName</code> and
<code class="inline">FunctionName</code> are atoms, referring to the function
<code class="inline">ModuleName:FunctionName/0</code></p></li><li><p>(Obsolete) A pair of atoms <code class="inline">{ModuleName, FunctionName}</code>, equivalent to
<code class="inline">{test, ModuleName, FunctionName}</code> if nothing else matches first. This might
be removed in a future version.</p></li><li><p>A pair <code class="inline">{LineNumber, SimpleTest}</code>, where <code class="inline">LineNumber</code> is a nonnegative integer
and <code class="inline">SimpleTest</code> is another simple test object. <code class="inline">LineNumber</code> should indicate
the source line of the test. Pairs like this are usually only created via
<code class="inline">?_test(...)</code> macros; see <a href="chapter.html#Basic_macros">Basic macros</a>.</p></li></ul><p>In brief, a simple test object consists of a single function that takes no
arguments (possibly annotated with some additional metadata, i.e., a line
number). Evaluation of the function either <em>succeeds</em>, by returning some value
(which is ignored), or <em>fails</em>, by throwing an exception.</p><p><a href="" id="Test_sets_and_deep_lists"></a></p><h3 id="test-sets-and-deep-lists" class="section-heading"><a href="#test-sets-and-deep-lists" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Test sets and deep lists</span></h3><p>A test set can be easily created by placing a sequence of test objects in a
list. If <code class="inline">T_1</code>, ..., <code class="inline">T_N</code> are individual test objects, then <code class="inline">[T_1, ..., T_N]</code>
is a test set consisting of those objects (in that order).</p><p>Test sets can be joined in the same way: if <code class="inline">S_1</code>, ..., <code class="inline">S_K</code> are test sets,
then <code class="inline">[S_1, ..., S_K]</code> is also a test set, where the tests of <code class="inline">S_i</code> are ordered
before those of <code class="inline">S_(i+1)</code>, for each subset <code class="inline">S_i</code>.</p><p>Thus, the main representation of test sets is <em>deep lists</em>, and a simple test
object can be viewed as a test set containing only a single test; there is no
difference between <code class="inline">T</code> and <code class="inline">[T]</code>.</p><p>A module can also be used to represent a test set; see <code class="inline">ModuleName</code> under
<a href="chapter.html#primitives">Primitives</a> below.</p><h3 id="titles" class="section-heading"><a href="#titles" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Titles</span></h3><p>Any test or test set <code class="inline">T</code> can be annotated with a title, by wrapping it in a pair
<code class="inline">{Title, T}</code>, where <code class="inline">Title</code> is a string. For convenience, any test which is
normally represented using a tuple can simply be given a title string as the
first element, i.e., writing <code class="inline">{&quot;The Title&quot;, ...}</code> instead of adding an extra
tuple wrapper as in <code class="inline">{&quot;The Title&quot;, {...}}</code>.</p><h3 id="primitives" class="section-heading"><a href="#primitives" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Primitives</span></h3><p>The following are primitives, which do not contain other test sets as arguments:</p><ul><li><p><strong><code class="inline">ModuleName::atom()</code></strong> - A single atom represents a module name, and is
equivalent to <code class="inline">{module, ModuleName}</code>. This is often used as in the call
<code class="inline">eunit:test(some_module)</code>.</p></li><li><p><strong><code class="inline">{module, ModuleName::atom()}</code></strong> - This composes a test set from the
exported test functions of the named module, i.e., those functions with arity
zero whose names end with <code class="inline">_test</code> or <code class="inline">_test_</code>. Basically, the <code class="inline">..._test()</code>
functions become simple tests, while the <code class="inline">..._test_()</code> functions become
generators.</p><p>In addition, EUnit will also look for another module whose name is
<code class="inline">ModuleName</code> plus the suffix <code class="inline">_tests</code>, and if it exists, all the tests from
that module will also be added. (If <code class="inline">ModuleName</code> already contains the suffix
<code class="inline">_tests</code>, this is not done.) E.g., the specification <code class="inline">{module, mymodule}</code> will
run all tests in the modules <code class="inline">mymodule</code> and <code class="inline">mymodule_tests</code>. Typically, the
<code class="inline">_tests</code> module should only contain test cases that use the public interface
of the main module (and no other code).</p></li><li><p><strong><code class="inline">{application, AppName::atom(), Info::list()}</code></strong> - This is a normal
Erlang/OTP application descriptor, as found in an <code class="inline">.app</code> file. The resulting
test set consists of the modules listed in the <code class="inline">modules</code> entry in <code class="inline">Info</code>.</p></li><li><p><strong><code class="inline">{application, AppName::atom()}</code></strong> - This creates a test set from all the
modules belonging to the specified application, by consulting the
application's <code class="inline">.app</code> file (see <code class="inline">{file, FileName}</code>), or if no such file exists,
by testing all object files in the application's <code class="inline">ebin</code>-directory (see
<code class="inline">{dir, Path}</code>); if that does not exist, the <code class="inline">code:lib_dir(AppName)</code> directory
is used.</p></li><li><p><strong><code class="inline">Path::string()</code></strong> - A single string represents the path of a file or
directory, and is equivalent to <code class="inline">{file, Path}</code>, or <code class="inline">{dir, Path}</code>,
respectively, depending on what <code class="inline">Path</code> refers to in the file system.</p></li><li><p><strong><code class="inline">{file, FileName::string()}</code></strong> - If <code class="inline">FileName</code> has a suffix that indicates
an object file (<code class="inline">.beam</code>), EUnit will try to reload the module from the
specified file and test it. Otherwise, the file is assumed to be a text file
containing test specifications, which will be read using the standard library
function <a href="../../apps/kernel/file.html#path_consult/2"><code class="inline">file:path_consult/2</code></a>.</p><p>Unless the file name is absolute, the file is first searched for relative to
the current directory, and then using the normal search path
(<code class="inline">code:get_path()</code>). This means that the names of typical &quot;app&quot; files can be
used directly, without a path, e.g., <code class="inline">&quot;mnesia.app&quot;</code>.</p></li><li><p><strong><code class="inline">{dir, Path::string()}</code></strong> - This tests all object files in the specified
directory, as if they had been individually specified using
<code class="inline">{file, FileName}</code>.</p></li><li><p><strong><code class="inline">{generator, GenFun::(() -&gt; Tests)}</code></strong> - The generator function <code class="inline">GenFun</code> is
called to produce a test set.</p></li><li><p><strong><code class="inline">{generator, ModuleName::atom(), FunctionName::atom()}</code></strong> - The function
<code class="inline">ModuleName:FunctionName()</code> is called to produce a test set.</p></li><li><p><strong><code class="inline">{with, X::any(), [AbstractTestFun::((any()) -&gt; any())]}</code></strong> - Distributes
the value <code class="inline">X</code> over the unary functions in the list, turning them into nullary
test functions. An <code class="inline">AbstractTestFun</code> is like an ordinary test fun, but takes
one argument instead of zero - it's basically missing some information before
it can be a proper test. In practice, <code class="inline">{with, X, [F_1, ..., F_N]}</code> is
equivalent to <code class="inline">[fun () -&gt; F_1(X) end, ..., fun () -&gt; F_N(X) end]</code>. This is
particularly useful if your abstract test functions are already implemented as
proper functions:
<code class="inline">{with, FD, [fun filetest_a/1, fun filetest_b/1, fun filetest_c/1]}</code> is
equivalent to
<code class="inline">[fun () -&gt; filetest_a(FD) end, fun () -&gt; filetest_b(FD) end, fun () -&gt; filetest_c(FD) end]</code>,
but much more compact. See also <a href="chapter.html#fixtures">Fixtures</a>, below.</p></li></ul><h3 id="control" class="section-heading"><a href="#control" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Control</span></h3><p>The following representations control how and where tests are executed:</p><ul><li><p><strong><code class="inline">{spawn, Tests}</code></strong> - Runs the specified tests in a separate subprocess,
while the current test process waits for it to finish. This is useful for
tests that need a fresh, isolated process state. (Note that EUnit always
starts at least one such a subprocess automatically; tests are never executed
by the caller's own process.)</p></li><li><p><strong><code class="inline">{spawn, Node::atom(), Tests}</code></strong> - Like <code class="inline">{spawn, Tests}</code>, but runs the
specified tests on the given Erlang node.</p></li><li><p><strong><code class="inline">{timeout, Time::number(), Tests}</code></strong> - Runs the specified tests under the
given timeout. Time is in seconds; e.g., 60 means one minute and 0.1 means
1/10th of a second. If the timeout is exceeded, the unfinished tests will be
forced to terminate. Note that if a timeout is set around a fixture, it
includes the time for setup and cleanup, and if the timeout is triggered, the
entire fixture is abruptly terminated (without running the cleanup). The
default timeout for an individual test is 5 seconds.</p></li><li><p><strong><code class="inline">{inorder, Tests}</code></strong> - Runs the specified tests in strict order. Also see
<code class="inline">{inparallel, Tests}</code>. By default, tests are neither marked as <code class="inline">inorder</code> or
<code class="inline">inparallel</code>, but may be executed as the test framework chooses.</p></li><li><p><strong><code class="inline">{inparallel, Tests}</code></strong> - Runs the specified tests in parallel (if
possible). Also see <code class="inline">{inorder, Tests}</code>.</p></li><li><p><strong><code class="inline">{inparallel, N::integer(), Tests}</code></strong> - Like <code class="inline">{inparallel, Tests}</code>, but
running no more than <code class="inline">N</code> subtests simultaneously.</p></li></ul><h3 id="fixtures" class="section-heading"><a href="#fixtures" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Fixtures</span></h3><p>A &quot;fixture&quot; is some state that is necessary for a particular set of tests to
run. EUnit's support for fixtures makes it easy to set up such state locally for
a test set, and automatically tear it down again when the test set is finished,
regardless of the outcome (success, failures, timeouts, etc.).</p><p>To make the descriptions simpler, we first list some definitions:</p><table><thead><tr><th style="text-align: left;"></th><th style="text-align: left;"></th></tr></thead><tbody><tr><td style="text-align: left;"><code class="inline">Setup</code></td><td style="text-align: left;"><code class="inline">() -&gt; (R::any())</code></td></tr><tr><td style="text-align: left;"><code class="inline">SetupX</code></td><td style="text-align: left;"><code class="inline">(X::any()) -&gt; (R::any())</code></td></tr><tr><td style="text-align: left;"><code class="inline">Cleanup</code></td><td style="text-align: left;"><code class="inline">(R::any()) -&gt; any()</code></td></tr><tr><td style="text-align: left;"><code class="inline">CleanupX</code></td><td style="text-align: left;"><code class="inline">(X::any(), R::any()) -&gt; any()</code></td></tr><tr><td style="text-align: left;"><code class="inline">Instantiator</code></td><td style="text-align: left;"><code class="inline">((R::any()) -&gt; Tests)</code> | <code class="inline">{with, [AbstractTestFun::((any()) -&gt; any())]}</code></td></tr><tr><td style="text-align: left;"><code class="inline">Where</code></td><td style="text-align: left;"><code class="inline">local</code> | <code class="inline">spawn</code> | <code class="inline">{spawn, Node::atom()}</code></td></tr></tbody></table><p>(these are explained in more detail further below.)</p><p>The following representations specify fixture handling for test sets:</p><ul><li><p><strong><code class="inline">{setup, Setup, Tests | Instantiator}</code></strong></p></li><li><p><strong><code class="inline">{setup, Setup, Cleanup, Tests | Instantiator}</code></strong></p></li><li><p><strong><code class="inline">{setup, Where, Setup, Tests | Instantiator}</code></strong></p></li><li><p><strong><code class="inline">{setup, Where, Setup, Cleanup, Tests | Instantiator}</code></strong> - <code class="inline">setup</code> sets up a
single fixture for running all of the specified tests, with optional teardown
afterwards. The arguments are described in detail below.</p></li><li><p><strong><code class="inline">{node, Node::atom(), Tests | Instantiator}</code></strong></p></li><li><p><strong><code class="inline">{node, Node::atom(), Args::string(), Tests | Instantiator}</code></strong> - <code class="inline">node</code> is
like <code class="inline">setup</code>, but with a built-in behaviour: it starts a slave node for the
duration of the tests. The atom <code class="inline">Node</code> should have the format
<code class="inline">nodename@full.machine.name</code>, and <code class="inline">Args</code> are the optional arguments to the new
node; see <a href="../../apps/stdlib/slave.html#start_link/3"><code class="inline">slave:start_link/3</code></a> for details.</p></li><li><p><strong><code class="inline">{foreach, Where, Setup, Cleanup, [Tests | Instantiator]}</code></strong></p></li><li><p><strong><code class="inline">{foreach, Setup, Cleanup, [Tests | Instantiator]}</code></strong></p></li><li><p><strong><code class="inline">{foreach, Where, Setup, [Tests | Instantiator]}</code></strong></p></li><li><p><strong><code class="inline">{foreach, Setup, [Tests | Instantiator]}</code></strong> - <code class="inline">foreach</code> is used to set up a
fixture and optionally tear it down afterwards, repeated for each single one
of the specified test sets.</p></li><li><p><strong><code class="inline">{foreachx, Where, SetupX, CleanupX, Pairs::[{X::any(), ((X::any(), R::any()) -&gt; Tests)}]}</code></strong></p></li><li><p><strong><code class="inline">{foreachx, SetupX, CleanupX, Pairs}</code></strong></p></li><li><p><strong><code class="inline">{foreachx, Where, SetupX, Pairs}</code></strong></p></li><li><p><strong><code class="inline">{foreachx, SetupX, Pairs}</code></strong> - <code class="inline">foreachx</code> is like <code class="inline">foreach</code>, but uses a
list of pairs, each containing an extra argument <code class="inline">X</code> and an extended
instantiator function.</p></li></ul><p>A <code class="inline">Setup</code> function is executed just before any of the specified tests are run,
and a <code class="inline">Cleanup</code> function is executed when no more of the specified tests will be
run, regardless of the reason. A <code class="inline">Setup</code> function takes no argument, and returns
some value which will be passed as it is to the <code class="inline">Cleanup</code> function. A <code class="inline">Cleanup</code>
function should do whatever necessary and return some arbitrary value, such as
the atom <code class="inline">ok</code>. (<code class="inline">SetupX</code> and <code class="inline">CleanupX</code> functions are similar, but receive one
additional argument: some value <code class="inline">X</code>, which depends on the context.) When no
<code class="inline">Cleanup</code> function is specified, a dummy function is used which has no effect.</p><p>An <code class="inline">Instantiator</code> function receives the same value as the <code class="inline">Cleanup</code> function,
i.e., the value returned by the <code class="inline">Setup</code> function. It should then behave much
like a generator (see <a href="chapter.html#primitives">Primitives</a>), and return a test
set whose tests have been <em>instantiated</em> with the given value. A special case is
the syntax <code class="inline">{with, [AbstractTestFun]}</code> which represents an instantiator function
that distributes the value over a list of unary functions; see
<a href="chapter.html#primitives">Primitives</a>: <code class="inline">{with, X, [...]}</code> for more details.</p><p>A <code class="inline">Where</code> term controls how the specified tests are executed. The default is
<code class="inline">spawn</code>, which means that the current process handles the setup and teardown,
while the tests are executed in a subprocess. <code class="inline">{spawn, Node}</code> is like <code class="inline">spawn</code>,
but runs the subprocess on the specified node. <code class="inline">local</code> means that the current
process will handle both setup/teardown and running the tests - the drawback is
that if a test times out so that the process is killed, the <em>cleanup will not be
performed</em>; hence, avoid this for persistent fixtures such as file operations.
In general, <code class="inline">local</code> should only be used when:</p><ul><li>the setup/teardown needs to be executed by the process that will run the
tests;</li><li>no further teardown needs to be done if the process is killed (i.e., no state
outside the process was affected by the setup)</li></ul><p><a href="" id="Lazy_generators"></a></p><h3 id="lazy-generators" class="section-heading"><a href="#lazy-generators" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Lazy generators</span></h3><p>Sometimes, it can be convenient not to produce the whole set of test
descriptions before the testing begins; for example, if you want to generate a
huge amount of tests that would take up too much space to keep in memory all at
once.</p><p>It is fairly easy to write a generator which, each time it is called, either
produces an empty list if it is done, or otherwise produces a list containing a
single test case plus a new generator which will produce the rest of the tests.
This demonstrates the basic pattern:</p><pre><code class="text">   lazy_test_() -&gt;
       lazy_gen(10000).

   lazy_gen(N) -&gt;
       {generator,
        fun () -&gt;
            if N &gt; 0 -&gt;
                   [?_test(...)
                    | lazy_gen(N-1)];
               true -&gt;
                   []
            end
        end}.</code></pre><p>When EUnit traverses the test representation in order to run the tests, the new
generator will not be called to produce the next test until the previous test
has been executed.</p><p>Note that it is easiest to write this kind of recursive generator using a help
function, like the <code class="inline">lazy_gen/1</code> function above. It can also be written using a
recursive fun, if you prefer to not clutter your function namespace and are
comfortable with writing that kind of code.</p>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="notes.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          â† Previous Page
        </span>
        <span class="title">
EUnit Release Notes
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="eunit.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.38.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright Â© 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
