<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="utf-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- gen_statem Behaviour</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script id="js3" type="text/javascript" src="../js/topbar.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function setscrollpos() {
                var objf = document.getElementById('loadscrollpos');
                if (objf) {
                  document.getElementById("leftnav").firstChild.scrollTop = objf.offsetTop - 10;
                }
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //-->
</script><div class="topbar">
<div class="topbar-expand "><button onclick="toggleDisplay();"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" id="Capa_1" viewBox="0 0 54 54" width="24" height="24"><g><path style="fill:#000000;" d="M27,54c-0.552,0-1-0.448-1-1V8c0-0.552,0.448-1,1-1s1,0.448,1,1v45C28,53.552,27.552,54,27,54z"></path><path style="fill:#000000;" d="M11,25c-0.256,0-0.512-0.098-0.707-0.293c-0.391-0.391-0.391-1.023,0-1.414l16-16                                      c0.391-0.391,1.023-0.391,1.414,0s0.391,1.023,0,1.414l-16,16C11.512,24.902,11.256,25,11,25z"></path><path style="fill:#000000;" d="M43,25c-0.256,0-0.512-0.098-0.707-0.293l-16-16c-0.391-0.391-0.391-1.023,0-1.414                                      s1.023-0.391,1.414,0l16,16c0.391,0.391,0.391,1.023,0,1.414C43.512,24.902,43.256,25,43,25z"></path><path style="fill:#000000;" d="M43,2H11c-0.552,0-1-0.448-1-1s0.448-1,1-1h32c0.552,0,1,0.448,1,1S43.552,2,43,2z"></path></g></svg></button></div>
<div class="topbar-title"><h1 id="gen_statem Behaviour">3 
                gen_statem Behaviour</h1></div>
<div class="search-expand ">        <button id="docsearch-mobile">
            <svg fill="#000000" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 50 50" width="24" height="24"><path d="M 21 3 C 11.621094 3 4 10.621094 4 20 C 4 29.378906 11.621094 37 21 37 C 24.710938 37 28.140625 35.804688 30.9375 33.78125 L 44.09375 46.90625 L 46.90625 44.09375 L 33.90625 31.0625 C 36.460938 28.085938 38 24.222656 38 20 C 38 10.621094 30.378906 3 21 3 Z M 21 5 C 29.296875 5 36 11.703125 36 20 C 36 28.296875 29.296875 35 21 35 C 12.703125 35 6 28.296875 6 20 C 6 11.703125 12.703125 5 21 5 Z"/></svg>
        </button>
</div>
</div>
<aside class="hide-mobile" id="leftnav"><nav class="leftnav-tube"><div class="erlang-logo-wrapper"><a href="../index.html"><img alt="Erlang Logo" src="../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">OTP Design Principles</p>
<p class="section-subtitle">User's Guide</p>
<p class="section-version">Version 12.1.2</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="../pdf/otp-system-documentation.pdf">PDF</a></li>
<li><a href="../index.html">Top</a></li>
</ul>
<div id="docsearch"></div>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3 id="chapters">Chapters</h3>
<ul class="flipMenu" imagePath="../js/flipmenu">
<li id="no" title="Overview" expanded="false">Overview<ul>
<li><a href="des_princ.html">
              Top of chapter
            </a></li>
<li title="Supervision Trees"><a href="des_princ.html#supervision-trees">Supervision Trees</a></li>
<li title="Behaviours"><a href="des_princ.html#behaviours">Behaviours</a></li>
<li title="Applications"><a href="des_princ.html#applications">Applications</a></li>
<li title="Releases"><a href="des_princ.html#releases">Releases</a></li>
<li title="Release Handling"><a href="des_princ.html#release-handling">Release Handling</a></li>
</ul>
</li>
<li id="no" title="gen_server Behaviour" expanded="false">gen_server Behaviour<ul>
<li><a href="gen_server_concepts.html">
              Top of chapter
            </a></li>
<li title="Client-Server Principles"><a href="gen_server_concepts.html#client-server-principles">Client-Server Principles</a></li>
<li title="Example"><a href="gen_server_concepts.html#example">Example</a></li>
<li title="Starting a Gen_Server"><a href="gen_server_concepts.html#starting-a-gen_server">Starting a Gen_Server</a></li>
<li title="Synchronous Requests - Call"><a href="gen_server_concepts.html#synchronous-requests---call">Synchronous Requests - Call</a></li>
<li title="Asynchronous Requests - Cast"><a href="gen_server_concepts.html#asynchronous-requests---cast">Asynchronous Requests - Cast</a></li>
<li title="Stopping"><a href="gen_server_concepts.html#stopping">Stopping</a></li>
<li title="Handling Other Messages"><a href="gen_server_concepts.html#handling-other-messages">Handling Other Messages</a></li>
</ul>
</li>
<li id="loadscrollpos" title="gen_statem Behaviour" expanded="true">gen_statem Behaviour<ul>
<li><a href="statem.html">
              Top of chapter
            </a></li>
<li title="Event-Driven State Machines"><a href="statem.html#event-driven-state-machines">Event-Driven State Machines</a></li>
<li title="When to use gen_statem"><a href="statem.html#when-to-use-gen_statem">When to use gen_statem</a></li>
<li title="Callback Module"><a href="statem.html#callback-module">Callback Module</a></li>
<li title="Callback Modes"><a href="statem.html#callback-modes">Callback Modes</a></li>
<li title="State Callback"><a href="statem.html#state-callback">State Callback</a></li>
<li title="Transition Actions"><a href="statem.html#transition-actions">Transition Actions</a></li>
<li title="Event Types and Event Content"><a href="statem.html#event-types-and-event-content">Event Types and Event Content</a></li>
<li title="State Enter Calls"><a href="statem.html#state-enter-calls">State Enter Calls</a></li>
<li title="Time-Outs"><a href="statem.html#time-outs">Time-Outs</a></li>
<li title="Example"><a href="statem.html#example">Example</a></li>
<li title="Starting gen_statem"><a href="statem.html#starting-gen_statem">Starting gen_statem</a></li>
<li title="Handling Events"><a href="statem.html#handling-events">Handling Events</a></li>
<li title="State Time-Outs"><a href="statem.html#state-time-outs">State Time-Outs</a></li>
<li title="All State Events"><a href="statem.html#all-state-events">All State Events</a></li>
<li title="One State Callback"><a href="statem.html#one-state-callback">One State Callback</a></li>
<li title="Stopping"><a href="statem.html#stopping">Stopping</a></li>
<li title="Event Time-Outs"><a href="statem.html#event-time-outs">Event Time-Outs</a></li>
<li title="Generic Time-Outs"><a href="statem.html#generic-time-outs">Generic Time-Outs</a></li>
<li title="Erlang Timers"><a href="statem.html#erlang-timers">Erlang Timers</a></li>
<li title="Postponing Events"><a href="statem.html#postponing-events">Postponing Events</a></li>
<li title="State Enter Actions"><a href="statem.html#state-enter-actions">State Enter Actions</a></li>
<li title="Inserted Events"><a href="statem.html#inserted-events">Inserted Events</a></li>
<li title="Example Revisited"><a href="statem.html#example-revisited">Example Revisited</a></li>
<li title="Filter the State"><a href="statem.html#filter-the-state">Filter the State</a></li>
<li title="Complex State"><a href="statem.html#complex-state">Complex State</a></li>
<li title="Hibernation"><a href="statem.html#hibernation">Hibernation</a></li>
</ul>
</li>
<li id="no" title="gen_event Behaviour" expanded="false">gen_event Behaviour<ul>
<li><a href="events.html">
              Top of chapter
            </a></li>
<li title="Event Handling Principles"><a href="events.html#event-handling-principles">Event Handling Principles</a></li>
<li title="Example"><a href="events.html#example">Example</a></li>
<li title="Starting an Event Manager"><a href="events.html#starting-an-event-manager">Starting an Event Manager</a></li>
<li title="Adding an Event Handler"><a href="events.html#adding-an-event-handler">Adding an Event Handler</a></li>
<li title="Notifying about Events"><a href="events.html#notifying-about-events">Notifying about Events</a></li>
<li title="Deleting an Event Handler"><a href="events.html#deleting-an-event-handler">Deleting an Event Handler</a></li>
<li title="Stopping"><a href="events.html#stopping">Stopping</a></li>
<li title="Handling Other Messages"><a href="events.html#handling-other-messages">Handling Other Messages</a></li>
</ul>
</li>
<li id="no" title="Supervisor Behaviour" expanded="false">Supervisor Behaviour<ul>
<li><a href="sup_princ.html">
              Top of chapter
            </a></li>
<li title="Supervision Principles"><a href="sup_princ.html#supervision-principles">Supervision Principles</a></li>
<li title="Example"><a href="sup_princ.html#example">Example</a></li>
<li title="Supervisor Flags"><a href="sup_princ.html#supervisor-flags">Supervisor Flags</a></li>
<li title="Restart Strategy"><a href="sup_princ.html#restart-strategy">Restart Strategy</a></li>
<li title="Maximum Restart Intensity"><a href="sup_princ.html#maximum-restart-intensity">Maximum Restart Intensity</a></li>
<li title="Automatic Shutdown"><a href="sup_princ.html#automatic-shutdown">Automatic Shutdown</a></li>
<li title="Child Specification"><a href="sup_princ.html#child-specification">Child Specification</a></li>
<li title="Starting a Supervisor"><a href="sup_princ.html#starting-a-supervisor">Starting a Supervisor</a></li>
<li title="Adding a Child Process"><a href="sup_princ.html#adding-a-child-process">Adding a Child Process</a></li>
<li title="Stopping a Child Process"><a href="sup_princ.html#stopping-a-child-process">Stopping a Child Process</a></li>
<li title="Simplified one_for_one Supervisors"><a href="sup_princ.html#simplified-one_for_one-supervisors">Simplified one_for_one Supervisors</a></li>
<li title="Stopping"><a href="sup_princ.html#stopping">Stopping</a></li>
</ul>
</li>
<li id="no" title="sys and proc_lib" expanded="false">sys and proc_lib<ul>
<li><a href="spec_proc.html">
              Top of chapter
            </a></li>
<li title="Simple Debugging"><a href="spec_proc.html#simple-debugging">Simple Debugging</a></li>
<li title="Special Processes"><a href="spec_proc.html#special-processes">Special Processes</a></li>
<li title="User-Defined Behaviours"><a href="spec_proc.html#user-defined-behaviours">User-Defined Behaviours</a></li>
</ul>
</li>
<li id="no" title="Applications" expanded="false">Applications<ul>
<li><a href="applications.html">
              Top of chapter
            </a></li>
<li title="Application Concept"><a href="applications.html#application-concept">Application Concept</a></li>
<li title="Application Callback Module"><a href="applications.html#application-callback-module">Application Callback Module</a></li>
<li title="Application Resource File"><a href="applications.html#application-resource-file">Application Resource File</a></li>
<li title="Directory Structure"><a href="applications.html#directory-structure">Directory Structure</a></li>
<li title="Application Controller"><a href="applications.html#application-controller">Application Controller</a></li>
<li title="Loading and Unloading Applications"><a href="applications.html#loading-and-unloading-applications">Loading and Unloading Applications</a></li>
<li title="Starting and Stopping Applications"><a href="applications.html#starting-and-stopping-applications">Starting and Stopping Applications</a></li>
<li title="Configuring an Application"><a href="applications.html#configuring-an-application">Configuring an Application</a></li>
<li title="Application Start Types"><a href="applications.html#application-start-types">Application Start Types</a></li>
</ul>
</li>
<li id="no" title="Included Applications" expanded="false">Included Applications<ul>
<li><a href="included_applications.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="included_applications.html#introduction">Introduction</a></li>
<li title="Specifying Included Applications"><a href="included_applications.html#specifying-included-applications">Specifying Included Applications</a></li>
<li title="Synchronizing Processes during Startup"><a href="included_applications.html#synchronizing-processes-during-startup">Synchronizing Processes during Startup</a></li>
</ul>
</li>
<li id="no" title="Distributed Applications" expanded="false">Distributed Applications<ul>
<li><a href="distributed_applications.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="distributed_applications.html#introduction">Introduction</a></li>
<li title="Specifying Distributed Applications"><a href="distributed_applications.html#specifying-distributed-applications">Specifying Distributed Applications</a></li>
<li title="Starting and Stopping Distributed Applications"><a href="distributed_applications.html#starting-and-stopping-distributed-applications">Starting and Stopping Distributed Applications</a></li>
<li title="Failover"><a href="distributed_applications.html#failover">Failover</a></li>
<li title="Takeover"><a href="distributed_applications.html#takeover">Takeover</a></li>
</ul>
</li>
<li id="no" title="Releases" expanded="false">Releases<ul>
<li><a href="release_structure.html">
              Top of chapter
            </a></li>
<li title="Release Concept"><a href="release_structure.html#release-concept">Release Concept</a></li>
<li title="Release Resource File"><a href="release_structure.html#release-resource-file">Release Resource File</a></li>
<li title="Generating Boot Scripts"><a href="release_structure.html#generating-boot-scripts">Generating Boot Scripts</a></li>
<li title="Creating a Release Package"><a href="release_structure.html#creating-a-release-package">Creating a Release Package</a></li>
<li title="Directory Structure"><a href="release_structure.html#directory-structure">Directory Structure</a></li>
</ul>
</li>
<li id="no" title="Release Handling" expanded="false">Release Handling<ul>
<li><a href="release_handling.html">
              Top of chapter
            </a></li>
<li title="Release Handling Principles"><a href="release_handling.html#release-handling-principles">Release Handling Principles</a></li>
<li title="Requirements"><a href="release_handling.html#requirements">Requirements</a></li>
<li title="Distributed Systems"><a href="release_handling.html#distributed-systems">Distributed Systems</a></li>
<li title="Release Handling Instructions"><a href="release_handling.html#release-handling-instructions">Release Handling Instructions</a></li>
<li title="Application Upgrade File"><a href="release_handling.html#application-upgrade-file">Application Upgrade File</a></li>
<li title="Release Upgrade File"><a href="release_handling.html#release-upgrade-file">Release Upgrade File</a></li>
<li title="Installing a Release"><a href="release_handling.html#installing-a-release">Installing a Release</a></li>
<li title="Updating Application Specifications"><a href="release_handling.html#updating-application-specifications">Updating Application Specifications</a></li>
</ul>
</li>
<li id="no" title="Appup Cookbook" expanded="false">Appup Cookbook<ul>
<li><a href="appup_cookbook.html">
              Top of chapter
            </a></li>
<li title="Changing a Functional Module"><a href="appup_cookbook.html#changing-a-functional-module">Changing a Functional Module</a></li>
<li title="Changing a Residence Module"><a href="appup_cookbook.html#changing-a-residence-module">Changing a Residence Module</a></li>
<li title="Changing a Callback Module"><a href="appup_cookbook.html#changing-a-callback-module">Changing a Callback Module</a></li>
<li title="Changing Internal State"><a href="appup_cookbook.html#changing-internal-state">Changing Internal State</a></li>
<li title="Module Dependencies"><a href="appup_cookbook.html#module-dependencies">Module Dependencies</a></li>
<li title="Changing Code for a Special Process"><a href="appup_cookbook.html#changing-code-for-a-special-process">Changing Code for a Special Process</a></li>
<li title="Changing a Supervisor"><a href="appup_cookbook.html#changing-a-supervisor">Changing a Supervisor</a></li>
<li title="Adding or Deleting a Module"><a href="appup_cookbook.html#adding-or-deleting-a-module">Adding or Deleting a Module</a></li>
<li title="Starting or Terminating a Process"><a href="appup_cookbook.html#starting-or-terminating-a-process">Starting or Terminating a Process</a></li>
<li title="Adding or Removing an Application"><a href="appup_cookbook.html#adding-or-removing-an-application">Adding or Removing an Application</a></li>
<li title="Restarting an Application"><a href="appup_cookbook.html#restarting-an-application">Restarting an Application</a></li>
<li title="Changing an Application Specification"><a href="appup_cookbook.html#changing-an-application-specification">Changing an Application Specification</a></li>
<li title="Changing Application Configuration"><a href="appup_cookbook.html#changing-application-configuration">Changing Application Configuration</a></li>
<li title="Changing Included Applications"><a href="appup_cookbook.html#changing-included-applications">Changing Included Applications</a></li>
<li title="Changing Non-Erlang Code"><a href="appup_cookbook.html#changing-non-erlang-code">Changing Non-Erlang Code</a></li>
<li title="Emulator Restart and Upgrade"><a href="appup_cookbook.html#emulator-restart-and-upgrade">Emulator Restart and Upgrade</a></li>
<li title="Emulator Upgrade From Pre OTP R15"><a href="appup_cookbook.html#emulator-upgrade-from-pre-otp-r15">Emulator Upgrade From Pre OTP R15</a></li>
</ul>
</li>
</ul></nav></aside><div id="content">
<div class="innertube">
<h1 id="gen_statem Behaviour">3 gen_statem Behaviour</h1>
  
  <a name="gen_statem%20Behaviour"></a>
  <p>
    This section is to be read with the
    <span class="bold_code bc-18"><a href="../man/gen_statem.html"><span class="code">gen_statem(3)</span></a></span>
    manual page in STDLIB, where all interface functions and callback
    functions are described in detail.
  </p>



  <a name="Event-Driven%20State%20Machines"></a><h3 id="event-driven-state-machines" class="title-link" onMouseOver="document.getElementById('ghlink-event-driven-state-machines-idm339').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-event-driven-state-machines-idm339').style.visibility = 'hidden';">
<div class="title-name">3.1 
        Event-Driven State Machines</div>
<div class="title-anchors"><span id="ghlink-event-driven-state-machines-idm339" class="ghlink-after"><a href="#event-driven-state-machines" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L42" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      Established Automata Theory does not deal much with
      how a <strong>state transition</strong> is triggered,
      but assumes that the output is a function
      of the input (and the state) and that they are
      some kind of values.
    </p>
    <p>
      For an Event-Driven State Machine, the input is an event
      that triggers a <strong>state transition</strong> and the output
      is actions executed during the <strong>state transition</strong>.
      Analogously to the mathematical model of a
      Finite State Machine, it can be described as
      a set of relations of the following form:
    </p>
    <div class="example"><pre>
State(S) x Event(E) -&gt; Actions(A), State(S')</pre></div>
    <p>
      These relations are interpreted as follows:
      if we are in state <span class="code">S</span> and event <span class="code">E</span> occurs, we
      are to perform actions <span class="code">A</span>, and make a transition to
      state <span class="code">S'</span>. Notice that <span class="code">S'</span> can be equal to <span class="code">S</span>,
      and that <span class="code">A</span> can be empty.
    </p>
    <p>
      In <span class="code">gen_statem</span> we define
      a <strong>state change</strong> as a <strong>state transition</strong>
      in which the new state <span class="code">S'</span> is different from
      the current state <span class="code">S</span>, where "different" means
      Erlang's strict inequality: <span class="code">=/=</span>
      also known as "does not match".
      <span class="code">gen_statem</span> does more things during <strong>state changes</strong>
      than during other <strong>state transitions</strong>.
    </p>
    <p>
      As <span class="code">A</span> and <span class="code">S'</span> depend only on
      <span class="code">S</span> and <span class="code">E</span>, the kind of state machine described
      here is a Mealy machine
      (see, for example, the Wikipedia article "Mealy machine").
    </p>
    <p>
      Like most <span class="code">gen_</span> behaviours, <span class="code">gen_statem</span> keeps
      a server <span class="code">Data</span> besides the state. Because of this, and as
      there is no restriction on the number of states
      (assuming that there is enough virtual machine memory)
      or on the number of distinct input events,
      a state machine implemented with this behaviour
      is in fact Turing complete.
      But it feels mostly like an Event-Driven Mealy machine.
    </p>
  



  <a name="When%20to%20use%20gen_statem"></a><h3 id="when-to-use-gen_statem" class="title-link" onMouseOver="document.getElementById('ghlink-when-to-use-gen_statem-idm375').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-when-to-use-gen_statem-idm375').style.visibility = 'hidden';">
<div class="title-name">3.2 
        When to use gen_statem</div>
<div class="title-anchors"><span id="ghlink-when-to-use-gen_statem-idm375" class="ghlink-after"><a href="#when-to-use-gen_statem" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L99" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      If your process logic is convenient to describe as a state machine,
      and you want any of these <span class="code">gen_statem</span> key features:
    </p>
    <ul>
      <li>
	Co-located callback code for each state,
	for all
	<span class="bold_code bc-17"><a href="#Event%20Types%20and%20Event%20Content">
	  <strong>Event Types</strong>
	</a></span>
	(such as <strong>call</strong>, <strong>cast</strong> and <strong>info</strong>)
      </li>
      <li>
	<span class="bold_code bc-17"><a href="#Postponing%20Events">
	  Postponing Events
	</a></span>
	(a substitute for selective receive)
      </li>
      <li>
	<span class="bold_code bc-17"><a href="#Inserted%20Events">
	  Inserted Events
	</a></span>
	(that is, events from the state machine to itself;
	 for purely internal events in particular)
      </li>
      <li>
	<span class="bold_code bc-17"><a href="#State%20Enter%20Calls">
	  <strong>State Enter Calls</strong>
	</a></span>
	(callback on state entry co-located with the rest
	of each state's callback code)
      </li>
      <li>
	Easy-to-use time-outs
	(<span class="bold_code bc-17"><a href="#State%20Time-Outs">State Time-Outs</a></span>,
	<span class="bold_code bc-17"><a href="#Event%20Time-Outs">Event Time-Outs</a></span>
	and
	<span class="bold_code bc-17"><a href="#Generic%20Time-Outs">Generic Time-Outs</a></span>
	(named time-outs))
      </li>
    </ul>
    <p>
      If so, or if possibly needed in future versions,
      then you should consider using <span class="code">gen_statem</span> over
      <span class="bold_code bc-18"><a href="../man/gen_server.html"><span class="code">gen_server</span></a></span>.
    </p>
    <p>
      For simple state machines not needing these features
      <span class="bold_code bc-18"><a href="../man/gen_server.html"><span class="code">gen_server</span></a></span>
      works just fine.
      It also has got smaller call overhead,
      but we are talking about something like 2 vs 3.3 microseconds
      call roundtrip time here, so if the server callback
      does just a little bit more than just replying,
      or if the call is not extremely frequent,
      that difference will be hard to notice.
    </p>
  



  <a name="Callback%20Module"></a><h3 id="callback-module" class="title-link" onMouseOver="document.getElementById('ghlink-callback-module-idm405').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-callback-module-idm405').style.visibility = 'hidden';">
<div class="title-name">3.3 
        Callback Module</div>
<div class="title-anchors"><span id="ghlink-callback-module-idm405" class="ghlink-after"><a href="#callback-module" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L164" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      The <strong>callback module</strong> contains functions that implement
      the state machine.
      When an event occurs,
      the <span class="code">gen_statem</span> behaviour engine
      calls a function in the <strong>callback module</strong> with the event,
      current state and server data.
      This function performs the actions for this event,
      and returns the new state and server data
      and also actions to be performed by the behaviour engine.
    </p>
    <p>
      The behaviour engine holds the state machine state,
      server data, timer references, a queue of postponed messages
      and other metadata.  It receives all process messages,
      handles the system messages, and calls the <strong>callback module</strong>
      with machine specific events.
    </p>
    <p>
      The <strong>callback module</strong> can be changed for a running server
      using any of the
      <span class="bold_code bc-17"><a href="#Transition%20Actions">transition actions</a></span>
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-action"><span class="code">{change_callback_module, NewModule}</span></a></span>,
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-action"><span class="code">{push_callback_module, NewModule}</span></a></span> or
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-action"><span class="code">pop_callback_module</span></a></span>.
      Note that this is a pretty esoteric thing to do...
      The origin for this feature is a protocol that after
      version negotiation branches off into quite different
      state machines depending on the protocol version.
      There <i>might</i> be other use cases.
      <i>Beware</i> that the new callback module
      completely replaces the previous behaviour module,
      so all relevant callback functions have to handle
      the state and data from the previous callback module.
    </p>
  



  <a name="Callback%20Modes"></a><h3 id="callback-modes" class="title-link" onMouseOver="document.getElementById('ghlink-callback-modes-idm425').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-callback-modes-idm425').style.visibility = 'hidden';">
<div class="title-name">3.4 
        Callback Modes</div>
<div class="title-anchors"><span id="ghlink-callback-modes-idm425" class="ghlink-after"><a href="#callback-modes" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L206" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      The <span class="code">gen_statem</span> behaviour supports two <strong>callback modes</strong>:
    </p>
    <dl>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-callback_mode">
	  <span class="code">state_functions</span>
	</a></span>
      </strong></dt>
      <dd>
        <p>
	  Events are handled by one callback function per state.
	</p>
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-callback_mode">
	  <span class="code">handle_event_function</span>
	  </a></span>
      </strong></dt>
      <dd>
        <p>
	  Events are handled by one single callback function.
	</p>
      </dd>
    </dl>
    <p>
      The <strong>callback mode</strong> is a property of
      the <strong>callback module</strong> and is set at server start.
      It may be changed due to a code upgrade/downgrade,
      or when changing the <strong>callback module</strong>.
    </p>
    <p>
      See the section
      <span class="bold_code bc-17"><a href="#State%20Callback"><strong>State Callback</strong></a></span>
      that describes the event handling callback function(s).
    </p>
    <p>
      The <strong>callback mode</strong> is selected by implementing
      a mandatory callback function
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#Module:callback_mode-0">
	<span class="code">Module:callback_mode()</span>
      </a></span>
      that returns one of the <strong>callback modes</strong>.
    </p>
    <p>
      The
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#Module:callback_mode-0">
	<span class="code">Module:callback_mode()</span>
      </a></span>
      function may also return a list containing the <strong>callback mode</strong>
      and the atom <span class="code">state_enter</span> in which case
      <span class="bold_code bc-17"><a href="#State%20Enter%20Calls">
	<strong>state enter calls</strong>
      </a></span>
      are activated for the <strong>callback mode</strong>.
    </p>

    <a name="Choosing%20the%20Callback%20Mode"></a><h4 id="choosing-the-callback-mode" class="title-link" onMouseOver="document.getElementById('ghlink-choosing-the-callback-mode-idm462').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-choosing-the-callback-mode-idm462').style.visibility = 'hidden';">
<div class="title-name">Choosing the Callback Mode</div>
<div class="title-anchors"><span id="ghlink-choosing-the-callback-mode-idm462" class="ghlink-after"><a href="#choosing-the-callback-mode" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L266" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h4>
      
      
      <p>
	The short version: choose <span class="code">state_functions</span> -
	it is the one most like <span class="code">gen_fsm</span>.
	But if you do not want the restriction that the state
	must be an atom, or if you do not want to write
	one <strong>state callback</strong> function per state; please read on...
      </p>
      <p>
	The two
	<span class="bold_code bc-17"><a href="#Callback%20Modes"><strong>callback modes</strong></a></span>
	give different possibilities and restrictions,
	with one common goal:
	to handle all possible combinations of events and states.
      </p>
      <p>
	This can be done, for example, by focusing on one state at the time
	and for every state ensure that all events are handled.
	Alternatively, you can focus on one event at the time
	and ensure that it is handled in every state.
	You can also use a mix of these strategies.
      </p>
      <p>
	With <span class="code">state_functions</span>, you are restricted to use
	atom-only states, and the <span class="code">gen_statem</span> engine
	branches depending on state name for you.
	This encourages the <strong>callback module</strong> to co-locate
	the implementation of all event actions particular
	to one state in the same place in the code,
	hence to focus on one state at the time.
      </p>
      <p>
	This mode fits well when you have a regular state diagram,
	like the ones in this chapter, which describes all events and actions
	belonging to a state visually around that state,
	and each state has its unique name.
      </p>
      <p>
	With <span class="code">handle_event_function</span>, you are free to mix strategies,
	as all events and states are handled in the same callback function.
      </p>
      <p>
	This mode works equally well when you want to focus on
	one event at the time or on
	one state at the time, but function
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#Module:handle_event-4">
	  <span class="code">Module:handle_event/4</span>
	</a></span>
	quickly grows too large to handle without branching to
	helper functions.
      </p>
      <p>
	The mode enables the use of non-atom states, for example,
	complex states or even hierarchical states.
	See section
	<span class="bold_code bc-17"><a href="#Complex%20State">Complex State</a></span>.
	If, for example, a state diagram is largely alike
	for the client side and the server side of a protocol,
	you can have a state <span class="code">{StateName,server}</span> or
	<span class="code">{StateName,client}</span>,
	and make <span class="code">StateName</span> determine where in the code
	to handle most events in the state.
	The second element of the tuple is then used to select
	whether to handle special client-side or server-side events.
      </p>
    
  



  <a name="State%20Callback"></a><h3 id="state-callback" class="title-link" onMouseOver="document.getElementById('ghlink-state-callback-idm488').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-state-callback-idm488').style.visibility = 'hidden';">
<div class="title-name">3.5 
        State Callback</div>
<div class="title-anchors"><span id="ghlink-state-callback-idm488" class="ghlink-after"><a href="#state-callback" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L338" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      The <strong>state callback</strong> is the callback function
      that handles an event in the current state,
      and which function that is depends on the <strong>callback mode</strong>:
    </p>
    <dl>
      <dt><strong><span class="code">state_functions</span></strong></dt>
      <dd>
	The event is handled by:<br>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#Module:StateName-3">
	  <span class="code">Module:StateName(EventType, EventContent, Data)</span>
	</a></span>
	<p>
	  This form is the one mostly used in the
	  <span class="bold_code bc-17"><a href="#Example">Example</a></span>
	  section.
	</p>
      </dd>
      <dt><strong><span class="code">handle_event_function</span></strong></dt>
      <dd>
	The event is handled by:<br>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#Module:handle_event-4">
	  <span class="code">Module:handle_event(EventType, EventContent, State, Data)</span>
	</a></span>
	<p>
	  See section
	  <span class="bold_code bc-17"><a href="#One%20State%20Callback">
	    <strong>One State Callback</strong>
	  </a></span>
	  for an example.
	</p>
      </dd>
    </dl>
    <p>
      The state is either the name of the function itself or an argument to it.
      The other arguments are the <span class="code">EventType</span>
      and the event dependent <span class="code">EventContent</span>,
      both described in section
      <span class="bold_code bc-17"><a href="#Event%20Types%20and%20Event%20Content">Event Types and Event Content</a></span>,
      and the current server <span class="code">Data</span>.
    </p>
    <p>
      <strong>State enter calls</strong> are also handled by the event handler
      and have slightly different arguments. See section
      <span class="bold_code bc-17"><a href="#State%20Enter%20Calls">State Enter Calls</a></span>.
    </p>
    <p>
      The <strong>state callback</strong> return values
      are defined in the description of
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#Module:StateName-3">
	<span class="code">Module:StateName/3</span>
      </a></span>
      in the <span class="code">gen_statem</span> manual page, but here is
      a more readable list:
    </p>
    <dl>
      <dt><strong>
	<span class="code">{next_state, NextState, NewData, Actions}</span><br>
	<span class="code">{next_state, NextState, NewData}</span>
      </strong></dt>
      <dd>
	<p>
	  Set next state and update the server data.
	  If the <span class="code">Actions</span> field is used,
	  execute <strong>transition actions</strong>.
	  An empty <span class="code">Actions</span> list is equivalent to
	  not returning the field.
	</p>
	<p>
	  See section
	  <span class="bold_code bc-17"><a href="#Transition%20Actions">
	    <strong>Transition Actions</strong>
	  </a></span>
	  for a list of possible
	  <strong>transition actions</strong>.
	</p>
	<p>
	  If <span class="code">NextState =/= State</span> this is a <strong>state change</strong>
	  so the extra things <span class="code">gen_statem</span> does are: the event queue
	  is restarted from the oldest
	  <span class="bold_code bc-17"><a href="#Postponing%20Events">postponed event</a></span>,
	  any current
	  <span class="bold_code bc-17"><a href="#State%20Time-Outs">state time-out</a></span>
	  is cancelled, and a
	  <span class="bold_code bc-17"><a href="#State%20Enter%20Calls">state enter call</a></span>
	  is performed, if enabled.
	</p>
      </dd>
      <dt><strong>
	<span class="code">{keep_state, NewData, Actions}</span><br>
	<span class="code">{keep_state, NewData}</span>
      </strong></dt>
      <dd>
	<p>
	  Same as the <span class="code">next_state</span> values with
	  <span class="code">NextState =:= State</span>, that is, no <strong>state change</strong>.
	</p>
      </dd>
      <dt><strong>
	<span class="code">{keep_state_and_data, Actions}</span><br>
	<span class="code">keep_state_and_data</span>
      </strong></dt>
      <dd>
	<p>
	  Same as the <span class="code">keep_state</span> values with
	  <span class="code">NextData =:= Data</span>, that is, no change in server data.
	</p>
      </dd>
      <dt><strong>
	<span class="code">{repeat_state, NewData, Actions}</span><br>
	<span class="code">{repeat_state, NewData}</span><br>
	<span class="code">{repeat_state_and_data, Actions}</span><br>
	<span class="code">repeat_state_and_data</span>
      </strong></dt>
      <dd>
	<p>
	  Same as the <span class="code">keep_state</span> or <span class="code">keep_state_and_data</span> values,
	  and if
	  <span class="bold_code bc-17"><a href="#State%20Enter%20Calls">
	    State Enter Calls
	  </a></span>
	  are enabled, repeat the <strong>state enter call</strong>
	  as if this state was entered again.
	</p>
	<p>
	  If these return values are used from a
	  <strong>state enter call</strong> the <span class="code">OldState</span> does not change,
	  but if used from an event handling <strong>state callback</strong>
	  the new <strong>state enter call's</strong> <span class="code">OldState</span>
	  will be the current state.
	</p>
      </dd>
      <dt><strong>
	<span class="code">{stop, Reason, NewData}</span><br>
	<span class="code">{stop, Reason}</span>
      </strong></dt>
      <dd>
	<p>
	  Stop the server with reason <span class="code">Reason</span>.
	  If the <span class="code">NewData</span> field is used, first update the server data.
	</p>
      </dd>
      <dt><strong>
	<span class="code">{stop_and_reply, Reason, NewData, ReplyActions}</span><br>
	<span class="code">{stop_and_reply, Reason, ReplyActions}</span>
      </strong></dt>
      <dd>
	<p>
	  Same as the <span class="code">stop</span> values, but first execute the given
	  <span class="bold_code bc-17"><a href="#Transition%20Actions">
	    <strong>transition actions</strong>
	  </a></span>
	  that may only be reply actions.
	</p>
      </dd>
    </dl>

    <a name="The%20First%20State"></a><h4 id="the-first-state" class="title-link" onMouseOver="document.getElementById('ghlink-the-first-state-idm600').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-the-first-state-idm600').style.visibility = 'hidden';">
<div class="title-name">The First State</div>
<div class="title-anchors"><span id="ghlink-the-first-state-idm600" class="ghlink-after"><a href="#the-first-state" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L498" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h4>
      
      
      <p>
	To decide the first state the
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#Module:init-1">
	  <span class="code">Module:init(Args)</span>
	</a></span>
	callback function is called before any
	<span class="bold_code bc-17"><a href="#State%20Callback"><strong>state callback</strong></a></span>
	is called.  This function behaves like a <strong>state callback</strong>
	function, but gets its only argument <span class="code">Args</span> from
	the <span class="code">gen_statem</span>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#start-3">
	  <span class="code">start/3,4</span>
	</a></span>
	or
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#start_link-3">
	  <span class="code">start_link/3,4</span>
	</a></span>
	function, and returns <span class="code">{ok, State, Data}</span>
	or <span class="code">{ok, State, Data, Actions}</span>.
	If you use the
	<span class="bold_code bc-17"><a href="#Postponing%20Events"><span class="code">postpone</span></a></span>
	action from this function, that action is ignored,
	since there is no event	to postpone.
      </p>
    

  



  <a name="Transition%20Actions"></a><h3 id="transition-actions" class="title-link" onMouseOver="document.getElementById('ghlink-transition-actions-idm619').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-transition-actions-idm619').style.visibility = 'hidden';">
<div class="title-name">3.6 
        Transition Actions</div>
<div class="title-anchors"><span id="ghlink-transition-actions-idm619" class="ghlink-after"><a href="#transition-actions" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L531" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      In the first section
      (<span class="bold_code bc-17"><a href="#Event-Driven%20State%20Machines">Event-Driven State Machines</a></span>),
      actions were mentioned as a part of
      the general state machine model. These general actions
      are implemented with the code that <strong>callback module</strong>
      <span class="code">gen_statem</span> executes in an event-handling
      callback function before returning
      to the <span class="code">gen_statem</span> engine.
    </p>
    <p>
      There are more specific <strong>transition actions</strong>
      that a callback function can command the <span class="code">gen_statem</span>
      engine to do after the callback function return.
      These are commanded by returning a list of
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-action">actions</a></span>
      in the
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-state_callback_result">
	return value
      </a></span>
      from the
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#Module:StateName-3">callback function</a></span>.
      These are the possible <strong>transition actions</strong>:
    </p>
    <dl>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-postpone">
	  <span class="code">postpone</span>
	</a></span>
	<br>
	<span class="code">{postpone, Boolean}</span>
      </strong></dt>
      <dd>
	If set postpone the current event, see section
	<span class="bold_code bc-17"><a href="#Postponing%20Events">Postponing Events</a></span>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-hibernate">
	  <span class="code">hibernate</span>
	</a></span>
	<br>
	<span class="code">{hibernate, Boolean}</span>
      </strong></dt>
      <dd>
	If set hibernate the <span class="code">gen_statem</span>, treated in section
	<span class="bold_code bc-17"><a href="#Hibernation">Hibernation</a></span>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-state_timeout">
	  <span class="code">{state_timeout, Time, EventContent}</span>
	</a></span>
	<br>
	<span class="code">{state_timeout, Time, EventContent, Opts}</span><br>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-timeout_update_action">
	  <span class="code">{state_timeout, update, EventContent}</span>
	</a></span>
	<br>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-timeout_cancel_action">
	  <span class="code">{state_timeout, cancel}</span>
	</a></span>
      </strong></dt>
      <dd>
	Start, update or cancel a state time-out, read more in sections
	<span class="bold_code bc-17"><a href="#Time-Outs">Time-Outs</a></span> and
	<span class="bold_code bc-17"><a href="#State%20Time-Outs">State Time-Outs</a></span>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-generic_timeout">
	  <span class="code">{{timeout, Name}, Time, EventContent}</span>
	</a></span>
	<br>
	<span class="code">{{timeout, Name}, Time, EventContent, Opts}</span><br>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-timeout_update_action">
	  <span class="code">{{timeout, Name}, update, EventContent}</span>
	</a></span>
	<br>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-timeout_cancel_action">
	  <span class="code">{{timeout, Name}, cancel}</span>
	</a></span>
      </strong></dt>
      <dd>
	Start, update or cancel a generic time-out, read more in sections
	<span class="bold_code bc-17"><a href="#Time-Outs">Time-Outs</a></span> and
	<span class="bold_code bc-17"><a href="#Generic%20Time-Outs">Generic Time-Outs</a></span>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-event_timeout">
	  <span class="code">{timeout, Time, EventContent}</span>
	</a></span>
	<br>
	<span class="code">{timeout, Time, EventContent, Opts}</span><br>
	<span class="code">Time</span>
      </strong></dt>
      <dd>
	Start an event time-out, see more in sections
	<span class="bold_code bc-17"><a href="#Time-Outs">Time-Outs</a></span> and
	<span class="bold_code bc-17"><a href="#Event%20Time-Outs">Event Time-Outs</a></span>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-reply_action">
	  <span class="code">{reply, From, Reply}</span>
	</a></span>
      </strong></dt>
      <dd>
	Reply to a caller, mentioned at the end of section
	<span class="bold_code bc-17"><a href="#All%20State%20Events">All State Events</a></span>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-action">
	  <span class="code">{next_event, EventType, EventContent}</span>
	</a></span>
      </strong></dt>
      <dd>
	Generate the next event to handle, see section
	<span class="bold_code bc-17"><a href="#Inserted%20Events">Inserted Events</a></span>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-action">
	  <span class="code">{change_callback_module, NewModule}</span>
	</a></span>
      </strong></dt>
      <dd>
	Change the
	<span class="bold_code bc-17"><a href="#Callback%20Module">
	  <strong>callback module</strong>
	</a></span>
	for the running server.
	This can be done during any <strong>state transition</strong>,
	whether it is a <strong>state change</strong> or not,
	but it can <i>not</i> be done from a
	<span class="bold_code bc-17"><a href="#State%20Enter%20Calls"><strong>state enter call</strong></a></span>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-action">
	  <span class="code">{push_callback_module, NewModule}</span>
	</a></span>
      </strong></dt>
      <dd>
	Push the current <strong>callback module</strong>
	to the top of an internal stack of callback modules
	and set the new
	<span class="bold_code bc-17"><a href="#Callback%20Module">
	  <strong>callback module</strong>
	</a></span>
	for the running server.
	Otherwise like
	<span class="code">{change_callback_module, NewModule}</span>
	above.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-action">
	  <span class="code">pop_callback_module</span>
	</a></span>
      </strong></dt>
      <dd>
	Pop the top module from
	the internal stack of callback modules
	and set it to be the new
	<span class="bold_code bc-17"><a href="#Callback%20Module">
	  <strong>callback module</strong>
	</a></span>
	for the running server.
	If the stack is empty the server fails.
	Otherwise like
	<span class="code">{change_callback_module, NewModule}</span>
	above.
      </dd>
    </dl>
    <p>
      For details, see the <span class="code">gen_statem(3)</span>
      manual page for type
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-action"><span class="code">action()</span></a></span>.
      You can, for example, reply to many callers,
      generate multiple next events,
      and set a time-out to use absolute instead of relative time
      (using the <span class="code">Opts</span> field).
    </p>
    <p>
      Among these <strong>transition actions</strong> only to reply to a caller
      is an immediate action.  The others are collected and handled
      later during the <strong>state transition</strong>.
      <span class="bold_code bc-17"><a href="#Inserted%20Events">Inserted Events</a></span>
      are stored and inserted all together,
      and the rest set transition options
      where the last of a specific type override the previous.
      See the description of a <strong>state transition</strong>
      in the <span class="code">gen_statem(3)</span> manual page for type
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-transition_option"><span class="code">transition_option()</span></a></span>.
    </p>
    <p>
      The different
      <span class="bold_code bc-17"><a href="#Time-Outs">Time-Outs</a></span> and
      <span class="bold_code bc-17"><a href="#Inserted%20Events"><span class="code">next_event</span></a></span>
      actions generate new events with corresponding
      <span class="bold_code bc-17"><a href="#Event%20Types%20and%20Event%20Content">
	Event Types and Event Content
      </a></span>.
    </p>
  



  <a name="Event%20Types%20and%20Event%20Content"></a><h3 id="event-types-and-event-content" class="title-link" onMouseOver="document.getElementById('ghlink-event-types-and-event-content-idm742').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-event-types-and-event-content-idm742').style.visibility = 'hidden';">
<div class="title-name">3.7 
        Event Types and Event Content</div>
<div class="title-anchors"><span id="ghlink-event-types-and-event-content-idm742" class="ghlink-after"><a href="#event-types-and-event-content" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L736" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      Events are categorized in different
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-event_type"><strong>event types</strong></a></span>.
      Events of all types are for a given state
      handled in the same callback function, and that function gets
      <span class="code">EventType</span> and <span class="code">EventContent</span> as arguments.
      The meaning of the <span class="code">EventContent</span>
      depends on the <span class="code">EventType</span>.
    </p>
    <p>
      The following is a complete list of <strong>event types</strong> and where
      they come from:
    </p>
    <dl>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-external_event_type">
	  <span class="code">cast</span>
	</a></span>
      </strong></dt>
      <dd>
	Generated by
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#cast-2">
	  <span class="code">gen_statem:cast(ServerRef, Msg)</span>
	</a></span>
	where <span class="code">Msg</span> becomes the <span class="code">EventContent</span>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-external_event_type">
	  <span class="code">{call,From}</span>
	</a></span>
      </strong></dt>
      <dd>
	Generated by
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#call-2">
	  <span class="code">gen_statem:call(ServerRef, Request)</span>
	</a></span>
	where <span class="code">Request</span> becomes the <span class="code">EventContent</span>.
	<span class="code">From</span> is the reply address to use
	when replying either through the <strong>transition action</strong>
	<span class="code">{reply,From,Reply}</span> or by calling
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#reply-1">
	  <span class="code">gen_statem:reply(From, Reply)</span>
	</a></span>
	from the <strong>callback module</strong>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-external_event_type">
	  <span class="code">info</span>
	</a></span>
      </strong></dt>
      <dd>
	Generated by any regular process message sent to
	the <span class="code">gen_statem</span> process.
	The process message becomes the <span class="code">EventContent</span>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-timeout_event_type">
	  <span class="code">state_timeout</span>
	</a></span>
      </strong></dt>
      <dd>
	Generated by <strong>transition action</strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-timeout_action">
	  <span class="code">{state_timeout,Time,EventContent}</span>
	</a></span>
	state timer timing out. Read more in sections
	<span class="bold_code bc-17"><a href="#Time-Outs">Time-Outs</a></span> and
	<span class="bold_code bc-17"><a href="#State%20Time-Outs">State Time-Outs</a></span>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-timeout_event_type">
	  <span class="code">{timeout,Name}</span>
	</a></span>
      </strong></dt>
      <dd>
	Generated by <strong>transition action</strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-timeout_action">
	  <span class="code">{{timeout,Name},Time,EventContent}</span>
	</a></span>
	generic timer timing out.  Read more in sections
	<span class="bold_code bc-17"><a href="#Time-Outs">Time-Outs</a></span> and
	<span class="bold_code bc-17"><a href="#Generic%20Time-Outs">Generic Time-Outs</a></span>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-timeout_event_type">
	  <span class="code">timeout</span>
	</a></span>
      </strong></dt>
      <dd>
	Generated by <strong>transition action</strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-timeout_action">
	  <span class="code">{timeout,Time,EventContent}</span>
	</a></span>
	(or its short form <span class="code">Time</span>)
	event timer timing out.  Read more in sections
	<span class="bold_code bc-17"><a href="#Time-Outs">Time-Outs</a></span> and
	<span class="bold_code bc-17"><a href="#Event%20Time-Outs">Event Time-Outs</a></span>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-event_type">
	  <span class="code">internal</span>
	</a></span>
      </strong></dt>
      <dd>
	Generated by <strong>transition action</strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-action"><span class="code">{next_event,internal,EventContent}</span></a></span>.
	All <strong>event types</strong> above can also be generated using
	the <span class="code">next_event</span> action:
	<span class="code">{next_event,EventType,EventContent}</span>.
      </dd>
    </dl>
  



  <a name="State%20Enter%20Calls"></a><h3 id="state-enter-calls" class="title-link" onMouseOver="document.getElementById('ghlink-state-enter-calls-idm821').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-state-enter-calls-idm821').style.visibility = 'hidden';">
<div class="title-name">3.8 
        State Enter Calls</div>
<div class="title-anchors"><span id="ghlink-state-enter-calls-idm821" class="ghlink-after"><a href="#state-enter-calls" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L854" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      The <span class="code">gen_statem</span> behaviour can if this is enabled,
      regardless of <strong>callback mode</strong>,
      automatically
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-state_enter">
	call the state callback
      </a></span>
      with special arguments whenever the state changes
      so you can write state enter actions
      near the rest of the <strong>state transition</strong> rules.
      It typically looks like this:
    </p>
    <div class="example"><pre>
StateName(enter, OldState, Data) -&gt;
    ... code for state enter actions here ...
    {keep_state, NewData};
StateName(EventType, EventContent, Data) -&gt;
    ... code for actions here ...
    {next_state, NewStateName, NewData}.</pre></div>
    <p>
      Since the <strong>state enter call</strong> is not an event there are restrictions
      on the allowed return value and
      <span class="bold_code bc-17"><a href="#Transition%20Actions">State Transition Actions</a></span>.
      You may not change the state,
      <span class="bold_code bc-17"><a href="#Postponing%20Events">postpone</a></span>
      this non-event,
      <span class="bold_code bc-17"><a href="#Inserted%20Events">insert any events</a></span>,
      or change the
      <span class="bold_code bc-17"><a href="#Callback%20Module"><strong>callback module</strong></a></span>.
    </p>
    <p>
      The first state that is entered
      will get a <strong>state enter call</strong>
      with <span class="code">OldState</span> equal to the current state.
    </p>
    <p>
      You may repeat the <strong>state enter call</strong>
      using the <span class="code">{repeat_state,...}</span>
      return value from the
      <span class="bold_code bc-17"><a href="#State%20Callback">state callback</a></span>.
      In this case <span class="code">OldState</span> will also be equal to the current state.
    </p>
    <p>
      Depending on how your state machine is specified,
      this can be a very useful feature, but it forces you to handle
      the <strong>state enter calls</strong> in all states.
      See also the
      <span class="bold_code bc-17"><a href="#State%20Enter%20Actions">
	State Enter Actions
      </a></span>
      section.
    </p>
  



  <a name="Time-Outs"></a><h3 id="time-outs" class="title-link" onMouseOver="document.getElementById('ghlink-time-outs-idm848').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-time-outs-idm848').style.visibility = 'hidden';">
<div class="title-name">3.9 
        Time-Outs</div>
<div class="title-anchors"><span id="ghlink-time-outs-idm848" class="ghlink-after"><a href="#time-outs" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L913" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      Time-outs in <span class="code">gen_statem</span> are started from a
      <span class="bold_code bc-17"><a href="#Transition%20Actions">
	<strong>transition action</strong>
      </a></span>
      during a state transition that is when exiting from the
      <span class="bold_code bc-17"><a href="#State%20Callback"><strong>state callback</strong></a></span>.
    </p>
    <p>
      There are 3 types of time-outs in <span class="code">gen_statem</span>:
    </p>
    <dl>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-state_timeout">
	  <span class="code">state_timeout</span>
	</a></span>
      </strong></dt>
      <dd>
	There is one
	<span class="bold_code bc-17"><a href="#State%20Time-Outs">State Time-Out</a></span>
	that is automatically cancelled by a <strong>state change</strong>.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-generic_timeout">
	  <span class="code">{timeout, Name}</span>
	</a></span>
      </strong></dt>
      <dd>
	There are any number of
	<span class="bold_code bc-17"><a href="#Generic%20Time-Outs">Generic Time-Outs</a></span>
	differing by their <span class="code">Name</span>.
	They have no automatic cancelling.
      </dd>
      <dt><strong>
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-event_timeout">
	  <span class="code">timeout</span>
	</a></span>
      </strong></dt>
      <dd>
	There is one
	<span class="bold_code bc-17"><a href="#Event%20Time-Outs">Event Time-Out</a></span>
	that is automatically cancelled by any event.
	Note that
	<span class="bold_code bc-17"><a href="#Postponing%20Events">postponed </a></span>
	and
	<span class="bold_code bc-17"><a href="#Inserted%20Events">inserted</a></span>
	events cancel this time-out just as external events.
      </dd>
    </dl>
    <p>
      When a time-out is started any running time-out of the same type;
      <span class="code">state_timeout</span>, <span class="code">{timeout, Name}</span> or <span class="code">timeout</span>,
      is cancelled, that is, the time-out is restarted with the new time.
    </p>
    <p>
      All time-outs has got an <span class="code">EventContent</span> that is part of the
      <span class="bold_code bc-17"><a href="#Transition%20Actions">
	<strong>transition action</strong>
      </a></span>
      that starts the time-out.
      Different <span class="code">EventContent</span>s does not create different time-outs.
      The <span class="code">EventContent</span> is delivered to the
      <span class="bold_code bc-17"><a href="#State%20Callback"><strong>state callback</strong></a></span>
      when the time-out expires.
    </p>
    <a name="Cancelling%20a%20Time-Out"></a><h4 id="cancelling-a-time-out" class="title-link" onMouseOver="document.getElementById('ghlink-cancelling-a-time-out-idm891').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-cancelling-a-time-out-idm891').style.visibility = 'hidden';">
<div class="title-name">Cancelling a Time-Out</div>
<div class="title-anchors"><span id="ghlink-cancelling-a-time-out-idm891" class="ghlink-after"><a href="#cancelling-a-time-out" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L981" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h4>
      
      
      <p>
	If a time-out is started with the time <span class="code">infinity</span> it will
	never time out, in fact it will not even be started, and any
	running time-out with the same tag will be cancelled.
	The <span class="code">EventContent</span> will in this case be ignored,
	so why not set it to <span class="code">undefined</span>.
      </p>
      <p>
	A more explicit way to cancel a timer is to use a
	<span class="bold_code bc-17"><a href="#Transition%20Actions">
	  <strong>transition action</strong>
	</a></span>
	on the form
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-timeout_cancel_action">
	  <span class="code">{TimeoutType, cancel}</span>
	</a></span>
	which is a feature introduced in OTP 22.1.
      </p>
    
    <a name="Updating%20a%20Time-Out"></a><h4 id="updating-a-time-out" class="title-link" onMouseOver="document.getElementById('ghlink-updating-a-time-out-idm903').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-updating-a-time-out-idm903').style.visibility = 'hidden';">
<div class="title-name">Updating a Time-Out</div>
<div class="title-anchors"><span id="ghlink-updating-a-time-out-idm903" class="ghlink-after"><a href="#updating-a-time-out" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1003" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h4>
      
      
      <p>
	While a time-out is running, its <span class="code">EventContent</span>
	can be updated using a
	<span class="bold_code bc-17"><a href="#Transition%20Actions">
	  <strong>transition action</strong>
	</a></span>
	on the form
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#type-timeout_update_action">
	  <span class="code">{TimeoutType, update, NewEventContent}</span>
	</a></span>
	which is a feature introduced in OTP 22.1.
      </p>
      <p>
	If this feature is used while no such <span class="code">TimeoutType</span>
	is running then a time-out event is immediately delivered
	as when starting a
	<span class="bold_code bc-17"><a href="#Time-Out%20Zero">Time-Out Zero</a></span>.
      </p>
    
    <a name="Time-Out%20Zero"></a><h4 id="time-out-zero" class="title-link" onMouseOver="document.getElementById('ghlink-time-out-zero-idm915').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-time-out-zero-idm915').style.visibility = 'hidden';">
<div class="title-name">Time-Out Zero</div>
<div class="title-anchors"><span id="ghlink-time-out-zero-idm915" class="ghlink-after"><a href="#time-out-zero" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1025" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h4>
      
      
      <p>
	If a time-out is started with the time <span class="code">0</span> it will
	actually not be started.  Instead the time-out event will
	immediately be inserted to be processed after any events
	already enqueued, and before any not yet received external events.
	Note that some time-outs are automatically cancelled
	so if you for example combine
	<span class="bold_code bc-17"><a href="#Postponing%20Events">postponing</a></span>
	an event in a <strong>state change</strong> with starting an
	<span class="bold_code bc-17"><a href="#Event%20Time-Outs">event time-out</a></span>
	with time <span class="code">0</span> there will be no time-out event inserted
	since the event time-out is cancelled by the postponed
	event that is delivered due to the state change.
      </p>
    
  




  <a name="Example"></a><h3 id="example" class="title-link" onMouseOver="document.getElementById('ghlink-example-idm924').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-example-idm924').style.visibility = 'hidden';">
<div class="title-name">3.10 
        Example</div>
<div class="title-anchors"><span id="ghlink-example-idm924" class="ghlink-after"><a href="#example" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1048" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      A door with a code lock can be seen as a state machine.
      Initially, the door is locked. When someone presses a button,
      an event is generated.
      The pressed buttons are collected, up to the number of buttons
      in the correct code.
      If correct, the door is unlocked for 10 seconds.
      If not correct, we wait for a new button to be pressed.
    </p>
    
    <div class="doc-image-wrapper">
<object alt="IMAGE MISSING" data="../design_principles/code_lock.svg" class="doc-svg doc-image"></object>
      <p class="doc-image-caption">Figure
        3.1:
         
        Code Lock State Diagram</p>
    </div>
    <p>
      This code lock state machine can be implemented using
      <span class="code">gen_statem</span> with the following <strong>callback module</strong>:
    </p>
    <div class="example example-erl"><pre>-module(code_lock).
-behaviour(gen_statem).
-define(NAME, code_lock).

-export([start_link/1]).
-export([button/1]).
-export([init/1,callback_mode/0,terminate/3]).
-export([locked/3,open/3]).

start_link(Code) -&gt;
    gen_statem:start_link({local,?NAME}, ?MODULE, Code, []).

button(Button) -&gt;
    gen_statem:cast(?NAME, {button,Button}).

init(Code) -&gt;
    do_lock(),
    Data = #{code =&gt; Code, length =&gt; length(Code), buttons =&gt; []},
    {ok, locked, Data}.

callback_mode() -&gt;
    state_functions.</pre></div>
    <div class="example example-erl"><pre>locked(
  cast, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
    NewButtons =
        if
            length(Buttons) &lt; Length -&gt;
                Buttons;
            true -&gt;
                tl(Buttons)
        end ++ [Button],
    if
        NewButtons =:= Code -&gt; % Correct
	    do_unlock(),
            {next_state, open, Data#{buttons := []},
             [{state_timeout,10000,lock}]}; % Time in milliseconds
	true -&gt; % Incomplete | Incorrect
            {next_state, locked, Data#{buttons := NewButtons}}
    end.</pre></div>
    <div class="example example-erl"><pre>open(state_timeout, lock,  Data) -&gt;
    do_lock(),
    {next_state, locked, Data};
open(cast, {button,_}, Data) -&gt;
    {next_state, open, Data}.</pre></div>
    <div class="example example-erl"><pre>do_lock() -&gt;
    io:format("Lock~n", []).
do_unlock() -&gt;
    io:format("Unlock~n", []).

terminate(_Reason, State, _Data) -&gt;
    State =/= locked andalso do_lock(),
    ok.</pre></div>
    <p>The code is explained in the next sections.</p>
  



  <a name="Starting%20gen_statem"></a><h3 id="starting-gen_statem" class="title-link" onMouseOver="document.getElementById('ghlink-starting-gen_statem-idm938').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-starting-gen_statem-idm938').style.visibility = 'hidden';">
<div class="title-name">3.11 
        Starting gen_statem</div>
<div class="title-anchors"><span id="ghlink-starting-gen_statem-idm938" class="ghlink-after"><a href="#starting-gen_statem" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1135" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      In the example in the previous section, <span class="code">gen_statem</span> is
      started by calling <span class="code">code_lock:start_link(Code)</span>:
    </p>
    <div class="example example-erl"><pre>start_link(Code) -&gt;
    gen_statem:start_link({local,?NAME}, ?MODULE, Code, []).</pre></div>
    <p>
      <span class="code">start_link</span> calls function
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#start_link-4"><span class="code">gen_statem:start_link/4</span></a></span>,
      which spawns and links to a new process, a <span class="code">gen_statem</span>.
    </p>
    <ul>
      <li>
        <p>
          The first argument, <span class="code">{local,?NAME}</span>, specifies
          the name. In this case, the <span class="code">gen_statem</span> is locally
          registered as <span class="code">code_lock</span> through the macro <span class="code">?NAME</span>.
        </p>
        <p>
          If the name is omitted, the <span class="code">gen_statem</span> is not registered.
          Instead its pid must be used. The name can also be specified
          as <span class="code">{global,Name}</span>, then the <span class="code">gen_statem</span> is
          registered using
          <span class="bold_code bc-13"><a href="../man/global.html#register_name-2"><span class="code">global:register_name/2</span></a></span>
          in Kernel.
        </p>
      </li>
      <li>
        <p>
          The second argument, <span class="code">?MODULE</span>, is the name of
          the <strong>callback module</strong>, that is,
	  the module where the callback
          functions are located, which is this module.
        </p>
        <p>
          The interface functions (<span class="code">start_link/1</span> and <span class="code">button/1</span>)
          are located in the same module as the callback functions
          (<span class="code">init/1</span>, <span class="code">locked/3</span>, and <span class="code">open/3</span>).
          It is normally good programming practice to have the client-side
          code and the server-side code contained in one module.
        </p>
      </li>
      <li>
        <p>
          The third argument, <span class="code">Code</span>, is a list of digits, which
          is the correct unlock code that is passed
          to callback function <span class="code">init/1</span>.
	</p>
      </li>
      <li>
        <p>
          The fourth argument, <span class="code">[]</span>, is a list of options.
          For the available options, see
          <span class="bold_code bc-13"><a href="../man/gen_statem.html#start_link-3"><span class="code">gen_statem:start_link/3</span></a></span>.
	</p>
      </li>
    </ul>
    <p>
      If name registration succeeds, the new <span class="code">gen_statem</span> process
      calls callback function <span class="code">code_lock:init(Code)</span>.
      This function is expected to return <span class="code">{ok, State, Data}</span>,
      where <span class="code">State</span> is the initial state of the <span class="code">gen_statem</span>,
      in this case <span class="code">locked</span>; assuming that the door is locked to begin
      with. <span class="code">Data</span> is the internal server data of the <span class="code">gen_statem</span>.
      Here the server data is a <span class="bold_code bc-18"><a href="../man/maps.html">map</a></span>
      with key <span class="code">code</span> that stores the correct button sequence,
      key <span class="code">length</span> store its length,
      and key <span class="code">buttons</span> that stores the collected buttons
      up to the same length.
    </p>

    <div class="example example-erl"><pre>init(Code) -&gt;
    do_lock(),
    Data = #{code =&gt; Code, length =&gt; length(Code), buttons =&gt; []},
    {ok, locked, Data}.</pre></div>
    <p>Function
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#start_link-3"><span class="code">gen_statem:start_link</span></a></span>
      is synchronous. It does not return until the <span class="code">gen_statem</span>
      is initialized and is ready to receive events.
    </p>
    <p>
      Function
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#start_link-3"><span class="code">gen_statem:start_link</span></a></span>
      must be used if the <span class="code">gen_statem</span>
      is part of a supervision tree, that is, started by a supervisor.
      Another function,
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#start-3"><span class="code">gen_statem:start</span></a></span>
      can be used to start a standalone <span class="code">gen_statem</span>, that is,
      a <span class="code">gen_statem</span> that is not part of a supervision tree.
    </p>

    <p>
      Function
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#Module:callback_mode-0"><span class="code">Module:callback_mode/0</span></a></span>
      selects the
      <span class="bold_code bc-17"><a href="#Callback%20Modes"><span class="code">CallbackMode</span></a></span>
      for the <strong>callback module</strong>, in this case
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-callback_mode"><span class="code">state_functions</span></a></span>.
      That is, each state has got its own handler function:
    </p>
    <div class="example example-erl"><pre>callback_mode() -&gt;
    state_functions.</pre></div>

  



  <a name="Handling%20Events"></a><h3 id="handling-events" class="title-link" onMouseOver="document.getElementById('ghlink-handling-events-idm1017').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-handling-events-idm1017').style.visibility = 'hidden';">
<div class="title-name">3.12 
        Handling Events</div>
<div class="title-anchors"><span id="ghlink-handling-events-idm1017" class="ghlink-after"><a href="#handling-events" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1251" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>The function notifying the code lock about a button event is
      implemented using
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#cast-2"><span class="code">gen_statem:cast/2</span></a></span>:
    </p>
    <div class="example example-erl"><pre>button(Button) -&gt;
    gen_statem:cast(?NAME, {button,Button}).</pre></div>
    <p>
      The first argument is the name of the <span class="code">gen_statem</span> and must
      agree with the name used to start it. So, we use the
      same macro <span class="code">?NAME</span> as when starting.
      <span class="code">{button,Button}</span> is the event content.
    </p>
    <p>
      The event is sent to the <span class="code">gen_statem</span>.
      When the event is received, the <span class="code">gen_statem</span> calls
      <span class="code">StateName(cast, Event, Data)</span>, which is expected to
      return a tuple <span class="code">{next_state, NewStateName, NewData}</span>,
      or <span class="code">{next_state, NewStateName, NewData, Actions}</span>.
      <span class="code">StateName</span> is the name of the current state and
      <span class="code">NewStateName</span> is the name of the next state to go to.
      <span class="code">NewData</span> is a new value for the server data of
      the <span class="code">gen_statem</span>, and <span class="code">Actions</span> is a list of
      actions to be performed by the <span class="code">gen_statem</span> engine.
    </p>

    <div class="example example-erl"><pre>locked(
  cast, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
    NewButtons =
        if
            length(Buttons) &lt; Length -&gt;
                Buttons;
            true -&gt;
                tl(Buttons)
        end ++ [Button],
    if
        NewButtons =:= Code -&gt; % Correct
	    do_unlock(),
            {next_state, open, Data#{buttons := []},
             [{state_timeout,10000,lock}]}; % Time in milliseconds
	true -&gt; % Incomplete | Incorrect
            {next_state, locked, Data#{buttons := NewButtons}}
    end.</pre></div>
    <p>
      In state <span class="code">locked</span>, when a button is pressed,
      it is collected with the last pressed buttons
      up to the length of the correct code,
      and compared with the correct code.
      Depending on the result, the door is either unlocked
      and the <span class="code">gen_statem</span> goes to state <span class="code">open</span>,
      or the door remains in state <span class="code">locked</span>.
    </p>
    <p>
      When changing to state <span class="code">open</span>, the collected
      buttons are reset, the lock unlocked, and a state timer
      for 10 s is started.
    </p>

    <div class="example example-erl"><pre>open(cast, {button,_}, Data) -&gt;
    {next_state, open, Data}.</pre></div>
    <p>
      In state <span class="code">open</span>, a button event is ignored
      by staying in the same state.  This can also be done
      by returning <span class="code">{keep_state, Data}</span> or in this case
      since <span class="code">Data</span> unchanged even by returning
      <span class="code">keep_state_and_data</span>.
    </p>
  

  <a name="State%20Time-Outs"></a><h3 id="state-time-outs" class="title-link" onMouseOver="document.getElementById('ghlink-state-time-outs-idm1054').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-state-time-outs-idm1054').style.visibility = 'hidden';">
<div class="title-name">3.13 
        State Time-Outs</div>
<div class="title-anchors"><span id="ghlink-state-time-outs-idm1054" class="ghlink-after"><a href="#state-time-outs" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1329" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      When a correct code has been given, the door is unlocked and
      the following tuple is returned from <span class="code">locked/2</span>:
    </p>
    <div class="example example-erl"><pre>{next_state, open, Data#{buttons := []},
 [{state_timeout,10000,lock}]}; % Time in milliseconds</pre></div>
    <p>
      10,000 is a time-out value in milliseconds.
      After this time (10 seconds), a time-out occurs.
      Then, <span class="code">StateName(state_timeout, lock, Data)</span> is called.
      The time-out occurs when the door has been in state <span class="code">open</span>
      for 10 seconds. After that the door is locked again:
    </p>
    <div class="example example-erl"><pre>open(state_timeout, lock,  Data) -&gt;
    do_lock(),
    {next_state, locked, Data};</pre></div>
    <p>
      The timer for a state time-out is automatically cancelled
      when the state machine does a <strong>state change</strong>.
    </p>
    <p>
      You can restart, cancel or update a state time-out.
      See section
      <span class="bold_code bc-17"><a href="#Time-Outs">Time-Outs</a></span>
      for details.
    </p>
  



  <a name="All%20State%20Events"></a><h3 id="all-state-events" class="title-link" onMouseOver="document.getElementById('ghlink-all-state-events-idm1068').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-all-state-events-idm1068').style.visibility = 'hidden';">
<div class="title-name">3.14 
        All State Events</div>
<div class="title-anchors"><span id="ghlink-all-state-events-idm1068" class="ghlink-after"><a href="#all-state-events" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1366" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      Sometimes events can arrive in any state of the <span class="code">gen_statem</span>.
      It is convenient to handle these in a common state handler function
      that all state functions call for events not specific to the state.
    </p>
    <p>
      Consider a <span class="code">code_length/0</span> function that returns
      the length of the correct code.
      We dispatch all events that are not state-specific
      to the common function <span class="code">handle_common/3</span>:
    </p>
    <div class="example example-erl"><pre>...
-export([button/1,code_length/0]).
...

code_length() -&gt;
    gen_statem:call(?NAME, code_length).

...
locked(...) -&gt; ... ;
locked(EventType, EventContent, Data) -&gt;
    handle_common(EventType, EventContent, Data).

...
open(...) -&gt; ... ;
open(EventType, EventContent, Data) -&gt;
    handle_common(EventType, EventContent, Data).

handle_common({call,From}, code_length, #{code := Code} = Data) -&gt;
    {keep_state, Data,
     [{reply,From,length(Code)}]}.</pre></div>

    <p>
      Another way to do it is through a convenience macro
      <span class="code">?HANDLE_COMMON/0</span>:
    </p>
    <div class="example example-erl"><pre>...
-export([button/1,code_length/0]).
...

code_length() -&gt;
    gen_statem:call(?NAME, code_length).

-define(HANDLE_COMMON,
    ?FUNCTION_NAME(T, C, D) -&gt; handle_common(T, C, D)).
%%
handle_common({call,From}, code_length, #{code := Code} = Data) -&gt;
    {keep_state, Data,
     [{reply,From,length(Code)}]}.

...
locked(...) -&gt; ... ;
?HANDLE_COMMON.

...
open(...) -&gt; ... ;
?HANDLE_COMMON.</pre></div>

    <p>
      This example uses
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#call-2"><span class="code">gen_statem:call/2</span></a></span>,
      which waits for a reply from the server.
      The reply is sent with a <span class="code">{reply,From,Reply}</span> tuple
      in an action list in the <span class="code">{keep_state, ...}</span> tuple
      that retains the current state.  This return form is convenient
      when you want to stay in the current state but do not know or
      care about what it is.
    </p>
    <p>
      If the common <strong>state callback</strong> needs to know the current state
      a function <span class="code">handle_common/4</span> can be used instead:
    </p>
    <div class="example example-erl"><pre>-define(HANDLE_COMMON,
    ?FUNCTION_NAME(T, C, D) -&gt; handle_common(T, C, ?FUNCTION_NAME, D)).</pre></div>
  



  <a name="One%20State%20Callback"></a><h3 id="one-state-callback" class="title-link" onMouseOver="document.getElementById('ghlink-one-state-callback-idm1089').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-one-state-callback-idm1089').style.visibility = 'hidden';">
<div class="title-name">3.15 
        One State Callback</div>
<div class="title-anchors"><span id="ghlink-one-state-callback-idm1089" class="ghlink-after"><a href="#one-state-callback" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1453" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      If
      <span class="bold_code bc-17"><a href="#Callback%20Modes">
	<strong>callback mode</strong>
      </a></span>
      <span class="code">handle_event_function</span> is used,
      all events are handled in
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#Module:handle_event-4"><span class="code">Module:handle_event/4</span></a></span>
      and we can (but do not have to) use an event-centered approach
      where we first branch depending on event
      and then depending on state:
    </p>
    <div class="example example-erl"><pre>...
-export([handle_event/4]).

...
callback_mode() -&gt;
    handle_event_function.

handle_event(cast, {button,Button}, State, #{code := Code} = Data) -&gt;
    case State of
	locked -&gt;
            #{length := Length, buttons := Buttons} = Data,
            NewButtons =
                if
                    length(Buttons) &lt; Length -&gt;
                        Buttons;
                    true -&gt;
                        tl(Buttons)
                end ++ [Button],
            if
                NewButtons =:= Code -&gt; % Correct
                    do_unlock(),
                    {next_state, open, Data#{buttons := []},
                     [{state_timeout,10000,lock}]}; % Time in milliseconds
                true -&gt; % Incomplete | Incorrect
                    {keep_state, Data#{buttons := NewButtons}}
            end;
	open -&gt;
            keep_state_and_data
    end;
handle_event(state_timeout, lock, open, Data) -&gt;
    do_lock(),
    {next_state, locked, Data};
handle_event(
  {call,From}, code_length, _State, #{code := Code} = Data) -&gt;
    {keep_state, Data,
     [{reply,From,length(Code)}]}.

...</pre></div>
  



  <a name="Stopping"></a><h3 id="stopping" class="title-link" onMouseOver="document.getElementById('ghlink-stopping-idm1099').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-stopping-idm1099').style.visibility = 'hidden';">
<div class="title-name">3.16 
        Stopping</div>
<div class="title-anchors"><span id="ghlink-stopping-idm1099" class="ghlink-after"><a href="#stopping" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1512" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    

    <a name="In%20a%20Supervision%20Tree"></a><h4 id="in-a-supervision-tree" class="title-link" onMouseOver="document.getElementById('ghlink-in-a-supervision-tree-idm1102').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-in-a-supervision-tree-idm1102').style.visibility = 'hidden';">
<div class="title-name">In a Supervision Tree</div>
<div class="title-anchors"><span id="ghlink-in-a-supervision-tree-idm1102" class="ghlink-after"><a href="#in-a-supervision-tree" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1516" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h4>
      
      
      <p>
	If the <span class="code">gen_statem</span> is part of a supervision tree,
	no stop function is needed.
	The <span class="code">gen_statem</span> is automatically terminated by its supervisor.
	Exactly how this is done is defined by a
	<span class="bold_code bc-15"><a href="sup_princ.html#shutdown">shutdown strategy</a></span>
	set in the supervisor.
      </p>
      <p>
	If it is necessary to clean up before termination, the shutdown
	strategy must be a time-out value and the <span class="code">gen_statem</span> must
	in function <span class="code">init/1</span> set itself to trap exit signals
	by calling
	<span class="bold_code bc-13"><a href="../man/erlang.html#process_flag-2"><span class="code">process_flag(trap_exit, true)</span></a></span>:
      </p>
      <div class="example example-erl"><pre>init(Args) -&gt;
    process_flag(trap_exit, true),
    do_lock(),
    ...</pre></div>
      <p>
	When ordered to shut down, the <span class="code">gen_statem</span> then calls
	callback function <span class="code">terminate(shutdown, State, Data)</span>.
      </p>
      <p>
	In this example, function <span class="code">terminate/3</span>
	locks the door if it is open, so we do not accidentally leave the door
	open when the supervision tree terminates:
      </p>
      <div class="example example-erl"><pre>terminate(_Reason, State, _Data) -&gt;
    State =/= locked andalso do_lock(),
    ok.</pre></div>
    

    <a name="Standalone%20gen_statem"></a><h4 id="standalone-gen_statem" class="title-link" onMouseOver="document.getElementById('ghlink-standalone-gen_statem-idm1121').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-standalone-gen_statem-idm1121').style.visibility = 'hidden';">
<div class="title-name">Standalone gen_statem</div>
<div class="title-anchors"><span id="ghlink-standalone-gen_statem-idm1121" class="ghlink-after"><a href="#standalone-gen_statem" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1556" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h4>
      
      
      <p>
	If the <span class="code">gen_statem</span> is not part of a supervision tree,
	it can be stopped using
	<span class="bold_code bc-13"><a href="../man/gen_statem.html#stop-1"><span class="code">gen_statem:stop</span></a></span>,
	preferably through an API function:
      </p>
      <div class="example example-erl"><pre>...
-export([start_link/1,stop/0]).

...
stop() -&gt;
    gen_statem:stop(?NAME).</pre></div>
      <p>
	This makes the <span class="code">gen_statem</span> call callback function
	<span class="code">terminate/3</span> just like for a supervised server
	and waits for the process to terminate.
      </p>
    
  



  <a name="Event%20Time-Outs"></a><h3 id="event-time-outs" class="title-link" onMouseOver="document.getElementById('ghlink-event-time-outs-idm1132').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-event-time-outs-idm1132').style.visibility = 'hidden';">
<div class="title-name">3.17 
        Event Time-Outs</div>
<div class="title-anchors"><span id="ghlink-event-time-outs-idm1132" class="ghlink-after"><a href="#event-time-outs" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1583" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      A time-out feature inherited from <span class="code">gen_statem</span>'s predecessor
      <span class="bold_code bc-18"><a href="../man/gen_fsm.html"><span class="code">gen_fsm</span></a></span>,
      is an event time-out, that is,
      if an event arrives the timer is cancelled.
      You get either an event or a time-out, but not both.
    </p>
    <p>
      It is ordered by the
      <span class="bold_code bc-17"><a href="#Transition%20Actions">
	<strong>transition action</strong>
      </a></span>
      <span class="code">{timeout,Time,EventContent}</span>, or just an integer <span class="code">Time</span>,
      even without the enclosing actions list
      (the latter is a form inherited from <span class="code">gen_fsm</span>.
    </p>
    <p>
      This type of time-out is useful for example to act on inactivity.
      Let us restart the code sequence
      if no button is pressed for say 30 seconds:
    </p>
    <div class="example example-erl"><pre>...

locked(timeout, _, Data) -&gt;
    {next_state, locked, Data#{buttons := []}};
locked(
  cast, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
...
	true -&gt; % Incomplete | Incorrect
            {next_state, locked, Data#{buttons := NewButtons},
             30000} % Time in milliseconds
...</pre></div>
    <p>
      Whenever we receive a button event we start an event time-out
      of 30 seconds, and if we get an <strong>event type</strong> of <span class="code">timeout</span>
      we reset the remaining code sequence.
    </p>
    <p>
      An event time-out is cancelled by any other event so you either
      get some other event or the time-out event.  It is therefore
      not possible nor needed to cancel, restart or update an event time-out.
      Whatever event you act on has already cancelled the event time-out,
      so there is never a running event time-out
      while the <strong>state callback</strong> executes.
    </p>
    <p>
      Note that an event time-out does not work well
      when you have for example a status call as in section
      <span class="bold_code bc-17"><a href="#All%20State%20Events">All State Events</a></span>,
      or handle unknown events, since all kinds of events
      will cancel the event time-out.
    </p>
  



  <a name="Generic%20Time-Outs"></a><h3 id="generic-time-outs" class="title-link" onMouseOver="document.getElementById('ghlink-generic-time-outs-idm1154').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-generic-time-outs-idm1154').style.visibility = 'hidden';">
<div class="title-name">3.18 
        Generic Time-Outs</div>
<div class="title-anchors"><span id="ghlink-generic-time-outs-idm1154" class="ghlink-after"><a href="#generic-time-outs" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1645" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      The previous example of state time-outs only work if
      the state machine stays in the same state during the
      time-out time.  And event time-outs only work if no
      disturbing unrelated events occur.
    </p>
    <p>
      You may want to start a timer in one state and respond
      to the time-out in another, maybe cancel the time-out
      without changing states, or perhaps run multiple
      time-outs in parallel. All this can be accomplished with
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-generic_timeout">generic time-outs</a></span>.
      They may look a little bit like
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-event_timeout">event time-outs</a></span>
      but contain a name to allow for any number of them simultaneously
      and they are not automatically cancelled.
    </p>
    <p>
      Here is how to accomplish the state time-out
      in the previous example by instead using a generic time-out
      named for example <span class="code">open</span>:
    </p>
    <div class="example example-erl"><pre>...
locked(
  cast, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
...
    if
        NewButtons =:= Code -&gt; % Correct
	    do_unlock(),
            {next_state, open, Data#{buttons := []},
             [{{timeout,open},10000,lock}]}; % Time in milliseconds
...

open({timeout,open}, lock, Data) -&gt;
    do_lock(),
    {next_state,locked,Data};
open(cast, {button,_}, Data) -&gt;
    {keep_state,Data};
...</pre></div>
    <p>
      Specific generic time-outs can just as
      <span class="bold_code bc-17"><a href="#State%20Time-Outs">state time-outs</a></span>
      be restarted or cancelled
      by setting it to a new time or <span class="code">infinity</span>.
    </p>
    <p>
      In this particular case we do not need to cancel the time-out
      since the time-out event is the only possible reason to
      do a <strong>state change</strong> from <span class="code">open</span> to <span class="code">locked</span>.
    </p>
    <p>
      Instead of bothering with when to cancel a time-out,
      a late time-out event can be handled by ignoring it
      if it arrives in a state where it is known to be late.
    </p>
    <p>
      You can restart, cancel or update a generic time-out.
      See section
      <span class="bold_code bc-17"><a href="#Time-Outs">Time-Outs</a></span>
      for details.
    </p>
  



  <a name="Erlang%20Timers"></a><h3 id="erlang-timers" class="title-link" onMouseOver="document.getElementById('ghlink-erlang-timers-idm1174').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-erlang-timers-idm1174').style.visibility = 'hidden';">
<div class="title-name">3.19 
        Erlang Timers</div>
<div class="title-anchors"><span id="ghlink-erlang-timers-idm1174" class="ghlink-after"><a href="#erlang-timers" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1716" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      The most versatile way to handle time-outs is to use
      Erlang Timers; see
      <span class="bold_code bc-13"><a href="../man/erlang.html#start_timer-4"><span class="code">erlang:start_timer/3,4</span></a></span>.
      Most time-out tasks can be performed with the
      time-out features in <span class="code">gen_statem</span>,
      but an example of one that cannot is if you should need
      the return value from
      <span class="bold_code bc-13"><a href="../man/erlang.html#cancel_timer-2"><span class="code">erlang:cancel_timer(Tref)</span></a></span>, that is; the remaining time of the timer.
    </p>
    <p>
      Here is how to accomplish the state time-out
      in the previous example by instead using an Erlang Timer:
    </p>
    <div class="example example-erl"><pre>...
locked(
  cast, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
...
    if
        NewButtons =:= Code -&gt; % Correct
	    do_unlock(),
	    Tref =
                 erlang:start_timer(
                     10000, self(), lock), % Time in milliseconds
            {next_state, open, Data#{buttons := [], timer =&gt; Tref}};
...

open(info, {timeout,Tref,lock}, #{timer := Tref} = Data) -&gt;
    do_lock(),
    {next_state,locked,maps:remove(timer, Data)};
open(cast, {button,_}, Data) -&gt;
    {keep_state,Data};
...</pre></div>
    <p>
      Removing the <span class="code">timer</span> key from the map when we
      do a <strong>state change</strong> to <span class="code">locked</span> is not strictly
      necessary since we can only get into state <span class="code">open</span>
      with an updated <span class="code">timer</span> map value.  But it can be nice
      to not have outdated values in the state <span class="code">Data</span>!
    </p>
    <p>
      If you need to cancel a timer because of some other event, you can use
      <span class="bold_code bc-13"><a href="../man/erlang.html#cancel_timer-2"><span class="code">erlang:cancel_timer(Tref)</span></a></span>.
      Note that no time-out message will arrive after this (because the timer has been explicitly canceled),
      unless you have already postponed one earlier (see the next section),
      so ensure that you do not accidentally postpone such messages.
      Also note that a time-out message may arrive during a <strong>state callback</strong>
      that is cancelling the timer, so you may have to read out
      such a message from the process mailbox, depending on
      the return value from
      <span class="bold_code bc-13"><a href="../man/erlang.html#cancel_timer-2"><span class="code">erlang:cancel_timer(Tref)</span></a></span>.
    </p>
    <p>
      Another way to handle a late time-out can be to not cancel it,
      but to ignore it if it arrives in a state
      where it is known to be late.
    </p>
  



  <a name="Postponing%20Events"></a><h3 id="postponing-events" class="title-link" onMouseOver="document.getElementById('ghlink-postponing-events-idm1199').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-postponing-events-idm1199').style.visibility = 'hidden';">
<div class="title-name">3.20 
        Postponing Events</div>
<div class="title-anchors"><span id="ghlink-postponing-events-idm1199" class="ghlink-after"><a href="#postponing-events" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1783" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      If you want to ignore a particular event in the current state
      and handle it in a future state, you can postpone the event.
      A postponed event is retried after a <strong>state change</strong>,
      that is, <span class="code">OldState =/= NewState</span>.
    </p>
    <p>
      Postponing is ordered by the
      <span class="bold_code bc-17"><a href="#Transition%20Actions">
	<strong>transition action</strong>
      </a></span>
      <span class="code">postpone</span>.
    </p>
    <p>
      In this example, instead of ignoring button events
      while in the <span class="code">open</span> state, we can postpone them
      and they are queued and later handled in the <span class="code">locked</span> state:
    </p>
    <div class="example example-erl"><pre>...
open(cast, {button,_}, Data) -&gt;
    {keep_state,Data,[postpone]};
...</pre></div>
    <p>
      Since a postponed event is only retried
      after a <strong>state change</strong>,
      you have to think about where to keep a state data item.
      You can keep it in the server <span class="code">Data</span>
      or in the <span class="code">State</span> itself,
      for example by having two more or less identical states
      to keep a boolean value, or by using a complex state
      (see section
      <span class="bold_code bc-17"><a href="#Complex%20State">Complex State</a></span>)
      with
      <span class="bold_code bc-17"><a href="#Callback%20Modes"><strong>callback mode</strong></a></span>
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-callback_mode"><span class="code">handle_event_function</span></a></span>.
      If a change in the value changes the set of events that is handled,
      then the value should be kept in the State.
      Otherwise no postponed events will be retried
      since only the server Data changes.
    </p>
    <p>
      This is not important if you do not postpone events.
      But if you later decide to start postponing some events,
      then the design flaw of not having separate states
      when they should be, might become a hard-to-find bug.
    </p>

    <a name="Fuzzy%20State%20Diagrams"></a><h4 id="fuzzy-state-diagrams" class="title-link" onMouseOver="document.getElementById('ghlink-fuzzy-state-diagrams-idm1223').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-fuzzy-state-diagrams-idm1223').style.visibility = 'hidden';">
<div class="title-name">Fuzzy State Diagrams</div>
<div class="title-anchors"><span id="ghlink-fuzzy-state-diagrams-idm1223" class="ghlink-after"><a href="#fuzzy-state-diagrams" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1835" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h4>
      
      
      <p>
	It is not uncommon that a state diagram does not specify
	how to handle events that are not illustrated
	in a particular state in the diagram.
	Hopefully this is described in an associated text
	or from the context.
      </p>
      <p>
	Possible actions: ignore as in drop the event
	(maybe log it) or deal with the event in some other state
	as in postpone it.
      </p>
    

    <a name="Selective%20Receive"></a><h4 id="selective-receive" class="title-link" onMouseOver="document.getElementById('ghlink-selective-receive-idm1228').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-selective-receive-idm1228').style.visibility = 'hidden';">
<div class="title-name">Selective Receive</div>
<div class="title-anchors"><span id="ghlink-selective-receive-idm1228" class="ghlink-after"><a href="#selective-receive" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1852" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h4>
      
      
      <p>
        Erlang's selective receive statement is often used to
        describe simple state machine examples in straightforward
        Erlang code. The following is a possible implementation of
        the first example:
      </p>
    <div class="example example-erl"><pre>-module(code_lock).
-define(NAME, code_lock_1).
-export([start_link/1,button/1]).

start_link(Code) -&gt;
    spawn(
      fun () -&gt;
	      true = register(?NAME, self()),
	      do_lock(),
	      locked(Code, length(Code), [])
      end).

button(Button) -&gt;
    ?NAME ! {button,Button}.</pre></div>
    <div class="example example-erl"><pre>locked(Code, Length, Buttons) -&gt;
    receive
        {button,Button} -&gt;
            NewButtons =
                if
                    length(Buttons) &lt; Length -&gt;
                        Buttons;
                    true -&gt;
                        tl(Buttons)
                end ++ [Button],
            if
                NewButtons =:= Code -&gt; % Correct
                    do_unlock(),
		    open(Code, Length);
                true -&gt; % Incomplete | Incorrect
                    locked(Code, Length, NewButtons)
            end
    end.</pre></div>
    <div class="example example-erl"><pre>open(Code, Length) -&gt;
    receive
    after 10000 -&gt; % Time in milliseconds
	    do_lock(),
	    locked(Code, Length, [])
    end.

do_lock() -&gt;
    io:format("Locked~n", []).
do_unlock() -&gt;
    io:format("Open~n", []).</pre></div>
    <p>
      The selective receive in this case causes <span class="code">open</span>
      to implicitly postpone any events to the <span class="code">locked</span> state.
    </p>
    <p>
      A selective receive cannot be used from a <span class="code">gen_statem</span>
      behaviour (or from any <span class="code">gen_*</span> behaviour),
      as the receive statement is within the <span class="code">gen_*</span> engine itself.
      It must be there because all
      <span class="bold_code bc-18"><a href="../man/sys.html"><span class="code">sys</span></a></span>
      compatible behaviours must respond to system messages and therefore
      do that in their engine receive loop,
      passing non-system messages to the <strong>callback module</strong>.
    </p>
    <p>
      The
      <span class="bold_code bc-17"><a href="#Transition%20Actions">
	<strong>transition action</strong>
      </a></span>
      <span class="code">postpone</span> is designed to model
      selective receives. A selective receive implicitly postpones
      any not received events, but the <span class="code">postpone</span>
      <strong>transition action</strong> explicitly postpones one received event.
    </p>
    <p>
      Both mechanisms have the same theoretical
      time and memory complexity, while the selective receive
      language construct has smaller constant factors.
    </p>
    
  



  <a name="State%20Enter%20Actions"></a><h3 id="state-enter-actions" class="title-link" onMouseOver="document.getElementById('ghlink-state-enter-actions-idm1252').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-state-enter-actions-idm1252').style.visibility = 'hidden';">
<div class="title-name">3.21 
        State Enter Actions</div>
<div class="title-anchors"><span id="ghlink-state-enter-actions-idm1252" class="ghlink-after"><a href="#state-enter-actions" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L1944" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      Say you have a state machine specification
      that uses state enter actions.
      Allthough you can code this using inserted events
      (described in the next section), especially if just
      one or a few states has got state enter actions,
      this is a perfect use case for the built in
      <span class="bold_code bc-17"><a href="#State%20Enter%20Calls"><strong>state enter calls</strong></a></span>.
    </p>
    <p>
      You return a list containing <span class="code">state_enter</span> from your
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#Module:callback_mode-0">
	<span class="code">callback_mode/0</span>
      </a></span>
      function and the <span class="code">gen_statem</span> engine will call your
      <strong>state callback</strong> once with an event
      <span class="code">(enter, OldState, ...)</span>
      whenever it does a <strong>state change</strong>.
      Then you just need to handle these event-like calls in all states.
    </p>
    <div class="example example-erl"><pre>...
init(Code) -&gt;
    process_flag(trap_exit, true),
    Data = #{code =&gt; Code, length = length(Code)},
    {ok, locked, Data}.

callback_mode() -&gt;
    [state_functions,state_enter].

locked(enter, _OldState, Data) -&gt;
    do_lock(),
    {keep_state,Data#{buttons =&gt; []}};
locked(
  cast, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
...
    if
        NewButtons =:= Code -&gt; % Correct
            {next_state, open, Data};
...

open(enter, _OldState, _Data) -&gt;
    do_unlock(),
    {keep_state_and_data,
     [{state_timeout,10000,lock}]}; % Time in milliseconds
open(state_timeout, lock, Data) -&gt;
    {next_state, locked, Data};
...</pre></div>
    <p>
      You can repeat the state enter code by returning one of
      <span class="code">{repeat_state, ...}</span>, <span class="code">{repeat_state_and_data,_}</span>
      or <span class="code">repeat_state_and_data</span> that otherwise behaves
      exactly like their <span class="code">keep_state</span> siblings.
      See the type
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-state_callback_result">
	<span class="code">state_callback_result()</span>
      </a></span>
      in the reference manual.
    </p>
  



  <a name="Inserted%20Events"></a><h3 id="inserted-events" class="title-link" onMouseOver="document.getElementById('ghlink-inserted-events-idm1274').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-inserted-events-idm1274').style.visibility = 'hidden';">
<div class="title-name">3.22 
        Inserted Events</div>
<div class="title-anchors"><span id="ghlink-inserted-events-idm1274" class="ghlink-after"><a href="#inserted-events" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L2012" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      It can sometimes be beneficial to be able to generate events
      to your own state machine.
      This can be done with the
      <span class="bold_code bc-17"><a href="#Transition%20Actions">
	<strong>transition action</strong>
      </a></span>
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-action"><span class="code">{next_event,EventType,EventContent}</span></a></span>.
    </p>
    <p>
      You can generate events of any existing
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-action">type</a></span>,
      but the <span class="code">internal</span> type can only be generated through action
      <span class="code">next_event</span>. Hence, it cannot come from an external source,
      so you can be certain that an <span class="code">internal</span> event is an event
      from your state machine to itself.
    </p>
    <p>
      One example for this is to pre-process incoming data, for example
      decrypting chunks or collecting characters up to a line break.
    </p>
    <p>
      Purists may argue that this should be modelled with a separate
      state machine that sends pre-processed events
      to the main state machine,
      but to decrease overhead the small pre-processing state machine
      can be implemented in the common state event handling
      of the main state machine using a few state data variables
      that then sends the pre-processed events as internal events
      to the main state machine.
      Using internal events also can make it easier
      to synchronize the state machines.
    </p>
    <p>
      A variant of this is to use a
      <span class="bold_code bc-17"><a href="#Complex%20State">complex state</a></span>
      with
      <span class="bold_code bc-17"><a href="#One%20State%20Callback"><strong>one state callback</strong></a></span>.
      The state is then modeled with for example a tuple
      <span class="code">{MainFSMState,SubFSMState}</span>.
    </p>
    <p>
      To illustrate this we make up an example where the buttons
      instead generate down and up (press and release) events,
      and the lock responds to an up event only after
      the corresponding down event.
    </p>
    <div class="example example-erl"><pre>...
-export([down/1, up/1]).
...
down(Button) -&gt;
    gen_statem:cast(?NAME, {down,Button}).

up(Button) -&gt;
    gen_statem:cast(?NAME, {up,Button}).

...

locked(enter, _OldState, Data) -&gt;
    do_lock(),
    {keep_state,Data#{buttons =&gt; []}};
locked(
  internal, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
...</pre></div>
    <div class="example example-erl"><pre>handle_common(cast, {down,Button}, Data) -&gt;
    {keep_state, Data#{button =&gt; Button}};
handle_common(cast, {up,Button}, Data) -&gt;
    case Data of
        #{button := Button} -&gt;
            {keep_state,maps:remove(button, Data),
             [{next_event,internal,{button,Button}}]};
        #{} -&gt;
            keep_state_and_data
    end;
...

open(internal, {button,_}, Data) -&gt;
    {keep_state,Data,[postpone]};
...</pre></div>
    <p>
      If you start this program with <span class="code">code_lock:start([17])</span>
      you can unlock with <span class="code">code_lock:down(17), code_lock:up(17).</span>
    </p>
  



  <a name="Example%20Revisited"></a><h3 id="example-revisited" class="title-link" onMouseOver="document.getElementById('ghlink-example-revisited-idm1300').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-example-revisited-idm1300').style.visibility = 'hidden';">
<div class="title-name">3.23 
        Example Revisited</div>
<div class="title-anchors"><span id="ghlink-example-revisited-idm1300" class="ghlink-after"><a href="#example-revisited" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L2107" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      This section includes the example after most of the mentioned
      modifications and some more using <strong>state enter calls</strong>,
      which deserves a new state diagram:
    </p>
    
    <div class="doc-image-wrapper">
<object alt="IMAGE MISSING" data="../design_principles/code_lock_2.svg" class="doc-svg doc-image"></object>
      <p class="doc-image-caption">Figure
        3.2:
         
        Code Lock State Diagram Revisited</p>
    </div>
    <p>
      Notice that this state diagram does not specify how to handle
      a button event in the state <span class="code">open</span>. So, you need to
      read in some side notes, that is, here: that unspecified events
      shall be postponed (handled in some later state).
      Also, the state diagram does not show that the <span class="code">code_length/0</span>
      call must be handled in every state.
    </p>

    <a name="Callback%20Mode:%20state_functions"></a><h4 id="callback-mode--state_functions" class="title-link" onMouseOver="document.getElementById('ghlink-callback-mode--state_functions-idm1310').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-callback-mode--state_functions-idm1310').style.visibility = 'hidden';">
<div class="title-name">Callback Mode: state_functions</div>
<div class="title-anchors"><span id="ghlink-callback-mode--state_functions-idm1310" class="ghlink-after"><a href="#callback-mode--state_functions" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L2129" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h4>
      
      
      <p>
	Using state functions:
      </p>
      <div class="example example-erl"><pre>-module(code_lock).
-behaviour(gen_statem).
-define(NAME, code_lock_2).

-export([start_link/1,stop/0]).
-export([down/1,up/1,code_length/0]).
-export([init/1,callback_mode/0,terminate/3]).
-export([locked/3,open/3]).

start_link(Code) -&gt;
    gen_statem:start_link({local,?NAME}, ?MODULE, Code, []).
stop() -&gt;
    gen_statem:stop(?NAME).

down(Button) -&gt;
    gen_statem:cast(?NAME, {down,Button}).
up(Button) -&gt;
    gen_statem:cast(?NAME, {up,Button}).
code_length() -&gt;
    gen_statem:call(?NAME, code_length).</pre></div>
      <div class="example example-erl"><pre>init(Code) -&gt;
    process_flag(trap_exit, true),
    Data = #{code =&gt; Code, length =&gt; length(Code), buttons =&gt; []},
    {ok, locked, Data}.

callback_mode() -&gt;
    [state_functions,state_enter].

-define(HANDLE_COMMON,
    ?FUNCTION_NAME(T, C, D) -&gt; handle_common(T, C, D)).
%%
handle_common(cast, {down,Button}, Data) -&gt;
    {keep_state, Data#{button =&gt; Button}};
handle_common(cast, {up,Button}, Data) -&gt;
    case Data of
        #{button := Button} -&gt;
            {keep_state, maps:remove(button, Data),
             [{next_event,internal,{button,Button}}]};
        #{} -&gt;
            keep_state_and_data
    end;
handle_common({call,From}, code_length, #{code := Code}) -&gt;
    {keep_state_and_data,
     [{reply,From,length(Code)}]}.</pre></div>
    <div class="example example-erl"><pre>locked(enter, _OldState, Data) -&gt;
    do_lock(),
    {keep_state, Data#{buttons := []}};
locked(state_timeout, button, Data) -&gt;
    {keep_state, Data#{buttons := []}};
locked(
  internal, {button,Button},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
    NewButtons =
        if
            length(Buttons) &lt; Length -&gt;
                Buttons;
            true -&gt;
                tl(Buttons)
        end ++ [Button],
    if
        NewButtons =:= Code -&gt; % Correct
            {next_state, open, Data};
	true -&gt; % Incomplete | Incorrect
            {keep_state, Data#{buttons := NewButtons},
             [{state_timeout,30000,button}]} % Time in milliseconds
    end;
?HANDLE_COMMON.</pre></div>
    <div class="example example-erl"><pre>open(enter, _OldState, _Data) -&gt;
    do_unlock(),
    {keep_state_and_data,
     [{state_timeout,10000,lock}]}; % Time in milliseconds
open(state_timeout, lock, Data) -&gt;
    {next_state, locked, Data};
open(internal, {button,_}, _) -&gt;
    {keep_state_and_data, [postpone]};
?HANDLE_COMMON.

do_lock() -&gt;
    io:format("Locked~n", []).
do_unlock() -&gt;
    io:format("Open~n", []).

terminate(_Reason, State, _Data) -&gt;
    State =/= locked andalso do_lock(),
    ok.</pre></div>
    

    <a name="Callback%20Mode:%20handle_event_function"></a><h4 id="callback-mode--handle_event_function" class="title-link" onMouseOver="document.getElementById('ghlink-callback-mode--handle_event_function-idm1318').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-callback-mode--handle_event_function-idm1318').style.visibility = 'hidden';">
<div class="title-name">Callback Mode: handle_event_function</div>
<div class="title-anchors"><span id="ghlink-callback-mode--handle_event_function-idm1318" class="ghlink-after"><a href="#callback-mode--handle_event_function" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L2230" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h4>
      
      
      <p>
        This section describes what to change in the example
        to use one <span class="code">handle_event/4</span> function.
        The previously used approach to first branch depending on event
	does not work that well here
	because of the <strong>state enter calls</strong>,
        so this example first branches depending on state:
      </p>
      <div class="example example-erl"><pre>-export([handle_event/4]).</pre></div>
      <div class="example example-erl"><pre>callback_mode() -&gt;
    [handle_event_function,state_enter].</pre></div>
      <div class="example example-erl"><pre>%%
%% State: locked
handle_event(enter, _OldState, locked, Data) -&gt;
    do_lock(),
    {keep_state, Data#{buttons := []}};
handle_event(state_timeout, button, locked, Data) -&gt;
    {keep_state, Data#{buttons := []}};
handle_event(
  internal, {button,Button}, locked,
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
    NewButtons =
        if
            length(Buttons) &lt; Length -&gt;
                Buttons;
            true -&gt;
                tl(Buttons)
        end ++ [Button],
    if
        NewButtons =:= Code -&gt; % Correct
            {next_state, open, Data};
	true -&gt; % Incomplete | Incorrect
            {keep_state, Data#{buttons := NewButtons},
             [{state_timeout,30000,button}]} % Time in milliseconds
    end;</pre></div>
      <div class="example example-erl"><pre>%%
%% State: open
handle_event(enter, _OldState, open, _Data) -&gt;
    do_unlock(),
    {keep_state_and_data,
     [{state_timeout,10000,lock}]}; % Time in milliseconds
handle_event(state_timeout, lock, open, Data) -&gt;
    {next_state, locked, Data};
handle_event(internal, {button,_}, open, _) -&gt;
    {keep_state_and_data,[postpone]};</pre></div>
      <div class="example example-erl"><pre>%% Common events
handle_event(cast, {down,Button}, _State, Data) -&gt;
    {keep_state, Data#{button =&gt; Button}};
handle_event(cast, {up,Button}, _State, Data) -&gt;
    case Data of
        #{button := Button} -&gt;
            {keep_state, maps:remove(button, Data),
             [{next_event,internal,{button,Button}},
              {state_timeout,30000,button}]}; % Time in milliseconds
        #{} -&gt;
            keep_state_and_data
    end;
handle_event({call,From}, code_length, _State, #{length := Length}) -&gt;
    {keep_state_and_data,
     [{reply,From,Length}]}.</pre></div>
    
    <p>
      Notice that postponing buttons from the <span class="code">open</span> state
      to the <span class="code">locked</span> state feels like a strange thing to do
      for a code lock, but it at least illustrates event postponing.
    </p>
  



  <a name="Filter%20the%20State"></a><h3 id="filter-the-state" class="title-link" onMouseOver="document.getElementById('ghlink-filter-the-state-idm1332').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-filter-the-state-idm1332').style.visibility = 'hidden';">
<div class="title-name">3.24 
        Filter the State</div>
<div class="title-anchors"><span id="ghlink-filter-the-state-idm1332" class="ghlink-after"><a href="#filter-the-state" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L2313" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      The example servers so far in this chapter
      print the full internal state in the error log, for example,
      when killed by an exit signal or because of an internal error.
      This state contains both the code lock code
      and which digits that remain to unlock.
    </p>
    <p>
      This state data can be regarded as sensitive,
      and maybe not what you want in the error log
      because of some unpredictable event.
    </p>
    <p>
      Another reason to filter the state can be
      that the state is too large to print, as it fills
      the error log with uninteresting details.
    </p>
    <p>
      To avoid this, you can format the internal state
      that gets in the error log and gets returned from
      <span class="bold_code bc-13"><a href="../man/sys.html#get_status-1"><span class="code">sys:get_status/1,2</span></a></span>
      by implementing function
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#Module:format_status-2"><span class="code">Module:format_status/2</span></a></span>,
      for example like this:
    </p>
    <div class="example example-erl"><pre>...
-export([init/1,terminate/3,format_status/2]).
...

format_status(Opt, [_PDict,State,Data]) -&gt;
    StateData =
	{State,
	 maps:filter(
	   fun (code, _) -&gt; false;
	       (_, _) -&gt; true
	   end,
	   Data)},
    case Opt of
	terminate -&gt;
	    StateData;
	normal -&gt;
	    [{data,[{"State",StateData}]}]
    end.</pre></div>
    <p>
      It is not mandatory to implement a
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#Module:format_status-2"><span class="code">Module:format_status/2</span></a></span>
      function. If you do not, a default implementation is used that
      does the same as this example function without filtering
      the <span class="code">Data</span> term, that is, <span class="code">StateData = {State,Data}</span>,
      in this example containing sensitive information.
    </p>
  



  <a name="Complex%20State"></a><h3 id="complex-state" class="title-link" onMouseOver="document.getElementById('ghlink-complex-state-idm1349').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-complex-state-idm1349').style.visibility = 'hidden';">
<div class="title-name">3.25 
        Complex State</div>
<div class="title-anchors"><span id="ghlink-complex-state-idm1349" class="ghlink-after"><a href="#complex-state" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L2373" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      The <strong>callback mode</strong>
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-callback_mode"><span class="code">handle_event_function</span></a></span>
      enables using a non-atom state as described in section
      <span class="bold_code bc-17"><a href="#Callback%20Modes">Callback Modes</a></span>,
      for example, a complex state term like a tuple.
    </p>
    <p>
      One reason to use this is when you have a state item
      that when changed should cancel the
      <span class="bold_code bc-17"><a href="#State%20Time-Outs">state time-out</a></span>,
      or one that affects the event handling
      in combination with postponing events.
      We will go for the latter and complicate the previous example
      by introducing a configurable lock button
      (this is the state item in question),
      which in the <span class="code">open</span> state immediately locks the door,
      and an API function <span class="code">set_lock_button/1</span> to set the lock button.
    </p>
    <p>
      Suppose now that we call <span class="code">set_lock_button</span>
      while the door is open,
      and we have already postponed a button event
      that was the new lock button:
    </p>
    <div class="example example-erl"><pre>1&gt; code_lock:start_link([a,b,c], x).
{ok,&lt;0.666.0&gt;}
2&gt; code_lock:button(a).
ok
3&gt; code_lock:button(b).
ok
4&gt; code_lock:button(c).
ok
Open
5&gt; code_lock:button(y).
ok
6&gt; code_lock:set_lock_button(y).
x
% What should happen here?  Immediate lock or nothing?</pre></div>
    <p>
      We could say that the button was pressed too early
      so it is not to be recognized as the lock button.
      Or we can make the lock button part of the state so
      when we then change the lock button in the locked state,
      the change becomes a <strong>state change</strong>
      and all postponed events are retried,
      therefore the lock is immediately locked!
    </p>
    <p>
      We define the state as <span class="code">{StateName,LockButton}</span>,
      where <span class="code">StateName</span> is as before
      and <span class="code">LockButton</span> is the current lock button:
    </p>
    <div class="example example-erl"><pre>-module(code_lock).
-behaviour(gen_statem).
-define(NAME, code_lock_3).

-export([start_link/2,stop/0]).
-export([button/1,set_lock_button/1]).
-export([init/1,callback_mode/0,terminate/3]).
-export([handle_event/4]).

start_link(Code, LockButton) -&gt;
    gen_statem:start_link(
        {local,?NAME}, ?MODULE, {Code,LockButton}, []).
stop() -&gt;
    gen_statem:stop(?NAME).

button(Button) -&gt;
    gen_statem:cast(?NAME, {button,Button}).
set_lock_button(LockButton) -&gt;
    gen_statem:call(?NAME, {set_lock_button,LockButton}).</pre></div>
    <div class="example example-erl"><pre>init({Code,LockButton}) -&gt;
    process_flag(trap_exit, true),
    Data = #{code =&gt; Code, length =&gt; length(Code), buttons =&gt; []},
    {ok, {locked,LockButton}, Data}.

callback_mode() -&gt;
    [handle_event_function,state_enter].

%% State: locked
handle_event(enter, _OldState, {locked,_}, Data) -&gt;
    do_lock(),
    {keep_state, Data#{buttons := []}};
handle_event(state_timeout, button, {locked,_}, Data) -&gt;
    {keep_state, Data#{buttons := []}};
handle_event(
  cast, {button,Button}, {locked,LockButton},
  #{code := Code, length := Length, buttons := Buttons} = Data) -&gt;
    NewButtons =
        if
            length(Buttons) &lt; Length -&gt;
                Buttons;
            true -&gt;
                tl(Buttons)
        end ++ [Button],
    if
        NewButtons =:= Code -&gt; % Correct
            {next_state, {open,LockButton}, Data};
	true -&gt; % Incomplete | Incorrect
            {keep_state, Data#{buttons := NewButtons},
             [{state_timeout,30000,button}]} % Time in milliseconds
    end;</pre></div>
    <div class="example example-erl"><pre>%%
%% State: open
handle_event(enter, _OldState, {open,_}, _Data) -&gt;
    do_unlock(),
    {keep_state_and_data,
     [{state_timeout,10000,lock}]}; % Time in milliseconds
handle_event(state_timeout, lock, {open,LockButton}, Data) -&gt;
    {next_state, {locked,LockButton}, Data};
handle_event(cast, {button,LockButton}, {open,LockButton}, Data) -&gt;
    {next_state, {locked,LockButton}, Data};
handle_event(cast, {button,_}, {open,_}, _Data) -&gt;
    {keep_state_and_data,[postpone]};</pre></div>
    <div class="example example-erl"><pre>%%
%% Common events
handle_event(
  {call,From}, {set_lock_button,NewLockButton},
  {StateName,OldLockButton}, Data) -&gt;
    {next_state, {StateName,NewLockButton}, Data,
     [{reply,From,OldLockButton}]}.</pre></div>
    <div class="example example-erl"><pre>do_lock() -&gt;
    io:format("Locked~n", []).
do_unlock() -&gt;
    io:format("Open~n", []).

terminate(_Reason, State, _Data) -&gt;
    State =/= locked andalso do_lock(),
    ok.</pre></div>
  



  <a name="Hibernation"></a><h3 id="hibernation" class="title-link" onMouseOver="document.getElementById('ghlink-hibernation-idm1375').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-hibernation-idm1375').style.visibility = 'hidden';">
<div class="title-name">3.26 
        Hibernation</div>
<div class="title-anchors"><span id="ghlink-hibernation-idm1375" class="ghlink-after"><a href="#hibernation" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/system/doc/design_principles/statem.xml#L2522" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
    
    
    <p>
      If you have many servers in one node
      and they have some state(s) in their lifetime in which
      the servers can be expected to idle for a while,
      and the amount of heap memory all these servers need
      is a problem, then the memory footprint of a server
      can be mimimized by hibernating it through
      <span class="bold_code bc-13"><a href="../man/proc_lib.html#hibernate-3"><span class="code">proc_lib:hibernate/3</span></a></span>.
    </p>
    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>
        It is rather costly to hibernate a process; see
        <span class="bold_code bc-13"><a href="../man/erlang.html#hibernate-3"><span class="code">erlang:hibernate/3</span></a></span>.
        It is not something you want to do after every event.
      </p>
    </p></div>
</div>
    <p>
      We can in this example hibernate in the <span class="code">{open,_}</span> state,
      because what normally occurs in that state is that
      the state time-out after a while
      triggers a transition to <span class="code">{locked,_}</span>:
    </p>
    <div class="example example-erl"><pre>...
%%
%% State: open
handle_event(enter, _OldState, {open,_}, _Data) -&gt;
    do_unlock(),
    {keep_state_and_data,
     [{state_timeout,10000,lock}, % Time in milliseconds
      hibernate]};
...</pre></div>
    <p>
      The atom
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-hibernate"><span class="code">hibernate</span></a></span>
      in the action list on the last line
      when entering the <span class="code">{open,_}</span> state is the only change.
      If any event arrives in the <span class="code">{open,_},</span> state, we
      do not bother to rehibernate, so the server stays
      awake after any event.
    </p>
    <p>
      To change that we would need to insert
      action <span class="code">hibernate</span> in more places.
      For example, the state-independent <span class="code">set_lock_button</span>
      operation would have to use <span class="code">hibernate</span> but only in the
      <span class="code">{open,_}</span> state, which would clutter the code.
    </p>
    <p>
      Another not uncommon scenario is to use the
      <span class="bold_code bc-17"><a href="#Event%20Time-Outs">event time-out</a></span>
      to trigger hibernation after a certain time of inactivity.
      There is also a server start option
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#type-enter_loop_opt">
	<span class="code">{hibernate_after, Timeout}</span>
      </a></span>
      for
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#start-3"><span class="code">start/3,4</span></a></span>,
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#start_link-3">
	<span class="code">start_link/3,4</span>
      </a></span>
      or
      <span class="bold_code bc-13"><a href="../man/gen_statem.html#enter_loop-4">
	<span class="code">enter_loop/4,5,6</span>
      </a></span>
      that may be used to automatically hibernate the server.
    </p>
    <p>
      This particular server probably does not use
      heap memory worth hibernating for.
      To gain anything from hibernation, your server would
      have to produce non-insignificant garbage
      during callback execution,
      for which this example server can serve as a bad example.
    </p>
  

</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2021 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../js/';</script><script type="text/javascript" src="../js/highlight.js"></script>
<script src="/assets/js/doc-search.bundle.js"></script>
</body>
</html>
