<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Non-blocking trace setting</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<div class="erlang-logo-wrapper"><a href="../../index.html"><img alt="Erlang Logo" src="../../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Erlang Run-Time System Application (ERTS)</p>
<p class="section-subtitle">Internal Documentation</p>
<p class="section-version">Version 10.7.2.19</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="index.html">Reference Manual</a></li>
<li><a href="internal_docs.html">Internal Documentation</a></li>
<li><a href="release_notes.html">Release Notes</a></li>
<li><a href="erts.pdf">PDF</a></li>
<li><a href="../../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Carrier Migration" expanded="false">Carrier Migration<ul>
<li><a href="CarrierMigration.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="CarrierMigration.html#introduction">Introduction</a></li>
<li title="Problem"><a href="CarrierMigration.html#problem">Problem</a></li>
<li title="Solution"><a href="CarrierMigration.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Thread Progress" expanded="false">Thread Progress<ul>
<li><a href="ThreadProgress.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="ThreadProgress.html#problems">Problems</a></li>
<li title="Functionality Used to Address These Problems"><a href="ThreadProgress.html#functionality-used-to-address-these-problems">Functionality Used to Address These Problems</a></li>
<li title="Implementation of the Thread Progress Functionality"><a href="ThreadProgress.html#implementation-of-the-thread-progress-functionality">Implementation of the Thread Progress Functionality</a></li>
</ul>
</li>
<li id="no" title="Non-Blocking Code Loading" expanded="false">Non-Blocking Code Loading<ul>
<li><a href="CodeLoading.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="CodeLoading.html#introduction">Introduction</a></li>
<li title="The Load Phases"><a href="CodeLoading.html#the-load-phases">The Load Phases</a></li>
<li title="The Finishing Sequence"><a href="CodeLoading.html#the-finishing-sequence">The Finishing Sequence</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Non-blocking trace setting" expanded="true">Non-blocking trace setting<ul>
<li><a href="Tracing.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="Tracing.html#introduction">Introduction</a></li>
<li title="Redesign of Breakpoint Wheel"><a href="Tracing.html#redesign-of-breakpoint-wheel">Redesign of Breakpoint Wheel</a></li>
<li title="Same Same but Different"><a href="Tracing.html#same-same-but-different">Same Same but Different</a></li>
<li title="Adding a new Breakpoint"><a href="Tracing.html#adding-a-new-breakpoint">Adding a new Breakpoint</a></li>
<li title="To Updating and Remove Breakpoints"><a href="Tracing.html#to-updating-and-remove-breakpoints">To Updating and Remove Breakpoints</a></li>
<li title="Global Tracing"><a href="Tracing.html#global-tracing">Global Tracing</a></li>
<li title="Future work"><a href="Tracing.html#future-work">Future work</a></li>
</ul>
</li>
<li id="no" title="Delayed Dealloc" expanded="false">Delayed Dealloc<ul>
<li><a href="DelayedDealloc.html">
              Top of chapter
            </a></li>
<li title="Problem"><a href="DelayedDealloc.html#problem">Problem</a></li>
<li title="Functionality Used to Address This problem"><a href="DelayedDealloc.html#functionality-used-to-address-this-problem">Functionality Used to Address This problem</a></li>
</ul>
</li>
<li id="no" title="The beam_makeops script" expanded="false">The beam_makeops script<ul>
<li><a href="beam_makeops.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="beam_makeops.html#introduction">Introduction</a></li>
<li title="An example: the move instruction"><a href="beam_makeops.html#an-example--the-move-instruction">An example: the move instruction</a></li>
<li title="Short overview of instruction loading"><a href="beam_makeops.html#short-overview-of-instruction-loading">Short overview of instruction loading</a></li>
<li title="Running beam_makeops"><a href="beam_makeops.html#running-beam_makeops">Running beam_makeops</a></li>
<li title="Syntax of .tab files"><a href="beam_makeops.html#syntax-of-.tab-files">Syntax of .tab files</a></li>
</ul>
</li>
<li id="no" title="Counting Instructions" expanded="false">Counting Instructions<ul><li><a href="CountingInstructions.html">
              Top of chapter
            </a></li></ul>
</li>
<li id="no" title="Erlang Garbage Collector" expanded="false">Erlang Garbage Collector<ul>
<li><a href="GarbageCollection.html">
              Top of chapter
            </a></li>
<li title="Overview"><a href="GarbageCollection.html#overview">Overview</a></li>
<li title="Generational Garbage Collection"><a href="GarbageCollection.html#generational-garbage-collection">Generational Garbage Collection</a></li>
<li title="The young heap"><a href="GarbageCollection.html#the-young-heap">The young heap</a></li>
<li title="Sizing the heap"><a href="GarbageCollection.html#sizing-the-heap">Sizing the heap</a></li>
<li title="Literals"><a href="GarbageCollection.html#literals">Literals</a></li>
<li title="Binary heap"><a href="GarbageCollection.html#binary-heap">Binary heap</a></li>
<li title="Messages"><a href="GarbageCollection.html#messages">Messages</a></li>
<li title="References"><a href="GarbageCollection.html#references">References</a></li>
</ul>
</li>
<li id="no" title="Process and Port Tables" expanded="false">Process and Port Tables<ul>
<li><a href="PTables.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="PTables.html#problems">Problems</a></li>
<li title="Solution"><a href="PTables.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Port Signals" expanded="false">Port Signals<ul>
<li><a href="PortSignals.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="PortSignals.html#problems">Problems</a></li>
<li title="Solution"><a href="PortSignals.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Process Management Optimizations" expanded="false">Process Management Optimizations<ul>
<li><a href="ProcessManagementOptimizations.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="ProcessManagementOptimizations.html#problems">Problems</a></li>
<li title="Solution"><a href="ProcessManagementOptimizations.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Super Carrier" expanded="false">Super Carrier<ul>
<li><a href="SuperCarrier.html">
              Top of chapter
            </a></li>
<li title="Problem"><a href="SuperCarrier.html#problem">Problem</a></li>
<li title="Solution"><a href="SuperCarrier.html#solution">Solution</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>4 Non-blocking trace setting</h1>


<h3>
<a name="Introduction"></a><span onMouseOver="document.getElementById('ghlink-introduction-idm30291').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-introduction-idm30291').style.visibility = 'hidden';"><span id="ghlink-introduction-idm30291"></span><a class="title_link" name="introduction" href="#introduction">4.1 
          Introduction</a></span>
</h3>



<p>
Before OTP R16 when trace settings were changed by <span class="code">erlang:trace_pattern</span>,
all other execution in the VM were halted while the trace operation
was carried out in single threaded mode. Similar to code loading, this
can impose a severe problem for availability that grows with the
number of cores.
</p>

<p>
In OTP R16, trace breakpoints are set in the code without blocking the
VM. Erlang processes may continue executing undisturbed in parallel
during the entire operation. The same base technique is used as for
code loading. A staging area of breakpoints is prepared and then made
active with a single atomic operation.
</p>



<h3>
<a name="Redesign-of-Breakpoint-Wheel"></a><span onMouseOver="document.getElementById('ghlink-redesign-of-breakpoint-wheel-idm30297').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-redesign-of-breakpoint-wheel-idm30297').style.visibility = 'hidden';"><span id="ghlink-redesign-of-breakpoint-wheel-idm30297"></span><a class="title_link" name="redesign-of-breakpoint-wheel" href="#redesign-of-breakpoint-wheel">4.2 
          Redesign of Breakpoint Wheel</a></span>
</h3>



<p>
To make it easier to manage breakpoints without single threaded mode a
redesign of the breakpoint mechanism has been made. The old
"breakpoint wheel" data structure was a circular double-linked list of
breakpoints for each instrumented function. It was invented before the
SMP emulator. To support it in the SMP emulator, is was essentially
expanded to one breakpoint wheel per scheduler. As more breakpoint
types have been added, the implementation have become messy and hard
to understand and maintain.
</p>

<p>
In the new design the old wheel was dropped and instead replaced by
one struct (<span class="code">GenericBp</span>) to hold the data for all types of breakpoints
for each instrumented function. A bit-flag field is used to indicate
what different type of break actions that are enabled.
</p>



<h3>
<a name="Same-Same-but-Different"></a><span onMouseOver="document.getElementById('ghlink-same-same-but-different-idm30303').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-same-same-but-different-idm30303').style.visibility = 'hidden';"><span id="ghlink-same-same-but-different-idm30303"></span><a class="title_link" name="same-same-but-different" href="#same-same-but-different">4.3 
          Same Same but Different</a></span>
</h3>



<p>
Even though <span class="code">trace_pattern</span> use the same technique as the non-blocking
code loading with replicated generations of data structures and an
atomic switch, the implementations are quite separate from each
other. One initial idea was to use the existing mechanism of code
loading to do a dummy load operation that would make a copy of the
affected modules. That copy could then be instrumented with
breakpoints before making it reachable with the same atomic switch as
done for code loading. This approach seems straight forward but has a
number of shortcomings, one being the large memory footprint when many
modules are instrumented. Another problem is how execution will reach
the new instrumented code. Normally loaded code can only be reached
through external functions calls. Trace settings must be activated
instantaneously without the need of external function calls.
</p>

<p>
The chosen solution is instead for tracing to use the technique of
replication applied on the data structures for breakpoints. Two
generations of breakpoints are kept and indentified by index of 0 and
</p>
<ul><li>
The global atomic variables <span class="code">erts_active_bp_index</span> will determine
which generation of breakpoints running code will use.

</li></ul>
<h4>
<a name="Same-Same-but-Different_Atomicity-Without-Atomic-Operations"></a><span onMouseOver="document.getElementById('ghlink-atomicity-without-atomic-operations-idm30312').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-atomicity-without-atomic-operations-idm30312').style.visibility = 'hidden';"><span id="ghlink-atomicity-without-atomic-operations-idm30312"></span><a class="title_link" name="atomicity-without-atomic-operations" href="#atomicity-without-atomic-operations">Atomicity Without Atomic Operations</a></span>
</h4>



<p>
Not using the code loading generations (or any other code duplication)
means that <span class="code">trace_pattern</span> must at some point write to the active beam
code in order for running processes to reach the staged breakpoints
structures. This can be done with one single atomic write operation
per instrumented function. The beam instruction words are however read
with normal memory loads and not through the atomic API. The only
guarantee we need is that the written instruction word is seen as
atomic. Either fully written or not at all. This is true for word
aligned write operation on all hardware architectures we use.
</p>





<h3>
<a name="Adding-a-new-Breakpoint"></a><span onMouseOver="document.getElementById('ghlink-adding-a-new-breakpoint-idm30317').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-adding-a-new-breakpoint-idm30317').style.visibility = 'hidden';"><span id="ghlink-adding-a-new-breakpoint-idm30317"></span><a class="title_link" name="adding-a-new-breakpoint" href="#adding-a-new-breakpoint">4.4 
          Adding a new Breakpoint</a></span>
</h3>



<p>
This is a simplified sequence describing what <span class="code">trace_pattern</span> goes
through when adding a new breakpoint.
</p>

<ul>
<li>
<p>Seize exclusive code write permission (suspend process until we get it).
</p>

</li>
<li>
<p>Allocate breakpoint structure <span class="code">GenericBp</span> including both generations.
Set the active part as disabled with a zeroed flagfield. Save the original
instruction word in the breakpoint.
</p>

</li>
<li>
<p>Write a pointer to the breakpoint at offset -4 from the first
instruction "func_info" header.
</p>

</li>
<li>
<p>Set the staging part of the breakpoint as enabled with specified
breakpoint data.
</p>

</li>
<li>
<p>Wait for thread progress.
</p>

</li>
<li>
<p>Write a <span class="code">op_i_generic_breakpoint</span> as the first instruction for the function.
This instruction will execute the breakpoint that it finds at offset -4.
</p>

</li>
<li>
<p>Wait for thread progress.
</p>

</li>
<li>
<p>Commit the breadpoint by switching <span class="code">erts_active_bp_index</span>.
</p>

</li>
<li>
<p>Wait for thread progress.
</p>

</li>
<li>
<p>Prepare for next call to <span class="code">trace_pattern</span> by updating the new staging part
(the old active) of the breakpoint to be identic to the the new active part.
</p>

</li>
<li>
<p>Release code write permission and return from <span class="code">trace_pattern</span>.
</p>
</li>
</ul>
<p>
The code write permission "lock" seized in step 1 is the same as used
by code loading. This will ensure that only one process at a time can
stage new trace settings but it will also prevent concurrent code
loading and make sure we see a consistent view of the beam code during
the entire sequence.
</p>

<p>
Between step 6 and 8, runninng processes might execute the written
<span class="code">op_i_generic_breakpoint</span> instruction. They will get the breakpoint
structure written in step 3, read <span class="code">erts_active_bp_index</span> and execute
the corresponding part of the breakpoint. Before the switch in step 8
becomes visible they will however execute the disabled part of the
breakpoint structure and do nothing other than executing the saved
original instruction.
</p>



<h3>
<a name="To-Updating-and-Remove-Breakpoints"></a><span onMouseOver="document.getElementById('ghlink-to-updating-and-remove-breakpoints-idm30354').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-to-updating-and-remove-breakpoints-idm30354').style.visibility = 'hidden';"><span id="ghlink-to-updating-and-remove-breakpoints-idm30354"></span><a class="title_link" name="to-updating-and-remove-breakpoints" href="#to-updating-and-remove-breakpoints">4.5 
          To Updating and Remove Breakpoints</a></span>
</h3>



<p>
The above sequence did only describe adding a new breakpoint. We do
basically the same sequence to update the settings of an existing
breakpoint except step 2,3 and 6 can be skipped as it has already been
done.
</p>

<p>
To remove a breakpoint some more steps are needed. The idea is to
first stage the breakpoint as disabled, do the switch, wait for thread
progress and then remove the disabled breakpoint by restoring the
original beam instruction.
</p>

<p>
Here is a more complete sequence that contains both adding, updating
and removing breakpoints.
</p>

<ul>
<li>
<p>Seize exclusive code write permission (suspend process until we get it).
</p>

</li>
<li>
<p>Allocate new breakpoint structures with a disabled active part and
the original beam instruction. Write a pointer to the breakpoint in
"func_info" header at offset -4.
</p>

</li>
<li>
<p>Update the staging part of all affected breakpoints. Disable
breakpoints that are to be removed.
</p>

</li>
<li>
<p>Wait for thread progress.
</p>

</li>
<li>
<p>Write a <span class="code">op_i_generic_breakpoint</span> as the first instruction for all
functions with new breakpoints.
</p>

</li>
<li>
<p>Wait for thread progress.
</p>

</li>
<li>
<p>Commit all staged breadpoints by switching <span class="code">erts_active_bp_index</span>.
</p>

</li>
<li>
<p>Wait for thread progress.
</p>

</li>
<li>
<p>Restore original beam instruction for disabled breakpoints.
</p>

</li>
<li>
<p>Wait for thread progress.
</p>

</li>
<li>
<p>Prepare for next call to <span class="code">trace_pattern</span> by updating the new
staging area (the old active) for all enabled breakpoints.
</p>

</li>
<li>
<p>Deallocate disabled breakpoint structures.
</p>

</li>
<li>
<p>Release code write permission and return from <span class="code">trace_pattern</span>.
</p>
</li>
</ul>
<h4>
<a name="To-Updating-and-Remove-Breakpoints_All-that-Waiting-for-Thread-Progress"></a><span onMouseOver="document.getElementById('ghlink-all-that-waiting-for-thread-progress-idm30391').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-all-that-waiting-for-thread-progress-idm30391').style.visibility = 'hidden';"><span id="ghlink-all-that-waiting-for-thread-progress-idm30391"></span><a class="title_link" name="all-that-waiting-for-thread-progress" href="#all-that-waiting-for-thread-progress">All that Waiting for Thread Progress</a></span>
</h4>



<p>
There are four rounds of waiting for thread progress in the above
sequence. In the code loading sequence we sacrificed memory overhead
of three generations to avoid a second round of thread progress. The
latency of <span class="code">trace_pattern</span> should not be such a big problem for
however, as it is normally not called in a rapid sequence.
</p>

<p>
The waiting in step 4 is to make sure all threads will see an updated
view of the breakpoint structures once they become reachable through
the <span class="code">op_i_generic_breakpoint</span> instruction written in step 5.
</p>

<p>
The waiting in step 6 is to make the activation of the new trace
settings "as atomic as possible". Different cores might see the new
value of <span class="code">erts_active_bp_index</span> at different times as it is read
without any memory barrier. But this is the best we can do without
more expensive thread synchronization.
</p>

<p>
The waiting in step 8 is to make sure we dont't restore the original
bream instructions for disabled breakpoints until we know that no
thread is still accessing the old enabled part of a disabled
breakpoint.
</p>

<p>
The waiting in step 10 is to make sure no lingering thread is still
accessing disabled breakpoint structures to be deallocated in step
12.
</p>





<h3>
<a name="Global-Tracing"></a><span onMouseOver="document.getElementById('ghlink-global-tracing-idm30402').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-global-tracing-idm30402').style.visibility = 'hidden';"><span id="ghlink-global-tracing-idm30402"></span><a class="title_link" name="global-tracing" href="#global-tracing">4.6 
          Global Tracing</a></span>
</h3>



<p>
Call tracing with <span class="code">global</span> option only affects external function
calls. This was earlier handled by inserting a special trace
instruction in export entries without the use of breakpoints. With the
new non-blocking tracing we want to avoid special handling for global
tracing and make use of the staging and atomic switching within the
breakpoint mechanism. The solution was to create the same type of
breakpoint structure for a global call trace. The difference to local
tracing is that we insert the <span class="code">op_i_generic_breakpoint</span> instruction
(with its pointer at offset -4) in the export entry rather than in the
code.
</p>



<h3>
<a name="Future-work"></a><span onMouseOver="document.getElementById('ghlink-future-work-idm30408').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-future-work-idm30408').style.visibility = 'hidden';"><span id="ghlink-future-work-idm30408"></span><a class="title_link" name="future-work" href="#future-work">4.7 
          Future work</a></span>
</h3>



<p>
We still go to single threaded mode when new code is loaded for a
module that is traced, or when loading code when there is a default
trace pattern set. That is not impossible to fix, but that requires
much closer cooperation between tracing BIFs and the loader BIFs.
</p>


</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2024 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../../js/';</script><script type="text/javascript" src="../../js/highlight.js"></script>
</body>
</html>
