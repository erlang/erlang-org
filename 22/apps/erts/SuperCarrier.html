<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Super Carrier</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<div class="erlang-logo-wrapper"><a href="../../index.html"><img alt="Erlang Logo" src="../../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Erlang Run-Time System Application (ERTS)</p>
<p class="section-subtitle">Internal Documentation</p>
<p class="section-version">Version 10.7.2.19</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="index.html">Reference Manual</a></li>
<li><a href="internal_docs.html">Internal Documentation</a></li>
<li><a href="release_notes.html">Release Notes</a></li>
<li><a href="erts.pdf">PDF</a></li>
<li><a href="../../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Carrier Migration" expanded="false">Carrier Migration<ul>
<li><a href="CarrierMigration.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="CarrierMigration.html#introduction">Introduction</a></li>
<li title="Problem"><a href="CarrierMigration.html#problem">Problem</a></li>
<li title="Solution"><a href="CarrierMigration.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Thread Progress" expanded="false">Thread Progress<ul>
<li><a href="ThreadProgress.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="ThreadProgress.html#problems">Problems</a></li>
<li title="Functionality Used to Address These Problems"><a href="ThreadProgress.html#functionality-used-to-address-these-problems">Functionality Used to Address These Problems</a></li>
<li title="Implementation of the Thread Progress Functionality"><a href="ThreadProgress.html#implementation-of-the-thread-progress-functionality">Implementation of the Thread Progress Functionality</a></li>
</ul>
</li>
<li id="no" title="Non-Blocking Code Loading" expanded="false">Non-Blocking Code Loading<ul>
<li><a href="CodeLoading.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="CodeLoading.html#introduction">Introduction</a></li>
<li title="The Load Phases"><a href="CodeLoading.html#the-load-phases">The Load Phases</a></li>
<li title="The Finishing Sequence"><a href="CodeLoading.html#the-finishing-sequence">The Finishing Sequence</a></li>
</ul>
</li>
<li id="no" title="Non-blocking trace setting" expanded="false">Non-blocking trace setting<ul>
<li><a href="Tracing.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="Tracing.html#introduction">Introduction</a></li>
<li title="Redesign of Breakpoint Wheel"><a href="Tracing.html#redesign-of-breakpoint-wheel">Redesign of Breakpoint Wheel</a></li>
<li title="Same Same but Different"><a href="Tracing.html#same-same-but-different">Same Same but Different</a></li>
<li title="Adding a new Breakpoint"><a href="Tracing.html#adding-a-new-breakpoint">Adding a new Breakpoint</a></li>
<li title="To Updating and Remove Breakpoints"><a href="Tracing.html#to-updating-and-remove-breakpoints">To Updating and Remove Breakpoints</a></li>
<li title="Global Tracing"><a href="Tracing.html#global-tracing">Global Tracing</a></li>
<li title="Future work"><a href="Tracing.html#future-work">Future work</a></li>
</ul>
</li>
<li id="no" title="Delayed Dealloc" expanded="false">Delayed Dealloc<ul>
<li><a href="DelayedDealloc.html">
              Top of chapter
            </a></li>
<li title="Problem"><a href="DelayedDealloc.html#problem">Problem</a></li>
<li title="Functionality Used to Address This problem"><a href="DelayedDealloc.html#functionality-used-to-address-this-problem">Functionality Used to Address This problem</a></li>
</ul>
</li>
<li id="no" title="The beam_makeops script" expanded="false">The beam_makeops script<ul>
<li><a href="beam_makeops.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="beam_makeops.html#introduction">Introduction</a></li>
<li title="An example: the move instruction"><a href="beam_makeops.html#an-example--the-move-instruction">An example: the move instruction</a></li>
<li title="Short overview of instruction loading"><a href="beam_makeops.html#short-overview-of-instruction-loading">Short overview of instruction loading</a></li>
<li title="Running beam_makeops"><a href="beam_makeops.html#running-beam_makeops">Running beam_makeops</a></li>
<li title="Syntax of .tab files"><a href="beam_makeops.html#syntax-of-.tab-files">Syntax of .tab files</a></li>
</ul>
</li>
<li id="no" title="Counting Instructions" expanded="false">Counting Instructions<ul><li><a href="CountingInstructions.html">
              Top of chapter
            </a></li></ul>
</li>
<li id="no" title="Erlang Garbage Collector" expanded="false">Erlang Garbage Collector<ul>
<li><a href="GarbageCollection.html">
              Top of chapter
            </a></li>
<li title="Overview"><a href="GarbageCollection.html#overview">Overview</a></li>
<li title="Generational Garbage Collection"><a href="GarbageCollection.html#generational-garbage-collection">Generational Garbage Collection</a></li>
<li title="The young heap"><a href="GarbageCollection.html#the-young-heap">The young heap</a></li>
<li title="Sizing the heap"><a href="GarbageCollection.html#sizing-the-heap">Sizing the heap</a></li>
<li title="Literals"><a href="GarbageCollection.html#literals">Literals</a></li>
<li title="Binary heap"><a href="GarbageCollection.html#binary-heap">Binary heap</a></li>
<li title="Messages"><a href="GarbageCollection.html#messages">Messages</a></li>
<li title="References"><a href="GarbageCollection.html#references">References</a></li>
</ul>
</li>
<li id="no" title="Process and Port Tables" expanded="false">Process and Port Tables<ul>
<li><a href="PTables.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="PTables.html#problems">Problems</a></li>
<li title="Solution"><a href="PTables.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Port Signals" expanded="false">Port Signals<ul>
<li><a href="PortSignals.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="PortSignals.html#problems">Problems</a></li>
<li title="Solution"><a href="PortSignals.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Process Management Optimizations" expanded="false">Process Management Optimizations<ul>
<li><a href="ProcessManagementOptimizations.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="ProcessManagementOptimizations.html#problems">Problems</a></li>
<li title="Solution"><a href="ProcessManagementOptimizations.html#solution">Solution</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Super Carrier" expanded="true">Super Carrier<ul>
<li><a href="SuperCarrier.html">
              Top of chapter
            </a></li>
<li title="Problem"><a href="SuperCarrier.html#problem">Problem</a></li>
<li title="Solution"><a href="SuperCarrier.html#solution">Solution</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>12Â Super Carrier</h1>


<p>
A super carrier is large memory area, allocated at VM start, which can
be used during runtime to allocate normal carriers from.
</p>

<p>
The super carrier feature was introduced in OTP R16B03. It is
enabled with command line option +MMscs &lt;size in Mb&gt;
and can be configured with other options.
</p>

<h3>
<a name="Problem"></a><span onMouseOver="document.getElementById('ghlink-problem-idm32141').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-problem-idm32141').style.visibility = 'hidden';"><span id="ghlink-problem-idm32141"></span><a class="title_link" name="problem" href="#problem">12.1Â 
          Problem</a></span>
</h3>



<p>
The initial motivation for this feature was customers asking for a way
to pre-allocate physcial memory at VM start for it to use.
</p>

<p>
Other problems were different experienced limitations of the OS
implementation of mmap:
</p>

<ul>
<li>
Increasingly bad performance of mmap/munmap as the number of mmap'ed areas grow.

</li>
<li>
Fragmentation problem between mmap'ed areas.

</li>
</ul>
<p>
A third problem was management of low memory in the halfword
emulator. The implementation used a naive linear search structure to
hold free segments which would lead to poor performance when
fragmentation increased.
</p>



<h3>
<a name="Solution"></a><span onMouseOver="document.getElementById('ghlink-solution-idm32150').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-solution-idm32150').style.visibility = 'hidden';"><span id="ghlink-solution-idm32150"></span><a class="title_link" name="solution" href="#solution">12.2Â 
          Solution</a></span>
</h3>



<p>
Allocate one large continious area of address space at VM start and
then use that area to satisfy our dynamic memory need during
runtime. In other words: implement our own mmap.
</p>

<h4>
<a name="Solution_Use-cases"></a><span onMouseOver="document.getElementById('ghlink-use-cases-idm32154').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-use-cases-idm32154').style.visibility = 'hidden';"><span id="ghlink-use-cases-idm32154"></span><a class="title_link" name="use-cases" href="#use-cases">Use cases</a></span>
</h4>



<p>
If command line option +MMscrpm (Reserve Physical Memory) is set to
false, only virtual space is allocated for the super carrier from
start. The super carrier then acts as an "alternative mmap" implementation
without changing the consumption of physical memory pages. Physical
pages will be reserved on demand when an allocation is done from the super
carrier and be unreserved when the memory is released back to the
super carrier.
</p>

<p>
If +MMscrpm is set to true, which is default, the initial allocation
will reserve physical memory for the entire super carrier. This can be
used by users that want to ensure a certain <strong>minimum</strong> amount of
physical memory for the VM.
</p>

<p>
However, what reservation of physical memory actually means highly
depends on the operating system, and how it is configured. For
example, different memory overcommit settings on Linux drastically
change the behaviour.
</p>

<p>
A third feature is to have the super carrier limit the <strong>maximum</strong>
amount of memory used by the VM. If +MMsco (Super Carrier Only) is set
to true, which is default, allocations will only be done from the
super carrier. When the super carrier gets full, the VM will fail due
to out of memory.
If +MMsco is false, allocations will use mmap directly if the super
carrier is full.
</p>



<h4>
<a name="Solution_Implementation"></a><span onMouseOver="document.getElementById('ghlink-implementation-idm32163').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-implementation-idm32163').style.visibility = 'hidden';"><span id="ghlink-implementation-idm32163"></span><a class="title_link" name="implementation" href="#implementation">Implementation</a></span>
</h4>



<p>
The entire super carrier implementation is kept in erl_mmap.c. The
name suggest that it can be viewed as our own mmap implementation.
</p>

<p>
A super carrier needs to satisfy two slightly different kinds of
allocation requests; multi block carriers (MBC) and single block
carriers (SBC). They are both rather large blocks of continious
memory, but MBCs and SBCs have different demands on alignment and
size.
</p>

<p>
SBCs can have arbitrary size and do only need minimum 8-byte
alignment.
</p>

<p>
MBCs are more restricted. They can only have a number of fixed
sizes that are powers of 2. The start address need to have a very
large aligment (currently 256 kb, called "super alignment"). This is a
design choice that allows very low overhead per allocated block in the
MBC.
</p>

<p>
To reduce fragmentation within the super carrier, it is good to keep SBCs
and MBCs apart. MBCs with their uniform alignment and sizes can be
packed very efficiently together. SBCs without demand for aligment can
also be allocated quite efficiently together. But mixing them can lead
to a lot of memory wasted when we need to create large holes of
padding to the next alignment limit.
</p>

<p>
The super carrier thus contains two areas. One area for MBCs growing from
the bottom and up. And one area for SBCs growing from the top and
down. Like a process with a heap and a stack growing towards each
other.
</p>



<h4>
<a name="Solution_Data-structures"></a><span onMouseOver="document.getElementById('ghlink-data-structures-idm32172').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-data-structures-idm32172').style.visibility = 'hidden';"><span id="ghlink-data-structures-idm32172"></span><a class="title_link" name="data-structures" href="#data-structures">Data structures</a></span>
</h4>



<p>
The MBC area is called <strong>sa</strong> as in super aligned and the SBC area is
called <strong>sua</strong> as in super un-aligned.
</p>

<p>
Note that the "super" in super alignment and the "super" in super
carrier has nothing to do with each other. We could have choosen
another naming to avoid confusion, such as "meta" carrier or "giant"
aligment.
</p>

<div class="example example-none"><pre>+-------+ &lt;---- sua.top
|  sua  |
|       |
|-------| &lt;---- sua.bot
|       |
|       |
|       |
|-------| &lt;---- sa.top
|       |
|  sa   |
|       |
+-------+ &lt;---- sa.bot</pre></div>
<p>
When a carrier is deallocated a free memory segment will be created
inside the corresponding area, unless the carrier was at the very top
(in <span class="code">sa</span>) or bottom (in <span class="code">sua</span>) in which case the area will just shrink
down or up.
</p>

<p>
We need to keep track of all the free segments in order to reuse them
for new carrier allocations. One initial idea was to use the same
mechanism that is used to keep track of free blocks within MBCs
(alloc_util and the different strategies). However, that would not be
as straight forward as one can think and can also waste quite a lot of
memory as it uses prepended block headers. The granularity of the
super carrier is one memory page (usually 4kb). We want to allocate
and free entire pages and we don't want to waste an entire page just
to hold the block header of the following pages.
</p>

<p>
Instead we store the meta information about all the free segments in a
dedicated area apart from the <span class="code">sa</span> and <span class="code">sua</span> areas. Every free segment is
represented by a descriptor struct (<span class="code">ErtsFreeSegDesc</span>).
</p>

<div class="example example-none"><pre>typedef struct {
    RBTNode snode;      /* node in 'stree' */
    RBTNode anode;      /* node in 'atree' */
    char* start;
    char* end;
}ErtsFreeSegDesc;</pre></div>
<p>
To find the smallest free segment that will satisfy a carrier allocation
(best fit), the free segments are organized in a tree sorted by
size (<span class="code">stree</span>). We search in this tree at allocation. If no free segment of
sufficient size was found, the area (<span class="code">sa</span> or <span class="code">sua</span>) is instead expanded.
If two or more free segments with equal size exist, the one at lowest
address is chosen for <span class="code">sa</span> and highest address for <span class="code">sua</span>.
</p>

<p>
At carrier deallocation, we want to coalesce with any adjacent free
segments, to form one large free segment. To do that, all free
segments are also organized in a tree sorted in address order (<span class="code">atree</span>).
</p>

<p>
So, in total we keep four trees of free descriptors for the super
carrier; two for <span class="code">sa</span> and two for <span class="code">sua</span>. They all use the same
red-black-tree implementation that support the different sorting
orders used.
</p>

<p>
When allocating a new MBC we first search after a free segment in <span class="code">sa</span>,
then try to raise <span class="code">sa.top</span>, and then as a fallback try to search after a
free segment in <span class="code">sua</span>. When an MBC is allocated in <span class="code">sua</span>, a larger segment
is allocated which is then trimmed to obtain the right
alignment. Allocation search for an SBC is done in reverse order. When
an SBC is allocated in <span class="code">sa</span>, the size is aligned up to super aligned
size.
</p>



<h4>
<a name="Solution_The-free-descriptor-area"></a><span onMouseOver="document.getElementById('ghlink-the-free-descriptor-area-idm32206').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-the-free-descriptor-area-idm32206').style.visibility = 'hidden';"><span id="ghlink-the-free-descriptor-area-idm32206"></span><a class="title_link" name="the-free-descriptor-area" href="#the-free-descriptor-area">The free descriptor area</a></span>
</h4>



<p>
As mentioned above, the descriptors for the free segments are
allocated in a separate area. This area has a constant configurable
size (+MMscrfsd) that defaults to 65536 descriptors. This should be
more than enough in most cases. If the descriptors area should fill up,
new descriptor areas will be allocated first directly from the OS, and
then from <span class="code">sua</span> and <span class="code">sa</span> in the super carrier, and lastly from the memory
segment itself which is being deallocated. Allocating free descriptor
areas from the super carrier is only a last resort, and should be
avoided, as it creates fragmentation.
</p>



<h4>
<a name="Solution_Halfword-emulator"></a><span onMouseOver="document.getElementById('ghlink-halfword-emulator-idm32212').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-halfword-emulator-idm32212').style.visibility = 'hidden';"><span id="ghlink-halfword-emulator-idm32212"></span><a class="title_link" name="halfword-emulator" href="#halfword-emulator">Halfword emulator</a></span>
</h4>



<p>
The halfword emulator uses the super carrier implementation to manage
its low memory mappings thar are needed for all term storage. The
super carrier can here not be configured by command line options. One
could imagine a second configurable instance of the super carrier used
by high memory allocation, but that has not been implemented.
</p>




</div>
<div class="footer">
<hr>
<p>Copyright Â© 1997-2024 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../../js/';</script><script type="text/javascript" src="../../js/highlight.js"></script>
</body>
</html>
