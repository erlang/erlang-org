<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.38.1">
    <meta name="project" content="Erlang System Documentation v28.2">


<meta name="major-vsn" content="28">
<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=28&q=">
<link rel="canonical" href="https://www.erlang.org/doc/system/overview.html" />
    <title>Overview — Erlang System Documentation v28.2</title>

    <link rel="stylesheet" href="dist/html-erlang-ZK43ZOAC.css" />

    <script defer src="dist/sidebar_items-351B7E11.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-DPJLHKSM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="Erlang System Documentation" />
        </a>

      <div>
        <a href="../index.html" class="sidebar-projectName" translate="no">
Erlang System Documentation
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v28.2
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of Erlang System Documentation</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>Overview</h1>


      <a href="https://github.com/erlang/otp/blob/OTP-28.2/system/doc/tutorial/overview.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<h2 id="built-in-mechanisms" class="section-heading"><a href="#built-in-mechanisms" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Built-In Mechanisms</span></h2><p>Two interoperability mechanisms are built into the Erlang runtime system,
<em>distributed Erlang</em>, <em>ports</em>, and <em>nifs</em>. A variation of ports is <em>linked-in drivers</em>.</p><h3 id="distributed-erlang" class="section-heading"><a href="#distributed-erlang" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Distributed Erlang</span></h3><p>An Erlang runtime system is made a distributed Erlang node by giving it a name.
A distributed Erlang node can connect to, and monitor, other nodes. It can also
spawn processes at other nodes. Message passing and error handling between
processes at different nodes are transparent. A number of useful STDLIB modules
are available in a distributed Erlang system. For example, <a href="../apps/kernel/global.html"><code class="inline">global</code></a>, which
provides global name registration. The distribution mechanism is implemented
using TCP/IP sockets.</p><p><em>When to use:</em> Distributed Erlang is primarily used for Erlang-Erlang
communication. It can also be used for communication between Erlang and C, if
the C program is implemented as a C node, see
<a href="overview.html#c-nodes">C and Java Libraries</a>.</p><p><em>Where to read more:</em> Distributed Erlang and some distributed programming
techniques are described in the Erlang book.</p><p>For more information, see
<a href="../system/conc_prog.html#distributed-programming">Distributed Programming</a>.</p><p>Relevant manual pages are the following:</p><ul><li><a href="../apps/erts/erlang.html"><code class="inline">erlang</code></a> manual page in ERTS (describes the BIFs)</li><li><a href="../apps/kernel/global.html"><code class="inline">global</code></a> manual page in Kernel</li><li><a href="../apps/kernel/net_adm.html"><code class="inline">net_adm</code></a> manual page in Kernel</li><li><a href="../apps/kernel/pg.html"><code class="inline">pg</code></a> manual page in Kernel</li><li><a href="../apps/kernel/rpc.html"><code class="inline">rpc</code></a> manual page in Kernel</li><li><a href="../apps/stdlib/pool.html"><code class="inline">pool</code></a> manual page in STDLIB</li><li><a href="../apps/stdlib/slave.html"><code class="inline">slave</code></a> manual page in STDLIB</li></ul><h3 id="ports-and-linked-in-drivers" class="section-heading"><a href="#ports-and-linked-in-drivers" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Ports and Linked-In Drivers</span></h3><p>Ports provide the basic mechanism for communication with the external world,
from Erlang's point of view. The ports provide a byte-oriented interface to an
external program. When a port is created, Erlang can communicate with it by
sending and receiving <a href="../apps/erts/erlang.html#t:iolist/0">lists of bytes</a> or <a href="../apps/erts/erlang.html#t:binary/0">binaries</a> (not Erlang terms).
This means that the programmer might have to invent a suitable encoding and decoding scheme.</p><p>The implementation of the port mechanism depends on the platform. For UNIX,
pipes are used and the external program is assumed to read from standard input
and write to standard output. The external program can be written in any
programming language as long as it can handle the interprocess communication
mechanism with which the port is implemented.</p><p>The external program resides in another OS process than the Erlang runtime
system. In some cases this is not acceptable. Consider, for example, drivers
with very hard time requirements. It is therefore possible to write a program in
C according to certain principles, and dynamically link it to the Erlang runtime
system. This is called a <em>linked-in driver</em>.</p><p><em>When to use:</em> Ports can be used for all kinds of interoperability situations
where the Erlang program and the other program runs on the same machine.
Programming is fairly straight-forward.</p><p>Linked-in drivers involves writing certain call-back functions in C. This
requires very good skills as the code is linked to the Erlang runtime system.
It is recommended to use <a href="#native-implemented-functions-nifs">NIFs</a>
instead of linked-in drivers as they provide a richer feature set and can use
<a href="../apps/erts/erl_nif.html#dirty_nifs">dirty schedulers for lengthy work</a>.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>A faulty linked-in driver causes the entire Erlang runtime system to leak
memory, hang, or crash.</p></section><p><em>Where to read more:</em> Ports are described in section &quot;Miscellaneous Items&quot; of
the Erlang book. Linked-in drivers are described in Appendix E.</p><p>The BIF <a href="../apps/erts/erlang.html#open_port/2"><code class="inline">open_port/2</code></a> is documented in the <a href="../apps/erts/erlang.html"><code class="inline">erlang</code></a> manual
page in ERTS.</p><p>For linked-in drivers, the programmer needs to read the <a href="../apps/kernel/erl_ddll.html"><code class="inline">erl_ddll</code></a> manual page
in Kernel.</p><p><em>Examples:</em> Port example in <a href="c_port.html">Ports</a>.</p><h3 id="native-implemented-functions-nifs" class="section-heading"><a href="#native-implemented-functions-nifs" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Native implemented functions (Nifs)</span></h3><p>NIFs provide an alternative to a port using linked-in drivers to link C code into
the Erlang runtime system. NIFs make it possible to provide C implementation of
normal Erlang functions when interacting with the OS or some other external library.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>A faulty NIFs causes the entire Erlang runtime system to leak
memory, hang, crash, or leak sensitive information.</p></section><p><em>When to use:</em> Since a faulty NIF can cause many different problems related to both
stability and security it is recommended to use an external Port if possible. If the
overhead is not acceptable then a NIF is a good solution for interacting with any
native code, be it in C, C++ or Rust.</p><p><em>Where to read more:</em> NIFs are described in <a href="../apps/erts/erl_nif.html">API functions for an Erlang NIF library</a>.</p><p><em>Examples:</em> Port example in <a href="nif.html">NIFs</a>.</p><h2 id="c-and-java-libraries" class="section-heading"><a href="#c-and-java-libraries" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">C and Java Libraries</span></h2><h3 id="erl_interface" class="section-heading"><a href="#erl_interface" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Erl_Interface</span></h3><p>The program at the other side of a port is often a C program. To help the C
programmer, the Erl_Interface library has been developed</p><p>The Erlang external term format is a representation of an Erlang term as a
sequence of bytes, that is, a binary. Conversion between the two representations
is done using the following BIFs:</p><pre><code class="text">Binary = term_to_binary(Term)
Term = binary_to_term(Binary)</code></pre><p>A port can be set to use binaries instead of lists of bytes. It is then not
necessary to invent any encoding/decoding scheme. Erl_Interface functions are
used for unpacking the binary and convert it into a struct similar to an Erlang
term. Such a struct can be manipulated in different ways, be converted to the
Erlang external format, and sent to Erlang.</p><p><em>When to use:</em> In C code, in conjunction with Erlang binaries.</p><p><em>Where to read more:</em> See the Erlang Interface User's Guide, Command Reference,
and Library Reference. In Erlang/OTP R5B, and earlier versions, the information
is part of the Kernel application.</p><p><em>Examples:</em> Erl_Interface example in <a href="erl_interface.html">Erl_Interface</a>.</p><h3 id="c-nodes" class="section-heading"><a href="#c-nodes" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">C Nodes</span></h3><p>A C program that uses the Erl<em>Interface functions for setting up a connection
to, and communicating with, a distributed Erlang node is called a _C node</em>, or a
<em>hidden node</em>. The main advantage with a C node is that the communication from
the Erlang programmer's perspective is extremely easy, as the C program behaves
as a distributed Erlang node.</p><p><em>When to use:</em> C nodes can typically be used on device processors (as opposed to
control processors) where C is a better choice than Erlang due to memory
limitations or application characteristics, or both.</p><p><em>Where to read more:</em> See the <code class="inline">ei_connect</code> part of the
<a href="erl_interface.html">Erl_Interface</a> documentation. The programmer also needs to be
familiar with TCP/IP sockets, see Sockets in
<a href="overview.html#sockets">Standard Protocols</a> and Distributed Erlang in
<a href="overview.html#distributed-erlang">Built-In Mechanisms</a>.</p><p><em>Example:</em> C node example in <a href="cnode.html">C Nodes</a>.</p><h3 id="jinterface" class="section-heading"><a href="#jinterface" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Jinterface</span></h3><p>In Erlang/OTP R6B, a library similar to Erl<em>Interface for Java was added called
_jinterface</em>. It provides a tool for Java programs to communicate with Erlang
nodes.</p><h2 id="standard-protocols" class="section-heading"><a href="#standard-protocols" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Standard Protocols</span></h2><p>Sometimes communication between an Erlang program and another program using a
standard protocol is desirable. Erlang/OTP currently supports TCP/IP and UDP
<em>sockets</em>: as follows:</p><ul><li>SNMP</li><li>HTTP</li><li>IIOP (CORBA)</li></ul><p>Using one of the latter three requires good knowledge about the protocol and is
not covered by this tutorial. See the SNMP, Inets, and Orber applications,
respectively.</p><h3 id="sockets" class="section-heading"><a href="#sockets" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Sockets</span></h3><p>Simply put, connection-oriented socket communication (TCP/IP) consists of an
initiator socket (&quot;server&quot;) started at a certain host with a certain port
number. A connector socket (&quot;client&quot;), which is aware of the initiator host name
and port number, can connect to it and data can be sent between them.</p><p>Connection-less socket communication (UDP) consists of an initiator socket at a
certain host with a certain port number and a connector socket sending data to
it.</p><p>For a detailed description of the socket concept, refer to a suitable book about
network programming. A suggestion is <em>UNIX Network Programming, Volume 1:
Networking APIs - Sockets and XTI</em> by W. Richard Stevens, ISBN: 013490012X.</p><p>In Erlang/OTP, access to TCP/IP and UDP sockets is provided by the modules
<code class="inline">gen_tcp</code> and <code class="inline">gen_udp</code> in Kernel. Both are easy to use and do not require
detailed knowledge about the socket concept.</p><p><em>When to use:</em> For programs running on the same or on another machine than the
Erlang program.</p><p><em>Where to read more:</em> See the <a href="../apps/kernel/gen_tcp.html"><code class="inline">gen_tcp</code></a> and the <a href="../apps/kernel/gen_udp.html"><code class="inline">gen_udp</code></a> manual pages in
Kernel.</p><h2 id="ic-and-corba" class="section-heading"><a href="#ic-and-corba" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">IC and CORBA</span></h2><p>IC (Erlang IDL Compiler) is an interface generator that, given an IDL interface
specification, automatically generates stub code in Erlang, C, or Java. See the
IC User's Guide and IC Reference Manual.</p><p>For details, see the <a href="https://github.com/erlang/corba">corba repository</a>.</p>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="tutorial.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Introduction
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="example.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Problem Example
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="Erlang System Documentation.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.38.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright © 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
