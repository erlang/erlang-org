<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.38.1">
    <meta name="project" content="stdlib v7.1">


<meta name="major-vsn" content="28">
<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=28&q=">
<link rel="canonical" href="https://www.erlang.org/doc/apps/stdlib/re.html" />
    <title>re â€” stdlib v7.1</title>

    <link rel="stylesheet" href="dist/html-erlang-ZK43ZOAC.css" />

    <script defer src="dist/sidebar_items-296BF65E.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-DPJLHKSM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="stdlib" />
        </a>

      <div>
        <a href="../../index.html" class="sidebar-projectName" translate="no">
stdlib
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v7.1
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-module" id="main" data-type="modules">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of stdlib</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>
      <span translate="no">re</span> 
      <small class="app-vsn" translate="no">(stdlib v7.1)</small>

    </h1>

      <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L22" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


    <section id="moduledoc">
<!--%% %CopyrightBegin%%%%% SPDX-License-Identifier: Apache-2.0%%%% Copyright Ericsson AB 2008-2025. All Rights Reserved.%%%% Licensed under the Apache License, Version 2.0 (the "License");%% you may not use this file except in compliance with the License.%% You may obtain a copy of the License at%%%%     http://www.apache.org/licenses/LICENSE-2.0%%%% Unless required by applicable law or agreed to in writing, software%% distributed under the License is distributed on an "AS IS" BASIS,%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.%% See the License for the specific language governing permissions and%% limitations under the License.%%%% %CopyrightEnd%--><p>This module contains regular expression matching functions for strings and
binaries.</p><p>The <a href="re.html#module-perl-like-regular-expression-syntax">regular expression</a> syntax and
semantics resemble that of Perl.</p><p>The matching algorithms of the library are based on the PCRE2 library, but not
all of the PCRE2 library is interfaced and some parts of the library go beyond
what PCRE2 offers. Currently PCRE2 version 10.45 (release date 2024-11-27) is used.
The sections of the PCRE2 documentation that are relevant to this module are
included here.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The Erlang literal syntax for strings uses the <code class="inline">\</code> (backslash) character as
an escape code. You need to escape backslashes in literal strings, both in
your code and in the shell, with an extra backslash, that is, <code class="inline">&quot;\\&quot;</code> or
<code class="inline">&lt;&lt;&quot;\\&quot;&gt;&gt;</code>.</p><p>Since Erlang/OTP 27 you can use <a href="../../system/data_types.html#sigil">verbatim sigils</a>
to write literal strings. The example above would be written as <code class="inline">~S&quot;\&quot;</code> or <code class="inline">~B&quot;\&quot;</code>.</p></section><h2 id="module-perl-like-regular-expression-syntax" class="section-heading"><a href="#module-perl-like-regular-expression-syntax" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Perl-Like Regular Expression Syntax</span></h2><p>The following sections contain reference material for the regular expressions
used by this module. The information is based on the PCRE2 documentation, with
changes where this module behaves differently to the PCRE2 library.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>Starting with Erlang/OTP 28, the underlying library for handling regular expressions via the <code class="inline">re</code>
module changes from PCRE to PCRE2. This upgrade brings Erlang's regular expression capabilities
more in line with modern standards, particularly Perl, but also introduces several breaking
changes and differences in behavior compared to PCRE, see
<a href="re_incompat.html">PCRE incompatabilities</a>.</p></section><h2 id="module-pcre2-regular-expression-details" class="section-heading"><a href="#module-pcre2-regular-expression-details" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">PCRE2 Regular Expression Details</span></h2><p>The syntax and semantics of the regular expressions that are supported by PCRE2
are described in detail below. Perl's regular expressions are described in its own documentation,
and regular expressions in general are covered in a number of books, some of which have
copious examples. Jeffrey Friedl's &quot;Mastering Regular Expressions&quot;, published
by O'Reilly, covers regular expressions in great detail. This description of
PCRE2's regular expressions is intended as reference material.</p><p>The reference material is divided into the following sections:</p><ul><li><a href="re.html#sect1">Special Start-of-Pattern Items</a></li><li><a href="re.html#sect2">Characters and Metacharacters</a></li><li><a href="re.html#sect3">Backslash</a></li><li><a href="re.html#sect4">Circumflex and Dollar</a></li><li><a href="re.html#sect5">Full Stop (Period, Dot) and \N</a></li><li><a href="re.html#sect6">Matching a Single Code Unit</a></li><li><a href="re.html#sect7">Square Brackets and Character Classes</a></li><li><a href="re.html#sect7X">Perl Extended Character Classes</a></li><li><a href="re.html#sect8">Posix Character Classes</a></li><li><a href="re.html#sect9">Vertical Bar</a></li><li><a href="re.html#sect10">Internal Option Setting</a></li><li><a href="re.html#sect11">Groups</a></li><li><a href="re.html#sect12">Duplicate Group Numbers</a></li><li><a href="re.html#sect13">Named Capture Groups</a></li><li><a href="re.html#sect14">Repetition</a></li><li><a href="re.html#sect15">Atomic Grouping and Possessive Quantifiers</a></li><li><a href="re.html#sect16">Backreferences</a></li><li><a href="re.html#sect17">Assertions</a></li><li><a href="re.html#sect18">Non-Atomic Assertions </a></li><li><a href="re.html#sect18X">Scan Substring Assertions</a></li><li><a href="re.html#sect19">Script Runs</a></li><li><a href="re.html#sect20">Conditional Groups</a></li><li><a href="re.html#sect21">Comments</a></li><li><a href="re.html#sect22">Recursive Patterns</a></li><li><a href="re.html#sect23">Groups as Subroutines</a></li><li><a href="re.html#sect24">Oniguruma Subroutine Syntax</a></li><li><a href="re.html#sect25">Backtracking Control</a></li></ul><p><a href="" id="sect1"></a></p><h2 id="module-special-start-of-pattern-items" class="section-heading"><a href="#module-special-start-of-pattern-items" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Special Start-of-Pattern Items</span></h2><p>A number of options that can be passed to <a href="#compile/2"><code class="inline">compile/2</code></a> can also be set
by special items at the start of a pattern. These are not Perl-compatible, but
are provided to make these options accessible to pattern writers who are not
able to change the program that processes the pattern. Any number of these
items may appear, but they must all be together right at the start of the
pattern string, and the letters must be in upper case.</p><p><em>UTF support</em></p><p>Unicode support is basically UTF-8 based. To use Unicode characters, you either
call <a href="#compile/2"><code class="inline">compile/2</code></a> or <a href="#run/3"><code class="inline">run/3</code></a> with option <code class="inline">unicode</code>, or the pattern must start
with one of these special sequences: <code class="inline">(*UTF)</code>, which is equivalent to setting <code class="inline">unicode</code>.
Note that with these instructions, the automatic conversion of lists to UTF-8
is not performed by the <code class="inline">re</code> functions. Therefore, using these sequences is not
recommended. Add option <code class="inline">unicode</code> when running <a href="#compile/2"><code class="inline">compile/2</code></a> instead.</p><p>Some applications that allow their users to supply patterns may wish to
restrict them to non-UTF data for security reasons. If the <code class="inline">never_utf</code>
option is passed to <a href="#compile/2"><code class="inline">compile/2</code></a>, <code class="inline">(*UTF)</code> is not allowed, and its
appearance in a pattern causes an error.</p><p><em>Unicode Property Support</em></p><p>Another special sequence that may appear at the start of a pattern is <code class="inline">(*UCP)</code>.
This has the same effect as setting the <code class="inline">ucp</code> option: it causes sequences
such as <code class="inline">\d</code> and <code class="inline">\w</code> to use Unicode properties to determine character types,
instead of recognizing only characters with codes less than 256 via a lookup
table. It also causes upper/lower casing operations to use Unicode properties
for characters with code points greater than 127, even when UTF is not set.
These behaviours can be changed within the pattern; see <a href="re.html#sect10">Internal Option Setting</a>.</p><p>Some applications that allow their users to supply patterns may wish to
restrict them for security reasons. If the <code class="inline">never_ucp</code> option is passed to
<a href="#compile/2"><code class="inline">compile/2</code></a>, <code class="inline">(*UCP)</code> is not allowed, and its appearance in a pattern
causes an error.</p><p><em>Locking Out Empty String Matching</em></p><p>Starting a pattern with <code class="inline">(*NOTEMPTY)</code> or <code class="inline">(*NOTEMPTY_ATSTART)</code> has the same effect
as passing the <code class="inline">notempty</code> or <code class="inline">notempty_atstart</code> option to whichever
matching function is subsequently called to match the pattern. These options
lock out the matching of empty strings, either entirely, or only at the start
of the subject.</p><p><em>Disabling Start-Up Optimizations</em></p><p>If a pattern starts with <code class="inline">(*NO_START_OPT)</code>, it has the same effect as setting the
<code class="inline">no_start_optimize</code> option. This disables several optimizations for
quickly reaching &quot;no match&quot; results.</p><p><em>Disabling Automatic Anchoring</em></p><p>If a pattern starts with <code class="inline">(*NO_DOTSTAR_ANCHOR)</code>. This disables optimizations that
apply to patterns whose top-level branches all start with .* (match any number
of arbitrary characters).</p><p><em>Setting Match Resource Limits</em></p><p>The caller of <a href="#run/3"><code class="inline">run/3</code></a> can set a
limit on this counter, which therefore limits the amount of computing resource
used for a match. The maximum depth of nested backtracking can also be limited;
this indirectly restricts the amount of heap memory that is used, but there is
also an explicit memory limit that can be set.</p><p>These facilities are provided to catch runaway matches that are provoked by
patterns with huge matching trees. A common example is a pattern with nested
unlimited repeats applied to a long string that does not match. When one of
these limits is reached, <a href="#run/3"><code class="inline">run/3</code></a> gives an error return. The limits
can also be set by items at the start of the pattern of the form</p><pre><code class="text">(*LIMIT_HEAP=d)
(*LIMIT_MATCH=d)
(*LIMIT_DEPTH=d)</code></pre><p>where d is any number of decimal digits. However, the value of the setting must
be less than the value set as default
for it to have any effect. In other words, the pattern writer can lower the
limits set by the programmer, but not raise them. If there is more than one
setting of one of these limits, the lower value is used. The heap limit is
specified in kibibytes (units of 1024 bytes).</p><p>The default value for <code class="inline">LIMIT_MATCH</code> and <code class="inline">LIMIT_DEPTH</code> is 10,000,000 in the
Erlang VM.
Notice that the recursion limit does not affect the stack depth of the VM, as PCRE for
Erlang is compiled in such a way that the match function never does recursion on
the C stack.</p><p>Prior to release 10.30, LIMIT_DEPTH was called LIMIT_RECURSION. This name is
still recognized for backwards compatibility.</p><p><a href="" id="sect1.1"></a>
<em>Newline Conventions</em></p><p>PCRE2 supports six different conventions for indicating line breaks in
strings: a single CR (carriage return) character, a single LF (linefeed)
character, the two-character sequence CRLF, any of the three preceding, any
Unicode newline sequence, or the NUL character (binary zero).</p><p>It is also possible to specify a newline convention by starting a pattern
string with one of the following sequences:</p><ul><li><strong>(*CR)</strong> -  carriage return</li><li><strong>(*LF)</strong> -  linefeed</li><li><strong>(*CRLF)</strong> -  carriage return, followed by linefeed</li><li><strong>(*ANYCRLF)</strong> -  any of the three above</li><li><strong>(*ANY)</strong> -  all Unicode newline sequences</li><li><strong>(*NUL)</strong> -  the NUL character (binary zero)</li></ul><p>These override the default and the options given to the compiling function. For
example, on a Unix system where LF is the default newline sequence, the pattern</p><pre><code class="text">(*CR)a.b</code></pre><p>changes the convention to CR. That pattern matches &quot;a\nb&quot; because LF is no
longer a newline. If more than one of these settings is present, the last one
is used.</p><p>The newline convention affects where the circumflex and dollar assertions are
true. It also affects the interpretation of the dot metacharacter when
<code class="inline">dotall</code> is not set, and the behaviour of <code class="inline">\N</code> when not followed by an
opening brace. However, it does not affect what the <code class="inline">\R</code> escape sequence
matches. By default, this is any Unicode newline sequence, for Perl
compatibility. However, this can be changed; see the next section and the
description of <code class="inline">\R</code> in <a href="re.html#sect3.3">Newline Sequences</a>.
A change of <code class="inline">\R</code> setting can be combined with a change of newline
convention.</p><p><em>Specifying What <code class="inline">\R</code> Matches</em></p><p>It is possible to restrict <code class="inline">\R</code> to match only CR, LF, or CRLF (instead of the
complete set of Unicode line endings) by setting the option <code class="inline">bsr_anycrlf</code>
at compile time. This effect can also be achieved by starting a pattern with
<code class="inline">(*BSR_ANYCRLF)</code>. For completeness, <code class="inline">(*BSR_UNICODE)</code> is also recognized,
corresponding to <code class="inline">bsr_anycrlf</code>.</p><p><a href="" id="sect2"></a></p><h2 id="module-characters-and-metacharacters" class="section-heading"><a href="#module-characters-and-metacharacters" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Characters and Metacharacters</span></h2><p>A regular expression is a pattern that is matched against a subject string from
left to right. Most characters stand for themselves in a pattern, and match the
corresponding characters in the subject. As a trivial example, the pattern</p><pre><code class="text">The quick brown fox</code></pre><p>matches a portion of a subject string that is identical to itself. When
caseless matching is specified (the <code class="inline">caseless</code> option or (?i) within the
pattern), letters are matched independently of case. Note that there are two
ASCII characters, K and S, that, in addition to their lower case ASCII
equivalents, are case-equivalent with Unicode U+212A (Kelvin sign) and U+017F
(long S) respectively when either <code class="inline">unicode</code> or <code class="inline">ucp</code> is set.</p><p>The power of regular expressions comes from the ability to include wild cards,
character classes, alternatives, and repetitions in the pattern. These are
encoded in the pattern by the use of <em>metacharacters</em>, which do not stand
for themselves but instead are interpreted in some special way.</p><p>There are two different sets of metacharacters: those that are recognized
anywhere in the pattern except within square brackets, and those that are
recognized within square brackets. Outside square brackets, the metacharacters
are as follows:</p><ul><li><strong><code class="inline">\</code></strong> -  general escape character with several uses</li><li><strong><code class="inline">^</code></strong> -  assert start of string (or line, in multiline mode)</li><li><strong><code class="inline">$</code></strong> -  assert end of string (or line, in multiline mode)</li><li><strong><code class="inline">.</code></strong> -  match any character except newline (by default)</li><li><strong><code class="inline">[</code></strong> -  start character class definition</li><li><strong><code class="inline">|</code></strong> -  start of alternative branch</li><li><strong><code class="inline">(</code></strong> -  start group or control verb</li><li><strong><code class="inline">)</code></strong> -  end group or control verb</li><li><strong><code class="inline">*</code></strong> -  0 or more quantifier</li><li><strong><code class="inline">+</code></strong> -  1 or more quantifier; also &quot;possessive quantifier&quot;</li><li><strong><code class="inline">?</code></strong> -  0 or 1 quantifier; also quantifier minimizer</li><li><strong><code class="inline">{</code></strong> -  potential start of min/max quantifier</li></ul><p>Brace characters <code class="inline">{</code> and <code class="inline">}</code> are also used to enclose data for constructions such
as <code class="inline">\g{2}</code> or <code class="inline">\k{name}</code>. In almost all uses of braces, space and/or horizontal
tab characters that follow <code class="inline">{</code> or precede <code class="inline">}</code> are allowed and are ignored. In the
case of quantifiers, they may also appear before or after the comma. </p><p>Part of a pattern that is in square brackets is called a &quot;character class&quot;. In
a character class the only metacharacters are:</p><ul><li><strong><code class="inline">\</code></strong> -  general escape character</li><li><strong><code class="inline">^</code></strong> -  negate the class, but only if the first character</li><li><strong><code class="inline">-</code></strong> -  indicates character range</li><li><strong><code class="inline">[</code></strong> -  POSIX character class (if followed by POSIX syntax)</li><li><strong><code class="inline">]</code></strong> -  terminates the character class</li></ul><p>If a pattern is compiled with the <code class="inline">extended</code> option, most white space in
the pattern, other than in a character class, within a <code class="inline">\Q...\E</code> sequence, or
between a <code class="inline">#</code>  outside a character class and the next newline, inclusive, is
ignored. An escaping backslash can be used to include a white space or a #
character as part of the pattern.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Only these two characters are ignored,
not the full set of pattern white space characters that are ignored outside a
character class. Option settings can be changed within a pattern; see <a href="re.html#sect10">Internal Option Setting</a>.</p></section><p>The following sections describe the use of each of the metacharacters.</p><p><a href="" id="sect3"></a></p><h2 id="module-backslash" class="section-heading"><a href="#module-backslash" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Backslash</span></h2><p>The backslash character has several uses. Firstly, if it is followed by a
character that is not a digit or a letter, it takes away any special meaning
that character may have. This use of backslash as an escape character applies
both inside and outside character classes.</p><p>For example, if you want to match a <code class="inline">*</code>  character, you must write <code class="inline">\*</code> in the
pattern. This escaping action applies whether or not the following character
would otherwise be interpreted as a metacharacter, so it is always safe to
precede a non-alphanumeric with backslash to specify that it stands for itself.
In particular, if you want to match a backslash, you write <code class="inline">\\</code>.</p><p>Only ASCII digits and letters have any special meaning after a backslash. All
other characters (in particular, those whose code points are greater than 127)
are treated as literals.</p><p>If you want to treat all characters in a sequence as literals, you can do so by
putting them between <code class="inline">\Q</code> and <code class="inline">\E</code>. Note that this includes white space even when
the <code class="inline">extended</code> option is set so that most other white space is ignored. The
behaviour is different from Perl in that <code class="inline">$</code> and <code class="inline">@</code> are handled as literals in
<code class="inline">\Q...\E</code> sequences in PCRE2, whereas in Perl, <code class="inline">$</code> and <code class="inline">@</code> cause variable
interpolation. Also, Perl does &quot;double-quotish backslash interpolation&quot; on any
backslashes between <code class="inline">\Q</code> and <code class="inline">\E</code> which, its documentation says, &quot;may lead to
confusing results&quot;. PCRE2 treats a backslash between <code class="inline">\Q</code> and <code class="inline">\E</code> just like any
other character. Note the following examples:</p><ul><li><strong>Pattern</strong> -  PCRE2 matches   Perl matches</li><li><strong>\Qabc$xyz\E</strong> -  abc$xyz        abc followed by the
contents of $xyz</li><li><strong>\Qabc$xyz\E</strong> -  abc$xyz       abc$xyz</li><li><strong>\Qabc\E$\Qxyz\E</strong> -  abc$xyz        abc$xyz</li><li><strong>\QA\B\E</strong> -  A\B            A\B</li><li><strong>\Q\E</strong> -  \              \E</li></ul><p>The <code class="inline">\Q...\E</code> sequence is recognized both inside and outside character classes.
An isolated <code class="inline">\E</code> that is not preceded by <code class="inline">\Q</code> is ignored. If <code class="inline">\Q</code> is not followed
by <code class="inline">\E</code> later in the pattern, the literal interpretation continues to the end of
the pattern (that is, <code class="inline">\E</code> is assumed at the end). If the isolated <code class="inline">\Q</code> is inside
a character class, this causes an error, because the character class is then
not terminated by a closing square bracket.</p><p>Another difference from Perl is that any appearance of <code class="inline">\Q</code> or <code class="inline">\E</code> inside what
might otherwise be a quantifier causes PCRE2 not to recognize the sequence as a
quantifier. Perl recognizes a quantifier if (redundantly) either of the numbers
is inside <code class="inline">\Q...\E</code>, but not if the separating comma is. When not recognized as
a quantifier a sequence such as <code class="inline">{\Q1\E,2}</code> is treated as the literal string
&quot;{1,2}&quot;.</p><p><a href="" id="sect3.1"></a> 
<em>Non-Printing Characters</em></p><p>A second use of backslash provides a way of encoding non-printing characters
in patterns in a visible manner. There is no restriction on the appearance of
non-printing characters in a pattern, but when a pattern is being prepared by
text editing, it is often easier to use one of the following escape sequences
instead of the binary character it represents. In an ASCII or Unicode
environment, these escapes are as follows:</p><ul><li><strong><code class="inline">\a</code></strong> -  alarm, that is, the BEL character (hex 07)</li><li><strong><code class="inline">\cx</code></strong> -  &quot;control-x&quot;, where x is a non-control ASCII character</li><li><strong><code class="inline">\e</code></strong> -  escape (hex 1B)</li><li><strong><code class="inline">\f</code></strong> -  form feed (hex 0C)</li><li><strong><code class="inline">\n</code></strong> -  linefeed (hex 0A)</li><li><strong><code class="inline">\r</code></strong> -  carriage return (hex 0D) (but see below)</li><li><strong><code class="inline">\t</code></strong> -  tab (hex 09)</li><li><strong><code class="inline">\0dd</code></strong> -  character with octal code 0dd</li><li><strong><code class="inline">\ddd</code></strong> -  character with octal code ddd, or back reference</li><li><strong><code class="inline">\o{ddd..}</code></strong> -  character with octal code ddd..</li><li><strong><code class="inline">\xhh</code></strong> -  character with hex code hh</li><li><strong><code class="inline">\x{hhh..}</code></strong> -  character with hex code hhh..</li><li><strong><code class="inline">\N{U+hhh..}</code></strong> -  character with Unicode hex code point hhh..</li></ul><p>A description of how back references work is given
later,
following the discussion of
parenthesized groups.</p><p>By default, after <code class="inline">\x</code> that is not followed by <code class="inline">{</code>, one or two hexadecimal
digits are read (letters can be in upper or lower case). If the character that
follows <code class="inline">\x</code> is neither <code class="inline">{</code> nor a hexadecimal digit, an error occurs. This is
different from Perl's default behaviour, which generates a NUL character, but
is in line with the behaviour of Perl's 'strict' mode in re.</p><p>Any number of hexadecimal digits may appear between <code class="inline">\x{</code> and <code class="inline">}</code>. If a character
other than a hexadecimal digit appears between <code class="inline">\x{</code> and <code class="inline">}</code>, or if there is no
terminating <code class="inline">}</code>, an error occurs.</p><p>Characters whose code points are less than 256 can be defined by either of the
two syntaxes for <code class="inline">\x</code> or by an octal sequence. There is no difference in the way
they are handled. For example, <code class="inline">\xdc</code> is exactly the same as <code class="inline">\x{dc}</code> or <code class="inline">\334</code>.
However, using the braced versions does make such sequences easier to read.</p><p>The <code class="inline">\N{U+hhh..}</code> escape sequence is recognized only when PCRE2 is operating in
UTF mode. Perl also uses <code class="inline">\N{name}</code> to specify characters by Unicode name; PCRE2
does not support this. Note that when <code class="inline">\N</code> is not followed by an opening brace
(curly bracket) it has an entirely different meaning, matching any character
that is not a newline.</p><p>There are some legacy applications where the escape sequence <code class="inline">\r</code> is expected to
match a newline.</p><p>An error occurs if <code class="inline">\c</code> is not followed by a character whose ASCII code point
is in the range 32 to 126. The precise effect of <code class="inline">\cx</code> is as follows: if x is a
lower case letter, it is converted to upper case. Then bit 6 of the character
(hex 40) is inverted. Thus <code class="inline">\cA</code> to <code class="inline">\cZ</code> become hex 01 to hex 1A (A is 41, Z is
5A), but <code class="inline">\c{</code> becomes hex 3B ({ is 7B), and <code class="inline">\c</code>; becomes hex 7B (; is 3B). If
the code unit following <code class="inline">\c</code> has a code point less than 32 or greater than 126,
a compile-time error occurs.</p><p><em>Octal Escapes and Back References</em></p><p>The escape <code class="inline">\o</code> must be followed by a sequence of octal digits, enclosed in
braces. An error occurs if this is not the case. This escape provides a way of
specifying character code points as octal numbers greater than 0777, and it
also allows octal numbers and backreferences to be unambiguously distinguished.</p><p>If braces are not used, after <code class="inline">\0</code> up to two further octal digits are read.</p><p>Inside a character class, when a backslash is followed by any octal digit, up
to three octal digits are read to generate a code point. Any subsequent digits
stand for themselves. The sequences <code class="inline">\8</code> and <code class="inline">\9</code> are treated as the literal
characters &quot;8&quot; and &quot;9&quot;.</p><p>Outside a character class, Perl's handling of a backslash followed by a digit
other than 0 is complicated by ambiguity, and Perl has changed over time,
causing PCRE2 also to change.</p><p>For greater clarity and unambiguity, it is best to avoid following \e by a
digit greater than zero. Instead, use <code class="inline">\o{...}</code> or <code class="inline">\x{...}</code> to specify numerical
character code points, and <code class="inline">\g{...}</code> to specify backreferences.</p><p><em>Perl Rules for Non-Class Backslash 1-9</em></p><p>All the digits that follow the backslash are read as a decimal number. If the
number is less than 10, begins with the digit 8 or 9, or if there are at least
that many previous capture groups in the expression, the entire sequence is
taken as a back reference. Otherwise, up to three octal digits are read to form
a character code. For example:</p><ul><li><strong><code class="inline">\040</code></strong> -  is another way of writing an ASCII space</li><li><strong><code class="inline">\40</code></strong> -  is the same, provided there are fewer than 40
previous capture groups</li><li><strong><code class="inline">\7</code></strong> -  is always a backreference</li><li><strong><code class="inline">\11</code></strong> -  might be a backreference, or another way of
writing a tab</li><li><strong><code class="inline">\011</code></strong> -  is always a tab</li><li><strong><code class="inline">\0113</code></strong> -  is a tab followed by the character &quot;3&quot;</li><li><strong><code class="inline">\113</code></strong> -  might be a backreference, otherwise the
character with octal code 113</li><li><strong><code class="inline">\377</code></strong> -  might be a backreference, otherwise
the value 255 (decimal)</li><li><strong><code class="inline">\81</code></strong> -  is always a backreference</li></ul><p>Note that octal values of 100 or greater that are specified using this syntax
must not be introduced by a leading zero, because no more than three octal
digits are ever read.</p><p><em>Python Rules for Non-Class Backslash 1-9</em></p><p>If there are at least three octal digits after the backslash, exactly three are
read as an octal code point number, but the value must be no greater than
<code class="inline">\377</code>, even in modes where higher code point values are supported. Any
subsequent digits stand for themselves. If there are fewer than three octal
digits, the sequence is taken as a decimal back reference. Thus, for example,
<code class="inline">\12</code> is always a back reference, independent of how many captures there are in
the pattern. An error is generated for a reference to a non-existent capturing
group.</p><p><em>Constraints on Character Values</em></p><p>Characters that are specified using octal or hexadecimal numbers are
limited to certain values, as follows:</p><ul><li><strong>8-bit non-UTF mode</strong> -  no greater than 0xff</li><li><strong>8-bit UTF-8 mode</strong> -  no greater than 0x10ffff and a valid code point</li></ul><p>Invalid Unicode code points are all those in the range 0xd800 to 0xdfff (the
so-called &quot;surrogate&quot; code points).</p><p><em>Escape Sequences in Character Classes</em></p><p>All the sequences that define a single character value can be used both inside
and outside character classes. In addition, inside a character class, <code class="inline">\b</code> is
interpreted as the backspace character (hex 08).</p><p>When not followed by an opening brace, <code class="inline">\N</code> is not allowed in a character class.
<code class="inline">\B</code>, <code class="inline">\R</code>, and <code class="inline">\X</code> are not special inside a character class. Like other
unrecognized alphabetic escape sequences, they cause an error. Outside a
character class, these sequences have different meanings.</p><p><em>Unsupported Escape Sequences</em></p><p>In Perl, the sequences <code class="inline">\F</code>, <code class="inline">\l</code>, <code class="inline">\L</code>, <code class="inline">\u</code>, and <code class="inline">\U</code> are recognized by its string
handler and used to modify the case of following characters. By default, PCRE2
does not support these escape sequences in patterns.</p><p><em>Absolute and Relative Backreferences</em></p><p>The sequence <code class="inline">\g</code> followed by a signed or unsigned number, optionally enclosed
in braces, is an absolute or relative backreference. A named backreference
can be coded as <code class="inline">\g{name}</code>. Backreferences are discussed
later,
following the discussion of
parenthesized groups.</p><p><em>Absolute and Relative Subroutine Calls</em></p><p>For compatibility with Oniguruma, the non-Perl syntax <code class="inline">\g</code> followed by a name or
a number enclosed either in angle brackets or single quotes, is an alternative
syntax for referencing a capture group as a subroutine. Details are discussed
later.
Note that <code class="inline">\g{...}</code> (Perl syntax) and <code class="inline">\g&lt;...&gt;</code> (Oniguruma syntax) are <em>not</em>
synonymous. The former is a backreference; the latter is a
subroutine
call.</p><p><a href="" id="sect3.2"></a>
<em>Generic Character Types</em></p><p>Another use of backslash is for specifying generic character types:</p><ul><li><strong><code class="inline">\d</code></strong> -  any decimal digit</li><li><strong><code class="inline">\D</code></strong> -  any character that is not a decimal digit</li><li><strong><code class="inline">\h</code></strong> -  any horizontal white space character</li><li><strong><code class="inline">\H</code></strong> -  any character that is not a horizontal white space character</li><li><strong><code class="inline">\N</code></strong> -  any character that is not a newline</li><li><strong><code class="inline">\s</code></strong> -  any white space character</li><li><strong><code class="inline">\S</code></strong> -  any character that is not a white space character</li><li><strong><code class="inline">\v</code></strong> -  any vertical white space character</li><li><strong><code class="inline">\V</code></strong> -  any character that is not a vertical white space character</li><li><strong><code class="inline">\w</code></strong> -  any &quot;word&quot; character</li><li><strong><code class="inline">\W</code></strong> -  any &quot;non-word&quot; character</li></ul><p>The <code class="inline">\N</code> escape sequence has the same meaning as
the &quot;.&quot; metacharacter
when <code class="inline">dotall</code> is not set, but setting <code class="inline">dotall</code> does not change the
meaning of <code class="inline">\N</code>. Note that when <code class="inline">\N</code> is followed by an opening brace it has a
different meaning. See <a href="re.html#sect3.1">Non-Printing Characters</a>. Perl also uses <code class="inline">\N{name}</code> to specify characters by Unicode
name; PCRE2 does not support this.</p><p>Each pair of lower and upper case escape sequences partitions the complete set
of characters into two disjoint sets. Any given character matches one, and only
one, of each pair. The sequences can appear both inside and outside character
classes. They each match one character of the appropriate type. If the current
matching point is at the end of the subject string, all of them fail, because
there is no character to match.</p><p>The default <code class="inline">\s</code> characters are HT (9), LF (10), VT (11), FF (12), CR (13), and
space (32), which are defined as white space in the &quot;C&quot; locale. This list may
vary if locale-specific matching is taking place. For example, in some locales
the &quot;non-breaking space&quot; character (<code class="inline">\xA0</code>) is recognized as white space, and in
others the VT character is not.</p><p>A &quot;word&quot; character is an underscore or any character that is a letter or digit.
By default, the definition of letters and digits is controlled by PCRE2's
low-valued character tables, and may vary if locale-specific matching is taking
place. For example, in a French locale such as &quot;fr_FR&quot; in Unix-like systems,
or &quot;french&quot; in Windows, some character codes greater than 127 are used for
accented letters, and these are then matched by <code class="inline">\w</code>. The use of locales with
Unicode is discouraged.</p><p>By default, characters whose code points are greater than 127 never match <code class="inline">\d</code>,
<code class="inline">\s</code>, or <code class="inline">\w</code>, and always match <code class="inline">\D</code>, <code class="inline">\S</code>, and <code class="inline">\W</code>, although this may be different
for characters in the range 128-255 when locale-specific matching is happening.
These escape sequences retain their original meanings from before Unicode
support was available, mainly for efficiency reasons. If the <code class="inline">ucp</code> option
is set, the behaviour is changed so that Unicode properties are used to
determine character types, as follows:</p><ul><li><p><strong><code class="inline">\d</code></strong> - Any character that matches <code class="inline">\p{Nd}</code> (decimal digit)</p></li><li><p><strong><code class="inline">\s</code></strong> - Any character that matches <code class="inline">\p{Z}</code> or <code class="inline">\h</code> or <code class="inline">\v</code></p></li><li><p><strong><code class="inline">\w</code></strong> - Any character that matches <code class="inline">\p{L}</code>, <code class="inline">\p{N}</code>, <code class="inline">\p{Mn}</code>, or <code class="inline">\p{Pc}</code></p></li></ul><p>The addition of <code class="inline">\p{Mn}</code> (non-spacing mark) and the replacement of an explicit
test for underscore with a test for <code class="inline">\p{Pc}</code> (connector punctuation) happened in
PCRE2 release 10.43. This brings PCRE2 into line with Perl.</p><p>The upper case escapes match the inverse sets of characters. Note that <code class="inline">\d</code>
matches only decimal digits, whereas <code class="inline">\w</code> matches any Unicode digit, as well as
other character categories. Note also that <code class="inline">ucp</code> affects <code class="inline">\b</code>, and
<code class="inline">\B</code> because they are defined in terms of <code class="inline">\w</code> and <code class="inline">\W</code>. Matching these sequences
is noticeably slower when <code class="inline">ucp</code> is set.</p><p>The effect of <code class="inline">ucp</code> on any one of these escape sequences can be negated by
the options within
a pattern by means of an <a href="re.html#sect10">Internal Option Setting</a>.</p><p>The sequences <code class="inline">\h</code>, <code class="inline">\H</code>, <code class="inline">\v</code>, and <code class="inline">\V</code>, in contrast to the other sequences, which
match only ASCII characters by default, always match a specific list of code
points, whether or not <code class="inline">ucp</code> is set. The horizontal space characters are:</p><ul><li><p><strong>U+0009</strong> -  Horizontal tab (HT)</p></li><li><p><strong>U+0020</strong> -  Space</p></li><li><p><strong>U+00A0</strong> -  Non-break space</p></li><li><p><strong>U+1680</strong> -  Ogham space mark</p></li><li><p><strong>U+180E</strong> -  Mongolian vowel separator</p></li><li><p><strong>U+2000</strong> -  En quad</p></li><li><p><strong>U+2001</strong> -  Em quad</p></li><li><p><strong>U+2002</strong> -  En space</p></li><li><p><strong>U+2003</strong> -  Em space</p></li><li><p><strong>U+2004</strong> -  Three-per-em space</p></li><li><p><strong>U+2005</strong> -  Four-per-em space</p></li><li><p><strong>U+2006</strong> -  Six-per-em space</p></li><li><p><strong>U+2007</strong> -  Figure space</p></li><li><p><strong>U+2008</strong> -  Punctuation space</p></li><li><p><strong>U+2009</strong> -  Thin space</p></li><li><p><strong>U+200A</strong> -  Hair space</p></li><li><p><strong>U+202F</strong> -  Narrow no-break space</p></li><li><p><strong>U+205F</strong> -  Medium mathematical space</p></li><li><p><strong>U+3000</strong> -  Ideographic space</p></li></ul><p>The vertical space characters are:</p><ul><li><p><strong>U+000A</strong> -  Linefeed (LF)</p></li><li><p><strong>U+000B</strong> -  Vertical tab (VT)</p></li><li><p><strong>U+000C</strong> -  Form feed (FF)</p></li><li><p><strong>U+000D</strong> -  Carriage return (CR)</p></li><li><p><strong>U+0085</strong> -  Next line (NEL)</p></li><li><p><strong>U+2028</strong> -  Line separator</p></li><li><p><strong>U+2029</strong> -  Paragraph separator</p></li></ul><p>In 8-bit, non-UTF-8 mode, only the characters with code points less than 256
are relevant.</p><p><a href="" id="sect3.3"></a>
<em>Newline Sequences</em></p><p>Outside a character class, by default, the escape sequence <code class="inline">\R</code> matches any
Unicode newline sequence. In 8-bit non-UTF-8 mode <code class="inline">\R</code> is equivalent to the
following:</p><pre><code class="text">(?&gt;\r\n|\n|\x0b|\f|\r|\x85)</code></pre><p>This is an example of an &quot;atomic group&quot;, details of which are given
below.
This particular group matches either the two-character sequence CR followed by
LF, or one of the single characters LF (linefeed, U+000A), VT (vertical tab,
U+000B), FF (form feed, U+000C), CR (carriage return, U+000D), or NEL (next
line, U+0085). Because this is an atomic group, the two-character sequence is
treated as a single unit that cannot be split.</p><p>In other modes, two additional characters whose code points are greater than 255
are added: LS (line separator, U+2028) and PS (paragraph separator, U+2029).
Unicode support is not needed for these characters to be recognized.</p><p>It is possible to restrict <code class="inline">\R</code> to match only CR, LF, or CRLF (instead of the
complete set of Unicode line endings) by setting the option <code class="inline">bsr_anycrlf</code>
at compile time. (BSR is an abbreviation for &quot;backslash R&quot;.) This can be made
the default when PCRE2 is built; if this is the case, the other behaviour can
be requested via the <code class="inline">bsr_anycrlf</code> option. It is also possible to specify
these settings by starting a pattern string with one of the following
sequences:</p><ul><li><strong>(*BSR_ANYCRLF)</strong> -  CR, LF, or CRLF only</li><li><strong>(*BSR_UNICODE)</strong> -  any Unicode newline sequence</li></ul><p>These override the default and the options given to the compiling function.
Note that these special settings, which are not Perl-compatible, are recognized
only at the very start of a pattern, and that they must be in upper case. If
more than one of them is present, the last one is used. They can be combined
with a change of newline convention; for example, a pattern can start with:</p><pre><code class="text">(*ANY)(*BSR_ANYCRLF)</code></pre><p>They can also be combined with the <code class="inline">(*UTF)</code> or <code class="inline">(*UCP)</code> special sequences. Inside a
character class, <code class="inline">\R</code> is treated as an unrecognized escape sequence, and causes
an error.</p><p><em>Unicode Character Properties</em></p><p>When PCRE2 is built with Unicode support (the default), three additional escape
sequences that match characters with specific properties are available. They
can be used in any mode, though in 8-bit non-UTF modes these
sequences are of course limited to testing characters whose code points are
less than U+0100.</p><p>Matching characters by Unicode property is not fast, because PCRE2 has to do a
multistage table lookup in order to find a character's property. That is why
the traditional escape sequences such as <code class="inline">\d</code> and <code class="inline">\w</code> do not use Unicode
properties in PCRE2 by default, though you can make them do so by setting the
<code class="inline">ucp</code> option or by starting the pattern with <code class="inline">(*UCP)</code>.</p><p>The extra escape sequences that provide property support are:</p><ul><li><strong><code class="inline">\p{_xx_}</code></strong> -  a character with the _xx_ property</li><li><strong><code class="inline">\P{_xx_}</code></strong> -  a character without the _xx_ property</li><li><strong><code class="inline">\X</code></strong> -  a Unicode extended grapheme cluster</li></ul><p>For compatibility with Perl, negation can be specified by including a
circumflex between the opening brace and the property. For example, <code class="inline">\p{^Lu}</code> is
the same as <code class="inline">\P{Lu}</code>.</p><p>In accordance with Unicode's &quot;loose matching&quot; rules, ASCII white space
characters, hyphens, and underscores are ignored in the properties represented
by _xx_ above. As well as the space character, ASCII white space can be
tab, linefeed, vertical tab, formfeed, or carriage return.</p><p>Some properties are specified as a name only; others as a name and a value,
separated by a colon or an equals sign. The names and values consist of ASCII
letters and digits (with one Perl-specific exception, see below). They are not
case sensitive. Note, however, that the escapes themselves, <code class="inline">\p</code> and <code class="inline">\P</code>,
_are_ case sensitive. There are abbreviations for many names. The following
examples are all equivalent:</p><pre><code class="text">\p{bidiclass=al}
\p{BC=al}
\p{ Bidi_Class : AL }
\p{ Bi-di class = Al }
\P{ ^ Bi-di class = Al }</code></pre><p>There is support for Unicode script names, Unicode general category properties,
&quot;Any&quot;, which matches any character (including newline), Bidi_Class, a number of
binary (yes/no) properties, and some special PCRE2 properties (described
below).
Certain other Perl properties such as &quot;InMusicalSymbols&quot; are not supported by
PCRE2. Note that <code class="inline">\P{Any}</code> does not match any characters, so always causes a
match failure.</p><p><em>Script Properties for <code class="inline">\p</code> and <code class="inline">\P</code></em></p><p>There are three different syntax forms for matching a script. Each Unicode
character has a basic script and, optionally, a list of other scripts (&quot;Script
Extensions&quot;) with which it is commonly used. Using the Adlam script as an
example, <code class="inline">\p{sc:Adlam}</code> matches characters whose basic script is Adlam, whereas
<code class="inline">\p{scx:Adlam}</code> matches, in addition, characters that have Adlam in their
extensions list. The full names &quot;script&quot; and &quot;script extensions&quot; for the
property types are recognized and, as for all property specifications, an
equals sign is an alternative to the colon. If a script name is given without a
property type, for example, <code class="inline">\p{Adlam}</code>, it is treated as <code class="inline">\p{scx:Adlam}</code>. Perl
changed to this interpretation at release 5.26 and PCRE2 changed at release
10.40.</p><p>Unassigned characters are assigned the &quot;Unknown&quot; script. Others that are not
part of an identified script are lumped together as &quot;Common&quot;.</p><p><em>The General Category Property for <code class="inline">\p</code> and <code class="inline">\P</code></em></p><p>Each character has exactly one Unicode general category property, specified by
a two-letter abbreviation. If only one letter is specified with <code class="inline">\p</code> or <code class="inline">\P</code>, it
includes all the general category properties that start with that letter. In
this case, in the absence of negation, the curly brackets in the escape
sequence are optional; these two examples have the same effect:</p><pre><code class="text">\p{L}
\pL</code></pre><p>The following general category property codes are supported:</p><ul><li><strong>C</strong> -  Other</li><li><strong>Cc</strong> -  Control</li><li><strong>Cf</strong> -  Format</li><li><strong>Cn</strong> -  Unassigned</li><li><strong>Co</strong> -  Private use</li><li><strong>Cs</strong> -  Surrogate</li><li><strong>L</strong> -  Letter</li><li><strong>Lc</strong> -  Cased letter</li><li><strong>Ll</strong> -  Lower case letter</li><li><strong>Lm</strong> -  Modifier letter</li><li><strong>Lo</strong> -  Other letter</li><li><strong>Lt</strong> -  Title case letter</li><li><strong>Lu</strong> -  Upper case letter</li><li><strong>M</strong> -  Mark</li><li><strong>Mc</strong> -  Spacing mark</li><li><strong>Me</strong> -  Enclosing mark</li><li><strong>Mn</strong> -  Non-spacing mark</li><li><strong>N</strong> -  Number</li><li><strong>Nd</strong> -  Decimal number</li><li><strong>Nl</strong> -  Letter number</li><li><strong>No</strong> -  Other number</li><li><strong>P</strong> -  Punctuation</li><li><strong>Pc</strong> -  Connector punctuation</li><li><strong>Pd</strong> -  Dash punctuation</li><li><strong>Pe</strong> -  Close punctuation</li><li><strong>Pf</strong> -  Final punctuation</li><li><strong>Pi</strong> -  Initial punctuation</li><li><strong>Po</strong> -  Other punctuation</li><li><strong>Ps</strong> -  Open punctuation</li><li><strong>S</strong> -  Symbol</li><li><strong>Sc</strong> -  Currency symbol</li><li><strong>Sk</strong> -  Modifier symbol</li><li><strong>Sm</strong> -  Mathematical symbol</li><li><strong>So</strong> -  Other symbol</li><li><strong>Z</strong> -  Separator</li><li><strong>Zl</strong> -  Line separator</li><li><strong>Zp</strong> -  Paragraph separator</li><li><strong>Zs</strong> -  Space separator</li></ul><p>Perl originally used the name L&amp; for the Lc property. This is still supported
by Perl, but discouraged. PCRE2 also still supports it. This property matches
any character that has the Lu, Ll, or Lt property, in other words, any letter
that is not classified as a modifier or &quot;other&quot;. From release 10.45 of PCRE2
the properties Lu, Ll, and Lt are all treated as Lc when case-independent
matching is set by the <code class="inline">caseless</code> option or (?i) within the pattern. The
other properties are not affected by caseless matching.</p><p>The Cs (Surrogate) property applies only to characters whose code points are in
the range U+D800 to U+DFFF.
However, they are not valid in Unicode strings and so cannot be tested by PCRE2
in UTF mode.</p><p>The long synonyms for property names that Perl supports (such as <code class="inline">\p{Letter}</code>)
are not supported by PCRE2, nor is it permitted to prefix any of these
properties with &quot;Is&quot;.</p><p>No character that is in the Unicode table has the Cn (unassigned) property.
Instead, this property is assumed for any code point that is not in the
Unicode table.</p><p><em>Binary (Yes/No) Properties for <code class="inline">\p</code> and <code class="inline">\P</code></em></p><p>Unicode defines a number of binary properties, that is, properties whose only
values are true or false. You can obtain a list of those that are recognized by
<code class="inline">\p</code> and <code class="inline">\P</code>, along with their abbreviations, by running this command:</p><pre><code class="text">pcre2test -LP</code></pre><p><em>The Bidi_Class Property for <code class="inline">\p</code> and <code class="inline">\P</code></em></p><ul><li><strong><code class="inline">\p{Bidi_Class:&lt;class&gt;}</code></strong> -  matches a character with the given class</li><li><strong><code class="inline">\p{BC:&lt;class&gt;}</code></strong> -  matches a character with the given class</li></ul><p>The recognized classes are:</p><ul><li><strong>AL</strong> -  Arabic letter</li><li><strong>AN</strong> -  Arabic number</li><li><strong>B</strong> -  paragraph separator</li><li><strong>BN</strong> -  boundary neutral</li><li><strong>CS</strong> -  common separator</li><li><strong>EN</strong> -  European number</li><li><strong>ES</strong> -  European separator</li><li><strong>ET</strong> -  European terminator</li><li><strong>FSI</strong> -  first strong isolate</li><li><strong>L</strong> -  left-to-right</li><li><strong>LRE</strong> -  left-to-right embedding</li><li><strong>LRI</strong> -  left-to-right isolate</li><li><strong>LRO</strong> -  left-to-right override</li><li><strong>NSM</strong> -  non-spacing mark</li><li><strong>ON</strong> -  other neutral</li><li><strong>PDF</strong> -  pop directional format</li><li><strong>PDI</strong> -  pop directional isolate</li><li><strong>R</strong> -  right-to-left</li><li><strong>RLE</strong> -  right-to-left embedding</li><li><strong>RLI</strong> -  right-to-left isolate</li><li><strong>RLO</strong> -  right-to-left override</li><li><strong>S</strong> -  segment separator</li><li><strong>WS</strong> -  white space</li></ul><p>As in all property specifications, an equals sign may be used instead of a
colon and the class names are case-insensitive. Only the short names listed
above are recognized; PCRE2 does not at present support any long alternatives.</p><p><em>Extended Grapheme Clusters</em></p><p>The <code class="inline">\X</code> escape matches any number of Unicode characters that form an &quot;extended
grapheme cluster&quot;, and treats the sequence as an atomic group
(see below).
Unicode supports various kinds of composite character by giving each character
a grapheme breaking property, and having rules that use these properties to
define the boundaries of extended grapheme clusters. The rules are defined in
Unicode Standard Annex 29, &quot;Unicode Text Segmentation&quot;. Unicode 11.0.0
abandoned the use of some previous properties that had been used for emojis.
Instead it introduced various emoji-specific properties. PCRE2 uses only the
Extended Pictographic property.</p><p><code class="inline">\X</code> always matches at least one character. Then it decides whether to add
additional characters according to the following rules for ending a cluster:</p><ol><li><p>End at the end of the subject string.</p></li><li><p>Do not end between CR and LF; otherwise end after any control character.</p></li><li><p>Do not break Hangul (a Korean script) syllable sequences. Hangul characters
are of five types: L, V, T, LV, and LVT. An L character may be followed by an
L, V, LV, or LVT character; an LV or V character may be followed by a V or T
character; an LVT or T character may be followed only by a T character.</p></li><li><p>Do not end before extending characters or spacing marks or the zero-width
joiner (ZWJ) character. Characters with the &quot;mark&quot; property always have the
&quot;extend&quot; grapheme breaking property.</p></li><li><p>Do not end after prepend characters.</p></li><li><p>Do not end within emoji modifier sequences or emoji ZWJ (zero-width
joiner) sequences. An emoji ZWJ sequence consists of a character with the
Extended_Pictographic property, optionally followed by one or more characters
with the Extend property, followed by the ZWJ character, followed by another
Extended_Pictographic character.</p></li><li><p>Do not break within emoji flag sequences. That is, do not break between
regional indicator (RI) characters if there are an odd number of RI characters
before the break point.</p></li><li><p>Otherwise, end the cluster.</p></li></ol><p><em>PCRE2's Additional Properties</em></p><p>As well as the standard Unicode properties described above, PCRE2 supports four
more that make it possible to convert traditional escape sequences such as <code class="inline">\w</code>
and <code class="inline">\s</code> to use Unicode properties. PCRE2 uses these non-standard, non-Perl
properties internally when <code class="inline">ucp</code> is set. However, they may also be used
explicitly. These properties are:</p><ul><li><strong>Xan</strong> -  Any alphanumeric character</li><li><strong>Xps</strong> -  Any POSIX space character</li><li><strong>Xsp</strong> -  Any Perl space character</li><li><strong>Xwd</strong> -  Any Perl &quot;word&quot; character</li></ul><p>Xan matches characters that have either the L (letter) or the N (number)
property. Xps matches the characters tab, linefeed, vertical tab, form feed, or
carriage return, and any other character that has the Z (separator) property
(this includes the space character). Xsp is the same as Xps; in PCRE1 it used
to exclude vertical tab, for Perl compatibility, but Perl changed. Xwd matches
the same characters as Xan, plus those that match Mn (non-spacing mark) or Pc
(connector punctuation, which includes underscore).</p><p>There is another non-standard property, Xuc, which matches any character that
can be represented by a Universal Character Name in C++ and other programming
languages. These are the characters $, @, ` (grave accent), and all characters
with Unicode code points greater than or equal to U+00A0, except for the
surrogates U+D800 to U+DFFF. Note that most base (ASCII) characters are
excluded. (Universal Character Names are of the form <code class="inline">\uHHHH</code> or <code class="inline">\UHHHHHHH</code>H
where H is a hexadecimal digit. Note that the Xuc property does not match these
sequences but the characters that they represent.)</p><p><em>Resetting the Match Start</em></p><p>In normal use, the escape sequence <code class="inline">\K</code> causes any previously matched characters
not to be included in the final matched sequence that is returned. For example,
the pattern:</p><pre><code class="text">foo\Kbar</code></pre><p>matches &quot;foobar&quot;, but reports that it has matched &quot;bar&quot;. <code class="inline">\K</code> does not interact
with anchoring in any way. The pattern:</p><pre><code class="text">^foo\Kbar</code></pre><p>matches only when the subject begins with &quot;foobar&quot; (in single line mode),
though it again reports the matched string as &quot;bar&quot;. This feature is similar to
a lookbehind assertion
(described below),
but the part of the pattern that precedes <code class="inline">\K</code> is not constrained to match a
limited number of characters, as is required for a lookbehind assertion. The
use of <code class="inline">\K</code> does not interfere with the setting of
captured substrings.
For example, when the pattern</p><pre><code class="text">(foo)\Kbar</code></pre><p>matches &quot;foobar&quot;, the first substring is still set to &quot;foo&quot;.</p><p>From version 5.32.0 Perl forbids the use of <code class="inline">\K</code> in lookaround assertions. From
release 10.38 PCRE2 also forbids this by default.</p><p><em>Simple Assertions</em></p><p>The final use of backslash is for certain simple assertions. An assertion
specifies a condition that has to be met at a particular point in a match,
without consuming any characters from the subject string. The use of
groups for more complicated assertions is described
below.
The backslashed assertions are:</p><ul><li><strong><code class="inline">\b</code></strong> -  matches at a word boundary</li><li><strong><code class="inline">\B</code></strong> -  matches when not at a word boundary</li><li><strong><code class="inline">\A</code></strong> -  matches at the start of the subject</li><li><strong><code class="inline">\Z</code></strong> -  matches at the end of the subject
also matches before a newline at the end of the subject</li><li><strong><code class="inline">\z</code></strong> -  matches only at the end of the subject</li><li><strong><code class="inline">\G</code></strong> -  matches at the first matching position in the subject</li></ul><p>Inside a character class, <code class="inline">\b</code> has a different meaning; it matches the backspace
character. If any other of these assertions appears in a character class, an
&quot;invalid escape sequence&quot; error is generated.</p><p>A word boundary is a position in the subject string where the current character
and the previous character do not both match <code class="inline">\w</code> or <code class="inline">\W</code> (i.e. one matches
<code class="inline">\w</code> and the other matches <code class="inline">\W</code>), or the start or end of the string if the
first or last character matches <code class="inline">\w</code>, respectively. When PCRE2 is built with
Unicode support, the meanings of <code class="inline">\w</code> and <code class="inline">\W</code> can be changed by setting the
<code class="inline">ucp</code> option. When this is done, it also affects <code class="inline">\b</code> and <code class="inline">\B</code>. Neither PCRE2
nor Perl has a separate &quot;start of word&quot; or &quot;end of word&quot; metasequence. However,
whatever follows <code class="inline">\b</code> normally determines which it is. For example, the fragment
<code class="inline">\ba</code> matches &quot;a&quot; at the start of a word.</p><p>The <code class="inline">\A</code>, <code class="inline">\Z</code>, and <code class="inline">\z</code> assertions differ from the traditional circumflex and
dollar (described in the next section) in that they only ever match at the very
start and end of the subject string, whatever options are set. Thus, they are
independent of multiline mode. These three assertions are not affected by the
<code class="inline">notbol</code> or <code class="inline">noteol</code> options, which affect only the behaviour of the
circumflex and dollar metacharacters. However, if the <em>startoffset</em>
argument of <a href="#run/3"><code class="inline">run/3</code></a> is non-zero, indicating that matching is to
start at a point other than the beginning of the subject, <code class="inline">\A</code> can never match.
The difference between <code class="inline">\Z</code> and <code class="inline">\z</code> is that <code class="inline">\Z</code> matches before a newline at the
end of the string as well as at the very end, whereas <code class="inline">\z</code> matches only at the
end.</p><p>The <code class="inline">\G</code> assertion is true only when the current matching position is at the
start point of the matching process, as specified by the <em>startoffset</em>
argument of <a href="#run/3"><code class="inline">run/3</code></a>. It differs from <code class="inline">\A</code> when the value of
<em>startoffset</em> is non-zero. By calling <a href="#run/3"><code class="inline">run/3</code></a> multiple times
with appropriate arguments, you can mimic Perl's /g option, and it is in this
kind of implementation where <code class="inline">\G</code> can be useful.</p><p>Note, however, that PCRE2's implementation of <code class="inline">\G</code>, being true at the starting
character of the matching process, is subtly different from Perl's, which
defines it as true at the end of the previous match. In Perl, these can be
different when the previously matched string was empty. Because PCRE2 does just
one match at a time, it cannot reproduce this behaviour.</p><p>If all the alternatives of a pattern begin with <code class="inline">\G</code>, the expression is anchored
to the starting match position, and the &quot;anchored&quot; flag is set in the compiled
regular expression.</p><p><a href="" id="sect4"></a></p><h2 id="module-circumflex-and-dollar" class="section-heading"><a href="#module-circumflex-and-dollar" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Circumflex and Dollar</span></h2><p>The circumflex and dollar metacharacters are zero-width assertions. That is,
they test for a particular condition being true without consuming any
characters from the subject string. These two metacharacters are concerned with
matching the starts and ends of lines. If the newline convention is set so that
only the two-character sequence CRLF is recognized as a newline, isolated CR
and LF characters are treated as ordinary data characters, and are not
recognized as newlines.</p><p>Outside a character class, in the default matching mode, the circumflex
character is an assertion that is true only if the current matching point is at
the start of the subject string. If the <em>startoffset</em> argument of
<a href="#run/3"><code class="inline">run/3</code></a> is non-zero, or if <code class="inline">notbol</code> is set, circumflex can
never match if the <code class="inline">multiline</code> option is unset. Inside a character class,
circumflex has an entirely different meaning
(see below).</p><p>Circumflex need not be the first character of the pattern if a number of
alternatives are involved, but it should be the first thing in each alternative
in which it appears if the pattern is ever to match that branch. If all
possible alternatives start with a circumflex, that is, if the pattern is
constrained to match only at the start of the subject, it is said to be an
&quot;anchored&quot; pattern. (There are also other constructs that can cause a pattern
to be anchored.)</p><p>The dollar character is an assertion that is true only if the current matching
point is at the end of the subject string, or immediately before a newline at
the end of the string (by default), unless <code class="inline">noteol</code> is set. Note, however,
that it does not actually match the newline. Dollar need not be the last
character of the pattern if a number of alternatives are involved, but it
should be the last item in any branch in which it appears. Dollar has no
special meaning in a character class.</p><p>The meaning of dollar can be changed so that it matches only at the very end of
the string, by setting the <code class="inline">dollar_endonly</code> option at compile time. This
does not affect the <code class="inline">\Z</code> assertion.</p><p>The meanings of the circumflex and dollar metacharacters are changed if the
<code class="inline">multiline</code> option is set. When this is the case, a dollar character
matches before any newlines in the string, as well as at the very end, and a
circumflex matches immediately after internal newlines as well as at the start
of the subject string. It does not match after a newline that ends the string,
for compatibility with Perl.</p><p>For example, the pattern /^abc$/ matches the subject string &quot;def\nabc&quot; (where
<code class="inline">\n</code> represents a newline) in multiline mode, but not otherwise. Consequently,
patterns that are anchored in single line mode because all branches start with
^ are not anchored in multiline mode, and a match for circumflex is possible
when the <em>startoffset</em> argument of <a href="#run/3"><code class="inline">run/3</code></a> is non-zero. The
<code class="inline">dollar_endonly</code> option is ignored if <code class="inline">multiline</code> is set.</p><p>When the <a href="re.html#sect1.1">Newline Conventions</a> recognizes the two-character sequence CRLF as a newline, this is
preferred, even if the single characters CR and LF are also recognized as
newlines. For example, if the newline convention is &quot;any&quot;, a multiline mode
circumflex matches before &quot;xyz&quot; in the string &quot;abc\r\nxyz&quot; rather than after
CR, even though CR on its own is a valid newline. (It also matches at the very
start of the string, of course.)</p><p>Note that the sequences <code class="inline">\A</code>, <code class="inline">\Z</code>, and <code class="inline">\z</code> can be used to match the start and
end of the subject in both modes, and if all branches of a pattern start with
<code class="inline">\A</code> it is always anchored, whether or not <code class="inline">multiline</code> is set.</p><p><a href="" id="sect5"></a></p><h2 id="module-full-stop-period-dot-and-n" class="section-heading"><a href="#module-full-stop-period-dot-and-n" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Full Stop (Period, Dot) and \N</span></h2><p>Outside a character class, a dot in the pattern matches any one character in
the subject string except (by default) a character that signifies the end of a
line. One or more characters may be specified as line terminators (see
<a href="re.html#sect1.1">Newline Conventions</a>).</p><p>Dot never matches a single line-ending character. When the two-character
sequence CRLF is the only line ending, dot does not match CR if it is
immediately followed by LF, but otherwise it matches all characters (including
isolated CRs and LFs). When ANYCRLF is selected for line endings, no occurrences
of CR of LF match dot. When all Unicode line endings are being recognized, dot
does not match CR or LF or any of the other line ending characters.</p><p>The behaviour of dot with regard to newlines can be changed. If the
<code class="inline">dotall</code> option is set, a dot matches any one character, without exception.
If the two-character sequence CRLF is present in the subject string, it takes
two dots to match it.</p><p>The handling of dot is entirely independent of the handling of circumflex and
dollar, the only relationship being that they both involve newlines. Dot has no
special meaning in a character class.</p><p>The escape sequence <code class="inline">\N</code> when not followed by an opening brace behaves like a
dot, except that it is not affected by the <code class="inline">dotall</code> option. In other words,
it matches any character except one that signifies the end of a line.</p><p>When <code class="inline">\N</code> is followed by an opening brace it has a different meaning. See <a href="re.html#sect3.1">Non-Printing Characters</a>.
Perl also uses <code class="inline">\N{name}</code> to specify characters by Unicode
name; PCRE2 does not support this.</p><p><a href="" id="sect6"></a></p><h2 id="module-matching-a-single-code-unit" class="section-heading"><a href="#module-matching-a-single-code-unit" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Matching a Single Code Unit</span></h2><p>Outside a character class, the escape sequence <code class="inline">\C</code> matches any one code unit,
whether or not a UTF mode is set. In the 8-bit library, one code unit is one
byte. Unlike a dot, <code class="inline">\C</code> always matches line-ending characters. The
feature is provided in Perl in order to match individual bytes in UTF-8 mode,
but it is unclear how it can usefully be used.</p><p>Because <code class="inline">\C</code> breaks up characters into individual code units, matching one unit
with <code class="inline">\C</code> in UTF-8 mode means that the rest of the string may start
with a malformed UTF character. This has undefined results, because PCRE2
assumes that it is matching character by character in a valid UTF string (by
default it checks the subject string's validity at the start of processing).</p><p>PCRE2 does not allow <code class="inline">\C</code> to appear in lookbehind assertions
(described below)
in UTF-8 mode, because this would make it impossible to calculate
the length of the lookbehind.</p><p>In general, the <code class="inline">\C</code> escape sequence is best avoided. However, one way of using
it that avoids the problem of malformed UTF-8 characters is to use a
lookahead to check the length of the next character, as in this pattern, which
could be used with a UTF-8 string (ignore white space and line breaks):</p><pre><code class="text">(?| (?=[\x00-\x7f])(\C) |
      (?=[\x80-\x{7ff}])(\C)(\C) |
      (?=[\x{800}-\x{ffff}])(\C)(\C)(\C) |
      (?=[\x{10000}-\x{1fffff}])(\C)(\C)(\C)(\C))</code></pre><p>In this example, a group that starts with <code class="inline">(?|</code> resets the capturing parentheses
numbers in each alternative (see
<a href="re.html#sect12">Duplicate Group Numbers</a>).
The assertions at the start of each branch check the next UTF-8
character for values whose encoding uses 1, 2, 3, or 4 bytes, respectively. The
character's individual bytes are then captured by the appropriate number of
<code class="inline">\C</code> groups.</p><p><a href="" id="sect7"></a></p><h2 id="module-square-brackets-and-character-classes" class="section-heading"><a href="#module-square-brackets-and-character-classes" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Square Brackets and Character Classes</span></h2><p>An opening square bracket introduces a character class, terminated by a closing
square bracket. A closing square bracket on its own is not special by default.
If a closing square bracket is required as a member of the class, it should be
the first data character in the class (after an initial circumflex, if present)
or escaped with a backslash. This means that, by default, an empty class cannot
be defined.</p><p>A character class matches a single character in the subject. A matched
character must be in the set of characters defined by the class, unless the
first character in the class definition is a circumflex, in which case the
subject character must not be in the set defined by the class. If a circumflex
is actually required as a member of the class, ensure it is not the first
character, or escape it with a backslash.</p><p>For example, the character class [aeiou] matches any lower case English vowel,
whereas [^aeiou] matches all other characters. Note that a circumflex is just a
convenient notation for specifying the characters that are in the class by
enumerating those that are not. A class that starts with a circumflex is not an
assertion; it still consumes a character from the subject string, and therefore
it fails to match if the current pointer is at the end of the string.</p><p>Characters in a class may be specified by their code points using <code class="inline">\o</code>, <code class="inline">\x</code>, or
<code class="inline">\N{U+hh..}</code> in the usual way. When caseless matching is set, any letters in a
class represent both their upper case and lower case versions, so for example,
a caseless [aeiou] matches &quot;A&quot; as well as &quot;a&quot;, and a caseless [^aeiou] does not
match &quot;A&quot;, whereas a caseful version would. Note that there are two ASCII
characters, K and S, that, in addition to their lower case ASCII equivalents,
are case-equivalent with Unicode U+212A (Kelvin sign) and U+017F (long S)
respectively when either <code class="inline">unicode</code> or <code class="inline">ucp</code> is set.</p><p>Characters that might indicate line breaks are never treated in any special way
when matching character classes, whatever line-ending sequence is in use, and
whatever setting of the <code class="inline">dotall</code> and <code class="inline">multiline</code> options is used. A
class such as [^a] always matches one of these characters.</p><p>The generic character type escape sequences <code class="inline">\d</code>, <code class="inline">\D</code>, <code class="inline">\h</code>, <code class="inline">\H</code>, <code class="inline">\p</code>, <code class="inline">\P</code>, <code class="inline">\s</code>,
<code class="inline">\S</code>, <code class="inline">\v</code>, <code class="inline">\V</code>, <code class="inline">\w</code>, and <code class="inline">\W</code> may appear in a character class, and add the
characters that they match to the class. For example, [<code class="inline">\dABCDEF]</code> matches any
hexadecimal digit. In UTF modes, the <code class="inline">ucp</code> option affects the meanings of
<code class="inline">\d</code>, <code class="inline">\s</code>, <code class="inline">\w</code> and their upper case partners, just as it does when they appear
outside a character class, as described in
<a href="re.html#sect3.2">Generic character types</a>.
The escape sequence <code class="inline">\b</code> has a different meaning inside a character
class; it matches the backspace character. The sequences <code class="inline">\B</code>, <code class="inline">\R</code>, and <code class="inline">\X</code> are
not special inside a character class. Like any other unrecognized escape
sequences, they cause an error. The same is true for <code class="inline">\N</code> when not followed by
an opening brace.</p><p>The minus (hyphen) character can be used to specify a range of characters in a
character class. For example, [d-m] matches any letter between d and m,
inclusive. If a minus character is required in a class, it must be escaped with
a backslash or appear in a position where it cannot be interpreted as
indicating a range, typically as the first or last character in the class,
or immediately after a range. For example, [b-d-z] matches letters in the range
b to d, a hyphen character, or z.</p><p>Perl treats a hyphen as a literal if it appears before or after a POSIX class
(see below) or before or after a character type escape such as <code class="inline">\d</code> or <code class="inline">\H</code>.
However, unless the hyphen is the last character in the class, Perl outputs a
warning in its warning mode, as this is most likely a user error. As PCRE2 has
no facility for warning, an error is given in these cases.</p><p>It is not possible to have the literal character &quot;]&quot; as the end character of a
range. A pattern such as <code class="inline">[W-]46]</code> is interpreted as a class of two characters
(&quot;W&quot; and &quot;-&quot;) followed by a literal string &quot;46]&quot;, so it would match &quot;W46]&quot; or
&quot;-46]&quot;. However, if the &quot;]&quot; is escaped with a backslash it is interpreted as
the end of a range, so <code class="inline">[W-\]46]</code> is interpreted as a class containing a range
and two other characters. The octal or hexadecimal representation of
&quot;]&quot; can also be used to end a range.</p><p>Ranges normally include all code points between the start and end characters,
inclusive. They can also be used for code points specified numerically, for
example <code class="inline">[\000-\037]</code>. Ranges can include any characters that are valid for the
current mode. In any UTF mode, the so-called &quot;surrogate&quot; characters (those
whose code points lie between 0xd800 and 0xdfff inclusive) may not be specified
explicitly by default. However, ranges such as <code class="inline">[\x{d7ff}-\x{e000}]</code>, which include the
surrogates, are always permitted.</p><p>If a range that includes letters is used when caseless matching is set, it
matches the letters in either case. For example, <code class="inline">[W-c]</code> is equivalent to
<code class="inline">[][\^_`wxyzabc]</code>, matched caselessly, and in a non-UTF mode, if character
tables for a French locale are in use, <code class="inline">[\xc8-\xcb]</code> matches accented E
characters in both cases.</p><p>A circumflex can conveniently be used with the upper case character types to
specify a more restricted set of characters than the matching lower case type.
For example, the class <code class="inline">[^\W_]</code> matches any letter or digit, but not underscore,
whereas <code class="inline">[\w]</code> includes underscore. A positive character class should be read as
&quot;something OR something OR ...&quot; and a negative class as &quot;NOT something AND NOT
something AND NOT ...&quot;.</p><p>The metacharacters that are recognized in character classes are backslash,
hyphen (when it can be interpreted as specifying a range), circumflex
(only at the start), and the terminating closing square bracket. An opening
square bracket is also special when it can be interpreted as introducing a
POSIX class (see &quot;Posix character classes&quot; below), or a special compatibility feature (see
Compatibility feature for word boundaries&quot; below).
Escaping any non-alphanumeric character in a class turns it into a
literal, whether or not it would otherwise be a metacharacter.</p><p><a href="" id="sect7X"></a></p><h2 id="module-perl-extended-character-classes" class="section-heading"><a href="#module-perl-extended-character-classes" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Perl Extended Character Classes</span></h2><p>From release 10.45 PCRE2 supports Perl's <code class="inline">(?[...])</code> extended character class
syntax. This can be used to perform set operations such as intersection on
character classes.</p><p>The syntax permitted within <code class="inline">(?[...])</code> is quite different to ordinary character
classes. Inside the extended class, there is an expression syntax consisting of
&quot;atoms&quot;, operators, and ordinary parentheses &quot;()&quot; used for grouping. Such
classes always have the Perl /xx modifier (PCRE2 option PCRE2_EXTENDED_MORE)
turned on within them. This means that literal space and tab characters are
ignored everywhere in the class.</p><p>The allowed atoms are individual characters specified by escape sequences such
as <code class="inline">\n</code> or <code class="inline">\x{123}</code>, character types such as <code class="inline">\d</code>, POSIX classes such as
<code class="inline">[:alpha:]</code>, and nested ordinary (non-extended) character classes. For example,
in <code class="inline">(?[\d &amp; [...]])</code> the nested class <code class="inline">[...]</code> follows the usual rules for ordinary
character classes, in which parentheses are not metacharacters, and character
literals and ranges are permitted.</p><p>Character literals and ranges may not appear outside a nested ordinary
character class because they are not atoms in the extended syntax. The extended
syntax does not introduce any additional escape sequences, so <code class="inline">(?[\y])</code> is an
unknown escape, as it would be in <code class="inline">[\y]</code>.</p><p>In the extended syntax, ^ does not negate a class (except within an
ordinary class nested inside an extended class); it is instead a binary
operator.</p><p>The binary operators are &quot;&amp;&quot; (intersection), &quot;|&quot; or &quot;+&quot; (union), &quot;-&quot;
(subtraction) and &quot;^&quot; (symmetric difference). These are left-associative and
&quot;&amp;&quot; has higher (tighter) precedence, while the others have equal lower
precedence. The one prefix unary operator is &quot;!&quot; (complement), with highest
precedence.</p><p><a href="" id="sect8"></a></p><h2 id="module-posix-character-classes" class="section-heading"><a href="#module-posix-character-classes" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Posix Character Classes</span></h2><p>Perl supports the POSIX notation for character classes. This uses names
enclosed by <code class="inline">[:</code> and <code class="inline">:]</code> within the enclosing square brackets. PCRE2 also supports
this notation. in both ordinary and extended classes. For example,</p><pre><code class="text">[01[:alpha:]%]</code></pre><p>matches &quot;0&quot;, &quot;1&quot;, any alphabetic character, or &quot;%&quot;. The supported class names
are:</p><ul><li><strong>alnum</strong> -  letters and digits</li><li><strong>alpha</strong> -  letters</li><li><strong>ascii</strong> -  character codes 0-127</li><li><strong>blank</strong> -  space or tab only</li><li><strong>cntrl</strong> -  control characters</li><li><strong>digit</strong> -  decimal digits (same as <code class="inline">\d</code>)</li><li><strong>graph</strong> -  printing characters, excluding space</li><li><strong>lower</strong> -  lower case letters</li><li><strong>print</strong> -  printing characters, including space</li><li><strong>punct</strong> -  printing characters, excluding letters and digits and space</li><li><strong>space</strong> -  white space (the same as <code class="inline">\s</code> from PCRE2 8.34)</li><li><strong>upper</strong> -  upper case letters</li><li><strong>word</strong> -  &quot;word&quot; characters (same as <code class="inline">\w</code>)</li><li><strong>xdigit</strong> -  hexadecimal digits</li></ul><p>The default &quot;space&quot; characters are HT (9), LF (10), VT (11), FF (12), CR (13),
and space (32). If locale-specific matching is taking place, the list of space
characters may be different; there may be fewer or more of them. &quot;Space&quot; and
<code class="inline">\s</code> match the same set of characters, as do &quot;word&quot; and <code class="inline">\w</code>.</p><p>The name &quot;word&quot; is a Perl extension, and &quot;blank&quot; is a GNU extension from Perl
5.8. Another Perl extension is negation, which is indicated by a <code class="inline">^</code>  character
after the colon. For example,</p><pre><code class="text">[12[:^digit:]]</code></pre><p>matches &quot;1&quot;, &quot;2&quot;, or any non-digit. PCRE2 (and Perl) also recognize the POSIX
syntax <code class="inline">[.ch.]</code> and <code class="inline">[=ch=]</code> where &quot;ch&quot; is a &quot;collating element&quot;, but these are not
supported, and an error is given if they are encountered.</p><p>By default, characters with values greater than 127 do not match any of the
POSIX character classes, although this may be different for characters in the
range 128-255 when locale-specific matching is happening. However, in UCP mode,
unless certain options are set (see below), some of the classes are changed so
that Unicode character properties are used. This is achieved by replacing
POSIX classes with other sequences, as follows:</p><ul><li><p><strong><code class="inline">[:alnum:]</code></strong> - Becomes <em><code class="inline">\p{Xan}</code></em></p></li><li><p><strong><code class="inline">[:alpha:]</code></strong> - Becomes <em><code class="inline">\p{L}</code></em></p></li><li><p><strong><code class="inline">[:blank:]</code></strong> - Becomes <em><code class="inline">\h</code></em></p></li><li><p><strong><code class="inline">[:cntrl:]</code></strong> - Becomes  \p{Cc}</p></li><li><p><strong><code class="inline">[:digit:]</code></strong> - Becomes <em><code class="inline">\p{Nd}</code></em></p></li><li><p><strong><code class="inline">[:lower:]</code></strong> - Becomes <em><code class="inline">\p{Ll}</code></em></p></li><li><p><strong><code class="inline">[:space:]</code></strong> - Becomes <em><code class="inline">\p{Xps}</code></em></p></li><li><p><strong><code class="inline">[:upper:]</code></strong> - Becomes <em><code class="inline">\p{Lu}</code></em></p></li><li><p><strong><code class="inline">[:word:]</code></strong> - Becomes <em><code class="inline">\p{Xwd}</code></em></p></li></ul><p>Negated versions, such as <code class="inline">[:^alpha:]</code>, use <code class="inline">\P</code> instead of <code class="inline">\p</code>. Four other POSIX
classes are handled specially in UCP mode:</p><ul><li><p><strong><code class="inline">[:graph:]</code></strong> - This matches characters that have glyphs that mark the page
when printed. In Unicode property terms, it matches all characters with the L,
M, N, P, S, or Cf properties, except for:</p><ul><li><p><strong>U+061C</strong> - Arabic Letter Mark</p></li><li><p><strong>U+180E</strong> - Mongolian Vowel Separator</p></li><li><p><strong>U+2066 - U+2069</strong> - Various &quot;isolate&quot;s</p></li></ul></li><li><p><strong><code class="inline">[:print:]</code></strong> - This matches the same characters as <code class="inline">[:graph:]</code> plus space
characters that are not controls, that is, characters with the Zs property.</p></li><li><p><strong><code class="inline">[:punct:]</code></strong> - This matches all characters that have the Unicode P (punctuation) property,
plus those characters with code points less than 256 that have the S (Symbol)
property.</p></li><li><p><strong><code class="inline">[:xdigit:]</code></strong> - In addition to the ASCII hexadecimal digits, this also matches the &quot;fullwidth&quot;</p></li></ul><p>versions of those characters, whose Unicode code points start at U+FF10. This
is a change that was made in PCRE2 release 10.43 for Perl compatibility.</p><p>The other POSIX classes are unchanged by <code class="inline">ucp</code>, and match only characters
with code points less than 256.</p><p>There are two options that can be used to restrict the POSIX classes to ASCII
characters when <code class="inline">ucp</code> is set. The option PCRE2_EXTRA_ASCII_DIGIT affects
just <code class="inline">[:digit:]</code> and <code class="inline">[:xdigit:]</code>. Within a pattern, this can be set and unset by
<code class="inline">(?aT)</code> and <code class="inline">(?-aT)</code>. The PCRE2_EXTRA_ASCII_POSIX option disables UCP processing
for all POSIX classes, including <code class="inline">[:digit:]</code> and <code class="inline">[:xdigit:]</code>. Within a pattern,
<code class="inline">(?aP)</code> and <code class="inline">(?-aP)</code> set and unset both these options for consistency.</p><p><em>Compatibility Feature for Word Boundaries</em></p><p>In the POSIX.2 compliant library that was included in 4.4BSD Unix, the ugly
syntax <code class="inline">[[:&lt;:]]</code> and <code class="inline">[[:&gt;:]]</code> is used for matching &quot;start of word&quot; and &quot;end of
word&quot;. PCRE2 treats these items as follows:</p><pre><code class="text">[[:&lt;:]]  is converted to  \b(?=\w)
[[:&gt;:]]  is converted to  \b(?&lt;=\w)</code></pre><p>Only these exact character sequences are recognized. A sequence such as
[a[:&lt;:]b] provokes error for an unrecognized POSIX class name. This support is
not compatible with Perl. It is provided to help migrations from other
environments, and is best not used in any new patterns. Note that <code class="inline">\b</code> matches
at the start and the end of a word (see
&quot;Simple assertions&quot;
above), and in a Perl-style pattern the preceding or following character
normally shows which is wanted, without the need for the assertions that are
used above in order to give exactly the POSIX behaviour. Note also that the
<code class="inline">ucp</code> option changes the meaning of <code class="inline">\w</code> (and therefore <code class="inline">\b)</code> by default, so
it also affects these POSIX sequences.</p><p><a href="" id="sect9"></a></p><h2 id="module-vertical-bar" class="section-heading"><a href="#module-vertical-bar" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Vertical Bar</span></h2><p>Vertical bar characters are used to separate alternative patterns. For example,
the pattern</p><pre><code class="text">gilbert|sullivan</code></pre><p>matches either &quot;gilbert&quot; or &quot;sullivan&quot;. Any number of alternatives may appear,
and an empty alternative is permitted (matching the empty string). The matching
process tries each alternative in turn, from left to right, and the first one
that succeeds is used. If the alternatives are within a group (defined below),
&quot;succeeds&quot; means matching the rest of the main pattern as well as the
alternative in the group.</p><p><a href="" id="sect10"></a></p><h2 id="module-internal-option-setting" class="section-heading"><a href="#module-internal-option-setting" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Internal Option Setting</span></h2><p>The settings of several options can be changed within a pattern by a sequence
of letters enclosed between &quot;(?&quot; and &quot;)&quot;. The option letters are:</p><pre><code class="text">i  for `caseless`
m  for `multiline`
n  for PCRE2_NO_AUTO_CAPTURE
s  for `dotall`
x  for `extended`
xx for PCRE2_EXTENDED_MORE</code></pre><p>For example, (?im) sets caseless, multiline matching. It is also possible to
unset these options by preceding the relevant letters with a hyphen, for
example (?-im). The two &quot;extended&quot; options are not independent; unsetting
either one cancels the effects of both of them.</p><p>A combined setting and unsetting such as (?im-sx), which sets <code class="inline">caseless</code>
and <code class="inline">multiline</code> while unsetting <code class="inline">dotall</code> and <code class="inline">extended</code>, is also
permitted. Only one hyphen may appear in the options string. If a letter
appears both before and after the hyphen, the option is unset. An empty options
setting &quot;(?)&quot; is allowed. Needless to say, it has no effect.</p><p>If the first character following <code class="inline">(?</code> is a circumflex, it causes all of the above
options to be unset. Letters may follow the circumflex to cause some options to
be re-instated, but a hyphen may not appear.</p><p>Some PCRE2-specific options can be changed by the same mechanism using these
pairs or individual letters:</p><pre><code class="text">aD for PCRE2_EXTRA_ASCII_BSD
aS for PCRE2_EXTRA_ASCII_BSS
aW for PCRE2_EXTRA_ASCII_BSW
aP for PCRE2_EXTRA_ASCII_POSIX and PCRE2_EXTRA_ASCII_DIGIT
aT for PCRE2_EXTRA_ASCII_DIGIT
r  for PCRE2_EXTRA_CASELESS_RESTRICT
J  for `dupnames`
U  for `ungreedy`</code></pre><p>However, except for 'r', these are not unset by <code class="inline">(?^)</code>, which is equivalent to
<code class="inline">(?-imnrsx)</code>. If 'a' is not followed by any of the upper case letters shown
above, it sets (or unsets) all the ASCII options.</p><p>PCRE2_EXTRA_ASCII_DIGIT has no additional effect when PCRE2_EXTRA_ASCII_POSIX
is set, but including it in <code class="inline">(?aP)</code> means that <code class="inline">(?-aP)</code> suppresses all ASCII
restrictions for POSIX classes.</p><p>When one of these option changes occurs at top level (that is, not inside group
parentheses), the change applies until a subsequent change, or the end of the
pattern. An option change within a <a href="re.html#sect11">groups</a> affects only that part of the group that follows it. At the end of the
group these options are reset to the state they were before the group. For
example,</p><pre><code class="text">(a(?i)b)c</code></pre><p>matches abc and aBc and no other strings (assuming <code class="inline">caseless</code> is not set
externally). Any changes made in one alternative do carry on into subsequent
branches within the same group. For example,</p><pre><code class="text">(a(?i)b|c)</code></pre><p>matches &quot;ab&quot;, &quot;aB&quot;, &quot;c&quot;, and &quot;C&quot;, even though when matching &quot;C&quot; the first
branch is abandoned before the option setting. This is because the effects of
option settings happen at compile time. There would be some very weird
behaviour otherwise.</p><p>As a convenient shorthand, if any option settings are required at the start of
a non-capturing group (see the next section), the option letters may
appear between the &quot;?&quot; and the &quot;:&quot;. Thus the two patterns</p><pre><code class="text">(?i:saturday|sunday)
(?:(?i)saturday|sunday)</code></pre><p>match exactly the same set of strings.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>There are other PCRE2-specific options, applying to the whole
pattern, which can be set by the application when the compiling function is
called. In addition, the pattern can contain special leading sequences such as
<code class="inline">(*CRLF)</code> to override what the application has set or what has been defaulted.
Details are given in <a href="re.html#sect3.3">Newline Sequences</a>.
There are also the <code class="inline">(*UTF)</code> and <code class="inline">(*UCP)</code> leading sequences that can be used
to set UTF and Unicode property modes; they are equivalent to setting the
<code class="inline">unicode</code> and <code class="inline">ucp</code> options, respectively. However, the application can set
the <code class="inline">never_utf</code> or <code class="inline">never_ucp</code> options, which lock out the use of the
<code class="inline">(*UTF)</code> and <code class="inline">(*UCP)</code> sequences.</p></section><p><a href="" id="sect11"></a></p><h2 id="module-groups" class="section-heading"><a href="#module-groups" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Groups</span></h2><p>Groups are delimited by parentheses (round brackets), which can be nested.
Turning part of a pattern into a group does two things:</p><ol><li>It localizes a set of alternatives. For example, the pattern</li></ol><pre><code class="text">cat(aract|erpillar|)</code></pre><p>matches &quot;cataract&quot;, &quot;caterpillar&quot;, or &quot;cat&quot;. Without the parentheses, it would
match &quot;cataract&quot;, &quot;erpillar&quot; or an empty string.</p><ol start="2"><li>It creates a &quot;capture group&quot;. This means that, when the whole pattern
matches, the portion of the subject string that matched the group is passed
back to the caller, separately from the portion that matched the whole pattern.</li></ol><p>Opening parentheses are counted from left to right (starting from 1) to obtain
numbers for capture groups. For example, if the string &quot;the red king&quot; is
matched against the pattern</p><pre><code class="text">the ((red|white) (king|queen))</code></pre><p>the captured substrings are &quot;red king&quot;, &quot;red&quot;, and &quot;king&quot;, and are numbered 1,
2, and 3, respectively.</p><p>The fact that plain parentheses fulfil two functions is not always helpful.
There are often times when grouping is required without capturing. If an
opening parenthesis is followed by a question mark and a colon, the group
does not do any capturing, and is not counted when computing the number of any
subsequent capture groups. For example, if the string &quot;the white queen&quot;
is matched against the pattern the <code class="inline">((?:red|white) (king|queen))</code>
the captured substrings are &quot;white queen&quot; and &quot;queen&quot;, and are numbered 1 and</p><ol start="2"><li>The maximum number of capture groups is 65535.</li></ol><p>As a convenient shorthand, if any option settings are required at the start of
a non-capturing group, the option letters may appear between the &quot;?&quot; and the
&quot;:&quot;. Thus the two patterns</p><pre><code class="text">(?i:saturday|sunday)
(?:(?i)saturday|sunday)</code></pre><p>match exactly the same set of strings. Because alternative branches are tried
from left to right, and options are not reset until the end of the group is
reached, an option setting in one branch does affect subsequent branches, so
the above patterns match &quot;SUNDAY&quot; as well as &quot;Saturday&quot;.</p><p><a href="" id="sect12"></a></p><h2 id="module-duplicate-group-numbers" class="section-heading"><a href="#module-duplicate-group-numbers" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Duplicate Group Numbers</span></h2><p>Perl 5.10 introduced a feature whereby each alternative in a group uses the
same numbers for its capturing parentheses. Such a group starts with <code class="inline">(?|</code> and is
itself a non-capturing group. For example, consider this pattern:</p><pre><code class="text">(?|(Sat)ur|(Sun))day</code></pre><p>Because the two alternatives are inside a <code class="inline">(?|</code> group, both sets of capturing
parentheses are numbered one. Thus, when the pattern matches, you can look
at captured substring number one, whichever alternative matched. This construct
is useful when you want to capture part, but not all, of one of a number of
alternatives. Inside a <code class="inline">(?|</code> group, parentheses are numbered as usual, but the
number is reset at the start of each branch. The numbers of any capturing
parentheses that follow the whole group start after the highest number used in
any branch. The following example is taken from the Perl documentation. The
numbers underneath show in which buffer the captured content will be stored.</p><pre><code class="text"># before  ---------------branch-reset----------- after
/ ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
# 1            2         2  3        2     3     4</code></pre><p>A backreference to a capture group uses the most recent value that is set for
the group. The following pattern matches &quot;abcabc&quot; or &quot;defdef&quot;:</p><pre><code class="text">/(?|(abc)|(def))\1/</code></pre><p>In contrast, a subroutine call to a capture group always refers to the
first one in the pattern with the given number. The following pattern matches
&quot;abcabc&quot; or &quot;defabc&quot;:</p><pre><code class="text">/(?|(abc)|(def))(?1)/</code></pre><p>A relative reference such as <code class="inline">(?-1)</code> is no different: it is just a convenient way
of computing an absolute group number.</p><p>If a condition test for a group's having matched refers to a non-unique number, the test is
true if any group with that number has matched.</p><p>An alternative approach to using this &quot;branch reset&quot; feature is to use
duplicate named groups, as described in the next section.</p><p><a href="" id="sect13"></a></p><h2 id="module-named-capture-groups" class="section-heading"><a href="#module-named-capture-groups" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Named Capture Groups</span></h2><p>Identifying capture groups by number is simple, but it can be very hard to keep
track of the numbers in complicated patterns. Furthermore, if an expression is
modified, the numbers may change. To help with this difficulty, PCRE2 supports
the naming of capture groups. This feature was not added to Perl until release
5.10. Python had the feature earlier, and PCRE1 introduced it at release 4.0,
using the Python syntax. PCRE2 supports both the Perl and the Python syntax.</p><p>In PCRE2, a capture group can be named in one of three ways: <code class="inline">(?&lt;name&gt;...)</code> or
<code class="inline">(?'name'...)</code> as in Perl, or <code class="inline">(?P&lt;name&gt;...)</code> as in Python. Names may be up to 128
code units long. When <code class="inline">unicode</code> is not set, they may contain only ASCII
alphanumeric characters and underscores, but must start with a non-digit. When
<code class="inline">unicode</code> is set, the syntax of group names is extended to allow any Unicode
letter or Unicode decimal digit. In other words, group names must match one of
these patterns:</p><ul><li><strong><code class="inline">^[_A-Za-z][_A-Za-z0-9]*\z</code></strong> -  when unicode is not set</li><li><strong><code class="inline">^[_\p{L}][_\p{L}\p{Nd}]*\z</code></strong> -  when unicode is set</li></ul><p>References to capture groups from other parts of the pattern, such as
backreferences, recursion, and conditions, can all be made by name as well as by number.</p><p>Named capture groups are allocated numbers as well as names, exactly as
if the names were not present. In both PCRE2 and Perl, capture groups
are primarily identified by numbers; any names are just aliases for these
numbers. The PCRE2 API provides function calls for extracting the complete
name-to-number translation table from a compiled pattern, as well as
convenience functions for extracting captured substrings by name.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>When more than one capture group has the same number, as
described in the previous section, a name given to one of them applies to all
of them. Perl allows identically numbered groups to have different names.
Consider this pattern, where there are two capture groups, both numbered 1:</p><pre><code class="text">(?|(?&lt;AA&gt;aa)|(?&lt;BB&gt;bb))</code></pre><p>Perl allows this, with both names AA and BB as aliases of group 1. Thus, after
a successful match, both names yield the same value (either &quot;aa&quot; or &quot;bb&quot;).</p><p>In an attempt to reduce confusion, PCRE2 does not allow the same group number
to be associated with more than one name. The example above provokes a
compile-time error. However, there is still scope for confusion. Consider this
pattern:</p><pre><code class="text">(?|(?&lt;AA&gt;aa)|(bb))</code></pre><p>Although the second group number 1 is not explicitly named, the name AA is
still an alias for any group 1. Whether the pattern matches &quot;aa&quot; or &quot;bb&quot;, a
reference by name to group AA yields the matched string.</p></section><p>By default, a name must be unique within a pattern, except that duplicate names
are permitted for groups with the same number, for example:</p><pre><code class="text">(?|(?&lt;AA&gt;aa)|(?&lt;AA&gt;bb))</code></pre><p>The duplicate name constraint can be disabled by setting the <code class="inline">dupnames</code>
option at compile time, or by the use of <code class="inline">(?J)</code> within the pattern, see <a href="re.html#sect10">Internal Option Setting</a>.</p><p>Duplicate names can be useful for patterns where only one instance of the named
capture group can match. Suppose you want to match the name of a weekday,
either as a 3-letter abbreviation or as the full name, and in both cases you
want to extract the abbreviation. This pattern (ignoring the line breaks) does
the job:</p><pre><code class="text">(?J)
(?&lt;DN&gt;Mon|Fri|Sun)(?:day)?|
(?&lt;DN&gt;Tue)(?:sday)?|
(?&lt;DN&gt;Wed)(?:nesday)?|
(?&lt;DN&gt;Thu)(?:rsday)?|
(?&lt;DN&gt;Sat)(?:urday)?</code></pre><p>There are five capture groups, but only one is ever set after a match. The
convenience functions for extracting the data by name returns the substring for
the first (and in this example, the only) group of that name that matched. This
saves searching to find which numbered group it was. (An alternative way of
solving this problem is to use a &quot;branch reset&quot; group, as described in the
previous section.)</p><p>If you make a backreference to a non-unique named group from elsewhere in the
pattern, the groups to which the name refers are checked in the order in which
they appear in the overall pattern. The first one that is set is used for the
reference. For example, this pattern matches both &quot;foofoo&quot; and &quot;barbar&quot; but not
&quot;foobar&quot; or &quot;barfoo&quot;:</p><pre><code class="text">(?J)(?:(?&lt;n&gt;foo)|(?&lt;n&gt;bar))\k&lt;n&gt;</code></pre><p>If you make a subroutine call to a non-unique named group, the one that
corresponds to the first occurrence of the name is used. In the absence of
duplicate numbers this is the one with the lowest number.</p><p>If you use a named reference in a condition
test (see the section about conditions below), either to check whether a capture group has matched, or to check for
recursion, all groups with the same name are tested. If the condition is true
for any one of them, the overall condition is true. This is the same behaviour
as testing by number.</p><p><a href="" id="sect14"></a></p><h2 id="module-repetition" class="section-heading"><a href="#module-repetition" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Repetition</span></h2><p>Repetition is specified by quantifiers, which may follow any one of these
items:</p><pre><code class="text">a literal data character
the dot metacharacter
the `\C` escape sequence
the `\R` escape sequence
the `\X` escape sequence
any escape sequence that matches a single character
a character class
a backreference
a parenthesized group (including lookaround assertions)
a subroutine call (recursive or otherwise)</code></pre><p>If a quantifier does not follow a repeatable item, an error occurs. The
general repetition quantifier specifies a minimum and maximum number of
permitted matches by giving two numbers in curly brackets (braces), separated
by a comma. The numbers must be less than 65536, and the first must be less
than or equal to the second. For example,</p><pre><code class="text">z{2,4}</code></pre><p>matches &quot;zz&quot;, &quot;zzz&quot;, or &quot;zzzz&quot;. A closing brace on its own is not a special
character. If the second number is omitted, but the comma is present, there is
no upper limit; if the second number and the comma are both omitted, the
quantifier specifies an exact number of required matches. Thus</p><pre><code class="text">[aeiou]{3,}</code></pre><p>matches at least 3 successive vowels, but may match many more, whereas</p><pre><code class="text">\d{8}</code></pre><p>matches exactly 8 digits. If the first number is omitted, the lower limit is
taken as zero; in this case the upper limit must be present.</p><pre><code class="text">X{,4} is interpreted as X{0,4}</code></pre><p>This is a change in behaviour that happened in Perl 5.34.0 and PCRE2 10.43. In
earlier versions such a sequence was not interpreted as a quantifier. Other
regular expression engines may behave either way.</p><p>If the characters that follow an opening brace do not match the syntax of a
quantifier, the brace is taken as a literal character. In particular, this
means that <code class="inline">{,}</code> is a literal string of three characters.</p><p>Note that not every opening brace is potentially the start of a quantifier
because braces are used in other items such as <code class="inline">\N{U+345}</code> or <code class="inline">\k{name}</code>.</p><p>In UTF modes, quantifiers apply to characters rather than to individual code
units. Thus, for example, <code class="inline">\x{100}{2}</code> matches two characters, each of
which is represented by a two-byte sequence in a UTF-8 string. Similarly,
<code class="inline">\X{3}</code> matches three Unicode extended grapheme clusters, each of which may be
several code units long (and they may be of different lengths).</p><p>The quantifier <code class="inline">{0}</code> is permitted, causing the expression to behave as if the
previous item and the quantifier were not present. This may be useful for
capture groups that are referenced as
subroutines
from elsewhere in the pattern (see
<a href="re.html#sect20.1">Defining capture groups for use by reference only</a>).
Except for parenthesized groups, items that have a <code class="inline">{0}</code> quantifier are
omitted from the compiled pattern.</p><p>For convenience, the three most common quantifiers have single-character
abbreviations:</p><ul><li><strong><code class="inline">*</code></strong> -  is equivalent to {0,}</li><li><strong><code class="inline">+</code></strong> -  is equivalent to {1,}</li><li><strong><code class="inline">?</code></strong> -  is equivalent to {0,1}</li></ul><p>It is possible to construct infinite loops by following a group that can match
no characters with a quantifier that has no upper limit, for example:</p><pre><code class="text">(a?)*</code></pre><p>Earlier versions of Perl and PCRE1 used to give an error at compile time for
such patterns. However, because there are cases where this can be useful, such
patterns are now accepted, but whenever an iteration of such a group matches no
characters, matching moves on to the next item in the pattern instead of
repeatedly matching an empty string. This does not prevent backtracking into
any of the iterations if a subsequent item fails to match.</p><p>By default, quantifiers are &quot;greedy&quot;, that is, they match as much as possible
(up to the maximum number of permitted repetitions), without causing the rest
of the pattern to fail. The classic example of where this gives problems is in
trying to match comments in C programs. These appear between <code class="inline">/*</code> and <code class="inline">*/</code> and
within the comment, individual <code class="inline">*</code>  and <code class="inline">/</code>  characters may appear. An attempt to
match C comments by applying the pattern</p><pre><code class="text">/\*.*\*/</code></pre><p>to the string</p><pre><code class="text">/* first comment */  not comment  /* second comment */</code></pre><p>fails, because it matches the entire string owing to the greediness of the <code class="inline">.*</code>
item. However, if a quantifier is followed by a question mark, it ceases to be
greedy, and instead matches the minimum number of times possible, so the
pattern</p><pre><code class="text">/\*.*?\*/</code></pre><p>does the right thing with C comments. The meaning of the various quantifiers is
not otherwise changed, just the preferred number of matches. Do not confuse
this use of question mark with its use as a quantifier in its own right.
Because it has two uses, it can sometimes appear doubled, as in</p><pre><code class="text">\d??\d</code></pre><p>which matches one digit by preference, but can match two if that is the only
way the rest of the pattern matches.</p><p>If the <code class="inline">ungreedy</code> option is set (an option that is not available in Perl),
the quantifiers are not greedy by default, but individual ones can be made
greedy by following them with a question mark. In other words, it inverts the
default behaviour.</p><p>When a parenthesized group is quantified with a minimum repeat count that
is greater than 1 or with a limited maximum, more memory is required for the
compiled pattern, in proportion to the size of the minimum or maximum.</p><p>If a pattern starts with <code class="inline">.*</code> or <code class="inline">.{0,}</code> and the <code class="inline">dotall</code> option (equivalent
to Perl's /s) is set, thus allowing the dot to match newlines, the pattern is
implicitly anchored, because whatever follows will be tried against every
character position in the subject string, so there is no point in retrying the
overall match at any position after the first. PCRE2 normally treats such a
pattern as though it were preceded by <code class="inline">\A</code>.</p><p>In cases where it is known that the subject string contains no newlines, it is
worth setting <code class="inline">dotall</code> in order to obtain this optimization, or
alternatively, using <code class="inline">^</code>  to indicate anchoring explicitly.</p><p>However, there are some cases where the optimization cannot be used. When .*
is inside capturing parentheses that are the subject of a backreference
elsewhere in the pattern, a match at the start may fail where a later one
succeeds. Consider, for example:</p><pre><code class="text">(.*)abc\1</code></pre><p>If the subject is &quot;xyz123abc123&quot; the match point is the fourth character. For
this reason, such a pattern is not implicitly anchored.</p><p>Another case where implicit anchoring is not applied is when the leading .* is
inside an atomic group. Once again, a match at the start may fail where a later
one succeeds. Consider this pattern:</p><pre><code class="text">(?&gt;.*?a)b</code></pre><p>It matches &quot;ab&quot; in the subject &quot;aab&quot;. The use of the backtracking control verbs
<code class="inline">(*PRUNE)</code> and <code class="inline">(*SKIP)</code> also disable this optimization.</p><p>When a capture group is repeated, the value captured is the substring that
matched the final iteration. For example, after</p><pre><code class="text">(tweedle[dume]{3}\s*)+</code></pre><p>has matched &quot;tweedledum tweedledee&quot; the value of the captured substring is
&quot;tweedledee&quot;. However, if there are nested capture groups, the corresponding
captured values may have been set in previous iterations. For example, after</p><pre><code class="text">(a|(b))+</code></pre><p>matches &quot;aba&quot; the value of the second captured substring is &quot;b&quot;.</p><p><a href="" id="sect15"></a></p><h2 id="module-atomic-grouping-and-possessive-quantifiers" class="section-heading"><a href="#module-atomic-grouping-and-possessive-quantifiers" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Atomic Grouping and Possessive Quantifiers</span></h2><p>With both maximizing (&quot;greedy&quot;) and minimizing (&quot;ungreedy&quot; or &quot;lazy&quot;)
repetition, failure of what follows normally causes the repeated item to be
re-evaluated to see if a different number of repeats allows the rest of the
pattern to match. Sometimes it is useful to prevent this, either to change the
nature of the match, or to cause it fail earlier than it otherwise might, when
the author of the pattern knows there is no point in carrying on.</p><p>Consider, for example, the pattern <code class="inline">\d+foo</code> when applied to the subject line</p><pre><code class="text">123456bar</code></pre><p>After matching all 6 digits and then failing to match &quot;foo&quot;, the normal
action of the matcher is to try again with only 5 digits matching the <code class="inline">\d+</code>
item, and then with 4, and so on, before ultimately failing. &quot;Atomic grouping&quot;
(a term taken from Jeffrey Friedl's book) provides the means for specifying
that once a group has matched, it is not to be re-evaluated in this way.</p><p>If we use atomic grouping for the previous example, the matcher gives up
immediately on failing to match &quot;foo&quot; the first time. The notation is a kind of
special parenthesis, starting with <code class="inline">(?&gt;</code> as in this example:</p><pre><code class="text">(?&gt;\d+)foo</code></pre><p>Perl 5.28 introduced an experimental alphabetic form starting with <code class="inline">(*</code> which may
be easier to remember:</p><pre><code class="text">(*atomic:\d+)foo</code></pre><p>This kind of parenthesized group &quot;locks up&quot; the part of the pattern it contains
once it has matched, and a failure further into the pattern is prevented from
backtracking into it. Backtracking past it to previous items, however, works as
normal.</p><p>An alternative description is that a group of this type matches exactly the
string of characters that an identical standalone pattern would match, if
anchored at the current point in the subject string.</p><p>Atomic groups are not capture groups. Simple cases such as the above example
can be thought of as a maximizing repeat that must swallow everything it can.
So, while both <code class="inline">\d+</code> and <code class="inline">\d+?</code> are prepared to adjust the number of digits they
match in order to make the rest of the pattern match, <code class="inline">(?&gt;\d+)</code> can only match
an entire sequence of digits.</p><p>Atomic groups in general can of course contain arbitrarily complicated
expressions, and can be nested. However, when the contents of an atomic
group is just a single repeated item, as in the example above, a simpler
notation, called a &quot;possessive quantifier&quot; can be used. This consists of an
additional <code class="inline">+</code>  character following a quantifier. Using this notation, the
previous example can be rewritten as</p><pre><code class="text">\d++foo</code></pre><p>Note that a possessive quantifier can be used with an entire group, for
example:</p><pre><code class="text">(abc|xyz){2,3}+</code></pre><p>Possessive quantifiers are always greedy; the setting of the <code class="inline">ungreedy</code>
option is ignored. They are a convenient notation for the simpler forms of
atomic group. However, there is no difference in the meaning of a possessive
quantifier and the equivalent atomic group, though there may be a performance
difference; possessive quantifiers should be slightly faster.</p><p>The possessive quantifier syntax is an extension to the Perl 5.8 syntax.
Jeffrey Friedl originated the idea (and the name) in the first edition of his
book. Mike McCloskey liked it, so implemented it when he built Sun's Java
package, and PCRE1 copied it from there. It found its way into Perl at release
5.10.</p><p>PCRE2 has an optimization that automatically &quot;possessifies&quot; certain simple
pattern constructs. For example, the sequence A+B is treated as A++B because
there is no point in backtracking into a sequence of A's when B must follow.
This feature can be disabled by the PCRE2_NO_AUTO_POSSESS option, by
starting the pattern with <code class="inline">(*NO_AUTO_POSSESS)</code>.</p><p>When a pattern contains an unlimited repeat inside a group that can itself be
repeated an unlimited number of times, the use of an atomic group is the only
way to avoid some failing matches taking a very long time indeed. The pattern</p><pre><code class="text">(\D+|&lt;\d+&gt;)*[!?]</code></pre><p>matches an unlimited number of substrings that either consist of non-digits, or
digits enclosed in <code class="inline">&lt;&gt;</code>, followed by either <code class="inline">!</code>  or <code class="inline">?</code>. When it matches, it runs
quickly. However, if it is applied to</p><pre><code class="text">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre><p>it takes a long time before reporting failure. This is because the string can
be divided between the internal <code class="inline">\D+</code> repeat and the external <code class="inline">*</code>  repeat in a
large number of ways, and all have to be tried. (The example uses <code class="inline">[!?]</code> rather
than a single character at the end, because both PCRE2 and Perl have an
optimization that allows for fast failure when a single character is used. They
remember the last single character that is required for a match, and fail early
if it is not present in the string.) If the pattern is changed so that it uses
an atomic group, like this:</p><pre><code class="text">((?&gt;\D+)|&lt;\d+&gt;)*[!?]</code></pre><p>sequences of non-digits cannot be broken, and failure happens quickly.</p><p><a href="" id="sect16"></a></p><h2 id="module-backreferences" class="section-heading"><a href="#module-backreferences" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Backreferences</span></h2><p>Outside a character class, a backslash followed by a digit greater than 0 (and
possibly further digits) is a backreference to a capture group earlier (that
is, to its left) in the pattern, provided there have been that many previous
capture groups.</p><p>However, if the decimal number following the backslash is less than 8, it is
always taken as a backreference, and causes an error only if there are not that
many capture groups in the entire pattern. In other words, the group that is
referenced need not be to the left of the reference for numbers less than 8. A
&quot;forward backreference&quot; of this type can make sense when a repetition is
involved and the group to the right has participated in an earlier iteration.</p><p>It is not possible to have a numerical &quot;forward backreference&quot; to a group whose
number is 8 or more using this syntax because a sequence such as <code class="inline">\50</code> is
interpreted as a character defined in octal. See <a href="re.html#sect3.1">Non-Printing Characters</a>
for further details of the handling of digits following a backslash. Other
forms of backreferencing do not suffer from this restriction. In particular,
there is no problem when <a href="re.html#sect13">named capture groups</a> are used.</p><p>Another way of avoiding the ambiguity inherent in the use of digits following a
backslash is to use the <code class="inline">\g</code> escape sequence. This escape must be followed by a
signed or unsigned number, optionally enclosed in braces. These examples are
all identical:</p><pre><code class="text">(ring), \1
(ring), \g1
(ring), \g{1}</code></pre><p>An unsigned number specifies an absolute reference without the ambiguity that
is present in the older syntax. It is also useful when literal digits follow
the reference. A signed number is a relative reference. Consider this example:</p><pre><code class="text">(abc(def)ghi)\g{-1}</code></pre><p>The sequence <code class="inline">\g{-1}</code> is a reference to the capture group whose number is one
less than the number of the next group to be started, so in this example (where
the next group would be numbered 3) is it equivalent to <code class="inline">\2</code>, and <code class="inline">\g{-2}</code> would
be equivalent to <code class="inline">\1</code>. Note that if this construct is inside a capture group,
that group is included in the count, so in this example <code class="inline">\g{-2}</code> also refers to
group 1:</p><pre><code class="text">(A)(\g{-2}B)</code></pre><p>The use of relative references can be helpful in long patterns, and also in
patterns that are created by joining together fragments that contain references
within themselves.</p><p>The sequence <code class="inline">\g{+1}</code> is a reference to the next capture group that is started
after this item, and <code class="inline">\g{+2}</code> refers to the one after that, and so on. This kind
of forward reference can be useful in patterns that repeat. Perl does not
support the use of <code class="inline">+</code> in this way.</p><p>A backreference matches whatever actually most recently matched the capture
group in the current subject string, rather than anything at all that matches
the group (see <a href="re.html#sect23">Groups as Subroutines</a> below for a way of doing that). So the pattern</p><pre><code class="text">(sens|respons)e and \1ibility</code></pre><p>matches &quot;sense and sensibility&quot; and &quot;response and responsibility&quot;, but not
&quot;sense and responsibility&quot;. If caseful matching is in force at the time of the
backreference, the case of letters is relevant. For example,</p><pre><code class="text">((?i)rah)\s+\1</code></pre><p>matches &quot;rah rah&quot; and &quot;RAH RAH&quot;, but not &quot;RAH rah&quot;, even though the original
capture group is matched caselessly.</p><p>There are several different ways of writing backreferences to named capture
groups. The .NET syntax is <code class="inline">\k{name}</code>, the Python syntax is <code class="inline">(?=name)</code>, and the
original Perl syntax is <code class="inline">\k&lt;name&gt;</code> or <code class="inline">\k'name'</code>. All of these are now supported
by both Perl and PCRE2. Perl 5.10's unified backreference syntax, in which <code class="inline">\g</code>
can be used for both numeric and named references, is also supported by PCRE2.
We could rewrite the above example in any of the following ways:</p><pre><code class="text">(?&lt;p1&gt;(?i)rah)\s+\k&lt;p1&gt;
(?'p1'(?i)rah)\s+\k{p1}
(?P&lt;p1&gt;(?i)rah)\s+(?P=p1)
(?&lt;p1&gt;(?i)rah)\s+\g{p1}</code></pre><p>A capture group that is referenced by name may appear in the pattern before or
after the reference.</p><p>There may be more than one backreference to the same group. If a group has not
actually been used in a particular match, backreferences to it always fail by
default. For example, the pattern</p><pre><code class="text">(a|(bc))\2</code></pre><p>always fails if it starts to match &quot;a&quot; rather than &quot;bc&quot;.</p><p>Because there may be many capture groups in a pattern, all digits following a
backslash are taken as part of a potential backreference number. If the pattern
continues with a digit character, some delimiter must be used to terminate the
backreference. If the <code class="inline">extended</code> or PCRE2_EXTENDED_MORE option is set, this
can be white space. Otherwise, the <code class="inline">\g{}</code> syntax or an empty comment (see
<a href="re.html#sect21">Comments</a> below) can be used.</p><p><em>Recursive Backreferences</em></p><p>A backreference that occurs inside the group to which it refers fails when the
group is first used, so, for example, <code class="inline">(a\1)</code> never matches. However, such
references can be useful inside repeated groups. For example, the pattern</p><pre><code class="text">(a|b\1)+</code></pre><p>matches any number of &quot;a&quot;s and also &quot;aba&quot;, &quot;ababbaa&quot; etc. At each iteration of
the group, the backreference matches the character string corresponding to the
previous iteration. In order for this to work, the pattern must be such that
the first iteration does not need to match the backreference. This can be done
using alternation, as in the example above, or by a quantifier with a minimum
of zero.</p><p>For versions of PCRE2 less than 10.25, backreferences of this type used to
cause the group that they reference to be treated as an
atomic group.
This restriction no longer applies, and backtracking into such groups can occur
as normal.</p><p><a href="" id="sect17"></a></p><h2 id="module-assertions" class="section-heading"><a href="#module-assertions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Assertions</span></h2><p>An assertion is a test that does not consume any characters. The test must
succeed for the match to continue. The simple assertions coded as <code class="inline">\b</code>, <code class="inline">\B</code>,
<code class="inline">\A</code>, <code class="inline">\G</code>, <code class="inline">\Z</code>, <code class="inline">\z</code>, <code class="inline">^</code>  and <code class="inline">$</code>  are described
above.</p><p>More complicated assertions are coded as parenthesized groups. If matching such
a group succeeds, matching continues after it, but with the matching position
in the subject string reset to what it was before the assertion was processed.</p><p>A special kind of assertion, called a &quot;scan substring&quot; assertion, matches a
subpattern against a previously captured substring. This is described in 
<a href="re.html#sect18X">Scan Substring Assertions</a>. It is a PCRE2 extension, not
compatible with Perl.</p><p>The other goup-based assertions are of two kinds: those that look ahead of the
current position in the subject string, and those that look behind it, and in
each case an assertion may be positive (must match for the assertion to be
true) or negative (must not match for the assertion to be true).</p><p>The Perl-compatible lookaround assertions are atomic. If an assertion is true,
but there is a subsequent matching failure, there is no backtracking into the
assertion. However, there are some cases where non-atomic assertions can be
useful. PCRE2 has some support for these, described in
<a href="re.html#sect18">Non-atomic assertions</a>, but they are not Perl-compatible.</p><p>A lookaround assertion may appear as the condition in a
<a href="re.html#sect20">conditional groups</a>. In this case, the result of matching the
assertion determines which branch of the condition is followed.</p><p>Assertion groups are not capture groups. If an assertion contains capture
groups within it, these are counted for the purposes of numbering the capture
groups in the whole pattern. Within each branch of an assertion, locally
captured substrings may be referenced in the usual way. For example, a sequence
such as <code class="inline">(.)\g{-1}</code> can be used to check that two adjacent characters are the
same.</p><p>When a branch within an assertion fails to match, any substrings that were
captured are discarded (as happens with any pattern branch that fails to
match). A negative assertion is true only when all its branches fail to match;
this means that no captured substrings are ever retained after a successful
negative assertion. When an assertion contains a matching branch, what happens
depends on the type of assertion.</p><p>For a positive assertion, internally captured substrings in the successful
branch are retained, and matching continues with the next pattern item after
the assertion. For a negative assertion, a matching branch means that the
assertion is not true. If such an assertion is being used as a condition in a
<a href="re.html#sect20">conditional groups</a>, captured substrings are retained, because matching continues with
the &quot;no&quot; branch of the condition. For other failing negative assertions,
control passes to the previous backtracking point, thus discarding any captured
strings within the assertion.</p><p>Most assertion groups may be repeated; though it makes no sense to assert the
same thing several times, the side effect of capturing in positive assertions
may occasionally be useful. However, an assertion that forms the condition for
a conditional group may not be quantified. PCRE2 used to restrict the
repetition of assertions, but from release 10.35 the only restriction is that
an unlimited maximum repetition is changed to be one more than the minimum. For
example, <code class="inline">{3,}</code> is treated as <code class="inline">{3,4}</code>.</p><p><em>Alphabetic Assertion Names</em></p><p>Traditionally, symbolic sequences such as <code class="inline">(?=</code> and <code class="inline">(?&lt;=</code> have been used to
specify lookaround assertions. Perl 5.28 introduced some experimental
alphabetic alternatives which might be easier to remember. They all start with
<code class="inline">(*</code> instead of <code class="inline">(?</code> and must be written using lower case letters. PCRE2 supports
the following synonyms:</p><pre><code class="text">(*positive_lookahead:  or (*pla: is the same as (?=
(*negative_lookahead:  or (*nla: is the same as (?!
(*positive_lookbehind: or (*plb: is the same as (?&lt;=
(*negative_lookbehind: or (*nlb: is the same as (?&lt;!</code></pre><p>For example, <code class="inline">(*pla:foo)</code> is the same assertion as <code class="inline">(?=foo)</code>. In the following
sections, the various assertions are described using the original symbolic
forms.</p><p><em>Lookahead Assertions</em></p><p>Lookahead assertions start with <code class="inline">(?=</code> for positive assertions and <code class="inline">(?!</code> for
negative assertions. For example,</p><pre><code class="text">\w+(?=;)</code></pre><p>matches a word followed by a semicolon, but does not include the semicolon in
the match, and</p><pre><code class="text">foo(?!bar)</code></pre><p>matches any occurrence of &quot;foo&quot; that is not followed by &quot;bar&quot;. Note that the
apparently similar pattern</p><pre><code class="text">(?!foo)bar</code></pre><p>does not find an occurrence of &quot;bar&quot; that is preceded by something other than
&quot;foo&quot;; it finds any occurrence of &quot;bar&quot; whatsoever, because the assertion
<code class="inline">(?!foo)</code> is always true when the next three characters are &quot;bar&quot;. A
lookbehind assertion is needed to achieve the other effect.</p><p>If you want to force a matching failure at some point in a pattern, the most
convenient way to do it is with <code class="inline">(?!)</code> because an empty string always matches, so
an assertion that requires there not to be an empty string must always fail.
The backtracking control verb <code class="inline">(*FAIL)</code> or <code class="inline">(*F)</code> is a synonym for <code class="inline">(?!)</code>.</p><p><em>Lookbehind Assertions</em></p><p>Lookbehind assertions start with <code class="inline">(?&lt;=</code> for positive assertions and <code class="inline">(?&lt;!</code> for
negative assertions. For example,</p><pre><code class="text">(?&lt;!foo)bar</code></pre><p>does find an occurrence of &quot;bar&quot; that is not preceded by &quot;foo&quot;. The contents of
a lookbehind assertion are restricted such that there must be a known maximum
to the lengths of all the strings it matches. There are two cases:</p><p>If every top-level alternative matches a fixed length, for example</p><pre><code class="text">(?&lt;=colour|color)</code></pre><p>there is a limit of 65535 characters to the lengths, which do not have to be
the same, as this example demonstrates. This is the only kind of lookbehind
supported by PCRE2 versions earlier than 10.43.</p><p>In PCRE2 10.43 and later, <a href="#run/3"><code class="inline">run/3</code></a> supports lookbehind assertions in
which one or more top-level alternatives can match more than one string length,
for example</p><pre><code class="text">(?&lt;=colou?r)</code></pre><p>The maximum matching length for any branch of the lookbehind is limited to a
value set by the calling program (default 255 characters). Unlimited repetition
(for example <code class="inline">\d*</code>) is not supported. In some cases, the escape sequence <code class="inline">\K</code>
(see above)
can be used instead of a lookbehind assertion at the start of a pattern to get
round the length limit restriction.</p><p>In UTF-8, PCRE2 does not allow the <code class="inline">\C</code> escape (which matches a
single code unit even in a UTF mode) to appear in lookbehind assertions,
because it makes it impossible to calculate the length of the lookbehind. The
<code class="inline">\X</code> and <code class="inline">\R</code> escapes, which can match different numbers of code units, are never
permitted in lookbehinds.</p><p>&quot;Subroutine&quot;
calls (see below) such as <code class="inline">(?2)</code> or <code class="inline">(?&amp;X)</code> are permitted in lookbehinds, as long
as the called capture group matches a limited-length string. However,
recursion,
that is, a &quot;subroutine&quot; call into a group that is already active,
is not supported.</p><p>PCRE2 supports backreferences in lookbehinds, but only if certain conditions
are met. There must be no
use of <code class="inline">(?|</code> in the pattern (it creates duplicate group numbers), and if the
backreference is by name, the name must be unique. Of course, the referenced
group must itself match a limited length substring. The following pattern
matches words containing at least two characters that begin and end with the
same character:</p><pre><code class="text">\b(\w)\w++(?&lt;=\1)</code></pre><p>Possessive quantifiers can be used in conjunction with lookbehind assertions to
specify efficient matching at the end of subject strings. Consider a simple
pattern such as</p><pre><code class="text">abcd$</code></pre><p>when applied to a long string that does not match. Because matching proceeds
from left to right, PCRE2 will look for each &quot;a&quot; in the subject and then see if
what follows matches the rest of the pattern. If the pattern is specified as</p><pre><code class="text">^.*abcd$</code></pre><p>the initial .* matches the entire string at first, but when this fails (because
there is no following &quot;a&quot;), it backtracks to match all but the last character,
then all but the last two characters, and so on. Once again the search for &quot;a&quot;
covers the entire string, from right to left, so we are no better off. However,
if the pattern is written as</p><pre><code class="text">^.*+(?&lt;=abcd)</code></pre><p>there can be no backtracking for the .*+ item because of the possessive
quantifier; it can match only the entire string. The subsequent lookbehind
assertion does a single test on the last four characters. If it fails, the
match fails immediately. For long strings, this approach makes a significant
difference to the processing time.</p><p><em>Using Multiple Assertions</em></p><p>Several assertions (of any sort) may occur in succession. For example,</p><pre><code class="text">(?&lt;=`\d{3}`)(?&lt;!999)foo</code></pre><p>matches &quot;foo&quot; preceded by three digits that are not &quot;999&quot;. Notice that each of
the assertions is applied independently at the same point in the subject
string. First there is a check that the previous three characters are all
digits, and then there is a check that the same three characters are not &quot;999&quot;.
This pattern does <em>not</em> match &quot;foo&quot; preceded by six characters, the first
of which are digits and the last three of which are not &quot;999&quot;. For example, it
doesn't match &quot;123abcfoo&quot;. A pattern to do that is</p><pre><code class="text">(?&lt;=\d{3}...)(?&lt;!999)foo</code></pre><p>This time the first assertion looks at the preceding six characters, checking
that the first three are digits, and then the second assertion checks that the
preceding three characters are not &quot;999&quot;.</p><p>Assertions can be nested in any combination. For example,</p><pre><code class="text">(?&lt;=(?&lt;!foo)bar)baz</code></pre><p>matches an occurrence of &quot;baz&quot; that is preceded by &quot;bar&quot; which in turn is not
preceded by &quot;foo&quot;, while</p><pre><code class="text">(?&lt;=\d{3}(?!999)...)foo</code></pre><p>is another pattern that matches &quot;foo&quot; preceded by three digits and any three
characters that are not &quot;999&quot;.</p><p><a href="" id="sect18"></a></p><h2 id="module-non-atomic-assertions" class="section-heading"><a href="#module-non-atomic-assertions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Non-Atomic Assertions</span></h2><p>Traditional lookaround assertions are atomic. That is, if an assertion is true,
but there is a subsequent matching failure, there is no backtracking into the
assertion. However, there are some cases where non-atomic positive assertions
can be useful. PCRE2 provides these using the following syntax:</p><pre><code class="text">(*non_atomic_positive_lookahead:  or (*napla: or (?*
(*non_atomic_positive_lookbehind: or (*naplb: or (?&lt;*</code></pre><p>Consider the problem of finding the right-most word in a string that also
appears earlier in the string, that is, it must appear at least twice in total.
This pattern returns the required result as captured substring 1:</p><pre><code class="text">^(?x)(*napla: .* \b(\w++)) (?&gt; .*? \b\1\b ){2}</code></pre><p>For a subject such as &quot;word1 word2 word3 word2 word3 word4&quot; the result is
&quot;word3&quot;. How does it work? At the start, <code class="inline">^(?x)</code> anchors the pattern and sets the
&quot;x&quot; option, which causes white space (introduced for readability) to be
ignored. Inside the assertion, the greedy <code class="inline">.*</code> at first consumes the entire
string, but then has to backtrack until the rest of the assertion can match a
word, which is captured by group 1. In other words, when the assertion first
succeeds, it captures the right-most word in the string.</p><p>The current matching point is then reset to the start of the subject, and the
rest of the pattern match checks for two occurrences of the captured word,
using an ungreedy .<em>? to scan from the left. If this succeeds, we are done, but
if the last word in the string does not occur twice, this part of the pattern
fails. If a traditional atomic lookahead <code class="inline">(?=</code> or `(</em>pla:` had been used, the
assertion could not be re-entered, and the whole match would fail. The pattern
would succeed only if the very last word in the subject was found twice.</p><p>Using a non-atomic lookahead, however, means that when the last word does not
occur twice in the string, the lookahead can backtrack and find the second-last
word, and so on, until either the match succeeds, or all words have been
tested.</p><p>Two conditions must be met for a non-atomic assertion to be useful: the
contents of one or more capturing groups must change after a backtrack into the
assertion, and there must be a backreference to a changed group later in the
pattern. If this is not the case, the rest of the pattern match fails exactly
as before because nothing has changed, so using a non-atomic assertion just
wastes resources.</p><p>There is one exception to backtracking into a non-atomic assertion. If an
<code class="inline">(*ACCEPT)</code> control verb is triggered, the assertion succeeds atomically. That
is, a subsequent match failure cannot backtrack into the assertion.</p><p>Note that assertions that appear as conditions for
<a href="re.html#sect20">conditional groups</a> must be atomic.</p><p><a href="" id="sect18X"></a></p><h2 id="module-scan-substring-assertions" class="section-heading"><a href="#module-scan-substring-assertions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Scan Substring Assertions</span></h2><p>A special kind of assertion, not compatible with Perl, makes it possible to
check the contents of a captured substring by matching it with a subpattern.
Because this involves capturing.</p><p>A scan substring assertion starts with the sequence <code class="inline">(*scan_substring:</code> or
<code class="inline">(*scs:</code> which is followed by a list of substring numbers (absolute or relative)
and/or substring names enclosed in single quotes or angle brackets, all within
parentheses. The rest of the item is the subpattern that is applied to the
substring, as shown in these examples:</p><pre><code class="text">(*scan_substring:(1)...)
(*scs:(-2)...)
(*scs:('AB')...)
(*scs:(1,'AB',-2)...)</code></pre><p>The list of groups is checked in the order they are given, and it is the
contents of the first one that is found to be set that are scanned. When
<code class="inline">dupnames</code> is set and there are ambiguous group names, all groups with the
same name are checked in numerical order. A scan substring assertion fails if
none of the groups it references have been set.</p><p>The pattern match on the substring is always anchored, that is, it must match
from the start of the substring. There is no &quot;bumpalong&quot; if it does not match
at the start. The end of the subject is temporarily reset to be the end of the
substring, so <code class="inline">\Z</code>, <code class="inline">\z</code>, and <code class="inline">$</code>  will match there. However, the start of the
subject is <em>not</em> reset. This means that <code class="inline">^</code>  matches only if the substring is
actually at the start of the main subject, but it also means that lookbehind
assertions into what precedes the substring are possible.</p><p>Here is a very simple example: find a word that contains the rare (in English)
sequence of letters &quot;rh&quot; not at the start:</p><pre><code class="text">\b(\w++)(*scs:(1).+rh)</code></pre><p>The first group captures a word which is then scanned by the second group.
This example does not actually need this heavyweight feature; the same match
can be achieved with:</p><pre><code class="text">\b\w+?rh\w*\eb</code></pre><p>When things are more complicated, however, scanning a captured substring can be
a useful way to describe the required match. For exmple, there is a rather
complicated pattern in the PCRE2 test data that checks an entire subject string
for a palindrome, that is, the sequence of letters is the same in both
directions. Suppose you want to search for individual words of two or more
characters such as &quot;level&quot; that are palindromes:</p><pre><code class="text">(\b\w{2,}+\b)(*scs:(1)...palindrome-matching-pattern...)</code></pre><p>Within a substring scanning subpattern, references to other groups work as
normal. Capturing groups may appear, and will retain their values during
ongoing matching if the assertion succeeds.</p><p><a href="" id="sect19"></a></p><h2 id="module-script-runs" class="section-heading"><a href="#module-script-runs" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Script Runs</span></h2><p>In concept, a script run is a sequence of characters that are all from the same
Unicode script such as Latin or Greek. However, because some scripts are
commonly used together, and because some diacritical and other marks are used
with multiple scripts, it is not that simple. There is a full description of
the rules that PCRE2 uses in the section entitled
&quot;Script Runs&quot;
in the
<code class="inline">pcre2unicode</code>
documentation.</p><p>If part of a pattern is enclosed between <code class="inline">(*script_run:</code> or <code class="inline">(*sr:</code> and a closing
parenthesis, it fails if the sequence of characters that it matches are not a
script run. After a failure, normal backtracking occurs. Script runs can be
used to detect spoofing attacks using characters that look the same, but are
from different scripts. The string &quot;paypal.com&quot; is an infamous example, where
the letters could be a mixture of Latin and Cyrillic. This pattern ensures that
the matched characters in a sequence of non-spaces that follow white space are
a script run:</p><pre><code class="text">\s+(*sr:\S+)</code></pre><p>To be sure that they are all from the Latin script (for example), a lookahead
can be used:</p><pre><code class="text">\s+(?=\p{Latin})(*sr:\S+)</code></pre><p>This works as long as the first character is expected to be a character in that
script, and not (for example) punctuation, which is allowed with any script. If
this is not the case, a more creative lookahead is needed. For example, if
digits, underscore, and dots are permitted at the start:</p><pre><code class="text">\s+(?=[0-9_.]*\p{Latin})(*sr:\S+)</code></pre><p>In many cases, backtracking into a script run pattern fragment is not
desirable. The script run can employ an atomic group to prevent this. Because
this is a common requirement, a shorthand notation is provided by
<code class="inline">(*atomic_script_run:</code> or <code class="inline">(*asr:</code></p><pre><code class="text">(*asr:...) is the same as (*sr:(?&gt;...))</code></pre><p>Note that the atomic group is inside the script run. Putting it outside would
not prevent backtracking into the script run pattern.</p><p>Support for script runs is not available if PCRE2 is compiled without Unicode
support. A compile-time error is given if any of the above constructs is
encountered.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>The <code class="inline">(*ACCEPT)</code> control verb (see below)
should not be used within a script run group, because it causes an immediate
exit from the group, bypassing the script run checking.</p></section><p><a href="" id="sect20"></a></p><h2 id="module-conditional-groups" class="section-heading"><a href="#module-conditional-groups" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Conditional Groups</span></h2><p>It is possible to cause the matching process to obey a pattern fragment
conditionally or to choose between two alternative fragments, depending on
the result of an assertion, or whether a specific capture group has
already been matched. The two possible forms of conditional group are:</p><pre><code class="text">(?(condition)yes-pattern)
(?(condition)yes-pattern|no-pattern)</code></pre><p>If the condition is satisfied, the yes-pattern is used; otherwise the
no-pattern (if present) is used. An absent no-pattern is equivalent to an empty
string (it always matches). If there are more than two alternatives in the
group, a compile-time error occurs. Each of the two alternatives may itself
contain nested groups of any form, including conditional groups; the
restriction to two alternatives applies only at the level of the condition
itself. This pattern fragment is an example where the alternatives are complex:</p><pre><code class="text">(?(1) (A|B|C) |  (D |  (?(2)E|F) |  E) )</code></pre><p>There are five kinds of condition: references to capture groups, references to
recursion, two pseudo-conditions called DEFINE and VERSION, and assertions.</p><p><em>Checking for a Used Capture Group by Number</em></p><p>If the text between the parentheses consists of a sequence of digits, the
condition is true if a capture group of that number has previously matched. If
there is more than one capture group with the same number (see <a href="re.html#sect12">Duplicate Group Numbers</a>),
the condition is true if any of them have matched. An alternative notation,
which is a PCRE2 extension, not supported by Perl, is to precede the digits
with a plus or minus sign. In this case, the group number is relative rather
than absolute. The most recently opened capture group (which could be enclosing
this condition) can be referenced by <code class="inline">(?(-1)</code>, the next most recent by <code class="inline">(?(-2)</code>,
and so on. Inside loops it can also make sense to refer to subsequent groups.
The next capture group to be opened can be referenced as <code class="inline">(?(+1)</code>, and so on. The
value zero in any of these forms is not used; it provokes a compile-time error.</p><p>Consider the following pattern, which contains non-significant white space to
make it more readable (assume the <code class="inline">extended</code> option) and to divide it into
three parts for ease of discussion:</p><ul><li><strong>( ( )?</strong> - [^()]+ (?(1) ) )</li></ul><p>The first part matches an optional opening parenthesis, and if that
character is present, sets it as the first captured substring. The second part
matches one or more characters that are not parentheses. The third part is a
conditional group that tests whether or not the first capture group
matched. If it did, that is, if subject started with an opening parenthesis,
the condition is true, and so the yes-pattern is executed and a closing
parenthesis is required. Otherwise, since no-pattern is not present, the
conditional group matches nothing. In other words, this pattern matches a
sequence of non-parentheses, optionally enclosed in parentheses.</p><p>If you were embedding this pattern in a larger one, you could use a relative
reference:</p><ul><li><strong>...other stuff... ( ( )?</strong> -  [^()]+    (?(-1) ) )  ...</li></ul><p>This makes the fragment independent of the parentheses in the larger pattern.</p><p><em>Checking for a Used Capture Group by Name</em></p><p>Perl uses the syntax <code class="inline">(?(&lt;name&gt;)...)</code> or <code class="inline">(?('name')...)</code> to test for a used
capture group by name. For compatibility with earlier versions of PCRE1, which
had this facility before Perl, the syntax (?(name)...) is also recognized.
Note, however, that undelimited names consisting of the letter R followed by
digits are ambiguous (see the following section). Rewriting the above example
to use a named group gives this:</p><ul><li><strong>(?&lt;OPEN&gt; ( )?</strong> - [^()]+ (?(&lt;OPEN&gt;) ) )</li></ul><p>If the name used in a condition of this kind is a duplicate, the test is
applied to all groups of the same name, and is true if any one of them has
matched.</p><p><em>Checking for Pattern Recursion</em></p><p>&quot;Recursion&quot; in this sense refers to any subroutine-like call from one part of
the pattern to another, whether or not it is actually recursive. See 
<a href="re.html#sect22">Recursive Patterns</a>
and
<a href="re.html#sect23">Groups as Subroutines</a> for details of recursion and subroutine calls.</p><p>If a condition is the string (R), and there is no capture group with the name
R, the condition is true if matching is currently in a recursion or subroutine
call to the whole pattern or any capture group. If digits follow the letter R,
and there is no group with that name, the condition is true if the most recent
call is into a group with the given number, which must exist somewhere in the
overall pattern. This is a contrived example that is equivalent to a+b:</p><pre><code class="text">((?(R1)a+|(?1)b))</code></pre><p>However, in both cases, if there is a capture group with a matching name, the
condition tests for its being set, as described in the section above, instead
of testing for recursion. For example, creating a group with the name R1 by
adding <code class="inline">(?&lt;R1&gt;)</code> to the above pattern completely changes its meaning.</p><p>If a name preceded by ampersand follows the letter R, for example:</p><pre><code class="text">(?(R&amp;name)...)</code></pre><p>the condition is true if the most recent recursion is into a group of that name
(which must exist within the pattern).</p><p>This condition does not check the entire recursion stack. It tests only the
current level. If the name used in a condition of this kind is a duplicate, the
test is applied to all groups of the same name, and is true if any one of
them is the most recent recursion.</p><p>At &quot;top level&quot;, all these recursion test conditions are false.</p><p><a href="" id="sect20.1"></a>
<em>Defining Capture Groups for Use by Reference Only</em></p><p>If the condition is the string <code class="inline">(DEFINE)</code>, the condition is always false, even if
there is a group with the name DEFINE. In this case, there may be only one
alternative in the rest of the conditional group. It is always skipped if
control reaches this point in the pattern; the idea of DEFINE is that it can be
used to define subroutines that can be referenced from elsewhere. (The use of
subroutines
is described below.) For example, a pattern to match an IPv4 address such as
&quot;192.168.23.245&quot; could be written like this (ignore white space and line
breaks):</p><pre><code class="text">(?(DEFINE) (?&lt;byte&gt; 2[0-4]\d |  25[0-5] |  1\d\d |  [1-9]?\d) )
\b (?&amp;byte) (\.(?&amp;byte)){3} \b</code></pre><p>The first part of the pattern is a DEFINE group inside which another group
named &quot;byte&quot; is defined. This matches an individual component of an IPv4
address (a number less than 256). When matching takes place, this part of the
pattern is skipped because DEFINE acts like a false condition. The rest of the
pattern uses references to the named group to match the four dot-separated
components of an IPv4 address, insisting on a word boundary at each end.</p><p><em>Checking the PCRE2 Version</em></p><p>Programs that link with a PCRE2 library can check the version by calling
<code class="inline">pcre2\_config()</code> with appropriate arguments. Users of applications that do
not have access to the underlying code cannot do this. A special &quot;condition&quot;
called VERSION exists to allow such users to discover which version of PCRE2
they are dealing with by using this condition to match a string such as
&quot;yesno&quot;. VERSION must be followed either by &quot;=&quot; or &quot;&gt;=&quot; and a version number.
For example:</p><pre><code class="text">(?(VERSION&gt;=10.4)yes|no)</code></pre><p>This pattern matches &quot;yes&quot; if the PCRE2 version is greater or equal to 10.4, or
&quot;no&quot; otherwise. The fractional part of the version number may not contain more
than two digits.</p><p><em>Assertion Conditions</em></p><p>If the condition is not in any of the above formats, it must be a parenthesized
assertion. This may be a positive or negative lookahead or lookbehind
assertion. However, it must be a traditional atomic assertion, not one of the
non-atomic assertions.</p><p>Consider this pattern, again containing non-significant white space, and with
the two alternatives on the second line:</p><pre><code class="text">(?(?=[^a-z]*[a-z])
\d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )</code></pre><p>The condition is a positive lookahead assertion that matches an optional
sequence of non-letters followed by a letter. In other words, it tests for the
presence of at least one letter in the subject. If a letter is found, the
subject is matched against the first alternative; otherwise it is matched
against the second. This pattern matches strings in one of the two forms
dd-aaa-dd or dd-dd-dd, where aaa are letters and dd are digits.</p><p>When an assertion that is a condition contains capture groups, any
capturing that occurs in a matching branch is retained afterwards, for both
positive and negative assertions, because matching always continues after the
assertion, whether it succeeds or fails. (Compare non-conditional assertions,
for which captures are retained only for positive assertions that succeed.)</p><p><a href="" id="sect21"></a></p><h2 id="module-comments" class="section-heading"><a href="#module-comments" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Comments</span></h2><p>There are two ways of including comments in patterns that are processed by
PCRE2. In both cases, the start of the comment must not be in a character
class, nor in the middle of any other sequence of related characters such as
<code class="inline">(?:</code> or a group name or number or a Unicode property name. The characters that
make up a comment play no part in the pattern matching.</p><p>The sequence <code class="inline">(?#</code> marks the start of a comment that continues up to the next
closing parenthesis. Nested parentheses are not permitted. If the
<code class="inline">extended</code> or PCRE2_EXTENDED_MORE option is set, an unescaped <code class="inline">#</code>  character
also introduces a comment, which in this case continues to immediately after
the next newline character or character sequence in the pattern. Which
characters are interpreted as newlines is controlled by an option passed to the
compiling function or by a special sequence at the start of the pattern, as
described in <a href="re.html#sect1.1">Newline Conventions</a>.
Note that the end of this type of comment is a literal newline sequence
in the pattern; escape sequences that happen to represent a newline do not
count. For example, consider this pattern when <code class="inline">extended</code> is set, and the
default newline convention (a single linefeed character) is in force:</p><pre><code class="text">abc #comment \n still comment</code></pre><p>On encountering the <code class="inline">#</code>  character, <a href="#compile/2"><code class="inline">compile/2</code></a> skips along, looking for
a newline in the pattern. The sequence <code class="inline">\n</code> is still literal at this stage, so
it does not terminate the comment. Only an actual character with the code value
0x0a (the default newline) does so.</p><p><a href="" id="sect22"></a></p><h2 id="module-recursive-patterns" class="section-heading"><a href="#module-recursive-patterns" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Recursive Patterns</span></h2><p>Consider the problem of matching a string in parentheses, allowing for
unlimited nested parentheses. Without the use of recursion, the best that can
be done is to use a pattern that matches up to some fixed depth of nesting. It
is not possible to handle an arbitrary nesting depth.</p><p>For some time, Perl has provided a facility that allows regular expressions to
recurse (amongst other things). It does this by interpolating Perl code in the
expression at run time, and the code can refer to the expression itself. A Perl
pattern using code interpolation to solve the parentheses problem can be
created like this:</p><pre><code class="text">$re =  qr{\( (?: (?&gt;[^()]+) |  (?p{$re}) )* \)}x;</code></pre><p>The <code class="inline">(?p{...})</code> item interpolates Perl code at run time, and in this case refers
recursively to the pattern in which it appears.</p><p>Obviously, PCRE2 cannot support the interpolation of Perl code. Instead, it
supports special syntax for recursion of the entire pattern, and also for
individual capture group recursion. After its introduction in PCRE1 and Python,
this kind of recursion was subsequently introduced into Perl at release 5.10.</p><p>A special item that consists of <code class="inline">(?</code> followed by a number greater than zero and a
closing parenthesis is a recursive subroutine call of the capture group of the
given number, provided that it occurs inside that group. (If not, it is a
non-recursive subroutine
call, which is described in the next section.) The special item <code class="inline">(?R)</code> or <code class="inline">(?0)</code> is
a recursive call of the entire regular expression.</p><p>This PCRE2 pattern solves the nested parentheses problem (assume the
<code class="inline">extended</code> option is set so that white space is ignored):</p><pre><code class="text">\( ( [^()]++ | (?R) )* \)</code></pre><p>First it matches an opening parenthesis. Then it matches any number of
substrings which can either be a sequence of non-parentheses, or a recursive
match of the pattern itself (that is, a correctly parenthesized substring).
Finally there is a closing parenthesis. Note the use of a possessive quantifier
to avoid backtracking into sequences of non-parentheses.</p><p>If this were part of a larger pattern, you would not want to recurse the entire
pattern, so instead you could use this:</p><pre><code class="text">( \( ( [^()]++ | (?1) )* \) )</code></pre><p>We have put the pattern into parentheses, and caused the recursion to refer to
them instead of the whole pattern.</p><p>In a larger pattern, keeping track of parenthesis numbers can be tricky. This
is made easier by the use of relative references. Instead of <code class="inline">(?1)</code> in the
pattern above you can write <code class="inline">(?-2)</code> to refer to the second most recently opened
parentheses preceding the recursion. In other words, a negative number counts
capturing parentheses leftwards from the point at which it is encountered.</p><p>Be aware however, that if
duplicate capture group numbers
are in use, relative references refer to the earliest group with the
appropriate number. Consider, for example:</p><pre><code class="text">(?|(a)|(b)) (c) (?-2)</code></pre><p>The first two capture groups (a) and (b) are both numbered 1, and group (c)
is number 2. When the reference <code class="inline">(?-2)</code> is encountered, the second most recently
opened parentheses has the number 1, but it is the first such group (the (a)
group) to which the recursion refers. This would be the same if an absolute
reference <code class="inline">(?1)</code> was used. In other words, relative references are just a
shorthand for computing a group number.</p><p>It is also possible to refer to subsequent capture groups, by writing
references such as <code class="inline">(?+2)</code>. However, these cannot be recursive because the
reference is not inside the parentheses that are referenced. They are always
non-recursive subroutine
calls, as described in the next section.</p><p>An alternative approach is to use named parentheses. The Perl syntax for this
is <code class="inline">(?&amp;name)</code>; PCRE1's earlier syntax <code class="inline">(?P&gt;name)</code> is also supported. We could
rewrite the above example as follows:</p><pre><code class="text">(?&lt;pn&gt; \( ( [^()]++ | (?&amp;pn) )* \) )</code></pre><p>If there is more than one group with the same name, the earliest one is
used.</p><p>The example pattern that we have been looking at contains nested unlimited
repeats, and so the use of a possessive quantifier for matching strings of
non-parentheses is important when applying the pattern to strings that do not
match. For example, when this pattern is applied to</p><pre><code class="text">(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</code></pre><p>it yields &quot;no match&quot; quickly. However, if a possessive quantifier is not used,
the match runs for a very long time indeed because there are so many different
ways the <code class="inline">+</code> and <code class="inline">*</code> repeats can carve up the subject, and all have to be tested
before failure can be reported.</p><p>At the end of a match, the values of capturing parentheses are those from
the outermost level. If you want to obtain intermediate values, a callout
function can be used (see below and the
<code class="inline">pcre2callout</code>
documentation). If the pattern above is matched against</p><pre><code class="text">(ab(cd)ef)</code></pre><p>the value for the inner capturing parentheses (numbered 2) is &quot;ef&quot;, which is
the last value taken on at the top level. If a capture group is not matched at
the top level, its final captured value is unset, even if it was (temporarily)
set at a deeper level during the matching process.</p><p>Do not confuse the <code class="inline">(?R)</code> item with the condition <code class="inline">(R)</code>, which tests for recursion.
Consider this pattern, which matches text in angle brackets, allowing for
arbitrary nesting. Only digits are allowed in nested brackets (that is, when
recursing), whereas any characters are permitted at the outer level.</p><pre><code class="text">&lt; (?: (?(R) \d++  |  [^&lt;&gt;]*+) |  (?R)) *  &gt;</code></pre><p>In this pattern, <code class="inline">(?(R)</code> is the start of a conditional group, with two different
alternatives for the recursive and non-recursive cases. The <code class="inline">(?R)</code> item is the
actual recursive call.</p><p><em>Differences in Recursion Processing Between PCRE2 and Perl</em></p><p>Some former differences between PCRE2 and Perl no longer exist.</p><p>Before release 10.30, recursion processing in PCRE2 differed from Perl in that
a recursive subroutine call was always treated as an atomic group. That is,
once it had matched some of the subject string, it was never re-entered, even
if it contained untried alternatives and there was a subsequent matching
failure. (Historical note: PCRE implemented recursion before Perl did.)</p><p>Starting with release 10.30, recursive subroutine calls are no longer treated
as atomic. That is, they can be re-entered to try unused alternatives if there
is a matching failure later in the pattern. This is now compatible with the way
Perl works. If you want a subroutine call to be atomic, you must explicitly
enclose it in an atomic group.</p><p>Supporting backtracking into recursions simplifies certain types of recursive
pattern. For example, this pattern matches palindromic strings:</p><pre><code class="text">^((.)(?1)\2|.?)$</code></pre><p>The second branch in the group matches a single central character in the
palindrome when there are an odd number of characters, or nothing when there
are an even number of characters, but in order to work it has to be able to try
the second case when the rest of the pattern match fails. If you want to match
typical palindromic phrases, the pattern has to ignore all non-word characters,
which can be done like this:</p><pre><code class="text">^\W*+((.)\W*+(?1)\W*+\2|\W*+.?)\W*+$</code></pre><p>If run with the <code class="inline">caseless</code> option, this pattern matches phrases such as &quot;A
man, a plan, a canal: Panama!&quot;. Note the use of the possessive quantifier *+ to
avoid backtracking into sequences of non-word characters. Without this, PCRE2
takes a great deal longer (ten times or more) to match typical phrases, and
Perl takes so long that you think it has gone into a loop.</p><p>Another way in which PCRE2 and Perl used to differ in their recursion
processing is in the handling of captured values. Formerly in Perl, when a
group was called recursively or as a subroutine (see <a href="re.html#sect23">Groups as Subroutines</a>), it
had no access to any values that were captured outside the recursion, whereas
in PCRE2 these values can be referenced. Consider this pattern:</p><pre><code class="text">^(.)(\1|a(?2))</code></pre><p>This pattern matches &quot;bab&quot;. The first capturing parentheses match &quot;b&quot;, then in
the second group, when the backreference <code class="inline">\1</code> fails to match &quot;b&quot;, the second
alternative matches &quot;a&quot; and then recurses. In the recursion, <code class="inline">\1</code> does now match
&quot;b&quot; and so the whole match succeeds. This match used to fail in Perl, but in
later versions (I tried 5.024) it now works.</p><p><a href="" id="sect23"></a></p><h2 id="module-groups-as-subroutines" class="section-heading"><a href="#module-groups-as-subroutines" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Groups as Subroutines</span></h2><p>If the syntax for a recursive group call (either by number or by name) is used
outside the parentheses to which it refers, it operates a bit like a subroutine
in a programming language. More accurately, PCRE2 treats the referenced group
as an independent subpattern which it tries to match at the current matching
position. The called group may be defined before or after the reference. A
numbered reference can be absolute or relative, as in these examples:</p><pre><code class="text">(...(absolute)...)...(?2)...
(...(relative)...)...(?-1)...
(...(?+1)...(relative)...</code></pre><p>An earlier example pointed out that the pattern</p><pre><code class="text">(sens|respons)e and \1ibility</code></pre><p>matches &quot;sense and sensibility&quot; and &quot;response and responsibility&quot;, but not
&quot;sense and responsibility&quot;. If instead the pattern</p><pre><code class="text">(sens|respons)e and (?1)ibility</code></pre><p>is used, it does match &quot;sense and responsibility&quot; as well as the other two
strings. Another example is given in the discussion of DEFINE above.</p><p>Like recursions, subroutine calls used to be treated as atomic, but this
changed at PCRE2 release 10.30, so backtracking into subroutine calls can now
occur. However, any capturing parentheses that are set during the subroutine
call revert to their previous values afterwards.</p><p>Processing options such as case-independence are fixed when a group is
defined, so if it is used as a subroutine, such options cannot be changed for
different calls. For example, consider this pattern:</p><pre><code class="text">(abc)(?i:(?-1))</code></pre><p>It matches &quot;abcabc&quot;. It does not match &quot;abcABC&quot; because the change of
processing option does not affect the called group.</p><p>The behaviour of
backtracking control verbs
in groups when called as subroutines is described in
<a href="re.html#sect25.1">Backtracking verbs in subroutines</a>.</p><p><a href="" id="sect24"></a></p><h2 id="module-oniguruma-subroutine-syntax" class="section-heading"><a href="#module-oniguruma-subroutine-syntax" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Oniguruma Subroutine Syntax</span></h2><p>For compatibility with Oniguruma, the non-Perl syntax <code class="inline">\g</code> followed by a name or
a number enclosed either in angle brackets or single quotes, is an alternative
syntax for calling a group as a subroutine, possibly recursively. Here are two
of the examples used above, rewritten using this syntax:</p><pre><code class="text">(?&lt;pn&gt; \( (  (?&gt;[^()]+) |  \g&lt;pn&gt; )* \) )
(sens|respons)e and \g'1'ibility</code></pre><p>PCRE2 supports an extension to Oniguruma: if a number is preceded by a
plus or a minus sign it is taken as a relative reference. For example:</p><pre><code class="text">(abc)(?i:\g&lt;-1&gt;)</code></pre><p>Note that <code class="inline">\g{...}</code> (Perl syntax) and \g&lt;...&gt; (Oniguruma syntax) are <em>not</em>
synonymous. The former is a backreference; the latter is a subroutine call.</p><p><a href="" id="sect25"></a></p><h2 id="module-backtracking-control" class="section-heading"><a href="#module-backtracking-control" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Backtracking Control</span></h2><p>There are a number of special &quot;Backtracking Control Verbs&quot; (to use Perl's
terminology) that modify the behaviour of backtracking during matching. They
are generally of the form <code class="inline">(*VERB)</code> or <code class="inline">(*VERB:NAME)</code>. Some verbs take either form,
and may behave differently depending on whether or not a name argument is
present. The names are not required to be unique within the pattern.</p><p>By default, for compatibility with Perl, a name is any sequence of characters
that does not include a closing parenthesis. The name is not processed in
any way, and it is not possible to include a closing parenthesis in the name.</p><p>A closing parenthesis can be included in a name either as <code class="inline">\)</code> or between <code class="inline">\Q</code>
and <code class="inline">\E</code>. In addition to backslash processing, if the <code class="inline">extended</code> or
PCRE2_EXTENDED_MORE option is also set, unescaped whitespace in verb names is
skipped, and #-comments are recognized, exactly as in the rest of the pattern.
<code class="inline">extended</code> and PCRE2_EXTENDED_MORE do not affect verb names.</p><p>The maximum length of a name is 255 in the 8-bit library. If the name is empty, that is, if the closing
parenthesis immediately follows the colon, the effect is as if the colon were
not there. Any number of these verbs may occur in a pattern. Except for
<code class="inline">(*ACCEPT)</code>, they may not be quantified.</p><p>Since these verbs are specifically related to backtracking, most of them can be
used only when the pattern is to be matched using the traditional matching
function, because it uses backtracking algorithms. With the exception
of <code class="inline">(*FAIL)</code>, which behaves like a failing negative assertion.</p><p>The behaviour of these verbs in repeated groups, assertions, and in
capture groups called as subroutines
(whether or not recursively) is documented below.</p><p><em>Optimizations that affect backtracking verbs</em></p><p>PCRE2 contains some optimizations that are used to speed up matching by running
some checks at the start of each match attempt. For example, it may know the
minimum length of matching subject, or that a particular character must be
present. When one of these optimizations bypasses the running of a match, any
included backtracking verbs will not, of course, be processed. You can suppress
the start-of-match optimizations by setting the <code class="inline">no_start_optimize</code> option
when calling <a href="#compile/2"><code class="inline">compile/2</code></a> or by starting the pattern with <code class="inline">(*NO_START_OPT)</code>.</p><p>Experiments with Perl suggest that it too has similar optimizations, and like
PCRE2, turning them off can change the result of a match.</p><p><em>Verbs that act immediately</em></p><p>The following verbs act as soon as they are encountered.</p><pre><code class="text">(*ACCEPT) or (*ACCEPT:NAME)</code></pre><p>This verb causes the match to end successfully, skipping the remainder of the
pattern. However, when it is inside a capture group that is called as a
subroutine, only that group is ended successfully. Matching then continues
at the outer level. If <code class="inline">(*ACCEPT)</code> in triggered in a positive assertion, the
assertion succeeds; in a negative assertion, the assertion fails.</p><p>If <code class="inline">(*ACCEPT)</code> is inside capturing parentheses, the data so far is captured. For
example:</p><pre><code class="text">A((?:A|B(*ACCEPT)|C)D)</code></pre><p>This matches &quot;AB&quot;, &quot;AAD&quot;, or &quot;ACD&quot;; when it matches &quot;AB&quot;, &quot;B&quot; is captured by
the outer parentheses.</p><p><code class="inline">(*ACCEPT)</code> is the only backtracking verb that is allowed to be quantified
because an ungreedy quantification with a minimum of zero acts only when a
backtrack happens. Consider, for example,</p><pre><code class="text">(A(*ACCEPT)??B)C</code></pre><p>where A, B, and C may be complex expressions. After matching &quot;A&quot;, the matcher
processes &quot;BC&quot;; if that fails, causing a backtrack, <code class="inline">(*ACCEPT)</code> is triggered and
the match succeeds. In both cases, all but C is captured. Whereas <code class="inline">(*COMMIT)</code>
(see below) means &quot;fail on backtrack&quot;, a repeated <code class="inline">(*ACCEPT)</code> of this type means
&quot;succeed on backtrack&quot;.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p><code class="inline">(*ACCEPT)</code> should not be used within a script run group, because
it causes an immediate exit from the group, bypassing the script run checking.</p></section><pre><code class="text">(*FAIL) or (*FAIL:NAME)</code></pre><p>This verb causes a matching failure, forcing backtracking to occur. It may be
abbreviated to <code class="inline">(*F)</code>. It is equivalent to <code class="inline">(?!)</code> but easier to read. The Perl
documentation notes that it is probably useful only when combined with <code class="inline">(?{})</code> or
<code class="inline">(??{})</code>. Those are, of course, Perl features that are not present in PCRE2. The
nearest equivalent is the callout feature, as for example in this pattern:</p><pre><code class="text">a+(?C)(*FAIL)</code></pre><p>A match with the string &quot;aaaa&quot; always fails, but the callout is taken before
each backtrack happens (in this example, 10 times).</p><p><code class="inline">(*ACCEPT:NAME)</code> and <code class="inline">(*FAIL:NAME)</code> behave the same as <code class="inline">(*MARK:NAME)(*ACCEPT)</code> and
<code class="inline">(*MARK:NAME)(*FAIL)</code>, respectively, that is, a <code class="inline">(*MARK)</code> is recorded just before
the verb acts.</p><p><em>Recording which path was taken</em></p><p>There is one verb whose main purpose is to track how a match was arrived at,
though it also has a secondary use in conjunction with advancing the match
starting point (see <code class="inline">(*SKIP)</code> below).</p><pre><code class="text">(*MARK:NAME) or (*:NAME)</code></pre><p>A name is always required with this verb. For all the other backtracking
control verbs, a NAME argument is optional.</p><p>When a match succeeds, the name of the last-encountered mark name on the
matching path is passed back to the caller as described in the section entitled
&quot;Other information about the match&quot;
in the
<code class="inline">pcre2api</code>
documentation. This applies to all instances of <code class="inline">(*MARK)</code> and other verbs,
including those inside assertions and atomic groups. However, there are
differences in those cases when <code class="inline">(*MARK)</code> is used in conjunction with <code class="inline">(*SKIP)</code> as
described below.</p><p>The mark name that was last encountered on the matching path is passed back. A
verb without a NAME argument is ignored for this purpose. Here is an example of
<code class="inline">pcre2test</code> output, where the &quot;mark&quot; modifier requests the retrieval and
outputting of <code class="inline">(*MARK)</code> data:</p><pre><code class="text">    re&gt; /X(*MARK:A)Y|X(*MARK:B)Z/mark
data&gt; XY
   0: XY
MK: A
XZ
   0: XZ
MK: B</code></pre><p>The <code class="inline">(*MARK)</code> name is tagged with &quot;MK:&quot; in this output, and in this example it
indicates which of the two alternatives matched. This is a more efficient way
of obtaining this information than putting each alternative in its own
capturing parentheses.</p><p>If a verb with a name is encountered in a positive assertion that is true, the
name is recorded and passed back if it is the last-encountered. This does not
happen for negative assertions or failing positive assertions.</p><p>After a partial match or a failed match, the last encountered name in the
entire match process is returned. For example:</p><pre><code class="text">    re&gt; /X(*MARK:A)Y|X(*MARK:B)Z/mark
data&gt; XP
No match, mark `=`  B</code></pre><p>Note that in this unanchored example the mark is retained from the match
attempt that started at the letter &quot;X&quot; in the subject. Subsequent match
attempts starting at &quot;P&quot; and then with an empty string do not get as far as the
<code class="inline">(*MARK)</code> item, but nevertheless do not reset it.</p><p>If you are interested in <code class="inline">(*MARK)</code> values after failed matches, you should
probably either set the <code class="inline">no_start_optimize</code> option
to ensure that the match is always attempted.</p><p><em>Verbs that act after backtracking</em></p><p>The following verbs do nothing when they are encountered. Matching continues
with what follows, but if there is a subsequent match failure, causing a
backtrack to the verb, a failure is forced. That is, backtracking cannot pass
to the left of the verb. However, when one of these verbs appears inside an
atomic group or in an atomic lookaround assertion that is true, its effect is
confined to that group, because once the group has been matched, there is never
any backtracking into it. Backtracking from beyond an atomic assertion or group
ignores the entire group, and seeks a preceding backtracking point.</p><p>These verbs differ in exactly what kind of failure occurs when backtracking
reaches them. The behaviour described below is what happens when the verb is
not in a subroutine or an assertion. Subsequent sections cover these special
cases.</p><pre><code class="text">(*COMMIT) or (*COMMIT:NAME)</code></pre><p>This verb causes the whole match to fail outright if there is a later matching
failure that causes backtracking to reach it. Even if the pattern is
unanchored, no further attempts to find a match by advancing the starting point
take place. If <code class="inline">(*COMMIT)</code> is the only backtracking verb that is encountered,
once it has been passed <a href="#run/3"><code class="inline">run/3</code></a> is committed to finding a match at
the current starting point, or not at all. For example:</p><pre><code class="text">a+(*COMMIT)b</code></pre><p>This matches &quot;xxaab&quot; but not &quot;aacaab&quot;. It can be thought of as a kind of
dynamic anchor, or &quot;I've started, so I must finish.&quot;</p><p>The behaviour of <code class="inline">(*COMMIT:NAME)</code> is not the same as <code class="inline">(*MARK:NAME)(*COMMIT)</code>. It is
like <code class="inline">(*MARK:NAME)</code> in that the name is remembered for passing back to the
caller. However, <code class="inline">(*SKIP:NAME)</code> searches only for names that are set with
<code class="inline">(*MARK)</code>, ignoring those set by any of the other backtracking verbs.</p><p>If there is more than one backtracking verb in a pattern, a different one that
follows <code class="inline">(*COMMIT)</code> may be triggered first, so merely passing <code class="inline">(*COMMIT)</code> during a
match does not always guarantee that a match must be at this starting point.</p><p>Note that <code class="inline">(*COMMIT)</code> at the start of a pattern is not the same as an anchor,
unless PCRE2's start-of-match optimizations are turned off, as shown in this
output from <code class="inline">pcre2test</code>:</p><pre><code class="text">    re&gt; /(*COMMIT)abc/
data&gt; xyzabc
   0: abc
data&gt;
re&gt; /(*COMMIT)abc/no_start_optimize
data&gt; xyzabc
No match</code></pre><p>For the first pattern, PCRE2 knows that any match must start with &quot;a&quot;, so the
optimization skips along the subject to &quot;a&quot; before applying the pattern to the
first set of data. The match attempt then succeeds. The second pattern disables
the optimization that skips along to the first character. The pattern is now
applied starting at &quot;x&quot;, and so the <code class="inline">(*COMMIT)</code> causes the match to fail without
trying any other starting points.</p><pre><code class="text">(*PRUNE) or (*PRUNE:NAME)</code></pre><p>This verb causes the match to fail at the current starting position in the
subject if there is a later matching failure that causes backtracking to reach
it. If the pattern is unanchored, the normal &quot;bumpalong&quot; advance to the next
starting character then happens. Backtracking can occur as usual to the left of
<code class="inline">(*PRUNE)</code>, before it is reached, or when matching to the right of <code class="inline">(*PRUNE)</code>, but
if there is no match to the right, backtracking cannot cross <code class="inline">(*PRUNE)</code>. In
simple cases, the use of <code class="inline">(*PRUNE)</code> is just an alternative to an atomic group or
possessive quantifier, but there are some uses of <code class="inline">(*PRUNE)</code> that cannot be
expressed in any other way. In an anchored pattern <code class="inline">(*PRUNE)</code> has the same effect
as <code class="inline">(*COMMIT)</code>.</p><p>The behaviour of <code class="inline">(*PRUNE:NAME)</code> is not the same as <code class="inline">(*MARK:NAME)(*PRUNE)</code>. It is
like <code class="inline">(*MARK:NAME)</code> in that the name is remembered for passing back to the
caller. However, <code class="inline">(*SKIP:NAME)</code> searches only for names set with <code class="inline">(*MARK)</code>,
ignoring those set by other backtracking verbs.</p><pre><code class="text">(*SKIP)</code></pre><p>This verb, when given without a name, is like <code class="inline">(*PRUNE)</code>, except that if the
pattern is unanchored, the &quot;bumpalong&quot; advance is not to the next character,
but to the position in the subject where <code class="inline">(*SKIP)</code> was encountered. <code class="inline">(*SKIP)</code>
signifies that whatever text was matched leading up to it cannot be part of a
successful match if there is a later mismatch. Consider:</p><pre><code class="text">a+(*SKIP)b</code></pre><p>If the subject is &quot;aaaac...&quot;, after the first match attempt fails (starting at
the first character in the string), the starting point skips on to start the
next attempt at &quot;c&quot;. Note that a possessive quantifier does not have the same
effect as this example; although it would suppress backtracking during the
first match attempt, the second attempt would start at the second character
instead of skipping on to &quot;c&quot;.</p><p>If <code class="inline">(*SKIP)</code> is used to specify a new starting position that is the same as the
starting position of the current match, or (by being inside a lookbehind)
earlier, the position specified by <code class="inline">(*SKIP)</code> is ignored, and instead the normal
&quot;bumpalong&quot; occurs.</p><pre><code class="text">(*SKIP:NAME)</code></pre><p>When <code class="inline">(*SKIP)</code> has an associated name, its behaviour is modified. When such a
<code class="inline">(*SKIP)</code> is triggered, the previous path through the pattern is searched for the
most recent <code class="inline">(*MARK)</code> that has the same name. If one is found, the &quot;bumpalong&quot;
advance is to the subject position that corresponds to that <code class="inline">(*MARK)</code> instead of
to where <code class="inline">(*SKIP)</code> was encountered. If no <code class="inline">(*MARK)</code> with a matching name is found,
the <code class="inline">(*SKIP)</code> is ignored.</p><p>The search for a <code class="inline">(*MARK)</code> name uses the normal backtracking mechanism, which
means that it does not see <code class="inline">(*MARK)</code> settings that are inside atomic groups or
assertions, because they are never re-entered by backtracking. Compare the
following <code class="inline">pcre2test</code> examples:</p><pre><code class="text">    re&gt; /a(?&gt;(*MARK:X))(*SKIP:X)(*F)|(.)/
data: abc
   0: a
   1: a
data:
    re&gt; /a(?:(*MARK:X))(*SKIP:X)(*F)|(.)/
data: abc
   0: b
   1: b</code></pre><p>In the first example, the <code class="inline">(*MARK)</code> setting is in an atomic group, so it is not
seen when <code class="inline">(*SKIP:X)</code> triggers, causing the <code class="inline">(*SKIP)</code> to be ignored. This allows
the second branch of the pattern to be tried at the first character position.
In the second example, the <code class="inline">(*MARK)</code> setting is not in an atomic group. This
allows <code class="inline">(*SKIP:X)</code> to find the <code class="inline">(*MARK)</code> when it backtracks, and this causes a new
matching attempt to start at the second character. This time, the <code class="inline">(*MARK)</code> is
never seen because &quot;a&quot; does not match &quot;b&quot;, so the matcher immediately jumps to
the second branch of the pattern.</p><p>Note that <code class="inline">(*SKIP:NAME)</code> searches only for names set by <code class="inline">(*MARK:NAME)</code>. It ignores
names that are set by other backtracking verbs.</p><pre><code class="text">(*THEN) or (*THEN:NAME)</code></pre><p>This verb causes a skip to the next innermost alternative when backtracking
reaches it. That is, it cancels any further backtracking within the current
alternative. Its name comes from the observation that it can be used for a
pattern-based if-then-else block:</p><pre><code class="text">( COND1 (*THEN) FOO |  COND2 (*THEN) BAR |  COND3 (*THEN) BAZ )  ...</code></pre><p>If the COND1 pattern matches, FOO is tried (and possibly further items after
the end of the group if FOO succeeds); on failure, the matcher skips to the
second alternative and tries COND2, without backtracking into COND1. If that
succeeds and BAR fails, COND3 is tried. If subsequently BAZ fails, there are no
more alternatives, so there is a backtrack to whatever came before the entire
group. If <code class="inline">(*THEN)</code> is not inside an alternation, it acts like <code class="inline">(*PRUNE)</code>.</p><p>The behaviour of <code class="inline">(*THEN:NAME)</code> is not the same as <code class="inline">(*MARK:NAME)(*THEN)</code>. It is
like <code class="inline">(*MARK:NAME)</code> in that the name is remembered for passing back to the
caller. However, <code class="inline">(*SKIP:NAME)</code> searches only for names set with <code class="inline">(*MARK)</code>,
ignoring those set by other backtracking verbs.</p><p>A group that does not contain a <code class="inline">|</code>  character is just a part of the enclosing
alternative; it is not a nested alternation with only one alternative. The
effect of <code class="inline">(*THEN)</code> extends beyond such a group to the enclosing alternative.
Consider this pattern, where A, B, etc. are complex pattern fragments that do
not contain any <code class="inline">|</code>  characters at this level:</p><pre><code class="text">A (B(*THEN)C) |  D</code></pre><p>If A and B are matched, but there is a failure in C, matching does not
backtrack into A; instead it moves to the next alternative, that is, D.
However, if the group containing <code class="inline">(*THEN)</code> is given an alternative, it
behaves differently:</p><pre><code class="text">A (B(*THEN)C |  (*FAIL)) |  D</code></pre><p>The effect of <code class="inline">(*THEN)</code> is now confined to the inner group. After a failure in C,
matching moves to <code class="inline">(*FAIL)</code>, which causes the whole group to fail because there
are no more alternatives to try. In this case, matching does backtrack into A.</p><p>Note that a conditional group is not considered as having two alternatives,
because only one is ever used. In other words, the <code class="inline">|</code>  character in a conditional
group has a different meaning. Ignoring white space, consider:</p><pre><code class="text">^.*? (?(?=a) a |  b(*THEN)c )</code></pre><p>If the subject is &quot;ba&quot;, this pattern does not match. Because <code class="inline">.*?</code> is ungreedy,
it initially matches zero characters. The condition (?=a) then fails, the
character &quot;b&quot; is matched, but &quot;c&quot; is not. At this point, matching does not
backtrack to .<em>? as might perhaps be expected from the presence of the |
character. The conditional group is part of the single alternative that
comprises the whole pattern, and so the match fails. (If there was a backtrack
into `.</em>?`, allowing it to match &quot;b&quot;, the match would succeed.)</p><p>The verbs just described provide four different &quot;strengths&quot; of control when
subsequent matching fails. <code class="inline">(*THEN)</code> is the weakest, carrying on the match at the
next alternative. <code class="inline">(*PRUNE)</code> comes next, failing the match at the current
starting position, but allowing an advance to the next character (for an
unanchored pattern). <code class="inline">(*SKIP)</code> is similar, except that the advance may be more
than one character. <code class="inline">(*COMMIT)</code> is the strongest, causing the entire match to
fail.</p><p><em>More than one backtracking verb</em></p><p>If more than one backtracking verb is present in a pattern, the one that is
backtracked onto first acts. For example, consider this pattern, where A, B,
etc. are complex pattern fragments:</p><pre><code class="text">(A(*COMMIT)B(*THEN)C|ABD)</code></pre><p>If A matches but B fails, the backtrack to <code class="inline">(*COMMIT)</code> causes the entire match to
fail. However, if A and B match, but C fails, the backtrack to <code class="inline">(*THEN)</code> causes
the next alternative (ABD) to be tried. This behaviour is consistent, but is
not always the same as Perl's. It means that if two or more backtracking verbs
appear in succession, all but the last of them has no effect. Consider this
example:</p><pre><code class="text">...(*COMMIT)(*PRUNE)...</code></pre><p>If there is a matching failure to the right, backtracking onto <code class="inline">(*PRUNE)</code> causes
it to be triggered, and its action is taken. There can never be a backtrack
onto <code class="inline">(*COMMIT)</code>.</p><p><em>Backtracking verbs in repeated groups</em></p><p>PCRE2 sometimes differs from Perl in its handling of backtracking verbs in
repeated groups. For example, consider:</p><pre><code class="text">/(a(*COMMIT)b)+ac/</code></pre><p>If the subject is &quot;abac&quot;, Perl matches unless its optimizations are disabled,
but PCRE2 always fails because the <code class="inline">(*COMMIT)</code> in the second repeat of the group
acts.</p><p><em>Backtracking verbs in assertions</em></p><p><code class="inline">(*FAIL)</code> in any assertion has its normal effect: it forces an immediate
backtrack. The behaviour of the other backtracking verbs depends on whether or
not the assertion is standalone or acting as the condition in a conditional
group.</p><p><code class="inline">(*ACCEPT)</code> in a standalone positive assertion causes the assertion to succeed
without any further processing; captured strings and a mark name (if set) are
retained. In a standalone negative assertion, <code class="inline">(*ACCEPT)</code> causes the assertion to
fail without any further processing; captured substrings and any mark name are
discarded.</p><p>If the assertion is a condition, <code class="inline">(*ACCEPT)</code> causes the condition to be true for
a positive assertion and false for a negative one; captured substrings are
retained in both cases.</p><p>The remaining verbs act only when a later failure causes a backtrack to
reach them. This means that, for the Perl-compatible assertions, their effect
is confined to the assertion, because Perl lookaround assertions are atomic. A
backtrack that occurs after such an assertion is complete does not jump back
into the assertion. Note in particular that a <code class="inline">(*MARK)</code> name that is set in an
assertion is not &quot;seen&quot; by an instance of <code class="inline">(*SKIP:NAME)</code> later in the pattern.</p><p>PCRE2 now supports non-atomic positive assertions and also &quot;scan substring&quot;
assertions, as described in the sections entitled
&quot;Non-atomic assertions&quot;
and
&quot;Scan substring assertions&quot;
above. These assertions must be standalone (not used as conditions). They are
not Perl-compatible. For these assertions, a later backtrack does jump back
into the assertion, and therefore verbs such as <code class="inline">(*COMMIT)</code> can be triggered by
backtracks from later in the pattern.</p><p>The effect of <code class="inline">(*THEN)</code> is not allowed to escape beyond an assertion. If there
are no more branches to try, <code class="inline">(*THEN)</code> causes a positive assertion to be false,
and a negative assertion to be true. This behaviour differs from Perl when the
assertion has only one branch.</p><p>The other backtracking verbs are not treated specially if they appear in a
standalone positive assertion. In a conditional positive assertion,
backtracking (from within the assertion) into <code class="inline">(*COMMIT)</code>, <code class="inline">(*SKIP)</code>, or <code class="inline">(*PRUNE)</code>
causes the condition to be false. However, for both standalone and conditional
negative assertions, backtracking into <code class="inline">(*COMMIT)</code>, <code class="inline">(*SKIP)</code>, or <code class="inline">(*PRUNE)</code> causes
the assertion to be true, without considering any further alternative branches.</p><p><a href="" id="sect25.1"></a>
<em>Backtracking verbs in subroutines</em></p><p>These behaviours occur whether or not the group is called recursively.</p><p><code class="inline">(*ACCEPT)</code> in a group called as a subroutine causes the subroutine match to
succeed without any further processing. Matching then continues after the
subroutine call. Perl documents this behaviour. Perl's treatment of the other
verbs in subroutines is different in some cases.</p><p><code class="inline">(*FAIL)</code> in a group called as a subroutine has its normal effect: it forces
an immediate backtrack.</p><p><code class="inline">(*COMMIT)</code>, <code class="inline">(*SKIP)</code>, and <code class="inline">(*PRUNE)</code> cause the subroutine match to fail when
triggered by being backtracked to in a group called as a subroutine. There is
then a backtrack at the outer level.</p><p><code class="inline">(*THEN)</code>, when triggered, skips to the next alternative in the innermost
enclosing group that has alternatives (its normal behaviour). However, if there
is no such group within the subroutine's group, the subroutine match fails and
there is a backtrack at the outer level.</p>
    </section>

</div>

  <section id="summary" class="details-list">
    <h1 class="section-heading">
      <a class="hover-link" href="#summary">
        <i class="ri-link-m" aria-hidden="true"></i>
      </a>
      <span class="text">Summary</span>
    </h1>
<div class="summary-types summary">
  <h2>
    <a href="#types">Types</a>
  </h2>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:capture/0" data-no-tooltip="" translate="no">capture()</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:compile_option/0" data-no-tooltip="" translate="no">compile_option()</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:compile_options/0" data-no-tooltip="" translate="no">compile_options()</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:exported/0" data-no-tooltip="" translate="no">exported()</a>

      </div>

        <div class="summary-synopsis"><p>Opaque data type containing an <a>exported</a> compiled regular
expression.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:mp/0" data-no-tooltip="" translate="no">mp()</a>

      </div>

        <div class="summary-synopsis"><p>Opaque data type containing a compiled regular expression.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:nl_spec/0" data-no-tooltip="" translate="no">nl_spec()</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:option/0" data-no-tooltip="" translate="no">option()</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:options/0" data-no-tooltip="" translate="no">options()</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:replace_fun/0" data-no-tooltip="" translate="no">replace_fun()</a>

      </div>

    </div>

</div>
<div class="summary-functions summary">
  <h2>
    <a href="#functions">Functions</a>
  </h2>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#compile/1" data-no-tooltip="" translate="no">compile(Regexp)</a>

      </div>

        <div class="summary-synopsis"><p>The same as <a><code class="inline">compile(Regexp,[])</code></a></p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#compile/2" data-no-tooltip="" translate="no">compile(Regexp, Options)</a>

      </div>

        <div class="summary-synopsis"><p>Compiles a regular expression, with the syntax described below, into an internal
format to be used later as a parameter to <a><code class="inline">run/2</code></a> and <a><code class="inline">run/3</code></a>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#import/1" data-no-tooltip="" translate="no">import(Exported)</a>

      </div>

        <div class="summary-synopsis"><p>Imports a regular expression compiled with option <a><code class="inline">export</code></a>. The
importing is cheap if the importing node is compatible enough to the exporting
node. If incompatible, as a fallback the <a><code class="inline">import/1</code></a> function will re-compile the regular
expression from its string format, which is included in
<a><code class="inline">exported()</code></a>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#inspect/2" data-no-tooltip="" translate="no">inspect(MP, Item)</a>

      </div>

        <div class="summary-synopsis"><p>Takes a compiled regular expression and an item, and returns the relevant data
from the regular expression.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#replace/3" data-no-tooltip="" translate="no">replace(Subject, RE, Replacement)</a>

      </div>

        <div class="summary-synopsis"><p>Equivalent to <a><code class="inline">replace(Subject, RE, Replacement, [])</code></a>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#replace/4" data-no-tooltip="" translate="no">replace(Subject, RE, Replacement, Options)</a>

      </div>

        <div class="summary-synopsis"><p>Replaces the matched part of the <code class="inline">Subject</code> string with <code class="inline">Replacement</code>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#run/2" data-no-tooltip="" translate="no">run(Subject, RE)</a>

      </div>

        <div class="summary-synopsis"><p>Equivalent to <a><code class="inline">run(Subject, RE, [])</code></a>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#run/3" data-no-tooltip="" translate="no">run(Subject, RE, Options)</a>

      </div>

        <div class="summary-synopsis"><p>Executes a regular expression matching, and returns <code class="inline">match/{match, Captured}</code> or
<code class="inline">nomatch</code>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#split/2" data-no-tooltip="" translate="no">split(Subject, RE)</a>

      </div>

        <div class="summary-synopsis"><p>Equivalent to <a><code class="inline">split(Subject, RE, [])</code></a>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#split/3" data-no-tooltip="" translate="no">split(Subject, RE, Options)</a>

      </div>

        <div class="summary-synopsis"><p>Splits the input into parts by finding tokens according to the regular
expression supplied.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#version/0" data-no-tooltip="" translate="no">version()</a>

      </div>

        <div class="summary-synopsis"><p>The return of this function is a string with the PCRE version of the system that
was used in the Erlang/OTP compilation.</p></div>

    </div>

</div>

  </section>


  <section id="types" class="details-list">
    <h1 class="section-heading">
      <a class="hover-link" href="#types">
        <i class="ri-link-m" aria-hidden="true"></i>
      </a>
      <span class="text">Types</span>
    </h1>
    <div class="types-list">
<section class="detail" id="t:capture/0">

  <div class="detail-header">
    <a href="#t:capture/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">capture()</h1>

        <span class="note">(not exported)</span>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L83" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> capture() ::
          all | all_but_first | all_names | first | none |
          (ValueList :: [<a href="../../apps/erts/erlang.html#t:integer/0">integer</a>() | <a href="../../apps/erts/erlang.html#t:string/0">string</a>() | <a href="../../apps/erts/erlang.html#t:atom/0">atom</a>()]).</pre>

      </div>


  </section>
</section>
<section class="detail" id="t:compile_option/0">

  <div class="detail-header">
    <a href="#t:compile_option/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">compile_option()</h1>

        <span class="note">(not exported)</span>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L67" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> compile_option() ::
          unicode | anchored | caseless | dollar_endonly | dotall | extended | firstline | multiline |
          no_auto_capture | dupnames | ungreedy |
          {newline, <a href="#t:nl_spec/0">nl_spec</a>()} |
          bsr_anycrlf | bsr_unicode | no_start_optimize | ucp | never_utf.</pre>

      </div>


  </section>
</section>
<section class="detail" id="t:compile_options/0">

  <div class="detail-header">
    <a href="#t:compile_options/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">compile_options()</h1>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L66" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> compile_options() :: [<a href="#t:compile_option/0">compile_option</a>()].</pre>

      </div>


  </section>
</section>
<section class="detail" id="t:exported/0">

  <div class="detail-header">
    <a href="#t:exported/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">exported()</h1>

        <span class="note">(not exported)</span>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L62" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> exported() :: {re_exported_pattern, _, _, _, _}.</pre>

      </div>

<p>Opaque data type containing an <a href="#EXPORT_OPT">exported</a> compiled regular
expression.</p><p>Type <code class="inline">exported()</code> is guaranteed to be a tuple having the atom
<code class="inline">re_exported_pattern</code> as its first element to allow for matching in guards. The
arity of the tuple or the content of the other fields can change in future
Erlang/OTP releases.</p>
  </section>
</section>
<section class="detail" id="t:mp/0">

  <div class="detail-header">
    <a href="#t:mp/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">mp()</h1>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L51" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> mp() :: {re_pattern, _, _, _, _}.</pre>

      </div>

<p>Opaque data type containing a compiled regular expression.</p><p>A compiled regular expression of this type can only be executed on the node
instance where it was compiled.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>Before Erlang/OTP 28, it was possible to abuse <code class="inline">mp()</code> and execute such terms
on nodes other than the one where they were compiled. This was unsafe, as it only
worked if the two nodes were sufficiently compatible (hardware and software), and
executing incompatible <code class="inline">mp()</code> terms could lead to unpleasant side effects.</p><p>From Erlang/OTP 28 this unsafe abuse is no longer possible. Instead use the
possibility to safely <a href="#EXPORT_OPT">export</a> and <a href="#import/1">import</a>
compiled regular expressions between nodes.</p></section><p>Type <code class="inline">mp()</code> is guaranteed to be a tuple having the atom <code class="inline">re_pattern</code> as its
first element to allow for matching in guards. The arity of the tuple or the
content of the other fields can change in future Erlang/OTP releases.</p>
  </section>
</section>
<section class="detail" id="t:nl_spec/0">

  <div class="detail-header">
    <a href="#t:nl_spec/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">nl_spec()</h1>

        <span class="note">(not exported)</span>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L64" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> nl_spec() :: cr | crlf | lf | nul | anycrlf | any.</pre>

      </div>


  </section>
</section>
<section class="detail" id="t:option/0">

  <div class="detail-header">
    <a href="#t:option/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">option()</h1>

        <span class="note">(not exported)</span>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L75" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> option() ::
          anchored | global | notbol | noteol | notempty | notempty_atstart | report_errors |
          {offset, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
          {match_limit, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
          {match_limit_recursion, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
          {capture, ValueSpec :: <a href="#t:capture/0">capture</a>()} |
          {capture, ValueSpec :: <a href="#t:capture/0">capture</a>(), Type :: index | list | binary} |
          <a href="#t:compile_option/0">compile_option</a>().</pre>

      </div>


  </section>
</section>
<section class="detail" id="t:options/0">

  <div class="detail-header">
    <a href="#t:options/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">options()</h1>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L74" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> options() :: [<a href="#t:option/0">option</a>()].</pre>

      </div>


  </section>
</section>
<section class="detail" id="t:replace_fun/0">

  <div class="detail-header">
    <a href="#t:replace_fun/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">replace_fun()</h1>

        <span class="note">(not exported)</span>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L86" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> replace_fun() :: fun((<a href="../../apps/erts/erlang.html#t:binary/0">binary</a>(), [<a href="../../apps/erts/erlang.html#t:binary/0">binary</a>()]) -> <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>()).</pre>

      </div>


  </section>
</section>

    </div>
  </section>

  <section id="functions" class="details-list">
    <h1 class="section-heading">
      <a class="hover-link" href="#functions">
        <i class="ri-link-m" aria-hidden="true"></i>
      </a>
      <span class="text">Functions</span>
    </h1>
    <div class="functions-list">
<section class="detail" id="compile/1">

  <div class="detail-header">
    <a href="#compile/1" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">compile(Regexp)</h1>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L128" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> compile(Regexp) -> {ok, <a href="#t:mp/0">mp</a>()} | {error, ErrSpec}
                 when
                     Regexp :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>(),
                     ErrSpec :: {ErrString :: <a href="../../apps/erts/erlang.html#t:string/0">string</a>(), Position :: <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()}.</pre>

      </div>

<p>The same as <a href="#compile/2"><code class="inline">compile(Regexp,[])</code></a></p>
  </section>
</section>
<section class="detail" id="compile/2">

  <div class="detail-header">
    <a href="#compile/2" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">compile(Regexp, Options)</h1>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L288" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> compile(Regexp, Options) -> {ok, <a href="#t:mp/0">mp</a>() | <a href="#t:exported/0">exported</a>()} | {error, ErrSpec}
                 when
                     Regexp :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                     Options :: [Option],
                     Option :: <a href="#t:compile_option/0">compile_option</a>() | export,
                     ErrSpec :: {ErrString :: <a href="../../apps/erts/erlang.html#t:string/0">string</a>(), Position :: <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()}.</pre>

      </div>

<p>Compiles a regular expression, with the syntax described below, into an internal
format to be used later as a parameter to <a href="#run/2"><code class="inline">run/2</code></a> and <a href="#run/3"><code class="inline">run/3</code></a>.</p><p>Compiling the regular expression before matching is useful if the same
expression is to be used in matching against multiple subjects during the
lifetime of the program. Compiling once and executing many times is far more
efficient than compiling each time one wants to match.</p><p>When option <code class="inline">unicode</code> is specified, the regular expression is to be specified as
a valid Unicode <code class="inline">charlist()</code>, otherwise as any valid <a href="../../apps/erts/erlang.html#t:iodata/0"><code class="inline">iodata/0</code></a>.</p><p><a href="" id="compile_options"></a></p><p>Options:</p><ul><li><p><strong><code class="inline">unicode</code></strong> - The regular expression is specified as a Unicode <code class="inline">charlist()</code>
and the resulting regular expression code is to be run against a valid Unicode
<code class="inline">charlist()</code> subject. Also consider option <code class="inline">ucp</code> when using Unicode
characters.</p></li><li><p><strong><code class="inline">anchored</code></strong> - The pattern is forced to be &quot;anchored&quot;, that is, it is
constrained to match only at the first matching point in the string that is
searched (the &quot;subject string&quot;). This effect can also be achieved by
appropriate constructs in the pattern itself.</p></li><li><p><strong><code class="inline">caseless</code></strong> - Letters in the pattern match both uppercase and lowercase
letters. It is equivalent to Perl option <code class="inline">/i</code> and can be changed within a
pattern by a <code class="inline">(?i)</code> option setting. Uppercase and lowercase letters are
defined as in the ISO 8859-1 character set.</p></li><li><p><strong><code class="inline">dollar_endonly</code></strong> - A dollar metacharacter in the pattern matches only at
the end of the subject string. Without this option, a dollar also matches
immediately before a newline at the end of the string (but not before any
other newlines). This option is ignored if option <code class="inline">multiline</code> is specified.
There is no equivalent option in Perl, and it cannot be set within a pattern.</p></li><li><p><strong><code class="inline">dotall</code></strong> - A dot in the pattern matches all characters, including those
indicating newline. Without it, a dot does not match when the current position
is at a newline. This option is equivalent to Perl option <code class="inline">/s</code> and it can be
changed within a pattern by a <code class="inline">(?s)</code> option setting. A negative class, such as
<code class="inline">[^a]</code>, always matches newline characters, independent of the setting of this
option.</p></li><li><p><strong><code class="inline">extended</code></strong> - If this option is set, most white space characters in the
pattern are totally ignored except when escaped or inside a character class.
However, white space is not allowed within sequences such as <code class="inline">(?&gt;</code> that
introduce various parenthesized subpatterns, nor within a numerical quantifier
such as <code class="inline">{1,3}</code>. However, ignorable white space is permitted between an item
and a following quantifier and between a quantifier and a following + that
indicates possessiveness.</p><p>White space did not used to include the VT character (code 11), because Perl
did not treat this character as white space. However, Perl changed at release
5.18, so PCRE followed at release 8.34, and VT is now treated as white space.</p><p>This also causes characters between an unescaped # outside a character class
and the next newline, inclusive, to be ignored. This is equivalent to Perl's
<code class="inline">/x</code> option, and it can be changed within a pattern by a <code class="inline">(?x)</code> option
setting.</p><p>With this option, comments inside complicated patterns can be included.
However, notice that this applies only to data characters. Whitespace
characters can never appear within special character sequences in a pattern,
for example within sequence <code class="inline">(?(</code> that introduces a conditional subpattern.</p></li><li><p><strong><code class="inline">firstline</code></strong> - An unanchored pattern is required to match before or at the
first newline in the subject string, although the matched text can continue
over the newline.</p></li><li><p><strong><code class="inline">multiline</code></strong> - By default, PCRE treats the subject string as consisting of
a single line of characters (even if it contains newlines). The &quot;start of
line&quot; metacharacter (<code class="inline">^</code>) matches only at the start of the string, while the
&quot;end of line&quot; metacharacter (<code class="inline">$</code>) matches only at the end of the string, or
before a terminating newline (unless option <code class="inline">dollar_endonly</code> is specified).
This is the same as in Perl.</p><p>When this option is specified, the &quot;start of line&quot; and &quot;end of line&quot;
constructs match immediately following or immediately before internal newlines
in the subject string, respectively, as well as at the very start and end.
This is equivalent to Perl option <code class="inline">/m</code> and can be changed within a pattern by
a <code class="inline">(?m)</code> option setting. If there are no newlines in a subject string, or no
occurrences of <code class="inline">^</code> or <code class="inline">$</code> in a pattern, setting <code class="inline">multiline</code> has no effect.</p></li><li><p><strong><code class="inline">no_auto_capture</code></strong> - Disables the use of numbered capturing parentheses in
the pattern. Any opening parenthesis that is not followed by <code class="inline">?</code> behaves as if
it is followed by <code class="inline">?:</code>. Named parentheses can still be used for capturing (and
they acquire numbers in the usual way). There is no equivalent option in Perl.</p></li><li><p><strong><code class="inline">dupnames</code></strong> - Names used to identify capturing subpatterns need not be
unique. This can be helpful for certain types of pattern when it is known that
only one instance of the named subpattern can ever be matched. More details of
named subpatterns are provided below.</p></li><li><p><strong><code class="inline">ungreedy</code></strong> - Inverts the &quot;greediness&quot; of the quantifiers so that they are
not greedy by default, but become greedy if followed by &quot;?&quot;. It is not
compatible with Perl. It can also be set by a <code class="inline">(?U)</code> option setting within the
pattern.</p></li><li><p><strong><code class="inline">{newline, NLSpec}</code></strong> - Overrides the default definition of a newline in the
subject string, which is LF (ASCII 10) in Erlang.</p><ul><li><p><strong><code class="inline">cr</code></strong> - Newline is indicated by a single character <code class="inline">cr</code> (ASCII 13).</p></li><li><p><strong><code class="inline">lf</code></strong> - Newline is indicated by a single character LF (ASCII 10), the
default.</p></li><li><p><strong><code class="inline">nul</code></strong> - Newline is indicated by a single character NUL (ASCII 0).</p></li><li><p><strong><code class="inline">crlf</code></strong> - Newline is indicated by the two-character CRLF (ASCII 13
followed by ASCII 10) sequence.</p></li><li><p><strong><code class="inline">anycrlf</code></strong> - Any of the three preceding sequences is to be recognized.</p></li><li><p><strong><code class="inline">any</code></strong> - Any of the newline sequences above, and the Unicode sequences VT
(vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS
(line separator, U+2028), and PS (paragraph separator, U+2029).</p></li></ul></li><li><p><strong><code class="inline">bsr_anycrlf</code></strong> - Specifies specifically that \R is to match only the CR,
LF, or CRLF sequences, not the Unicode-specific newline characters.</p></li><li><p><strong><code class="inline">bsr_unicode</code></strong> - Specifies specifically that \R is to match all the
Unicode newline characters (including CRLF, and so on, the default).</p></li><li><p><strong><code class="inline">no_start_optimize</code></strong> - Disables optimization that can malfunction if
&quot;Special start-of-pattern items&quot; are present in the regular expression. A
typical example would be when matching &quot;DEFABC&quot; against &quot;(<em>COMMIT)ABC&quot;, where
the start optimization of PCRE would skip the subject up to &quot;A&quot; and never
realize that the (</em>COMMIT) instruction is to have made the matching fail. This
option is only relevant if you use &quot;start-of-pattern items&quot;, as discussed in
section <a href="re.html#module-pcre2-regular-expression-details">PCRE Regular Expression Details</a>.</p></li><li><p><strong><code class="inline">ucp</code></strong> - Specifies that Unicode character properties are to be used when
resolving \B, \b, \D, \d, \S, \s, \W and \w. Without this flag, only
ISO Latin-1 properties are used. Using Unicode properties hurts performance,
but is semantically correct when working with Unicode characters beyond the
ISO Latin-1 range.</p></li><li><p><strong><code class="inline">never_utf</code></strong> - Specifies that the (<em>UTF) and/or (</em>UTF8) &quot;start-of-pattern
items&quot; are forbidden. This flag cannot be combined with option <code class="inline">unicode</code>.
Useful if ISO Latin-1 patterns from an external source are to be compiled.</p></li><li><p><a href="" id="EXPORT_OPT"></a><strong><code class="inline">export</code></strong> - Returns the compiled regular expression in
a format <a href="#t:exported/0"><code class="inline">exported()</code></a> that can be imported into any node
instance. Normally, a compiled regex can only be executed by the node instance
that compiled it. With option <code class="inline">export</code> the returned term can be communicated
(in any way) to any node. The receiving node must import it by calling
<a href="#import/1"><code class="inline">import/1</code></a> to get a compiled regular expression executable on that local node.</p><p>Option <code class="inline">export</code> and function <a href="#import/1"><code class="inline">import/1</code></a> are supported since OTP 28.1.</p></li></ul>
  </section>
</section>
<section class="detail" id="import/1">

  <div class="detail-header">
    <a href="#import/1" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">import(Exported)</h1>

        <span class="note">(since OTP 28.1)</span>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L105" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> import(Exported :: <a href="#t:exported/0">exported</a>()) -> <a href="#t:mp/0">mp</a>().</pre>

      </div>

<p>Imports a regular expression compiled with option <a href="#EXPORT_OPT"><code class="inline">export</code></a>. The
importing is cheap if the importing node is compatible enough to the exporting
node. If incompatible, as a fallback the <a href="#import/1"><code class="inline">import/1</code></a> function will re-compile the regular
expression from its string format, which is included in
<a href="#t:exported/0"><code class="inline">exported()</code></a>.</p>
  </section>
</section>
<section class="detail" id="inspect/2">

  <div class="detail-header">
    <a href="#inspect/2" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">inspect(MP, Item)</h1>

        <span class="note">(since OTP 17.0)</span>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L902" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> inspect(MP, Item) -> {namelist, [<a href="../../apps/erts/erlang.html#t:binary/0">binary</a>()]} when MP :: <a href="#t:mp/0">mp</a>(), Item :: namelist.</pre>

      </div>

<p>Takes a compiled regular expression and an item, and returns the relevant data
from the regular expression.</p><p>The only supported item is <code class="inline">namelist</code>, which returns the tuple <code class="inline">{namelist, [binary()]}</code>,
containing the names of all (unique) named subpatterns in the regular expression.</p><p>For example:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="0561067030-1">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">MP</span><span class="p" data-group-id="0561067030-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">re</span><span class="p">:</span><span class="nf">compile</span><span class="p" data-group-id="0561067030-2">(</span><span class="s">&quot;(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;</span><span class="p" data-group-id="0561067030-2">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="0561067030-3">{</span><span class="ss">ok</span><span class="p">,</span><span class="p" data-group-id="0561067030-4">{</span><span class="ss">re_pattern</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w">
                </span><span class="p" data-group-id="0561067030-5">&lt;&lt;</span><span class="mi">69</span><span class="p">,</span><span class="mi">82</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">119</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="w">
                  </span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="0561067030-5">&gt;&gt;</span><span class="p" data-group-id="0561067030-4">}</span><span class="p" data-group-id="0561067030-3">}</span><span class="gp unselectable">
2&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">inspect</span><span class="p" data-group-id="0561067030-6">(</span><span class="n">MP</span><span class="p">,</span><span class="ss">namelist</span><span class="p" data-group-id="0561067030-6">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="0561067030-7">{</span><span class="ss">namelist</span><span class="p">,</span><span class="p" data-group-id="0561067030-8">[</span><span class="p" data-group-id="0561067030-9">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="0561067030-9">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="0561067030-10">&lt;&lt;</span><span class="s">&quot;B&quot;</span><span class="p" data-group-id="0561067030-10">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="0561067030-11">&lt;&lt;</span><span class="s">&quot;C&quot;</span><span class="p" data-group-id="0561067030-11">&gt;&gt;</span><span class="p" data-group-id="0561067030-8">]</span><span class="p" data-group-id="0561067030-7">}</span><span class="gp unselectable">
3&gt; </span><span class="p" data-group-id="0561067030-12">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">MPD</span><span class="p" data-group-id="0561067030-12">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">re</span><span class="p">:</span><span class="nf">compile</span><span class="p" data-group-id="0561067030-13">(</span><span class="s">&quot;(?&lt;C&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;</span><span class="p">,</span><span class="p" data-group-id="0561067030-14">[</span><span class="ss">dupnames</span><span class="p" data-group-id="0561067030-14">]</span><span class="p" data-group-id="0561067030-13">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="0561067030-15">{</span><span class="ss">ok</span><span class="p">,</span><span class="p" data-group-id="0561067030-16">{</span><span class="ss">re_pattern</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w">
                </span><span class="p" data-group-id="0561067030-17">&lt;&lt;</span><span class="mi">69</span><span class="p">,</span><span class="mi">82</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">119</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="w">
                  </span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="0561067030-17">&gt;&gt;</span><span class="p" data-group-id="0561067030-16">}</span><span class="p" data-group-id="0561067030-15">}</span><span class="gp unselectable">
4&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">inspect</span><span class="p" data-group-id="0561067030-18">(</span><span class="n">MPD</span><span class="p">,</span><span class="ss">namelist</span><span class="p" data-group-id="0561067030-18">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="0561067030-19">{</span><span class="ss">namelist</span><span class="p">,</span><span class="p" data-group-id="0561067030-20">[</span><span class="p" data-group-id="0561067030-21">&lt;&lt;</span><span class="s">&quot;B&quot;</span><span class="p" data-group-id="0561067030-21">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="0561067030-22">&lt;&lt;</span><span class="s">&quot;C&quot;</span><span class="p" data-group-id="0561067030-22">&gt;&gt;</span><span class="p" data-group-id="0561067030-20">]</span><span class="p" data-group-id="0561067030-19">}</span></code></pre><p>Notice in the second example that the duplicate name only occurs once in the
returned list, and that the list is in alphabetical order regardless of where
the names are positioned in the regular expression. The order of the names is
the same as the order of captured subexpressions if <code class="inline">{capture, all_names}</code> is
specified as an option to <a href="#run/3"><code class="inline">run/3</code></a>. You can therefore create a name-to-value
mapping from the result of <a href="#run/3"><code class="inline">run/3</code></a> like this:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="8034783573-1">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">MP</span><span class="p" data-group-id="8034783573-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">re</span><span class="p">:</span><span class="nf">compile</span><span class="p" data-group-id="8034783573-2">(</span><span class="s">&quot;(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;</span><span class="p" data-group-id="8034783573-2">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8034783573-3">{</span><span class="ss">ok</span><span class="p">,</span><span class="p" data-group-id="8034783573-4">{</span><span class="ss">re_pattern</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w">
                </span><span class="p" data-group-id="8034783573-5">&lt;&lt;</span><span class="mi">69</span><span class="p">,</span><span class="mi">82</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">119</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="w">
                  </span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="8034783573-5">&gt;&gt;</span><span class="p" data-group-id="8034783573-4">}</span><span class="p" data-group-id="8034783573-3">}</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="8034783573-6">{</span><span class="ss">namelist</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p" data-group-id="8034783573-6">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">re</span><span class="p">:</span><span class="nf">inspect</span><span class="p" data-group-id="8034783573-7">(</span><span class="n">MP</span><span class="p">,</span><span class="ss">namelist</span><span class="p" data-group-id="8034783573-7">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8034783573-8">{</span><span class="ss">namelist</span><span class="p">,</span><span class="p" data-group-id="8034783573-9">[</span><span class="p" data-group-id="8034783573-10">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="8034783573-10">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="8034783573-11">&lt;&lt;</span><span class="s">&quot;B&quot;</span><span class="p" data-group-id="8034783573-11">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="8034783573-12">&lt;&lt;</span><span class="s">&quot;C&quot;</span><span class="p" data-group-id="8034783573-12">&gt;&gt;</span><span class="p" data-group-id="8034783573-9">]</span><span class="p" data-group-id="8034783573-8">}</span><span class="gp unselectable">
3&gt; </span><span class="p" data-group-id="8034783573-13">{</span><span class="ss">match</span><span class="p">,</span><span class="n">L</span><span class="p" data-group-id="8034783573-13">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="8034783573-14">(</span><span class="s">&quot;AA&quot;</span><span class="p">,</span><span class="n">MP</span><span class="p">,</span><span class="p" data-group-id="8034783573-15">[</span><span class="p" data-group-id="8034783573-16">{</span><span class="ss">capture</span><span class="p">,</span><span class="ss">all_names</span><span class="p">,</span><span class="ss">binary</span><span class="p" data-group-id="8034783573-16">}</span><span class="p" data-group-id="8034783573-15">]</span><span class="p" data-group-id="8034783573-14">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8034783573-17">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="8034783573-18">[</span><span class="p" data-group-id="8034783573-19">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="8034783573-19">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="8034783573-20">&lt;&lt;</span><span class="p" data-group-id="8034783573-20">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="8034783573-21">&lt;&lt;</span><span class="p" data-group-id="8034783573-21">&gt;&gt;</span><span class="p" data-group-id="8034783573-18">]</span><span class="p" data-group-id="8034783573-17">}</span><span class="gp unselectable">
4&gt; </span><span class="n">NameMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">lists</span><span class="p">:</span><span class="nf">zip</span><span class="p" data-group-id="8034783573-22">(</span><span class="n">N</span><span class="p">,</span><span class="n">L</span><span class="p" data-group-id="8034783573-22">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8034783573-23">[</span><span class="p" data-group-id="8034783573-24">{</span><span class="p" data-group-id="8034783573-25">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="8034783573-25">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="8034783573-26">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="8034783573-26">&gt;&gt;</span><span class="p" data-group-id="8034783573-24">}</span><span class="p">,</span><span class="p" data-group-id="8034783573-27">{</span><span class="p" data-group-id="8034783573-28">&lt;&lt;</span><span class="s">&quot;B&quot;</span><span class="p" data-group-id="8034783573-28">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="8034783573-29">&lt;&lt;</span><span class="p" data-group-id="8034783573-29">&gt;&gt;</span><span class="p" data-group-id="8034783573-27">}</span><span class="p">,</span><span class="p" data-group-id="8034783573-30">{</span><span class="p" data-group-id="8034783573-31">&lt;&lt;</span><span class="s">&quot;C&quot;</span><span class="p" data-group-id="8034783573-31">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="8034783573-32">&lt;&lt;</span><span class="p" data-group-id="8034783573-32">&gt;&gt;</span><span class="p" data-group-id="8034783573-30">}</span><span class="p" data-group-id="8034783573-23">]</span></code></pre>
  </section>
</section>
<section class="detail" id="replace/3">

  <div class="detail-header">
    <a href="#replace/3" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">replace(Subject, RE, Replacement)</h1>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L1286" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> replace(Subject, RE, Replacement) -> <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>()
                 when
                     Subject :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                     RE :: <a href="#t:mp/0">mp</a>() | <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>(),
                     Replacement :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>() | <a href="#t:replace_fun/0">replace_fun</a>().</pre>

      </div>

<p>Equivalent to <a href="#replace/4"><code class="inline">replace(Subject, RE, Replacement, [])</code></a>.</p>
  </section>
</section>
<section class="detail" id="replace/4">

  <div class="detail-header">
    <a href="#replace/4" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">replace(Subject, RE, Replacement, Options)</h1>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L1383" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> replace(Subject, RE, Replacement, Options) -> <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>()
                 when
                     Subject :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                     RE :: <a href="#t:mp/0">mp</a>() | <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                     Replacement :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>() | <a href="#t:replace_fun/0">replace_fun</a>(),
                     Options :: [Option],
                     Option ::
                         anchored | global | notbol | noteol | notempty | notempty_atstart |
                         {offset, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
                         {match_limit, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
                         {match_limit_recursion, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
                         {return, ReturnType} |
                         CompileOpt,
                     ReturnType :: iodata | list | binary,
                     CompileOpt :: <a href="#t:compile_option/0">compile_option</a>().</pre>

      </div>

<p>Replaces the matched part of the <code class="inline">Subject</code> string with <code class="inline">Replacement</code>.</p><p>The permissible options are the same as for <a href="#run/3"><code class="inline">run/3</code></a>, except that
option<code class="inline">capture</code> is not allowed. Instead a <code class="inline">{return, ReturnType}</code> is present.
The default return type is <code class="inline">iodata</code>, constructed in a way to minimize copying.
The <code class="inline">iodata</code> result can be used directly in many I/O operations. If a flat
<a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a> is desired, specify <code class="inline">{return, list}</code>. If a binary is desired, specify
<code class="inline">{return, binary}</code>.</p><p>As in function <a href="#run/3"><code class="inline">run/3</code></a>, an <a href="#t:mp/0"><code class="inline">mp/0</code></a> compiled with option <code class="inline">unicode</code>
requires <code class="inline">Subject</code> to be a Unicode <code class="inline">charlist()</code>. If compilation is done
implicitly and the <code class="inline">unicode</code> compilation option is specified to this function,
both the regular expression and <code class="inline">Subject</code> are to specified as valid Unicode
<code class="inline">charlist()</code>s.</p><p>If the replacement is given as a string, it can contain the special character
<code class="inline">&amp;</code>, which inserts the whole matching expression in the result, and the special
sequence <code class="inline">\</code>N (where N is an integer &gt; 0), <code class="inline">\g</code>N, or <code class="inline">\g{</code>N<code class="inline">}</code>, resulting in the
subexpression number N, is inserted in the result. If no subexpression with that
number is generated by the regular expression, nothing is inserted.</p><p>To insert an &amp; or a \ in the result, precede it with a \. Notice that Erlang
already gives a special meaning to \ in literal strings, so a single \ must be
written as <code class="inline">&quot;\\&quot;</code> and therefore a double \ as <code class="inline">&quot;\\\\&quot;</code>.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">replace</span><span class="p" data-group-id="6791625173-1">(</span><span class="s">&quot;abcd&quot;</span><span class="p">,</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="s">&quot;[&amp;]&quot;</span><span class="p">,</span><span class="p" data-group-id="6791625173-2">[</span><span class="p" data-group-id="6791625173-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="6791625173-3">}</span><span class="p" data-group-id="6791625173-2">]</span><span class="p" data-group-id="6791625173-1">)</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;ab[c]d&quot;</span></code></pre><p>while</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">2&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">replace</span><span class="p" data-group-id="7079367625-1">(</span><span class="s">&quot;abcd&quot;</span><span class="p">,</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="s">&quot;[\\&amp;]&quot;</span><span class="p">,</span><span class="p" data-group-id="7079367625-2">[</span><span class="p" data-group-id="7079367625-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="7079367625-3">}</span><span class="p" data-group-id="7079367625-2">]</span><span class="p" data-group-id="7079367625-1">)</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;ab[&amp;]d&quot;</span></code></pre><p>If the replacement is given as a fun, it will be called with the whole matching
expression as the first argument and a list of subexpression matches in the
order in which they appear in the regular expression. The returned value will be
inserted in the result.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">3&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">replace</span><span class="p" data-group-id="3149079547-1">(</span><span class="s">&quot;abcd&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;.(.)&quot;</span><span class="p">,</span><span class="w">
    </span><span class="nf">fun</span><span class="p" data-group-id="3149079547-2">(</span><span class="n">Whole</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3149079547-3">[</span><span class="p" data-group-id="3149079547-4">&lt;&lt;</span><span class="n">C</span><span class="p" data-group-id="3149079547-4">&gt;&gt;</span><span class="p" data-group-id="3149079547-3">]</span><span class="p" data-group-id="3149079547-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
         </span><span class="p" data-group-id="3149079547-5">&lt;&lt;</span><span class="sc">$#</span><span class="p">,</span><span class="w"> </span><span class="n">Whole</span><span class="o">/</span><span class="ss">binary</span><span class="p">,</span><span class="w"> </span><span class="sc">$-</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3149079547-6">(</span><span class="n">C</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="sc">$a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="sc">$A</span><span class="p" data-group-id="3149079547-6">)</span><span class="p">,</span><span class="w"> </span><span class="sc">$#</span><span class="p" data-group-id="3149079547-5">&gt;&gt;</span><span class="w">
    </span><span class="k">end</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="3149079547-7">[</span><span class="p" data-group-id="3149079547-8">{</span><span class="ss">return</span><span class="p">,</span><span class="w"> </span><span class="ss">list</span><span class="p" data-group-id="3149079547-8">}</span><span class="p" data-group-id="3149079547-7">]</span><span class="p" data-group-id="3149079547-1">)</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;#ab-B#cd&quot;</span></code></pre><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Non-matching optional subexpressions will not be included in the list of
subexpression matches if they are the last subexpressions in the regular
expression.</p><p><em>Example:</em></p><p>The regular expression <code class="inline">&quot;(a)(b)?(c)?&quot;</code> (&quot;a&quot;, optionally followed by &quot;b&quot;,
optionally followed by &quot;c&quot;) will create the following subexpression lists:</p><ul><li><code class="inline">[&lt;&lt;&quot;a&quot;&gt;&gt;, &lt;&lt;&quot;b&quot;&gt;&gt;, &lt;&lt;&quot;c&quot;&gt;&gt;]</code> when applied to the string <code class="inline">&quot;abc&quot;</code></li><li><code class="inline">[&lt;&lt;&quot;a&quot;&gt;&gt;, &lt;&lt;&gt;&gt;, &lt;&lt;&quot;c&quot;&gt;&gt;]</code> when applied to the string <code class="inline">&quot;acx&quot;</code></li><li><code class="inline">[&lt;&lt;&quot;a&quot;&gt;&gt;, &lt;&lt;&quot;b&quot;&gt;&gt;]</code> when applied to the string <code class="inline">&quot;abx&quot;</code></li><li><code class="inline">[&lt;&lt;&quot;a&quot;&gt;&gt;]</code> when applied to the string <code class="inline">&quot;axx&quot;</code></li></ul></section><p>As with <a href="#run/3"><code class="inline">run/3</code></a>, compilation errors raise the <code class="inline">badarg</code> exception.
<a href="#compile/2"><code class="inline">compile/2</code></a> can be used to get more information about the error.</p>
  </section>
</section>
<section class="detail" id="run/2">

  <div class="detail-header">
    <a href="#run/2" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">run(Subject, RE)</h1>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L298" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> run(Subject, RE) -> {match, Captured} | nomatch
             when
                 Subject :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                 RE :: <a href="#t:mp/0">mp</a>() | <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>(),
                 Captured :: [CaptureData],
                 CaptureData :: {<a href="../../apps/erts/erlang.html#t:integer/0">integer</a>(), <a href="../../apps/erts/erlang.html#t:integer/0">integer</a>()}.</pre>

      </div>

<p>Equivalent to <a href="#run/3"><code class="inline">run(Subject, RE, [])</code></a>.</p>
  </section>
</section>
<section class="detail" id="run/3">

  <div class="detail-header">
    <a href="#run/3" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">run(Subject, RE, Options)</h1>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L816" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> run(Subject, RE, Options) -> {match, Captured} | match | nomatch | {error, ErrType}
             when
                 Subject :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                 RE :: <a href="#t:mp/0">mp</a>() | <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                 Options :: <a href="#t:options/0">options</a>(),
                 Captured :: [CaptureData] | [[CaptureData]],
                 CaptureData :: {<a href="../../apps/erts/erlang.html#t:integer/0">integer</a>(), <a href="../../apps/erts/erlang.html#t:integer/0">integer</a>()} | ListConversionData | <a href="../../apps/erts/erlang.html#t:binary/0">binary</a>(),
                 ListConversionData ::
                     <a href="../../apps/erts/erlang.html#t:string/0">string</a>() | {error, <a href="../../apps/erts/erlang.html#t:string/0">string</a>(), <a href="../../apps/erts/erlang.html#t:binary/0">binary</a>()} | {incomplete, <a href="../../apps/erts/erlang.html#t:string/0">string</a>(), <a href="../../apps/erts/erlang.html#t:binary/0">binary</a>()},
                 ErrType :: match_limit | match_limit_recursion | {compile, CompileErr},
                 CompileErr :: {ErrString :: <a href="../../apps/erts/erlang.html#t:string/0">string</a>(), Position :: <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()}.</pre>

      </div>

<p>Executes a regular expression matching, and returns <code class="inline">match/{match, Captured}</code> or
<code class="inline">nomatch</code>.</p><p>The regular expression can be specified either as <a href="../../apps/erts/erlang.html#t:iodata/0"><code class="inline">iodata/0</code></a> in
which case it is automatically compiled (as by <a href="#compile/2"><code class="inline">compile/2</code></a>) and
executed, or as a precompiled <a href="#t:mp/0"><code class="inline">mp()</code></a> in which case it is executed
against the subject directly.</p><p>When compilation is involved, exception <code class="inline">badarg</code> is thrown if a compilation
error occurs. Call <a href="#compile/2"><code class="inline">compile/2</code></a> to get information about the
location of the error in the regular expression.</p><p>If the regular expression is previously compiled, the option list can only
contain the following options:</p><ul><li><code class="inline">anchored</code></li><li><code class="inline">{capture, ValueSpec}/{capture, ValueSpec, Type}</code></li><li><code class="inline">global</code></li><li><code class="inline">{match_limit, integer() &gt;= 0}</code></li><li><code class="inline">{match_limit_recursion, integer() &gt;= 0}</code></li><li><code class="inline">notbol</code></li><li><code class="inline">notempty</code></li><li><code class="inline">notempty_atstart</code></li><li><code class="inline">noteol</code></li><li><code class="inline">{offset, integer() &gt;= 0}</code></li><li><code class="inline">report_errors</code></li></ul><p>Otherwise all options valid for function <a href="#compile/2"><code class="inline">compile/2</code></a> are also
allowed. Options allowed both for compilation and execution of a match, namely
<code class="inline">anchored</code>, affect both the compilation and execution if
present together with a non-precompiled regular expression.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>As from Erlang/OTP 28, options <code class="inline">{newline, _}</code>, <code class="inline">bsr_anycrlf</code> and <code class="inline">bsr_unicode</code>
can only be used to control the <em>compilation</em> of a regular expression. They
will no longer be accepted by <a href="#run/3"><code class="inline">run/3</code></a>, <a href="#replace/4"><code class="inline">replace/4</code></a> and <a href="#split/3"><code class="inline">split/3</code></a> if the
regular expression was previously compiled and the options do not comply with
what was given at compile time.</p></section><p>If the regular expression was previously compiled with option <code class="inline">unicode</code>,
<code class="inline">Subject</code> is to be provided as a valid Unicode <code class="inline">charlist()</code>, otherwise any
<a href="../../apps/erts/erlang.html#t:iodata/0"><code class="inline">iodata/0</code></a> will do. If compilation is involved and option <code class="inline">unicode</code> is
specified, both <code class="inline">Subject</code> and the regular expression are to be specified as
valid Unicode <code class="inline">charlists()</code>.</p><p><code class="inline">{capture, ValueSpec}/{capture, ValueSpec, Type}</code> defines what to return from
the function upon successful matching. The <code class="inline">capture</code> tuple can contain both a
value specification, telling which of the captured substrings are to be
returned, and a type specification, telling how captured substrings are to be
returned (as index tuples, lists, or binaries). The options are described in
detail below.</p><p>If the capture options describe that no substring capturing is to be done
(<code class="inline">{capture, none}</code>), the function returns the single atom <code class="inline">match</code> upon
successful matching, otherwise the tuple <code class="inline">{match, ValueList}</code>. Disabling
capturing can be done either by specifying <code class="inline">none</code> or an empty list as
<code class="inline">ValueSpec</code>.</p><p>Option <code class="inline">report_errors</code> adds the possibility that an error tuple is returned. The
tuple either indicates a matching error (<code class="inline">match_limit</code> or
<code class="inline">match_limit_recursion</code>), or a compilation error, where the error tuple has the
format <code class="inline">{error, {compile, CompileErr}}</code>. Notice that if option <code class="inline">report_errors</code>
is not specified, the function never returns error tuples, but reports
compilation errors as a <code class="inline">badarg</code> exception and failed matches because of
exceeded match limits simply as <code class="inline">nomatch</code>.</p><p>The following options are relevant for execution:</p><ul><li><p><strong><code class="inline">anchored</code></strong> - Limits <a href="#run/3"><code class="inline">run/3</code></a> to matching at the first matching
position. If a pattern was compiled with <code class="inline">anchored</code>, or turned out to be
anchored by virtue of its contents, it cannot be made unanchored at matching
time, hence there is no <code class="inline">unanchored</code> option.</p></li><li><p><strong><code class="inline">global</code></strong> - Implements global (repetitive) search (flag <code class="inline">g</code> in Perl). Each
match is returned as a separate <a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a> containing the specific match and
any matching subexpressions (or as specified by option <code class="inline">capture</code>. The
<code class="inline">Captured</code> part of the return value is hence a <a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a> of <a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a>s when
this option is specified.</p><p>The interaction of option <code class="inline">global</code> with a regular expression that matches an
empty string surprises some users. When option <code class="inline">global</code> is specified,
<a href="#run/3"><code class="inline">run/3</code></a> handles empty matches in the same way as Perl: a
zero-length match at any point is also retried with options
<code class="inline">[anchored, notempty_atstart]</code>. If that search gives a result of length &gt; 0,
the result is included. Example:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="2952075885-1">(</span><span class="s">&quot;cat&quot;</span><span class="p">,</span><span class="s">&quot;(|at)&quot;</span><span class="p">,</span><span class="p" data-group-id="2952075885-2">[</span><span class="ss">global</span><span class="p" data-group-id="2952075885-2">]</span><span class="p" data-group-id="2952075885-1">)</span><span class="p">.</span></code></pre><p>The following matchings are performed:</p><ul><li><p><strong>At offset <code class="inline">0</code></strong> - The regular expression <code class="inline">(|at)</code> first match at the
initial position of string <code class="inline">cat</code>, giving the result set <code class="inline">[{0,0},{0,0}]</code> (the
second <code class="inline">{0,0}</code> is because of the subexpression marked by the parentheses).
As the length of the match is 0, we do not advance to the next position yet.</p></li><li><p><strong>At offset <code class="inline">0</code> with <code class="inline">[anchored, notempty_atstart]</code></strong> - The search is
retried with options <code class="inline">[anchored, notempty_atstart]</code> at the same position,
which does not give any interesting result of longer length, so the search
position is advanced to the next character (<code class="inline">a</code>).</p></li><li><p><strong>At offset <code class="inline">1</code></strong> - The search results in <code class="inline">[{1,0},{1,0}]</code>, so this search is
also repeated with the extra options.</p></li><li><p><strong>At offset <code class="inline">1</code> with <code class="inline">[anchored, notempty_atstart]</code></strong> - Alternative <code class="inline">ab</code> is
found and the result is [{1,2},{1,2}]. The result is added to the list
of results and the position in the search string is advanced two steps.</p></li><li><p><strong>At offset <code class="inline">3</code></strong> - The search once again matches the empty string, giving
<code class="inline">[{3,0},{3,0}]</code>.</p></li><li><p><strong>At offset <code class="inline">1</code> with <code class="inline">[anchored, notempty_atstart]</code></strong> - This gives no result
of length &gt; 0 and we are at the last position, so the global search is
complete.</p></li></ul><p>The result of the call is:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="1578360528-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="1578360528-2">[</span><span class="p" data-group-id="1578360528-3">[</span><span class="p" data-group-id="1578360528-4">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="1578360528-4">}</span><span class="p">,</span><span class="p" data-group-id="1578360528-5">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="1578360528-5">}</span><span class="p" data-group-id="1578360528-3">]</span><span class="p">,</span><span class="p" data-group-id="1578360528-6">[</span><span class="p" data-group-id="1578360528-7">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="1578360528-7">}</span><span class="p">,</span><span class="p" data-group-id="1578360528-8">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="1578360528-8">}</span><span class="p" data-group-id="1578360528-6">]</span><span class="p">,</span><span class="p" data-group-id="1578360528-9">[</span><span class="p" data-group-id="1578360528-10">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="1578360528-10">}</span><span class="p">,</span><span class="p" data-group-id="1578360528-11">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="1578360528-11">}</span><span class="p" data-group-id="1578360528-9">]</span><span class="p">,</span><span class="p" data-group-id="1578360528-12">[</span><span class="p" data-group-id="1578360528-13">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="1578360528-13">}</span><span class="p">,</span><span class="p" data-group-id="1578360528-14">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="1578360528-14">}</span><span class="p" data-group-id="1578360528-12">]</span><span class="p" data-group-id="1578360528-2">]</span><span class="p" data-group-id="1578360528-1">}</span></code></pre></li><li><p><strong><code class="inline">notempty</code></strong> - An empty string is not considered to be a valid match if this
option is specified. If alternatives in the pattern exist, they are tried. If
all the alternatives match the empty string, the entire match fails.</p><p><em>Example:</em></p><p>If the following pattern is applied to a string not beginning with &quot;a&quot; or &quot;b&quot;,
it would normally match the empty string at the start of the subject:</p><pre><code class="text">a?b?</code></pre><p>With option <code class="inline">notempty</code>, this match is invalid, so <a href="#run/3"><code class="inline">run/3</code></a> searches
further into the string for occurrences of &quot;a&quot; or &quot;b&quot;.</p></li><li><p><strong><code class="inline">notempty_atstart</code></strong> - Like <code class="inline">notempty</code>, except that an empty string match
that is not at the start of the subject is permitted. If the pattern is
anchored, such a match can occur only if the pattern contains \K.</p><p>Perl has no direct equivalent of <code class="inline">notempty</code> or <code class="inline">notempty_atstart</code>, but it does
make a special case of a pattern match of the empty string within its split()
function, and when using modifier <code class="inline">/g</code>. The Perl behavior can be emulated
after matching a null string by first trying the match again at the same
offset with <code class="inline">notempty_atstart</code> and <code class="inline">anchored</code>, and then, if that fails, by
advancing the starting offset (see below) and trying an ordinary match again.</p></li><li><p><strong><code class="inline">notbol</code></strong> - Specifies that the first character of the subject string is not
the beginning of a line, so the circumflex metacharacter is not to match
before it. Setting this without <code class="inline">multiline</code> (at compile time) causes
circumflex never to match. This option only affects the behavior of the
circumflex metacharacter. It does not affect \A.</p></li><li><p><strong><code class="inline">noteol</code></strong> - Specifies that the end of the subject string is not the end of
a line, so the dollar metacharacter is not to match it nor (except in
multiline mode) a newline immediately before it. Setting this without
<code class="inline">multiline</code> (at compile time) causes dollar never to match. This option
affects only the behavior of the dollar metacharacter. It does not affect \Z
or \z.</p></li><li><p><strong><code class="inline">report_errors</code></strong> - Gives better control of the error handling in
<a href="#run/3"><code class="inline">run/3</code></a>. When specified, compilation errors (if the regular
expression is not already compiled) and runtime errors are explicitly returned
as an error tuple.</p><p>The following are the possible runtime errors:</p><ul><li><p><strong><code class="inline">match_limit</code></strong> - The PCRE library sets a limit on how many times the
internal match function can be called. Defaults to 10,000,000 in the library
compiled for Erlang. If <code class="inline">{error, match_limit}</code> is returned, the execution of
the regular expression has reached this limit. This is normally to be
regarded as a <code class="inline">nomatch</code>, which is the default return value when this occurs,
but by specifying <code class="inline">report_errors</code>, you are informed when the match fails
because of too many internal calls.</p></li><li><p><strong><code class="inline">match_limit_recursion</code></strong> - This error is very similar to <code class="inline">match_limit</code>,
but occurs when the internal match function of PCRE is &quot;recursively&quot; called
more times than the <code class="inline">match_limit_recursion</code> limit, which defaults to
10,000,000 as well. Notice that as long as the <code class="inline">match_limit</code> and
<code class="inline">match_limit_default</code> values are kept at the default values, the
<code class="inline">match_limit_recursion</code> error cannot occur, as the <code class="inline">match_limit</code> error
occurs before that (each recursive call is also a call, but not conversely).
Both limits can however be changed, either by setting limits directly in the
regular expression string (see section
<a href="re.html#module-pcre2-regular-expression-details">PCRE Regular Expression Details</a>) or by
specifying options to <a href="#run/3"><code class="inline">run/3</code></a>.</p></li></ul><p>It is important to understand that what is referred to as &quot;recursion&quot; when
limiting matches is not recursion on the C stack of the Erlang machine or on
the Erlang process stack. The PCRE version compiled into the Erlang VM uses
machine &quot;heap&quot; memory to store values that must be kept over recursion in
regular expression matches.</p></li><li><p><strong><code class="inline">{match_limit, integer() &gt;= 0}</code></strong> - Limits the execution time of a match in
an implementation-specific way. It is described as follows by the PCRE
documentation:</p><blockquote><p>The match_limit field provides a means of preventing PCRE from using
up a vast amount of resources when running patterns that are not going
to match, but which have a very large number of possibilities in their
search trees. The classic example is a pattern that uses nested
unlimited repeats.</p><p>Internally, pcre_exec() uses a function called match(), which it calls
repeatedly (sometimes recursively). The limit set by match_limit is
imposed on the number of times this function is called during a match,
which has the effect of limiting the amount of backtracking that can
take place. For patterns that are not anchored, the count restarts
from zero for each position in the subject string.</p></blockquote><p>This means that runaway regular expression matches can fail faster if the
limit is lowered using this option. The default value 10,000,000 is compiled
into the Erlang VM.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>This option does in no way affect the execution of the Erlang VM in terms of
&quot;long running BIFs&quot;. <a href="#run/3"><code class="inline">run/3</code></a> always gives control back to the
scheduler of Erlang processes at intervals that ensures the real-time
properties of the Erlang system.</p></section></li><li><p><strong><code class="inline">{match_limit_recursion, integer() &gt;= 0}</code></strong> - Limits the execution time and
memory consumption of a match in an implementation-specific way, very similar
to <code class="inline">match_limit</code>. It is described as follows by the PCRE documentation:</p><blockquote><p>The match_limit_recursion field is similar to match_limit, but instead
of limiting the total number of times that match() is called, it
limits the depth of recursion. The recursion depth is a smaller number
than the total number of calls, because not all calls to match() are
recursive. This limit is of use only if it is set smaller than
match_limit.</p><p>Limiting the recursion depth limits the amount of machine stack that
can be used, or, when PCRE has been compiled to use memory on the heap
instead of the stack, the amount of heap memory that can be used.</p></blockquote><p>The Erlang VM uses a PCRE library where heap memory is used when regular
expression match recursion occurs. This therefore limits the use of machine
heap, not C stack.</p><p>Specifying a lower value can result in matches with deep recursion failing,
when they should have matched:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="5212791343-1">(</span><span class="s">&quot;aaaaaaaaaaaaaz&quot;</span><span class="p">,</span><span class="s">&quot;(a+)*z&quot;</span><span class="p" data-group-id="5212791343-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="5212791343-2">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="5212791343-3">[</span><span class="p" data-group-id="5212791343-4">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">14</span><span class="p" data-group-id="5212791343-4">}</span><span class="p">,</span><span class="p" data-group-id="5212791343-5">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">13</span><span class="p" data-group-id="5212791343-5">}</span><span class="p" data-group-id="5212791343-3">]</span><span class="p" data-group-id="5212791343-2">}</span><span class="gp unselectable">
2&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="5212791343-6">(</span><span class="s">&quot;aaaaaaaaaaaaaz&quot;</span><span class="p">,</span><span class="s">&quot;(a+)*z&quot;</span><span class="p">,</span><span class="p" data-group-id="5212791343-7">[</span><span class="p" data-group-id="5212791343-8">{</span><span class="ss">match_limit_recursion</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="5212791343-8">}</span><span class="p" data-group-id="5212791343-7">]</span><span class="p" data-group-id="5212791343-6">)</span><span class="p">.</span><span class="w">
</span><span class="ss">nomatch</span><span class="gp unselectable">
3&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="5212791343-9">(</span><span class="s">&quot;aaaaaaaaaaaaaz&quot;</span><span class="p">,</span><span class="s">&quot;(a+)*z&quot;</span><span class="p">,</span><span class="p" data-group-id="5212791343-10">[</span><span class="p" data-group-id="5212791343-11">{</span><span class="ss">match_limit_recursion</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="5212791343-11">}</span><span class="p">,</span><span class="ss">report_errors</span><span class="p" data-group-id="5212791343-10">]</span><span class="p" data-group-id="5212791343-9">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="5212791343-12">{</span><span class="ss">error</span><span class="p">,</span><span class="ss">match_limit_recursion</span><span class="p" data-group-id="5212791343-12">}</span></code></pre><p>This option and option <code class="inline">match_limit</code> are only to be used in rare cases.
Understanding of the PCRE library internals is recommended before tampering
with these limits.</p></li><li><p><strong><code class="inline">{offset, integer() &gt;= 0}</code></strong> - Start matching at the offset (position)
specified in the subject string. The offset is zero-based, so that the default
is <code class="inline">{offset,0}</code> (all of the subject string).</p></li><li><p><strong><code class="inline">{capture, ValueSpec}</code>/<code class="inline">{capture, ValueSpec, Type}</code></strong> - Specifies which
captured substrings are returned and in what format. By default,
<a href="#run/3"><code class="inline">run/3</code></a> captures all of the matching part of the substring and all
capturing subpatterns (all of the pattern is automatically captured). The
default return type is (zero-based) indexes of the captured parts of the
string, specified as <code class="inline">{Offset,Length}</code> pairs (the <code class="inline">index</code> <code class="inline">Type</code> of
capturing).</p><p>As an example of the default behavior, the following call returns, as first
and only captured string, the matching part of the subject (&quot;abcd&quot; in the
middle) as an index pair <code class="inline">{3,4}</code>, where character positions are zero-based,
just as in offsets:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="4942942274-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;abcd&quot;</span><span class="p">,</span><span class="p" data-group-id="4942942274-2">[</span><span class="p" data-group-id="4942942274-2">]</span><span class="p" data-group-id="4942942274-1">)</span><span class="p">.</span></code></pre><p>The return value of this call is:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="7784084382-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="7784084382-2">[</span><span class="p" data-group-id="7784084382-3">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="7784084382-3">}</span><span class="p" data-group-id="7784084382-2">]</span><span class="p" data-group-id="7784084382-1">}</span></code></pre><p>Another (and quite common) case is where the regular expression matches all of
the subject:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="7531599669-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*abcd.*&quot;</span><span class="p">,</span><span class="p" data-group-id="7531599669-2">[</span><span class="p" data-group-id="7531599669-2">]</span><span class="p" data-group-id="7531599669-1">)</span><span class="p">.</span></code></pre><p>Here the return value correspondingly points out all of the string, beginning
at index 0, and it is 10 characters long:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="6671747325-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="6671747325-2">[</span><span class="p" data-group-id="6671747325-3">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="6671747325-3">}</span><span class="p" data-group-id="6671747325-2">]</span><span class="p" data-group-id="6671747325-1">}</span></code></pre><p>If the regular expression contains capturing subpatterns, like in:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="4287210642-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*(abcd).*&quot;</span><span class="p">,</span><span class="p" data-group-id="4287210642-2">[</span><span class="p" data-group-id="4287210642-2">]</span><span class="p" data-group-id="4287210642-1">)</span><span class="p">.</span></code></pre><p>all of the matched subject is captured, as well as the captured substrings:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="7346856572-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="7346856572-2">[</span><span class="p" data-group-id="7346856572-3">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="7346856572-3">}</span><span class="p">,</span><span class="p" data-group-id="7346856572-4">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="7346856572-4">}</span><span class="p" data-group-id="7346856572-2">]</span><span class="p" data-group-id="7346856572-1">}</span></code></pre><p>The complete matching pattern always gives the first return value in the list
and the remaining subpatterns are added in the order they occurred in the
regular expression.</p><p>The capture tuple is built up as follows:</p><ul><li><p><strong><code class="inline">ValueSpec</code></strong> - Specifies which captured (sub)patterns are to be returned.
<code class="inline">ValueSpec</code> can either be an atom describing a predefined set of return
values, or a list containing the indexes or the names of specific
subpatterns to return.</p><p>The following are the predefined sets of subpatterns:</p><ul><li><p><strong><code class="inline">all</code></strong> - All captured subpatterns including the complete matching
string. This is the default.</p></li><li><p><strong><code class="inline">all_names</code></strong> - All <em>named</em> subpatterns in the regular expression, as if
a <a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a> of all the names <em>in alphabetical order</em> was specified. The
list of all names can also be retrieved with <a href="#inspect/2"><code class="inline">inspect/2</code></a>.</p></li><li><p><strong><code class="inline">first</code></strong> - Only the first captured subpattern, which is always the
complete matching part of the subject. All explicitly captured subpatterns
are discarded.</p></li><li><p><strong><code class="inline">all_but_first</code></strong> - All but the first matching subpattern, that is, all
explicitly captured subpatterns, but not the complete matching part of the
subject string. This is useful if the regular expression as a whole
matches a large part of the subject, but the part you are interested in is
in an explicitly captured subpattern. If the return type is <code class="inline">list</code> or
<code class="inline">binary</code>, not returning subpatterns you are not interested in is a good
way to optimize.</p></li><li><p><strong><code class="inline">none</code></strong> - Returns no matching subpatterns, gives the single atom
<code class="inline">match</code> as the return value of the function when matching successfully
instead of the <code class="inline">{match, list()}</code> return. Specifying an empty list gives
the same behavior.</p></li></ul><p>The value list is a list of indexes for the subpatterns to return, where
index 0 is for all of the pattern, and 1 is for the first explicit capturing
subpattern in the regular expression, and so on. When using named captured
subpatterns (see below) in the regular expression, one can use <a href="../../apps/erts/erlang.html#t:atom/0"><code class="inline">atom/0</code></a>s
or <a href="../../apps/erts/erlang.html#t:string/0"><code class="inline">string/0</code></a>s to specify the subpatterns to be returned. For example,
consider the regular expression:</p><pre><code class="text">&quot;.*(abcd).*&quot;</code></pre><p>matched against string &quot;ABCabcdABC&quot;, capturing only the &quot;abcd&quot; part (the
first explicit subpattern):</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="1538006994-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*(abcd).*&quot;</span><span class="p">,</span><span class="p" data-group-id="1538006994-2">[</span><span class="p" data-group-id="1538006994-3">{</span><span class="ss">capture</span><span class="p">,</span><span class="p" data-group-id="1538006994-4">[</span><span class="mi">1</span><span class="p" data-group-id="1538006994-4">]</span><span class="p" data-group-id="1538006994-3">}</span><span class="p" data-group-id="1538006994-2">]</span><span class="p" data-group-id="1538006994-1">)</span><span class="p">.</span></code></pre><p>The call gives the following result, as the first explicitly captured
subpattern is &quot;(abcd)&quot;, matching &quot;abcd&quot; in the subject, at (zero-based)
position 3, of length 4:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="2934359653-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="2934359653-2">[</span><span class="p" data-group-id="2934359653-3">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="2934359653-3">}</span><span class="p" data-group-id="2934359653-2">]</span><span class="p" data-group-id="2934359653-1">}</span></code></pre><p>Consider the same regular expression, but with the subpattern explicitly
named 'FOO':</p><pre><code class="text">&quot;.*(?&lt;FOO&gt;abcd).*&quot;</code></pre><p>With this expression, we could still give the index of the subpattern with
the following call:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="8595690279-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*(?&lt;FOO&gt;abcd).*&quot;</span><span class="p">,</span><span class="p" data-group-id="8595690279-2">[</span><span class="p" data-group-id="8595690279-3">{</span><span class="ss">capture</span><span class="p">,</span><span class="p" data-group-id="8595690279-4">[</span><span class="mi">1</span><span class="p" data-group-id="8595690279-4">]</span><span class="p" data-group-id="8595690279-3">}</span><span class="p" data-group-id="8595690279-2">]</span><span class="p" data-group-id="8595690279-1">)</span><span class="p">.</span></code></pre><p>giving the same result as before. But, as the subpattern is named, we can
also specify its name in the value list:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="6149837993-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*(?&lt;FOO&gt;abcd).*&quot;</span><span class="p">,</span><span class="p" data-group-id="6149837993-2">[</span><span class="p" data-group-id="6149837993-3">{</span><span class="ss">capture</span><span class="p">,</span><span class="p" data-group-id="6149837993-4">[</span><span class="ss">&#39;FOO&#39;</span><span class="p" data-group-id="6149837993-4">]</span><span class="p" data-group-id="6149837993-3">}</span><span class="p" data-group-id="6149837993-2">]</span><span class="p" data-group-id="6149837993-1">)</span><span class="p">.</span></code></pre><p>This would give the same result as the earlier examples, namely:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="8076599996-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="8076599996-2">[</span><span class="p" data-group-id="8076599996-3">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="8076599996-3">}</span><span class="p" data-group-id="8076599996-2">]</span><span class="p" data-group-id="8076599996-1">}</span></code></pre><p>The values list can specify indexes or names not present in the regular
expression, in which case the return values vary depending on the type. If
the type is <code class="inline">index</code>, the tuple <code class="inline">{-1,0}</code> is returned for values with no
corresponding subpattern in the regular expression, but for the other types
(<code class="inline">binary</code> and <code class="inline">list</code>), the values are the empty binary or list,
respectively.</p></li><li><p><strong><code class="inline">Type</code></strong> - Optionally specifies how captured substrings are to be
returned. If omitted, the default of <code class="inline">index</code> is used.</p><p><code class="inline">Type</code> can be one of the following:</p><ul><li><p><strong><code class="inline">index</code></strong> - Returns captured substrings as pairs of byte indexes into
the subject string and length of the matching string in the subject (as if
the subject string was flattened with <a href="../../apps/erts/erlang.html#iolist_to_binary/1"><code class="inline">erlang:iolist_to_binary/1</code></a> or
<a href="unicode.html#characters_to_binary/2"><code class="inline">unicode:characters_to_binary/2</code></a> before matching). Notice that option
<code class="inline">unicode</code> results in <em>byte-oriented</em> indexes in a (possibly virtual)
<em>UTF-8 encoded</em> binary. A byte index tuple <code class="inline">{0,2}</code> can therefore represent
one or two characters when <code class="inline">unicode</code> is in effect. This can seem
counter-intuitive, but has been deemed the most effective and useful way
to do it. To return lists instead can result in simpler code if that is
desired. This return type is the default.</p></li><li><p><strong><code class="inline">list</code></strong> - Returns matching substrings as lists of characters (Erlang
<a href="../../apps/erts/erlang.html#t:string/0"><code class="inline">string/0</code></a>s). It option <code class="inline">unicode</code> is used in combination with the \C
sequence in the regular expression, a captured subpattern can contain
bytes that are not valid UTF-8 (\C matches bytes regardless of character
encoding). In that case the <code class="inline">list</code> capturing can result in the same types
of tuples that <a href="unicode.html#characters_to_list/2"><code class="inline">unicode:characters_to_list/2</code></a> can return, namely
three-tuples with tag <code class="inline">incomplete</code> or <code class="inline">error</code>, the successfully converted
characters and the invalid UTF-8 tail of the conversion as a binary. The
best strategy is to avoid using the \C sequence when capturing lists.</p></li><li><p><strong><code class="inline">binary</code></strong> - Returns matching substrings as binaries. If option
<code class="inline">unicode</code> is used, these binaries are in UTF-8. If the \C sequence is
used together with <code class="inline">unicode</code>, the binaries can be invalid UTF-8.</p></li></ul></li></ul><p>In general, subpatterns that were not assigned a value in the match are
returned as the tuple <code class="inline">{-1,0}</code> when <code class="inline">type</code> is <code class="inline">index</code>. Unassigned subpatterns
are returned as the empty binary or list, respectively, for other return
types. Consider the following regular expression:</p><pre><code class="text">&quot;.*((?&lt;FOO&gt;abdd)|a(..d)).*&quot;</code></pre><p>There are three explicitly capturing subpatterns, where the opening
parenthesis position determines the order in the result, hence
<code class="inline">((?&lt;FOO&gt;abdd)|a(..d))</code> is subpattern index 1, <code class="inline">(?&lt;FOO&gt;abdd)</code> is subpattern
index 2, and <code class="inline">(..d)</code> is subpattern index 3. When matched against the following
string:</p><pre><code class="text">&quot;ABCabcdABC&quot;</code></pre><p>the subpattern at index 2 does not match, as &quot;abdd&quot; is not present in the
string, but the complete pattern matches (because of the alternative
<code class="inline">a(..d)</code>). The subpattern at index 2 is therefore unassigned and the default
return value is:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="3984169927-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="3984169927-2">[</span><span class="p" data-group-id="3984169927-3">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="3984169927-3">}</span><span class="p">,</span><span class="p" data-group-id="3984169927-4">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="3984169927-4">}</span><span class="p">,</span><span class="p" data-group-id="3984169927-5">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="3984169927-5">}</span><span class="p">,</span><span class="p" data-group-id="3984169927-6">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="3984169927-6">}</span><span class="p" data-group-id="3984169927-2">]</span><span class="p" data-group-id="3984169927-1">}</span></code></pre><p>Setting the capture <code class="inline">Type</code> to <code class="inline">binary</code> gives:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="3987147581-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="3987147581-2">[</span><span class="p" data-group-id="3987147581-3">&lt;&lt;</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p" data-group-id="3987147581-3">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="3987147581-4">&lt;&lt;</span><span class="s">&quot;abcd&quot;</span><span class="p" data-group-id="3987147581-4">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="3987147581-5">&lt;&lt;</span><span class="p" data-group-id="3987147581-5">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="3987147581-6">&lt;&lt;</span><span class="s">&quot;bcd&quot;</span><span class="p" data-group-id="3987147581-6">&gt;&gt;</span><span class="p" data-group-id="3987147581-2">]</span><span class="p" data-group-id="3987147581-1">}</span></code></pre><p>Here the empty binary (<code class="inline">&lt;&lt;&gt;&gt;</code>) represents the unassigned subpattern. In the
<code class="inline">binary</code> case, some information about the matching is therefore lost, as
<code class="inline">&lt;&lt;&gt;&gt;</code> can also be an empty string captured.</p><p>If differentiation between empty matches and non-existing subpatterns is
necessary, use the <code class="inline">type</code> <code class="inline">index</code> and do the conversion to the final type in
Erlang code.</p><p>When option <code class="inline">global</code> is speciified, the <code class="inline">capture</code> specification affects each
match separately, so that:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="5094663986-1">(</span><span class="s">&quot;cacb&quot;</span><span class="p">,</span><span class="s">&quot;c(a|b)&quot;</span><span class="p">,</span><span class="p" data-group-id="5094663986-2">[</span><span class="ss">global</span><span class="p">,</span><span class="p" data-group-id="5094663986-3">{</span><span class="ss">capture</span><span class="p">,</span><span class="p" data-group-id="5094663986-4">[</span><span class="mi">1</span><span class="p" data-group-id="5094663986-4">]</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="5094663986-3">}</span><span class="p" data-group-id="5094663986-2">]</span><span class="p" data-group-id="5094663986-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="7907955525-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="7907955525-2">[</span><span class="p" data-group-id="7907955525-3">[</span><span class="s">&quot;a&quot;</span><span class="p" data-group-id="7907955525-3">]</span><span class="p">,</span><span class="p" data-group-id="7907955525-4">[</span><span class="s">&quot;b&quot;</span><span class="p" data-group-id="7907955525-4">]</span><span class="p" data-group-id="7907955525-2">]</span><span class="p" data-group-id="7907955525-1">}</span></code></pre></li></ul><p>For a descriptions of options only affecting the compilation step, see
<a href="#compile/2"><code class="inline">compile/2</code></a>.</p>
  </section>
</section>
<section class="detail" id="split/2">

  <div class="detail-header">
    <a href="#split/2" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">split(Subject, RE)</h1>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L914" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> split(Subject, RE) -> SplitList
               when
                   Subject :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                   RE :: <a href="#t:mp/0">mp</a>() | <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>(),
                   SplitList :: [<a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>()].</pre>

      </div>

<p>Equivalent to <a href="#split/3"><code class="inline">split(Subject, RE, [])</code></a>.</p>
  </section>
</section>
<section class="detail" id="split/3">

  <div class="detail-header">
    <a href="#split/3" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">split(Subject, RE, Options)</h1>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L1108" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> split(Subject, RE, Options) -> SplitList
               when
                   Subject :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                   RE :: <a href="#t:mp/0">mp</a>() | <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                   Options :: [Option],
                   Option ::
                       anchored | notbol | noteol | notempty | notempty_atstart |
                       {offset, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
                       {match_limit, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
                       {match_limit_recursion, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
                       {return, ReturnType} |
                       {parts, NumParts} |
                       group | trim | CompileOpt,
                   NumParts :: <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>() | infinity,
                   ReturnType :: iodata | list | binary,
                   CompileOpt :: <a href="#t:compile_option/0">compile_option</a>(),
                   SplitList :: [RetData] | [GroupedRetData],
                   GroupedRetData :: [RetData],
                   RetData :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>() | <a href="../../apps/erts/erlang.html#t:binary/0">binary</a>() | <a href="../../apps/erts/erlang.html#t:list/0">list</a>().</pre>

      </div>

<p>Splits the input into parts by finding tokens according to the regular
expression supplied.</p><p>The splitting is basically done by running a global regular
expression match and dividing the initial string wherever a match occurs. The
matching part of the string is removed from the output.</p><p>As in <a href="#run/3"><code class="inline">run/3</code></a>, an <a href="#t:mp/0"><code class="inline">mp/0</code></a> compiled with option <code class="inline">unicode</code> requires <code class="inline">Subject</code> to
be a Unicode <code class="inline">charlist()</code>. If compilation is done implicitly and the <code class="inline">unicode</code>
compilation option is specified to this function, both the regular expression
and <code class="inline">Subject</code> are to be specified as valid Unicode <code class="inline">charlist()</code>s.</p><p>The result is given as a list of &quot;strings&quot;, the preferred data type specified in
option <code class="inline">return</code> (default <code class="inline">iodata</code>).</p><p>If subexpressions are specified in the regular expression, the matching
subexpressions are returned in the resulting list as well. For example:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="0042236933-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[ln]&quot;</span><span class="p">,</span><span class="p" data-group-id="0042236933-2">[</span><span class="p" data-group-id="0042236933-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="0042236933-3">}</span><span class="p" data-group-id="0042236933-2">]</span><span class="p" data-group-id="0042236933-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="5173881786-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;g&quot;</span><span class="p" data-group-id="5173881786-1">]</span></code></pre><p>while</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="9582344579-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;([ln])&quot;</span><span class="p">,</span><span class="p" data-group-id="9582344579-2">[</span><span class="p" data-group-id="9582344579-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="9582344579-3">}</span><span class="p" data-group-id="9582344579-2">]</span><span class="p" data-group-id="9582344579-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="2494592506-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;l&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;n&quot;</span><span class="p">,</span><span class="s">&quot;g&quot;</span><span class="p" data-group-id="2494592506-1">]</span></code></pre><p>The text matching the subexpression (marked by the parentheses in the regular
expression) is inserted in the result list where it was found. This means that
concatenating the result of a split where the whole regular expression is a
single subexpression (as in the last example) always results in the original
string.</p><p>As there is no matching subexpression for the last part in the example (the
&quot;g&quot;), nothing is inserted after that. To make the group of strings and the parts
matching the subexpressions more obvious, one can use option <code class="inline">group</code>, which
groups together the part of the subject string with the parts matching the
subexpressions when the string was split:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="2013646056-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;([ln])&quot;</span><span class="p">,</span><span class="p" data-group-id="2013646056-2">[</span><span class="p" data-group-id="2013646056-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="2013646056-3">}</span><span class="p">,</span><span class="ss">group</span><span class="p" data-group-id="2013646056-2">]</span><span class="p" data-group-id="2013646056-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="5826746970-1">[</span><span class="p" data-group-id="5826746970-2">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;l&quot;</span><span class="p" data-group-id="5826746970-2">]</span><span class="p">,</span><span class="p" data-group-id="5826746970-3">[</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;n&quot;</span><span class="p" data-group-id="5826746970-3">]</span><span class="p">,</span><span class="p" data-group-id="5826746970-4">[</span><span class="s">&quot;g&quot;</span><span class="p" data-group-id="5826746970-4">]</span><span class="p" data-group-id="5826746970-1">]</span></code></pre><p>Here the regular expression first matched the &quot;l&quot;, causing &quot;Er&quot; to be the first
part in the result. When the regular expression matched, the (only)
subexpression was bound to the &quot;l&quot;, so the &quot;l&quot; is inserted in the group together
with &quot;Er&quot;. The next match is of the &quot;n&quot;, making &quot;a&quot; the next part to be
returned. As the subexpression is bound to substring &quot;n&quot; in this case, the &quot;n&quot;
is inserted into this group. The last group consists of the remaining string, as
no more matches are found.</p><p>By default, all parts of the string, including the empty strings, are returned
from the function, for example:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="2666873372-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[lg]&quot;</span><span class="p">,</span><span class="p" data-group-id="2666873372-2">[</span><span class="p" data-group-id="2666873372-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="2666873372-3">}</span><span class="p" data-group-id="2666873372-2">]</span><span class="p" data-group-id="2666873372-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="6017238254-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;an&quot;</span><span class="p">,</span><span class="p" data-group-id="6017238254-2">[</span><span class="p" data-group-id="6017238254-2">]</span><span class="p" data-group-id="6017238254-1">]</span></code></pre><p>as the matching of the &quot;g&quot; in the end of the string leaves an empty rest, which
is also returned. This behavior differs from the default behavior of the split
function in Perl, where empty strings at the end are by default removed. To get
the &quot;trimming&quot; default behavior of Perl, specify <code class="inline">trim</code> as an option:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="1855712921-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[lg]&quot;</span><span class="p">,</span><span class="p" data-group-id="1855712921-2">[</span><span class="p" data-group-id="1855712921-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="1855712921-3">}</span><span class="p">,</span><span class="ss">trim</span><span class="p" data-group-id="1855712921-2">]</span><span class="p" data-group-id="1855712921-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="8126199393-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;an&quot;</span><span class="p" data-group-id="8126199393-1">]</span></code></pre><p>The &quot;trim&quot; option says; &quot;give me as many parts as possible except the empty
ones&quot;, which sometimes can be useful. You can also specify how many parts you
want, by specifying <code class="inline">{parts,</code>N<code class="inline">}</code>:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="0917515072-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[lg]&quot;</span><span class="p">,</span><span class="p" data-group-id="0917515072-2">[</span><span class="p" data-group-id="0917515072-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="0917515072-3">}</span><span class="p">,</span><span class="p" data-group-id="0917515072-4">{</span><span class="ss">parts</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="0917515072-4">}</span><span class="p" data-group-id="0917515072-2">]</span><span class="p" data-group-id="0917515072-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="4228641271-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;ang&quot;</span><span class="p" data-group-id="4228641271-1">]</span></code></pre><p>Notice that the last part is &quot;ang&quot;, not &quot;an&quot;, as splitting was specified into
two parts, and the splitting stops when enough parts are given, which is why the
result differs from that of <code class="inline">trim</code>.</p><p>More than three parts are not possible with this indata, so</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="6117109194-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[lg]&quot;</span><span class="p">,</span><span class="p" data-group-id="6117109194-2">[</span><span class="p" data-group-id="6117109194-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="6117109194-3">}</span><span class="p">,</span><span class="p" data-group-id="6117109194-4">{</span><span class="ss">parts</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="6117109194-4">}</span><span class="p" data-group-id="6117109194-2">]</span><span class="p" data-group-id="6117109194-1">)</span><span class="p">.</span></code></pre><p>gives the same result as the default, which is to be viewed as &quot;an infinite
number of parts&quot;.</p><p>Specifying <code class="inline">0</code> as the number of parts gives the same effect as option <code class="inline">trim</code>. If
subexpressions are captured, empty subexpressions matched at the end are also
stripped from the result if <code class="inline">trim</code> or <code class="inline">{parts,0}</code> is specified.</p><p>The <code class="inline">trim</code> behavior corresponds exactly to the Perl default. <code class="inline">{parts,N}</code>, where
N is a positive integer, corresponds exactly to the Perl behavior with a
positive numerical third parameter. The default behavior of
<a href="#split/3"><code class="inline">split/3</code></a> corresponds to the Perl behavior when a negative integer
is specified as the third parameter for the Perl routine.</p><p>Summary of options not previously described for function <a href="#run/3"><code class="inline">run/3</code></a>:</p><ul><li><p><strong><code class="inline">{return,ReturnType}</code></strong> - Specifies how the parts of the original string are
presented in the result list. Valid types:</p><ul><li><p><strong><code class="inline">iodata</code></strong> - The variant of <a href="../../apps/erts/erlang.html#t:iodata/0"><code class="inline">iodata/0</code></a> that gives the least copying of
data with the current implementation (often a binary, but do not depend on
it).</p></li><li><p><strong><code class="inline">binary</code></strong> - All parts returned as binaries.</p></li><li><p><strong><code class="inline">list</code></strong> - All parts returned as lists of characters (&quot;strings&quot;).</p></li></ul></li><li><p><strong><code class="inline">group</code></strong> - Groups together the part of the string with the parts of the
string matching the subexpressions of the regular expression.</p><p>The return value from the function is in this case a <a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a> of
<a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a>s. Each sublist begins with the string picked out of the subject
string, followed by the parts matching each of the subexpressions in order of
occurrence in the regular expression.</p></li><li><p><strong><code class="inline">{parts,N}</code></strong> - Specifies the number of parts the subject string is to be
split into.</p><p>The number of parts is to be a positive integer for a specific maximum number
of parts, and <code class="inline">infinity</code> for the maximum number of parts possible (the
default). Specifying <code class="inline">{parts,0}</code> gives as many parts as possible disregarding
empty parts at the end, the same as specifying <code class="inline">trim</code>.</p></li><li><p><strong><code class="inline">trim</code></strong> - Specifies that empty parts at the end of the result list are to
be disregarded. The same as specifying <code class="inline">{parts,0}</code>. This corresponds to the
default behavior of the <code class="inline">split</code> built-in function in Perl.</p></li></ul>
  </section>
</section>
<section class="detail" id="version/0">

  <div class="detail-header">
    <a href="#version/0" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">version()</h1>

        <span class="note">(since OTP 20.0)</span>


        <a href="https://github.com/erlang/otp/blob/OTP-28.2/lib/stdlib/src/re.erl#L120" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> version() -> <a href="../../apps/erts/erlang.html#t:binary/0">binary</a>().</pre>

      </div>

<p>The return of this function is a string with the PCRE version of the system that
was used in the Erlang/OTP compilation.</p>
  </section>
</section>

    </div>
  </section>

    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="stdlib.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.38.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright Â© 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
