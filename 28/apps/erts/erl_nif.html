<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.38.1">
    <meta name="project" content="erts v16.1.2">


<meta name="major-vsn" content="28">
<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=28&q=">
<link rel="canonical" href="https://www.erlang.org/doc/apps/erts/erl_nif.html" />
    <title>erl_nif â€” erts v16.1.2</title>

    <link rel="stylesheet" href="dist/html-erlang-ZK43ZOAC.css" />

    <script defer src="dist/sidebar_items-E03DE236.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-DPJLHKSM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="erts" />
        </a>

      <div>
        <a href="../../index.html" class="sidebar-projectName" translate="no">
erts
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v16.1.2
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of erts</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>erl_nif</h1>


      <a href="https://github.com/erlang/otp/blob/OTP-28.2/erts/doc/references/erl_nif.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<p>API functions for an Erlang NIF library.</p><h2 id="description" class="section-heading"><a href="#description" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Description</span></h2><p>A NIF library contains native implementation of some functions of an Erlang
module. The native implemented functions (NIFs) are called like any other
functions without any difference to the caller. A NIF library is built as a
dynamically linked library file and loaded in runtime by calling
<a href="erlang.html#load_nif/2"><code class="inline">erlang:load_nif/2</code></a>.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p><a href="" id="WARNING"></a> <em>Use this functionality with extreme care.</em></p><p>A native function is executed as a direct extension of the native code of the
VM. Execution is not made in a safe environment. The VM <em>cannot</em> provide the
same services as provided when executing Erlang code, such as pre-emptive
scheduling or memory protection. If the native function does not behave well,
the whole VM will misbehave.</p><ul><li>A native function that crashes will crash the whole VM.</li><li>An erroneously implemented native function can cause a VM internal state
inconsistency, which can cause a crash of the VM, or miscellaneous
misbehaviors of the VM at any point after the call to the native function.</li><li>A native function doing <a href="erl_nif.html#lengthy_work">lengthy work</a> before
returning degrades responsiveness of the VM, and can cause miscellaneous
strange behaviors. Such strange behaviors include, but are not limited to,
extreme memory usage, and bad load balancing between schedulers. Strange
behaviors that can occur because of lengthy work can also vary between
Erlang/OTP releases.</li></ul></section><h2 id="example" class="section-heading"><a href="#example" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Example</span></h2><p>A minimal example of a NIF library can look as follows:</p><pre><code class="makeup c" translate="no"><span class="cm">/* niftest.c */</span><span class="w">
</span><span class="kp">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">erl_nif</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span><span class="w">

</span><span class="k">static</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">hello</span><span class="p" data-group-id="0267536450-1">(</span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">argv</span><span class="p" data-group-id="0267536450-2">[</span><span class="p" data-group-id="0267536450-2">]</span><span class="p" data-group-id="0267536450-1">)</span><span class="w">
</span><span class="p" data-group-id="0267536450-3">{</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="nf">enif_make_string</span><span class="p" data-group-id="0267536450-4">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello world!&quot;</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_LATIN1</span><span class="p" data-group-id="0267536450-4">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="0267536450-3">}</span><span class="w">

</span><span class="k">static</span><span class="w"> </span><span class="no">ErlNifFunc</span><span class="w"> </span><span class="n">nif_funcs</span><span class="p" data-group-id="0267536450-5">[</span><span class="p" data-group-id="0267536450-5">]</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="p" data-group-id="0267536450-6">{</span><span class="w">
    </span><span class="p" data-group-id="0267536450-7">{</span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">hello</span><span class="p" data-group-id="0267536450-7">}</span><span class="w">
</span><span class="p" data-group-id="0267536450-6">}</span><span class="p">;</span><span class="w">

</span><span class="no">ERL_NIF_INIT</span><span class="p" data-group-id="0267536450-8">(</span><span class="n">niftest</span><span class="p">,</span><span class="n">nif_funcs</span><span class="p">,</span><span class="no">NULL</span><span class="p">,</span><span class="no">NULL</span><span class="p">,</span><span class="no">NULL</span><span class="p">,</span><span class="no">NULL</span><span class="p" data-group-id="0267536450-8">)</span></code></pre><p>The Erlang module can look as follows:</p><pre><code class="makeup erlang" translate="no"><span class="p">-</span><span class="na">module</span><span class="p" data-group-id="1744849178-1">(</span><span class="ss">niftest</span><span class="p" data-group-id="1744849178-1">)</span><span class="p">.</span><span class="w">
</span><span class="w">
</span><span class="p">-</span><span class="na">export</span><span class="p" data-group-id="1744849178-2">(</span><span class="p" data-group-id="1744849178-3">[</span><span class="ss">init</span><span class="p">/</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="ss">hello</span><span class="p">/</span><span class="mi">0</span><span class="p" data-group-id="1744849178-3">]</span><span class="p" data-group-id="1744849178-2">)</span><span class="p">.</span><span class="w">
</span><span class="w">
</span><span class="p">-</span><span class="na">nifs</span><span class="p" data-group-id="1744849178-4">(</span><span class="p" data-group-id="1744849178-5">[</span><span class="ss">hello</span><span class="p">/</span><span class="mi">0</span><span class="p" data-group-id="1744849178-5">]</span><span class="p" data-group-id="1744849178-4">)</span><span class="p">.</span><span class="w">
</span><span class="w">
</span><span class="p">-</span><span class="na">on_load</span><span class="p" data-group-id="1744849178-6">(</span><span class="ss">init</span><span class="p">/</span><span class="mi">0</span><span class="p" data-group-id="1744849178-6">)</span><span class="p">.</span><span class="w">

</span><span class="nf">init</span><span class="p" data-group-id="1744849178-7">(</span><span class="p" data-group-id="1744849178-7">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
      </span><span class="nc">erlang</span><span class="p">:</span><span class="nf">load_nif</span><span class="p" data-group-id="1744849178-8">(</span><span class="s">&quot;./niftest&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="1744849178-8">)</span><span class="p">.</span><span class="w">

</span><span class="nf">hello</span><span class="p" data-group-id="1744849178-9">(</span><span class="p" data-group-id="1744849178-9">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
      </span><span class="nc">erlang</span><span class="p">:</span><span class="nf">nif_error</span><span class="p" data-group-id="1744849178-10">(</span><span class="s">&quot;NIF library not loaded&quot;</span><span class="p" data-group-id="1744849178-10">)</span><span class="p">.</span></code></pre><p>Compile and test can look as follows (on Linux):</p><pre><code class="text">$&gt; gcc -fPIC -shared -o niftest.so niftest.c -I $ERL_ROOT/usr/include/
$&gt; erl

1&gt; c(niftest).
{ok,niftest}
2&gt; niftest:hello().
&quot;Hello world!&quot;</code></pre><p>In the example above the <a href="../../system/code_loading.html#on_load"><em><code class="inline">on_load</code></em></a>
directive is used get function <code class="inline">init</code> called automatically when the module is
loaded. Function <code class="inline">init</code> in turn calls <a href="erlang.html#load_nif/2"><code class="inline">erlang:load_nif/2</code></a> which loads the NIF
library and replaces the <code class="inline">hello</code> function with its native implementation in C.
Once loaded, a NIF library is persistent. It will not be unloaded until the
module instance that it belongs to is purged.</p><p>The <a href="../../system/modules.html#nifs_attribute"><code class="inline">-nifs()</code></a> attribute specifies which
functions in the module that are to be replaced by NIFs.</p><p>Each NIF must have an implementation in Erlang to be invoked if the function is
called before the NIF library is successfully loaded. A typical such stub
implementation is to call <a href="erlang.html#nif_error/1"><code class="inline">erlang:nif_error</code></a> which will
raise an exception. The Erlang function can also be used as a fallback
implementation if the NIF library lacks implementation for some OS or hardware
architecture for example.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>A NIF does not have to be exported, it can be local to the module. However,
unused local stub functions will be optimized away by the compiler, causing
loading of the NIF library to fail.</p></section><h2 id="functionality" class="section-heading"><a href="#functionality" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Functionality</span></h2><p>All interaction between NIF code and the Erlang runtime system is performed by
calling NIF API functions. Functions exist for the following functionality:</p><ul><li><p><strong>Read and write Erlang terms</strong> - Any Erlang terms can be passed to a NIF as
function arguments and be returned as function return values. The terms are of
C-type <a href="erl_nif.html#ERL_NIF_TERM"><code class="inline">ERL_NIF_TERM</code></a> and can only be read or
written using API functions. Most functions to read the content of a term are
prefixed <code class="inline">enif_get_</code> and usually return <code class="inline">true</code> (or <code class="inline">false</code>) if the term is of
the expected type (or not). The functions to write terms are all prefixed
<code class="inline">enif_make_</code> and usually return the created <code class="inline">ERL_NIF_TERM</code>. There are also
some functions to query terms, like <code class="inline">enif_is_atom</code>, <code class="inline">enif_is_identical</code>, and
<code class="inline">enif_compare</code>.</p><p>All terms of type <code class="inline">ERL_NIF_TERM</code> belong to an environment of type
<a href="erl_nif.html#ErlNifEnv"><code class="inline">ErlNifEnv</code></a>, except atoms created during loading (by
callbacks <a href="erl_nif.html#load"><code class="inline">load</code></a> or <a href="erl_nif.html#upgrade"><code class="inline">upgrade</code></a>). The
lifetime of a term is controlled by the lifetime of its environment object.
All API functions that read or write terms have the environment that the term
belongs to as the first function argument. However, the atoms created during
loading can be referred as a term in any <code class="inline">ErlNifEnv</code>. That is, the best
practice it to create all your atoms during loading and store them in
static/global variables, for example:</p><pre><code class="makeup c" translate="no"><span class="kp">#include</span><span class="w"> </span><span class="o">&lt;</span><span class="n">erl_nif</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span><span class="w">

</span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">world_atom</span><span class="p">;</span><span class="w">

</span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">load</span><span class="p" data-group-id="0724601032-1">(</span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="kc">void</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="n">priv_data</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">load_info</span><span class="p" data-group-id="0724601032-1">)</span><span class="w">
</span><span class="p" data-group-id="0724601032-2">{</span><span class="w">
    </span><span class="n">world_atom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">enif_make_atom</span><span class="p" data-group-id="0724601032-3">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;world&quot;</span><span class="p" data-group-id="0724601032-3">)</span><span class="p">;</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="0724601032-2">}</span><span class="w">

</span><span class="k">static</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">hello</span><span class="p" data-group-id="0724601032-4">(</span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">argv</span><span class="p" data-group-id="0724601032-5">[</span><span class="p" data-group-id="0724601032-5">]</span><span class="p" data-group-id="0724601032-4">)</span><span class="w">
</span><span class="p" data-group-id="0724601032-6">{</span><span class="w">
    </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">hello_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">enif_make_string</span><span class="p" data-group-id="0724601032-7">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_LATIN1</span><span class="p" data-group-id="0724601032-7">)</span><span class="p">;</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="nf">enif_make_tuple2</span><span class="p" data-group-id="0724601032-8">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">hello_string</span><span class="p">,</span><span class="w"> </span><span class="n">world_atom</span><span class="p" data-group-id="0724601032-8">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="0724601032-6">}</span><span class="w">

</span><span class="k">static</span><span class="w"> </span><span class="no">ErlNifFunc</span><span class="w"> </span><span class="n">nif_funcs</span><span class="p" data-group-id="0724601032-9">[</span><span class="p" data-group-id="0724601032-9">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="0724601032-10">{</span><span class="w"> </span><span class="p" data-group-id="0724601032-11">{</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="p" data-group-id="0724601032-11">}</span><span class="w"> </span><span class="p" data-group-id="0724601032-10">}</span><span class="p">;</span><span class="w">

</span><span class="no">ERL_NIF_INIT</span><span class="p" data-group-id="0724601032-12">(</span><span class="n">niftest</span><span class="p">,</span><span class="w"> </span><span class="n">nif_funcs</span><span class="p">,</span><span class="w"> </span><span class="n">load</span><span class="p">,</span><span class="w"> </span><span class="no">NULL</span><span class="p">,</span><span class="w"> </span><span class="no">NULL</span><span class="p">,</span><span class="w"> </span><span class="no">NULL</span><span class="p" data-group-id="0724601032-12">)</span></code></pre></li><li><p><strong>Binaries</strong> - Terms of type binary are accessed with the help of struct type
<a href="erl_nif.html#ErlNifBinary"><code class="inline">ErlNifBinary</code></a>, which contains a pointer (<code class="inline">data</code>)
to the raw binary data and the length (<code class="inline">size</code>) of the data in bytes. Both
<code class="inline">data</code> and <code class="inline">size</code> are read-only and are only to be written using calls to API
functions. Instances of <code class="inline">ErlNifBinary</code> are, however, always allocated by the
user (usually as local variables).</p><p>The raw data pointed to by <code class="inline">data</code> is only mutable after a call to
<a href="erl_nif.html#enif_alloc_binary"><code class="inline">enif_alloc_binary</code></a> or
<a href="erl_nif.html#enif_realloc_binary"><code class="inline">enif_realloc_binary</code></a>. All other functions
that operate on a binary leave the data as read-only. A mutable binary must in
the end either be freed with
<a href="erl_nif.html#enif_release_binary"><code class="inline">enif_release_binary</code></a> or made read-only by
transferring it to an Erlang term with
<a href="erl_nif.html#enif_make_binary"><code class="inline">enif_make_binary</code></a>. However, it does not have
to occur in the same NIF call. Read-only binaries do not have to be released.</p><p><a href="erl_nif.html#enif_make_new_binary"><code class="inline">enif_make_new_binary</code></a> can be used as a
shortcut to allocate and return a binary in the same NIF call.</p><p>Binaries are sequences of whole bytes. Bitstrings with an arbitrary bit length
have no support yet.</p></li><li><p><strong id="resource_objects">Resource objects</strong><br/>The use of resource objects is a safe way to return pointers to native data
structures from a NIF. A resource object is only a block of memory allocated
with <a href="erl_nif.html#enif_alloc_resource"><code class="inline">enif_alloc_resource</code></a>. A handle (&quot;safe
pointer&quot;) to this memory block can then be returned to Erlang by the use of
<a href="erl_nif.html#enif_make_resource"><code class="inline">enif_make_resource</code></a>. The term returned by
<code class="inline">enif_make_resource</code> is opaque in nature. It can be stored and passed between
processes, but the only real end usage is to pass it back as an argument to a
NIF. The NIF can then call <a href="erl_nif.html#enif_get_resource"><code class="inline">enif_get_resource</code></a>
and get back a pointer to the memory block, which is guaranteed to still be
valid. A resource object is not deallocated until the last handle term is
garbage collected by the VM and the resource is released with
<a href="erl_nif.html#enif_release_resource"><code class="inline">enif_release_resource</code></a> (not necessarily
in that order).</p><p>All resource objects are created as instances of some <em>resource type</em>. This
makes resources from different modules to be distinguishable. A resource type
is created by calling
<a href="erl_nif.html#enif_open_resource_type"><code class="inline">enif_open_resource_type</code></a> when a library
is loaded. Objects of that resource type can then later be allocated and
<code class="inline">enif_get_resource</code> verifies that the resource is of the expected type. A
resource type can have a user-supplied destructor function, which is
automatically called when resources of that type are released (by either the
garbage collector or <code class="inline">enif_release_resource</code>). Resource types are uniquely
identified by a supplied name string and the name of the implementing module.</p><p><a href="" id="enif_resource_example"></a> The following is a template example of how to
create and return a resource object.</p><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">;</span><span class="w">
</span><span class="no">MyStruct</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">enif_alloc_resource</span><span class="p" data-group-id="9629025910-1">(</span><span class="n">my_resource_type</span><span class="p">,</span><span class="w"> </span><span class="nf">sizeof</span><span class="p" data-group-id="9629025910-2">(</span><span class="no">MyStruct</span><span class="p" data-group-id="9629025910-2">)</span><span class="p" data-group-id="9629025910-1">)</span><span class="p">;</span><span class="w">

</span><span class="cm">/* initialize struct ... */</span><span class="w">

</span><span class="n">term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">enif_make_resource</span><span class="p" data-group-id="9629025910-3">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">obj</span><span class="p" data-group-id="9629025910-3">)</span><span class="p">;</span><span class="w">

</span><span class="k">if</span><span class="w"> </span><span class="p" data-group-id="9629025910-4">(</span><span class="n">keep_a_reference_of_our_own</span><span class="p" data-group-id="9629025910-4">)</span><span class="w"> </span><span class="p" data-group-id="9629025910-5">{</span><span class="w">
    </span><span class="cm">/* store &#39;obj&#39; in static variable, private data or other resource object */</span><span class="w">
</span><span class="p" data-group-id="9629025910-5">}</span><span class="w">
</span><span class="k">else</span><span class="w"> </span><span class="p" data-group-id="9629025910-6">{</span><span class="w">
    </span><span class="nf">enif_release_resource</span><span class="p" data-group-id="9629025910-7">(</span><span class="n">obj</span><span class="p" data-group-id="9629025910-7">)</span><span class="p">;</span><span class="w">
    </span><span class="cm">/* resource now only owned by &quot;Erlang&quot; */</span><span class="w">
</span><span class="p" data-group-id="9629025910-6">}</span><span class="w">
</span><span class="k">return</span><span class="w"> </span><span class="n">term</span><span class="p">;</span></code></pre><p>Notice that once <code class="inline">enif_make_resource</code> creates the term to return to Erlang,
the code can choose to either keep its own native pointer to the allocated
struct and release it later, or release it immediately and rely only on the
garbage collector to deallocate the resource object eventually when it
collects the term.</p><p>Another use of resource objects is to create binary terms with user-defined
memory management.
<a href="erl_nif.html#enif_make_resource_binary"><code class="inline">enif_make_resource_binary</code></a> creates a
binary term that is connected to a resource object. The destructor of the
resource is called when the binary is garbage collected, at which time the
binary data can be released. An example of this can be a binary term
consisting of data from a <code class="inline">mmap</code>'ed file. The destructor can then do <code class="inline">munmap</code>
to release the memory region.</p><p>Resource types support upgrade in runtime by allowing a loaded NIF library to
take over an already existing resource type and by that &quot;inherit&quot; all existing
objects of that type. The destructor of the new library is thereafter called
for the inherited objects and the library with the old destructor function can
be safely unloaded. Existing resource objects, of a module that is upgraded,
must either be deleted or taken over by the new NIF library. The unloading of
a library is postponed as long as there exist resource objects with a
destructor function in the library.</p></li><li><p><strong>Module upgrade and static data</strong> - A loaded NIF library is tied to the
Erlang module instance that loaded it. If the module is upgraded, the new
module instance needs to load its own NIF library (or maybe choose not to).
The new module instance can, however, choose to load the exact same NIF
library as the old code if it wants to. Sharing the dynamic library means that
static data defined by the library is shared as well. To avoid unintentionally
shared static data between module instances, each Erlang module version can
keep its own private data. This private data can be set when the NIF library
is loaded and later retrieved by calling
<a href="erl_nif.html#enif_priv_data"><code class="inline">enif_priv_data</code></a>.</p></li><li><p><strong>Threads and concurrency</strong> - A NIF is thread-safe without any explicit
synchronization as long as it acts as a pure function and only reads the
supplied arguments. When you write to a shared state either through static
variables or <a href="erl_nif.html#enif_priv_data"><code class="inline">enif_priv_data</code></a>, you need to supply
your own explicit synchronization. This includes terms in process independent
environments that are shared between threads. Resource objects also require
synchronization if you treat them as mutable.</p><p>The library initialization callbacks <code class="inline">load</code> and <code class="inline">upgrade</code> are thread-safe even
for shared state data.</p></li><li><p><strong id="version_management">Version Management</strong> -
When a NIF library is built, information about the NIF API version is compiled
into the library. When a NIF library is loaded, the runtime system verifies
that the library is of a compatible version. <code class="inline">erl_nif.h</code> defines the
following:</p><ul><li><p><strong><code class="inline">ERL_NIF_MAJOR_VERSION</code></strong> - Incremented when NIF library incompatible
changes are made to the Erlang runtime system. Normally it suffices to
recompile the NIF library when the <code class="inline">ERL_NIF_MAJOR_VERSION</code> has changed, but
it can, under rare circumstances, mean that NIF libraries must be slightly
modified. If so, this will of course be documented.</p></li><li><p><strong><code class="inline">ERL_NIF_MINOR_VERSION</code></strong> - Incremented when new features are added. The
runtime system uses the minor version to determine what features to use.</p></li></ul><p>The runtime system normally refuses to load a NIF library if the major
versions differ, or if the major versions are equal and the minor version used
by the NIF library is greater than the one used by the runtime system. Old NIF
libraries with lower major versions are, however, allowed after a bump of the
major version during a transition period of two major releases. Such old NIF
libraries can however fail if deprecated features are used.</p></li><li><p><strong id="time_measurement">Time Measurement</strong> -
Support for time measurement in NIF libraries:</p><ul><li><a href="erl_nif.html#ErlNifTime"><code class="inline">ErlNifTime</code></a></li><li><a href="erl_nif.html#ErlNifTimeUnit"><code class="inline">ErlNifTimeUnit</code></a></li><li><a href="erl_nif.html#enif_monotonic_time"><code class="inline">enif_monotonic_time()</code></a></li><li><a href="erl_nif.html#enif_time_offset"><code class="inline">enif_time_offset()</code></a></li><li><a href="erl_nif.html#enif_convert_time_unit"><code class="inline">enif_convert_time_unit()</code></a></li></ul></li><li><p><strong id="enif_ioq">I/O Queues</strong><br/>The Erlang nif library contains function for easily working with I/O vectors
as used by the unix system call <code class="inline">writev</code>. The I/O Queue is not thread safe, so
some other synchronization mechanism has to be used.</p><ul><li><a href="erl_nif.html#SysIOVec"><code class="inline">SysIOVec</code></a></li><li><a href="erl_nif.html#ErlNifIOVec"><code class="inline">ErlNifIOVec</code></a></li><li><a href="erl_nif.html#enif_ioq_create"><code class="inline">enif_ioq_create()</code></a></li><li><a href="erl_nif.html#enif_ioq_destroy"><code class="inline">enif_ioq_destroy()</code></a></li><li><a href="erl_nif.html#enif_ioq_enq_binary"><code class="inline">enif_ioq_enq_binary()</code></a></li><li><a href="erl_nif.html#enif_ioq_enqv"><code class="inline">enif_ioq_enqv()</code></a></li><li><a href="erl_nif.html#enif_ioq_deq"><code class="inline">enif_ioq_deq()</code></a></li><li><a href="erl_nif.html#enif_ioq_peek"><code class="inline">enif_ioq_peek()</code></a></li><li><a href="erl_nif.html#enif_ioq_peek_head"><code class="inline">enif_ioq_peek_head()</code></a></li><li><a href="erl_nif.html#enif_inspect_iovec"><code class="inline">enif_inspect_iovec()</code></a></li><li><a href="erl_nif.html#enif_free_iovec"><code class="inline">enif_free_iovec()</code></a></li></ul><p>Typical usage when writing to a file descriptor looks like this:</p><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">writeiovec</span><span class="p" data-group-id="7794727404-1">(</span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="o">*</span><span class="n">tail</span><span class="p">,</span><span class="w">
               </span><span class="no">ErlNifIOQueue</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p" data-group-id="7794727404-1">)</span><span class="w"> </span><span class="p" data-group-id="7794727404-2">{</span><span class="w">

    </span><span class="no">ErlNifIOVec</span><span class="w"> </span><span class="n">vec</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">iovec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">;</span><span class="w">
    </span><span class="no">SysIOVec</span><span class="w"> </span><span class="o">*</span><span class="n">sysiovec</span><span class="p">;</span><span class="w">
    </span><span class="kt">int</span><span class="w"> </span><span class="n">saved_errno</span><span class="p">;</span><span class="w">
    </span><span class="kt">int</span><span class="w"> </span><span class="n">iovcnt</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">

    </span><span class="k">if</span><span class="w"> </span><span class="p" data-group-id="7794727404-3">(</span><span class="o">!</span><span class="nf">enif_inspect_iovec</span><span class="p" data-group-id="7794727404-4">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iovec</span><span class="p" data-group-id="7794727404-4">)</span><span class="p" data-group-id="7794727404-3">)</span><span class="w">
        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="w">

    </span><span class="k">if</span><span class="w"> </span><span class="p" data-group-id="7794727404-5">(</span><span class="nf">enif_ioq_size</span><span class="p" data-group-id="7794727404-6">(</span><span class="n">q</span><span class="p" data-group-id="7794727404-6">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="7794727404-5">)</span><span class="w"> </span><span class="p" data-group-id="7794727404-7">{</span><span class="w">
        </span><span class="cm">/* If the I/O queue contains data we enqueue the iovec and
           then peek the data to write out of the queue. */</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p" data-group-id="7794727404-8">(</span><span class="o">!</span><span class="nf">enif_ioq_enqv</span><span class="p" data-group-id="7794727404-9">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">iovec</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="7794727404-9">)</span><span class="p" data-group-id="7794727404-8">)</span><span class="w">
            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">;</span><span class="w">

        </span><span class="n">sysiovec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">enif_ioq_peek</span><span class="p" data-group-id="7794727404-10">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iovcnt</span><span class="p" data-group-id="7794727404-10">)</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="7794727404-7">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p" data-group-id="7794727404-11">{</span><span class="w">
        </span><span class="cm">/* If the I/O queue is empty we skip the trip through it. */</span><span class="w">
        </span><span class="n">iovcnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iovec</span><span class="o">-&gt;</span><span class="n">iovcnt</span><span class="p">;</span><span class="w">
        </span><span class="n">sysiovec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iovec</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="7794727404-11">}</span><span class="w">

    </span><span class="cm">/* Attempt to write the data */</span><span class="w">
    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">writev</span><span class="p" data-group-id="7794727404-12">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">sysiovec</span><span class="p">,</span><span class="w"> </span><span class="n">iovcnt</span><span class="p" data-group-id="7794727404-12">)</span><span class="p">;</span><span class="w">
    </span><span class="n">saved_errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">errno</span><span class="p">;</span><span class="w">

    </span><span class="k">if</span><span class="w"> </span><span class="p" data-group-id="7794727404-13">(</span><span class="nf">enif_ioq_size</span><span class="p" data-group-id="7794727404-14">(</span><span class="n">q</span><span class="p" data-group-id="7794727404-14">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="7794727404-13">)</span><span class="w"> </span><span class="p" data-group-id="7794727404-15">{</span><span class="w">
        </span><span class="cm">/* If the I/O queue was initially empty we enqueue any
           remaining data into the queue for writing later. */</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p" data-group-id="7794727404-16">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="nf">enif_ioq_enqv</span><span class="p" data-group-id="7794727404-17">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">iovec</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p" data-group-id="7794727404-17">)</span><span class="p" data-group-id="7794727404-16">)</span><span class="w">
            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="7794727404-15">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p" data-group-id="7794727404-18">{</span><span class="w">
        </span><span class="cm">/* Dequeue any data that was written from the queue. */</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p" data-group-id="7794727404-19">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="nf">enif_ioq_deq</span><span class="p" data-group-id="7794727404-20">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="no">NULL</span><span class="p" data-group-id="7794727404-20">)</span><span class="p" data-group-id="7794727404-19">)</span><span class="w">
            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="7794727404-18">}</span><span class="w">

    </span><span class="cm">/* return n, which is either number of bytes written or -1 if
       some error happened */</span><span class="w">
    </span><span class="n">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">saved_errno</span><span class="p">;</span><span class="w">
    </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="7794727404-2">}</span></code></pre></li><li><p><strong id="lengthy_work">Long-running NIFs</strong><br/>As mentioned in the <a href="erl_nif.html#WARNING">warning</a> text at the beginning of
this manual page, it is of <em>vital importance</em> that a native function returns
relatively fast. It is difficult to give an exact maximum amount of time that
a native function is allowed to work, but usually a well-behaving native
function is to return to its caller within 1 millisecond. This can be achieved
using different approaches. If you have full control over the code to execute
in the native function, the best approach is to divide the work into multiple
chunks of work and call the native function multiple times. This is, however,
not always possible, for example when calling third-party libraries.</p><p>The <a href="erl_nif.html#enif_consume_timeslice"><code class="inline">enif_consume_timeslice()</code></a> function
can be used to inform the runtime system about the length of the NIF call. It
is typically always to be used unless the NIF executes very fast.</p><p>If the NIF call is too lengthy, this must be handled in one of the following
ways to avoid degraded responsiveness, scheduler load balancing problems, and
other strange behaviors:</p><ul><li><p><strong>Yielding NIF</strong> - If the functionality of a long-running NIF can be split
so that its work can be achieved through a series of shorter NIF calls, the
application has two options:</p><ul><li>Make that series of NIF calls from the Erlang level.</li><li>Call a NIF that first performs a chunk of the work, then invokes the
<a href="erl_nif.html#enif_schedule_nif"><code class="inline">enif_schedule_nif</code></a> function to schedule
another NIF call to perform the next chunk. The final call scheduled in
this manner can then return the overall result.</li></ul><p>Breaking up a long-running function in this manner enables the VM to regain
control between calls to the NIFs.</p><p>This approach is always preferred over the other alternatives described
below. This both from a performance perspective and a system characteristics
perspective.</p></li><li><p><strong>Threaded NIF</strong> - This is accomplished by dispatching the work to another
thread managed by the NIF library, return from the NIF, and wait for the
result. The thread can send the result back to the Erlang process using
<a href="erl_nif.html#enif_send"><code class="inline">enif_send</code></a>. Information about thread primitives is
provided below.</p></li><li><p><strong id="dirty_nifs">Dirty NIF</strong><br/>A NIF that cannot be split and cannot execute in a millisecond or less is
called a &quot;dirty NIF&quot;, as it performs work that the ordinary schedulers of
the Erlang runtime system cannot handle cleanly. Applications that make use
of such functions must indicate to the runtime that the functions are dirty
so they can be handled specially. This is handled by executing dirty jobs on
a separate set of schedulers called dirty schedulers. A dirty NIF executing
on a dirty scheduler does not have the same duration restriction as a normal
NIF.</p><p>It is important to classify the dirty job correct. An I/O bound job should
be classified as such, and a CPU bound job should be classified as such. If
you should classify CPU bound jobs as I/O bound jobs, dirty I/O schedulers
might starve ordinary schedulers. I/O bound jobs are expected to either
block waiting for I/O, and/or spend a limited amount of time moving data.</p><p>To schedule a dirty NIF for execution, the application has two options:</p><ul><li>Set the appropriate flags value for the dirty NIF in its
<a href="erl_nif.html#ErlNifFunc"><code class="inline">ErlNifFunc</code></a> entry.</li><li>Call <a href="erl_nif.html#enif_schedule_nif"><code class="inline">enif_schedule_nif</code></a>, pass to it a
pointer to the dirty NIF to be executed, and indicate with argument
<code class="inline">flags</code> whether it expects the operation to be CPU-bound or I/O-bound.</li></ul><p>A job that alternates between I/O bound and CPU bound can be reclassified
and rescheduled using <code class="inline">enif_schedule_nif</code> so that it executes on the correct
type of dirty scheduler at all times. For more information see the
documentation of the <a href="erl_cmd.html">erl</a> command line arguments
<a href="erl_cmd.html#%2BSDcpu"><code class="inline">+SDcpu</code></a>, and <a href="erl_cmd.html#%2BSDio"><code class="inline">+SDio</code></a>.</p><p>While a process executes a dirty NIF, some operations that communicate with
it can take a very long time to complete. Suspend or garbage collection of a
process executing a dirty NIF cannot be done until the dirty NIF has
returned. Thus, other processes waiting for such operations to complete
might have to wait for a very long time. Blocking multi-scheduling, that is,
calling
<a href="erlang.html#system_flag_multi_scheduling"><code class="inline">erlang:system_flag(multi_scheduling, block)</code></a>,
can also take a very long time to complete. This is because all ongoing
dirty operations on all dirty schedulers must complete before the block
operation can complete.</p><p>Many operations communicating with a process executing a dirty NIF can,
however, complete while it executes the dirty NIF. For example, retrieving
information about it through <a href="erlang.html#process_info/1"><code class="inline">process_info</code></a>,
setting its group leader, register/unregister its name, and so on.</p><p>Termination of a process executing a dirty NIF can only be completed up to a
certain point while it executes the dirty NIF. All Erlang resources, such as
its registered name and its ETS tables, are released. All links and monitors
are triggered. The execution of the NIF is, however, <em>not</em> stopped. The NIF
can safely continue execution, allocate heap memory, and so on, but it is of
course better to stop executing as soon as possible. The NIF can check
whether a current process is alive using
<a href="erl_nif.html#enif_is_current_process_alive"><code class="inline">enif_is_current_process_alive</code></a>.
Communication using <a href="erl_nif.html#enif_send"><code class="inline">enif_send</code></a> and
<a href="erl_nif.html#enif_port_command"><code class="inline">enif_port_command</code></a> is also dropped when the
sending process is not alive. Deallocation of certain internal resources,
such as process heap and process control block, is delayed until the dirty
NIF has completed.</p></li></ul></li></ul><h2 id="initialization" class="section-heading"><a href="#initialization" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Initialization</span></h2><ul><li><p><strong id="ERL_NIF_INIT"><code class="inline">ERL_NIF_INIT(MODULE, ErlNifFunc funcs[], load, NULL, upgrade, unload)</code></strong> -
This is the magic macro to initialize a NIF library. It is
to be evaluated in global file scope.</p><p><code class="inline">MODULE</code> is the name of the Erlang module as an identifier without string
quotations. It is stringified by the macro.</p><p><code class="inline">funcs</code> is a static array of function descriptors for all the implemented NIFs
in this library.</p><p><code class="inline">load</code>, <code class="inline">upgrade</code> and <code class="inline">unload</code> are pointers to functions. One of <code class="inline">load</code> or
<code class="inline">upgrade</code> is called to initialize the library. <code class="inline">unload</code> is called to release
the library. All are described individually below.</p><p>The fourth argument <code class="inline">NULL</code> is ignored. It was earlier used for the deprecated
<code class="inline">reload</code> callback which is no longer supported since OTP 20.</p><p>If compiling a NIF lib for static inclusion through <code class="inline">--enable-static-nifs</code>,
then the macro <code class="inline">STATIC_ERLANG_NIF_LIBNAME</code> must be defined as the name of the
archive file (excluding file extension .a) without string quotations. It must
only contain characters allowed in a C indentifier. The macro must be defined
before <code class="inline">erl_nif.h</code> is included. If the older macro <code class="inline">STATIC_ERLANG_NIF</code> is
instead used, then the name of the archive file must match the name of the
module.</p><p>Multiple static NIF libraries can be included in a single archive file by
specifying the respective <code class="inline">STATIC_ERLANG_NIF_LIBNAME</code> values in the configure
call separated by colons after the archive file name:</p><pre><code class="makeup sh" translate="no"><span class="">./confgure --enable-static-nifs=/path/to/archive.a:nif_lib1:nif_lib2
</span></code></pre></li><li><p><strong><code class="inline">int (*load)(ErlNifEnv* caller_env, void** priv_data, ERL_NIF_TERM load_info)</code></strong> - 
<code class="inline" id="load">load</code> is called when the NIF library is loaded and no previously
loaded library exists for this module.</p><p><code class="inline">*priv_data</code> can be set to point to some private data if the library needs to
keep a state between NIF calls. <code class="inline">enif_priv_data</code> returns this pointer.
<code class="inline">*priv_data</code> is initialized to <code class="inline">NULL</code> when <code class="inline">load</code> is called.</p><p><code class="inline">load_info</code> is the second argument to <a href="erlang.html#load_nif/2"><code class="inline">erlang:load_nif/2</code></a>.</p><p>The library fails to load if <code class="inline">load</code> returns anything other than <code class="inline">0</code>. <code class="inline">load</code>
can be <code class="inline">NULL</code> if initialization is not needed.</p></li><li><p><strong><code class="inline">int (*upgrade)(ErlNifEnv* caller_env, void** priv_data, void** old_priv_data, ERL_NIF_TERM load_info)</code></strong> - <code class="inline" id="upgrade">upgrade</code> is called when the NIF library is loaded and there is
old code of this module with a loaded NIF library.</p><p>Works as <code class="inline">load</code>, except that <code class="inline">*old_priv_data</code> already contains the value set
by the last call to <code class="inline">load</code> or <code class="inline">upgrade</code> for the old module instance. <code class="inline">*priv_data</code>
is initialized to <code class="inline">NULL</code> when <code class="inline">upgrade</code> is called. It is allowed to write to
both <code class="inline">*priv_data</code> and <code class="inline">*old_priv_data.</code></p><p>The library fails to load if <code class="inline">upgrade</code> returns anything other than <code class="inline">0</code> or if
<code class="inline">upgrade</code> is <code class="inline">NULL</code>.</p></li><li><p><strong id="unload"><code class="inline">void (*unload)(ErlNifEnv* caller_env, void* priv_data)</code></strong> -
<code class="inline">unload</code> is called when the module instance that the NIF library belongs to is
purged as old. New code of the same module may or may not exist.</p></li></ul><h2 id="data-types" class="section-heading"><a href="#data-types" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Data Types</span></h2><ul><li><p><strong id="ERL_NIF_TERM"><code class="inline">ERL_NIF_TERM</code></strong> - Variables of type <code class="inline">ERL_NIF_TERM</code> can
refer to any Erlang term. This is an opaque type and values of it can only by
used either as arguments to API functions or as return values from NIFs. All
<code class="inline">ERL_NIF_TERM</code>s belong to an environment
(<a href="erl_nif.html#ErlNifEnv"><code class="inline">ErlNifEnv</code></a>). A term cannot be destructed
individually, it is valid until its environment is destructed.</p></li><li><p><strong id="ErlNifEnv"><code class="inline">ErlNifEnv</code></strong> - <code class="inline">ErlNifEnv</code> represents an environment that
can host Erlang terms. All terms in an environment are valid as long as the
environment is valid. <code class="inline">ErlNifEnv</code> is an opaque type; pointers to it can only
be passed on to API functions. Three types of environments exist:</p><ul><li><p><strong id="proc_bound_env">Process bound environment</strong><br/>Passed as the first argument to all NIFs. All function arguments passed to a
NIF belong to that environment. The return value from a NIF must also be a
term belonging to the same environment.</p><p>A process bound environment contains transient information about the calling
Erlang process. The environment is only valid in the thread where it was
supplied as argument until the NIF returns. It is thus useless and dangerous
to store pointers to process bound environments between NIF calls.</p></li><li><p><strong id="callback_env">Callback environment</strong><br/>Passed as the first argument to all the non-NIF callback functions
(<a href="erl_nif.html#load"><code class="inline">load</code></a>, <a href="erl_nif.html#upgrade"><code class="inline">upgrade</code></a>,
<a href="erl_nif.html#unload"><code class="inline">unload</code></a>, <a href="erl_nif.html#ErlNifResourceDtor"><code class="inline">dtor</code></a>,
<a href="erl_nif.html#ErlNifResourceDown"><code class="inline">down</code></a>,
<a href="erl_nif.html#ErlNifResourceStop"><code class="inline">stop</code></a> and
<a href="erl_nif.html#ErlNifResourceDynCall"><code class="inline">dyncall</code></a>). Works like a process bound
environment but with a temporary pseudo process that &quot;terminates&quot; when the
callback has returned. Terms may be created in this environment but they
will only be accessible during the callback.</p></li><li><p><strong id="proc_indep_env">Process independent environment</strong><br/>Created by calling <a href="erl_nif.html#enif_alloc_env"><code class="inline">enif_alloc_env</code></a>. This
environment can be used to store terms between NIF calls and to send terms
with <a href="erl_nif.html#enif_send"><code class="inline">enif_send</code></a>. A process independent environment
with all its terms is valid until you explicitly invalidate it with
<a href="erl_nif.html#enif_free_env"><code class="inline">enif_free_env</code></a> or <code class="inline">enif_send</code>.</p></li></ul><p>All contained terms of a list/tuple/map must belong to the same environment as
the list/tuple/map itself. Terms can be copied between environments with
<a href="erl_nif.html#enif_make_copy"><code class="inline">enif_make_copy</code></a>.</p></li><li><p><strong id="ErlNifFunc"><code class="inline">ErlNifFunc</code></strong></p><pre><code class="makeup c" translate="no"><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p" data-group-id="7337292379-1">{</span><span class="w">
    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w">
    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">arity</span><span class="p">;</span><span class="w">
    </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="p" data-group-id="7337292379-2">(</span><span class="o">*</span><span class="n">fptr</span><span class="p" data-group-id="7337292379-2">)</span><span class="p" data-group-id="7337292379-3">(</span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">argv</span><span class="p" data-group-id="7337292379-4">[</span><span class="p" data-group-id="7337292379-4">]</span><span class="p" data-group-id="7337292379-3">)</span><span class="p">;</span><span class="w">
    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="7337292379-1">}</span><span class="w"> </span><span class="no">ErlNifFunc</span><span class="p">;</span></code></pre><p>Describes a NIF by its name, arity, and implementation.</p><ul><li><p><strong><code class="inline">fptr</code></strong> - A pointer to the function that implements the NIF.</p></li><li><p><strong><code class="inline">argv</code></strong> - Contains the function arguments passed to the NIF.</p></li><li><p><strong><code class="inline">argc</code></strong> - The array length, that is, the function arity. <code class="inline">argv[N-1]</code> thus
denotes the Nth argument to the NIF. Notice that the argument <code class="inline">argc</code> allows
for the same C function to implement several Erlang functions with different
arity (but probably with the same name).</p></li><li><p><strong><code class="inline">flags</code></strong> - Is <code class="inline">0</code> for a regular NIF (and so its value can be omitted for
statically initialized <code class="inline">ErlNifFunc</code> instances).</p><p><code class="inline">flags</code> can be used to indicate that the NIF is a
<a href="erl_nif.html#dirty_nifs">dirty NIF</a> that is to be executed on a dirty
scheduler thread.</p><p>If the dirty NIF is expected to be CPU-bound, its <code class="inline">flags</code> field is to be set
to <code class="inline">ERL_NIF_DIRTY_JOB_CPU_BOUND</code>. If it's expected to be I/O-bound set
<code class="inline">flags</code> to <code class="inline">ERL_NIF_DIRTY_JOB_IO_BOUND</code>.</p></li></ul></li><li><p><strong id="ErlNifBinary"><code class="inline">ErlNifBinary</code></strong></p><pre><code class="text">typedef struct {
    size_t size;
    unsigned char* data;
} ErlNifBinary;</code></pre><p><code class="inline">ErlNifBinary</code> contains transient information about an inspected binary term.
<code class="inline">data</code> is a pointer to a buffer of <code class="inline">size</code> bytes with the raw content of the
binary.</p><p>Notice that <code class="inline">ErlNifBinary</code> is a semi-opaque type and you are only allowed to
read fields <code class="inline">size</code> and <code class="inline">data</code>.</p></li><li><p><strong id="ErlNifBinaryToTerm"><code class="inline">ErlNifBinaryToTerm</code></strong> - An enumeration of the
options that can be specified to
<a href="erl_nif.html#enif_binary_to_term"><code class="inline">enif_binary_to_term</code></a>. For default behavior,
use value <code class="inline">0</code>.</p><p>When receiving data from untrusted sources, use option
<code class="inline">ERL_NIF_BIN2TERM_SAFE</code>.</p></li><li><p><strong id="ErlNifMonitor"><code class="inline">ErlNifMonitor</code></strong> - This is an opaque data type that
identifies a monitor.</p><p>The nif writer is to provide the memory for storing the monitor when calling
<a href="erl_nif.html#enif_monitor_process"><code class="inline">enif_monitor_process</code></a>. The address of the
data is not stored by the runtime system, so <code class="inline">ErlNifMonitor</code> can be used as
any other data, it can be copied, moved in memory, forgotten, and so on. To
compare two monitors,
<a href="erl_nif.html#enif_compare_monitors"><code class="inline">enif_compare_monitors</code></a> must be used.</p></li><li><p><strong id="ErlNifOnHaltCallback"><code class="inline">ErlNifOnHaltCallback</code></strong></p><pre><code class="text">typedef void ErlNifOnHaltCallback(void *priv_data);</code></pre><p>The function prototype of an <em>on halt</em> callback function.</p><p>An <em>on halt</em> callback can be installed using
<a href="erl_nif.html#on_halt"><code class="inline">enif_set_option()</code></a>. Such an installed callback will be
called when the runtime system is halting.</p></li><li><p><strong id="ErlNifOnUnloadThreadCallback"><code class="inline">ErlNifOnUnloadThreadCallback</code></strong></p><pre><code class="text">typedef void ErlNifOnUnloadThreadCallback(void *priv_data);</code></pre><p>The function prototype of an <em>on_unload_thread</em> callback function.</p><p>An <em>on_unload_thread</em> callback can be installed using
<a href="erl_nif.html#on_unload_thread"><code class="inline">enif_set_option()</code></a>. Such an installed callback
will be called by each scheduler thread when this module instance is purged.</p></li><li><p><strong id="ErlNifOption"><code class="inline">ErlNifOption</code></strong> - An enumeration of the options that can
be set using <a href="erl_nif.html#enif_set_option"><code class="inline">enif_set_option()</code></a>.</p><p>Currently valid options:</p><ul><li><p><strong><a href="erl_nif.html#delay_halt"><code class="inline">ERL_NIF_OPT_DELAY_HALT</code></a></strong> - Enable delay of
runtime system halt with flushing enabled until all calls to NIFs in the NIF
library have returned.</p></li><li><p><strong><a href="erl_nif.html#on_halt"><code class="inline">ERL_NIF_OPT_ON_HALT</code></a></strong> - Install a callback that
will be called when the runtime system halts with flushing enabled.</p></li><li><p><strong><a href="erl_nif.html#on_unload_thread"><code class="inline">ERL_NIF_OPT_ON_UNLOAD_THREAD</code></a></strong> - Install a
callback that will be called <strong>by each scheduler thread</strong>
when the module instance that the NIF library belongs to is purged as old.</p></li></ul></li><li><p><strong id="ErlNifPid"><code class="inline">ErlNifPid</code></strong> - A process identifier (pid). In contrast to
pid terms (instances of <code class="inline">ERL_NIF_TERM</code>), <code class="inline">ErlNifPid</code>s are self-contained and
not bound to any <a href="erl_nif.html#ErlNifEnv">environment</a>. <code class="inline">ErlNifPid</code> is an opaque
type. It can be copied, moved in memory, forgotten, and so on.</p></li><li><p><strong id="ErlNifPort"><code class="inline">ErlNifPort</code></strong> - A port identifier. In contrast to port ID
terms (instances of <code class="inline">ERL_NIF_TERM</code>), <code class="inline">ErlNifPort</code>s are self-contained and not
bound to any <a href="erl_nif.html#ErlNifEnv">environment</a>. <code class="inline">ErlNifPort</code> is an opaque
type. It can be copied, moved in memory, forgotten, and so on.</p></li><li><p><strong id="ErlNifResourceType"><code class="inline">ErlNifResourceType</code></strong> - Each instance of
<code class="inline">ErlNifResourceType</code> represents a class of memory-managed resource objects
that can be garbage collected. Each resource type has a unique name and a
destructor function that is called when objects of its type are released.</p></li><li><p><strong id="ErlNifResourceTypeInit"><code class="inline">ErlNifResourceTypeInit</code></strong></p><pre><code class="makeup c" translate="no"><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p" data-group-id="8498113176-1">{</span><span class="w">
    </span><span class="no">ErlNifResourceDtor</span><span class="o">*</span><span class="w"> </span><span class="n">dtor</span><span class="p">;</span><span class="w">       </span><span class="c1">// #1 Destructor</span><span class="w">
    </span><span class="no">ErlNifResourceStop</span><span class="o">*</span><span class="w"> </span><span class="n">stop</span><span class="p">;</span><span class="w">       </span><span class="c1">// #2 Select stop</span><span class="w">
    </span><span class="no">ErlNifResourceDown</span><span class="o">*</span><span class="w"> </span><span class="n">down</span><span class="p">;</span><span class="w">       </span><span class="c1">// #3 Monitor down</span><span class="w">
    </span><span class="kt">int</span><span class="w"> </span><span class="n">members</span><span class="p">;</span><span class="w">
    </span><span class="no">ErlNifResourceDynCall</span><span class="o">*</span><span class="w"> </span><span class="n">dyncall</span><span class="p">;</span><span class="w"> </span><span class="c1">// #4 Dynamic call</span><span class="w">
</span><span class="p" data-group-id="8498113176-1">}</span><span class="w"> </span><span class="no">ErlNifResourceTypeInit</span><span class="p">;</span></code></pre><p>Initialization structure read by
<a href="erl_nif.html#enif_open_resource_type_x">enif_open_resource_type_x</a> and
<a href="erl_nif.html#enif_init_resource_type">enif_init_resource_type</a>.</p></li><li><p><strong><code class="inline" id="ErlNifResourceDtor">ErlNifResourceDtor</code></strong></p><pre><code class="text">typedef void ErlNifResourceDtor(ErlNifEnv* caller_env, void* obj);</code></pre><p>The function prototype of a resource destructor function.</p><p>The <code class="inline">obj</code> argument is a pointer to the resource. The only allowed use for the
resource in the destructor is to access its user data one final time. The
destructor is guaranteed to be the last callback before the resource is
deallocated.</p></li><li><p><strong id="ErlNifResourceDown"><code class="inline">ErlNifResourceDown</code></strong></p><pre><code class="makeup c" translate="no"><span class="k">typedef</span><span class="w"> </span><span class="kc">void</span><span class="w"> </span><span class="no">ErlNifResourceDown</span><span class="p" data-group-id="7973461372-1">(</span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">caller_env</span><span class="p">,</span><span class="w"> </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="no">ErlNifPid</span><span class="o">*</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="no">ErlNifMonitor</span><span class="o">*</span><span class="w"> </span><span class="n">mon</span><span class="p" data-group-id="7973461372-1">)</span><span class="p">;</span></code></pre><p>The function prototype of a resource down function, called on the behalf of
<a href="erl_nif.html#enif_monitor_process">enif_monitor_process</a>. <code class="inline">obj</code> is the
resource, <code class="inline">pid</code> is the identity of the monitored process that is exiting, and
<code class="inline">mon</code> is the identity of the monitor.</p></li><li><p><strong id="ErlNifResourceStop"><code class="inline">ErlNifResourceStop</code></strong></p><pre><code class="text">typedef void ErlNifResourceStop(ErlNifEnv* caller_env, void* obj, ErlNifEvent event, int is_direct_call);</code></pre><p>The function prototype of a resource stop function, called on the behalf of
<a href="erl_nif.html#enif_select">enif_select</a>. <code class="inline">obj</code> is the resource, <code class="inline">event</code> is OS
event, <code class="inline">is_direct_call</code> is true if the call is made directly from
<code class="inline">enif_select</code> or false if it is a scheduled call (potentially from another
thread).</p></li><li><p><strong id="ErlNifResourceDynCall"><code class="inline">ErlNifResourceDynCall</code></strong></p><pre><code class="makeup c" translate="no"><span class="k">typedef</span><span class="w"> </span><span class="kc">void</span><span class="w"> </span><span class="no">ErlNifResourceDynCall</span><span class="p" data-group-id="1940494840-1">(</span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">caller_env</span><span class="p">,</span><span class="w"> </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">call_data</span><span class="p" data-group-id="1940494840-1">)</span><span class="p">;</span></code></pre><p>The function prototype of a dynamic resource call function, called by
<a href="erl_nif.html#enif_dynamic_resource_call">enif_dynamic_resource_call</a>. Argument
<code class="inline">obj</code> is the resource object and <code class="inline">call_data</code> is the last argument to
<code class="inline">enif_dynamic_resource_call</code> passed through.</p></li><li><p><strong id="ErlNifCharEncoding"><code class="inline">ErlNifCharEncoding</code></strong></p><pre><code class="text">typedef enum {
    ERL_NIF_LATIN1,
    ERL_NIF_UTF8,
}ErlNifCharEncoding;</code></pre><p>The character encoding used in strings and atoms. The only supported encodings
are <code class="inline">ERL_NIF_LATIN1</code> for ISO Latin-1 (8-bit ASCII) and <code class="inline">ERL_NIF_UTF8</code> for
UTF-8.</p></li><li><p><strong id="ErlNifSysInfo"><code class="inline">ErlNifSysInfo</code></strong> - Used by
<a href="erl_nif.html#enif_system_info"><code class="inline">enif_system_info</code></a> to return information about
the runtime system. Contains the same content as
<a href="erl_driver.html#ErlDrvSysInfo"><code class="inline">ErlDrvSysInfo</code></a>.</p></li><li><p><strong id="ErlNifSInt64"><code class="inline">ErlNifSInt64</code></strong> - A native signed 64-bit integer type.</p></li><li><p><strong id="ErlNifUInt64"><code class="inline">ErlNifUInt64</code></strong> - A native unsigned 64-bit integer type.</p></li><li><p><strong id="ErlNifTime"><code class="inline">ErlNifTime</code></strong> - A signed 64-bit integer type for
representation of time.</p></li><li><p><strong id="ErlNifTimeUnit"><code class="inline">ErlNifTimeUnit</code></strong> - An enumeration of time units
supported by the NIF API:</p><ul><li><p><strong><code class="inline">ERL_NIF_SEC</code></strong> - Seconds</p></li><li><p><strong><code class="inline">ERL_NIF_MSEC</code></strong> - Milliseconds</p></li><li><p><strong><code class="inline">ERL_NIF_USEC</code></strong> - Microseconds</p></li><li><p><strong><code class="inline">ERL_NIF_NSEC</code></strong> - Nanoseconds</p></li></ul></li><li><p><strong id="ErlNifUniqueInteger"><code class="inline">ErlNifUniqueInteger</code></strong> - An enumeration of the
properties that can be requested from
<a href="erl_nif.html#enif_make_unique_integer"><code class="inline">enif_make_unique_integer</code></a>. For default
properties, use value <code class="inline">0</code>.</p><ul><li><p><strong><code class="inline">ERL_NIF_UNIQUE_POSITIVE</code></strong> - Return only positive integers.</p></li><li><p><strong><code class="inline">ERL_NIF_UNIQUE_MONOTONIC</code></strong> - Return only
<a href="time_correction.html#strictly-monotonically-increasing">strictly monotonically increasing</a>
integer corresponding to creation time.</p></li></ul></li><li><p><strong id="ErlNifHash"><code class="inline">ErlNifHash</code></strong> - An enumeration of the supported hash types
that can be generated using <a href="erl_nif.html#enif_hash"><code class="inline">enif_hash</code></a>.</p><ul><li><p><strong><code class="inline">ERL_NIF_INTERNAL_HASH</code></strong> - Non-portable hash function that only
guarantees the same hash for the same term within one Erlang VM instance.</p><p>It takes 32-bit salt values and generates hashes within <code class="inline">0..2^32-1</code>.</p></li><li><p><strong><code class="inline">ERL_NIF_PHASH2</code></strong> - Portable hash function that gives the same hash for
the same Erlang term regardless of machine architecture and ERTS version.</p><p><em>It ignores salt values</em> and generates hashes within <code class="inline">0..2^27-1</code>.</p><p>Slower than <code class="inline">ERL_NIF_INTERNAL_HASH.</code> It corresponds to <a href="erlang.html#phash2/1"><code class="inline">erlang:phash2/1</code></a>.</p></li></ul></li><li><p><strong id="SysIOVec"><code class="inline">SysIOVec</code></strong> - A system I/O vector, as used by <code class="inline">writev</code> on
Unix and <code class="inline">WSASend</code> on Win32. It is used in <code class="inline">ErlNifIOVec</code> and by
<a href="erl_nif.html#enif_ioq_peek"><code class="inline">enif_ioq_peek</code></a>.</p></li><li><p><strong id="ErlNifIOVec"><code class="inline">ErlNifIOVec</code></strong></p><pre><code class="makeup c" translate="no"><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p" data-group-id="9264709947-1">{</span><span class="w">
  </span><span class="kt">int</span><span class="w"> </span><span class="n">iovcnt</span><span class="p">;</span><span class="w">
  </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">
  </span><span class="no">SysIOVec</span><span class="o">*</span><span class="w"> </span><span class="n">iov</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="9264709947-1">}</span><span class="w"> </span><span class="no">ErlNifIOVec</span><span class="p">;</span></code></pre><p>An I/O vector containing <code class="inline">iovcnt</code> <code class="inline">SysIOVec</code>s pointing to the data. It is used
by <a href="erl_nif.html#enif_inspect_iovec"><code class="inline">enif_inspect_iovec</code></a> and
<a href="erl_nif.html#enif_ioq_enqv"><code class="inline">enif_ioq_enqv</code></a>.</p></li><li><p><strong id="ErlNifIOQueueOpts"><code class="inline">ErlNifIOQueueOpts</code></strong> - Options to configure a
<code class="inline">ErlNifIOQueue</code>.</p><ul><li><strong>ERL_NIF_IOQ_NORMAL</strong> - Create a normal I/O Queue</li></ul></li></ul><h2 id="enif_alloc" class="section-heading"><a href="#enif_alloc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_alloc()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_alloc</span><span class="p" data-group-id="0595633703-1">(</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="0595633703-1">)</span><span class="p">;</span></code></pre><p>Allocates memory of <code class="inline">size</code> bytes.</p><p>Returns <code class="inline">NULL</code> if the allocation fails.</p><p>The returned pointer is suitably aligned for any built-in type that fit in the
allocated memory.</p><h2 id="enif_alloc_binary" class="section-heading"><a href="#enif_alloc_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_alloc_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_alloc_binary</span><span class="p" data-group-id="0385699834-1">(</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifBinary</span><span class="o">*</span><span class="w"> </span><span class="n">bin</span><span class="p" data-group-id="0385699834-1">)</span><span class="p">;</span></code></pre><p>Allocates a new binary of size <code class="inline">size</code> bytes. Initializes the structure pointed
to by <code class="inline">bin</code> to refer to the allocated binary. The binary must either be released
by <a href="erl_nif.html#enif_release_binary"><code class="inline">enif_release_binary</code></a> or ownership
transferred to an Erlang term with
<a href="erl_nif.html#enif_make_binary"><code class="inline">enif_make_binary</code></a>. An allocated (and owned)
<code class="inline">ErlNifBinary</code> can be kept between NIF calls.</p><p>If you do not need to reallocate or keep the data alive across NIF calls,
consider using <a href="erl_nif.html#enif_make_new_binary"><code class="inline">enif_make_new_binary</code></a> instead
as it will allocate small binaries on the process heap when possible.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if allocation fails.</p><h2 id="enif_alloc_env" class="section-heading"><a href="#enif_alloc_env" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_alloc_env()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_alloc_env</span><span class="p" data-group-id="7177128155-1">(</span><span class="p" data-group-id="7177128155-1">)</span><span class="p">;</span></code></pre><p>Allocates a new <a href="erl_nif.html#proc_indep_env">process independent environment</a>.
The environment can be used to hold terms that are not bound to any process.
Such terms can later be copied to a process environment with
<a href="erl_nif.html#enif_make_copy"><code class="inline">enif_make_copy</code></a> or be sent to a process as a
message with <a href="erl_nif.html#enif_send"><code class="inline">enif_send</code></a>.</p><p>Returns pointer to the new environment.</p><p>Available since OTP R14B</p><h2 id="enif_alloc_resource" class="section-heading"><a href="#enif_alloc_resource" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_alloc_resource()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_alloc_resource</span><span class="p" data-group-id="4781152074-1">(</span><span class="w">
        </span><span class="no">ErlNifResourceType</span><span class="o">*</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="4781152074-1">)</span><span class="p">;</span></code></pre><p>Allocates a memory-managed resource object of type <code class="inline">type</code> and size <code class="inline">size</code> bytes.</p><p>Available since OTP R13B04</p><h2 id="enif_binary_to_term" class="section-heading"><a href="#enif_binary_to_term" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_binary_to_term()</span></h2><pre><code class="makeup c" translate="no"><span class="n">size_t</span><span class="w"> </span><span class="nf">enif_binary_to_term</span><span class="p" data-group-id="6281925018-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="o">*</span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">opts</span><span class="p" data-group-id="6281925018-1">)</span><span class="p">;</span></code></pre><p>Creates a term that is the result of decoding the binary data at <code class="inline">data</code>, which
must be encoded according to the Erlang external term format. No more than
<code class="inline">size</code> bytes are read from <code class="inline">data</code>. Argument <code class="inline">opts</code> corresponds to the second
argument to <a href="erlang.html#binary_to_term/2"><code class="inline">erlang:binary_to_term/2</code></a> and must be either <code class="inline">0</code> or
<code class="inline">ERL_NIF_BIN2TERM_SAFE</code>.</p><p>On success, stores the resulting term at <code class="inline">*term</code> and returns the number of bytes
read. Returns <code class="inline">0</code> if decoding fails or if <code class="inline">opts</code> is invalid.</p><p>See also <a href="erl_nif.html#ErlNifBinaryToTerm"><code class="inline">ErlNifBinaryToTerm</code></a>,
<a href="erlang.html#binary_to_term/2"><code class="inline">erlang:binary_to_term/2</code></a>, and
<a href="erl_nif.html#enif_term_to_binary"><code class="inline">enif_term_to_binary</code></a>.</p><p>Available since OTP 19.0</p><h2 id="enif_clear_env" class="section-heading"><a href="#enif_clear_env" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_clear_env()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_clear_env</span><span class="p" data-group-id="5184893904-1">(</span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p" data-group-id="5184893904-1">)</span><span class="p">;</span></code></pre><p>Frees all terms in an environment and clears it for reuse. The environment must
have been allocated with <a href="erl_nif.html#enif_alloc_env"><code class="inline">enif_alloc_env</code></a>.</p><p>Available since OTP R14B</p><h2 id="enif_compare" class="section-heading"><a href="#enif_compare" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_compare()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_compare</span><span class="p" data-group-id="8353133521-1">(</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">rhs</span><span class="p" data-group-id="8353133521-1">)</span><span class="p">;</span></code></pre><p>Returns an integer &lt; <code class="inline">0</code> if <code class="inline">lhs</code> &lt; <code class="inline">rhs</code>, <code class="inline">0</code> if <code class="inline">lhs</code> = <code class="inline">rhs</code>, and &gt; <code class="inline">0</code> if
<code class="inline">lhs</code> &gt; <code class="inline">rhs</code>. Corresponds to the Erlang operators <code class="inline">==</code>, <code class="inline">/=</code>, <code class="inline">=&lt;</code>, <code class="inline">&lt;</code>, <code class="inline">&gt;=</code>,
and <code class="inline">&gt;</code> (but <em>not</em> <code class="inline">=:=</code> or <code class="inline">=/=</code>).</p><p>Available since OTP R13B04</p><h2 id="enif_compare_monitors" class="section-heading"><a href="#enif_compare_monitors" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_compare_monitors()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_compare_monitors</span><span class="p" data-group-id="1640230502-1">(</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifMonitor</span><span class="w"> </span><span class="o">*</span><span class="n">monitor1</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifMonitor</span><span class="w"> </span><span class="o">*</span><span class="n">monitor2</span><span class="p" data-group-id="1640230502-1">)</span><span class="p">;</span></code></pre><p>Compares two <a href="erl_nif.html#ErlNifMonitor"><code class="inline">ErlNifMonitor</code></a>s. Can also be used to
imply some artificial order on monitors, for whatever reason.</p><p>Returns <code class="inline">0</code> if <code class="inline">monitor1</code> and <code class="inline">monitor2</code> are equal, &lt; <code class="inline">0</code> if <code class="inline">monitor1</code> &lt;
<code class="inline">monitor2</code>, and &gt; <code class="inline">0</code> if <code class="inline">monitor1</code> &gt; <code class="inline">monitor2</code>.</p><p>Available since OTP 20.0</p><h2 id="enif_compare_pids" class="section-heading"><a href="#enif_compare_pids" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_compare_pids()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_compare_pids</span><span class="p" data-group-id="1493203984-1">(</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifPid</span><span class="w"> </span><span class="o">*</span><span class="n">pid1</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifPid</span><span class="w"> </span><span class="o">*</span><span class="n">pid2</span><span class="p" data-group-id="1493203984-1">)</span><span class="p">;</span></code></pre><p>Compares two <a href="erl_nif.html#ErlNifPid"><code class="inline">ErlNifPid</code> </a>s according to term order.</p><p>Returns <code class="inline">0</code> if <code class="inline">pid1</code> and <code class="inline">pid2</code> are equal, &lt; <code class="inline">0</code> if <code class="inline">pid1</code> &lt; <code class="inline">pid2</code>, and &gt; <code class="inline">0</code>
if <code class="inline">pid1</code> &gt; <code class="inline">pid2</code>.</p><p>Available since OTP 22.0</p><h2 id="enif_cond_broadcast" class="section-heading"><a href="#enif_cond_broadcast" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_cond_broadcast()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_cond_broadcast</span><span class="p" data-group-id="0957947888-1">(</span><span class="w">
        </span><span class="no">ErlNifCond</span><span class="w"> </span><span class="o">*</span><span class="n">cnd</span><span class="p" data-group-id="0957947888-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_cond_broadcast"><code class="inline">erl_drv_cond_broadcast</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_cond_create" class="section-heading"><a href="#enif_cond_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_cond_create()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifCond</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_cond_create</span><span class="p" data-group-id="4079910397-1">(</span><span class="w">
        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p" data-group-id="4079910397-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_cond_create"><code class="inline">erl_drv_cond_create</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_cond_destroy" class="section-heading"><a href="#enif_cond_destroy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_cond_destroy()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_cond_destroy</span><span class="p" data-group-id="4484885428-1">(</span><span class="w">
        </span><span class="no">ErlNifCond</span><span class="w"> </span><span class="o">*</span><span class="n">cnd</span><span class="p" data-group-id="4484885428-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_cond_destroy"><code class="inline">erl_drv_cond_destroy</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_cond_name" class="section-heading"><a href="#enif_cond_name" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_cond_name()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">enif_cond_name</span><span class="p" data-group-id="0336218459-1">(</span><span class="w">
        </span><span class="no">ErlNifCond</span><span class="o">*</span><span class="w"> </span><span class="n">cnd</span><span class="p" data-group-id="0336218459-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_cond_name"><code class="inline">erl_drv_cond_name</code></a>.</p><p>Available since OTP 21.0</p><h2 id="enif_cond_signal" class="section-heading"><a href="#enif_cond_signal" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_cond_signal()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_cond_signal</span><span class="p" data-group-id="0636687272-1">(</span><span class="w">
        </span><span class="no">ErlNifCond</span><span class="w"> </span><span class="o">*</span><span class="n">cnd</span><span class="p" data-group-id="0636687272-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_cond_signal"><code class="inline">erl_drv_cond_signal</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_cond_wait" class="section-heading"><a href="#enif_cond_wait" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_cond_wait()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_cond_wait</span><span class="p" data-group-id="6259597541-1">(</span><span class="w">
        </span><span class="no">ErlNifCond</span><span class="w"> </span><span class="o">*</span><span class="n">cnd</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifMutex</span><span class="w"> </span><span class="o">*</span><span class="n">mtx</span><span class="p" data-group-id="6259597541-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_cond_wait"><code class="inline">erl_drv_cond_wait</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_consume_timeslice" class="section-heading"><a href="#enif_consume_timeslice" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_consume_timeslice()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_consume_timeslice</span><span class="p" data-group-id="7562323914-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="kt">int</span><span class="w"> </span><span class="n">percent</span><span class="p" data-group-id="7562323914-1">)</span><span class="p">;</span></code></pre><p>Gives the runtime system a hint about how much CPU time the current NIF call has
consumed since the last hint, or since the start of the NIF if no previous hint
has been specified. The time is specified as a percent of the timeslice that a
process is allowed to execute Erlang code until it can be suspended to give time
for other runnable processes. The scheduling timeslice is not an exact entity,
but can usually be approximated to about 1 millisecond.</p><p>Notice that it is up to the runtime system to determine if and how to use this
information. Implementations on some platforms can use other means to determine
consumed CPU time. Lengthy NIFs should regardless of this frequently call
<code class="inline">enif_consume_timeslice</code> to determine if it is allowed to continue execution.</p><p>Argument <code class="inline">percent</code> must be an integer between 1 and 100. This function must only
be called from a NIF-calling thread, and argument <code class="inline">env</code> must be the environment
of the calling process.</p><p>Returns <code class="inline">1</code> if the timeslice is exhausted, otherwise <code class="inline">0</code>. If <code class="inline">1</code> is returned,
the NIF is to return as soon as possible in order for the process to yield.</p><p>This function is provided to better support co-operative scheduling, improve
system responsiveness, and make it easier to prevent misbehaviors of the VM
because of a NIF monopolizing a scheduler thread. It can be used to divide
<a href="erl_nif.html#lengthy_work">length work</a> into a number of repeated NIF calls
without the need to create threads.</p><p>See also the <a href="erl_nif.html#WARNING">warning</a> text at the beginning of this manual
page.</p><p>Available since OTP R16B</p><h2 id="enif_convert_time_unit" class="section-heading"><a href="#enif_convert_time_unit" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_convert_time_unit()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifTime</span><span class="w"> </span><span class="nf">enif_convert_time_unit</span><span class="p" data-group-id="9178740206-1">(</span><span class="w">
        </span><span class="no">ErlNifTime</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifTimeUnit</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifTimeUnit</span><span class="w"> </span><span class="n">to</span><span class="p" data-group-id="9178740206-1">)</span><span class="p">;</span></code></pre><p>Converts the <code class="inline">val</code> value of time unit <code class="inline">from</code> to the corresponding value of time
unit <code class="inline">to</code>. The result is rounded using the floor function.</p><ul><li><p><strong><code class="inline">val</code></strong> - Value to convert time unit for.</p></li><li><p><strong><code class="inline">from</code></strong> - Time unit of <code class="inline">val</code>.</p></li><li><p><strong><code class="inline">to</code></strong> - Time unit of returned value.</p></li></ul><p>Returns <code class="inline">ERL_NIF_TIME_ERROR</code> if called with an invalid time unit argument.</p><p>See also <a href="erl_nif.html#ErlNifTime"><code class="inline">ErlNifTime</code></a> and
<a href="erl_nif.html#ErlNifTimeUnit"><code class="inline">ErlNifTimeUnit</code></a>.</p><p>Available since OTP 18.3</p><h2 id="enif_cpu_time" class="section-heading"><a href="#enif_cpu_time" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_cpu_time()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_cpu_time</span><span class="p" data-group-id="7692940086-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p" data-group-id="7692940086-1">)</span><span class="p">;</span></code></pre><p>Returns the CPU time in the same format as
<a href="erlang.html#timestamp/0"><code class="inline">erlang:timestamp()</code></a>. The CPU time is the time the
current logical CPU has spent executing since some arbitrary point in the past.
If the OS does not support fetching this value, <code class="inline">enif_cpu_time</code> invokes
<a href="erl_nif.html#enif_make_badarg"><code class="inline">enif_make_badarg</code></a>.</p><p>Available since OTP 19.0</p><h2 id="enif_demonitor_process" class="section-heading"><a href="#enif_demonitor_process" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_demonitor_process()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_demonitor_process</span><span class="p" data-group-id="7672165679-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">caller_env</span><span class="p">,</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifMonitor</span><span class="o">*</span><span class="w"> </span><span class="n">mon</span><span class="p" data-group-id="7672165679-1">)</span><span class="p">;</span></code></pre><p>Cancels a monitor created earlier with
<a href="erl_nif.html#enif_monitor_process"><code class="inline">enif_monitor_process</code></a>. Argument <code class="inline">obj</code> is a
pointer to the resource holding the monitor and <code class="inline">*mon</code> identifies the monitor.</p><p>Argument <code class="inline">caller_env</code> is the environment of the calling thread
(<a href="erl_nif.html#proc_bound_env">process bound</a> or
<a href="erl_nif.html#callback_env">callback</a> environment) or <code class="inline">NULL</code> if calling from a
custom thread not spawned by ERTS.</p><p>Returns <code class="inline">0</code> if the monitor was successfully identified and removed. Returns a
non-zero value if the monitor could not be identified, which means it was either</p><ul><li>never created for this resource</li><li>already cancelled</li><li>already triggered</li><li>just about to be triggered by a concurrent thread</li></ul><p>This function is thread-safe.</p><p>Available since OTP 20.0</p><h2 id="enif_dynamic_resource_call" class="section-heading"><a href="#enif_dynamic_resource_call" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_dynamic_resource_call()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_dynamic_resource_call</span><span class="p" data-group-id="5571827399-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">caller_env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">rt_module</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">rt_name</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">resource</span><span class="p">,</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">call_data</span><span class="p" data-group-id="5571827399-1">)</span><span class="p">;</span></code></pre><p>Call code of a resource type implemented by another NIF module. The atoms
<code class="inline">rt_module</code> and <code class="inline">rt_name</code> identifies the resource type to be called. Argument
<code class="inline">resource</code> identifies a resource object of that type.</p><p>The callback <a href="erl_nif.html#ErlNifResourceDynCall"><code class="inline">dyncall</code></a> of the identified
resource type will be called with a pointer to the resource objects <code class="inline">obj</code> and
the argument <code class="inline">call_data</code> passed through. The <code class="inline">call_data</code> argument is typically a
pointer to a struct used to passed both arguments to the <code class="inline">dyncall</code> function as
well as results back to the caller.</p><p>Returns 0 if the <code class="inline">dyncall</code> callback function was called. Returns a non-zero
value if no call was made, which happens if <code class="inline">rt_module</code> and <code class="inline">rt_name</code> did not
identify a resource type with a <code class="inline">dyncall</code> callback or if <code class="inline">resource</code> was not a
resource object of that type.</p><p>Available since OTP 24.0</p><h2 id="enif_equal_tids" class="section-heading"><a href="#enif_equal_tids" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_equal_tids()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_equal_tids</span><span class="p" data-group-id="7472161118-1">(</span><span class="w">
        </span><span class="no">ErlNifTid</span><span class="w"> </span><span class="n">tid1</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifTid</span><span class="w"> </span><span class="n">tid2</span><span class="p" data-group-id="7472161118-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_equal_tids"><code class="inline">erl_drv_equal_tids</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_fprintf" class="section-heading"><a href="#enif_fprintf" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_fprintf()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_fprintf</span><span class="p" data-group-id="8006924873-1">(</span><span class="w">
        </span><span class="no">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">stream</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">format</span><span class="p">,</span><span class="w">
        </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="8006924873-1">)</span><span class="p">;</span></code></pre><p>Similar to <code class="inline">fprintf</code> but this format string also accepts <code class="inline">&quot;%T&quot;</code>, which formats
Erlang terms of type <a href="erl_nif.html#ERL_NIF_TERM"><code class="inline">ERL_NIF_TERM</code></a>.</p><p>This function is primarily intended for debugging purpose. It is not recommended
to print very large terms with <code class="inline">%T</code>. The function may change <code class="inline">errno</code>, even if
successful.</p><p>Available since OTP 21.0</p><h2 id="enif_free" class="section-heading"><a href="#enif_free" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_free()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_free</span><span class="p" data-group-id="1284801372-1">(</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p" data-group-id="1284801372-1">)</span><span class="p">;</span></code></pre><p>Frees memory allocated by <a href="erl_nif.html#enif_alloc"><code class="inline">enif_alloc</code></a>.</p><h2 id="enif_free_env" class="section-heading"><a href="#enif_free_env" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_free_env()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_free_env</span><span class="p" data-group-id="3617462624-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p" data-group-id="3617462624-1">)</span><span class="p">;</span></code></pre><p>Frees an environment allocated with
<a href="erl_nif.html#enif_alloc_env"><code class="inline">enif_alloc_env</code></a>. All terms created in the
environment are freed as well.</p><p>Available since OTP R14B</p><h2 id="enif_free_iovec" class="section-heading"><a href="#enif_free_iovec" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_free_iovec()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_free_iovec</span><span class="p" data-group-id="6202425654-1">(</span><span class="w">
        </span><span class="no">ErlNifIOVec</span><span class="o">*</span><span class="w"> </span><span class="n">iov</span><span class="p" data-group-id="6202425654-1">)</span><span class="p">;</span></code></pre><p>Frees an io vector returned from
<a href="erl_nif.html#enif_inspect_iovec"><code class="inline">enif_inspect_iovec</code></a>. This is needed only if a
<code class="inline">NULL</code> environment is passed to
<a href="erl_nif.html#enif_inspect_iovec"><code class="inline">enif_inspect_iovec</code></a>.</p><pre><code class="makeup c" translate="no"><span class="no">ErlNifIOVec</span><span class="w"> </span><span class="o">*</span><span class="n">iovec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">NULL</span><span class="p">;</span><span class="w">
</span><span class="n">size_t</span><span class="w"> </span><span class="n">max_elements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w">
</span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p" data-group-id="7548580827-1">(</span><span class="o">!</span><span class="nf">enif_inspect_iovec</span><span class="p" data-group-id="7548580827-2">(</span><span class="no">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">max_elements</span><span class="p">,</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tail</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iovec</span><span class="p" data-group-id="7548580827-2">)</span><span class="p" data-group-id="7548580827-1">)</span><span class="w">
  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">

</span><span class="c1">// Do things with the iovec</span><span class="w">

</span><span class="cm">/* Free the iovector, possibly in another thread or nif function call */</span><span class="w">
</span><span class="nf">enif_free_iovec</span><span class="p" data-group-id="7548580827-3">(</span><span class="n">iovec</span><span class="p" data-group-id="7548580827-3">)</span><span class="p">;</span></code></pre><p>Available since OTP 20.1</p><h2 id="enif_get_atom" class="section-heading"><a href="#enif_get_atom" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_atom()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_atom</span><span class="p" data-group-id="2958131726-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifCharEncoding</span><span class="w"> </span><span class="n">encoding</span><span class="p" data-group-id="2958131726-1">)</span><span class="p">;</span></code></pre><p>Writes a <code class="inline">NULL</code>-terminated string in the buffer pointed to by <code class="inline">buf</code> of size
<code class="inline">size</code> bytes, consisting of the string representation of the atom <code class="inline">term</code> with
<a href="erl_nif.html#ErlNifCharEncoding">encoding</a>.</p><p>Returns the number of bytes written (including terminating <code class="inline">NULL</code> character) or
<code class="inline">0</code> if <code class="inline">term</code> is not an atom with maximum length of <code class="inline">size-1</code> bytes in
<code class="inline">encoding</code>.</p><p>Available since OTP R13B04</p><h2 id="enif_get_atom_length" class="section-heading"><a href="#enif_get_atom_length" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_atom_length()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_atom_length</span><span class="p" data-group-id="3239365680-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">len</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifCharEncoding</span><span class="w"> </span><span class="n">encoding</span><span class="p" data-group-id="3239365680-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*len</code> to the length (number of bytes excluding terminating <code class="inline">NULL</code>
character) of the atom <code class="inline">term</code> with <a href="erl_nif.html#ErlNifCharEncoding">encoding</a>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">term</code> is not an atom or if the atom
cannot be encoded using <code class="inline">encoding</code>.</p><p>Available since OTP R14B</p><h2 id="enif_get_double" class="section-heading"><a href="#enif_get_double" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_double()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_double</span><span class="p" data-group-id="2945053647-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">dp</span><span class="p" data-group-id="2945053647-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*dp</code> to the floating-point value of <code class="inline">term</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">term</code> is not a float.</p><p>Available since OTP R13B04</p><h2 id="enif_get_int" class="section-heading"><a href="#enif_get_int" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_int()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_int</span><span class="p" data-group-id="7696172747-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="p" data-group-id="7696172747-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*ip</code> to the integer value of <code class="inline">term</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">term</code> is not an integer or is outside
the bounds of type <code class="inline">int</code>.</p><h2 id="enif_get_int64" class="section-heading"><a href="#enif_get_int64" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_int64()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_int64</span><span class="p" data-group-id="5076940438-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifSInt64</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="p" data-group-id="5076940438-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*ip</code> to the integer value of <code class="inline">term</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">term</code> is not an integer or is outside
the bounds of a signed 64-bit integer.</p><p>Available since OTP R14B</p><h2 id="enif_get_local_pid" class="section-heading"><a href="#enif_get_local_pid" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_local_pid()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_local_pid</span><span class="p" data-group-id="1639763847-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifPid</span><span class="o">*</span><span class="w"> </span><span class="n">pid</span><span class="p" data-group-id="1639763847-1">)</span><span class="p">;</span></code></pre><p>If <code class="inline">term</code> is the pid of a node local process, this function initializes the pid
variable <code class="inline">*pid</code> from it and returns <code class="inline">true</code>. Otherwise returns <code class="inline">false</code>. No check
is done to see if the process is alive.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p><code class="inline">enif_get_local_pid</code> will return false if argument <code class="inline">term</code> is the atom
<a href="erl_nif.html#enif_make_pid"><code class="inline">undefined</code></a>.</p></section><p>Available since OTP R14B</p><h2 id="enif_get_local_port" class="section-heading"><a href="#enif_get_local_port" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_local_port()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_local_port</span><span class="p" data-group-id="7567378309-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifPort</span><span class="o">*</span><span class="w"> </span><span class="n">port_id</span><span class="p" data-group-id="7567378309-1">)</span><span class="p">;</span></code></pre><p>If <code class="inline">term</code> identifies a node local port, this function initializes the port
variable <code class="inline">*port_id</code> from it and returns <code class="inline">true</code>. Otherwise returns <code class="inline">false</code>. No
check is done to see if the port is alive.</p><p>Available since OTP 19.0</p><h2 id="enif_get_list_cell" class="section-heading"><a href="#enif_get_list_cell" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_list_cell()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_list_cell</span><span class="p" data-group-id="4304573853-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">list</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="p" data-group-id="4304573853-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*head</code> and <code class="inline">*tail</code> from list <code class="inline">list</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if it is not a list or the list is empty.</p><h2 id="enif_get_list_length" class="section-heading"><a href="#enif_get_list_length" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_list_length()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_list_length</span><span class="p" data-group-id="9398775743-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="o">*</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="9398775743-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*len</code> to the length of list <code class="inline">term</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">term</code> is not a proper list.</p><p>Available since OTP R14B</p><h2 id="enif_get_long" class="section-heading"><a href="#enif_get_long" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_long()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_long</span><span class="p" data-group-id="3959663369-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="p" data-group-id="3959663369-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*ip</code> to the long integer value of <code class="inline">term</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">term</code> is not an integer or is outside
the bounds of type <code class="inline">long int</code>.</p><p>Available since OTP R13B04</p><h2 id="enif_get_map_size" class="section-heading"><a href="#enif_get_map_size" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_map_size()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_map_size</span><span class="p" data-group-id="3191578773-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="p" data-group-id="3191578773-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*size</code> to the number of key-value pairs in the map <code class="inline">term</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">term</code> is not a map.</p><p>Available since OTP 18.0</p><h2 id="enif_get_map_value" class="section-heading"><a href="#enif_get_map_value" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_map_value()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_map_value</span><span class="p" data-group-id="5879580802-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">map</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5879580802-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*value</code> to the value associated with <code class="inline">key</code> in the map <code class="inline">map</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">map</code> is not a map or if <code class="inline">map</code> does not
contain <code class="inline">key</code>.</p><p>Available since OTP 18.0</p><h2 id="enif_get_resource" class="section-heading"><a href="#enif_get_resource" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_resource()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_resource</span><span class="p" data-group-id="7706456975-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifResourceType</span><span class="o">*</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="n">objp</span><span class="p" data-group-id="7706456975-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*objp</code> to point to the resource object referred to by <code class="inline">term</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">term</code> is not a handle to a resource
object of type <code class="inline">type</code>.</p><p><code class="inline">enif_get_resource</code> does not add a reference to the resource object. However,
the pointer received in <code class="inline">*objp</code> is guaranteed to be valid at least as long as
the resource handle <code class="inline">term</code> is valid.</p><p>Available since OTP R13B04</p><h2 id="enif_get_string" class="section-heading"><a href="#enif_get_string" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_string()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_string</span><span class="p" data-group-id="9336008145-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">list</span><span class="p">,</span><span class="w">
        </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifCharEncoding</span><span class="w"> </span><span class="n">encoding</span><span class="p" data-group-id="9336008145-1">)</span><span class="p">;</span></code></pre><p>Writes a <code class="inline">NULL</code>-terminated string in the buffer pointed to by <code class="inline">buf</code> with size
<code class="inline">size</code>, consisting of the characters in the string <code class="inline">list</code>. The characters are
written using <a href="erl_nif.html#ErlNifCharEncoding">encoding</a>.</p><p>Returns one of the following:</p><ul><li>The number of bytes written (including terminating <code class="inline">NULL</code> character)</li><li><code class="inline">-size</code> if the string was truncated because of buffer space</li><li><code class="inline">0</code> if <code class="inline">list</code> is not a string that can be encoded with <code class="inline">encoding</code> or if <code class="inline">size</code>
was &lt; <code class="inline">1</code>.</li></ul><p>The written string is always <code class="inline">NULL</code>-terminated, unless buffer <code class="inline">size</code> is &lt; <code class="inline">1</code>.</p><p>Available since OTP R13B04</p><h2 id="enif_get_string_length" class="section-heading"><a href="#enif_get_string_length" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_string_length()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_string_length</span><span class="p" data-group-id="9978786608-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">list</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">len</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifCharEncoding</span><span class="w"> </span><span class="n">encoding</span><span class="p" data-group-id="9978786608-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*len</code> to the length (number of bytes excluding terminating <code class="inline">NULL</code>
character) of the string <code class="inline">list</code> with <a href="erl_nif.html#ErlNifCharEncoding">encoding</a>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">list</code> is not a string that can be
encoded with <code class="inline">encoding</code>.</p><p>Available since OTP 26.0</p><h2 id="enif_get_tuple" class="section-heading"><a href="#enif_get_tuple" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_tuple()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_tuple</span><span class="p" data-group-id="9936283665-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">arity</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p" data-group-id="9936283665-1">)</span><span class="p">;</span></code></pre><p>If <code class="inline">term</code> is a tuple, this function sets <code class="inline">*array</code> to point to an array
containing the elements of the tuple, and sets <code class="inline">*arity</code> to the number of
elements. Notice that the array is read-only and <code class="inline">(*array)[N-1]</code> is the Nth
element of the tuple. <code class="inline">*array</code> is undefined if the arity of the tuple is zero.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">term</code> is not a tuple.</p><p>Available since OTP R13B04</p><h2 id="enif_get_uint" class="section-heading"><a href="#enif_get_uint" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_uint()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_uint</span><span class="p" data-group-id="5484914587-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="p" data-group-id="5484914587-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*ip</code> to the unsigned integer value of <code class="inline">term</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">term</code> is not an unsigned integer or is
outside the bounds of type <code class="inline">unsigned int</code>.</p><p>Available since OTP R13B04</p><h2 id="enif_get_uint64" class="section-heading"><a href="#enif_get_uint64" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_uint64()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_uint64</span><span class="p" data-group-id="9714051240-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifUInt64</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="p" data-group-id="9714051240-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*ip</code> to the unsigned integer value of <code class="inline">term</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">term</code> is not an unsigned integer or is
outside the bounds of an unsigned 64-bit integer.</p><p>Available since OTP R14B</p><h2 id="enif_get_ulong" class="section-heading"><a href="#enif_get_ulong" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_get_ulong()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_get_ulong</span><span class="p" data-group-id="3281915166-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="o">*</span><span class="w"> </span><span class="n">ip</span><span class="p" data-group-id="3281915166-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*ip</code> to the unsigned long integer value of <code class="inline">term</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">term</code> is not an unsigned integer or is
outside the bounds of type <code class="inline">unsigned long</code>.</p><h2 id="enif_getenv" class="section-heading"><a href="#enif_getenv" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_getenv()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_getenv</span><span class="p" data-group-id="6183391120-1">(</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w">
        </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">value_size</span><span class="p" data-group-id="6183391120-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_getenv"><code class="inline">erl_drv_getenv</code></a>.</p><p>Available since OTP 18.2</p><h2 id="enif_has_pending_exception" class="section-heading"><a href="#enif_has_pending_exception" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_has_pending_exception()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_has_pending_exception</span><span class="p" data-group-id="6595283171-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="o">*</span><span class="w"> </span><span class="n">reason</span><span class="p" data-group-id="6595283171-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if a pending exception is associated with the environment <code class="inline">env</code>.
If <code class="inline">reason</code> is a <code class="inline">NULL</code> pointer, ignore it. Otherwise, if a pending exception
associated with <code class="inline">env</code> exists, set <code class="inline">*reason</code> to the value of the exception term.
For example, if <a href="erl_nif.html#enif_make_badarg"><code class="inline">enif_make_badarg</code></a> is called to
set a pending <code class="inline">badarg</code> exception, a later call to
<code class="inline">enif_has_pending_exception(env, &amp;reason)</code> sets <code class="inline">*reason</code> to the atom <code class="inline">badarg</code>,
then return <code class="inline">true</code>.</p><p>See also <a href="erl_nif.html#enif_make_badarg"><code class="inline">enif_make_badarg</code></a> and
<a href="erl_nif.html#enif_raise_exception"><code class="inline">enif_raise_exception</code></a>.</p><p>Available since OTP 18.0</p><h2 id="enif_hash" class="section-heading"><a href="#enif_hash" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_hash()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifUInt64</span><span class="w"> </span><span class="nf">enif_hash</span><span class="p" data-group-id="9589165531-1">(</span><span class="w">
        </span><span class="no">ErlNifHash</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifUInt64</span><span class="w"> </span><span class="n">salt</span><span class="p" data-group-id="9589165531-1">)</span><span class="p">;</span></code></pre><p>Hashes <code class="inline">term</code> according to the specified <a href="erl_nif.html#ErlNifHash"><code class="inline">ErlNifHash</code></a>
<code class="inline">type</code>.</p><p>Ranges of taken salt (if any) and returned value depend on the hash type.</p><p>Available since OTP 20.0</p><h2 id="enif_inspect_binary" class="section-heading"><a href="#enif_inspect_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_inspect_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_inspect_binary</span><span class="p" data-group-id="3896946105-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">bin_term</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifBinary</span><span class="o">*</span><span class="w"> </span><span class="n">bin</span><span class="p" data-group-id="3896946105-1">)</span><span class="p">;</span></code></pre><p>Initializes the structure pointed to by <code class="inline">bin</code> with information about binary term
<code class="inline">bin_term</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">bin_term</code> is not a binary.</p><h2 id="enif_inspect_iolist_as_binary" class="section-heading"><a href="#enif_inspect_iolist_as_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_inspect_iolist_as_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_inspect_iolist_as_binary</span><span class="p" data-group-id="0732070817-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifBinary</span><span class="o">*</span><span class="w"> </span><span class="n">bin</span><span class="p" data-group-id="0732070817-1">)</span><span class="p">;</span></code></pre><p>Initializes the structure pointed to by <code class="inline">bin</code> with a continuous buffer with the
same byte content as <code class="inline">iolist</code>. As with <code class="inline">inspect_binary</code>, the data pointed to by
<code class="inline">bin</code> is transient and does not need to be released.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">iolist</code> is not an iolist.</p><p>Available since OTP R13B04</p><h2 id="enif_inspect_iovec" class="section-heading"><a href="#enif_inspect_iovec" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_inspect_iovec()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_inspect_iovec</span><span class="p" data-group-id="3642775593-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">max_elements</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">iovec_term</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifIOVec</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="n">iovec</span><span class="p" data-group-id="3642775593-1">)</span><span class="p">;</span></code></pre><p>Fills <code class="inline">iovec</code> with the list of binaries provided in <code class="inline">iovec_term</code>. The number of
elements handled in the call is limited to <code class="inline">max_elements</code>, and <code class="inline">tail</code> is set to
the remainder of the list. Note that the output may be longer than
<code class="inline">max_elements</code> on some platforms.</p><p>To create a list of binaries from an arbitrary iolist, use
<a href="erlang.html#iolist_to_iovec/1"><code class="inline">erlang:iolist_to_iovec/1</code></a>.</p><p>When calling this function, <code class="inline">iovec</code> should contain a pointer to <code class="inline">NULL</code> or a
ErlNifIOVec structure that should be used if possible. e.g.</p><pre><code class="makeup c" translate="no"><span class="cm">/* Don&#39;t use a pre-allocated structure */</span><span class="w">
</span><span class="no">ErlNifIOVec</span><span class="w"> </span><span class="o">*</span><span class="n">iovec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">NULL</span><span class="p">;</span><span class="w">
</span><span class="nf">enif_inspect_iovec</span><span class="p" data-group-id="9579519904-1">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">max_elements</span><span class="p">,</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tail</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iovec</span><span class="p" data-group-id="9579519904-1">)</span><span class="p">;</span><span class="w">

</span><span class="cm">/* Use a stack-allocated vector as an optimization for vectors with few elements */</span><span class="w">
</span><span class="no">ErlNifIOVec</span><span class="w"> </span><span class="n">vec</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">iovec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">;</span><span class="w">
</span><span class="nf">enif_inspect_iovec</span><span class="p" data-group-id="9579519904-2">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">max_elements</span><span class="p">,</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tail</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iovec</span><span class="p" data-group-id="9579519904-2">)</span><span class="p">;</span></code></pre><p>The contents of the <code class="inline">iovec</code> is valid until the called nif function returns. If
the <code class="inline">iovec</code> should be valid after the nif call returns, it is possible to call
this function with a <code class="inline">NULL</code> environment. If no environment is given the <code class="inline">iovec</code>
owns the data in the vector and it has to be explicitly freed using
<a href="erl_nif.html#enif_free_iovec"><code class="inline">enif_free_iovec</code> </a>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">iovec_term</code> not an iovec.</p><p>Available since OTP 20.1</p><h2 id="enif_ioq_create" class="section-heading"><a href="#enif_ioq_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_ioq_create()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifIOQueue</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_ioq_create</span><span class="p" data-group-id="5552301392-1">(</span><span class="w">
        </span><span class="no">ErlNifIOQueueOpts</span><span class="w"> </span><span class="n">opts</span><span class="p" data-group-id="5552301392-1">)</span><span class="p">;</span></code></pre><p>Create a new I/O Queue that can be used to store data. <code class="inline">opts</code> has to be set to
<code class="inline">ERL_NIF_IOQ_NORMAL</code>.</p><p>Available since OTP 20.1</p><h2 id="enif_ioq_destroy" class="section-heading"><a href="#enif_ioq_destroy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_ioq_destroy()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_ioq_destroy</span><span class="p" data-group-id="3203071158-1">(</span><span class="w">
        </span><span class="no">ErlNifIOQueue</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p" data-group-id="3203071158-1">)</span><span class="p">;</span></code></pre><p>Destroy the I/O queue and free all of it's contents</p><p>Available since OTP 20.1</p><h2 id="enif_ioq_deq" class="section-heading"><a href="#enif_ioq_deq" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_ioq_deq()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_ioq_deq</span><span class="p" data-group-id="9357691765-1">(</span><span class="w">
        </span><span class="no">ErlNifIOQueue</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="p" data-group-id="9357691765-1">)</span><span class="p">;</span></code></pre><p>Dequeue <code class="inline">count</code> bytes from the I/O queue. If <code class="inline">size</code> is not <code class="inline">NULL</code>, the new size
of the queue is placed there.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if the I/O does not contain <code class="inline">count</code> bytes.
On failure the queue is left un-altered.</p><p>Available since OTP 20.1</p><h2 id="enif_ioq_enq_binary" class="section-heading"><a href="#enif_ioq_enq_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_ioq_enq_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_ioq_enq_binary</span><span class="p" data-group-id="2239361291-1">(</span><span class="w">
        </span><span class="no">ErlNifIOQueue</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifBinary</span><span class="w"> </span><span class="o">*</span><span class="n">bin</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">skip</span><span class="p" data-group-id="2239361291-1">)</span><span class="p">;</span></code></pre><p>Enqueue the <code class="inline">bin</code> into <code class="inline">q</code> skipping the first <code class="inline">skip</code> bytes.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">skip</code> is greater than the size of
<code class="inline">bin</code>. Any ownership of the binary data is transferred to the queue and <code class="inline">bin</code> is
to be considered read-only for the rest of the NIF call and then as released.</p><p>Available since OTP 20.1</p><h2 id="enif_ioq_enqv" class="section-heading"><a href="#enif_ioq_enqv" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_ioq_enqv()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_ioq_enqv</span><span class="p" data-group-id="9477368072-1">(</span><span class="w">
        </span><span class="no">ErlNifIOQueue</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifIOVec</span><span class="w"> </span><span class="o">*</span><span class="n">iovec</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">skip</span><span class="p" data-group-id="9477368072-1">)</span><span class="p">;</span></code></pre><p>Enqueue the <code class="inline">iovec</code> into <code class="inline">q</code> skipping the first <code class="inline">skip</code> bytes.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">skip</code> is greater than the size of
<code class="inline">iovec</code>.</p><p>Available since OTP 20.1</p><h2 id="enif_ioq_peek" class="section-heading"><a href="#enif_ioq_peek" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_ioq_peek()</span></h2><pre><code class="makeup c" translate="no"><span class="no">SysIOVec</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_ioq_peek</span><span class="p" data-group-id="6203757802-1">(</span><span class="w">
        </span><span class="no">ErlNifIOQueue</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="w">
        </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">iovlen</span><span class="p" data-group-id="6203757802-1">)</span><span class="p">;</span></code></pre><p>Get the I/O queue as a pointer to an array of <code class="inline">SysIOVec</code>s. It also returns the
number of elements in <code class="inline">iovlen</code>.</p><p>Nothing is removed from the queue by this function, that must be done with
<a href="erl_nif.html#enif_ioq_deq"><code class="inline">enif_ioq_deq</code></a>.</p><p>The returned array is suitable to use with the Unix system call <code class="inline">writev</code>.</p><p>Available since OTP 20.1</p><h2 id="enif_ioq_peek_head" class="section-heading"><a href="#enif_ioq_peek_head" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_ioq_peek_head()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_ioq_peek_head</span><span class="p" data-group-id="2354276207-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifIOQueue</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="o">*</span><span class="n">bin_term</span><span class="p" data-group-id="2354276207-1">)</span><span class="p">;</span></code></pre><p>Get the head of the IO Queue as a binary term.</p><p>If <code class="inline">size</code> is not <code class="inline">NULL</code>, the size of the head is placed there.</p><p>Nothing is removed from the queue by this function, that must be done with
<a href="erl_nif.html#enif_ioq_deq"><code class="inline">enif_ioq_deq</code></a>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if the queue is empty.</p><p>Available since OTP 21.0</p><h2 id="enif_ioq_size" class="section-heading"><a href="#enif_ioq_size" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_ioq_size()</span></h2><pre><code class="makeup c" translate="no"><span class="n">size_t</span><span class="w"> </span><span class="nf">enif_ioq_size</span><span class="p" data-group-id="2912447953-1">(</span><span class="w">
        </span><span class="no">ErlNifIOQueue</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p" data-group-id="2912447953-1">)</span><span class="p">;</span></code></pre><p>Get the size of <code class="inline">q</code>.</p><p>Available since OTP 20.1</p><h2 id="enif_is_atom" class="section-heading"><a href="#enif_is_atom" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_atom()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_atom</span><span class="p" data-group-id="9131952637-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="9131952637-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is an atom.</p><p>Available since OTP R13B04</p><h2 id="enif_is_binary" class="section-heading"><a href="#enif_is_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_binary</span><span class="p" data-group-id="8202113643-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="8202113643-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a binary.</p><h2 id="enif_is_current_process_alive" class="section-heading"><a href="#enif_is_current_process_alive" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_current_process_alive()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_current_process_alive</span><span class="p" data-group-id="1262712424-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p" data-group-id="1262712424-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if the currently executing process is currently alive, otherwise
<code class="inline">false</code>.</p><p>This function can only be used from a NIF-calling thread, and with an
environment corresponding to currently executing processes.</p><p>Available since OTP 19.0</p><h2 id="enif_is_empty_list" class="section-heading"><a href="#enif_is_empty_list" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_empty_list()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_empty_list</span><span class="p" data-group-id="2065320790-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="2065320790-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is an empty list.</p><p>Available since OTP R13B04</p><h2 id="enif_is_exception" class="section-heading"><a href="#enif_is_exception" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_exception()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_exception</span><span class="p" data-group-id="7579535343-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="7579535343-1">)</span><span class="p">;</span></code></pre><p>Return true if <code class="inline">term</code> is an exception.</p><p>Available since OTP R14B03</p><h2 id="enif_is_fun" class="section-heading"><a href="#enif_is_fun" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_fun()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_fun</span><span class="p" data-group-id="0498402017-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="0498402017-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a fun.</p><p>Available since OTP R13B04</p><h2 id="enif_is_identical" class="section-heading"><a href="#enif_is_identical" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_identical()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_identical</span><span class="p" data-group-id="3919868458-1">(</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">rhs</span><span class="p" data-group-id="3919868458-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if the two terms are identical. Corresponds to the Erlang
operators <code class="inline">=:=</code> and <code class="inline">=/=</code>.</p><p>Available since OTP R13B04</p><h2 id="enif_is_list" class="section-heading"><a href="#enif_is_list" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_list()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_list</span><span class="p" data-group-id="8193172366-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="8193172366-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a list.</p><p>Available since OTP R14B</p><h2 id="enif_is_map" class="section-heading"><a href="#enif_is_map" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_map()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_map</span><span class="p" data-group-id="0322816832-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="0322816832-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a map, otherwise <code class="inline">false</code>.</p><p>Available since OTP 18.0</p><h2 id="enif_is_number" class="section-heading"><a href="#enif_is_number" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_number()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_number</span><span class="p" data-group-id="8680929577-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="8680929577-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a number.</p><p>Available since OTP R15B</p><h2 id="enif_is_pid" class="section-heading"><a href="#enif_is_pid" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_pid()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_pid</span><span class="p" data-group-id="7519072686-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="7519072686-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a pid.</p><p>Available since OTP R13B04</p><h2 id="enif_is_pid_undefined" class="section-heading"><a href="#enif_is_pid_undefined" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_pid_undefined()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_pid_undefined</span><span class="p" data-group-id="0809771554-1">(</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifPid</span><span class="o">*</span><span class="w"> </span><span class="n">pid</span><span class="p" data-group-id="0809771554-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">pid</code> has been set as undefined by
<a href="erl_nif.html#enif_set_pid_undefined"><code class="inline">enif_set_pid_undefined</code> </a>.</p><p>Available since OTP 22.0</p><h2 id="enif_is_port" class="section-heading"><a href="#enif_is_port" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_port()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_port</span><span class="p" data-group-id="5050190191-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="5050190191-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a port.</p><p>Available since OTP R13B04</p><h2 id="enif_is_port_alive" class="section-heading"><a href="#enif_is_port_alive" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_port_alive()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_port_alive</span><span class="p" data-group-id="4085260401-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifPort</span><span class="w"> </span><span class="o">*</span><span class="n">port_id</span><span class="p" data-group-id="4085260401-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">port_id</code> is alive.</p><p>This function is thread-safe.</p><p>Available since OTP 19.0</p><h2 id="enif_is_process_alive" class="section-heading"><a href="#enif_is_process_alive" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_process_alive()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_process_alive</span><span class="p" data-group-id="3381554344-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifPid</span><span class="w"> </span><span class="o">*</span><span class="n">pid</span><span class="p" data-group-id="3381554344-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">pid</code> is alive.</p><p>This function is thread-safe.</p><p>Available since OTP 19.0</p><h2 id="enif_is_ref" class="section-heading"><a href="#enif_is_ref" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_ref()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_ref</span><span class="p" data-group-id="7140822028-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="7140822028-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a reference.</p><p>Available since OTP R13B04</p><h2 id="enif_is_tuple" class="section-heading"><a href="#enif_is_tuple" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_is_tuple()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_is_tuple</span><span class="p" data-group-id="7169670770-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="7169670770-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a tuple.</p><p>Available since OTP R14B</p><h2 id="enif_keep_resource" class="section-heading"><a href="#enif_keep_resource" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_keep_resource()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_keep_resource</span><span class="p" data-group-id="2766919641-1">(</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p" data-group-id="2766919641-1">)</span><span class="p">;</span></code></pre><p>Adds a reference to resource object <code class="inline">obj</code> obtained from
<a href="erl_nif.html#enif_alloc_resource"><code class="inline">enif_alloc_resource</code></a>. Each call to
<code class="inline">enif_keep_resource</code> for an object must be balanced by a call to
<a href="erl_nif.html#enif_release_resource"><code class="inline">enif_release_resource</code></a> before the object is
destructed.</p><p>Available since OTP R14B</p><h2 id="enif_make_atom" class="section-heading"><a href="#enif_make_atom" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_atom()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_atom</span><span class="p" data-group-id="2290617751-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p" data-group-id="2290617751-1">)</span><span class="p">;</span></code></pre><p>Creates an atom term from the <code class="inline">NULL</code>-terminated C-string <code class="inline">name</code> with ISO
Latin-1 encoding. If the length of <code class="inline">name</code> exceeds the maximum length allowed for
an atom (255 characters), <code class="inline">enif_make_atom</code> invokes
<a href="erl_nif.html#enif_make_badarg"><code class="inline">enif_make_badarg</code></a>.</p><h2 id="enif_make_atom_len" class="section-heading"><a href="#enif_make_atom_len" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_atom_len()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_atom_len</span><span class="p" data-group-id="2940474241-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="2940474241-1">)</span><span class="p">;</span></code></pre><p>Create an atom term from the string <code class="inline">name</code> with length <code class="inline">len</code> and ISO Latin-1
encoding. <code class="inline">NULL</code> characters are treated as any other characters. If <code class="inline">len</code>
exceeds the maximum length allowed for an atom (255 characters),
<code class="inline">enif_make_atom</code> invokes <a href="erl_nif.html#enif_make_badarg"><code class="inline">enif_make_badarg</code> </a>.</p><p>Available since OTP R14B</p><h2 id="enif_make_badarg" class="section-heading"><a href="#enif_make_badarg" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_badarg()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_badarg</span><span class="p" data-group-id="0029448966-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p" data-group-id="0029448966-1">)</span><span class="p">;</span></code></pre><p>Makes a <code class="inline">badarg</code> exception to be returned from a NIF, and associates it with
environment <code class="inline">env</code>. Once a NIF or any function it calls invokes
<code class="inline">enif_make_badarg</code>, the runtime ensures that a <code class="inline">badarg</code> exception is raised when
the NIF returns, even if the NIF attempts to return a non-exception term
instead.</p><p>The return value from <code class="inline">enif_make_badarg</code> can be used only as the return value
from the NIF that invoked it (directly or indirectly) or be passed to
<a href="erl_nif.html#enif_is_exception"><code class="inline">enif_is_exception</code></a>, but not to any other NIF
API function.</p><p>See also <a href="erl_nif.html#enif_has_pending_exception"><code class="inline">enif_has_pending_exception</code></a>
and <a href="erl_nif.html#enif_raise_exception"><code class="inline">enif_raise_exception</code></a>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Before ERTS 7.0 (Erlang/OTP 18), the return value from <code class="inline">enif_make_badarg</code> had
to be returned from the NIF. This requirement is now lifted as the return
value from the NIF is ignored if <code class="inline">enif_make_badarg</code> has been invoked.</p></section><h2 id="enif_make_binary" class="section-heading"><a href="#enif_make_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_binary</span><span class="p" data-group-id="9828033015-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifBinary</span><span class="o">*</span><span class="w"> </span><span class="n">bin</span><span class="p" data-group-id="9828033015-1">)</span><span class="p">;</span></code></pre><p>Makes a binary term from <code class="inline">bin</code>. Any ownership of the binary data is transferred
to the created term and <code class="inline">bin</code> is to be considered read-only for the rest of the
NIF call and then as released.</p><h2 id="enif_make_copy" class="section-heading"><a href="#enif_make_copy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_copy()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_copy</span><span class="p" data-group-id="0922260900-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">dst_env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">src_term</span><span class="p" data-group-id="0922260900-1">)</span><span class="p">;</span></code></pre><p>Makes a copy of term <code class="inline">src_term</code>. The copy is created in environment <code class="inline">dst_env</code>.
The source term can be located in any environment.</p><p>Available since OTP R14B</p><h2 id="enif_make_double" class="section-heading"><a href="#enif_make_double" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_double()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_double</span><span class="p" data-group-id="4555953915-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p" data-group-id="4555953915-1">)</span><span class="p">;</span></code></pre><p>Creates a floating-point term from a <code class="inline">double</code>. If argument <code class="inline">double</code> is not
finite or is NaN, <code class="inline">enif_make_double</code> invokes
<a href="erl_nif.html#enif_make_badarg"><code class="inline">enif_make_badarg</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_make_existing_atom" class="section-heading"><a href="#enif_make_existing_atom" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_existing_atom()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_make_existing_atom</span><span class="p" data-group-id="1077906324-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="o">*</span><span class="n">atom</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifCharEncoding</span><span class="w"> </span><span class="n">encoding</span><span class="p" data-group-id="1077906324-1">)</span><span class="p">;</span></code></pre><p>Tries to create the term of an already existing atom from the <code class="inline">NULL</code>-terminated
C-string <code class="inline">name</code> with <a href="erl_nif.html#ErlNifCharEncoding">encoding</a>.</p><p>If the atom already exists, this function stores the term in <code class="inline">*atom</code> and returns
<code class="inline">true</code>, otherwise returns <code class="inline">false</code>. It also returns <code class="inline">false</code> if the string <code class="inline">name</code>
exceeds the maximum length allowed for an atom (255 characters) or if <code class="inline">name</code> is
not correctly encoded.</p><p>Available since OTP R13B04</p><h2 id="enif_make_existing_atom_len" class="section-heading"><a href="#enif_make_existing_atom_len" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_existing_atom_len()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_make_existing_atom_len</span><span class="p" data-group-id="4854410498-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="o">*</span><span class="n">atom</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifCharEncoding</span><span class="w"> </span><span class="n">encoding</span><span class="p" data-group-id="4854410498-1">)</span><span class="p">;</span></code></pre><p>Tries to create the term of an already existing atom from the string <code class="inline">name</code> with
length <code class="inline">len</code> bytes and <a href="erl_nif.html#ErlNifCharEncoding">encoding</a>. <code class="inline">NULL</code>
characters are treated as any other characters.</p><p>If the atom already exists, this function stores the term in <code class="inline">*atom</code> and returns
<code class="inline">true</code>, otherwise returns <code class="inline">false</code>. It also returns <code class="inline">false</code> if the string <code class="inline">name</code>
exceeds the maximum length allowed for an atom (255 characters) or if <code class="inline">name</code> is
not correctly encoded.</p><p>Available since OTP R14B</p><h2 id="enif_make_int" class="section-heading"><a href="#enif_make_int" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_int()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_int</span><span class="p" data-group-id="4843840159-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p" data-group-id="4843840159-1">)</span><span class="p">;</span></code></pre><p>Creates an integer term.</p><h2 id="enif_make_int64" class="section-heading"><a href="#enif_make_int64" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_int64()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_int64</span><span class="p" data-group-id="4456570999-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifSInt64</span><span class="w"> </span><span class="n">i</span><span class="p" data-group-id="4456570999-1">)</span><span class="p">;</span></code></pre><p>Creates an integer term from a signed 64-bit integer.</p><p>Available since OTP R14B</p><h2 id="enif_make_list" class="section-heading"><a href="#enif_make_list" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_list()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_list</span><span class="p" data-group-id="5576437871-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cnt</span><span class="p">,</span><span class="w">
        </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="5576437871-1">)</span><span class="p">;</span></code></pre><p>Creates an ordinary list term of length <code class="inline">cnt</code>. Expects <code class="inline">cnt</code> number of arguments
(after <code class="inline">cnt</code>) of type <code class="inline">ERL_NIF_TERM</code> as the elements of the list.</p><p>Returns an empty list if <code class="inline">cnt</code> is 0.</p><h2 id="enif_make_list1" class="section-heading"><a href="#enif_make_list1" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_list1()</span></h2><h2 id="enif_make_list2" class="section-heading"><a href="#enif_make_list2" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_list2()</span></h2><h2 id="enif_make_list3" class="section-heading"><a href="#enif_make_list3" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_list3()</span></h2><h2 id="enif_make_list4" class="section-heading"><a href="#enif_make_list4" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_list4()</span></h2><h2 id="enif_make_list5" class="section-heading"><a href="#enif_make_list5" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_list5()</span></h2><h2 id="enif_make_list6" class="section-heading"><a href="#enif_make_list6" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_list6()</span></h2><h2 id="enif_make_list7" class="section-heading"><a href="#enif_make_list7" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_list7()</span></h2><h2 id="enif_make_list8" class="section-heading"><a href="#enif_make_list8" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_list8()</span></h2><h2 id="enif_make_list9" class="section-heading"><a href="#enif_make_list9" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_list9()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_list1</span><span class="p" data-group-id="0633877472-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p" data-group-id="0633877472-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_list2</span><span class="p" data-group-id="6310026186-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e2</span><span class="p" data-group-id="6310026186-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_list3</span><span class="p" data-group-id="5757449504-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e2</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e3</span><span class="p" data-group-id="5757449504-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_list4</span><span class="p" data-group-id="0725018813-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e4</span><span class="p" data-group-id="0725018813-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_list5</span><span class="p" data-group-id="5836898221-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e5</span><span class="p" data-group-id="5836898221-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_list6</span><span class="p" data-group-id="5338925819-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e6</span><span class="p" data-group-id="5338925819-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_list7</span><span class="p" data-group-id="5620526502-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e7</span><span class="p" data-group-id="5620526502-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_list8</span><span class="p" data-group-id="3950326588-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e8</span><span class="p" data-group-id="3950326588-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_list9</span><span class="p" data-group-id="5778068884-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e9</span><span class="p" data-group-id="5778068884-1">)</span><span class="p">;</span></code></pre><p>Creates an ordinary list term with length indicated by the function name. Prefer
these functions (macros) over the variadic <code class="inline">enif_make_list</code> to get a
compile-time error if the number of arguments does not match.</p><p>Available since OTP R13B04</p><h2 id="enif_make_list_cell" class="section-heading"><a href="#enif_make_list_cell" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_list_cell()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_list_cell</span><span class="p" data-group-id="2894340757-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">tail</span><span class="p" data-group-id="2894340757-1">)</span><span class="p">;</span></code></pre><p>Creates a list cell <code class="inline">[head | tail]</code>.</p><h2 id="enif_make_list_from_array" class="section-heading"><a href="#enif_make_list_from_array" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_list_from_array()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_list_from_array</span><span class="p" data-group-id="7122724853-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">arr</span><span class="p" data-group-id="7122724853-2">[</span><span class="p" data-group-id="7122724853-2">]</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cnt</span><span class="p" data-group-id="7122724853-1">)</span><span class="p">;</span></code></pre><p>Creates an ordinary list containing the elements of array <code class="inline">arr</code> of length <code class="inline">cnt</code>.</p><p>Returns an empty list if <code class="inline">cnt</code> is 0.</p><p>Available since OTP R13B04</p><h2 id="enif_make_long" class="section-heading"><a href="#enif_make_long" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_long()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_long</span><span class="p" data-group-id="5923397714-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p" data-group-id="5923397714-1">)</span><span class="p">;</span></code></pre><p>Creates an integer term from a <code class="inline">long int</code>.</p><p>Available since OTP R13B04</p><h2 id="enif_make_map_put" class="section-heading"><a href="#enif_make_map_put" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_map_put()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_make_map_put</span><span class="p" data-group-id="7880230335-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">map_in</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="o">*</span><span class="w"> </span><span class="n">map_out</span><span class="p" data-group-id="7880230335-1">)</span><span class="p">;</span></code></pre><p>Makes a copy of map <code class="inline">map_in</code> and inserts <code class="inline">key</code> with <code class="inline">value</code>. If <code class="inline">key</code> already
exists in <code class="inline">map_in</code>, the old associated value is replaced by <code class="inline">value</code>.</p><p>If successful, this function sets <code class="inline">*map_out</code> to the new map and returns <code class="inline">true</code>.
Returns <code class="inline">false</code> if <code class="inline">map_in</code> is not a map.</p><p>The <code class="inline">map_in</code> term must belong to environment <code class="inline">env</code>.</p><p>Available since OTP 18.0</p><h2 id="enif_make_map_remove" class="section-heading"><a href="#enif_make_map_remove" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_map_remove()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_make_map_remove</span><span class="p" data-group-id="6139865610-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">map_in</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="o">*</span><span class="w"> </span><span class="n">map_out</span><span class="p" data-group-id="6139865610-1">)</span><span class="p">;</span></code></pre><p>If map <code class="inline">map_in</code> contains <code class="inline">key</code>, this function makes a copy of <code class="inline">map_in</code> in
<code class="inline">*map_out</code>, and removes <code class="inline">key</code> and the associated value. If map <code class="inline">map_in</code> does not
contain <code class="inline">key</code>, <code class="inline">*map_out</code> is set to <code class="inline">map_in</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if <code class="inline">map_in</code> is not a map.</p><p>The <code class="inline">map_in</code> term must belong to environment <code class="inline">env</code>.</p><p>Available since OTP 18.0</p><h2 id="enif_make_map_update" class="section-heading"><a href="#enif_make_map_update" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_map_update()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_make_map_update</span><span class="p" data-group-id="2410483290-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">map_in</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">new_value</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="o">*</span><span class="w"> </span><span class="n">map_out</span><span class="p" data-group-id="2410483290-1">)</span><span class="p">;</span></code></pre><p>Makes a copy of map <code class="inline">map_in</code> and replace the old associated value for <code class="inline">key</code> with
<code class="inline">new_value</code>.</p><p>If successful, this function sets <code class="inline">*map_out</code> to the new map and returns <code class="inline">true</code>.
Returns <code class="inline">false</code> if <code class="inline">map_in</code> is not a map or if it does not contain <code class="inline">key</code>.</p><p>The <code class="inline">map_in</code> term must belong to environment <code class="inline">env</code>.</p><p>Available since OTP 18.0</p><h2 id="enif_make_map_from_arrays" class="section-heading"><a href="#enif_make_map_from_arrays" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_map_from_arrays()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_make_map_from_arrays</span><span class="p" data-group-id="6499038957-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">keys</span><span class="p" data-group-id="6499038957-2">[</span><span class="p" data-group-id="6499038957-2">]</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">values</span><span class="p" data-group-id="6499038957-3">[</span><span class="p" data-group-id="6499038957-3">]</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">cnt</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="o">*</span><span class="n">map_out</span><span class="p" data-group-id="6499038957-1">)</span><span class="p">;</span></code></pre><p>Makes a map term from the given keys and values.</p><p>If successful, this function sets <code class="inline">*map_out</code> to the new map and returns <code class="inline">true</code>.
Returns <code class="inline">false</code> there are any duplicate keys.</p><p>All keys and values must belong to <code class="inline">env</code>.</p><p>Available since OTP 21.0</p><h2 id="enif_make_monitor_term" class="section-heading"><a href="#enif_make_monitor_term" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_monitor_term()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_monitor_term</span><span class="p" data-group-id="4765529272-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifMonitor</span><span class="o">*</span><span class="w"> </span><span class="n">mon</span><span class="p" data-group-id="4765529272-1">)</span><span class="p">;</span></code></pre><p>Creates a term identifying the given monitor received from
<a href="erl_nif.html#enif_monitor_process"><code class="inline">enif_monitor_process</code> </a>.</p><p>This function is primarily intended for debugging purpose.</p><p>Available since OTP 22.0</p><h2 id="enif_make_new_atom" class="section-heading"><a href="#enif_make_new_atom" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_new_atom()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_make_new_atom</span><span class="p" data-group-id="5188588876-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="o">*</span><span class="n">atom</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifCharEncoding</span><span class="w"> </span><span class="n">encoding</span><span class="p" data-group-id="5188588876-1">)</span><span class="p">;</span></code></pre><p>Creates an atom term from the <code class="inline">NULL</code>-terminated C-string <code class="inline">name</code> with
<a href="erl_nif.html#ErlNifCharEncoding">encoding</a>.</p><p>If successful, <code class="inline">true</code> is returned and the atom term is stored in <code class="inline">*atom</code>.</p><p>Otherwise, <code class="inline">false</code> is returned if the length of <code class="inline">name</code> exceeds the maximum
length allowed for an atom (255 characters) or if <code class="inline">name</code> is not correctly
encoded.</p><p>Available since OTP 26.0</p><h2 id="enif_make_new_atom_len" class="section-heading"><a href="#enif_make_new_atom_len" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_new_atom_len()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_make_new_atom_len</span><span class="p" data-group-id="7395939742-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="o">*</span><span class="n">atom</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifCharEncoding</span><span class="w"> </span><span class="n">encoding</span><span class="p" data-group-id="7395939742-1">)</span><span class="p">;</span></code></pre><p>Create an atom term from string <code class="inline">name</code> with length <code class="inline">len</code> bytes and
<a href="erl_nif.html#ErlNifCharEncoding">encoding</a>.</p><p>If successful, <code class="inline">true</code> is returned and atom term is stored in <code class="inline">*atom</code>.</p><p>Otherwise, <code class="inline">false</code> is returned if the string exceeds the maximum length allowed
for an atom (255 characters) or if the string is not correctly encoded.</p><p>Available since OTP 26.0</p><h2 id="enif_make_new_binary" class="section-heading"><a href="#enif_make_new_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_new_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_make_new_binary</span><span class="p" data-group-id="9917207399-1">(</span><span class="w">
</span><span class="err">	</span><span class="w"> </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
</span><span class="err">	</span><span class="w"> </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w">
</span><span class="err">	</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="o">*</span><span class="w"> </span><span class="n">termp</span><span class="p" data-group-id="9917207399-1">)</span><span class="p">;</span></code></pre><p>Allocates a binary of size <code class="inline">size</code> bytes and creates an owning term. The binary
data is mutable until the calling NIF returns. This is a quick way to create a
new binary without having to use <a href="erl_nif.html#ErlNifBinary"><code class="inline">ErlNifBinary</code></a>. The
drawbacks are that the binary cannot be kept between NIF calls and it cannot be
reallocated.</p><p>Returns a pointer to the raw binary data and sets <code class="inline">*termp</code> to the binary term.</p><p>Available since OTP R14B</p><h2 id="enif_make_new_map" class="section-heading"><a href="#enif_make_new_map" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_new_map()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_new_map</span><span class="p" data-group-id="4879917029-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p" data-group-id="4879917029-1">)</span><span class="p">;</span></code></pre><p>Makes an empty map term.</p><p>Available since OTP 18.0</p><h2 id="enif_make_pid" class="section-heading"><a href="#enif_make_pid" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_pid()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_pid</span><span class="p" data-group-id="5911313642-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifPid</span><span class="o">*</span><span class="w"> </span><span class="n">pid</span><span class="p" data-group-id="5911313642-1">)</span><span class="p">;</span></code></pre><p>Makes a pid term or the atom <a href="erl_nif.html#enif_set_pid_undefined"><code class="inline">undefined</code></a>
from <code class="inline">*pid</code>.</p><p>Available since OTP R14B</p><h2 id="enif_make_ref" class="section-heading"><a href="#enif_make_ref" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_ref()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_ref</span><span class="p" data-group-id="9717705791-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p" data-group-id="9717705791-1">)</span><span class="p">;</span></code></pre><p>Creates a reference like <a href="erlang.html#make_ref/0"><code class="inline">erlang:make_ref/0</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_make_resource" class="section-heading"><a href="#enif_make_resource" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_resource()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_resource</span><span class="p" data-group-id="0659628156-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p" data-group-id="0659628156-1">)</span><span class="p">;</span></code></pre><p>Creates an opaque handle to a memory-managed resource object obtained by
<a href="erl_nif.html#enif_alloc_resource"><code class="inline">enif_alloc_resource</code></a>. No ownership transfer
is done, as the resource object still needs to be released by
<a href="erl_nif.html#enif_release_resource"><code class="inline">enif_release_resource</code></a>. However, notice
that the call to <code class="inline">enif_release_resource</code> can occur immediately after obtaining
the term from <code class="inline">enif_make_resource</code>, in which case the resource object is
deallocated when the term is garbage collected. For more details, see the
<a href="erl_nif.html#enif_resource_example">example of creating and returning a resource object</a>
in the User's Guide.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Since ERTS 9.0 (OTP-20.0), resource terms have a defined behavior when
compared and serialized through <code class="inline">term_to_binary</code> or passed between nodes.</p><ul><li><p>Two resource terms will compare equal if and only if they would yield the
same resource object pointer when passed to
<a href="erl_nif.html#enif_get_resource"><code class="inline">enif_get_resource</code></a>.</p></li><li><p>A resource term can be serialized with <code class="inline">term_to_binary</code> and later be fully
recreated if the resource object is still alive when <code class="inline">binary_to_term</code> is
called. A <em>stale</em> resource term will be returned from <code class="inline">binary_to_term</code> if
the resource object has been deallocated.
<a href="erl_nif.html#enif_get_resource"><code class="inline">enif_get_resource</code></a> will return false for
stale resource terms.</p><p>The same principles of serialization apply when passing resource terms in
messages to remote nodes and back again. A resource term will act stale on
all nodes except the node where its resource object is still alive in
memory.</p></li></ul><p>Before ERTS 9.0 (OTP-20.0), all resource terms did compare equal to each other
and to empty binaries (<code class="inline">&lt;&lt;&gt;&gt;</code>). If serialized, they would be recreated as
plain empty binaries.</p></section><p>Available since OTP R13B04</p><h2 id="enif_make_resource_binary" class="section-heading"><a href="#enif_make_resource_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_resource_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_resource_binary</span><span class="p" data-group-id="8573305185-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="8573305185-1">)</span><span class="p">;</span></code></pre><p>Creates a binary term that is memory-managed by a resource object <code class="inline">obj</code> obtained
by <a href="erl_nif.html#enif_alloc_resource"><code class="inline">enif_alloc_resource</code></a>. The returned binary
term consists of <code class="inline">size</code> bytes pointed to by <code class="inline">data</code>. This raw binary data must be
kept readable and unchanged until the destructor of the resource is called. The
binary data can be stored external to the resource object, in which case the
destructor is responsible for releasing the data.</p><p>Several binary terms can be managed by the same resource object. The destructor
is not called until the last binary is garbage collected. This can be useful to
return different parts of a larger binary buffer.</p><p>As with <a href="erl_nif.html#enif_make_resource"><code class="inline">enif_make_resource</code></a>, no ownership
transfer is done. The resource still needs to be released with
<a href="erl_nif.html#enif_release_resource"><code class="inline">enif_release_resource</code></a>.</p><p>Available since OTP R14B</p><h2 id="enif_make_reverse_list" class="section-heading"><a href="#enif_make_reverse_list" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_reverse_list()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_make_reverse_list</span><span class="p" data-group-id="3660231631-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">list_in</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="o">*</span><span class="n">list_out</span><span class="p" data-group-id="3660231631-1">)</span><span class="p">;</span></code></pre><p>Sets <code class="inline">*list_out</code> to the reverse list of the list <code class="inline">list_in</code> and returns <code class="inline">true</code>,
or returns <code class="inline">false</code> if <code class="inline">list_in</code> is not a list.</p><p>This function is only to be used on short lists, as a copy is created of the
list, which is not released until after the NIF returns.</p><p>The <code class="inline">list_in</code> term must belong to environment <code class="inline">env</code>.</p><p>Available since OTP R15B</p><h2 id="enif_make_string" class="section-heading"><a href="#enif_make_string" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_string()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_string</span><span class="p" data-group-id="8275389922-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">string</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifCharEncoding</span><span class="w"> </span><span class="n">encoding</span><span class="p" data-group-id="8275389922-1">)</span><span class="p">;</span></code></pre><p>Creates a list containing the characters of the <code class="inline">NULL</code>-terminated string
<code class="inline">string</code> with <a href="erl_nif.html#ErlNifCharEncoding">encoding</a>.</p><h2 id="enif_make_string_len" class="section-heading"><a href="#enif_make_string_len" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_string_len()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_string_len</span><span class="p" data-group-id="1710320848-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">string</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifCharEncoding</span><span class="w"> </span><span class="n">encoding</span><span class="p" data-group-id="1710320848-1">)</span><span class="p">;</span></code></pre><p>Creates a list containing the characters of the string <code class="inline">string</code> with length
<code class="inline">len</code> and <a href="erl_nif.html#ErlNifCharEncoding">encoding</a>. <code class="inline">NULL</code> characters are
treated as any other characters.</p><p>Available since OTP R14B</p><h2 id="enif_make_sub_binary" class="section-heading"><a href="#enif_make_sub_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_sub_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_sub_binary</span><span class="p" data-group-id="9234348369-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">bin_term</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="9234348369-1">)</span><span class="p">;</span></code></pre><p>Makes a subbinary of binary <code class="inline">bin_term</code>, starting at zero-based position <code class="inline">pos</code>
with a length of <code class="inline">size</code> bytes. <code class="inline">bin_term</code> must be a binary or bitstring.
<code class="inline">pos+size</code> must be less or equal to the number of whole bytes in <code class="inline">bin_term</code>.</p><p>Available since OTP R13B04</p><h2 id="enif_make_tuple" class="section-heading"><a href="#enif_make_tuple" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_tuple()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_tuple</span><span class="p" data-group-id="8931701056-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cnt</span><span class="p">,</span><span class="w">
        </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="8931701056-1">)</span><span class="p">;</span></code></pre><p>Creates a tuple term of arity <code class="inline">cnt</code>. Expects <code class="inline">cnt</code> number of arguments (after
<code class="inline">cnt</code>) of type <code class="inline">ERL_NIF_TERM</code> as the elements of the tuple.</p><h2 id="enif_make_tuple1" class="section-heading"><a href="#enif_make_tuple1" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_tuple1()</span></h2><h2 id="enif_make_tuple2" class="section-heading"><a href="#enif_make_tuple2" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_tuple2()</span></h2><h2 id="enif_make_tuple3" class="section-heading"><a href="#enif_make_tuple3" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_tuple3()</span></h2><h2 id="enif_make_tuple4" class="section-heading"><a href="#enif_make_tuple4" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_tuple4()</span></h2><h2 id="enif_make_tuple5" class="section-heading"><a href="#enif_make_tuple5" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_tuple5()</span></h2><h2 id="enif_make_tuple6" class="section-heading"><a href="#enif_make_tuple6" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_tuple6()</span></h2><h2 id="enif_make_tuple7" class="section-heading"><a href="#enif_make_tuple7" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_tuple7()</span></h2><h2 id="enif_make_tuple8" class="section-heading"><a href="#enif_make_tuple8" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_tuple8()</span></h2><h2 id="enif_make_tuple9" class="section-heading"><a href="#enif_make_tuple9" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_tuple9()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_tuple1</span><span class="p" data-group-id="9136054898-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p" data-group-id="9136054898-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_tuple2</span><span class="p" data-group-id="7189815900-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e2</span><span class="p" data-group-id="7189815900-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_tuple3</span><span class="p" data-group-id="4529941246-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e2</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e3</span><span class="p" data-group-id="4529941246-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_tuple4</span><span class="p" data-group-id="6788260837-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e4</span><span class="p" data-group-id="6788260837-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_tuple5</span><span class="p" data-group-id="6197439751-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e5</span><span class="p" data-group-id="6197439751-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_tuple6</span><span class="p" data-group-id="0671641804-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e6</span><span class="p" data-group-id="0671641804-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_tuple7</span><span class="p" data-group-id="8208462323-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e7</span><span class="p" data-group-id="8208462323-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_tuple8</span><span class="p" data-group-id="4743620834-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e8</span><span class="p" data-group-id="4743620834-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_tuple9</span><span class="p" data-group-id="4966400794-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">e9</span><span class="p" data-group-id="4966400794-1">)</span><span class="p">;</span></code></pre><p>Creates a tuple term with length indicated by the function name. Prefer these
functions (macros) over the variadic <code class="inline">enif_make_tuple</code> to get a compile-time
error if the number of arguments does not match.</p><p>Available since OTP R13B04</p><h2 id="enif_make_tuple_from_array" class="section-heading"><a href="#enif_make_tuple_from_array" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_tuple_from_array()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_tuple_from_array</span><span class="p" data-group-id="6184150380-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">arr</span><span class="p" data-group-id="6184150380-2">[</span><span class="p" data-group-id="6184150380-2">]</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cnt</span><span class="p" data-group-id="6184150380-1">)</span><span class="p">;</span></code></pre><p>Creates a tuple containing the elements of array <code class="inline">arr</code> of length <code class="inline">cnt</code>.</p><p>Available since OTP R13B04</p><h2 id="enif_make_uint" class="section-heading"><a href="#enif_make_uint" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_uint()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_uint</span><span class="p" data-group-id="3183675038-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p" data-group-id="3183675038-1">)</span><span class="p">;</span></code></pre><p>Creates an integer term from an <code class="inline">unsigned int</code>.</p><p>Available since OTP R13B04</p><h2 id="enif_make_uint64" class="section-heading"><a href="#enif_make_uint64" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_uint64()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_uint64</span><span class="p" data-group-id="9060878523-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifUInt64</span><span class="w"> </span><span class="n">i</span><span class="p" data-group-id="9060878523-1">)</span><span class="p">;</span></code></pre><p>Creates an integer term from an unsigned 64-bit integer.</p><p>Available since OTP R14B</p><h2 id="enif_make_ulong" class="section-heading"><a href="#enif_make_ulong" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_ulong()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_ulong</span><span class="p" data-group-id="4077518815-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">i</span><span class="p" data-group-id="4077518815-1">)</span><span class="p">;</span></code></pre><p>Creates an integer term from an <code class="inline">unsigned long int</code>.</p><h2 id="enif_make_unique_integer" class="section-heading"><a href="#enif_make_unique_integer" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_make_unique_integer()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_make_unique_integer</span><span class="p" data-group-id="4942333345-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifUniqueInteger</span><span class="w"> </span><span class="n">properties</span><span class="p" data-group-id="4942333345-1">)</span><span class="p">;</span></code></pre><p>Returns a unique integer with the same properties as specified by
<a href="erlang.html#unique_integer/1"><code class="inline">erlang:unique_integer/1</code></a>.</p><p><code class="inline">env</code> is the environment to create the integer in.</p><p><code class="inline">ERL_NIF_UNIQUE_POSITIVE</code> and <code class="inline">ERL_NIF_UNIQUE_MONOTONIC</code> can be passed as the
second argument to change the properties of the integer returned. They can be
combined by OR:ing the two values together.</p><p>See also <a href="erl_nif.html#ErlNifUniqueInteger"><code class="inline">ErlNifUniqueInteger</code></a>.</p><p>Available since OTP 19.0</p><h2 id="enif_map_iterator_create" class="section-heading"><a href="#enif_map_iterator_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_map_iterator_create()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_map_iterator_create</span><span class="p" data-group-id="4463718129-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">map</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifMapIterator</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifMapIteratorEntry</span><span class="w"> </span><span class="n">entry</span><span class="p" data-group-id="4463718129-1">)</span><span class="p">;</span></code></pre><p>Creates an iterator for the map <code class="inline">map</code> by initializing the structure pointed to
by <code class="inline">iter</code>. Argument <code class="inline">entry</code> determines the start position of the iterator:
<code class="inline">ERL_NIF_MAP_ITERATOR_FIRST</code> or <code class="inline">ERL_NIF_MAP_ITERATOR_LAST</code>.</p><p>Returns <code class="inline">true</code> on success, or false if <code class="inline">map</code> is not a map.</p><p>A map iterator is only useful during the lifetime of environment <code class="inline">env</code> that the
<code class="inline">map</code> belongs to. The iterator must be destroyed by calling
<a href="erl_nif.html#enif_map_iterator_destroy"><code class="inline">enif_map_iterator_destroy</code></a>:</p><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">
</span><span class="no">ErlNifMapIterator</span><span class="w"> </span><span class="n">iter</span><span class="p">;</span><span class="w">
</span><span class="nf">enif_map_iterator_create</span><span class="p" data-group-id="4413088661-1">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">my_map</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_MAP_ITERATOR_FIRST</span><span class="p" data-group-id="4413088661-1">)</span><span class="p">;</span><span class="w">

</span><span class="k">while</span><span class="w"> </span><span class="p" data-group-id="4413088661-2">(</span><span class="nf">enif_map_iterator_get_pair</span><span class="p" data-group-id="4413088661-3">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p" data-group-id="4413088661-3">)</span><span class="p" data-group-id="4413088661-2">)</span><span class="w"> </span><span class="p" data-group-id="4413088661-4">{</span><span class="w">
    </span><span class="nf">do_something</span><span class="p" data-group-id="4413088661-5">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p" data-group-id="4413088661-5">)</span><span class="p">;</span><span class="w">
    </span><span class="nf">enif_map_iterator_next</span><span class="p" data-group-id="4413088661-6">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iter</span><span class="p" data-group-id="4413088661-6">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="4413088661-4">}</span><span class="w">
</span><span class="nf">enif_map_iterator_destroy</span><span class="p" data-group-id="4413088661-7">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iter</span><span class="p" data-group-id="4413088661-7">)</span><span class="p">;</span></code></pre><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The key-value pairs of a map have no defined iteration order. The only
guarantee is that the iteration order of a single map instance is preserved
during the lifetime of the environment that the map belongs to.</p></section><p>Available since OTP 18.0</p><h2 id="enif_map_iterator_destroy" class="section-heading"><a href="#enif_map_iterator_destroy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_map_iterator_destroy()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_map_iterator_destroy</span><span class="p" data-group-id="7855510681-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifMapIterator</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p" data-group-id="7855510681-1">)</span><span class="p">;</span></code></pre><p>Destroys a map iterator created by
<a href="erl_nif.html#enif_map_iterator_create"><code class="inline">enif_map_iterator_create</code></a>.</p><p>Available since OTP 18.0</p><h2 id="enif_map_iterator_get_pair" class="section-heading"><a href="#enif_map_iterator_get_pair" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_map_iterator_get_pair()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_map_iterator_get_pair</span><span class="p" data-group-id="9910972444-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifMapIterator</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p" data-group-id="9910972444-1">)</span><span class="p">;</span></code></pre><p>Gets key and value terms at the current map iterator position.</p><p>On success, sets <code class="inline">*key</code> and <code class="inline">*value</code> and returns <code class="inline">true</code>. Returns <code class="inline">false</code> if the
iterator is positioned at head (before first entry) or tail (beyond last entry).</p><p>Available since OTP 18.0</p><h2 id="enif_map_iterator_is_head" class="section-heading"><a href="#enif_map_iterator_is_head" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_map_iterator_is_head()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_map_iterator_is_head</span><span class="p" data-group-id="2800527472-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifMapIterator</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p" data-group-id="2800527472-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if map iterator <code class="inline">iter</code> is positioned before the first entry.</p><p>Available since OTP 18.0</p><h2 id="enif_map_iterator_is_tail" class="section-heading"><a href="#enif_map_iterator_is_tail" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_map_iterator_is_tail()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_map_iterator_is_tail</span><span class="p" data-group-id="6282943712-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifMapIterator</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p" data-group-id="6282943712-1">)</span><span class="p">;</span></code></pre><p>Returns <code class="inline">true</code> if map iterator <code class="inline">iter</code> is positioned after the last entry.</p><p>Available since OTP 18.0</p><h2 id="enif_map_iterator_next" class="section-heading"><a href="#enif_map_iterator_next" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_map_iterator_next()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_map_iterator_next</span><span class="p" data-group-id="4870799023-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifMapIterator</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p" data-group-id="4870799023-1">)</span><span class="p">;</span></code></pre><p>Increments map iterator to point to the next key-value entry.</p><p>Returns <code class="inline">true</code> if the iterator is now positioned at a valid key-value entry, or
<code class="inline">false</code> if the iterator is positioned at the tail (beyond the last entry).</p><p>Available since OTP 18.0</p><h2 id="enif_map_iterator_prev" class="section-heading"><a href="#enif_map_iterator_prev" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_map_iterator_prev()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_map_iterator_prev</span><span class="p" data-group-id="7907487907-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifMapIterator</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p" data-group-id="7907487907-1">)</span><span class="p">;</span></code></pre><p>Decrements map iterator to point to the previous key-value entry.</p><p>Returns <code class="inline">true</code> if the iterator is now positioned at a valid key-value entry, or
<code class="inline">false</code> if the iterator is positioned at the head (before the first entry).</p><p>Available since OTP 18.0</p><h2 id="enif_monitor_process" class="section-heading"><a href="#enif_monitor_process" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_monitor_process()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_monitor_process</span><span class="p" data-group-id="1266137613-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">caller_env</span><span class="p">,</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifPid</span><span class="o">*</span><span class="w"> </span><span class="n">target_pid</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifMonitor</span><span class="o">*</span><span class="w"> </span><span class="n">mon</span><span class="p" data-group-id="1266137613-1">)</span><span class="p">;</span></code></pre><p>Starts monitoring a process from a resource. When a process is monitored, a
process exit results in a call to the provided
<a href="erl_nif.html#ErlNifResourceDown"><code class="inline">down</code></a> callback associated with the resource
type.</p><p>Argument <code class="inline">obj</code> is pointer to the resource to hold the monitor and <code class="inline">*target_pid</code>
identifies the local process to be monitored.</p><p>If <code class="inline">mon</code> is not <code class="inline">NULL</code>, a successful call stores the identity of the monitor in
the <a href="erl_nif.html#ErlNifMonitor"><code class="inline">ErlNifMonitor</code></a> struct pointed to by <code class="inline">mon</code>. This
identifier is used to refer to the monitor for later removal with
<a href="erl_nif.html#enif_demonitor_process"><code class="inline">enif_demonitor_process</code></a> or compare with
<a href="erl_nif.html#enif_compare_monitors"><code class="inline">enif_compare_monitors</code></a>. A monitor is
automatically removed when it triggers or when the resource is deallocated.</p><p>Argument <code class="inline">caller_env</code> is the environment of the calling thread
(<a href="erl_nif.html#proc_bound_env">process bound</a> or
<a href="erl_nif.html#callback_env">callback</a> environment) or <code class="inline">NULL</code> if calling from a
custom thread not spawned by ERTS.</p><p>Returns <code class="inline">0</code> on success, &lt; 0 if no <code class="inline">down</code> callback is provided, and &gt; 0 if the
process is no longer alive or if <code class="inline">target_pid</code> is
<a href="erl_nif.html#enif_set_pid_undefined">undefined</a>.</p><p>This function is thread-safe.</p><p>Available since OTP 20.0</p><h2 id="enif_monotonic_time" class="section-heading"><a href="#enif_monotonic_time" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_monotonic_time()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifTime</span><span class="w"> </span><span class="nf">enif_monotonic_time</span><span class="p" data-group-id="0056556706-1">(</span><span class="w">
        </span><span class="no">ErlNifTimeUnit</span><span class="w"> </span><span class="n">time_unit</span><span class="p" data-group-id="0056556706-1">)</span><span class="p">;</span></code></pre><p>Returns the current
<a href="time_correction.html#erlang-monotonic-time">Erlang monotonic time</a>. Notice that
it is not uncommon with negative values.</p><p><code class="inline">time_unit</code> is the time unit of the returned value.</p><p>Returns <code class="inline">ERL_NIF_TIME_ERROR</code> if called with an invalid time unit argument, or if
called from a thread that is not a scheduler thread.</p><p>See also <a href="erl_nif.html#ErlNifTime"><code class="inline">ErlNifTime</code></a> and
<a href="erl_nif.html#ErlNifTimeUnit"><code class="inline">ErlNifTimeUnit</code></a>.</p><p>Available since OTP 18.3</p><h2 id="enif_mutex_create" class="section-heading"><a href="#enif_mutex_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_mutex_create()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifMutex</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_mutex_create</span><span class="p" data-group-id="9704770905-1">(</span><span class="w">
        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p" data-group-id="9704770905-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_mutex_create"><code class="inline">erl_drv_mutex_create</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_mutex_destroy" class="section-heading"><a href="#enif_mutex_destroy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_mutex_destroy()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_mutex_destroy</span><span class="p" data-group-id="3676792727-1">(</span><span class="w">
        </span><span class="no">ErlNifMutex</span><span class="w"> </span><span class="o">*</span><span class="n">mtx</span><span class="p" data-group-id="3676792727-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_mutex_destroy"><code class="inline">erl_drv_mutex_destroy</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_mutex_lock" class="section-heading"><a href="#enif_mutex_lock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_mutex_lock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_mutex_lock</span><span class="p" data-group-id="4107502584-1">(</span><span class="w">
        </span><span class="no">ErlNifMutex</span><span class="w"> </span><span class="o">*</span><span class="n">mtx</span><span class="p" data-group-id="4107502584-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_mutex_lock"><code class="inline">erl_drv_mutex_lock</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_mutex_name" class="section-heading"><a href="#enif_mutex_name" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_mutex_name()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">enif_mutex_name</span><span class="p" data-group-id="1568842537-1">(</span><span class="w">
        </span><span class="no">ErlNifMutex</span><span class="o">*</span><span class="w"> </span><span class="n">mtx</span><span class="p" data-group-id="1568842537-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_mutex_name"><code class="inline">erl_drv_mutex_name</code></a>.</p><p>Available since OTP 21.0</p><h2 id="enif_mutex_trylock" class="section-heading"><a href="#enif_mutex_trylock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_mutex_trylock()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_mutex_trylock</span><span class="p" data-group-id="6832008778-1">(</span><span class="w">
        </span><span class="no">ErlNifMutex</span><span class="w"> </span><span class="o">*</span><span class="n">mtx</span><span class="p" data-group-id="6832008778-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_mutex_trylock"><code class="inline">erl_drv_mutex_trylock</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_mutex_unlock" class="section-heading"><a href="#enif_mutex_unlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_mutex_unlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_mutex_unlock</span><span class="p" data-group-id="6467004615-1">(</span><span class="w">
        </span><span class="no">ErlNifMutex</span><span class="w"> </span><span class="o">*</span><span class="n">mtx</span><span class="p" data-group-id="6467004615-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_mutex_unlock"><code class="inline">erl_drv_mutex_unlock</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_now_time" class="section-heading"><a href="#enif_now_time" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_now_time()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_now_time</span><span class="p" data-group-id="5043063307-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p" data-group-id="5043063307-1">)</span><span class="p">;</span></code></pre><p>Returns an <a href="erlang.html#now/0"><code class="inline">erlang:now()</code></a> time stamp.</p><p><em>This function is deprecated.</em></p><p>Available since OTP 19.0</p><h2 id="enif_open_resource_type" class="section-heading"><a href="#enif_open_resource_type" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_open_resource_type()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifResourceType</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_open_resource_type</span><span class="p" data-group-id="7142302626-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">module_str</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifResourceDtor</span><span class="o">*</span><span class="w"> </span><span class="n">dtor</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifResourceFlags</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifResourceFlags</span><span class="o">*</span><span class="w"> </span><span class="n">tried</span><span class="p" data-group-id="7142302626-1">)</span><span class="p">;</span></code></pre><p>Creates or takes over a resource type identified by the string <code class="inline">name</code> and gives
it the destructor function pointed to by
<a href="erl_nif.html#ErlNifResourceDtor"><code class="inline">dtor</code></a>. Argument <code class="inline">flags</code> can have the following
values:</p><ul><li><p><strong><code class="inline">ERL_NIF_RT_CREATE</code></strong> - Creates a new resource type that does not already
exist.</p></li><li><p><strong><code class="inline">ERL_NIF_RT_TAKEOVER</code></strong> - Opens an existing resource type and takes over
ownership of all its instances. The supplied destructor <code class="inline">dtor</code> is called both
for existing instances and new instances not yet created by the calling NIF
library.</p></li></ul><p>The two flag values can be combined with bitwise OR. The resource type name is
local to the calling module. Argument <code class="inline">module_str</code> is not (yet) used and must be
<code class="inline">NULL</code>. <code class="inline">dtor</code> can be <code class="inline">NULL</code> if no destructor is needed.</p><p>On success, the function returns a pointer to the resource type and <code class="inline">*tried</code> is
set to either <code class="inline">ERL_NIF_RT_CREATE</code> or <code class="inline">ERL_NIF_RT_TAKEOVER</code> to indicate what was
done. On failure, returns <code class="inline">NULL</code> and sets <code class="inline">*tried</code> to <code class="inline">flags</code>. It is allowed to
set <code class="inline">tried</code> to <code class="inline">NULL</code>.</p><p>Notice that <code class="inline">enif_open_resource_type</code> is only allowed to be called in the two
callbacks <a href="erl_nif.html#load"><code class="inline">load</code></a> and <a href="erl_nif.html#upgrade"><code class="inline">upgrade</code></a>. The
resource type is only created or taken over if the calling <code class="inline">load</code>/<code class="inline">upgrade</code>
function returns successfully.</p><p>See also <a href="erl_nif.html#enif_open_resource_type_x"><code class="inline">enif_open_resource_type_x</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_open_resource_type_x" class="section-heading"><a href="#enif_open_resource_type_x" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_open_resource_type_x()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifResourceType</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_open_resource_type_x</span><span class="p" data-group-id="0272348115-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifResourceTypeInit</span><span class="o">*</span><span class="w"> </span><span class="n">init</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifResourceFlags</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifResourceFlags</span><span class="o">*</span><span class="w"> </span><span class="n">tried</span><span class="p" data-group-id="0272348115-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_nif.html#enif_open_resource_type"><code class="inline">enif_open_resource_type</code></a> except
it accepts additional callback functions for resource types that are used
together with <a href="erl_nif.html#enif_select"><code class="inline">enif_select</code></a> and
<a href="erl_nif.html#enif_monitor_process"><code class="inline">enif_monitor_process</code></a>.</p><p>Argument <code class="inline">init</code> is a pointer to an
<a href="erl_nif.html#ErlNifResourceTypeInit"><code class="inline">ErlNifResourceTypeInit</code></a> structure that
contains the function pointers for destructor, down and stop callbacks for the
resource type.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Only members <code class="inline">dtor</code>, <code class="inline">down</code> and <code class="inline">stop</code> in
<a href="erl_nif.html#ErlNifResourceTypeInit"><code class="inline">ErlNifResourceTypeInit</code></a> are read by
<code class="inline">enif_open_resource_type_x</code>. To implement the new <code class="inline">dyncall</code> callback use
<a href="erl_nif.html#enif_init_resource_type"><code class="inline">enif_init_resource_type</code></a>.</p></section><p>Available since OTP 20.0</p><h2 id="enif_init_resource_type" class="section-heading"><a href="#enif_init_resource_type" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_init_resource_type()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifResourceType</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_init_resource_type</span><span class="p" data-group-id="7904259527-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifResourceTypeInit</span><span class="o">*</span><span class="w"> </span><span class="n">init</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifResourceFlags</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifResourceFlags</span><span class="o">*</span><span class="w"> </span><span class="n">tried</span><span class="p" data-group-id="7904259527-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_nif.html#enif_open_resource_type_x"><code class="inline">enif_open_resource_type_x</code></a>
except it accepts an additional callback function for resource types that are
used together with
<a href="erl_nif.html#enif_dynamic_resource_call"><code class="inline">enif_dynamic_resource_call</code></a>.</p><p>Argument <code class="inline">init</code> is a pointer to an
<a href="erl_nif.html#ErlNifResourceTypeInit"><code class="inline">ErlNifResourceTypeInit</code></a> structure that
contains the callback function pointers <code class="inline">dtor</code>, <code class="inline">down</code>, <code class="inline">stop</code> and the new
<code class="inline">dyncall</code>. The struct also contains the field <code class="inline">members</code> that must be set to the
number of initialized callbacks counted from the top of the struct. For example,
to initialize all callbacks including <code class="inline">dyncall</code>, <code class="inline">members</code> should be set to 4.
All callbacks are optional and may be set to <code class="inline">NULL</code>.</p><p>Available since OTP 24.0</p><h2 id="enif_port_command" class="section-heading"><a href="#enif_port_command" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_port_command()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_port_command</span><span class="p" data-group-id="3343548926-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w">
        </span><span class="no">ErlNifPort</span><span class="o">*</span><span class="w"> </span><span class="n">to_port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">msg_env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">msg</span><span class="p" data-group-id="3343548926-1">)</span><span class="p">;</span></code></pre><p>Works as <a href="erlang.html#port_command/2"><code class="inline">erlang:port_command/2</code></a>, except that it is always completely
asynchronous.</p><ul><li><p><strong><code class="inline">env</code></strong> - The environment of the calling process. Must not be <code class="inline">NULL</code>.</p></li><li><p><strong><code class="inline">*to_port</code></strong> - The port ID of the receiving port. The port ID is to refer to
a port on the local node.</p></li><li><p><strong><code class="inline">msg_env</code></strong> - The environment of the message term. Can be a process
independent environment allocated with
<a href="erl_nif.html#enif_alloc_env"><code class="inline">enif_alloc_env</code></a> or <code class="inline">NULL</code>.</p></li><li><p><strong><code class="inline">msg</code></strong> - The message term to send. The same limitations apply as on the
payload to <a href="erlang.html#port_command/2"><code class="inline">erlang:port_command/2</code></a>.</p></li></ul><p>Using a <code class="inline">msg_env</code> of <code class="inline">NULL</code> is an optimization, which groups together calls to
<code class="inline">enif_alloc_env</code>, <code class="inline">enif_make_copy</code>, <code class="inline">enif_port_command</code>, and <code class="inline">enif_free_env</code>
into one call. This optimization is only useful when a majority of the terms are
to be copied from <code class="inline">env</code> to <code class="inline">msg_env</code>.</p><p>Returns <code class="inline">true</code> if the command is successfully sent. Returns <code class="inline">false</code> if the
command fails, for example:</p><ul><li><code class="inline">*to_port</code> does not refer to a local port.</li><li>The currently executing process (that is, the sender) is not alive.</li><li><code class="inline">msg</code> is invalid.</li></ul><p>See also <a href="erl_nif.html#enif_get_local_port"><code class="inline">enif_get_local_port</code></a>.</p><p>Available since OTP 19.0</p><h2 id="enif_priv_data" class="section-heading"><a href="#enif_priv_data" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_priv_data()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_priv_data</span><span class="p" data-group-id="7674406495-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p" data-group-id="7674406495-1">)</span><span class="p">;</span></code></pre><p>Returns the pointer to the private data that was set by
<a href="erl_nif.html#load"><code class="inline">load</code></a> or <a href="erl_nif.html#upgrade"><code class="inline">upgrade</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_raise_exception" class="section-heading"><a href="#enif_raise_exception" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_raise_exception()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_raise_exception</span><span class="p" data-group-id="4435484004-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">reason</span><span class="p" data-group-id="4435484004-1">)</span><span class="p">;</span></code></pre><p>Creates an error exception with the term <code class="inline">reason</code> to be returned from a NIF, and
associates it with environment <code class="inline">env</code>. Once a NIF or any function it calls
invokes <code class="inline">enif_raise_exception</code>, the runtime ensures that the exception it
creates is raised when the NIF returns, even if the NIF attempts to return a
non-exception term instead.</p><p>The return value from <code class="inline">enif_raise_exception</code> can only be used as the return
value from the NIF that invoked it (directly or indirectly) or be passed to
<a href="erl_nif.html#enif_is_exception"><code class="inline">enif_is_exception</code></a>, but not to any other NIF
API function.</p><p>See also <a href="erl_nif.html#enif_has_pending_exception"><code class="inline">enif_has_pending_exception</code></a>
and <a href="erl_nif.html#enif_make_badarg"><code class="inline">enif_make_badarg</code></a>.</p><p>Available since OTP 18.0</p><h2 id="enif_realloc" class="section-heading"><a href="#enif_realloc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_realloc()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_realloc</span><span class="p" data-group-id="6496782286-1">(</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="6496782286-1">)</span><span class="p">;</span></code></pre><p>Reallocates memory allocated by <a href="erl_nif.html#enif_alloc"><code class="inline">enif_alloc</code></a> to <code class="inline">size</code>
bytes.</p><p>Returns <code class="inline">NULL</code> if the reallocation fails.</p><p>The returned pointer is suitably aligned for any built-in type that fit in the
allocated memory.</p><p>Available since OTP 20.2</p><h2 id="enif_realloc_binary" class="section-heading"><a href="#enif_realloc_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_realloc_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_realloc_binary</span><span class="p" data-group-id="1831917117-1">(</span><span class="w">
        </span><span class="no">ErlNifBinary</span><span class="o">*</span><span class="w"> </span><span class="n">bin</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="1831917117-1">)</span><span class="p">;</span></code></pre><p>Changes the size of a binary <code class="inline">bin</code>. The source binary can be read-only, in which
case it is left untouched and a mutable copy is allocated and assigned to
<code class="inline">*bin</code>.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if memory allocation failed.</p><p>Available since OTP R13B04</p><h2 id="enif_release_binary" class="section-heading"><a href="#enif_release_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_release_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_release_binary</span><span class="p" data-group-id="4128177858-1">(</span><span class="w">
        </span><span class="no">ErlNifBinary</span><span class="o">*</span><span class="w"> </span><span class="n">bin</span><span class="p" data-group-id="4128177858-1">)</span><span class="p">;</span></code></pre><p>Releases a binary obtained from
<a href="erl_nif.html#enif_alloc_binary"><code class="inline">enif_alloc_binary</code></a>.</p><h2 id="enif_release_resource" class="section-heading"><a href="#enif_release_resource" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_release_resource()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_release_resource</span><span class="p" data-group-id="9573089084-1">(</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p" data-group-id="9573089084-1">)</span><span class="p">;</span></code></pre><p>Removes a reference to resource object <code class="inline">obj</code> obtained from
<a href="erl_nif.html#enif_alloc_resource"><code class="inline">enif_alloc_resource</code></a>. The resource object is
destructed when the last reference is removed. Each call to
<code class="inline">enif_release_resource</code> must correspond to a previous call to
<code class="inline">enif_alloc_resource</code> or <a href="erl_nif.html#enif_keep_resource"><code class="inline">enif_keep_resource</code></a>.
References made by <a href="erl_nif.html#enif_make_resource"><code class="inline">enif_make_resource</code></a> can
only be removed by the garbage collector.</p><p>There are no guarantees exactly when the destructor of an unreferenced resource
is called. It could be called directly by <code class="inline">enif_release_resource</code> but it could
also be scheduled to be called at a later time possibly by another thread.</p><p>Available since OTP R13B04</p><h2 id="enif_rwlock_create" class="section-heading"><a href="#enif_rwlock_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_rwlock_create()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifRWLock</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_rwlock_create</span><span class="p" data-group-id="0382728279-1">(</span><span class="w">
        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p" data-group-id="0382728279-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_rwlock_create"><code class="inline">erl_drv_rwlock_create</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_rwlock_destroy" class="section-heading"><a href="#enif_rwlock_destroy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_rwlock_destroy()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_rwlock_destroy</span><span class="p" data-group-id="1856009383-1">(</span><span class="w">
        </span><span class="no">ErlNifRWLock</span><span class="w"> </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="1856009383-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_rwlock_destroy"><code class="inline">erl_drv_rwlock_destroy</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_rwlock_name" class="section-heading"><a href="#enif_rwlock_name" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_rwlock_name()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">enif_rwlock_name</span><span class="p" data-group-id="5346664541-1">(</span><span class="w">
        </span><span class="no">ErlNifRWLock</span><span class="o">*</span><span class="w"> </span><span class="n">rwlck</span><span class="p" data-group-id="5346664541-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_rwlock_name"><code class="inline">erl_drv_rwlock_name</code></a>.</p><p>Available since OTP 21.0</p><h2 id="enif_rwlock_rlock" class="section-heading"><a href="#enif_rwlock_rlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_rwlock_rlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_rwlock_rlock</span><span class="p" data-group-id="1907900895-1">(</span><span class="w">
        </span><span class="no">ErlNifRWLock</span><span class="w"> </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="1907900895-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_rwlock_rlock"><code class="inline">erl_drv_rwlock_rlock</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_rwlock_runlock" class="section-heading"><a href="#enif_rwlock_runlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_rwlock_runlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_rwlock_runlock</span><span class="p" data-group-id="3898165316-1">(</span><span class="w">
        </span><span class="no">ErlNifRWLock</span><span class="w"> </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="3898165316-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_rwlock_runlock"><code class="inline">erl_drv_rwlock_runlock</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_rwlock_rwlock" class="section-heading"><a href="#enif_rwlock_rwlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_rwlock_rwlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_rwlock_rwlock</span><span class="p" data-group-id="1483765867-1">(</span><span class="w">
        </span><span class="no">ErlNifRWLock</span><span class="w"> </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="1483765867-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_rwlock_rwlock"><code class="inline">erl_drv_rwlock_rwlock</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_rwlock_rwunlock" class="section-heading"><a href="#enif_rwlock_rwunlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_rwlock_rwunlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_rwlock_rwunlock</span><span class="p" data-group-id="4402136649-1">(</span><span class="w">
        </span><span class="no">ErlNifRWLock</span><span class="w"> </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="4402136649-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_rwlock_rwunlock"><code class="inline">erl_drv_rwlock_rwunlock</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_rwlock_tryrlock" class="section-heading"><a href="#enif_rwlock_tryrlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_rwlock_tryrlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_rwlock_tryrlock</span><span class="p" data-group-id="2119048737-1">(</span><span class="w">
        </span><span class="no">ErlNifRWLock</span><span class="w"> </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="2119048737-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_rwlock_tryrlock"><code class="inline">erl_drv_rwlock_tryrlock</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_rwlock_tryrwlock" class="section-heading"><a href="#enif_rwlock_tryrwlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_rwlock_tryrwlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_rwlock_tryrwlock</span><span class="p" data-group-id="7467717980-1">(</span><span class="w">
        </span><span class="no">ErlNifRWLock</span><span class="w"> </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="7467717980-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_rwlock_tryrwlock"><code class="inline">erl_drv_rwlock_tryrwlock</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_schedule_nif" class="section-heading"><a href="#enif_schedule_nif" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_schedule_nif()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="nf">enif_schedule_nif</span><span class="p" data-group-id="2319674977-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">caller_env</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">fun_name</span><span class="p">,</span><span class="w">
        </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="p" data-group-id="2319674977-2">(</span><span class="o">*</span><span class="n">fp</span><span class="p" data-group-id="2319674977-2">)</span><span class="p" data-group-id="2319674977-3">(</span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">argv</span><span class="p" data-group-id="2319674977-4">[</span><span class="p" data-group-id="2319674977-4">]</span><span class="p" data-group-id="2319674977-3">)</span><span class="p">,</span><span class="w">
        </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">argv</span><span class="p" data-group-id="2319674977-5">[</span><span class="p" data-group-id="2319674977-5">]</span><span class="p" data-group-id="2319674977-1">)</span><span class="p">;</span></code></pre><p>Schedules NIF <code class="inline">fp</code> to execute. This function allows an application to break up
long-running work into multiple regular NIF calls or to schedule a
<a href="erl_nif.html#dirty_nifs">dirty NIF</a> to execute on a dirty scheduler thread.</p><ul><li><p><strong><code class="inline">caller_env</code></strong> - Must be <a href="erl_nif.html#proc_bound_env">process bound</a>
environment of the calling NIF.</p></li><li><p><strong><code class="inline">fun_name</code></strong> - Provides a name for the NIF that is scheduled for execution.
If it cannot be converted to an atom, <code class="inline">enif_schedule_nif</code> returns a <code class="inline">badarg</code>
exception.</p></li><li><p><strong><code class="inline">flags</code></strong> - Must be set to <code class="inline">0</code> for a regular NIF,
<code class="inline">ERL_NIF_DIRTY_JOB_CPU_BOUND</code> if the job is expected to be CPU-bound, or
<code class="inline">ERL_NIF_DIRTY_JOB_IO_BOUND</code> for jobs that will be I/O-bound.</p></li><li><p><strong><code class="inline">argc</code> and <code class="inline">argv</code></strong> - Can either be the originals passed into the calling
NIF, or can be values created by the calling NIF.</p></li></ul><p>The calling NIF must use the return value of <code class="inline">enif_schedule_nif</code> as its own
return value.</p><p>Be aware that <code class="inline">enif_schedule_nif</code>, as its name implies, only schedules the NIF
for future execution. The calling NIF does not block waiting for the scheduled
NIF to execute and return. This means that the calling NIF cannot expect to
receive the scheduled NIF return value and use it for further operations.</p><p>Available since OTP 17.3</p><h2 id="enif_select" class="section-heading"><a href="#enif_select" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_select()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_select</span><span class="p" data-group-id="9369636102-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifEvent</span><span class="w"> </span><span class="n">event</span><span class="p">,</span><span class="w">
        </span><span class="k">enum</span><span class="w"> </span><span class="no">ErlNifSelectFlags</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifPid</span><span class="o">*</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">ref</span><span class="p" data-group-id="9369636102-1">)</span><span class="p">;</span></code></pre><p>This function can be used to receive asynchronous notifications when OS-specific
event objects become ready for either read or write operations.</p><p>Argument <code class="inline">event</code> identifies the event object. On Unix systems, the functions
<code class="inline">select</code>/<code class="inline">poll</code> are used. The event object must be a socket, pipe or other file
descriptor object that <code class="inline">select</code>/<code class="inline">poll</code> can use.</p><p>Argument <code class="inline">mode</code> describes the type of events to wait for. It can be
<code class="inline">ERL_NIF_SELECT_READ</code>, <code class="inline">ERL_NIF_SELECT_WRITE</code> or a bitwise OR combination to
wait for both. It can also be <code class="inline">ERL_NIF_SELECT_STOP</code> or <code class="inline">ERL_NIF_SELECT_CANCEL</code>
which are described further below. When a read or write event is triggered, a
notification message like this is sent to the process identified by <code class="inline">pid</code>:</p><pre><code class="text">{select, Obj, Ref, ready_input | ready_output}</code></pre><p><code class="inline">ready_input</code> or <code class="inline">ready_output</code> indicates if the event object is ready for
reading or writing.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>For complete control over the message format use the newer functions
<a href="erl_nif.html#enif_select_read"><code class="inline">enif_select_read</code></a> or
<a href="erl_nif.html#enif_select_write"><code class="inline">enif_select_write</code></a> introduced in erts-11.0
(OTP-22.0).</p></section><p>Argument <code class="inline">pid</code> may be <code class="inline">NULL</code> to indicate the calling process. It must not be set
as <a href="erl_nif.html#enif_set_pid_undefined">undefined</a>.</p><p>Argument <code class="inline">obj</code> is a resource object obtained from
<a href="erl_nif.html#enif_alloc_resource"><code class="inline">enif_alloc_resource</code></a>. The purpose of the
resource objects is as a container of the event object to manage its state and
lifetime. A handle to the resource is received in the notification message as
<code class="inline">Obj</code>.</p><p>Argument <code class="inline">ref</code> must be either a reference obtained from <a href="erlang.html#make_ref/0"><code class="inline">erlang:make_ref/0</code></a> or
the atom <code class="inline">undefined</code>. It will be passed as <code class="inline">Ref</code> in the notifications. If a
selective <code class="inline">receive</code> statement is used to wait for the notification then a
reference created just before the <code class="inline">receive</code> will exploit a runtime optimization
that bypasses all earlier received messages in the queue.</p><p>The notifications are one-shot only. To receive further notifications of the
same type (read or write), repeated calls to <code class="inline">enif_select</code> must be made after
receiving each notification.</p><p><code class="inline">ERL_NIF_SELECT_CANCEL</code> can be used to cancel previously selected events. It
must be used in a bitwise OR combination with <code class="inline">ERL_NIF_SELECT_READ</code> and/or
<code class="inline">ERL_NIF_SELECT_WRITE</code> to indicate which type of event to cancel. Arguments
<code class="inline">pid</code> and <code class="inline">ref</code> are ignored when <code class="inline">ERL_NIF_SELECT_CANCEL</code> is specified. The
return value will tell if the event was actually cancelled or if a notification
may already have been sent.</p><p>Use <code class="inline">ERL_NIF_SELECT_STOP</code> as <code class="inline">mode</code> in order to safely close an event object
that has been passed to <code class="inline">enif_select</code>. The
<a href="erl_nif.html#ErlNifResourceStop"><code class="inline">stop</code></a> callback of the resource <code class="inline">obj</code> will be
called when it is safe to close the event object. This safe way of closing event
objects must be used even if all notifications have been received (or cancelled)
and no further calls to <code class="inline">enif_select</code> have been made. <code class="inline">ERL_NIF_SELECT_STOP</code> will
first cancel any selected events before it calls or schedules the <code class="inline">stop</code>
callback. Arguments <code class="inline">pid</code> and <code class="inline">ref</code> are ignored when <code class="inline">ERL_NIF_SELECT_STOP</code> is
specified.</p><p>The first call to <code class="inline">enif_select</code> for a specific OS <code class="inline">event</code> will establish a
relation between the event object and the containing resource. All subsequent
calls for an <code class="inline">event</code> must pass its containing resource as argument <code class="inline">obj</code>. The
relation is dissolved when <code class="inline">enif_select</code> has been called with <code class="inline">mode</code> as
<code class="inline">ERL_NIF_SELECT_STOP</code> and the corresponding <code class="inline">stop</code> callback has returned. A
resource can contain several event objects but one event object can only be
contained within one resource. A resource will not be destructed until all its
contained relations have been dissolved.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Use <a href="erl_nif.html#enif_monitor_process"><code class="inline">enif_monitor_process</code></a> together with
<code class="inline">enif_select</code> to detect failing Erlang processes and prevent them from causing
permanent leakage of resources and their contained OS event objects.</p></section><p>Returns a non-negative value on success where the following bits can be set:</p><ul><li><p><strong><code class="inline">ERL_NIF_SELECT_STOP_CALLED</code></strong> - The stop callback was called directly by
<code class="inline">enif_select</code>.</p></li><li><p><strong><code class="inline">ERL_NIF_SELECT_STOP_SCHEDULED</code></strong> - The stop callback was scheduled to run
on some other thread or later by this thread.</p></li><li><p><strong><code class="inline">ERL_NIF_SELECT_READ_CANCELLED</code></strong> - A read event was cancelled by
<code class="inline">ERL_NIF_SELECT_CANCEL</code> or <code class="inline">ERL_NIF_SELECT_STOP</code> and is guaranteed not to
generate a <code class="inline">ready_input</code> notification message.</p></li><li><p><strong><code class="inline">ERL_NIF_SELECT_WRITE_CANCELLED</code></strong> - A write event was cancelled by
<code class="inline">ERL_NIF_SELECT_CANCEL</code> or <code class="inline">ERL_NIF_SELECT_STOP</code> and is guaranteed not to
generate a <code class="inline">ready_output</code> notification message.</p></li></ul><p>Returns a negative value if the call failed where the following bits can be set:</p><ul><li><p><strong><code class="inline">ERL_NIF_SELECT_INVALID_EVENT</code></strong> - Argument <code class="inline">event</code> is not a valid OS event
object.</p></li><li><p><strong><code class="inline">ERL_NIF_SELECT_FAILED</code></strong> - The system call failed to add the event object
to the poll set.</p></li></ul><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Use bitwise AND to test for specific bits in the return value. New significant
bits may be added in future releases to give more detailed information for
both failed and successful calls. Do NOT use equality tests like <code class="inline">==</code>, as that
may cause your application to stop working.</p><p>Example:</p><pre><code class="makeup c" translate="no"><span class="n">retval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">enif_select</span><span class="p" data-group-id="9835990246-1">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_SELECT_STOP</span><span class="p">,</span><span class="w"> </span><span class="n">resource</span><span class="p">,</span><span class="w"> </span><span class="n">ref</span><span class="p" data-group-id="9835990246-1">)</span><span class="p">;</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p" data-group-id="9835990246-2">(</span><span class="n">retval</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="9835990246-2">)</span><span class="w"> </span><span class="p" data-group-id="9835990246-3">{</span><span class="w">
    </span><span class="cm">/* handle error */</span><span class="w">
</span><span class="p" data-group-id="9835990246-3">}</span><span class="w">
</span><span class="cm">/* Success! */</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p" data-group-id="9835990246-4">(</span><span class="n">retval</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="no">ERL_NIF_SELECT_STOP_CALLED</span><span class="p" data-group-id="9835990246-4">)</span><span class="w"> </span><span class="p" data-group-id="9835990246-5">{</span><span class="w">
    </span><span class="cm">/* ... */</span><span class="w">
</span><span class="p" data-group-id="9835990246-5">}</span></code></pre></section><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The mode flag <code class="inline">ERL_NIF_SELECT_CANCEL</code> and the return flags
<code class="inline">ERL_NIF_SELECT_READ_CANCELLED</code> and <code class="inline">ERL_NIF_SELECT_WRITE_CANCELLED</code> were
introduced in erts-11.0 (OTP-22.0).</p></section><p>Available since OTP 20.0</p><h2 id="enif_select_read" class="section-heading"><a href="#enif_select_read" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_select_read()</span></h2><p>Available since OTP 22.0</p><h2 id="enif_select_write" class="section-heading"><a href="#enif_select_write" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_select_write()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_select_read</span><span class="p" data-group-id="6797336115-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifEvent</span><span class="w"> </span><span class="n">event</span><span class="p">,</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifPid</span><span class="o">*</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">msg_env</span><span class="p" data-group-id="6797336115-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_select_write</span><span class="p" data-group-id="1680633886-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifEvent</span><span class="w"> </span><span class="n">event</span><span class="p">,</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlNifPid</span><span class="o">*</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">msg_env</span><span class="p" data-group-id="1680633886-1">)</span><span class="p">;</span></code></pre><p>These are variants of <a href="erl_nif.html#enif_select">enif_select</a> where you can supply
your own message term <code class="inline">msg</code> that will be sent to the process instead of the
predefined tuple <code class="inline">{select,_,_,_}.</code></p><p>Argument <code class="inline">msg_env</code> must either be <code class="inline">NULL</code> or the environment of <code class="inline">msg</code> allocated
with <a href="erl_nif.html#enif_alloc_env"><code class="inline">enif_alloc_env</code></a>. If argument <code class="inline">msg_env</code> is
<code class="inline">NULL</code> the term <code class="inline">msg</code> will be copied, otherwise both <code class="inline">msg</code> and <code class="inline">msg_env</code> will be
invalidated by a successful call to <code class="inline">enif_select_read</code> or <code class="inline">enif_select_write</code>.
The environment is then to either be freed with
<a href="erl_nif.html#enif_free_env"><code class="inline">enif_free_env</code></a> or cleared for reuse with
<a href="erl_nif.html#enif_clear_env"><code class="inline">enif_clear_env</code></a>. An unsuccessful call will leave
<code class="inline">msg</code> and <code class="inline">msg_env</code> still valid.</p><p>Apart from the message format <code class="inline">enif_select_read</code> and <code class="inline">enif_select_write</code> behaves
exactly the same as <a href="erl_nif.html#enif_select">enif_select</a> with argument <code class="inline">mode</code>
as either <code class="inline">ERL_NIF_SELECT_READ</code> or <code class="inline">ERL_NIF_SELECT_WRITE</code>. To cancel or close
events use <a href="erl_nif.html#enif_select">enif_select</a>.</p><p>Available since OTP 22.0</p><h2 id="enif_self" class="section-heading"><a href="#enif_self" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_self()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifPid</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_self</span><span class="p" data-group-id="4517537456-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">caller_env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifPid</span><span class="o">*</span><span class="w"> </span><span class="n">pid</span><span class="p" data-group-id="4517537456-1">)</span><span class="p">;</span></code></pre><p>Initializes the <a href="erl_nif.html#ErlNifPid"><code class="inline">ErlNifPid</code></a> variable at <code class="inline">*pid</code> to
represent the calling process.</p><p>Returns <code class="inline">pid</code> if successful, or NULL if <code class="inline">caller_env</code> is not a
<a href="erl_nif.html#proc_bound_env">process bound environment</a>.</p><p>Available since OTP R14B</p><h2 id="enif_send" class="section-heading"><a href="#enif_send" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_send()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_send</span><span class="p" data-group-id="4074717993-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">caller_env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifPid</span><span class="o">*</span><span class="w"> </span><span class="n">to_pid</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="o">*</span><span class="w"> </span><span class="n">msg_env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">msg</span><span class="p" data-group-id="4074717993-1">)</span><span class="p">;</span></code></pre><p>Sends a message to a process.</p><ul><li><p><strong><code class="inline">caller_env</code></strong> - The environment of the calling thread
(<a href="erl_nif.html#proc_bound_env">process bound</a> or
<a href="erl_nif.html#callback_env">callback</a> environment) or <code class="inline">NULL</code> if calling from a
custom thread not spawned by ERTS.</p></li><li><p><strong><code class="inline">*to_pid</code></strong> - The pid of the receiving process. The pid is to refer to a
process on the local node.</p></li><li><p><strong><code class="inline">msg_env</code></strong> - The environment of the message term. Must be a process
independent environment allocated with
<a href="erl_nif.html#enif_alloc_env"><code class="inline">enif_alloc_env</code></a> or NULL.</p></li><li><p><strong><code class="inline">msg</code></strong> - The message term to send.</p></li></ul><p>Returns <code class="inline">true</code> if the message is successfully sent. Returns <code class="inline">false</code> if the send
operation fails, that is:</p><ul><li><code class="inline">*to_pid</code> does not refer to an alive local process.</li><li>The currently executing process (that is, the sender) is not alive.</li></ul><p>The message environment <code class="inline">msg_env</code> with all its terms (including <code class="inline">msg</code>) is
invalidated by a successful call to <code class="inline">enif_send</code>. The environment is to either be
freed with <a href="erl_nif.html#enif_free_env"><code class="inline">enif_free_env</code></a> or cleared for reuse with
<a href="erl_nif.html#enif_clear_env"><code class="inline">enif_clear_env</code></a>. An unsuccessful call will leave
<code class="inline">msg</code> and <code class="inline">msg_env</code> still valid.</p><p>If <code class="inline">msg_env</code> is set to <code class="inline">NULL</code>, the <code class="inline">msg</code> term is copied and the original term
and its environment is still valid after the call.</p><p>This function is thread-safe.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Passing <code class="inline">msg_env</code> as <code class="inline">NULL</code> is only supported as from ERTS 8.0 (Erlang/OTP
19).</p></section><p>Available since OTP R14B</p><h2 id="enif_set_option" class="section-heading"><a href="#enif_set_option" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_set_option()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_set_option</span><span class="p" data-group-id="2960007297-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifOption</span><span class="w"> </span><span class="n">opt</span><span class="p">,</span><span class="w">
</span><span class="err">	</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="2960007297-1">)</span><span class="p">;</span></code></pre><p>Set an option. On success, zero will be returned. On failure, a non zero value
will be returned. Currently the following options can be set:</p><ul><li><p><strong id="delay_halt"><a href="erl_nif.html#ErlNifOption"><code class="inline">ERL_NIF_OPT_DELAY_HALT</code></a></strong></p><pre><code class="makeup c" translate="no"><span class="nf">enif_set_option</span><span class="p" data-group-id="4861970568-1">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_OPT_DELAY_HALT</span><span class="p" data-group-id="4861970568-1">)</span></code></pre><p>Enable delay of
runtime system halt with flushing enabled until all calls to NIFs in the NIF
library have returned. If the <em>delay halt</em> feature has not been enabled, a
halt with flushing enabled may complete even though processes are still
executing inside NIFs in the NIF library. Note that by <em>returning</em> we here
mean the first point where the NIF returns control back to the runtime system,
and <em>not</em> the point where a call to a NIF return a value back to the Erlang
code that called the NIF. That is, if you schedule execution of a NIF, using
<a href="erl_nif.html#enif_schedule_nif"><code class="inline">enif_schedule_nif()</code></a>, from within a NIF while
the system is halting, the scheduled NIF call will <em>not</em> be executed even
though <em>delay halt</em> has been enabled for the NIF library.</p><p>The runtime system halts when one of the <a href="erlang.html#halt/0"><code class="inline">erlang:halt()</code></a>
BIFs are called. By default flushing is enabled, but can be disabled using the
<a href="erlang.html#halt/2"><code class="inline">erlang:halt/2</code></a> BIF. When flushing has been disabled, the <em>delay halt</em> setting
will have no effect. That is, the runtime system will halt without waiting for
NIFs to return even if the <em>delay halt</em> setting has been enabled. See the
<a href="erlang.html#halt_flush"><code class="inline">{flush, boolean()}</code></a> option of <a href="erlang.html#halt/2"><code class="inline">erlang:halt/2</code></a> for
more information.</p><p>The <code class="inline">ERL_NIF_OPT_DELAY_HALT</code> option can only be set during loading of a NIF
library in a call to <code class="inline">enif_set_option()</code> inside a NIF library
<a href="erl_nif.html#load"><code class="inline">load()</code></a> or <a href="erl_nif.html#upgrade"><code class="inline">upgrade()</code></a> call, and
will fail if set somewhere else. The <code class="inline">env</code> argument <em>must</em> be the callback
environment passed to the <code class="inline">load()</code> or the <code class="inline">upgrade()</code> call. This option can
also only be set once. That is, the <em>delay halt</em> setting cannot be changed
once it has been enabled. The <em>delay halt</em> setting is tied to the module
instance with which the NIF library instance has been loaded. That is, in case
both a new and old version of a module using the NIF library are loaded, they
can have the same or different <em>delay halt</em> settings.</p><p>The <em>delay halt</em> feature can be used in combination with an
<a href="erl_nif.html#on_halt"><em>on halt</em></a> callback. The <em>on halt</em> callback is in this
case typically used to notify processes blocked in NIFs in the library that it
is time to return in order to let the runtime system complete the halting.
Such NIFs should be dirty NIFs, since ordinary NIFs should never block for a
long time.</p></li><li><p><strong id="on_halt"><a href="erl_nif.html#ErlNifOption"><code class="inline">ERL_NIF_OPT_ON_HALT</code></a></strong></p><pre><code class="makeup c" translate="no"><span class="nf">enif_set_option</span><span class="p" data-group-id="5018154626-1">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_OPT_ON_HALT</span><span class="p">,</span><span class="w"> </span><span class="n">on_halt</span><span class="p" data-group-id="5018154626-1">)</span></code></pre><p>Install a callback that will be called when the runtime system halts with
flushing enabled.</p><p>The runtime system halts when one of the <a href="erlang.html#halt/0"><code class="inline">erlang:halt()</code></a>
BIFs are called. By default flushing is enabled, but can be disabled using the
<a href="erlang.html#halt/2"><code class="inline">erlang:halt/2</code></a> BIF. When flushing has been disabled, the runtime system will
halt without calling any <em>on halt</em> callbacks even if such are installed. See
the <a href="erlang.html#halt_flush"><code class="inline">{flush, boolean()}</code></a> option of <a href="erlang.html#halt/2"><code class="inline">erlang:halt/2</code></a>
for more information.</p><p>The <code class="inline">ERL_NIF_OPT_ON_HALT</code> option can only be set during loading of a NIF
library in a call to <code class="inline">enif_set_option()</code> inside a NIF library
<a href="erl_nif.html#load"><code class="inline">load()</code></a> or <a href="erl_nif.html#upgrade"><code class="inline">upgrade()</code></a> call, and
will fail if called somewhere else. The <code class="inline">env</code> argument <em>must</em> be the callback
environment passed to the <code class="inline">load()</code> or the <code class="inline">upgrade()</code> call. The <code class="inline">on_halt</code>
argument should be a function pointer to the callback to install.</p><p>The <a href="erl_nif.html#ErlNifOnHaltCallback"><code class="inline">on_halt</code></a> callback will be tied to the
module instance with which the NIF library
instance has been loaded. That is, in case both a new and old version of a
module using the NIF library are loaded, they can both have different, none,
or the same <em>on halt</em> callbacks installed. When unloading the NIF library
during a <a href="../../apps/kernel/code.html#purge/1">code purge</a>, an installed <em>on halt</em> callback will be
uninstalled. The <code class="inline">ERL_NIF_OPT_ON_HALT</code> option can also only be set once. That
is, the <em>on halt</em> callback cannot be changed or removed once it has been
installed by any other means than purging the module instance that loaded the
NIF library.</p><p>When the installed <em>on halt</em> callback is called, it will be passed a pointer
to <code class="inline">priv_data</code> as argument. The <code class="inline">priv_data</code> pointer can be set when loading
the NIF library.</p><p>The <em>on halt</em> callback can be used in combination with
<a href="erl_nif.html#delay_halt"><em>delay of halt</em></a> until all calls into the library have
returned. The <em>on halt</em> callback is in this case typically used to notify
processes blocked in NIFs in the library that it is time to return in order to
let the runtime system complete the halting. Such NIFs should be dirty NIFs,
since ordinary NIFs should never block for a long time.</p></li><li><p><strong id="on_unload_thread"><a href="erl_nif.html#ErlNifOption"><code class="inline">ERL_NIF_OPT_ON_UNLOAD_THREAD</code></a></strong></p><pre><code class="makeup c" translate="no"><span class="nf">enif_set_option</span><span class="p" data-group-id="2580119124-1">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="no">ERL_NIF_OPT_ON_UNLOAD_THREAD</span><span class="p">,</span><span class="w"> </span><span class="n">on_unload_thread</span><span class="p" data-group-id="2580119124-1">)</span></code></pre><p>Install a callback that will be called <strong>by each scheduler thread</strong> when the
module instance that the NIF library belongs to is purged as old. A typical
use is to release thread specific data.</p><p>The <code class="inline">ERL_NIF_OPT_ON_UNLOAD_THREAD</code> option can only be set during loading of a
NIF library inside a call to <a href="erl_nif.html#load"><code class="inline">load()</code></a> or
<a href="erl_nif.html#upgrade"><code class="inline">upgrade()</code></a> and will fail if called somewhere else. The
<code class="inline">env</code> argument <em>must</em> be the callback environment passed to the <code class="inline">load()</code> or
the <code class="inline">upgrade()</code> call.</p><p>The <a href="erl_nif.html#ErlNifOnUnloadThreadCallback"><code class="inline">on_unload_thread</code></a> argument
should be a function pointer to the callback to install. The
<em>on_unload_thread</em> callback will be tied to the module instance with which the
NIF library instance has been loaded. That is, in case both a new and old
version of a module using the NIF library are loaded, they can both have
different, none, or the same <em>on_unload_thread</em> callbacks installed. The
<code class="inline">ERL_NIF_OPT_ON_UNLOAD_THREAD</code> option can only be set once and cannot be
changed or removed once it has been installed for a module instance.</p><p>When the installed <em>on_unload_thread</em> callback is called, it will be passed a
pointer to <code class="inline">priv_data</code> as argument. The <code class="inline">priv_data</code> pointer can be set when
loading the NIF library.</p><p>The calls to the <em>on_unload_thread</em> function are made concurrently by the
different scheduler threads. There is no synchronization enforced between the
threads. However, the single finalizing call to the <a href="erl_nif.html#unload"><code class="inline">unload()</code></a>
callback for the module instance will not be made until all calls to
<em>on_unload_thread</em> have returned.</p></li></ul><p>Available since OTP 26.0</p><h2 id="enif_set_pid_undefined" class="section-heading"><a href="#enif_set_pid_undefined" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_set_pid_undefined()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_set_pid_undefined</span><span class="p" data-group-id="0959357125-1">(</span><span class="w">
        </span><span class="no">ErlNifPid</span><span class="o">*</span><span class="w"> </span><span class="n">pid</span><span class="p" data-group-id="0959357125-1">)</span><span class="p">;</span></code></pre><p>Sets an <a href="erl_nif.html#ErlNifPid"><code class="inline">ErlNifPid</code></a> variable as undefined. See
<a href="erl_nif.html#enif_is_pid_undefined"><code class="inline">enif_is_pid_undefined</code></a>.</p><p>Available since OTP 22.0</p><h2 id="enif_sizeof_resource" class="section-heading"><a href="#enif_sizeof_resource" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_sizeof_resource()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">unsigned</span><span class="w"> </span><span class="nf">enif_sizeof_resource</span><span class="p" data-group-id="5667572145-1">(</span><span class="w">
        </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p" data-group-id="5667572145-1">)</span><span class="p">;</span></code></pre><p>Gets the byte size of resource object <code class="inline">obj</code> obtained by
<a href="erl_nif.html#enif_alloc_resource"><code class="inline">enif_alloc_resource</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_snprintf" class="section-heading"><a href="#enif_snprintf" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_snprintf()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_snprintf</span><span class="p" data-group-id="5772332461-1">(</span><span class="w">
        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">format</span><span class="p">,</span><span class="w">
</span><span class="err">	</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="5772332461-1">)</span><span class="p">;</span></code></pre><p>Similar to <code class="inline">snprintf</code> but this format string also accepts <code class="inline">&quot;%T&quot;</code>, which formats
Erlang terms of type <a href="erl_nif.html#ERL_NIF_TERM"><code class="inline">ERL_NIF_TERM</code></a>.</p><p>This function is primarily intended for debugging purpose. It is not recommended
to print very large terms with <code class="inline">%T</code>. The function may change <code class="inline">errno</code>, even if
successful.</p><p>Available since OTP 19.0</p><h2 id="enif_system_info" class="section-heading"><a href="#enif_system_info" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_system_info()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_system_info</span><span class="p" data-group-id="8162840632-1">(</span><span class="w">
        </span><span class="no">ErlNifSysInfo</span><span class="w"> </span><span class="o">*</span><span class="n">sys_info_ptr</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="8162840632-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#driver_system_info"><code class="inline">driver_system_info</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_term_to_binary" class="section-heading"><a href="#enif_term_to_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_term_to_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_term_to_binary</span><span class="p" data-group-id="3868808447-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifBinary</span><span class="w"> </span><span class="o">*</span><span class="n">bin</span><span class="p" data-group-id="3868808447-1">)</span><span class="p">;</span></code></pre><p>Allocates a new binary with <a href="erl_nif.html#enif_alloc_binary"><code class="inline">enif_alloc_binary</code></a>
and stores the result of encoding <code class="inline">term</code> according to the Erlang external term
format.</p><p>Returns <code class="inline">true</code> on success, or <code class="inline">false</code> if the allocation fails.</p><p>See also <a href="erlang.html#term_to_binary/1"><code class="inline">erlang:term_to_binary/1</code></a> and
<a href="erl_nif.html#enif_binary_to_term"><code class="inline">enif_binary_to_term</code></a>.</p><p>Available since OTP 19.0</p><h2 id="enif_term_type" class="section-heading"><a href="#enif_term_type" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_term_type()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifTermType</span><span class="w"> </span><span class="nf">enif_term_type</span><span class="p" data-group-id="8702685526-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="8702685526-1">)</span><span class="p">;</span></code></pre><p>Determines the type of the given term. The term must be an ordinary Erlang term
and not one of the special terms returned by
<a href="erl_nif.html#enif_raise_exception"><code class="inline">enif_raise_exception</code></a>,
<a href="erl_nif.html#enif_schedule_nif"><code class="inline">enif_schedule_nif</code></a>, or similar.</p><p>The following types are defined at the moment:</p><ul><li><p><strong><code class="inline">ERL_NIF_TERM_TYPE_ATOM</code></strong></p></li><li><p><strong><code class="inline">ERL_NIF_TERM_TYPE_BITSTRING</code></strong> - A bitstring or binary</p></li><li><p><strong><code class="inline">ERL_NIF_TERM_TYPE_FLOAT</code></strong></p></li><li><p><strong><code class="inline">ERL_NIF_TERM_TYPE_FUN</code></strong></p></li><li><p><strong><code class="inline">ERL_NIF_TERM_TYPE_INTEGER</code></strong></p></li><li><p><strong><code class="inline">ERL_NIF_TERM_TYPE_LIST</code></strong> - A list, empty or not</p></li><li><p><strong><code class="inline">ERL_NIF_TERM_TYPE_MAP</code></strong></p></li><li><p><strong><code class="inline">ERL_NIF_TERM_TYPE_PID</code></strong></p></li><li><p><strong><code class="inline">ERL_NIF_TERM_TYPE_PORT</code></strong></p></li><li><p><strong><code class="inline">ERL_NIF_TERM_TYPE_REFERENCE</code></strong></p></li><li><p><strong><code class="inline">ERL_NIF_TERM_TYPE_TUPLE</code></strong></p></li></ul><p>Note that new types may be added in the future, so the caller must be prepared
to handle unknown types.</p><p>Available since OTP 22.0</p><h2 id="enif_thread_create" class="section-heading"><a href="#enif_thread_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_thread_create()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_thread_create</span><span class="p" data-group-id="9641837430-1">(</span><span class="w">
        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifTid</span><span class="w"> </span><span class="o">*</span><span class="n">tid</span><span class="p">,</span><span class="w">
        </span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p" data-group-id="9641837430-2">(</span><span class="o">*</span><span class="n">func</span><span class="p" data-group-id="9641837430-2">)</span><span class="p" data-group-id="9641837430-3">(</span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="p" data-group-id="9641837430-3">)</span><span class="p">,</span><span class="w">
        </span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifThreadOpts</span><span class="w"> </span><span class="o">*</span><span class="n">opts</span><span class="p" data-group-id="9641837430-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_thread_create"><code class="inline">erl_drv_thread_create</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_thread_exit" class="section-heading"><a href="#enif_thread_exit" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_thread_exit()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_thread_exit</span><span class="p" data-group-id="9395740189-1">(</span><span class="w">
        </span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="n">resp</span><span class="p" data-group-id="9395740189-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_thread_exit"><code class="inline">erl_drv_thread_exit</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_thread_join" class="section-heading"><a href="#enif_thread_join" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_thread_join()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_thread_join</span><span class="p" data-group-id="9379999579-1">(</span><span class="w">
        </span><span class="no">ErlNifTid</span><span class="w"> </span><span class="n">tid</span><span class="p">,</span><span class="w">
        </span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="o">*</span><span class="n">respp</span><span class="p" data-group-id="9379999579-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_thread_join"><code class="inline">erl_drv_thread_join</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_thread_name" class="section-heading"><a href="#enif_thread_name" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_thread_name()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">enif_thread_name</span><span class="p" data-group-id="2759825446-1">(</span><span class="w">
        </span><span class="no">ErlNifTid</span><span class="w"> </span><span class="n">tid</span><span class="p" data-group-id="2759825446-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_thread_name"><code class="inline">erl_drv_thread_name</code></a>.</p><p>Available since OTP 21.0</p><h2 id="enif_thread_opts_create" class="section-heading"><a href="#enif_thread_opts_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_thread_opts_create()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifThreadOpts</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_thread_opts_create</span><span class="p" data-group-id="8293596883-1">(</span><span class="w">
        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p" data-group-id="8293596883-1">)</span><span class="p">;</span></code></pre><p>Same as
<a href="erl_driver.html#erl_drv_thread_opts_create"><code class="inline">erl_drv_thread_opts_create</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_thread_opts_destroy" class="section-heading"><a href="#enif_thread_opts_destroy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_thread_opts_destroy()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_thread_opts_destroy</span><span class="p" data-group-id="6520396275-1">(</span><span class="w">
        </span><span class="no">ErlNifThreadOpts</span><span class="w"> </span><span class="o">*</span><span class="n">opts</span><span class="p" data-group-id="6520396275-1">)</span><span class="p">;</span></code></pre><p>Same as
<a href="erl_driver.html#erl_drv_thread_opts_destroy"><code class="inline">erl_drv_thread_opts_destroy</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_thread_self" class="section-heading"><a href="#enif_thread_self" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_thread_self()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifTid</span><span class="w"> </span><span class="nf">enif_thread_self</span><span class="p" data-group-id="3123618485-1">(</span><span class="kc">void</span><span class="p" data-group-id="3123618485-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_thread_self"><code class="inline">erl_drv_thread_self</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_thread_type" class="section-heading"><a href="#enif_thread_type" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_thread_type()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_thread_type</span><span class="p" data-group-id="2907107014-1">(</span><span class="kc">void</span><span class="p" data-group-id="2907107014-1">)</span><span class="p">;</span></code></pre><p>Determine the type of currently executing thread. A positive value indicates a
scheduler thread while a negative value or zero indicates another type of
thread. Currently the following specific types exist (which may be extended in
the future):</p><ul><li><p><strong><code class="inline">ERL_NIF_THR_UNDEFINED</code></strong> - Undefined thread that is not a scheduler thread.</p></li><li><p><strong><code class="inline">ERL_NIF_THR_NORMAL_SCHEDULER</code></strong> - A normal scheduler thread.</p></li><li><p><strong><code class="inline">ERL_NIF_THR_DIRTY_CPU_SCHEDULER</code></strong> - A dirty CPU scheduler thread.</p></li><li><p><strong><code class="inline">ERL_NIF_THR_DIRTY_IO_SCHEDULER</code></strong> - A dirty I/O scheduler thread.</p></li></ul><p>Available since OTP 19.0</p><h2 id="enif_time_offset" class="section-heading"><a href="#enif_time_offset" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_time_offset()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlNifTime</span><span class="w"> </span><span class="nf">enif_time_offset</span><span class="p" data-group-id="4953497590-1">(</span><span class="w">
        </span><span class="no">ErlNifTimeUnit</span><span class="w"> </span><span class="n">time_unit</span><span class="p" data-group-id="4953497590-1">)</span><span class="p">;</span></code></pre><p>Returns the current time offset between
<a href="time_correction.html#erlang-monotonic-time">Erlang monotonic time</a> and
<a href="time_correction.html#erlang-system-time">Erlang system time</a> converted into the
<code class="inline">time_unit</code> passed as argument.</p><p><code class="inline">time_unit</code> is the time unit of the returned value.</p><p>Returns <code class="inline">ERL_NIF_TIME_ERROR</code> if called with an invalid time unit argument or if
called from a thread that is not a scheduler thread.</p><p>See also <a href="erl_nif.html#ErlNifTime"><code class="inline">ErlNifTime</code></a> and
<a href="erl_nif.html#ErlNifTimeUnit"><code class="inline">ErlNifTimeUnit</code></a>.</p><p>Available since OTP 18.3</p><h2 id="enif_tsd_get" class="section-heading"><a href="#enif_tsd_get" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_tsd_get()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">enif_tsd_get</span><span class="p" data-group-id="4317998075-1">(</span><span class="w">
        </span><span class="no">ErlNifTSDKey</span><span class="w"> </span><span class="n">key</span><span class="p" data-group-id="4317998075-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_tsd_get"><code class="inline">erl_drv_tsd_get</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_tsd_key_create" class="section-heading"><a href="#enif_tsd_key_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_tsd_key_create()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_tsd_key_create</span><span class="p" data-group-id="8765514159-1">(</span><span class="w">
        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifTSDKey</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p" data-group-id="8765514159-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_tsd_key_create"><code class="inline">erl_drv_tsd_key_create</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_tsd_key_destroy" class="section-heading"><a href="#enif_tsd_key_destroy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_tsd_key_destroy()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_tsd_key_destroy</span><span class="p" data-group-id="5977672782-1">(</span><span class="w">
        </span><span class="no">ErlNifTSDKey</span><span class="w"> </span><span class="n">key</span><span class="p" data-group-id="5977672782-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_tsd_key_destroy"><code class="inline">erl_drv_tsd_key_destroy</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_tsd_set" class="section-heading"><a href="#enif_tsd_set" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_tsd_set()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">enif_tsd_set</span><span class="p" data-group-id="3939208137-1">(</span><span class="w">
        </span><span class="no">ErlNifTSDKey</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w">
        </span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p" data-group-id="3939208137-1">)</span><span class="p">;</span></code></pre><p>Same as <a href="erl_driver.html#erl_drv_tsd_set"><code class="inline">erl_drv_tsd_set</code></a>.</p><p>Available since OTP R13B04</p><h2 id="enif_vfprintf" class="section-heading"><a href="#enif_vfprintf" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_vfprintf()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_vfprintf</span><span class="p" data-group-id="4293898789-1">(</span><span class="w">
        </span><span class="no">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">stream</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">format</span><span class="p">,</span><span class="w">
        </span><span class="n">va_list</span><span class="w"> </span><span class="n">ap</span><span class="p" data-group-id="4293898789-1">)</span><span class="p">;</span></code></pre><p>Equivalent to <a href="erl_nif.html#enif_fprintf"><code class="inline">enif_fprintf</code></a> except that its called
with a <code class="inline">va_list</code> instead of a variable number of arguments.</p><p>Available since OTP 21.0</p><h2 id="enif_vsnprintf" class="section-heading"><a href="#enif_vsnprintf" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_vsnprintf()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_vsnprintf</span><span class="p" data-group-id="0126817605-1">(</span><span class="w">
        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="w">
        </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">format</span><span class="p">,</span><span class="w">
        </span><span class="n">va_list</span><span class="w"> </span><span class="n">ap</span><span class="p" data-group-id="0126817605-1">)</span><span class="p">;</span></code></pre><p>Equivalent to <a href="erl_nif.html#enif_snprintf"><code class="inline">enif_snprintf</code></a> except that its called
with a <code class="inline">va_list</code> instead of a variable number of arguments.</p><p>Available since OTP 21.0</p><h2 id="enif_whereis_pid" class="section-heading"><a href="#enif_whereis_pid" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_whereis_pid()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_whereis_pid</span><span class="p" data-group-id="6970561708-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">caller_env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifPid</span><span class="w"> </span><span class="o">*</span><span class="n">pid</span><span class="p" data-group-id="6970561708-1">)</span><span class="p">;</span></code></pre><p>Looks up a process by its registered name.</p><ul><li><p><strong><code class="inline">caller_env</code></strong> - The environment of the calling thread
(<a href="erl_nif.html#proc_bound_env">process bound</a> or
<a href="erl_nif.html#callback_env">callback</a> environment) or <code class="inline">NULL</code> if calling from a
custom thread not spawned by ERTS.</p></li><li><p><strong><code class="inline">name</code></strong> - The name of a registered process, as an atom.</p></li><li><p><strong><code class="inline">*pid</code></strong> - The <a href="erl_nif.html#ErlNifPid"><code class="inline">ErlNifPid</code></a> in which the resolved
process id is stored.</p></li></ul><p>On success, sets <code class="inline">*pid</code> to the local process registered with <code class="inline">name</code> and returns
<code class="inline">true</code>. If <code class="inline">name</code> is not a registered process, or is not an atom, <code class="inline">false</code> is
returned and <code class="inline">*pid</code> is unchanged.</p><p>Works as <a href="erlang.html#whereis/1"><code class="inline">erlang:whereis/1</code></a>, but restricted to processes. See
<a href="erl_nif.html#enif_whereis_port"><code class="inline">enif_whereis_port</code></a> to resolve registered ports.</p><p>Available since OTP 20.0</p><h2 id="enif_whereis_port" class="section-heading"><a href="#enif_whereis_port" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">enif_whereis_port()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">enif_whereis_port</span><span class="p" data-group-id="8537706387-1">(</span><span class="w">
        </span><span class="no">ErlNifEnv</span><span class="w"> </span><span class="o">*</span><span class="n">caller_env</span><span class="p">,</span><span class="w">
        </span><span class="no">ERL_NIF_TERM</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlNifPort</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="p" data-group-id="8537706387-1">)</span><span class="p">;</span></code></pre><p>Looks up a port by its registered name.</p><ul><li><p><strong><code class="inline">caller_env</code></strong> - The environment of the calling thread
(<a href="erl_nif.html#proc_bound_env">process bound</a> or
<a href="erl_nif.html#callback_env">callback</a> environment) or <code class="inline">NULL</code> if calling from a
custom thread not spawned by ERTS.</p></li><li><p><strong><code class="inline">name</code></strong> - The name of a registered port, as an atom.</p></li><li><p><strong><code class="inline">*port</code></strong> - The <a href="erl_nif.html#ErlNifPort"><code class="inline">ErlNifPort</code></a> in which the resolved
port id is stored.</p></li></ul><p>On success, sets <code class="inline">*port</code> to the port registered with <code class="inline">name</code> and returns <code class="inline">true</code>.
If <code class="inline">name</code> is not a registered port, or is not an atom, <code class="inline">false</code> is returned and
<code class="inline">*port</code> is unchanged.</p><p>Works as <a href="erlang.html#whereis/1"><code class="inline">erlang:whereis/1</code></a>, but restricted to ports. See
<a href="erl_nif.html#enif_whereis_pid"><code class="inline">enif_whereis_pid</code></a> to resolve registered
processes.</p><p>Available since OTP 20.0</p><h2 id="see-also" class="section-heading"><a href="#see-also" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">See Also</span></h2><p><a href="erlang.html#load_nif/2"><code class="inline">erlang:load_nif/2</code></a>
<a href="../../system/nif.html">NIFs (tutorial)</a>
<a href="../../system/debugging.html">Debugging NIFs and Port Drivers</a></p>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="erl_driver.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          â† Previous Page
        </span>
        <span class="title">
erl_driver
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="erts_alloc.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page â†’
        </span>
        <span class="title">
erts_alloc
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.38.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright Â© 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
