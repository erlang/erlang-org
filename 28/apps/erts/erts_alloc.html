<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.38.1">
    <meta name="project" content="erts v16.1.2">


<meta name="major-vsn" content="28">
<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=28&q=">
<link rel="canonical" href="https://www.erlang.org/doc/apps/erts/erts_alloc.html" />
    <title>erts_alloc — erts v16.1.2</title>

    <link rel="stylesheet" href="dist/html-erlang-ZK43ZOAC.css" />

    <script defer src="dist/sidebar_items-E03DE236.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-DPJLHKSM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="erts" />
        </a>

      <div>
        <a href="../../index.html" class="sidebar-projectName" translate="no">
erts
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v16.1.2
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of erts</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>erts_alloc</h1>


      <a href="https://github.com/erlang/otp/blob/OTP-28.2/erts/doc/references/erts_alloc.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<p>An Erlang runtime system internal memory allocator library.</p><h2 id="description" class="section-heading"><a href="#description" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Description</span></h2><p><code class="inline">erts_alloc</code> is an Erlang runtime system internal memory allocator library.
<code class="inline">erts_alloc</code> provides the Erlang runtime system with a number of memory
allocators.</p><h2 id="allocators" class="section-heading"><a href="#allocators" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Allocators</span></h2><p>The following allocators are present:</p><ul><li><p><strong><code class="inline">temp_alloc</code></strong> - Allocator used for temporary allocations.</p></li><li><p><strong><code class="inline">eheap_alloc</code></strong> - Allocator used for Erlang heap data, such as Erlang
process heaps.</p></li><li><p><strong><code class="inline">binary_alloc</code></strong> - Allocator used for Erlang binary data.</p></li><li><p><strong><code class="inline">ets_alloc</code></strong> - Allocator used for <code class="inline">ets</code> data.</p></li><li><p><strong><code class="inline">driver_alloc</code></strong> - Allocator used for driver data.</p></li><li><p><strong><code class="inline">literal_alloc</code></strong> - Allocator used for constant terms in Erlang code.</p></li><li><p><strong><code class="inline">sl_alloc</code></strong> - Allocator used for memory blocks that are expected to be
short-lived.</p></li><li><p><strong><code class="inline">ll_alloc</code></strong> - Allocator used for memory blocks that are expected to be
long-lived, for example, Erlang code.</p></li><li><p><strong><code class="inline">fix_alloc</code></strong> - A fast allocator used for some frequently used fixed size
data types.</p></li><li><p><strong><code class="inline">std_alloc</code></strong> - Allocator used for most memory blocks not allocated through
any of the other allocators described above.</p></li><li><p><strong><code class="inline">sys_alloc</code></strong> - This is normally the default <code class="inline">malloc</code> implementation used on
the specific OS.</p></li><li><p><strong><code class="inline">mseg_alloc</code></strong> - A memory segment allocator. It is used by other allocators
for allocating memory segments and is only available on systems that have the
<code class="inline">mmap</code> system call. Memory segments that are deallocated are kept for a while
in a segment cache before they are destroyed. When segments are allocated,
cached segments are used if possible instead of creating new segments. This to
reduce the number of system calls made.</p></li></ul><p><code class="inline">sys_alloc</code>, <code class="inline">literal_alloc</code> and <code class="inline">temp_alloc</code> are always enabled and cannot be
disabled. <code class="inline">mseg_alloc</code> is always enabled if it is available and an allocator
that uses it is enabled. All other allocators can be
<a href="erts_alloc.html#M_e">enabled or disabled</a>. By default all allocators are enabled.
When an allocator is disabled, <code class="inline">sys_alloc</code> is used instead of the disabled
allocator.</p><p>The main idea with the <code class="inline">erts_alloc</code> library is to separate memory blocks that
are used differently into different memory areas, to achieve less memory
fragmentation. By putting less effort in finding a good fit for memory blocks
that are frequently allocated than for those less frequently allocated, a
performance gain can be achieved.</p><p><a href="" id="alloc_util"></a></p><h2 id="the-alloc_util-framework" class="section-heading"><a href="#the-alloc_util-framework" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">The alloc_util Framework</span></h2><p>Internally a framework called <code class="inline">alloc_util</code> is used for implementing allocators.
<code class="inline">sys_alloc</code> and <code class="inline">mseg_alloc</code> do not use this framework, so the following does
<em>not</em> apply to them.</p><p>An allocator manages multiple areas, called carriers, in which memory blocks are
placed. A carrier is either placed in a separate memory segment (allocated
through <code class="inline">mseg_alloc</code>), or in the heap segment (allocated through <code class="inline">sys_alloc</code>).</p><ul><li>Multiblock carriers are used for storage of several blocks.</li><li>Singleblock carriers are used for storage of one block.</li><li>Blocks that are larger than the value of the singleblock carrier threshold
(<a href="erts_alloc.html#M_sbct"><code class="inline">sbct</code></a>) parameter are placed in singleblock carriers.</li><li>Blocks that are smaller than the value of parameter <code class="inline">sbct</code> are placed in
multiblock carriers.</li></ul><p>Normally an allocator creates a &quot;main multiblock carrier&quot;. Main multiblock
carriers are never deallocated. The size of the main multiblock carrier is
determined by the value of parameter <a href="erts_alloc.html#M_mmbcs"><code class="inline">mmbcs</code></a>.</p><p><a href="" id="mseg_mbc_sizes"></a> Sizes of multiblock carriers allocated through
<code class="inline">mseg_alloc</code> are decided based on the following parameters:</p><ul><li>The values of the largest multiblock carrier size
(<a href="erts_alloc.html#M_lmbcs"><code class="inline">lmbcs</code></a>)</li><li>The smallest multiblock carrier size (<a href="erts_alloc.html#M_smbcs"><code class="inline">smbcs</code></a>)</li><li>The multiblock carrier growth stages (<a href="erts_alloc.html#M_mbcgs"><code class="inline">mbcgs</code></a>)</li></ul><p>If <code class="inline">nc</code> is the current number of multiblock carriers (the main multiblock
carrier excluded) managed by an allocator, the size of the next <code class="inline">mseg_alloc</code>
multiblock carrier allocated by this allocator is roughly
<code class="inline">smbcs+nc*(lmbcs-smbcs)/mbcgs</code> when <code class="inline">nc &lt;= mbcgs</code>, and <code class="inline">lmbcs</code> when
<code class="inline">nc &gt; mbcgs</code>. If the value of parameter <code class="inline">sbct</code> is larger than the value of
parameter <code class="inline">lmbcs</code>, the allocator may have to create multiblock carriers that are
larger than the value of parameter <code class="inline">lmbcs</code>, though. Singleblock carriers
allocated through <code class="inline">mseg_alloc</code> are sized to whole pages.</p><p>Sizes of carriers allocated through <code class="inline">sys_alloc</code> are decided based on the value
of the <code class="inline">sys_alloc</code> carrier size (<a href="erts_alloc.html#Muycs"><code class="inline">ycs</code></a>) parameter. The
size of a carrier is the least number of multiples of the value of parameter
<code class="inline">ycs</code> satisfying the request.</p><p>Coalescing of free blocks are always performed immediately. Boundary tags
(headers and footers) in free blocks are used, which makes the time complexity
for coalescing constant.</p><p><a href="" id="strategy"></a> The memory allocation strategy used for multiblock carriers
by an allocator can be configured using parameter <a href="erts_alloc.html#M_as"><code class="inline">as</code></a>.
The following strategies are available:</p><ul><li><p><strong>Best fit</strong> - Strategy: Find the smallest block satisfying the requested
block size.</p><p>Implementation: A balanced binary search tree is used. The time complexity is
proportional to log N, where N is the number of sizes of free blocks.</p></li><li><p><strong>Address order best fit</strong> - Strategy: Find the smallest block satisfying the
requested block size. If multiple blocks are found, choose the one with the
lowest address.</p><p>Implementation: A balanced binary search tree is used. The time complexity is
proportional to log N, where N is the number of free blocks.</p></li><li><p><strong>Address order first fit</strong> - Strategy: Find the block with the lowest address
satisfying the requested block size.</p><p>Implementation: A balanced binary search tree is used. The time complexity is
proportional to log N, where N is the number of free blocks.</p></li><li><p><strong>Address order first fit carrier best fit</strong> - Strategy: Find the <em>carrier</em>
with the lowest address that can satisfy the requested block size, then find a
block within that carrier using the &quot;best fit&quot; strategy.</p><p>Implementation: Balanced binary search trees are used. The time complexity is
proportional to log N, where N is the number of free blocks.</p></li><li><p><strong>Address order first fit carrier address order best fit</strong> - Strategy: Find
the <em>carrier</em> with the lowest address that can satisfy the requested block
size, then find a block within that carrier using the &quot;address order best fit&quot;
strategy.</p><p>Implementation: Balanced binary search trees are used. The time complexity is
proportional to log N, where N is the number of free blocks.</p></li><li><p><strong>Age order first fit carrier address order first fit</strong> - Strategy: Find the
<em>oldest carrier</em> that can satisfy the requested block size, then find a block
within that carrier using the &quot;address order first fit&quot; strategy.</p><p>Implementation: A balanced binary search tree is used. The time complexity is
proportional to log N, where N is the number of free blocks.</p></li><li><p><strong>Age order first fit carrier best fit</strong> - Strategy: Find the <em>oldest carrier</em>
that can satisfy the requested block size, then find a block within that
carrier using the &quot;best fit&quot; strategy.</p><p>Implementation: Balanced binary search trees are used. The time complexity is
proportional to log N, where N is the number of free blocks.</p></li><li><p><strong>Age order first fit carrier address order best fit</strong> - Strategy: Find the
<em>oldest carrier</em> that can satisfy the requested block size, then find a block
within that carrier using the &quot;address order best fit&quot; strategy.</p><p>Implementation: Balanced binary search trees are used. The time complexity is
proportional to log N, where N is the number of free blocks.</p></li><li><p><strong>Good fit</strong> - Strategy: Try to find the best fit, but settle for the best fit
found during a limited search.</p><p>Implementation: The implementation uses segregated free lists with a maximum
block search depth (in each list) to find a good fit fast. When the maximum
block search depth is small (by default 3), this implementation has a time
complexity that is constant. The maximum block search depth can be configured
using parameter <a href="erts_alloc.html#M_mbsd"><code class="inline">mbsd</code></a>.</p></li><li><p><strong>A fit</strong> - Strategy: Do not search for a fit, inspect only one free block to
see if it satisfies the request. This strategy is only intended to be used for
temporary allocations.</p><p>Implementation: Inspect the first block in a free-list. If it satisfies the
request, it is used, otherwise a new carrier is created. The implementation
has a time complexity that is constant.</p><p>As from ERTS 5.6.1 the emulator refuses to use this strategy on other
allocators than <code class="inline">temp_alloc</code>. This because it only causes problems for other
allocators.</p></li></ul><p>Apart from the ordinary allocators described above, some pre-allocators are used
for some specific data types. These pre-allocators pre-allocate a fixed amount
of memory for certain data types when the runtime system starts. As long as
pre-allocated memory is available, it is used. When no pre-allocated memory is
available, memory is allocated in ordinary allocators. These pre-allocators are
typically much faster than the ordinary allocators, but can only satisfy a
limited number of requests.</p><p><a href="" id="flags"></a></p><h2 id="system-flags-effecting-erts_alloc" class="section-heading"><a href="#system-flags-effecting-erts_alloc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">System Flags Effecting erts_alloc</span></h2><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>Only use these flags if you are sure what you are doing. Unsuitable settings
can cause serious performance degradation and even a system crash at any time
during operation.</p></section><p>Memory allocator system flags have the following syntax: <code class="inline">+M&lt;S&gt;&lt;P&gt; &lt;V&gt;</code>, where
<code class="inline">&lt;S&gt;</code> is a letter identifying a subsystem, <code class="inline">&lt;P&gt;</code> is a parameter, and <code class="inline">&lt;V&gt;</code> is
the value to use. The flags can be passed to the Erlang emulator
(<a href="erl_cmd.html"><code class="inline">erl(1)</code></a>) as command-line arguments.</p><p>System flags effecting specific allocators have an uppercase letter as <code class="inline">&lt;S&gt;</code>.
The following letters are used for the allocators:</p><ul><li><code class="inline">B: binary_alloc</code></li><li><code class="inline">D: std_alloc</code></li><li><code class="inline">E: ets_alloc</code></li><li><code class="inline">F: fix_alloc</code></li><li><code class="inline">H: eheap_alloc</code></li><li><code class="inline">I: literal_alloc</code></li><li><code class="inline">L: ll_alloc</code></li><li><code class="inline">M: mseg_alloc</code></li><li><code class="inline">R: driver_alloc</code></li><li><code class="inline">S: sl_alloc</code></li><li><code class="inline">T: temp_alloc</code></li><li><code class="inline">Y: sys_alloc</code></li></ul><h3 id="flags-for-configuration-of-mseg_alloc" class="section-heading"><a href="#flags-for-configuration-of-mseg_alloc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Flags for Configuration of mseg_alloc</span></h3><ul><li><p><strong><code class="inline" id="MMamcbf">+MMamcbf &lt;size&gt;</code></strong> - Absolute maximum cache bad fit (in
kilobytes). A segment in the memory segment cache is not reused if its size
exceeds the requested size with more than the value of this parameter.
Defaults to <code class="inline">4096</code>.</p></li><li><p><strong><code class="inline" id="MMrmcbf">+MMrmcbf &lt;ratio&gt;</code></strong> - Relative maximum cache bad fit (in
percent). A segment in the memory segment cache is not reused if its size
exceeds the requested size with more than relative maximum cache bad fit
percent of the requested size. Defaults to <code class="inline">20</code>.</p></li><li><p><strong><code class="inline" id="MMlp">+MMlp on|off</code></strong> - Enables the use of large pages, sometimes known
as huge pages or super pages, for mapping memory segment allocations. Large
pages improve performance by reducing TLB pressure but they can sometimes be
costly to allocate or can only be allocated on a best-effort basis.  Currently
only affects memory segments allocated in a super carrier. Defaults to <code class="inline">off</code>.</p></li><li><p><strong><code class="inline" id="MMsco">+MMsco true|false</code></strong> - Sets <a href="erts_alloc.html#MMscs">super carrier</a>
only flag. Defaults to <code class="inline">true</code>. When a super carrier is used and this flag is
<code class="inline">true</code>, <code class="inline">mseg_alloc</code> only creates carriers in the super carrier. Notice that
the <code class="inline">alloc_util</code> framework can create <code class="inline">sys_alloc</code> carriers, so if you want all
carriers to be created in the super carrier, you therefore want to disable use
of <code class="inline">sys_alloc</code> carriers by also passing <a href="erts_alloc.html#Musac"><code class="inline">+Musac false</code></a>.
When the flag is <code class="inline">false</code>, <code class="inline">mseg_alloc</code> tries to create carriers outside of the
super carrier when the super carrier is full.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Setting this flag to <code class="inline">false</code> is not supported on all systems. The flag is
then ignored.</p></section></li><li><p><strong><code class="inline" id="MMscrfsd">+MMscrfsd &lt;amount&gt;</code></strong> - Sets
<a href="erts_alloc.html#MMscs">super carrier</a> reserved free segment descriptors.
Defaults to <code class="inline">65536</code>. This parameter determines the amount of memory to reserve
for free segment descriptors used by the super carrier. If the system runs out
of reserved memory for free segment descriptors, other memory is used. This
can however cause fragmentation issues, so you want to ensure that this never
happens. The maximum amount of free segment descriptors used can be retrieved
from the <code class="inline">erts_mmap</code> tuple part of the result from calling
<a href="erlang.html#system_info_allocator_tuple"><code class="inline">erlang:system_info({allocator, mseg_alloc})</code></a>.</p></li><li><p><strong><code class="inline" id="MMscrpm">+MMscrpm true|false</code></strong> - Sets
<a href="erts_alloc.html#MMscs">super carrier</a> reserve physical memory flag. Defaults to
<code class="inline">true</code>. When this flag is <code class="inline">true</code>, physical memory is reserved for the whole
super carrier at once when it is created. The reservation is after that left
unchanged. When this flag is set to <code class="inline">false</code>, only virtual address space is
reserved for the super carrier upon creation. The system attempts to reserve
physical memory upon carrier creations in the super carrier, and attempt to
unreserve physical memory upon carrier destructions in the super carrier.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>What reservation of physical memory means, highly depends on the operating
system, and how it is configured. For example, different memory overcommit
settings on Linux drastically change the behavior.</p><p>Setting this flag to <code class="inline">false</code> is possibly not supported on all systems. The
flag is then ignored.</p></section></li><li><p><strong><code class="inline" id="MMscs">+MMscs &lt;size in MB&gt;</code></strong> - Sets super carrier size (in MB).
Defaults to <code class="inline">0</code>, that is, the super carrier is by default disabled. The super
carrier is a large continuous area in the virtual address space. <code class="inline">mseg_alloc</code>
always tries to create new carriers in the super carrier if it exists. Notice
that the <code class="inline">alloc_util</code> framework can create <code class="inline">sys_alloc</code> carriers. For more
information, see <a href="erts_alloc.html#MMsco"><code class="inline">+MMsco</code></a>.</p></li><li><p><strong><code class="inline" id="MMmcs">+MMmcs &lt;amount&gt;</code></strong> - Maximum cached segments. The maximum number
of memory segments stored in the memory segment cache. Valid range is
<code class="inline">[0, 30]</code>. Defaults to <code class="inline">10</code>.</p></li></ul><h3 id="flags-for-configuration-of-sys_alloc" class="section-heading"><a href="#flags-for-configuration-of-sys_alloc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Flags for Configuration of sys_alloc</span></h3><ul><li><p><strong><code class="inline" id="MYe">+MYe true</code></strong> - Enables <code class="inline">sys_alloc</code>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p><code class="inline">sys_alloc</code> cannot be disabled.</p></section></li><li><p><strong><code class="inline" id="MYtt">+MYtt &lt;size&gt;</code></strong> - Trim threshold size (in kilobytes). This is the
maximum amount of free memory at the top of the heap (allocated by <code class="inline">sbrk</code>)
that is kept by <code class="inline">malloc</code> (not released to the operating system). When the
amount of free memory at the top of the heap exceeds the trim threshold,
<code class="inline">malloc</code> releases it (by calling <code class="inline">sbrk</code>). Trim threshold is specified in
kilobytes. Defaults to <code class="inline">128</code>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>This flag has effect only when the emulator is linked with the GNU C
library, and uses its <code class="inline">malloc</code> implementation.</p></section></li><li><p><strong><code class="inline" id="MYtp">+MYtp &lt;size&gt;</code></strong> - Top pad size (in kilobytes). This is the amount
of extra memory that is allocated by <code class="inline">malloc</code> when <code class="inline">sbrk</code> is called to get
more memory from the operating system. Defaults to <code class="inline">0</code>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>This flag has effect only when the emulator is linked with the GNU C
library, and uses its <code class="inline">malloc</code> implementation.</p></section></li></ul><h3 id="flags-for-configuration-of-allocators-based-on-alloc_util" class="section-heading"><a href="#flags-for-configuration-of-allocators-based-on-alloc_util" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Flags for Configuration of Allocators Based on alloc_util</span></h3><p>If <code class="inline">u</code> is used as subsystem identifier (that is, <code class="inline">&lt;S&gt; = u</code>), all allocators
based on <code class="inline">alloc_util</code> are effected. If <code class="inline">B</code>, <code class="inline">D</code>, <code class="inline">E</code>, <code class="inline">F</code>, <code class="inline">H</code>, <code class="inline">I</code>, <code class="inline">L</code>, <code class="inline">R</code>,
<code class="inline">S</code>, <code class="inline">T</code>, <code class="inline">X</code> is used as subsystem identifier, only the specific allocator
identifier is effected.</p><ul><li><p><strong><code class="inline" id="M_acul">+M&lt;S&gt;acul &lt;utilization&gt;|de</code></strong> - Abandon carrier utilization
limit. A valid <code class="inline">&lt;utilization&gt;</code> is an integer in the range <code class="inline">[0, 100]</code>
representing utilization in percent. When a utilization value &gt; 0 is used,
allocator instances are allowed to abandon multiblock carriers. If <code class="inline">de</code>
(default enabled) is passed instead of a <code class="inline">&lt;utilization&gt;</code>, a recommended
non-zero utilization value is used. The value chosen depends on the allocator
type and can be changed between ERTS versions. Defaults to <code class="inline">de</code>, but this can
be changed in the future.</p><p>Carriers are abandoned when memory utilization in the allocator instance falls
below the utilization value used. Once a carrier is abandoned, no new
allocations are made in it. When an allocator instance gets an increased
multiblock carrier need, it first tries to fetch an abandoned carrier from
another allocator instance. If no abandoned carrier can be fetched, it creates
a new empty carrier. When an abandoned carrier has been fetched, it will
function as an ordinary carrier. This feature has special requirements on the
<a href="erts_alloc.html#M_as">allocation strategy</a> used. Only the strategies <code class="inline">aoff</code>,
<code class="inline">aoffcbf</code>, <code class="inline">aoffcaobf</code>, <code class="inline">ageffcaoff</code>m, <code class="inline">ageffcbf</code> and <code class="inline">ageffcaobf</code> support
abandoned carriers.</p><p>This feature also requires
<a href="erts_alloc.html#M_t">multiple thread specific instances</a> to be enabled. When
enabling this feature, multiple thread-specific instances are enabled if not
already enabled, and the <code class="inline">aoffcbf</code> strategy is enabled if the current strategy
does not support abandoned carriers. This feature can be enabled on all
allocators based on the <code class="inline">alloc_util</code> framework, except <code class="inline">temp_alloc</code> (which
would be pointless).</p></li><li><p><strong><code class="inline" id="M_acfml">+M&lt;S&gt;acfml &lt;bytes&gt;</code></strong> - Abandon carrier free block min limit.
A valid <code class="inline">&lt;bytes&gt;</code> is a positive integer representing a block size limit. The
largest free block in a carrier must be at least <code class="inline">bytes</code> large, for the
carrier to be abandoned. The default is zero but can be changed in the future.</p><p>See also <a href="erts_alloc.html#M_acul"><code class="inline">acul</code></a>.</p></li><li><p><strong><code class="inline" id="M_acnl">+M&lt;S&gt;acnl &lt;amount&gt;</code></strong> - Abandon carrier number limit. A valid
<code class="inline">&lt;amount&gt;</code> is a positive integer representing max number of abandoned carriers
per allocator instance. Defaults to 1000 which will practically disable the
limit, but this can be changed in the future.</p><p>See also <a href="erts_alloc.html#M_acul"><code class="inline">acul</code></a>.</p></li><li><p><strong><code class="inline" id="M_acful">+M&lt;S&gt;acful &lt;utilization&gt;|de</code></strong> - Abandon carrier free
utilization limit. When the utilization of a carrier falls belows this limit
erts_alloc instructs the OS that unused memory in the carrier can be re-used
for allocation by other OS procesesses. On Unix this is done by calling
<code class="inline">madvise(..., ..., MADV_FREE)</code> on the unused memory region, on Windows it is
done by calling <code class="inline">VirtualAlloc(..., ..., MEM_RESET, PAGE_READWRITE)</code>. Defaults
to 0 which means that no memory will be marked as re-usable by the OS.</p><p>A valid <code class="inline">&lt;utilization&gt;</code> is an integer in the range <code class="inline">[0, 100]</code> representing
utilization in percent. If this value is larger than the <code class="inline">acul</code> limit it will
be lowered to the current <code class="inline">acul</code> limit. If <code class="inline">de</code> (default enabled) is passed
instead of a <code class="inline">&lt;utilization&gt;</code>, a recommended non-zero utilization value is
used. The value chosen depends on the allocator type and can be changed
between ERTS versions.</p><p>On Unix flag <a href="erts_alloc.html#Mumadtn"><code class="inline">+Mumadtn</code></a> may also be set to pass
<code class="inline">MADV_DONTNEED</code> instead of <code class="inline">MADV_FREE</code> as argument to <code class="inline">madvise()</code>.</p><p>See also <a href="erts_alloc.html#M_acul"><code class="inline">acul</code></a>.</p></li><li><p><strong><code class="inline" id="M_as">+M&lt;S&gt;as bf|aobf|aoff|aoffcbf|aoffcaobf|ageffcaoff|ageffcbf|ageffcaobf|gf|af</code></strong> - Allocation strategy. The following strategies are valid:</p><ul><li><code class="inline">bf</code> (best fit)</li><li><code class="inline">aobf</code> (address order best fit)</li><li><code class="inline">aoff</code> (address order first fit)</li><li><code class="inline">aoffcbf</code> (address order first fit carrier best fit)</li><li><code class="inline">aoffcaobf</code> (address order first fit carrier address order best fit)</li><li><code class="inline">ageffcaoff</code> (age order first fit carrier address order first fit)</li><li><code class="inline">ageffcbf</code> (age order first fit carrier best fit)</li><li><code class="inline">ageffcaobf</code> (age order first fit carrier address order best fit)</li><li><code class="inline">gf</code> (good fit)</li><li><code class="inline">af</code> (a fit)</li></ul><p>See the description of allocation strategies in section
<a href="erts_alloc.html#strategy">The alloc_util Framework</a>.</p></li><li><p><strong><code class="inline" id="M_asbcst">+M&lt;S&gt;asbcst &lt;size&gt;</code></strong> - Absolute singleblock carrier shrink
threshold (in kilobytes). When a block located in an <code class="inline">mseg_alloc</code> singleblock
carrier is shrunk, the carrier is left unchanged if the amount of unused
memory is less than this threshold, otherwise the carrier is shrunk. See also
<a href="erts_alloc.html#M_rsbcst"><code class="inline">rsbcst</code></a>.</p></li><li><p><strong><code class="inline" id="M_atags">+M&lt;S&gt;atags true|false</code></strong> - Adds a small tag to each allocated
block that contains basic information about what it is and who allocated it.
Use the <a href="../../apps/runtime_tools/instrument.html"><code class="inline">instrument</code></a> module to inspect this information.</p><p>The runtime overhead is two words per allocation when enabled. This may change
at any time in the future.</p><p>The default is <code class="inline">true</code> for <code class="inline">binary_alloc</code> and <code class="inline">driver_alloc</code>, and <code class="inline">false</code> for
the other allocator types.</p></li><li><p><strong><code class="inline" id="M_cp">+M&lt;S&gt;cp B|D|E|F|H||L|R|S|@|:</code></strong> - Set carrier pool to use for the
allocator. Memory carriers will only migrate between allocator instances that
use the same carrier pool. The following carrier pool names exist:</p><ul><li><p><strong><code class="inline">B</code></strong> - Carrier pool associated with <code class="inline">binary_alloc</code>.</p></li><li><p><strong><code class="inline">D</code></strong> - Carrier pool associated with <code class="inline">std_alloc</code>.</p></li><li><p><strong><code class="inline">E</code></strong> - Carrier pool associated with <code class="inline">ets_alloc</code>.</p></li><li><p><strong><code class="inline">F</code></strong> - Carrier pool associated with <code class="inline">fix_alloc</code>.</p></li><li><p><strong><code class="inline">H</code></strong> - Carrier pool associated with <code class="inline">eheap_alloc</code>.</p></li><li><p><strong><code class="inline">L</code></strong> - Carrier pool associated with <code class="inline">ll_alloc</code>.</p></li><li><p><strong><code class="inline">R</code></strong> - Carrier pool associated with <code class="inline">driver_alloc</code>.</p></li><li><p><strong><code class="inline">S</code></strong> - Carrier pool associated with <code class="inline">sl_alloc</code>.</p></li><li><p><strong><code class="inline">@</code></strong> - Carrier pool associated with the system as a whole.</p></li></ul><p>Besides passing carrier pool name as value to the parameter, you can also pass
<code class="inline">:</code>. By passing <code class="inline">:</code> instead of carrier pool name, the allocator will use the
carrier pool associated with itself. By passing the command line argument
&quot;<code class="inline">+Mucp :</code>&quot;, all allocators that have an associated carrier pool will use the
carrier pool associated with themselves.</p><p>The association between carrier pool and allocator is very loose. The
associations are more or less only there to get names for the amount of
carrier pools needed and names of carrier pools that can be easily identified
by the <code class="inline">:</code> value.</p><p>This flag is only valid for allocators that have an associated carrier pool.
Besides that, there are no restrictions on carrier pools to use for an
allocator.</p><p>Currently each allocator with an associated carrier pool defaults to using its
own associated carrier pool.</p></li><li><p><strong><code class="inline" id="M_e">+M&lt;S&gt;e true|false</code></strong> - Enables allocator <code class="inline">&lt;S&gt;</code>.</p></li><li><p><strong><code class="inline" id="M_lmbcs">+M&lt;S&gt;lmbcs &lt;size&gt;</code></strong> - Largest (<code class="inline">mseg_alloc</code>) multiblock
carrier size (in kilobytes). See the description on how sizes for <code class="inline">mseg_alloc</code>
multiblock carriers are decided in section
<a href="erts_alloc.html#mseg_mbc_sizes">The alloc_util Framework</a>. On 32-bit Unix style
OS this limit cannot be set &gt; 64 MB.</p></li><li><p><strong><code class="inline" id="M_mbcgs">+M&lt;S&gt;mbcgs &lt;ratio&gt;</code></strong> - (<code class="inline">mseg_alloc</code>) multiblock carrier
growth stages. See the description on how sizes for <code class="inline">mseg_alloc</code> multiblock
carriers are decided in section
<a href="erts_alloc.html#mseg_mbc_sizes">The alloc_util Framework</a>.</p></li><li><p><strong><code class="inline" id="M_mbsd">+M&lt;S&gt;mbsd &lt;depth&gt;</code></strong> - Maximum block search depth. This flag
has effect only if the good fit strategy is selected for allocator <code class="inline">&lt;S&gt;</code>. When
the good fit strategy is used, free blocks are placed in segregated
free-lists. Each free-list contains blocks of sizes in a specific range. The
maximum block search depth sets a limit on the maximum number of blocks to
inspect in a free-list during a search for suitable block satisfying the
request.</p></li><li><p><strong><code class="inline" id="M_mmbcs">+M&lt;S&gt;mmbcs &lt;size&gt;</code></strong> - Main multiblock carrier size. Sets the
size of the main multiblock carrier for allocator <code class="inline">&lt;S&gt;</code>. The main multiblock
carrier is allocated through <code class="inline">sys_alloc</code> and is never deallocated.</p></li><li><p><strong><code class="inline" id="M_mmmbc">+M&lt;S&gt;mmmbc &lt;amount&gt;</code></strong> - Maximum <code class="inline">mseg_alloc</code> multiblock
carriers. Maximum number of multiblock carriers allocated through <code class="inline">mseg_alloc</code>
by allocator <code class="inline">&lt;S&gt;</code>. When this limit is reached, new multiblock carriers are
allocated through <code class="inline">sys_alloc</code>.</p></li><li><p><strong><code class="inline" id="M_mmsbc">+M&lt;S&gt;mmsbc &lt;amount&gt;</code></strong> - Maximum <code class="inline">mseg_alloc</code> singleblock
carriers. Maximum number of singleblock carriers allocated through
<code class="inline">mseg_alloc</code> by allocator <code class="inline">&lt;S&gt;</code>. When this limit is reached, new singleblock
carriers are allocated through <code class="inline">sys_alloc</code>.</p></li><li><p><strong><code class="inline" id="M_ramv">+M&lt;S&gt;ramv &lt;bool&gt;</code></strong> - Realloc always moves. When enabled,
reallocate operations are more or less translated into an allocate, copy, free
sequence. This often reduces memory fragmentation, but costs performance.</p></li><li><p><strong><code class="inline" id="M_rmbcmt">+M&lt;S&gt;rmbcmt &lt;ratio&gt;</code></strong> - Relative multiblock carrier move
threshold (in percent). When a block located in a multiblock carrier is
shrunk, the block is moved if the ratio of the size of the freed memory
compared to the previous size is more than this threshold, otherwise the block
is shrunk at the current location.</p></li><li><p><strong><code class="inline" id="M_rsbcmt">+M&lt;S&gt;rsbcmt &lt;ratio&gt;</code></strong> - Relative singleblock carrier move
threshold (in percent). When a block located in a singleblock carrier is
shrunk to a size smaller than the value of parameter
<a href="erts_alloc.html#M_sbct"><code class="inline">sbct</code></a>, the block is left unchanged in the singleblock
carrier if the ratio of unused memory is less than this threshold, otherwise
it is moved into a multiblock carrier.</p></li><li><p><strong><code class="inline" id="M_rsbcst">+M&lt;S&gt;rsbcst &lt;ratio&gt;</code></strong> - Relative singleblock carrier shrink
threshold (in percent). When a block located in an <code class="inline">mseg_alloc</code> singleblock
carrier is shrunk, the carrier is left unchanged if the ratio of unused memory
is less than this threshold, otherwise the carrier is shrunk. See also
<a href="erts_alloc.html#M_asbcst"><code class="inline">asbcst</code></a>.</p></li><li><p><strong><code class="inline" id="M_sbct">+M&lt;S&gt;sbct &lt;size&gt;</code></strong> - Singleblock carrier threshold (in
kilobytes). Blocks larger than this threshold are placed in singleblock
carriers. Blocks smaller than this threshold are placed in multiblock
carriers. On 32-bit Unix style OS this threshold cannot be set &gt; 8 MB.</p></li><li><p><strong><code class="inline" id="M_smbcs">+M&lt;S&gt;smbcs &lt;size&gt;</code></strong> - Smallest (<code class="inline">mseg_alloc</code>) multiblock
carrier size (in kilobytes). See the description on how sizes for <code class="inline">mseg_alloc</code>
multiblock carriers are decided in section
<a href="erts_alloc.html#mseg_mbc_sizes">The alloc_util Framework</a>.</p></li><li><p><strong><code class="inline" id="M_t">+M&lt;S&gt;t true|false</code></strong> - Multiple, thread-specific instances of the
allocator. Default behavior is <code class="inline">NoSchedulers+1</code> instances. Each scheduler uses
a lock-free instance of its own and other threads use a common instance.</p><p>Before ERTS 5.9 it was possible to configure a smaller number of
thread-specific instances than schedulers. This is, however, not possible
anymore.</p></li></ul><h3 id="flags-for-configuration-of-alloc_util" class="section-heading"><a href="#flags-for-configuration-of-alloc_util" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Flags for Configuration of alloc_util</span></h3><p>All allocators based on <code class="inline">alloc_util</code> are effected.</p><ul><li><p><strong><code class="inline" id="Muycs">+Muycs &lt;size&gt;</code></strong> - <code class="inline">sys_alloc</code> carrier size. Carriers allocated
through <code class="inline">sys_alloc</code> are allocated in sizes that are multiples of the
<code class="inline">sys_alloc</code> carrier size. This is not true for main multiblock carriers and
carriers allocated during a memory shortage, though.</p></li><li><p><strong><code class="inline" id="Mummc">+Mummc &lt;amount&gt;</code></strong> - Maximum <code class="inline">mseg_alloc</code> carriers. Maximum
number of carriers placed in separate memory segments. When this limit is
reached, new carriers are placed in memory retrieved from <code class="inline">sys_alloc</code>.</p></li><li><p><strong><code class="inline" id="Musac">+Musac &lt;bool&gt;</code></strong> - Allow <code class="inline">sys_alloc</code> carriers. Defaults to
<code class="inline">true</code>. If set to <code class="inline">false</code>, <code class="inline">sys_alloc</code> carriers are never created by
allocators using the <code class="inline">alloc_util</code> framework.</p></li><li><p><strong><code class="inline" id="Mumadtn">+Mumadtn &lt;bool&gt;</code></strong> - Control how to mark memory as re-usable
on Unix when <a href="erts_alloc.html#M_acful"><code class="inline">+M&lt;S&gt;acful</code></a> is set. Default is <code class="inline">false</code>
which means <code class="inline">MADV_FREE</code> is passed to <code class="inline">madvise()</code>. If set to <code class="inline">true</code>,
<code class="inline">MADV_DONTNEED</code> is passed instead.</p></li></ul><h3 id="special-flag-for-literal_alloc" class="section-heading"><a href="#special-flag-for-literal_alloc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Special Flag for literal_alloc</span></h3><ul><li><strong><code class="inline" id="MIscs">+MIscs &lt;size in MB&gt;</code></strong> - <code class="inline">literal_alloc</code> super carrier size (in
MB). The amount of <em>virtual</em> address space reserved for literal terms in
Erlang code on 64-bit architectures. Defaults to <code class="inline">1024</code> (that is, 1 GB), which
is usually sufficient. The flag is ignored on 32-bit architectures.</li></ul><h3 id="instrumentation-flags" class="section-heading"><a href="#instrumentation-flags" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Instrumentation Flags</span></h3><ul><li><strong><code class="inline">+M&lt;S&gt;atags</code></strong> - Adds a small tag to each allocated block that contains
basic information about what it is and who allocated it. See
<a href="erts_alloc.html#M_atags"><code class="inline">+M&lt;S&gt;atags</code></a> for a more complete description.</li></ul><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>When instrumentation of the emulator is enabled, the emulator uses more memory
and runs slower.</p></section><h3 id="other-flags" class="section-heading"><a href="#other-flags" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Other Flags</span></h3><ul><li><p><strong><code class="inline" id="Mea">+Mea min|max|r9c|r10b|r11b|config</code></strong> - Options:</p><ul><li><p><strong><code class="inline">min</code></strong> - Disables all allocators that can be disabled.</p></li><li><p><strong><code class="inline">max</code></strong> - Enables all allocators (default).</p></li><li><p><strong><code class="inline">r9c|r10b|r11b</code></strong> - Configures all allocators as they were configured in
respective Erlang/OTP release. These will eventually be removed.</p></li></ul></li><li><p><strong><code class="inline" id="Mlpm">+Mlpm all|no</code></strong> - Lock physical memory. Defaults to <code class="inline">no</code>, that
is, no physical memory is locked. If set to <code class="inline">all</code>, all memory mappings made by
the runtime system are locked into physical memory. If set to <code class="inline">all</code>, the
runtime system fails to start if this feature is not supported, the user has
not got enough privileges, or the user is not allowed to lock enough physical
memory. The runtime system also fails with an out of memory condition if the
user limit on the amount of locked memory is reached.</p></li><li><p><strong><code class="inline" id="Mdai">+Mdai max|&lt;amount&gt;</code></strong> - Set amount of dirty allocator instances
used. Defaults to <code class="inline">0</code>. That is, by default no instances will be used. The
maximum amount of instances equals the amount of dirty CPU schedulers on the
system.</p><p>By default, each normal scheduler thread has its own allocator instance for
each allocator. All other threads in the system, including dirty schedulers,
share one instance for each allocator. By enabling dirty allocator instances,
dirty schedulers will get and use their own set of allocator instances. Note
that these instances are not exclusive to each dirty scheduler, but instead
shared among dirty schedulers. The more instances used the less risk of lock
contention on these allocator instances. Memory consumption do however
increase with increased amount of dirty allocator instances.</p></li></ul><h2 id="notes" class="section-heading"><a href="#notes" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Notes</span></h2><p>Only some default values have been presented here. For information about the
currently used settings and the current status of the allocators, see
<a href="erlang.html#system_info_allocator"><code class="inline">erlang:system_info(allocator)</code></a> and
<a href="erlang.html#system_info_allocator_tuple"><code class="inline">erlang:system_info({allocator, Alloc})</code></a>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Most of these flags are highly implementation-dependent and can be changed or
removed without prior notice.</p><p><code class="inline">erts_alloc</code> is not obliged to strictly use the settings that have been passed
to it (it can even ignore them).</p></section><h2 id="see-also" class="section-heading"><a href="#see-also" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">See Also</span></h2><p><a href="erl_cmd.html"><code class="inline">erl(1)</code></a>, <a href="erlang.html"><code class="inline">erlang</code></a>, <a href="../../apps/runtime_tools/instrument.html"><code class="inline">instrument</code></a></p>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="erl_nif.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
erl_nif
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="automaticyieldingofccode.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Automatic Yielding of C Code
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.38.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright © 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
