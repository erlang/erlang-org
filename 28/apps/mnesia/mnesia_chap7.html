<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.38.1">
    <meta name="project" content="mnesia v4.24">


<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=28&q=">
<meta name="major-vsn" content="28">
<link rel="canonical" href="https://www.erlang.org/doc/apps/mnesia/mnesia_chap7.html" />
    <title>Mnesia System Information — mnesia v4.24</title>

    <link rel="stylesheet" href="dist/html-erlang-ZK43ZOAC.css" />

    <script defer src="dist/sidebar_items-CA522193.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-DPJLHKSM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="mnesia" />
        </a>

      <div>
        <a href="../../index.html" class="sidebar-projectName" translate="no">
mnesia
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v4.24
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of mnesia</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>Mnesia System Information</h1>


      <a href="https://github.com/erlang/otp/blob/OTP-28.0.1/lib/mnesia/doc/guides/mnesia_chap7.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<p>The following topics are included:</p><ul><li>Database configuration data</li><li>Core dumps</li><li>Dumping tables</li><li>Checkpoints</li><li>Startup files, log file, and data files</li><li>Loading tables at startup</li><li>Recovery from communication failure</li><li>Recovery of transactions</li><li>Backup, restore, fallback, and disaster recovery</li></ul><h2 id="database-configuration-data" class="section-heading"><a href="#database-configuration-data" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Database Configuration Data</span></h2><p>The following two functions can be used to retrieve system information. For
details, see the Reference Manual.</p><ul><li><p><a href="mnesia.html#table_info/2"><code class="inline">mnesia:table_info(Tab, Key) -&gt; Info | exit({aborted, Reason})</code></a>
returns information about one table, for example, the current size of the
table and on which nodes it resides.</p></li><li><p><a href="mnesia.html#system_info/1"><code class="inline">mnesia:system_info(Key) -&gt; Info | exit({aborted, Reason})</code></a>
returns information about the <code class="inline">Mnesia</code> system, for example, transaction
statistics, <code class="inline">db_nodes</code>, and configuration parameters.</p></li></ul><h2 id="core-dumps" class="section-heading"><a href="#core-dumps" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Core Dumps</span></h2><p>If <code class="inline">Mnesia</code> malfunctions, system information is dumped to file
<code class="inline">MnesiaCore.Node.When</code>. The type of system information contained in this file
can also be generated with the function <code class="inline">mnesia_lib:coredump()</code>. If a <code class="inline">Mnesia</code>
system behaves strangely, it is recommended that a <code class="inline">Mnesia</code> core dump file is
included in the bug report.</p><h2 id="dumping-tables" class="section-heading"><a href="#dumping-tables" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Dumping Tables</span></h2><p>Tables of type <code class="inline">ram_copies</code> are by definition stored in memory only. However,
these tables can be dumped to disc, either at regular intervals or before the
system is shut down. The function
<a href="mnesia.html#dump_tables/1"><code class="inline">mnesia:dump_tables(TabList)</code></a> dumps all replicas of a
set of RAM tables to disc. The tables can be accessed while being dumped to
disc. To dump the tables to disc, all replicas must have the storage type
<code class="inline">ram_copies</code>.</p><p>The table content is placed in a <code class="inline">.DCD</code> file on the disc. When the <code class="inline">Mnesia</code>
system is started, the RAM table is initially loaded with data from its <code class="inline">.DCD</code>
file.</p><h2 id="checkpoints" class="section-heading"><a href="#checkpoints" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Checkpoints</span></h2><p>A checkpoint is a transaction consistent state that spans over one or more
tables. When a checkpoint is activated, the system remembers the current content
of the set of tables. The checkpoint retains a transaction consistent state of
the tables, allowing the tables to be read and updated while the checkpoint is
active. A checkpoint is typically used to back up tables to external media, but
they are also used internally in <code class="inline">Mnesia</code> for other purposes. Each checkpoint is
independent and a table can be involved in several checkpoints simultaneously.</p><p>Each table retains its old contents in a checkpoint retainer. For performance
critical applications, it can be important to realize the processing overhead
associated with checkpoints. In a worst case scenario, the checkpoint retainer
consumes more memory than the table itself. Also, each update becomes slightly
slower on those nodes where checkpoint retainers are attached to the tables.</p><p>For each table, it is possible to choose if there is to be one checkpoint
retainer attached to all replicas of the table, or if it is enough to have only
one checkpoint retainer attached to a single replica. With a single checkpoint
retainer per table, the checkpoint consumes less memory, but it is vulnerable to
node crashes. With several redundant checkpoint retainers, the checkpoint
survives as long as there is at least one active checkpoint retainer attached to
each table.</p><p>Checkpoints can be explicitly deactivated with the function
<a href="mnesia.html#deactivate_checkpoint/1"><code class="inline">mnesia:deactivate_checkpoint(Name)</code></a>, where
<code class="inline">Name</code> is the name of an active checkpoint. This function returns <code class="inline">ok</code> if
successful or <code class="inline">{error, Reason}</code> if there is an error. All tables in a checkpoint
must be attached to at least one checkpoint retainer. The checkpoint is
automatically deactivated by <code class="inline">Mnesia</code>, when any table lacks a checkpoint
retainer. This can occur when a node goes down or when a replica is deleted. Use
arguments <code class="inline">min</code> and <code class="inline">max</code> (described in the following list) to control the
degree of checkpoint retainer redundancy.</p><p><a href="" id="mnesia%3Achkpt%28Args%29"></a></p><p>Checkpoints are activated with the function
<a href="mnesia.html#activate_checkpoint/1"><code class="inline">mnesia:activate_checkpoint(Args)</code></a>, where <code class="inline">Args</code>
is a list of the following tuples:</p><ul><li><code class="inline">{name, Name}</code>, where <code class="inline">Name</code> specifies a temporary name of the checkpoint. The
name can be reused when the checkpoint has been deactivated. If no name is
specified, a name is generated automatically.</li><li><code class="inline">{max, MaxTabs}</code>, where <code class="inline">MaxTabs</code> is a list of tables that are to be included
in the checkpoint. Default is <code class="inline">[]</code> (empty list). For these tables, the
redundancy is maximized. The old content of the table is retained in the
checkpoint retainer when the main table is updated by the applications. The
checkpoint is more fault tolerant if the tables have several replicas. When
new replicas are added by the schema manipulation function
<a href="mnesia.html#add_table_copy/3"><code class="inline">mnesia:add_table_copy/3</code></a> it also attaches a local checkpoint retainer.</li><li><code class="inline">{min, MinTabs}</code>, where <code class="inline">MinTabs</code> is a list of tables that are to be included
in the checkpoint. Default is <code class="inline">[]</code>. For these tables, the redundancy is
minimized, and there is to be single checkpoint retainer per table, preferably
at the local node.</li><li><code class="inline">{allow_remote, Bool}</code>, where <code class="inline">false</code> means that all checkpoint retainers must
be local. If a table does not reside locally, the checkpoint cannot be
activated. <code class="inline">true</code> allows checkpoint retainers to be allocated on any node.
Default is <code class="inline">true</code>.</li><li><code class="inline">{ram_overrides_dump, Bool}</code>. This argument only applies to tables of type
<code class="inline">ram_copies</code>. <code class="inline">Bool</code> specifies if the table state in RAM is to override the
table state on disc. <code class="inline">true</code> means that the latest committed records in RAM are
included in the checkpoint retainer. These are the records that the
application accesses. <code class="inline">false</code> means that the records on the disc <code class="inline">.DAT</code> file
are included in the checkpoint retainer. These records are loaded on startup.
Default is <code class="inline">false</code>.</li></ul><p>The function <a href="mnesia.html#activate_checkpoint/1"><code class="inline">mnesia:activate_checkpoint(Args)</code></a>
returns one of the following values:</p><ul><li><code class="inline">{ok, Name, Nodes}</code></li><li><code class="inline">{error, Reason}</code></li></ul><p><code class="inline">Name</code> is the checkpoint name. <code class="inline">Nodes</code> are the nodes where the checkpoint is
known.</p><p>A list of active checkpoints can be obtained with the following functions:</p><ul><li><a href="mnesia.html#system_info/1"><code class="inline">mnesia:system_info(checkpoints)</code></a> returns all active
checkpoints on the current node.</li><li><a href="mnesia.html#table_info/2"><code class="inline">mnesia:table_info(Tab, checkpoints)</code></a> returns active
checkpoints on a specific table.</li></ul><h2 id="startup-files-log-file-and-data-files" class="section-heading"><a href="#startup-files-log-file-and-data-files" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Startup Files, Log File, and Data Files</span></h2><p>This section describes the internal files that are created and maintained by the
<code class="inline">Mnesia</code> system. In particular, the workings of the <code class="inline">Mnesia</code> log are described.</p><h3 id="startup-files" class="section-heading"><a href="#startup-files" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Startup Files</span></h3><p><a href="mnesia_chap3.html#start_mnesia">Start Mnesia</a> states the following prerequisites
for starting <code class="inline">Mnesia</code>:</p><ul><li>An Erlang session must be started and a <code class="inline">Mnesia</code> directory must be specified
for the database.</li><li>A database schema must be initiated, using the function
<a href="mnesia.html#create_schema/1"><code class="inline">mnesia:create_schema/1</code></a>.</li></ul><p>The following example shows how these tasks are performed:</p><p><em>Step 1:</em> Start an Erlang session and specify a <code class="inline">Mnesia</code> directory for the
database:</p><pre><code class="text">% erl -sname klacke -mnesia dir '&quot;/ldisc/scratch/klacke&quot;'</code></pre><pre><code class="makeup erlang" translate="no"><span class="n">Erlang</span><span class="o">/</span><span class="n">OTP</span><span class="w"> </span><span class="mi">27</span><span class="w"> </span><span class="p" data-group-id="0310807932-1">[</span><span class="ss">erts</span><span class="o">-</span><span class="mf">15.1</span><span class="p">.</span><span class="mi">2</span><span class="p" data-group-id="0310807932-1">]</span><span class="w">

</span><span class="n">Eshell</span><span class="w"> </span><span class="n">V15</span><span class="p">.</span><span class="mf">1.2</span><span class="w"> </span><span class="p" data-group-id="0310807932-2">(</span><span class="ss">press</span><span class="w"> </span><span class="n">Ctrl</span><span class="o">+</span><span class="n">G</span><span class="w"> </span><span class="ss">to</span><span class="w"> </span><span class="ss">abort</span><span class="p">,</span><span class="w"> </span><span class="ss">type</span><span class="w"> </span><span class="nf">help</span><span class="p" data-group-id="0310807932-3">(</span><span class="p" data-group-id="0310807932-3">)</span><span class="p">.</span><span class="w"> </span><span class="ss">for</span><span class="w"> </span><span class="ss">help</span><span class="p" data-group-id="0310807932-2">)</span><span class="gp unselectable">
(klacke@gin)1&gt; </span><span class="nc">mnesia</span><span class="p">:</span><span class="nf">create_schema</span><span class="p" data-group-id="0310807932-4">(</span><span class="p" data-group-id="0310807932-5">[</span><span class="nf">node</span><span class="p" data-group-id="0310807932-6">(</span><span class="p" data-group-id="0310807932-6">)</span><span class="p" data-group-id="0310807932-5">]</span><span class="p" data-group-id="0310807932-4">)</span><span class="p">.</span><span class="w">
</span><span class="nf">ok</span><span class="w">
</span><span class="p" data-group-id="0310807932-7">(</span><span class="ss">klacke@gin</span><span class="p" data-group-id="0310807932-7">)</span><span class="mi">2</span><span class="o">&gt;</span><span class="w">
</span><span class="n">Ctrl</span><span class="o">+</span><span class="n">Z</span><span class="w">
</span><span class="p" data-group-id="0310807932-8">[</span><span class="mi">1</span><span class="p" data-group-id="0310807932-8">]</span><span class="o">+</span><span class="w">  </span><span class="n">Stopped</span><span class="w">                 </span><span class="ss">erl</span></code></pre><p><em>Step 2:</em> You can inspect the <code class="inline">Mnesia</code> directory to see what files have been
created:</p><pre><code class="text">% ls -l /ldisc/scratch/klacke
-rw-rw-r--   1 klacke   staff       247 Aug 12 15:06 FALLBACK.BUP</code></pre><p>The response shows that the file <code class="inline">FALLBACK.BUP</code> has been created. This is called
a backup file, and it contains an initial schema. If more than one node in the
function <a href="mnesia.html#create_schema/1"><code class="inline">mnesia:create_schema/1</code></a> had been specified, identical backup files
would have been created on all nodes.</p><p><em>Step 3:</em> Start <code class="inline">Mnesia</code>:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">(klacke@gin)3&gt; </span><span class="nc">mnesia</span><span class="p">:</span><span class="nf">start</span><span class="p" data-group-id="5018187314-1">(</span><span class="p" data-group-id="5018187314-1">)</span><span class="p">.</span><span class="w">
</span><span class="ss">ok</span></code></pre><p><em>Step 4:</em> You can see the following listing in the <code class="inline">Mnesia</code> directory:</p><pre><code class="text">-rw-rw-r--   1 klacke   staff         86 May 26 19:03 LATEST.LOG
-rw-rw-r--   1 klacke   staff      34507 May 26 19:03 schema.DAT</code></pre><p>The schema in the backup file <code class="inline">FALLBACK.BUP</code> has been used to generate the file
<code class="inline">schema.DAT</code>. Since there are no other disc resident tables than the schema, no
other data files were created. The file <code class="inline">FALLBACK.BUP</code> was removed after the
successful &quot;restoration&quot;. You also see some files that are for internal use by
<code class="inline">Mnesia</code>.</p><p><em>Step 5:</em> Create a table:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">(klacke@gin)4&gt; </span><span class="nc">mnesia</span><span class="p">:</span><span class="nf">create_table</span><span class="p" data-group-id="8043057583-1">(</span><span class="ss">foo</span><span class="p">,</span><span class="p" data-group-id="8043057583-2">[</span><span class="p" data-group-id="8043057583-3">{</span><span class="ss">disc_copies</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8043057583-4">[</span><span class="nf">node</span><span class="p" data-group-id="8043057583-5">(</span><span class="p" data-group-id="8043057583-5">)</span><span class="p" data-group-id="8043057583-4">]</span><span class="p" data-group-id="8043057583-3">}</span><span class="p" data-group-id="8043057583-2">]</span><span class="p" data-group-id="8043057583-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8043057583-6">{</span><span class="ss">atomic</span><span class="p">,</span><span class="ss">ok</span><span class="p" data-group-id="8043057583-6">}</span></code></pre><p><em>Step 6:</em> You can see the following listing in the <code class="inline">Mnesia</code> directory:</p><pre><code class="text">% ls -l /ldisc/scratch/klacke
-rw-rw-r-- 1 klacke staff    86 May 26 19:07 LATEST.LOG
-rw-rw-r-- 1 klacke staff    94 May 26 19:07 foo.DCD
-rw-rw-r-- 1 klacke staff  6679 May 26 19:07 schema.DAT</code></pre><p>The file <code class="inline">foo.DCD</code> has been created. This file will eventually store all data
that is written into the <code class="inline">foo</code> table.</p><h3 id="log-file" class="section-heading"><a href="#log-file" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Log File</span></h3><p>When starting <code class="inline">Mnesia</code>, a <code class="inline">.LOG</code> file called <code class="inline">LATEST.LOG</code> is created and placed
in the database directory. This file is used by <code class="inline">Mnesia</code> to log disc-based
transactions. This includes all transactions that write at least one record in a
table that is of storage type <code class="inline">disc_copies</code> or <code class="inline">disc_only_copies</code>. The file also
includes all operations that manipulate the schema itself, such as creating new
tables. The log format can vary with different implementations of <code class="inline">Mnesia</code>. The
<code class="inline">Mnesia</code> log is currently implemented in the standard library module
<a href="../../apps/kernel/disk_log.html"><code class="inline">disk_log</code></a> in <code class="inline">Kernel</code>.</p><p>The log file grows continuously and must be dumped at regular intervals.
&quot;Dumping the log file&quot; means that <code class="inline">Mnesia</code> performs all the operations listed in
the log and place the records in the corresponding <code class="inline">.DAT</code>, <code class="inline">.DCD</code>, and <code class="inline">.DCL</code>
data files. For example, if the operation &quot;write record <code class="inline">{foo, 4, elvis, 6}</code>&quot; is
listed in the log, <code class="inline">Mnesia</code> inserts the operation into the file <code class="inline">foo.DCL</code>.
Later, when <code class="inline">Mnesia</code> thinks that the <code class="inline">.DCL</code> file is too large, the data is moved
to the <code class="inline">.DCD</code> file. The dumping operation can be time consuming if the log is
large. Notice that the <code class="inline">Mnesia</code> system continues to operate during log dumps.</p><p>By default <code class="inline">Mnesia</code> either dumps the log whenever 1000 records have been written
in the log or when three minutes have passed. This is controlled by the two
application parameters <code class="inline">-mnesia dump_log_write_threshold WriteOperations</code> and
<code class="inline">-mnesia dump_log_time_threshold MilliSecs</code>.</p><p>Before the log is dumped, the file <code class="inline">LATEST.LOG</code> is renamed to <code class="inline">PREVIOUS.LOG</code>,
and a new <code class="inline">LATEST.LOG</code> file is created. Once the log has been successfully
dumped, the file <code class="inline">PREVIOUS.LOG</code> is deleted.</p><p>The log is also dumped at startup and whenever a schema operation is performed.</p><h3 id="data-files" class="section-heading"><a href="#data-files" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Data Files</span></h3><p>The directory listing also contains one <code class="inline">.DAT</code> file, which contains the schema
itself, contained in the <code class="inline">schema.DAT</code> file. The <code class="inline">DAT</code> files are indexed files,
and it is efficient to insert and search for records in these files with a
specific key. The <code class="inline">.DAT</code> files are used for the schema and for
<code class="inline">disc_only_copies</code> tables. The <code class="inline">Mnesia</code> data files are currently implemented in
the standard library module <a href="../../apps/stdlib/dets.html"><code class="inline">dets</code></a> in <code class="inline">STDLIB</code>.</p><p>All operations that can be performed on <code class="inline">dets</code> files can also be performed on
the <code class="inline">Mnesia</code> data files. For example, <code class="inline">dets</code> contains the function
<a href="../../apps/stdlib/dets.html#traverse/2"><code class="inline">dets:traverse/2</code></a>, which can be used to view the contents of a <code class="inline">Mnesia</code> <code class="inline">DAT</code>
file. However, this can only be done when <code class="inline">Mnesia</code> is not running. So, to view
the schema file, do as follows;</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="1705075437-1">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p" data-group-id="1705075437-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">dets</span><span class="p">:</span><span class="nf">open_file</span><span class="p" data-group-id="1705075437-2">(</span><span class="ss">schema</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1705075437-3">[</span><span class="p" data-group-id="1705075437-4">{</span><span class="ss">file</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;./schema.DAT&quot;</span><span class="p" data-group-id="1705075437-4">}</span><span class="p">,</span><span class="p" data-group-id="1705075437-5">{</span><span class="ss">repair</span><span class="p">,</span><span class="ss">false</span><span class="p" data-group-id="1705075437-5">}</span><span class="p">,</span><span class="w">
</span><span class="p" data-group-id="1705075437-6">{</span><span class="ss">keypos</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="1705075437-6">}</span><span class="p" data-group-id="1705075437-3">]</span><span class="p" data-group-id="1705075437-2">)</span><span class="p">,</span><span class="w">
</span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">fun</span><span class="p" data-group-id="1705075437-7">(</span><span class="n">X</span><span class="p" data-group-id="1705075437-7">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">io</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="1705075437-8">(</span><span class="s">&quot;</span><span class="si">~p</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1705075437-9">[</span><span class="n">X</span><span class="p" data-group-id="1705075437-9">]</span><span class="p" data-group-id="1705075437-8">)</span><span class="p">,</span><span class="w"> </span><span class="ss">continue</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w">
</span><span class="nc">dets</span><span class="p">:</span><span class="nf">traverse</span><span class="p" data-group-id="1705075437-10">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p" data-group-id="1705075437-10">)</span><span class="p">,</span><span class="w">
</span><span class="nc">dets</span><span class="p">:</span><span class="nf">close</span><span class="p" data-group-id="1705075437-11">(</span><span class="n">N</span><span class="p" data-group-id="1705075437-11">)</span><span class="p">.</span></code></pre><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>The <code class="inline">DAT</code> files must always be opened with option <code class="inline">{repair, false}</code>. This
ensures that these files are not automatically repaired. Without this option,
the database can become inconsistent, because <code class="inline">Mnesia</code> can believe that the
files were properly closed. For information about configuration parameter
<code class="inline">auto_repair</code>, see the Reference Manual.</p></section><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>It is recommended that the data files are not tampered with while <code class="inline">Mnesia</code> is
running. While not prohibited, the behavior of <code class="inline">Mnesia</code> is unpredictable.</p></section><p>The <code class="inline">disc_copies</code> tables are stored on disk with <code class="inline">.DCL</code> and <code class="inline">.DCD</code> files, which
are standard <code class="inline">disk_log</code> files.</p><h2 id="loading-tables-at-startup" class="section-heading"><a href="#loading-tables-at-startup" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Loading Tables at Startup</span></h2><p>At startup, <code class="inline">Mnesia</code> loads tables to make them accessible for its applications.
Sometimes <code class="inline">Mnesia</code> decides to load all tables that reside locally, and sometimes
the tables are not accessible until <code class="inline">Mnesia</code> brings a copy of the table from
another node.</p><p>To understand the behavior of <code class="inline">Mnesia</code> at startup, it is essential to understand
how <code class="inline">Mnesia</code> reacts when it loses contact with <code class="inline">Mnesia</code> on another node. At this
stage, <code class="inline">Mnesia</code> cannot distinguish between a communication failure and a
&quot;normal&quot; node-down. When this occurs, <code class="inline">Mnesia</code> assumes that the other node is no
longer running, whereas, in reality, the communication between the nodes has
failed.</p><p>To overcome this situation, try to restart the ongoing transactions that are
accessing tables on the failing node, and write a <code class="inline">mnesia_down</code> entry to a log
file.</p><p>At startup, notice that all tables residing on nodes without a <code class="inline">mnesia_down</code>
entry can have fresher replicas. Their replicas can have been updated after the
termination of <code class="inline">Mnesia</code> on the current node. To catch up with the latest
updates, transfer a copy of the table from one of these other &quot;fresh&quot; nodes. If
you are unlucky, other nodes can be down and you must wait for the table to be
loaded on one of these nodes before receiving a fresh copy of the table.</p><p>Before an application makes its first access to a table,
<a href="mnesia.html#wait_for_tables/2"><code class="inline">mnesia:wait_for_tables(TabList, Timeout)</code></a> is to be
executed to ensure that the table is accessible from the local node. If the
function times out, the application can choose to force a load of the local
replica with <a href="mnesia.html#force_load_table/1"><code class="inline">mnesia:force_load_table(Tab)</code></a> and
deliberately lose all updates that can have been performed on the other nodes
while the local node was down. If <code class="inline">Mnesia</code> has loaded the table on another node
already, or intends to do so, copy the table from that node to avoid unnecessary
inconsistency.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>Only one table is loaded by
<a href="mnesia.html#force_load_table/1"><code class="inline">mnesia:force_load_table(Tab)</code></a>. Since committed
transactions can have caused updates in several tables, the tables can become
inconsistent because of the forced load.</p></section><p>The allowed <code class="inline">AccessMode</code> of a table can be defined to be <code class="inline">read_only</code> or
<code class="inline">read_write</code>. It can be toggled with the function
<a href="mnesia.html#change_table_access_mode/2"><code class="inline">mnesia:change_table_access_mode(Tab, AccessMode)</code></a>
in runtime. <code class="inline">read_only</code> tables and <code class="inline">local_content</code> tables are always loaded
locally, as there is no need for copying the table from other nodes. Other
tables are primarily loaded remotely from active replicas on other nodes if the
table has been loaded there already, or if the running <code class="inline">Mnesia</code> has decided to
load the table there already.</p><p>At startup, <code class="inline">Mnesia</code> assumes that its local replica is the most recent version
and loads the table from disc if either of the following situations is detected:</p><ul><li><code class="inline">mnesia_down</code> is returned from all other nodes that hold a disc resident
replica of the table.</li><li>All replicas are <code class="inline">ram_copies</code>.</li></ul><p>This is normally a wise decision, but it can be disastrous if the nodes have
been disconnected because of a communication failure, as the <code class="inline">Mnesia</code> normal
table load mechanism does not cope with communication failures.</p><p>When <code class="inline">Mnesia</code> loads many tables, the default load order is used. However, the
load order can be affected, by explicitly changing property <code class="inline">load_order</code> for the
tables, with the function
<a href="mnesia.html#change_table_load_order/2"><code class="inline">mnesia:change_table_load_order(Tab, LoadOrder)</code></a>.
<code class="inline">LoadOrder</code> is by default <code class="inline">0</code> for all tables, but it can be set to any integer.
The table with the highest <code class="inline">load_order</code> is loaded first. Changing the load order
is especially useful for applications that need to ensure early availability of
fundamental tables. Large peripheral tables are to have a low load order value,
perhaps less than <code class="inline">0</code></p><h2 id="recovery-from-communication-failure" class="section-heading"><a href="#recovery-from-communication-failure" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Recovery from Communication Failure</span></h2><p>There are several occasions when <code class="inline">Mnesia</code> can detect that the network has been
partitioned because of a communication failure, for example:</p><ul><li><code class="inline">Mnesia</code> is operational already and the Erlang nodes gain contact again. Then
<code class="inline">Mnesia</code> tries to contact <code class="inline">Mnesia</code> on the other node to see if it also thinks
that the network has been partitioned for a while. If <code class="inline">Mnesia</code> on both nodes
has logged <code class="inline">mnesia_down</code> entries from each other, <code class="inline">Mnesia</code> generates a system
event, called <code class="inline">{inconsistent_database, running_partitioned_network, Node}</code>,
which is sent to the <code class="inline">Mnesia</code> event handler and other possible subscribers.
The default event handler reports an error to the error logger.</li><li>If <code class="inline">Mnesia</code> detects at startup that both the local node and another node
received <code class="inline">mnesia_down</code> from each other, <code class="inline">Mnesia</code> generates an
<code class="inline">{inconsistent_database, starting_partitioned_network, Node}</code> system event and
acts as described in the previous item.</li></ul><p>If the application detects that there has been a communication failure that can
have caused an inconsistent database, it can use the function
<a href="mnesia.html#set_master_nodes/2"><code class="inline">mnesia:set_master_nodes(Tab, Nodes)</code></a> to pinpoint
from which nodes each table can be loaded.</p><p>At startup, the <code class="inline">Mnesia</code> normal table load algorithm is bypassed and the table
is loaded from one of the master nodes defined for the table, regardless of
potential <code class="inline">mnesia_down</code> entries in the log. <code class="inline">Nodes</code> can only contain nodes where
the table has a replica. If <code class="inline">Nodes</code> is empty, the master node recovery mechanism
for the particular table is reset and the normal load mechanism is used at the
next restart.</p><p>The function <a href="mnesia.html#set_master_nodes/1"><code class="inline">mnesia:set_master_nodes(Nodes)</code></a> sets
master nodes for all tables. For each table it determines its replica nodes and
starts <a href="mnesia.html#set_master_nodes/2"><code class="inline">mnesia:set_master_nodes(Tab, TabNodes)</code></a>
with those replica nodes that are included in the <code class="inline">Nodes</code> list (that is,
<code class="inline">TabNodes</code> is the intersection of <code class="inline">Nodes</code> and the replica nodes of the table).
If the intersection is empty, the master node recovery mechanism for the
particular table is reset and the normal load mechanism is used at the next
restart.</p><p>The functions <a href="mnesia.html#system_info/1"><code class="inline">mnesia:system_info(master_node_tables)</code></a>
and <a href="mnesia.html#table_info/2"><code class="inline">mnesia:table_info(Tab, master_nodes)</code></a> can be used to
obtain information about the potential master nodes.</p><p>Determining what data to keep after a communication failure is outside the scope
of <code class="inline">Mnesia</code>. One approach is to determine which &quot;island&quot; contains most of the
nodes. Using option <code class="inline">{majority,true}</code> for critical tables can be a way to ensure
that nodes that are not part of a &quot;majority island&quot; cannot update those tables.
Notice that this constitutes a reduction in service on the minority nodes. This
would be a tradeoff in favor of higher consistency guarantees.</p><p>The function <a href="mnesia.html#force_load_table/1"><code class="inline">mnesia:force_load_table(Tab)</code></a> can be
used to force load the table regardless of which table load mechanism that is
activated.</p><h2 id="recovery-of-transactions" class="section-heading"><a href="#recovery-of-transactions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Recovery of Transactions</span></h2><p>A <code class="inline">Mnesia</code> table can reside on one or more nodes. When a table is updated,
<code class="inline">Mnesia</code> ensures that the updates are replicated to all nodes where the table
resides. If a replica is inaccessible (for example, because of a temporary
node-down), <code class="inline">Mnesia</code> performs the replication later.</p><p>On the node where the application is started, there is a transaction coordinator
process. If the transaction is distributed, there is also a transaction
participant process on all the other nodes where commit-work needs to be
performed.</p><p>Internally <code class="inline">Mnesia</code> uses several commit protocols. The selected protocol depends
on which table that has been updated in the transaction. If all the involved
tables are symmetrically replicated (that is, they all have the same
<code class="inline">ram_nodes</code>, <code class="inline">disc_nodes</code>, and <code class="inline">disc_only_nodes</code> currently accessible from the
coordinator node), a lightweight transaction commit protocol is used.</p><p>The number of messages that the transaction coordinator and its participants
need to exchange is few, as the <code class="inline">Mnesia</code> table load mechanism takes care of the
transaction recovery if the commit protocol gets interrupted. Since all involved
tables are replicated symmetrically, the transaction is automatically recovered
by loading the involved tables from the same node at startup of a failing node.
It does not matter if the transaction was committed or terminated as long as the
ACID properties can be ensured. The lightweight commit protocol is non-blocking,
that is, the surviving participants and their coordinator finish the
transaction, even if any node crashes in the middle of the commit protocol.</p><p>If a node goes down in the middle of a dirty operation, the table load mechanism
ensures that the update is performed on all replicas, or none. Both asynchronous
dirty updates and synchronous dirty updates use the same recovery principle as
lightweight transactions.</p><p>If a transaction involves updates of asymmetrically replicated tables or updates
of the schema table, a heavyweight commit protocol is used. This protocol can
finish the transaction regardless of how the tables are replicated. The typical
use of a heavyweight transaction is when a replica is to be moved from one node
to another. Then ensure that the replica either is entirely moved or left as it
was. Do never end up in a situation with replicas on both nodes, or on no node
at all. Even if a node crashes in the middle of the commit protocol, the
transaction must be guaranteed to be atomic. The heavyweight commit protocol
involves more messages between the transaction coordinator and its participants
than a lightweight protocol, and it performs recovery work at startup to finish
the terminating or commit work.</p><p>The heavyweight commit protocol is also non-blocking, which allows the surviving
participants and their coordinator to finish the transaction regardless (even if
a node crashes in the middle of the commit protocol). When a node fails at
startup, <code class="inline">Mnesia</code> determines the outcome of the transaction and recovers it.
Lightweight protocols, heavyweight protocols, and dirty updates, are dependent
on other nodes to be operational to make the correct heavyweight transaction
recovery decision.</p><p>If <code class="inline">Mnesia</code> has not started on some of the nodes that are involved in the
transaction <em>and</em> neither the local node nor any of the already running nodes
know the outcome of the transaction, <code class="inline">Mnesia</code> waits for one, by default. In the
worst case scenario, all other involved nodes must start before <code class="inline">Mnesia</code> can
make the correct decision about the transaction and finish its startup.</p><p>Thus, <code class="inline">Mnesia</code> (on one node) can hang if a double fault occurs, that is, when
two nodes crash simultaneously and one attempts to start when the other refuses
to start, for example, because of a hardware error.</p><p>The maximum time that <code class="inline">Mnesia</code> waits for other nodes to respond with a
transaction recovery decision can be specified. The configuration parameter
<code class="inline">max_wait_for_decision</code> defaults to <code class="inline">infinity</code>, which can cause the indefinite
hanging as mentioned earlier. However, if the parameter is set to a definite
time period (for example, three minutes), <code class="inline">Mnesia</code> then enforces a transaction
recovery decision, if needed, to allow <code class="inline">Mnesia</code> to continue with its startup
procedure.</p><p>The downside of an enforced transaction recovery decision is that the decision
can be incorrect, because of insufficient information about the recovery
decisions from the other nodes. This can result in an inconsistent database
where <code class="inline">Mnesia</code> has committed the transaction on some nodes but terminated it on
others.</p><p>In fortunate cases, the inconsistency is only visible in tables belonging to a
specific application. However, if a schema transaction is inconsistently
recovered because of the enforced transaction recovery decision, the effects of
the inconsistency can be fatal. However, if the higher priority is availability
rather than consistency, it can be worth the risk.</p><p>If <code class="inline">Mnesia</code> detects an inconsistent transaction decision, an
<code class="inline">{inconsistent_database, bad_decision, Node}</code> system event is generated to give
the application a chance to install a fallback or other appropriate measures to
resolve the inconsistency. The default behavior of the <code class="inline">Mnesia</code> event handler is
the same as if the database became inconsistent as a result of partitioned
network (as described earlier).</p><h2 id="backup-restore-fallback-and-disaster-recovery" class="section-heading"><a href="#backup-restore-fallback-and-disaster-recovery" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Backup, Restore, Fallback, and Disaster Recovery</span></h2><p>The following functions are used to back up data, to install a backup as
fallback, and for disaster recovery:</p><ul><li><a href="mnesia.html#backup_checkpoint/2"><code class="inline">mnesia:backup_checkpoint(Name, Opaque [,Mod])</code></a>
performs a backup of the tables included in the checkpoint.</li><li><a href="mnesia.html#backup/1"><code class="inline">mnesia:backup(Opaque [,Mod])</code></a> activates a new checkpoint
that covers all <code class="inline">Mnesia</code> tables and performs a backup. It is performed with
maximum degree of redundancy (see also the function
<a href="mnesia_chap7.html#checkpoints"><code class="inline">mnesia:activate_checkpoint(Args)</code></a>,
<code class="inline">{max, MaxTabs} and {min, MinTabs})</code>.</li><li><a href="mnesia.html#traverse_backup/4"><code class="inline">mnesia:traverse_backup(Source, [SourceMod,] Target, [TargetMod,] Fun, Acc)</code></a> can be used to read an existing backup,
create a backup from an existing one, or to copy a backup from one type media
to another.</li><li><a href="mnesia.html#uninstall_fallback/0"><code class="inline">mnesia:uninstall_fallback()</code></a> removes
previously installed fallback files.</li><li><a href="mnesia.html#restore/2"><code class="inline">mnesia:restore(Opaque, Args)</code></a> restores a set of tables
from a previous backup.</li><li><a href="mnesia.html#install_fallback/1"><code class="inline">mnesia:install_fallback(Opaque [,Mod])</code></a> can be
configured to restart <code class="inline">Mnesia</code> and the reload data tables, and possibly the
schema tables, from an existing backup. This function is typically used for
disaster recovery purposes, when data or schema tables are corrupted.</li></ul><p>These functions are explained in the following sections. See also
<a href="mnesia_chap7.html#checkpoints">Checkpoints</a>, which describes the two functions
used to activate and deactivate checkpoints.</p><h3 id="backup" class="section-heading"><a href="#backup" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Backup</span></h3><p>Backup operation are performed with the following functions:</p><ul><li><a href="mnesia.html#backup_checkpoint/2"><code class="inline">mnesia:backup_checkpoint(Name, Opaque [,Mod])</code></a></li><li><a href="mnesia.html#backup/1"><code class="inline">mnesia:backup(Opaque [,Mod])</code></a></li><li><a href="mnesia.html#traverse_backup/4"><code class="inline">mnesia:traverse_backup(Source, [SourceMod,] Target, [TargetMod,] Fun, Acc)</code></a></li></ul><p>By default, the actual access to the backup media is performed through module
<code class="inline">mnesia_backup</code> for both read and write. Currently <code class="inline">mnesia_backup</code> is
implemented with the standard library module <code class="inline">disk_log</code>. However, you can write
your own module with the same interface as <code class="inline">mnesia_backup</code> and configure
<code class="inline">Mnesia</code> so that the alternative module performs the actual accesses to the
backup media. The user can therefore put the backup on a media that <code class="inline">Mnesia</code>
does not know about, possibly on hosts where Erlang is not running. Use
configuration parameter <code class="inline">-mnesia backup_module &lt;module&gt;</code> for this purpose.</p><p>The source for a backup is an activated checkpoint. The backup function
<a href="mnesia.html#backup_checkpoint/2"><code class="inline">mnesia:backup_checkpoint(Name, Opaque [,Mod])</code></a> is
most commonly used and returns <code class="inline">ok</code> or <code class="inline">{error,Reason}</code>. It has the following
arguments:</p><ul><li><code class="inline">Name</code> is the name of an activated checkpoint. For details on how to include
table names in checkpoints, see the function
<code class="inline">mnesia:activate_checkpoint(ArgList)</code> in
<a href="mnesia_chap7.html#checkpoints">Checkpoints</a>.</li><li><code class="inline">Opaque</code>. <code class="inline">Mnesia</code> does not interpret this argument, but it is forwarded to
the backup module. The <code class="inline">Mnesia</code> default backup module <code class="inline">mnesia_backup</code>
interprets this argument as a local filename.</li><li><code class="inline">Mod</code> is the name of an alternative backup module.</li></ul><p>The function <a href="mnesia.html#backup/1"><code class="inline">mnesia:backup(Opaque [,Mod])</code></a> activates a new
checkpoint that covers all <code class="inline">Mnesia</code> tables with maximum degree of redundancy and
performs a backup. Maximum redundancy means that each table replica has a
checkpoint retainer. Tables with property <code class="inline">local_contents</code> are backed up as they
look on the current node.</p><p>You can iterate over a backup, either to transform it into a new backup, or only
read it. The function <a href="mnesia.html#traverse_backup/4"><code class="inline">mnesia:traverse_backup(Source, [SourceMod,] Target, [TargetMod,] Fun, Acc)</code></a>, which normally returns
<code class="inline">{ok, LastAcc}</code>, is used for both of these purposes.</p><p>Before the traversal starts, the source backup media is opened with
<code class="inline">SourceMod:open_read(Source)</code>, and the target backup media is opened with
<code class="inline">TargetMod:open_write(Target)</code>. The arguments are as follows:</p><ul><li><code class="inline">SourceMod</code> and <code class="inline">TargetMod</code> are module names.</li><li><code class="inline">Source</code> and <code class="inline">Target</code> are opaque data used exclusively by the modules
<code class="inline">SourceMod</code> and <code class="inline">TargetMod</code> for initializing the backup media.</li><li><code class="inline">Acc</code> is an initial accumulator value.</li><li><code class="inline">Fun(BackupItems, Acc)</code> is applied to each item in the backup. The Fun must
return a tuple <code class="inline">{ValGoodBackupItems, NewAcc}</code>, where <code class="inline">ValidBackupItems</code> is a
list of valid backup items. <code class="inline">NewAcc</code> is a new accumulator value. The
<code class="inline">ValidBackupItems</code> are written to the target backup with the function
<code class="inline">TargetMod:write/2</code>.</li><li><code class="inline">LastAcc</code> is the last accumulator value, that is, the last <code class="inline">NewAcc</code> value that
was returned by <code class="inline">Fun</code>.</li></ul><p>Also, a read-only traversal of the source backup can be performed without
updating a target backup. If <code class="inline">TargetMod==read_only</code>, no target backup is
accessed.</p><p>By setting <code class="inline">SourceMod</code> and <code class="inline">TargetMod</code> to different modules, a backup can be
copied from one backup media to another.</p><p>Valid <code class="inline">BackupItems</code> are the following tuples:</p><ul><li><code class="inline">{schema, Tab}</code> specifies a table to be deleted.</li><li><code class="inline">{schema, Tab, CreateList}</code> specifies a table to be created. For more
information about <code class="inline">CreateList</code>, see <a href="mnesia.html#create_table/2"><code class="inline">mnesia:create_table/2</code></a>.</li><li><code class="inline">{Tab, Key}</code> specifies the full identity of a record to be deleted.</li><li><code class="inline">{Record}</code> specifies a record to be inserted. It can be a tuple with <code class="inline">Tab</code> as
first field. Notice that the record name is set to the table name regardless
of what <code class="inline">record_name</code> is set to.</li></ul><p>The backup data is divided into two sections. The first section contains
information related to the schema. All schema-related items are tuples where the
first field equals the atom schema. The second section is the record section.
Schema records cannot be mixed with other records and all schema records must be
located first in the backup.</p><p>The schema itself is a table and is possibly included in the backup. Each node
where the schema table resides is regarded as a <code class="inline">db_node</code>.</p><p>The following example shows how
<a href="mnesia.html#traverse_backup/4"><code class="inline">mnesia:traverse_backup</code></a> can be used to rename a
<code class="inline">db_node</code> in a backup file:</p><pre><code class="makeup erlang" translate="no"><span class="nf">change_node_name</span><span class="p" data-group-id="6066862561-1">(</span><span class="n">Mod</span><span class="p">,</span><span class="w"> </span><span class="n">From</span><span class="p">,</span><span class="w"> </span><span class="n">To</span><span class="p">,</span><span class="w"> </span><span class="n">Source</span><span class="p">,</span><span class="w"> </span><span class="n">Target</span><span class="p" data-group-id="6066862561-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="n">Switch</span><span class="w"> </span><span class="o">=</span><span class="w">
        </span><span class="nf">fun</span><span class="p" data-group-id="6066862561-2">(</span><span class="n">Node</span><span class="p" data-group-id="6066862561-2">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">From</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">To</span><span class="p">;</span><span class="w">
           </span><span class="p" data-group-id="6066862561-3">(</span><span class="n">Node</span><span class="p" data-group-id="6066862561-3">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">To</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">throw</span><span class="p" data-group-id="6066862561-4">(</span><span class="p" data-group-id="6066862561-5">{</span><span class="ss">error</span><span class="p">,</span><span class="w"> </span><span class="ss">already_exists</span><span class="p" data-group-id="6066862561-5">}</span><span class="p" data-group-id="6066862561-4">)</span><span class="p">;</span><span class="w">
           </span><span class="p" data-group-id="6066862561-6">(</span><span class="n">Node</span><span class="p" data-group-id="6066862561-6">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">Node</span><span class="w">
        </span><span class="k">end</span><span class="p">,</span><span class="w">
    </span><span class="n">Convert</span><span class="w"> </span><span class="o">=</span><span class="w">
        </span><span class="nf">fun</span><span class="p" data-group-id="6066862561-7">(</span><span class="p" data-group-id="6066862561-8">{</span><span class="ss">schema</span><span class="p">,</span><span class="w"> </span><span class="ss">version</span><span class="p">,</span><span class="w"> </span><span class="n">Version</span><span class="p" data-group-id="6066862561-8">}</span><span class="p">,</span><span class="w"> </span><span class="n">Acc</span><span class="p" data-group-id="6066862561-7">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                </span><span class="p" data-group-id="6066862561-9">{</span><span class="p" data-group-id="6066862561-10">[</span><span class="p" data-group-id="6066862561-11">{</span><span class="ss">schema</span><span class="p">,</span><span class="w"> </span><span class="ss">version</span><span class="p">,</span><span class="w"> </span><span class="n">Version</span><span class="p" data-group-id="6066862561-11">}</span><span class="p" data-group-id="6066862561-10">]</span><span class="p">,</span><span class="w"> </span><span class="n">Acc</span><span class="p" data-group-id="6066862561-9">}</span><span class="p">;</span><span class="w">
           </span><span class="p" data-group-id="6066862561-12">(</span><span class="p" data-group-id="6066862561-13">{</span><span class="ss">schema</span><span class="p">,</span><span class="w"> </span><span class="ss">cookie</span><span class="p">,</span><span class="w"> </span><span class="n">Cookie</span><span class="p" data-group-id="6066862561-13">}</span><span class="p">,</span><span class="w"> </span><span class="n">Acc</span><span class="p" data-group-id="6066862561-12">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                </span><span class="p" data-group-id="6066862561-14">{</span><span class="p" data-group-id="6066862561-15">[</span><span class="p" data-group-id="6066862561-16">{</span><span class="ss">schema</span><span class="p">,</span><span class="w"> </span><span class="ss">cookie</span><span class="p">,</span><span class="w"> </span><span class="n">Cookie</span><span class="p" data-group-id="6066862561-16">}</span><span class="p" data-group-id="6066862561-15">]</span><span class="p">,</span><span class="w"> </span><span class="n">Acc</span><span class="p" data-group-id="6066862561-14">}</span><span class="p">;</span><span class="w">
           </span><span class="p" data-group-id="6066862561-17">(</span><span class="p" data-group-id="6066862561-18">{</span><span class="ss">schema</span><span class="p">,</span><span class="w"> </span><span class="n">Tab</span><span class="p">,</span><span class="w"> </span><span class="n">CreateList</span><span class="p" data-group-id="6066862561-18">}</span><span class="p">,</span><span class="w"> </span><span class="n">Acc</span><span class="p" data-group-id="6066862561-17">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                </span><span class="n">Keys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="6066862561-19">[</span><span class="ss">ram_copies</span><span class="p">,</span><span class="w"> </span><span class="ss">disc_copies</span><span class="p">,</span><span class="w"> </span><span class="ss">disc_only_copies</span><span class="p" data-group-id="6066862561-19">]</span><span class="p">,</span><span class="w">
                </span><span class="n">OptSwitch</span><span class="w"> </span><span class="o">=</span><span class="w">
                    </span><span class="nf">fun</span><span class="p" data-group-id="6066862561-20">(</span><span class="p" data-group-id="6066862561-21">{</span><span class="n">Key</span><span class="p">,</span><span class="w"> </span><span class="n">Val</span><span class="p" data-group-id="6066862561-21">}</span><span class="p" data-group-id="6066862561-20">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                            </span><span class="k">case</span><span class="w"> </span><span class="nc">lists</span><span class="p">:</span><span class="nf">member</span><span class="p" data-group-id="6066862561-22">(</span><span class="n">Key</span><span class="p">,</span><span class="w"> </span><span class="n">Keys</span><span class="p" data-group-id="6066862561-22">)</span><span class="w"> </span><span class="k">of</span><span class="w">
                                </span><span class="ss">true</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="6066862561-23">{</span><span class="n">Key</span><span class="p">,</span><span class="w"> </span><span class="nc">lists</span><span class="p">:</span><span class="nf">map</span><span class="p" data-group-id="6066862561-24">(</span><span class="n">Switch</span><span class="p">,</span><span class="w"> </span><span class="n">Val</span><span class="p" data-group-id="6066862561-24">)</span><span class="p" data-group-id="6066862561-23">}</span><span class="p">;</span><span class="w">
                                </span><span class="ss">false</span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="6066862561-25">{</span><span class="n">Key</span><span class="p">,</span><span class="w"> </span><span class="n">Val</span><span class="p" data-group-id="6066862561-25">}</span><span class="w">
                            </span><span class="k">end</span><span class="w">
                    </span><span class="k">end</span><span class="p">,</span><span class="w">
                </span><span class="p" data-group-id="6066862561-26">{</span><span class="p" data-group-id="6066862561-27">[</span><span class="p" data-group-id="6066862561-28">{</span><span class="ss">schema</span><span class="p">,</span><span class="w"> </span><span class="n">Tab</span><span class="p">,</span><span class="w"> </span><span class="nc">lists</span><span class="p">:</span><span class="nf">map</span><span class="p" data-group-id="6066862561-29">(</span><span class="n">OptSwitch</span><span class="p">,</span><span class="w"> </span><span class="n">CreateList</span><span class="p" data-group-id="6066862561-29">)</span><span class="p" data-group-id="6066862561-28">}</span><span class="p" data-group-id="6066862561-27">]</span><span class="p">,</span><span class="w"> </span><span class="n">Acc</span><span class="p" data-group-id="6066862561-26">}</span><span class="p">;</span><span class="w">
           </span><span class="p" data-group-id="6066862561-30">(</span><span class="n">Other</span><span class="p">,</span><span class="w"> </span><span class="n">Acc</span><span class="p" data-group-id="6066862561-30">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                </span><span class="p" data-group-id="6066862561-31">{</span><span class="p" data-group-id="6066862561-32">[</span><span class="n">Other</span><span class="p" data-group-id="6066862561-32">]</span><span class="p">,</span><span class="w"> </span><span class="n">Acc</span><span class="p" data-group-id="6066862561-31">}</span><span class="w">
        </span><span class="k">end</span><span class="p">,</span><span class="w">
    </span><span class="nc">mnesia</span><span class="p">:</span><span class="nf">traverse_backup</span><span class="p" data-group-id="6066862561-33">(</span><span class="n">Source</span><span class="p">,</span><span class="w"> </span><span class="n">Mod</span><span class="p">,</span><span class="w"> </span><span class="n">Target</span><span class="p">,</span><span class="w"> </span><span class="n">Mod</span><span class="p">,</span><span class="w"> </span><span class="n">Convert</span><span class="p">,</span><span class="w"> </span><span class="ss">switched</span><span class="p" data-group-id="6066862561-33">)</span><span class="p">.</span><span class="w">

</span><span class="nf">view</span><span class="p" data-group-id="6066862561-34">(</span><span class="n">Source</span><span class="p">,</span><span class="w"> </span><span class="n">Mod</span><span class="p" data-group-id="6066862561-34">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="n">View</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">fun</span><span class="p" data-group-id="6066862561-35">(</span><span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="n">Acc</span><span class="p" data-group-id="6066862561-35">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                   </span><span class="nc">io</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="6066862561-36">(</span><span class="s">&quot;</span><span class="si">~p</span><span class="s">.</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="p" data-group-id="6066862561-37">[</span><span class="n">Item</span><span class="p" data-group-id="6066862561-37">]</span><span class="p" data-group-id="6066862561-36">)</span><span class="p">,</span><span class="w">
                   </span><span class="p" data-group-id="6066862561-38">{</span><span class="p" data-group-id="6066862561-39">[</span><span class="n">Item</span><span class="p" data-group-id="6066862561-39">]</span><span class="p">,</span><span class="w"> </span><span class="n">Acc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="6066862561-38">}</span><span class="w">
           </span><span class="k">end</span><span class="p">,</span><span class="w">
    </span><span class="nc">mnesia</span><span class="p">:</span><span class="nf">traverse_backup</span><span class="p" data-group-id="6066862561-40">(</span><span class="n">Source</span><span class="p">,</span><span class="w"> </span><span class="n">Mod</span><span class="p">,</span><span class="w"> </span><span class="ss">dummy</span><span class="p">,</span><span class="w"> </span><span class="ss">read_only</span><span class="p">,</span><span class="w"> </span><span class="n">View</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="6066862561-40">)</span><span class="p">.</span></code></pre><h3 id="restore" class="section-heading"><a href="#restore" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Restore</span></h3><p>Tables can be restored online from a backup without restarting <code class="inline">Mnesia</code>. A
restore is performed with the function
<a href="mnesia.html#restore/2"><code class="inline">mnesia:restore(Opaque, Args)</code></a>, where <code class="inline">Args</code> can contain the
following tuples:</p><ul><li><code class="inline">{module, Mod}</code>. The backup module <code class="inline">Mod</code> is used to access the backup media. If
omitted, the default backup module is used.</li><li><code class="inline">{skip_tables, TableList}</code>, where <code class="inline">TableList</code> is a list of tables, which is
not to be read from the backup.</li><li><code class="inline">{clear_tables, TableList}</code>, where <code class="inline">TableList</code> is a list of tables, which is
to be cleared before the records from the backup are inserted. That is, all
records in the tables are deleted before the tables are restored. Schema
information about the tables is not cleared or read from the backup.</li><li><code class="inline">{keep_tables, TableList}</code>, where <code class="inline">TableList</code> is a list of tables, which is
not to be cleared before the records from the backup are inserted. That is,
the records in the backup are added to the records in the table. Schema
information about the tables is not cleared or read from the backup.</li><li><code class="inline">{recreate_tables, TableList}</code>, where <code class="inline">TableList</code> is a list of tables, which
is to be recreated before the records from the backup are inserted. The tables
are first deleted and then created with the schema information from the
backup. All the nodes in the backup need to be operational.</li><li><code class="inline">{default_op, Operation}</code>, where <code class="inline">Operation</code> is one of the operations
<code class="inline">skip_tables</code>, <code class="inline">clear_tables</code>, <code class="inline">keep_tables</code>, or <code class="inline">recreate_tables</code>. The
default operation specifies which operation is to be used on tables from the
backup that are not specified in any of the previous lists. If omitted, the
operation <code class="inline">clear_tables</code> is used.</li></ul><p>The argument <code class="inline">Opaque</code> is forwarded to the backup module. It returns
<code class="inline">{atomic, TabList}</code> if successful, or the tuple <code class="inline">{aborted, Reason}</code> if there is
an error. <code class="inline">TabList</code> is a list of the restored tables. Tables that are restored
are write-locked during the restore operation. However, regardless of any lock
conflict caused by this, applications can continue to do their work during the
restore operation.</p><p>The restoration is performed as a single transaction. If the database is large,
it cannot always be restored online. The old database must then be restored by
installing a fallback, followed by a restart.</p><h3 id="fallback" class="section-heading"><a href="#fallback" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Fallback</span></h3><p>The function <a href="mnesia.html#install_fallback/2"><code class="inline">mnesia:install_fallback(Opaque [, Mod])</code></a>
installs a backup as fallback. It uses the backup module <code class="inline">Mod</code>,
or the default backup module, to access the backup media.
The function returns <code class="inline">ok</code> if successful, or <code class="inline">{error, Reason}</code> if there is an
error.</p><p>Installing a fallback is a distributed operation, which is <em>only</em> performed on
all <code class="inline">db_nodes</code>. The fallback restores the database the next time the system is
started. If a <code class="inline">Mnesia</code> node with a fallback installed detects that <code class="inline">Mnesia</code> on
another node has died, it unconditionally terminates itself.</p><p>A fallback is typically used when a system upgrade is performed. A system
typically involves the installation of new software versions, and <code class="inline">Mnesia</code>
tables are often transformed into new layouts. If the system crashes during an
upgrade, it is highly probable that reinstallation of the old applications is
required, and restoration of the database to its previous state. This can be
done if a backup is performed and installed as a fallback before the system
upgrade begins.</p><p>If the system upgrade fails, <code class="inline">Mnesia</code> must be restarted on all <code class="inline">db_nodes</code> to
restore the old database. The fallback is automatically deinstalled after a
successful startup. The function
<a href="mnesia.html#uninstall_fallback/0"><code class="inline">mnesia:uninstall_fallback()</code></a> can also be used to
deinstall the fallback after a successful system upgrade. Again, this is a
distributed operation that is either performed on all <code class="inline">db_nodes</code> or none. Both
the installation and deinstallation of fallbacks require Erlang to be
operational on all <code class="inline">db_nodes</code>, but it does not matter if <code class="inline">Mnesia</code> is running or
not.</p><h3 id="disaster-recovery" class="section-heading"><a href="#disaster-recovery" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Disaster Recovery</span></h3><p>The system can become inconsistent as a result of a power failure. The UNIX
feature <code class="inline">fsck</code> can possibly repair the file system, but there is no guarantee
that the file content is consistent.</p><p>If <code class="inline">Mnesia</code> detects that a file has not been properly closed, possibly as a
result of a power failure, it tries to repair the bad file in a similar manner.
Data can be lost, but <code class="inline">Mnesia</code> can be restarted even if the data is
inconsistent. Configuration parameter <code class="inline">-mnesia auto_repair &lt;bool&gt;</code> can be used
to control the behavior of <code class="inline">Mnesia</code> at startup. If <code class="inline">&lt;bool&gt;</code> has the value
<code class="inline">true</code>, <code class="inline">Mnesia</code> tries to repair the file. If <code class="inline">&lt;bool&gt;</code> has the value <code class="inline">false</code>,
<code class="inline">Mnesia</code> does not restart if it detects a suspect file. This configuration
parameter affects the repair behavior of log files, <code class="inline">DAT</code> files, and the default
backup media.</p><p>Configuration parameter <code class="inline">-mnesia dump_log_update_in_place &lt;bool&gt;</code> controls the
safety level of the function <a href="mnesia.html#dump_log/0"><code class="inline">mnesia:dump_log()</code></a> By
default, <code class="inline">Mnesia</code> dumps the transaction log directly into the <code class="inline">DAT</code> files. If a
power failure occurs during the dump, this can cause the randomly accessed <code class="inline">DAT</code>
files to become corrupt. If the parameter is set to <code class="inline">false</code>, <code class="inline">Mnesia</code> copies the
<code class="inline">DAT</code> files and target the dump to the new temporary files. If the dump is
successful, the temporary files are renamed to their normal <code class="inline">DAT</code> suffixes. The
possibility for unrecoverable inconsistencies in the data files becomes much
smaller with this strategy. However, the actual dumping of the transaction log
becomes considerably slower. The system designer must decide whether speed or
safety is the higher priority.</p><p>Replicas of type <code class="inline">disc_only_copies</code> are only affected by this parameter during
the initial dump of the log file at startup. When designing applications with
<em>very</em> high requirements, it can be appropriate not to use <code class="inline">disc_only_copies</code>
tables at all. The reason for this is the random access nature of normal
operating system files. If a node goes down for a reason such as a power
failure, these files can be corrupted because they are not properly closed. The
<code class="inline">DAT</code> files for <code class="inline">disc_only_copies</code> are updated on a per transaction basis.</p><p>If a disaster occurs and the <code class="inline">Mnesia</code> database is corrupted, it can be
reconstructed from a backup. Regard this as a last resort, as the backup
contains old data. The data is hopefully consistent, but data is definitely lost
when an old backup is used to restore the database.</p>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="mnesia_chap5.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Miscellaneous Mnesia Features
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="mnesia_chap8.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Combine Mnesia with SNMP
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="mnesia.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.38.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright © 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
