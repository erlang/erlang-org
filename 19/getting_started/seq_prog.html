<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- Sequential Programming</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="../pdf/otp-system-documentation.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Getting Started with Erlang</strong><br><strong>User's Guide</strong><br><small>Version 8.3</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="intro.html">
              Top of chapter
            </a></li>
<li title="Prerequisites"><a href="intro.html#id57375">Prerequisites</a></li>
<li title="Omitted Topics"><a href="intro.html#id61403">Omitted Topics</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Sequential Programming" expanded="true">Sequential Programming<ul>
<li><a href="seq_prog.html">
              Top of chapter
            </a></li>
<li title="The Erlang Shell"><a href="seq_prog.html#id63885">The Erlang Shell</a></li>
<li title="Modules and Functions"><a href="seq_prog.html#id61810">Modules and Functions</a></li>
<li title="Atoms"><a href="seq_prog.html#id62442">Atoms</a></li>
<li title="Tuples"><a href="seq_prog.html#id63406">Tuples</a></li>
<li title="Lists"><a href="seq_prog.html#id64399">Lists</a></li>
<li title="Maps"><a href="seq_prog.html#id61210">Maps</a></li>
<li title="Standard Modules and Manual Pages"><a href="seq_prog.html#id61546">Standard Modules and Manual Pages</a></li>
<li title="Writing Output to a Terminal"><a href="seq_prog.html#id61593">Writing Output to a Terminal</a></li>
<li title="A Larger Example"><a href="seq_prog.html#id63929">A Larger Example</a></li>
<li title="Matching, Guards, and Scope of Variables"><a href="seq_prog.html#id64103">Matching, Guards, and Scope of Variables</a></li>
<li title="More About Lists"><a href="seq_prog.html#id67551">More About Lists</a></li>
<li title="If and Case"><a href="seq_prog.html#id67816">If and Case</a></li>
<li title="Built-In Functions (BIFs)"><a href="seq_prog.html#id68048">Built-In Functions (BIFs)</a></li>
<li title="Higher-Order Functions (Funs)"><a href="seq_prog.html#id68245">Higher-Order Functions (Funs)</a></li>
</ul>
</li>
<li id="no" title="Concurrent Programming" expanded="false">Concurrent Programming<ul>
<li><a href="conc_prog.html">
              Top of chapter
            </a></li>
<li title="Processes"><a href="conc_prog.html#id68558">Processes</a></li>
<li title="Message Passing"><a href="conc_prog.html#id68696">Message Passing</a></li>
<li title="Registered Process Names"><a href="conc_prog.html#id69040">Registered Process Names</a></li>
<li title="Distributed Programming"><a href="conc_prog.html#id69141">Distributed Programming</a></li>
<li title="A Larger Example"><a href="conc_prog.html#id69427">A Larger Example</a></li>
</ul>
</li>
<li id="no" title="Robustness" expanded="false">Robustness<ul>
<li><a href="robustness.html">
              Top of chapter
            </a></li>
<li title="Time-outs"><a href="robustness.html#id70147">Time-outs</a></li>
<li title="Error Handling"><a href="robustness.html#id70269">Error Handling</a></li>
<li title="The Larger Example with Robustness Added"><a href="robustness.html#id70477">The Larger Example with Robustness Added</a></li>
</ul>
</li>
<li id="no" title="Records and Macros" expanded="false">Records and Macros<ul>
<li><a href="record_macros.html">
              Top of chapter
            </a></li>
<li title="The Larger Example Divided into Several Files"><a href="record_macros.html#id70673">The Larger Example Divided into Several Files</a></li>
<li title="Header Files"><a href="record_macros.html#id70838">Header Files</a></li>
<li title="Records"><a href="record_macros.html#id70882">Records</a></li>
<li title="Macros"><a href="record_macros.html#id70980">Macros</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>2 Sequential Programming</h1>
  

  <h3><a name="id63885">2.1 
        The Erlang Shell</a></h3>
    
    <p>
      Most operating systems have a command interpreter or shell, UNIX
      and Linux have many, Windows has the command prompt. Erlang has
      its own shell where bits of Erlang code can be written directly,
      and be evaluated to see what happens
      (see the <span class="bold_code"><a href="../man/shell.html">shell(3)</a></span>
      manual page in STDLIB).
    </p>
    <p>Start
      the Erlang shell (in Linux or UNIX) by starting a shell or
      command interpreter in your operating system and typing
      <span class="code">erl</span>. You will see something like this.</p>
    <div class="example"><pre>
% <span class="bold_code">erl</span>
Erlang R15B (erts-5.9.1) [source] [smp:8:8] [rq:8] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9.1  (abort with ^G)
1&gt;</pre></div>
    <p>Type "2 + 5." in the shell and then press Enter (carriage return).
    Notice that you tell the shell you are done entering code by finishing
    with a full stop "." and a carriage return.</p>
    <div class="example"><pre>
1&gt; <span class="bold_code">2 + 5.</span>
7
2&gt;</pre></div>
    <p>As shown, the Erlang shell numbers the lines that
      can be entered, (as 1&gt; 2&gt;) and that it correctly says
      that 2 + 5 is 7. If you make writing mistakes in the shell,
      you can delete with the backspace key, as in most shells.
      There are many more editing commands in the shell
      (see <span class="bold_code"><a href="../apps/erts/tty.html">tty - A command line interface</a></span> in ERTS User's Guide).</p>
    <p>(Notice that many line numbers given by the shell in the
      following examples are out of sequence. This is because this
      tutorial was written and code-tested in separate sessions).</p>
    <p>Here is a bit more complex calculation:</p>
    <div class="example"><pre>
2&gt; <span class="bold_code">(42 + 77) * 66 / 3.</span>
2618.0</pre></div>
    <p>Notice the use of brackets, the multiplication operator "*",
      and the division operator "/", as in normal arithmetic (see
      <span class="bold_code"><a href="../reference_manual/expressions.html">Expressions</a></span>).</p>
    <p>Press Control-C to shut down the Erlang system and the Erlang
      shell.</p>
    <p>The following output is shown:</p>
    <div class="example"><pre>
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
<span class="bold_code">a</span>
%</pre></div>
    <p>Type "a" to leave the Erlang system.</p>
    <p>Another way to shut down the Erlang system is by entering
      <span class="code">halt()</span>:</p>
    <div class="example"><pre>
3&gt; <span class="bold_code">halt().</span>
% </pre></div>
  

  <h3><a name="id61810">2.2 
        Modules and Functions</a></h3>
    
    <p>A programming language is not much use if you only can run code
      from the shell. So here is a small Erlang program. Enter it into
      a file named <span class="code">tut.erl</span> using a suitable
      text editor. The file name <span class="code">tut.erl</span> is important, and also
      that it is in the same directory as the one where you started
      <span class="code">erl</span>). If you are lucky your editor has an Erlang mode
      that makes it easier for you to enter and format your code
      nicely (see <span class="bold_code"><a href="../apps/tools/erlang_mode_chapter.html">The Erlang mode for Emacs</a></span> in Tools User's Guide), but you can manage
      perfectly well without. Here is the code to enter:</p>
    <div class="example"><pre>
-module(tut).
-export([double/1]).

double(X) -&gt;
    2 * X.</pre></div>
    <p>It is not hard to guess that this program doubles the value of
      numbers. The first two lines of the code are described later.
      Let us compile the program. This can be done in an Erlang shell
      as follows, where <span class="code">c</span> means compile:</p>
    <div class="example"><pre>
3&gt; <span class="bold_code">c(tut).</span>
{ok,tut}</pre></div>
    <p>The <span class="code">{ok,tut}</span> means that the compilation is OK. If it
      says "error" it means that there is some mistake in the text
      that you entered. Additional error messages gives an idea to
      what is wrong so you can modify the text and then try to compile
      the program again.</p>
    <p>Now run the program:</p>
    <div class="example"><pre>
4&gt; <span class="bold_code">tut:double(10).</span>
20</pre></div>
    <p>As expected, double of 10 is 20.</p>
    <p>Now let us get back to the first two lines of the code. Erlang
      programs are
      written in files. Each file contains an Erlang
      <strong>module</strong>. The first line of code in the module is
      the module name (see
      <span class="bold_code"><a href="../reference_manual/modules.html">Modules</a></span>):</p>
    <div class="example"><pre>
-module(tut).</pre></div>
    <p>Thus, the module is called <strong>tut</strong>. Notice
      the full stop "." at the end of the line. The files which are
      used to store
      the module must have the same name as the module but with
      the extension ".erl". In this case the file name is <span class="code">tut.erl</span>.
      When using a function in another module, the syntax
      <span class="code">module_name:function_name(arguments)</span> is used. So the
      following means call function <span class="code">double</span> in module <span class="code">tut</span>
      with argument "10".</p>
    <div class="example"><pre>
4&gt; <span class="bold_code">tut:double(10).</span></pre></div>
    <p>The second line says that the module <span class="code">tut</span> contains a
      function called <span class="code">double</span>, which takes one argument
      (<span class="code">X</span> in our example):</p>
    <div class="example"><pre>
-export([double/1]).</pre></div>
    <p>The second line also says that this function can be called from
      outside the module <span class="code">tut</span>. More about this later. Again,
      notice the "." at the end of the line.</p>
    <p>Now for a more complicated example, the factorial of a number.
      For example, the factorial of 4 is 4 * 3 * 2 * 1, which equals 24.</p>
    <p>Enter the following code in a file named <span class="code">tut1.erl</span>:</p>
    <div class="example"><pre>
-module(tut1).
-export([fac/1]).

fac(1) -&gt;
    1;
fac(N) -&gt;
    N * fac(N - 1).</pre></div>
    <p>So this is a module, called <span class="code">tut1</span> that contains a
      function called <span class="code">fac&gt;</span>, which takes one argument,
      <span class="code">N</span>.</p>
    <p>The first part says that the factorial of 1 is 1.:</p>
    <div class="example"><pre>
fac(1) -&gt;
    1;</pre></div>
    <p>Notice that this part ends with a semicolon ";" that indicates
      that there is more of the function <span class="code">fac&gt;</span> to come.</p>
    <p>The second part says that the factorial of N is N multiplied
      by the factorial of N - 1:</p>
    <div class="example"><pre>
fac(N) -&gt;
    N * fac(N - 1).</pre></div>
    <p>Notice that this part ends with a "." saying that there are
      no more parts of this function.</p>
    <p>Compile the file:</p>
    <div class="example"><pre>
5&gt; <span class="bold_code">c(tut1).</span>
{ok,tut1}</pre></div>
    <p>And now calculate the factorial of 4.</p>
    <div class="example"><pre>
6&gt; <span class="bold_code">tut1:fac(4).</span>
24</pre></div>
    <p>Here the function <span class="code">fac&gt;</span> in module <span class="code">tut1</span> is called
      with argument <span class="code">4</span>.</p>
    <p>A function can have many arguments. Let us expand the module
      <span class="code">tut1</span> with the function to multiply two numbers:</p>
    <div class="example"><pre>
-module(tut1).
-export([fac/1, mult/2]).

fac(1) -&gt;
    1;
fac(N) -&gt;
    N * fac(N - 1).

mult(X, Y) -&gt;
    X * Y.</pre></div>
    <p>Notice that it is also required to expand the <span class="code">-export</span> line
      with the information that there is another function <span class="code">mult</span>
      with two arguments.</p>
    <p>Compile:</p>
    <div class="example"><pre>
7&gt; <span class="bold_code">c(tut1).</span>
{ok,tut1}</pre></div>
    <p>Try out the new function <span class="code">mult</span>:</p>
    <div class="example"><pre>
8&gt; <span class="bold_code">tut1:mult(3,4).</span>
12</pre></div>
    <p>In this example the numbers are integers and the arguments
      in the functions in the code <span class="code">N</span>, <span class="code">X</span>, and <span class="code">Y</span> are
      called variables. Variables must start with a capital letter
      (see
      <span class="bold_code"><a href="../reference_manual/expressions.html">Variables</a></span>).
      Examples of variables are
      <span class="code">Number</span>, <span class="code">ShoeSize</span>, and <span class="code">Age</span>.</p>
  

  <h3><a name="id62442">2.3 
        Atoms</a></h3>
    
    <p>Atom is another data type in Erlang. Atoms start with a small
      letter (see
      <span class="bold_code"><a href="../reference_manual/data_types.html">Atom</a></span>),
      for example, <span class="code">charles</span>,
      <span class="code">centimeter</span>, and <span class="code">inch</span>. Atoms are simply names, nothing
      else. They are not like variables, which can have a value.</p>
    <p>Enter the next program in a file named <span class="code">tut2.erl</span>). It can be
      useful for converting from inches to centimeters and conversely:</p>
    <div class="example"><pre>
-module(tut2).
-export([convert/2]).

convert(M, inch) -&gt;
    M / 2.54;

convert(N, centimeter) -&gt;
    N * 2.54.</pre></div>
    <p>Compile:</p>
    <div class="example"><pre>
9&gt; <span class="bold_code">c(tut2).</span>
{ok,tut2}
</pre></div>
    <p>Test:</p>
 <div class="example"><pre>
10&gt; <span class="bold_code">tut2:convert(3, inch).</span>
1.1811023622047243
11&gt; <span class="bold_code">tut2:convert(7, centimeter).</span>
17.78</pre></div>
    <p>Notice the introduction of decimals (floating point numbers)
      without any explanation. Hopefully you can cope with that.</p>
    <p>Let us see what happens if something other than <span class="code">centimeter</span> or
      <span class="code">inch</span> is entered in the <span class="code">convert</span> function:</p>
    <div class="example"><pre>
12&gt; <span class="bold_code">tut2:convert(3, miles).</span>
** exception error: no function clause matching tut2:convert(3,miles) (tut2.erl, line 4)</pre></div>
    <p>The two parts of the <span class="code">convert</span> function are called its
      clauses. As shown, <span class="code">miles</span> is not part of either of
      the clauses. The Erlang system cannot <strong>match</strong> either of
      the clauses so an error message <span class="code">function_clause</span> is returned.
      The shell formats the error message nicely, but the error tuple
      is saved in the shell's history list and can be output by the shell
      command <span class="code">v/1</span>:</p>
    <div class="example"><pre>
13&gt; <span class="bold_code">v(12).</span>
{'EXIT',{function_clause,[{tut2,convert,
                                [3,miles],
                                [{file,"tut2.erl"},{line,4}]},
                          {erl_eval,do_apply,5,[{file,"erl_eval.erl"},{line,482}]},
                          {shell,exprs,7,[{file,"shell.erl"},{line,666}]},
                          {shell,eval_exprs,7,[{file,"shell.erl"},{line,621}]},
                          {shell,eval_loop,3,[{file,"shell.erl"},{line,606}]}]}}</pre></div>

  

  <h3><a name="id63406">2.4 
        Tuples</a></h3>
    
    <p>Now the <span class="code">tut2</span> program is hardly good programming style.
      Consider:</p>
    <div class="example"><pre>
tut2:convert(3, inch).</pre></div>
    <p>Does this mean that 3 is in inches? Or does it mean that 3 is
      in centimeters
      and is to be converted to inches? Erlang has a way to group
      things together to make things more understandable. These are called
      <strong>tuples</strong> and are surrounded by curly brackets, "{" and "}".</p>
    <p>So, <span class="code">{inch,3}</span> denotes 3 inches and
      <span class="code">{centimeter,5}</span> denotes 5 centimeters. Now let us write a
      new program that converts centimeters to inches and conversely.
      Enter the following code in a file called <span class="code">tut3.erl</span>):</p>
    <div class="example"><pre>
-module(tut3).
-export([convert_length/1]).

convert_length({centimeter, X}) -&gt;
    {inch, X / 2.54};
convert_length({inch, Y}) -&gt;
    {centimeter, Y * 2.54}.</pre></div>
    <p>Compile and test:</p>
    <div class="example"><pre>
14&gt; <span class="bold_code">c(tut3).</span>
{ok,tut3}
15&gt; <span class="bold_code">tut3:convert_length({inch, 5}).</span>
{centimeter,12.7}
16&gt; <span class="bold_code">tut3:convert_length(tut3:convert_length({inch, 5})).</span>
{inch,5.0}</pre></div>
    <p>Notice on line 16 that 5 inches is converted to centimeters and back
      again and reassuringly get back to the original value. That is,
      the argument to a function can be the result of another function.
      Consider how line 16 (above) works.
      The argument given to the function <span class="code">{inch,5}</span> is first
      matched against the first head clause of <span class="code">convert_length</span>,
      that is, <span class="code">convert_length({centimeter,X})</span>. It can be seen
      that <span class="code">{centimeter,X}</span> does not match <span class="code">{inch,5}</span>
      (the head is the bit before the "-&gt;"). This having failed,
      let us try
      the head of the next clause that is, <span class="code">convert_length({inch,Y})</span>.
      This matches, and <span class="code">Y</span> gets the value 5.</p>
    <p>Tuples can have more than two parts, in fact
      as many parts as you want, and contain any valid Erlang
      <strong>term</strong>. For example, to represent the temperature of
      various cities of the world:</p>
    <div class="example"><pre>
{moscow, {c, -10}}
{cape_town, {f, 70}}
{paris, {f, 28}}</pre></div>
    <p>Tuples have a fixed number of items in them. Each item in a
      tuple is called an <strong>element</strong>. In the tuple
      <span class="code">{moscow,{c,-10}}</span>, element 1 is <span class="code">moscow</span> and element
      2 is <span class="code">{c,-10}</span>. Here <span class="code">c</span> represents Celsius and
      <span class="code">f</span> Fahrenheit.</p>
  

  <h3><a name="id64399">2.5 
        Lists</a></h3>
    
    <p>Whereas tuples group things together, it is also needed to
      represent lists of things. Lists in Erlang are surrounded by
      square brackets, "[" and "]". For example, a list of the
      temperatures of various cities in the world can be:</p>
    <div class="example"><pre>
[{moscow, {c, -10}}, {cape_town, {f, 70}}, {stockholm, {c, -4}},
 {paris, {f, 28}}, {london, {f, 36}}]</pre></div>
    <p>Notice that this list was so long that it did not fit on one line.
      This does not matter, Erlang allows line breaks at all "sensible
      places" but not, for example, in the middle of atoms, integers,
       and others.</p>
    <p>A useful way of looking at parts of lists, is by using "|".
      This is best explained by an example using the shell:</p>
    <div class="example"><pre>
17&gt; <span class="bold_code">[First |TheRest] = [1,2,3,4,5].</span>
[1,2,3,4,5]
18&gt; <span class="bold_code">First.</span>
1
19&gt; <span class="bold_code">TheRest.</span>
[2,3,4,5]</pre></div>
    <p>To separate the first elements of the list from the rest of the
      list, <span class="code">|</span> is used. <span class="code">First</span> has got value 1 and
      <span class="code">TheRest</span> has got the value [2,3,4,5].</p>
    <p>Another example:</p>
    <div class="example"><pre>
20&gt; <span class="bold_code">[E1, E2 | R] = [1,2,3,4,5,6,7].</span>
[1,2,3,4,5,6,7]
21&gt; <span class="bold_code">E1.</span>
1
22&gt; <span class="bold_code">E2.</span>
2
23&gt; <span class="bold_code">R.</span>
[3,4,5,6,7]</pre></div>
    <p>Here you see the use of <span class="code">|</span> to get the first two elements from
      the list. If you try to get more elements from the list
      than there are elements in the list, an error is returned. Notice
      also the special case of the list with no elements, []:</p>
    <div class="example"><pre>
24&gt; <span class="bold_code">[A, B | C] = [1, 2].</span>
[1,2]
25&gt; <span class="bold_code">A.</span>
1
26&gt; <span class="bold_code">B.</span>
2
27&gt; <span class="bold_code">C.</span>
[]</pre></div>
    <p>In the previous examples, new variable names are used, instead of
      reusing the old ones: <span class="code">First</span>, <span class="code">TheRest</span>, <span class="code">E1</span>,
      <span class="code">E2</span>, <span class="code">R</span>, <span class="code">A</span>, <span class="code">B</span>, and <span class="code">C</span>. The reason
      for this is that a variable can only be given a value once in its
      context (scope). More about this later.</p>
    <p>The following example shows how to find the length of a list.
     Enter the following code in a file named <span class="code">tut4.erl</span>):</p>
    <div class="example"><pre>
-module(tut4).

-export([list_length/1]).

list_length([]) -&gt;
    0;    
list_length([First | Rest]) -&gt;
    1 + list_length(Rest).</pre></div>
    <p>Compile and test:</p>
    <div class="example"><pre>
28&gt; <span class="bold_code">c(tut4).</span>
{ok,tut4}
29&gt; <span class="bold_code">tut4:list_length([1,2,3,4,5,6,7]).</span>
7</pre></div>
    <p>Explanation:</p>
    <div class="example"><pre>
list_length([]) -&gt;
    0;</pre></div>
    <p>The length of an empty list is obviously 0.</p>
    <div class="example"><pre>
list_length([First | Rest]) -&gt;
    1 + list_length(Rest).</pre></div>
    <p>The length of a list with the first element <span class="code">First</span> and
      the remaining elements <span class="code">Rest</span> is 1 + the length of
      <span class="code">Rest</span>.</p>
    <p>(Advanced readers only: This is not tail recursive, there is a
      better way to write this function.)</p>
    <p>In general, tuples are used where "records"
      or "structs" are used in other languages. Also, lists are used when
      representing things with varying sizes, that is, where
      linked lists are used in other languages.</p>
    <p>Erlang does not have a string data type. Instead, strings can be
      represented by lists of Unicode characters. This implies for example that
      the list <span class="code">[97,98,99]</span> is equivalent to "abc". The Erlang shell is
      "clever" and guesses what list you  mean and outputs it
      in what it thinks is the most appropriate form, for example:</p>
    <div class="example"><pre>
30&gt; <span class="bold_code">[97,98,99].</span>
"abc"</pre></div>
  

  <h3><a name="id61210">2.6 
        Maps</a></h3>
    
    <p>Maps are a set of key to value associations. These associations
      are encapsulated with "#{" and "}". To create an association
      from "key" to value 42:</p>
<div class="example"><pre>
&gt; #{ "key" =&gt; 42 }.
#{"key" =&gt; 42}</pre></div>
    <p>Let us jump straight into the deep end with an example using some
      interesting features.</p>
    <p>The following example shows how to calculate alpha blending
      using maps to reference color and alpha channels. Enter the code
      in a file named <span class="code">color.erl</span>):</p>
    <div class="example"><pre>
-module(color).

-export([new/4, blend/2]).

-define(is_channel(V), (is_float(V) andalso V &gt;= 0.0 andalso V =&lt; 1.0)).

new(R,G,B,A) when ?is_channel(R), ?is_channel(G),
                  ?is_channel(B), ?is_channel(A) -&gt;
    #{red =&gt; R, green =&gt; G, blue =&gt; B, alpha =&gt; A}.

blend(Src,Dst) -&gt;
    blend(Src,Dst,alpha(Src,Dst)).

blend(Src,Dst,Alpha) when Alpha &gt; 0.0 -&gt;
    Dst#{
        red   := red(Src,Dst) / Alpha,
        green := green(Src,Dst) / Alpha,
        blue  := blue(Src,Dst) / Alpha,
        alpha := Alpha
    };
blend(_,Dst,_) -&gt;
    Dst#{
        red   := 0.0,
        green := 0.0,
        blue  := 0.0,
        alpha := 0.0
    }.

alpha(#{alpha := SA}, #{alpha := DA}) -&gt;
    SA + DA*(1.0 - SA).

red(#{red := SV, alpha := SA}, #{red := DV, alpha := DA}) -&gt;
    SV*SA + DV*DA*(1.0 - SA).
green(#{green := SV, alpha := SA}, #{green := DV, alpha := DA}) -&gt;
    SV*SA + DV*DA*(1.0 - SA).
blue(#{blue := SV, alpha := SA}, #{blue := DV, alpha := DA}) -&gt;
    SV*SA + DV*DA*(1.0 - SA).</pre></div>
    <p>Compile and test:</p>
    <div class="example"><pre>
&gt; <span class="bold_code">c(color).</span>
{ok,color}
&gt; <span class="bold_code">C1 = color:new(0.3,0.4,0.5,1.0).</span>
#{alpha =&gt; 1.0,blue =&gt; 0.5,green =&gt; 0.4,red =&gt; 0.3}
&gt; <span class="bold_code">C2 = color:new(1.0,0.8,0.1,0.3).</span>
#{alpha =&gt; 0.3,blue =&gt; 0.1,green =&gt; 0.8,red =&gt; 1.0}
&gt; <span class="bold_code">color:blend(C1,C2).</span>
#{alpha =&gt; 1.0,blue =&gt; 0.5,green =&gt; 0.4,red =&gt; 0.3}
&gt; <span class="bold_code">color:blend(C2,C1).</span>
#{alpha =&gt; 1.0,blue =&gt; 0.38,green =&gt; 0.52,red =&gt; 0.51}
</pre></div>
    <p>This example warrants some explanation:</p>
    <div class="example"><pre>
-define(is_channel(V), (is_float(V) andalso V &gt;= 0.0 andalso V =&lt; 1.0)).</pre></div>
    <p>First a macro <span class="code">is_channel</span> is defined to help with the
      guard tests. This is only here for convenience and to reduce
      syntax cluttering. For more information about macros, see
      <span class="bold_code"><a href="../reference_manual/macros.html">The Preprocessor</a></span>.
    </p>
    <div class="example"><pre>
new(R,G,B,A) when ?is_channel(R), ?is_channel(G),
                  ?is_channel(B), ?is_channel(A) -&gt;
    #{red =&gt; R, green =&gt; G, blue =&gt; B, alpha =&gt; A}.</pre></div>
    <p>The function <span class="code">new/4</span> creates a new map term and lets the keys
      <span class="code">red</span>, <span class="code">green</span>, <span class="code">blue</span>, and <span class="code">alpha</span> be
      associated with an initial value. In this case, only float
      values between and including 0.0 and 1.0 are allowed, as ensured
      by the <span class="code">?is_channel/1</span> macro for each argument. Only the
      <span class="code">=&gt;</span> operator is allowed when creating a new map.
    </p>
    <p>By calling <span class="code">blend/2</span> on any color term created by
      <span class="code">new/4</span>, the resulting color can be calculated as
      determined by the two map terms.
    </p>
    <p>The first thing <span class="code">blend/2</span> does is to calculate the
      resulting alpha channel:
    </p>
    <div class="example"><pre>
alpha(#{alpha := SA}, #{alpha := DA}) -&gt;
    SA + DA*(1.0 - SA).</pre></div>
    <p>The value associated with key <span class="code">alpha</span> is fetched for both
      arguments using the <span class="code">:=</span> operator. The other keys in the
      map are ignored, only the key <span class="code">alpha</span> is required and
      checked for.
    </p>
    <p>This is also the case for functions <span class="code">red/2</span>,
      <span class="code">blue/2</span>, and <span class="code">green/2</span>.</p>
    <div class="example"><pre>
red(#{red := SV, alpha := SA}, #{red := DV, alpha := DA}) -&gt;
    SV*SA + DV*DA*(1.0 - SA).</pre></div>
    <p>The difference here is that a check is made for two keys in
      each map argument. The other keys are ignored.
    </p>
    <p>Finally, let us return the resulting color in <span class="code">blend/3</span>:
    </p>
    <div class="example"><pre>
blend(Src,Dst,Alpha) when Alpha &gt; 0.0 -&gt;
    Dst#{
        red   := red(Src,Dst) / Alpha,
        green := green(Src,Dst) / Alpha,
        blue  := blue(Src,Dst) / Alpha,
        alpha := Alpha
    };</pre></div>
    <p>The <span class="code">Dst</span> map is updated with new channel values. The
      syntax for updating an existing key with a new value is with the
      <span class="code">:=</span> operator.
    </p>
  

  <h3><a name="id61546">2.7 
        Standard Modules and Manual Pages</a></h3>
    
    <p>Erlang has many standard modules to help you do things. For
      example, the module <span class="code">io</span> contains many functions that help
      in doing formatted input/output. To look up information about
      standard modules, the command <span class="code">erl -man</span> can be used at the
      operating shell or command prompt (the same place as you started
      <span class="code">erl</span>). Try the operating system shell command:</p>
    <div class="example"><pre>
% <span class="bold_code">erl -man io</span>
ERLANG MODULE DEFINITION                                    io(3)

MODULE
     io - Standard I/O Server Interface Functions

DESCRIPTION
     This module provides an  interface  to  standard  Erlang  IO
     servers. The output functions all return ok if they are suc-
     ...</pre></div>
    <p>If this does not work on your system, the documentation is
      included as HTML in the Erlang/OTP release. You can also read
      the documentation as HTML or download it as PDF from either of
      the sites www.erlang.se (commercial Erlang) or www.erlang.org
      (open source). For example, for Erlang/OTP release R9B:</p>
    <div class="example"><pre>
http://www.erlang.org/doc/r9b/doc/index.html</pre></div>
  

  <h3><a name="id61593">2.8 
        Writing Output to a Terminal</a></h3>
    
    <p>It is nice to be able to do formatted output in examples, so
      the next example shows a simple way to use the <span class="code">io:format</span>
      function. Like all other exported functions, you can test the
      <span class="code">io:format</span> function in the shell:</p>
    <div class="example"><pre>
31&gt; <span class="bold_code">io:format("hello world~n", []).</span>
hello world
ok
32&gt; <span class="bold_code">io:format("this outputs one Erlang term: ~w~n", [hello]).</span>
this outputs one Erlang term: hello
ok
33&gt; <span class="bold_code">io:format("this outputs two Erlang terms: ~w~w~n", [hello, world]).</span>
this outputs two Erlang terms: helloworld
ok
34&gt; <span class="bold_code">io:format("this outputs two Erlang terms: ~w ~w~n", [hello, world]).</span>
this outputs two Erlang terms: hello world
ok</pre></div>
    <p>The function <span class="code">format/2</span> (that is, <span class="code">format</span> with two
      arguments) takes two lists. The first one is nearly always a list
      written between " ". This list is printed out as it is,
      except that each ~w is replaced by a term taken in order from
      the second list. Each ~n is replaced by a new line.
      The <span class="code">io:format/2</span> function itself returns the atom <span class="code">ok</span>
      if everything goes as planned. Like other functions in Erlang, it
      crashes if an error occurs. This is not a fault in Erlang, it is
      a deliberate policy. Erlang has sophisticated mechanisms to
      handle errors which are shown later. As an exercise, try to
      make <span class="code">io:format</span> crash, it should not be difficult. But
      notice that although <span class="code">io:format</span> crashes, the Erlang shell
      itself does not crash.</p>
  

  <h3><a name="id63929">2.9 
        A Larger Example</a></h3>
    
    <p>Now for a larger example to consolidate what you have learnt so
      far. Assume that you have a list of temperature readings from a number
      of cities in the world. Some of them are in Celsius
      and some in Fahrenheit (as in the previous list). First let us
      convert them all to Celsius, then let us print the data neatly.</p>
    <div class="example"><pre>
%% This module is in file tut5.erl

-module(tut5).
-export([format_temps/1]).

%% Only this function is exported
format_temps([])-&gt;                        % No output for an empty list
    ok;
format_temps([City | Rest]) -&gt;
    print_temp(convert_to_celsius(City)),
    format_temps(Rest).

convert_to_celsius({Name, {c, Temp}}) -&gt;  % No conversion needed
    {Name, {c, Temp}};
convert_to_celsius({Name, {f, Temp}}) -&gt;  % Do the conversion
    {Name, {c, (Temp - 32) * 5 / 9}}.

print_temp({Name, {c, Temp}}) -&gt;
    io:format("~-15w ~w c~n", [Name, Temp]).</pre></div>
    <div class="example"><pre>
35&gt; <span class="bold_code">c(tut5).</span>
{ok,tut5}
36&gt; <span class="bold_code">tut5:format_temps([{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="bold_code">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
moscow          -10 c
cape_town       21.11111111111111 c
stockholm       -4 c
paris           -2.2222222222222223 c
london          2.2222222222222223 c
ok</pre></div>
    <p>Before looking at how this program works, notice that
      a few comments are added to the code. A comment starts with a
      %-character and goes on to the end of the line. Notice also that
      the <span class="code">-export([format_temps/1]).</span> line only includes
      the function <span class="code">format_temps/1</span>. The other functions are
      <strong>local</strong> functions, that is, they are not visible from outside
      the module <span class="code">tut5</span>.</p>
    <p>Notice also that when testing the program from the shell,
      the input is spread over two lines as the line was too long.</p>
    <p>When <span class="code">format_temps</span> is called the first time, <span class="code">City</span>
      gets the value <span class="code">{moscow,{c,-10}}</span> and <span class="code">Rest</span> is
      the rest of the list. So the function
      <span class="code">print_temp(convert_to_celsius({moscow,{c,-10}}))</span> is called.</p>
    <p>Here is a function call as
      <span class="code">convert_to_celsius({moscow,{c,-10}})</span> as the argument to
      the function <span class="code">print_temp</span>. When function calls are <strong>nested</strong>
      like this, they execute (evaluate) from the inside out.
      That is, first <span class="code">convert_to_celsius({moscow,{c,-10}})</span> is evaluated,
      which gives the value <span class="code">{moscow,{c,-10}}</span> as the temperature
      is already in Celsius. Then <span class="code">print_temp({moscow,{c,-10}})</span>
      is evaluated.
      The function <span class="code">convert_to_celsius</span> works in a similar way to
      the <span class="code">convert_length</span> function in the previous example.</p>
    <p><span class="code">print_temp</span> simply calls <span class="code">io:format</span> in a similar way
      to what has been described above. Notice that ~-15w says to print
      the "term" with a field length (width) of 15 and left justify it.
      (see the <span class="bold_code"><a href="../man/io.html#fwrite-1">io(3)</a></span>) manual page in STDLIB.</p>
    <p>Now <span class="code">format_temps(Rest)</span> is called with the rest of the list
      as an argument. This way of doing things is similar to the loop
      constructs in other languages. (Yes, this is recursion, but do not
      let that worry you.) So the same <span class="code">format_temps</span> function is
      called again, this time <span class="code">City</span> gets the value
      <span class="code">{cape_town,{f,70}}</span> and the same procedure is repeated as
      before. This is done until the list becomes empty, that is [],
      which causes the first clause <span class="code">format_temps([])</span> to match.
      This simply returns (results in) the atom <span class="code">ok</span>, so
      the program ends.</p>
  

  <h3><a name="id64103">2.10 
        Matching, Guards, and Scope of Variables</a></h3>
    
    <p>It can be useful to find the maximum and minimum temperature
      in lists like this. Before extending the program to do this,
      let us look at functions for finding the maximum value of
      the elements in a list:</p>
    <div class="example"><pre>
-module(tut6).
-export([list_max/1]).

list_max([Head|Rest]) -&gt;
   list_max(Rest, Head).

list_max([], Res) -&gt;
    Res;
list_max([Head|Rest], Result_so_far) when Head &gt; Result_so_far -&gt;
    list_max(Rest, Head);
list_max([Head|Rest], Result_so_far)  -&gt;
    list_max(Rest, Result_so_far).</pre></div>
    <div class="example"><pre>
37&gt; <span class="bold_code">c(tut6).</span>
{ok,tut6}
38&gt; <span class="bold_code">tut6:list_max([1,2,3,4,5,7,4,3,2,1]).</span>
7</pre></div>
    <p>First notice that two functions have the same name,
      <span class="code">list_max</span>. However, each of these takes a different number
      of arguments (parameters). In Erlang these are regarded as
      completely different functions. Where you need to distinguish
      between these functions, you write Name/Arity, where
      Name is the function name and Arity is
      the number of arguments, in this case <span class="code">list_max/1</span> and
      <span class="code">list_max/2</span>.</p>
    <p>In this example you walk through a list "carrying" a
      value, in this case <span class="code">Result_so_far</span>.
      <span class="code">list_max/1</span> simply assumes that the max value of the list
      is the head of the list and calls <span class="code">list_max/2</span> with the rest
      of the list and the value of the head of the list. In the above
      this would be <span class="code">list_max([2,3,4,5,7,4,3,2,1],1)</span>. If you tried
      to use <span class="code">list_max/1</span> with an empty list or tried to use it
      with something that is not a list at all, you would cause an error.
      Notice that the Erlang philosophy is not to handle errors of this
      type in the function they occur, but to do so elsewhere. More
      about this later.</p>
    <p>In <span class="code">list_max/2</span>, you walk down the list and use <span class="code">Head</span>
      instead of <span class="code">Result_so_far</span> when <span class="code">Head</span> &gt;
      <span class="code">Result_so_far</span>. <span class="code">when</span> is a special word used before
      the -&gt; in the function to say that you only use this part
      of the function if the test that follows is true. A test
      of this type is called <strong>guard</strong>. If the guard is false (that is,
      the guard fails), the next part of the function is tried. In this
      case, if <span class="code">Head</span> is not greater than <span class="code">Result_so_far</span>, then
      it must be smaller or equal to it. This means that a guard on
      the next part of the function is not needed.</p>
    <p>Some useful operators in guards are:
    </p>
<ul>
<li>&lt; less than</li>
    <li>&gt; greater than</li>
    <li>== equal</li>
    <li>&gt;= greater or equal</li>
    <li>=&lt; less or equal</li>
    <li>/= not equal</li>
</ul>
    <p>(see <span class="bold_code"><a href="../reference_manual/expressions.html">Guard Sequences</a></span>).</p>
    <p>To change the above program to one that works out the minimum
      value of the element in a list, you only need to
      write &lt; instead of &gt;. (But it would be wise to change
      the name of the function to <span class="code">list_min</span>.)</p>
    <p>Earlier it was mentioned that a variable can only be
      given a value once in its scope. In the above you see
      that <span class="code">Result_so_far</span> is given several values. This is
      OK since every time you call <span class="code">list_max/2</span> you create a new
      scope and one can regard <span class="code">Result_so_far</span> as a
      different variable in each scope.</p>
    <p>Another way of creating and giving a variable a value is by using
      the match operator = . So if you write <span class="code">M = 5</span>, a variable
      called <span class="code">M</span> is created with the value 5. If, in
      the same scope, you then write <span class="code">M = 6</span>, an error is returned. Try
      this out in the shell:</p>
    <div class="example"><pre>
39&gt; <span class="bold_code">M = 5.</span>
5
40&gt; <span class="bold_code">M = 6.</span>
** exception error: no match of right hand side value 6
41&gt; <span class="bold_code">M = M + 1.</span>
** exception error: no match of right hand side value 6
42&gt; <span class="bold_code">N = M + 1.</span>
6</pre></div>
    <p>The use of the match operator is particularly useful for pulling
      apart Erlang terms and creating new ones.</p>
    <div class="example"><pre>
43&gt; <span class="bold_code">{X, Y} = {paris, {f, 28}}.</span>
{paris,{f,28}}
44&gt; <span class="bold_code">X.</span>
paris
45&gt; <span class="bold_code">Y.</span>
{f,28}</pre></div>
    <p>Here <span class="code">X</span> gets the value <span class="code">paris</span> and
      <span class="code">Y</span><span class="code">{f,28}</span>.</p>
    <p>If you try to do the same again with another city,
      an error is returned:</p>
    <div class="example"><pre>
46&gt; <span class="bold_code">{X, Y} = {london, {f, 36}}.</span>
** exception error: no match of right hand side value {london,{f,36}}</pre></div>
    <p>Variables can also be used to improve the readability of
      programs. For example, in function <span class="code">list_max/2</span> above,
      you can write:</p>
    <div class="example"><pre>
list_max([Head|Rest], Result_so_far) when Head &gt; Result_so_far -&gt;
    New_result_far = Head,
    list_max(Rest, New_result_far);</pre></div>
    <p>This is possibly a little clearer.</p>
  

  <h3><a name="id67551">2.11 
        More About Lists</a></h3>
    
    <p>Remember that the | operator can be used to get the head of a
      list:</p>
    <div class="example"><pre>
47&gt; <span class="bold_code">[M1|T1] = [paris, london, rome].</span>
[paris,london,rome]
48&gt; <span class="bold_code">M1.</span>
paris
49&gt; <span class="bold_code">T1.</span>
[london,rome]</pre></div>
    <p>The | operator can also be used to add a head to a list:</p>
    <div class="example"><pre>
50&gt; <span class="bold_code">L1 = [madrid | T1].</span>
[madrid,london,rome]
51&gt; <span class="bold_code">L1.</span>
[madrid,london,rome]</pre></div>
    <p>Now an example of this when working with lists - reversing
      the order of a list:</p>
    <div class="example"><pre>
-module(tut8).

-export([reverse/1]).

reverse(List) -&gt;
    reverse(List, []).

reverse([Head | Rest], Reversed_List) -&gt;
    reverse(Rest, [Head | Reversed_List]);
reverse([], Reversed_List) -&gt;
    Reversed_List.</pre></div>
    <div class="example"><pre>
52&gt; <span class="bold_code">c(tut8).</span>
{ok,tut8}
53&gt; <span class="bold_code">tut8:reverse([1,2,3]).</span>
[3,2,1]</pre></div>
    <p>Consider how <span class="code">Reversed_List</span> is built. It starts as [],
      then successively the heads are taken off of the list to be reversed
      and added to the the <span class="code">Reversed_List</span>, as shown in
      the following:</p>
    <div class="example"><pre>
reverse([1|2,3], []) =&gt;
    reverse([2,3], [1|[]])

reverse([2|3], [1]) =&gt;
    reverse([3], [2|[1])

reverse([3|[]], [2,1]) =&gt;
    reverse([], [3|[2,1]])

reverse([], [3,2,1]) =&gt;
    [3,2,1]</pre></div>
    <p>The module <span class="code">lists</span> contains many functions for
      manipulating lists, for example, for reversing them. So before
      writing a list-manipulating function it is a good idea to check
      if one not already is written for you
      (see the <span class="bold_code"><a href="../man/lists.html">lists(3)</a></span>
      manual page in STDLIB).</p>
    <p>Now let us get back to the cities and temperatures, but take a more
      structured approach this time. First let us convert the whole list
      to Celsius as follows:</p>
    <div class="example"><pre>
-module(tut7).
-export([format_temps/1]).

format_temps(List_of_cities) -&gt;
    convert_list_to_c(List_of_cities).

convert_list_to_c([{Name, {f, F}} | Rest]) -&gt;
    Converted_City = {Name, {c, (F -32)* 5 / 9}},
    [Converted_City | convert_list_to_c(Rest)];

convert_list_to_c([City | Rest]) -&gt;
    [City | convert_list_to_c(Rest)];

convert_list_to_c([]) -&gt;
    [].</pre></div>
    <p>Test the function:</p>
    <div class="example"><pre>
54&gt; <span class="bold_code">c(tut7).</span>
{ok, tut7}.
55&gt; <span class="bold_code">tut7:format_temps([{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="bold_code">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
[{moscow,{c,-10}},
 {cape_town,{c,21.11111111111111}},
 {stockholm,{c,-4}},
 {paris,{c,-2.2222222222222223}},
 {london,{c,2.2222222222222223}}]</pre></div>
    <p>Explanation:</p>
    <div class="example"><pre>
format_temps(List_of_cities) -&gt;
    convert_list_to_c(List_of_cities).</pre></div>
    <p>Here <span class="code">format_temps/1</span> calls
      <span class="code">convert_list_to_c/1</span>. <span class="code">convert_list_to_c/1</span> takes off
      the head of the <span class="code">List_of_cities</span>, converts it to Celsius if
      needed. The | operator is used to add the (maybe) converted
      to the converted rest of the list:</p>
    <div class="example"><pre>
[Converted_City | convert_list_to_c(Rest)];</pre></div>
    <p>or:</p>
    <div class="example"><pre>
[City | convert_list_to_c(Rest)];</pre></div>
    <p>This is done until the end of the list is reached, that is,
      the list is empty:</p>
    <div class="example"><pre>
convert_list_to_c([]) -&gt;
    [].</pre></div>
    <p>Now when the list is converted, a function to print it is added:</p>
    <div class="example"><pre>
-module(tut7).
-export([format_temps/1]).

format_temps(List_of_cities) -&gt;
    Converted_List = convert_list_to_c(List_of_cities),
    print_temp(Converted_List).

convert_list_to_c([{Name, {f, F}} | Rest]) -&gt;
    Converted_City = {Name, {c, (F -32)* 5 / 9}},
    [Converted_City | convert_list_to_c(Rest)];

convert_list_to_c([City | Rest]) -&gt;
    [City | convert_list_to_c(Rest)];

convert_list_to_c([]) -&gt;
    [].

print_temp([{Name, {c, Temp}} | Rest]) -&gt;
    io:format("~-15w ~w c~n", [Name, Temp]),
    print_temp(Rest);
print_temp([]) -&gt;
    ok.</pre></div>
    <div class="example"><pre>
56&gt; <span class="bold_code">c(tut7).</span>
{ok,tut7}
57&gt; <span class="bold_code">tut7:format_temps([{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="bold_code">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
moscow          -10 c
cape_town       21.11111111111111 c
stockholm       -4 c
paris           -2.2222222222222223 c
london          2.2222222222222223 c
ok</pre></div>
    <p>Now a function has to be added to find the cities with
      the maximum and minimum temperatures. The following program is not
      the most efficient way of doing this as you walk through the list
      of cities four times. But it is better to first strive for
      clarity and correctness and to make programs efficient only if
      needed.</p>
    <div class="example"><pre>
-module(tut7).
-export([format_temps/1]).

format_temps(List_of_cities) -&gt;
    Converted_List = convert_list_to_c(List_of_cities),
    print_temp(Converted_List),
    {Max_city, Min_city} = find_max_and_min(Converted_List),
    print_max_and_min(Max_city, Min_city).

convert_list_to_c([{Name, {f, Temp}} | Rest]) -&gt;
    Converted_City = {Name, {c, (Temp -32)* 5 / 9}},
    [Converted_City | convert_list_to_c(Rest)];

convert_list_to_c([City | Rest]) -&gt;
    [City | convert_list_to_c(Rest)];

convert_list_to_c([]) -&gt;
    [].

print_temp([{Name, {c, Temp}} | Rest]) -&gt;
    io:format("~-15w ~w c~n", [Name, Temp]),
    print_temp(Rest);
print_temp([]) -&gt;
    ok.

find_max_and_min([City | Rest]) -&gt;
    find_max_and_min(Rest, City, City).

find_max_and_min([{Name, {c, Temp}} | Rest], 
         {Max_Name, {c, Max_Temp}}, 
         {Min_Name, {c, Min_Temp}}) -&gt;
    if 
        Temp &gt; Max_Temp -&gt;
            Max_City = {Name, {c, Temp}};           % Change
        true -&gt; 
            Max_City = {Max_Name, {c, Max_Temp}} % Unchanged
    end,
    if
         Temp &lt; Min_Temp -&gt;
            Min_City = {Name, {c, Temp}};           % Change
        true -&gt; 
            Min_City = {Min_Name, {c, Min_Temp}} % Unchanged
    end,
    find_max_and_min(Rest, Max_City, Min_City);

find_max_and_min([], Max_City, Min_City) -&gt;
    {Max_City, Min_City}.

print_max_and_min({Max_name, {c, Max_temp}}, {Min_name, {c, Min_temp}}) -&gt;
    io:format("Max temperature was ~w c in ~w~n", [Max_temp, Max_name]),
    io:format("Min temperature was ~w c in ~w~n", [Min_temp, Min_name]).</pre></div>
<div class="example"><pre>
58&gt; <span class="bold_code">c(tut7).</span>
{ok, tut7}
59&gt; <span class="bold_code">tut7:format_temps([{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="bold_code">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
moscow          -10 c
cape_town       21.11111111111111 c
stockholm       -4 c
paris           -2.2222222222222223 c
london          2.2222222222222223 c
Max temperature was 21.11111111111111 c in cape_town
Min temperature was -10 c in moscow
ok</pre></div>
  

  <h3><a name="id67816">2.12 
        If and Case</a></h3>
    
    <p>The function <span class="code">find_max_and_min</span> works out the maximum and
      minimum temperature. A new construct, <span class="code">if</span>, is introduced here.
      If works as follows:</p>
    <div class="example"><pre>
if
    Condition 1 -&gt;
        Action 1;
    Condition 2 -&gt;
        Action 2;
    Condition 3 -&gt;
        Action 3;
    Condition 4 -&gt;
        Action 4
end</pre></div>
    <p>Notice that there is no ";" before <span class="code">end</span>. Conditions do
      the same as guards, that is, tests that succeed or fail. Erlang
      starts at the top
      and tests until it finds a condition that succeeds. Then it evaluates
      (performs) the action following the condition and ignores all
      other conditions and actions before the <span class="code">end</span>. If no
      condition matches, a run-time failure occurs. A condition
      that always succeeds is the atom <span class="code">true</span>. This is
      often used last in an <span class="code">if</span>, meaning, do the action following
      the <span class="code">true</span> if all other conditions have failed.</p>
    <p>The following is a short program to show the workings of
      <span class="code">if</span>.</p>
    <div class="example"><pre>
-module(tut9).
-export([test_if/2]).

test_if(A, B) -&gt;
    if 
        A == 5 -&gt;
            io:format("A == 5~n", []),
            a_equals_5;
        B == 6 -&gt;
            io:format("B == 6~n", []),
            b_equals_6;
        A == 2, B == 3 -&gt;                      %That is A equals 2 and B equals 3
            io:format("A == 2, B == 3~n", []),
            a_equals_2_b_equals_3;
        A == 1 ; B == 7 -&gt;                     %That is A equals 1 or B equals 7
            io:format("A == 1 ; B == 7~n", []),
            a_equals_1_or_b_equals_7
    end.</pre></div>
    <p>Testing this program gives:</p>
    <div class="example"><pre>
60&gt; <span class="bold_code">c(tut9).</span>
{ok,tut9}
61&gt; <span class="bold_code">tut9:test_if(5,33).</span>
A == 5
a_equals_5
62&gt; <span class="bold_code">tut9:test_if(33,6).</span>
B == 6
b_equals_6
63&gt; <span class="bold_code">tut9:test_if(2, 3).</span>
A == 2, B == 3
a_equals_2_b_equals_3
64&gt; <span class="bold_code">tut9:test_if(1, 33).</span>
A == 1 ; B == 7
a_equals_1_or_b_equals_7
65&gt; <span class="bold_code">tut9:test_if(33, 7).</span>
A == 1 ; B == 7
a_equals_1_or_b_equals_7
66&gt; <span class="bold_code">tut9:test_if(33, 33).</span>
** exception error: no true branch found when evaluating an if expression
     in function  tut9:test_if/2 (tut9.erl, line 5)</pre></div>
    <p>Notice that <span class="code">tut9:test_if(33,33)</span> does not cause any
      condition to succeed. This leads to the run time error
      <span class="code">if_clause</span>, here nicely formatted by the shell. See
      <span class="bold_code"><a href="../reference_manual/expressions.html">Guard Sequences</a></span>
      for details of the many guard tests available.</p>
    <p><span class="code">case</span> is another construct in Erlang. Recall that the
      <span class="code">convert_length</span> function was written as:</p>
    <div class="example"><pre>
convert_length({centimeter, X}) -&gt;
    {inch, X / 2.54};
convert_length({inch, Y}) -&gt;
    {centimeter, Y * 2.54}.</pre></div>
    <p>The same program can also be written as:</p>
    <div class="example"><pre>
-module(tut10).
-export([convert_length/1]).

convert_length(Length) -&gt;
    case Length of
        {centimeter, X} -&gt;
            {inch, X / 2.54};
        {inch, Y} -&gt;
            {centimeter, Y * 2.54}
    end.</pre></div>
    <div class="example"><pre>
67&gt; <span class="bold_code">c(tut10).</span>
{ok,tut10}
68&gt; <span class="bold_code">tut10:convert_length({inch, 6}).</span>
{centimeter,15.24}
69&gt; <span class="bold_code">tut10:convert_length({centimeter, 2.5}).</span>
{inch,0.984251968503937}</pre></div>
    <p>Both <span class="code">case</span> and <span class="code">if</span> have <strong>return values</strong>, that is,
      in the above example <span class="code">case</span> returned
      either <span class="code">{inch,X/2.54}</span> or <span class="code">{centimeter,Y*2.54}</span>.
      The behaviour of <span class="code">case</span> can also be modified by using guards.
      The following example clarifies this. It
      tells us the length of a month, given the year.
      The year must be known, since February has 29 days in a leap year.</p>
    <div class="example"><pre>
-module(tut11).
-export([month_length/2]).

month_length(Year, Month) -&gt;
    %% All years divisible by 400 are leap
    %% Years divisible by 100 are not leap (except the 400 rule above)
    %% Years divisible by 4 are leap (except the 100 rule above)
    Leap = if
        trunc(Year / 400) * 400 == Year -&gt;
            leap;
        trunc(Year / 100) * 100 == Year -&gt;
            not_leap;
        trunc(Year / 4) * 4 == Year -&gt;
            leap;
        true -&gt;
            not_leap
    end,  
    case Month of
        sep -&gt; 30;
        apr -&gt; 30;
        jun -&gt; 30;
        nov -&gt; 30;
        feb when Leap == leap -&gt; 29;
        feb -&gt; 28;
        jan -&gt; 31;
        mar -&gt; 31;
        may -&gt; 31;
        jul -&gt; 31;
        aug -&gt; 31;
        oct -&gt; 31;
        dec -&gt; 31
    end.</pre></div>
    <div class="example"><pre>
70&gt; <span class="bold_code">c(tut11).</span>
{ok,tut11}
71&gt; <span class="bold_code">tut11:month_length(2004, feb).</span>
29
72&gt; <span class="bold_code">tut11:month_length(2003, feb).</span>
28
73&gt; <span class="bold_code">tut11:month_length(1947, aug).</span>
31</pre></div>
  

  <h3><a name="id68048">2.13 
        Built-In Functions (BIFs)</a></h3>
    
    <p>BIFs are functions that for some reason are
      built-in to the Erlang virtual machine. BIFs often implement
      functionality that is impossible or is too
      inefficient to implement in Erlang. Some BIFs can be called
      using the function name only but they are by default belonging
      to the <span class="code">erlang</span> module. For example, the call to the
      BIF <span class="code">trunc</span>
      below is equivalent to a call to <span class="code">erlang:trunc</span>.</p>
    <p>As shown, first it is checked if a year is leap. If a
      year is divisible by 400, it is a leap year. To determine this,
      first divide the year by 400 and use the BIF
      <span class="code">trunc</span> (more about this later) to cut off any decimals. Then
      multiply by 400 again and see if the same value is returned again.
      For example, year 2004:</p>
    <div class="example"><pre>
2004 / 400 = 5.01
trunc(5.01) = 5
5 * 400 = 2000</pre></div>
    <p>2000 is not the same as 2004, so 2004 is not divisible by 400.
    Year 2000:</p>
    <div class="example"><pre>
2000 / 400 = 5.0
trunc(5.0) = 5
5 * 400 = 2000</pre></div>
    <p>That is, a leap year. The next two <span class="code">trunc</span>-tests evaluate
      if the year is divisible by 100 or 4 in the same way. The first
      <span class="code">if</span> returns <span class="code">leap</span> or <span class="code">not_leap</span>, which lands up
      in the variable <span class="code">Leap</span>. This variable is used in the guard
      for <span class="code">feb</span> in the following <span class="code">case</span> that tells us how
      long the month is.</p>
    <p>This example showed the use of <span class="code">trunc</span>. It is easier
      to use the Erlang operator <span class="code">rem</span> that gives the remainder
      after division, for example:</p>
    <div class="example"><pre>
74&gt; <span class="bold_code">2004 rem 400.</span>
4</pre></div>
    <p>So instead of writing:</p>
    <div class="example"><pre>
trunc(Year / 400) * 400 == Year -&gt;
    leap;</pre></div>
    <p>it can be written:</p>
    <div class="example"><pre>
Year rem 400 == 0 -&gt;
    leap;</pre></div>
    <p>There are many other BIFs such as
      <span class="code">trunc</span>. Only a few BIFs can be used in guards,
      and you cannot use functions you have defined yourself in guards.
      (see
      <span class="bold_code"><a href="../reference_manual/expressions.html">Guard Sequences</a></span>)
      (For advanced readers: This is to ensure that guards do not have side
      effects.) Let us play with a few of these functions in the shell:</p>
    <div class="example"><pre>
75&gt; <span class="bold_code">trunc(5.6).</span>
5
76&gt; <span class="bold_code">round(5.6).</span>
6
77&gt; <span class="bold_code">length([a,b,c,d]).</span>
4
78&gt; <span class="bold_code">float(5).</span>
5.0
79&gt; <span class="bold_code">is_atom(hello).</span>
true
80&gt; <span class="bold_code">is_atom("hello").</span>
false
81&gt; <span class="bold_code">is_tuple({paris, {c, 30}}).</span>
true
82&gt; <span class="bold_code">is_tuple([paris, {c, 30}]).</span>
false</pre></div>
    <p>All of these can be used in guards. Now for some BIFs that cannot be
      used in guards:</p>
    <div class="example"><pre>
83&gt; <span class="bold_code">atom_to_list(hello).</span>
"hello"
84&gt; <span class="bold_code">list_to_atom("goodbye").</span>
goodbye
85&gt; <span class="bold_code">integer_to_list(22).</span>
"22"</pre></div>
    <p>These three BIFs do conversions that would be difficult (or
      impossible) to do in Erlang.</p>
  

  <h3><a name="id68245">2.14 
        Higher-Order Functions (Funs)</a></h3>
    
    <p>Erlang, like most modern functional programming languages, has
      higher-order functions. Here is an example using the shell:</p>
    <div class="example"><pre>
86&gt; <span class="bold_code">Xf = fun(X) -&gt; X * 2 end.</span>
#Fun&lt;erl_eval.5.123085357&gt;
87&gt; <span class="bold_code">Xf(5).</span>
10</pre></div>
    <p>Here is defined a function that doubles
      the value of a number and assigned this function to a variable. Thus
      <span class="code">Xf(5)</span> returns value 10. Two useful functions when
      working with lists are <span class="code">foreach</span> and <span class="code">map</span>, which are
      defined as follows:</p>
    <div class="example"><pre>
foreach(Fun, [First|Rest]) -&gt;
    Fun(First),
    foreach(Fun, Rest);
foreach(Fun, []) -&gt;
    ok.

map(Fun, [First|Rest]) -&gt; 
    [Fun(First)|map(Fun,Rest)];
map(Fun, []) -&gt; 
    [].</pre></div>
    <p>These two functions are provided in the standard module
      <span class="code">lists</span>. <span class="code">foreach</span> takes a list and applies a fun to
      every element in the list. <span class="code">map</span> creates a new list by
      applying a fun to every element in a list. Going back to
      the shell, <span class="code">map</span> is used and a fun to add 3 to
      every element of a list:</p>
    <div class="example"><pre>
88&gt; <span class="bold_code">Add_3 = fun(X) -&gt; X + 3 end.</span>
#Fun&lt;erl_eval.5.123085357&gt;
89&gt; <span class="bold_code">lists:map(Add_3, [1,2,3]).</span>
[4,5,6]</pre></div>
    <p>Let us (again) print the temperatures in a list of cities:</p>
    <div class="example"><pre>
90&gt; <span class="bold_code">Print_City = fun({City, {X, Temp}}) -&gt; io:format("~-15w ~w ~w~n",</span>
<span class="bold_code">[City, X, Temp]) end.</span>
#Fun&lt;erl_eval.5.123085357&gt;
91&gt; <span class="bold_code">lists:foreach(Print_City, [{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="bold_code">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
moscow          c -10
cape_town       f 70
stockholm       c -4
paris           f 28
london          f 36
ok</pre></div>
    <p>Let us now define a fun that can be used to go through a list
      of cities and temperatures and transform them all to Celsius.</p>
    <div class="example"><pre>
-module(tut13).

-export([convert_list_to_c/1]).

convert_to_c({Name, {f, Temp}}) -&gt;
    {Name, {c, trunc((Temp - 32) * 5 / 9)}};
convert_to_c({Name, {c, Temp}}) -&gt;
    {Name, {c, Temp}}.

convert_list_to_c(List) -&gt;
    lists:map(fun convert_to_c/1, List).</pre></div>
    <div class="example"><pre>
92&gt; <span class="bold_code">tut13:convert_list_to_c([{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="bold_code">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
[{moscow,{c,-10}},
 {cape_town,{c,21}},
 {stockholm,{c,-4}},
 {paris,{c,-2}},
 {london,{c,2}}]</pre></div>
    <p>The <span class="code">convert_to_c</span> function is the same as before, but here
      it is used as a fun:</p>
    <div class="example"><pre>
lists:map(fun convert_to_c/1, List)</pre></div>
    <p>When a function defined elsewhere is used as a fun, it can be referred
      to as <span class="code">Function/Arity</span> (remember that <span class="code">Arity</span> =
      number of arguments). So in the <span class="code">map</span>-call
      <span class="code">lists:map(fun convert_to_c/1, List)</span> is written. As shown,
      <span class="code">convert_list_to_c</span> becomes much shorter and easier to
      understand.</p>
    <p>The standard module <span class="code">lists</span> also contains a function
      <span class="code">sort(Fun, List)</span> where <span class="code">Fun</span> is a fun with two
      arguments. This fun returns <span class="code">true</span> if the first
      argument is less than the second argument, or else <span class="code">false</span>.
      Sorting is added to the <span class="code">convert_list_to_c</span>:</p>
    <div class="example"><pre>
-module(tut13).

-export([convert_list_to_c/1]).

convert_to_c({Name, {f, Temp}}) -&gt;
    {Name, {c, trunc((Temp - 32) * 5 / 9)}};
convert_to_c({Name, {c, Temp}}) -&gt;
    {Name, {c, Temp}}.

convert_list_to_c(List) -&gt;
    New_list = lists:map(fun convert_to_c/1, List),
    lists:sort(fun({_, {c, Temp1}}, {_, {c, Temp2}}) -&gt;
                       Temp1 &lt; Temp2 end, New_list).</pre></div>
    <div class="example"><pre>
93&gt; <span class="bold_code">c(tut13).</span>
{ok,tut13}
94&gt; <span class="bold_code">tut13:convert_list_to_c([{moscow, {c, -10}}, {cape_town, {f, 70}},</span>
<span class="bold_code">{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).</span>
[{moscow,{c,-10}},
 {stockholm,{c,-4}},
 {paris,{c,-2}},
 {london,{c,2}},
 {cape_town,{c,21}}]</pre></div>
    <p>In <span class="code">sort</span> the fun is used:</p>
    <div class="example"><pre>
fun({_, {c, Temp1}}, {_, {c, Temp2}}) -&gt; Temp1 &lt; Temp2 end,</pre></div>
    <p>Here the concept of an <strong>anonymous variable</strong>
      "_" is introduced. This is simply shorthand for a variable that
      gets a value, but the value is ignored. This can be used
      anywhere suitable, not just in funs. <span class="code">Temp1 &lt; Temp2</span>
      returns <span class="code">true</span> if <span class="code">Temp1</span> is less than <span class="code">Temp2</span>.</p>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1996-2017 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
