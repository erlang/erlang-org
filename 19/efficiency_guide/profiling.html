<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- Profiling</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="../pdf/otp-system-documentation.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Efficiency Guide</strong><br><strong>User's Guide</strong><br><small>Version 8.3</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="introduction.html">
              Top of chapter
            </a></li>
<li title="Purpose"><a href="introduction.html#id65906">Purpose</a></li>
<li title="Prerequisites"><a href="introduction.html#id63584">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="The Eight Myths of Erlang Performance" expanded="false">The Eight Myths of Erlang Performance<ul>
<li><a href="myths.html">
              Top of chapter
            </a></li>
<li title="Myth: Funs are Slow"><a href="myths.html#id63567">Myth: Funs are Slow</a></li>
<li title="Myth: List Comprehensions are Slow"><a href="myths.html#id63557">Myth: List Comprehensions are Slow</a></li>
<li title="Myth: Tail-Recursive Functions are Much Faster
    Than Recursive Functions"><a href="myths.html#id61999">Myth: Tail-Recursive Functions are Much Faster
    Than Recursive Functions</a></li>
<li title='Myth: Operator "++" is Always Bad'><a href="myths.html#id62699">Myth: Operator "++" is Always Bad</a></li>
<li title="Myth: Strings are Slow"><a href="myths.html#id57470">Myth: Strings are Slow</a></li>
<li title="Myth: Repairing a Dets File is Very Slow"><a href="myths.html#id62187">Myth: Repairing a Dets File is Very Slow</a></li>
<li title="Myth: BEAM is a Stack-Based Byte-Code Virtual Machine
    (and Therefore Slow)"><a href="myths.html#id62360">Myth: BEAM is a Stack-Based Byte-Code Virtual Machine
    (and Therefore Slow)</a></li>
<li title='Myth: Use "_" to Speed Up Your Program When a Variable
    is Not Used'><a href="myths.html#id62365">Myth: Use "_" to Speed Up Your Program When a Variable
    is Not Used</a></li>
</ul>
</li>
<li id="no" title="Common Caveats" expanded="false">Common Caveats<ul>
<li><a href="commoncaveats.html">
              Top of chapter
            </a></li>
<li title="Timer Module"><a href="commoncaveats.html#id65897">Timer Module</a></li>
<li title="list_to_atom/1"><a href="commoncaveats.html#id64815">list_to_atom/1</a></li>
<li title="length/1"><a href="commoncaveats.html#id59764">length/1</a></li>
<li title="setelement/3"><a href="commoncaveats.html#id61742">setelement/3</a></li>
<li title="size/1"><a href="commoncaveats.html#id66313">size/1</a></li>
<li title="split_binary/2"><a href="commoncaveats.html#id65292">split_binary/2</a></li>
<li title='Operator "--"'><a href="commoncaveats.html#id64604">Operator "--"</a></li>
</ul>
</li>
<li id="no" title="Constructing and Matching Binaries" expanded="false">Constructing and Matching Binaries<ul>
<li><a href="binaryhandling.html">
              Top of chapter
            </a></li>
<li title="How Binaries are Implemented"><a href="binaryhandling.html#id61539">How Binaries are Implemented</a></li>
<li title="Constructing Binaries"><a href="binaryhandling.html#id66208">Constructing Binaries</a></li>
<li title="Matching Binaries"><a href="binaryhandling.html#id65492">Matching Binaries</a></li>
</ul>
</li>
<li id="no" title="List Handling" expanded="false">List Handling<ul>
<li><a href="listHandling.html">
              Top of chapter
            </a></li>
<li title="Creating a List"><a href="listHandling.html#id68198">Creating a List</a></li>
<li title="List Comprehensions"><a href="listHandling.html#id68294">List Comprehensions</a></li>
<li title="Deep and Flat Lists"><a href="listHandling.html#id68364">Deep and Flat Lists</a></li>
<li title="Recursive List Functions"><a href="listHandling.html#id68511">Recursive List Functions</a></li>
</ul>
</li>
<li id="no" title="Functions" expanded="false">Functions<ul>
<li><a href="functions.html">
              Top of chapter
            </a></li>
<li title="Pattern Matching"><a href="functions.html#id68638">Pattern Matching</a></li>
<li title="Function Calls"><a href="functions.html#id68868">Function Calls</a></li>
<li title="Memory Usage in Recursion"><a href="functions.html#id69008">Memory Usage in Recursion</a></li>
</ul>
</li>
<li id="no" title="Tables and Databases" expanded="false">Tables and Databases<ul>
<li><a href="tablesDatabases.html">
              Top of chapter
            </a></li>
<li title="Ets, Dets, and Mnesia"><a href="tablesDatabases.html#id69098">Ets, Dets, and Mnesia</a></li>
<li title="Ets-Specific"><a href="tablesDatabases.html#id69496">Ets-Specific</a></li>
<li title="Mnesia-Specific"><a href="tablesDatabases.html#id69606">Mnesia-Specific</a></li>
</ul>
</li>
<li id="no" title="Processes" expanded="false">Processes<ul>
<li><a href="processes.html">
              Top of chapter
            </a></li>
<li title="Creating an Erlang Process"><a href="processes.html#id69726">Creating an Erlang Process</a></li>
<li title="Process Messages"><a href="processes.html#id69887">Process Messages</a></li>
<li title="SMP Emulator"><a href="processes.html#id70096">SMP Emulator</a></li>
</ul>
</li>
<li id="no" title="Drivers" expanded="false">Drivers<ul>
<li><a href="drivers.html">
              Top of chapter
            </a></li>
<li title="Drivers and Concurrency"><a href="drivers.html#id70202">Drivers and Concurrency</a></li>
<li title="Avoiding Copying Binaries When Calling a Driver"><a href="drivers.html#id70243">Avoiding Copying Binaries When Calling a Driver</a></li>
<li title="Returning Small Binaries from a Driver"><a href="drivers.html#id70318">Returning Small Binaries from a Driver</a></li>
<li title="Returning Large Binaries without Copying from a Driver"><a href="drivers.html#id70353">Returning Large Binaries without Copying from a Driver</a></li>
</ul>
</li>
<li id="no" title="Advanced" expanded="false">Advanced<ul>
<li><a href="advanced.html">
              Top of chapter
            </a></li>
<li title="Memory"><a href="advanced.html#id70488">Memory</a></li>
<li title="System Limits"><a href="advanced.html#id70924">System Limits</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Profiling" expanded="true">Profiling<ul>
<li><a href="profiling.html">
              Top of chapter
            </a></li>
<li title="Do Not Guess About Performance - Profile"><a href="profiling.html#id71474">Do Not Guess About Performance - Profile</a></li>
<li title="Large Systems"><a href="profiling.html#id71572">Large Systems</a></li>
<li title="What to Look For"><a href="profiling.html#id71592">What to Look For</a></li>
<li title="Tools"><a href="profiling.html#id71649">Tools</a></li>
<li title="Benchmarking"><a href="profiling.html#id72188">Benchmarking</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>11 Profiling</h1>
  

  <h3><a name="id71474">11.1 
        Do Not Guess About Performance - Profile</a></h3>
    

    <p>Even experienced software developers often guess wrong about where
    the performance bottlenecks are in their programs. Therefore, profile
    your program to see where the performance
    bottlenecks are and concentrate on optimizing them.</p>

    <p>Erlang/OTP contains several tools to help finding bottlenecks:</p>

    <ul>
      <li>
<span class="code">fprof</span> provides the most detailed information about
      where the program time is spent, but it significantly slows down the
      program it profiles.</li>

      <li>
<p><span class="code">eprof</span> provides time information of each function
      used in the program. No call graph is produced, but <span class="code">eprof</span> has
      considerable less impact on the program it profiles.</p>
      <p>If the program is too large to be profiled by <span class="code">fprof</span> or
      <span class="code">eprof</span>, the <span class="code">cover</span> and <span class="code">cprof</span> tools can be used
      to locate code parts that are to be more thoroughly profiled using
      <span class="code">fprof</span> or <span class="code">eprof</span>.</p>
</li>

      <li>
<span class="code">cover</span> provides execution counts per line per
      process, with less overhead than <span class="code">fprof</span>. Execution counts
      can, with some caution, be used to locate potential performance
      bottlenecks.</li>

      <li>
<span class="code">cprof</span> is the most lightweight tool, but it only
      provides execution counts on a function basis (for all processes,
      not per process).</li>
    </ul>

    <p>The tools are further described in
    <span class="bold_code"><a href="#profiling_tools">Tools</a></span>.</p>
  

  <h3><a name="id71572">11.2 
        Large Systems</a></h3>
    
    <p>For a large system, it can be interesting to run profiling
      on a simulated and limited scenario to start with. But bottlenecks
      have a tendency to appear or cause problems only when
      many things are going on at the same time, and when
      many nodes are involved. Therefore, it is also desirable to run
      profiling in a system test plant on a real target system.</p>

    <p>For a large system, you do not want to run the profiling
      tools on the whole system. Instead you want to concentrate on
      central processes and modules, which contribute for a big part
      of the execution.</p>
  

  <h3><a name="id71592">11.3 
        What to Look For</a></h3>
    
    <p>When analyzing the result file from the profiling activity,
      look for functions that are called many
      times and have a long "own" execution time (time excluding calls
      to other functions). Functions that are called a lot of
      times can also be interesting, as even small things can add
      up to quite a bit if repeated often. Also
      ask yourself what you can do to reduce this time. The following
      are appropriate types of questions to ask yourself:</p>

    <ul>
      <li>Is it possible to reduce the number of times the function
      is called?</li>
      <li>Can any test be run less often if the order of tests is
      changed?</li>
      <li>Can any redundant tests be removed?</li>
      <li>Does any calculated expression give the same result
       each time?</li>
      <li>Are there other ways to do this that are equivalent and
       more efficient?</li>
      <li>Can another internal data representation be used to make
       things more efficient?</li>
    </ul>

    <p>These questions are not always trivial to answer. Some
    benchmarks might be needed to back up your theory and to avoid
      making things slower if your theory is wrong. For details, see
    <span class="bold_code"><a href="#benchmark">Benchmarking</a></span>.</p>
  

  <h3><a name="id71649">11.4 
        Tools</a></h3>
    
    <a name="profiling_tools"></a>
    <h4>fprof</h4>
      
      <p><span class="code">fprof</span> measures the execution time for each function,
      both own time, that is, how much time a function has used for its
      own execution, and accumulated time, that is, including called
      functions. The values are displayed per process. You also get
      to know how many times each function has been called.</p>

      <p><span class="code">fprof</span> is based on trace to file to minimize runtime
      performance impact. Using <span class="code">fprof</span> is just a matter of
      calling a few library functions, see the
      <span class="bold_code"><a href="../man/fprof.html">fprof</a></span> manual page in
      Tools .<span class="code">fprof</span> was introduced in R8.</p>
    

    <h4>eprof</h4>
      
      <p><span class="code">eprof</span> is based on the Erlang <span class="code">trace_info</span> BIFs.
      <span class="code">eprof</span> shows how much time has been used by each process,
      and in which function calls this time has been spent. Time is
      shown as percentage of total time and absolute time. For more
      information, see the <span class="bold_code"><a href="../man/eprof.html">eprof</a></span>
      manual page in Tools.</p>
    

    <h4>cover</h4>
      
      <p>The primary use of <span class="code">cover</span> is coverage analysis to verify
      test cases, making sure that all relevant code is covered.
      <span class="code">cover</span> counts how many times each executable line of code
      is executed when a program is run, on a per module basis.</p>
      <p>Clearly, this information can be used to determine what
      code is run very frequently and can therefore be subject for
      optimization. Using <span class="code">cover</span> is just a matter of calling a
      few library functions, see the
      <span class="bold_code"><a href="../man/cover.html">cover</a></span> manual page in
      Tools.</p>
    

    <h4>cprof</h4>
      
      <p><span class="code">cprof</span> is something in between <span class="code">fprof</span> and
      <span class="code">cover</span> regarding features. It counts how many times each
      function is called when the program is run, on a per module
      basis. <span class="code">cprof</span> has a low performance degradation effect
      (compared with <span class="code">fprof</span>) and does not need to recompile
      any modules to profile (compared with <span class="code">cover</span>).
      For more information, see the
      <span class="bold_code"><a href="../man/cprof.html">cprof</a></span> manual page in
      Tools.</p>
    

    <h4>Tool Summary</h4>
      
      <table border="1" cellpadding="2" cellspacing="0">
<tr>
          <td align="left" valign="middle"><strong>Tool</strong></td>
          <td align="left" valign="middle"><strong>Results</strong></td>
          <td align="left" valign="middle"><strong>Size of Result</strong></td>
          <td align="left" valign="middle"><strong>Effects on Program Execution Time</strong></td>
          <td align="left" valign="middle"><strong>Records Number of Calls</strong></td>
          <td align="left" valign="middle"><strong>Records Execution Time</strong></td>
          <td align="left" valign="middle"><strong>Records Called by</strong></td>
          <td align="left" valign="middle"><strong>Records Garbage Collection</strong></td>
        </tr>
<tr>
          <td align="left" valign="middle"><span class="code">fprof</span></td>
          <td align="left" valign="middle">Per process to screen/file</td>
          <td align="left" valign="middle">Large</td>
          <td align="left" valign="middle">Significant slowdown</td>
          <td align="left" valign="middle">Yes</td>
          <td align="left" valign="middle">Total and own</td>
          <td align="left" valign="middle">Yes</td>
          <td align="left" valign="middle">Yes</td>
        </tr>
<tr>
          <td align="left" valign="middle"><span class="code">eprof</span></td>
          <td align="left" valign="middle">Per process/function to screen/file</td>
          <td align="left" valign="middle">Medium</td>
          <td align="left" valign="middle">Small slowdown</td>
          <td align="left" valign="middle">Yes</td>
          <td align="left" valign="middle">Only total</td>
          <td align="left" valign="middle">No</td>
          <td align="left" valign="middle">No</td>
        </tr>
<tr>
          <td align="left" valign="middle"><span class="code">cover</span></td>
          <td align="left" valign="middle">Per module to screen/file</td>
          <td align="left" valign="middle">Small</td>
          <td align="left" valign="middle">Moderate slowdown</td>
          <td align="left" valign="middle">Yes, per line</td>
          <td align="left" valign="middle">No</td>
          <td align="left" valign="middle">No</td>
          <td align="left" valign="middle">No</td>
        </tr>
<tr>
          <td align="left" valign="middle"><span class="code">cprof</span></td>
          <td align="left" valign="middle">Per module to caller</td>
          <td align="left" valign="middle">Small</td>
          <td align="left" valign="middle">Small slowdown</td>
          <td align="left" valign="middle">Yes</td>
          <td align="left" valign="middle">No</td>
          <td align="left" valign="middle">No</td>
          <td align="left" valign="middle">No</td>
        </tr>
</table>
<em>Table
        11.1:
         
        Tool Summary</em>
    
  

  <h3>
<a name="benchmark"></a><a name="id72188">11.5 
        Benchmarking</a>
</h3>
    
    

    <p>The main purpose of benchmarking is to find out which
    implementation of a given algorithm or function is the fastest.
    Benchmarking is far from an exact science. Today's operating systems
    generally run background tasks that are difficult to turn off.
    Caches and multiple CPU cores does not facilitate benchmarking.
    It would be best to run UNIX computers in single-user mode when
    benchmarking, but that is inconvenient to say the least for casual
    testing.</p>
    
    <p>Benchmarks can measure wall-clock time or CPU time.</p>

    <ul>
    <li>
<span class="bold_code"><a href="../man/timer.html#tc-3">timer:tc/3</a></span> measures
    wall-clock time. The advantage with wall-clock time is that I/O,
    swapping, and other activities in the operating system kernel are
    included in the measurements. The disadvantage is that the
    measurements vary a lot. Usually it is best to run the
    benchmark several times and note the shortest time, which is to
    be the minimum time that is possible to achieve under the best of
    circumstances.</li>

    <li>
<span class="bold_code"><a href="../man/erlang.html#statistics-1">statistics/1</a></span>
    with argument <span class="code">runtime</span> measures CPU time spent in the Erlang
    virtual machine. The advantage with CPU time is that the results are more
    consistent from run to run. The disadvantage is that the time
    spent in the operating system kernel (such as swapping and I/O)
    is not included. Therefore, measuring CPU time is misleading if
    any I/O (file or socket) is involved.</li>
    </ul>

    <p>It is probably a good idea to do both wall-clock measurements and
    CPU time measurements.</p>

    <p>Some final advice:</p>

    <ul>
    <li>The granularity of both measurement types can be high.
    Therefore, ensure that each individual measurement
    lasts for at least several seconds.</li>

    <li>To make the test fair, each new test run is to run in its own,
    newly created Erlang process. Otherwise, if all tests run in the
    same process, the later tests start out with larger heap sizes
    and therefore probably do fewer garbage collections.
    Also consider restarting the Erlang emulator between each test.</li>

    <li>Do not assume that the fastest implementation of a given algorithm
    on computer architecture X is also the fastest on computer architecture
    Y.</li>
    </ul>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 2001-2017 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
