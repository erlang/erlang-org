<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- Tables and Databases</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="../pdf/otp-system-documentation.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Efficiency Guide</strong><br><strong>User's Guide</strong><br><small>Version 8.3</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="introduction.html">
              Top of chapter
            </a></li>
<li title="Purpose"><a href="introduction.html#id65906">Purpose</a></li>
<li title="Prerequisites"><a href="introduction.html#id63584">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="The Eight Myths of Erlang Performance" expanded="false">The Eight Myths of Erlang Performance<ul>
<li><a href="myths.html">
              Top of chapter
            </a></li>
<li title="Myth: Funs are Slow"><a href="myths.html#id63567">Myth: Funs are Slow</a></li>
<li title="Myth: List Comprehensions are Slow"><a href="myths.html#id63557">Myth: List Comprehensions are Slow</a></li>
<li title="Myth: Tail-Recursive Functions are Much Faster
    Than Recursive Functions"><a href="myths.html#id61999">Myth: Tail-Recursive Functions are Much Faster
    Than Recursive Functions</a></li>
<li title='Myth: Operator "++" is Always Bad'><a href="myths.html#id62699">Myth: Operator "++" is Always Bad</a></li>
<li title="Myth: Strings are Slow"><a href="myths.html#id57470">Myth: Strings are Slow</a></li>
<li title="Myth: Repairing a Dets File is Very Slow"><a href="myths.html#id62187">Myth: Repairing a Dets File is Very Slow</a></li>
<li title="Myth: BEAM is a Stack-Based Byte-Code Virtual Machine
    (and Therefore Slow)"><a href="myths.html#id62360">Myth: BEAM is a Stack-Based Byte-Code Virtual Machine
    (and Therefore Slow)</a></li>
<li title='Myth: Use "_" to Speed Up Your Program When a Variable
    is Not Used'><a href="myths.html#id62365">Myth: Use "_" to Speed Up Your Program When a Variable
    is Not Used</a></li>
</ul>
</li>
<li id="no" title="Common Caveats" expanded="false">Common Caveats<ul>
<li><a href="commoncaveats.html">
              Top of chapter
            </a></li>
<li title="Timer Module"><a href="commoncaveats.html#id65897">Timer Module</a></li>
<li title="list_to_atom/1"><a href="commoncaveats.html#id64815">list_to_atom/1</a></li>
<li title="length/1"><a href="commoncaveats.html#id59764">length/1</a></li>
<li title="setelement/3"><a href="commoncaveats.html#id61742">setelement/3</a></li>
<li title="size/1"><a href="commoncaveats.html#id66313">size/1</a></li>
<li title="split_binary/2"><a href="commoncaveats.html#id65292">split_binary/2</a></li>
<li title='Operator "--"'><a href="commoncaveats.html#id64604">Operator "--"</a></li>
</ul>
</li>
<li id="no" title="Constructing and Matching Binaries" expanded="false">Constructing and Matching Binaries<ul>
<li><a href="binaryhandling.html">
              Top of chapter
            </a></li>
<li title="How Binaries are Implemented"><a href="binaryhandling.html#id61539">How Binaries are Implemented</a></li>
<li title="Constructing Binaries"><a href="binaryhandling.html#id66208">Constructing Binaries</a></li>
<li title="Matching Binaries"><a href="binaryhandling.html#id65492">Matching Binaries</a></li>
</ul>
</li>
<li id="no" title="List Handling" expanded="false">List Handling<ul>
<li><a href="listHandling.html">
              Top of chapter
            </a></li>
<li title="Creating a List"><a href="listHandling.html#id68198">Creating a List</a></li>
<li title="List Comprehensions"><a href="listHandling.html#id68294">List Comprehensions</a></li>
<li title="Deep and Flat Lists"><a href="listHandling.html#id68364">Deep and Flat Lists</a></li>
<li title="Recursive List Functions"><a href="listHandling.html#id68511">Recursive List Functions</a></li>
</ul>
</li>
<li id="no" title="Functions" expanded="false">Functions<ul>
<li><a href="functions.html">
              Top of chapter
            </a></li>
<li title="Pattern Matching"><a href="functions.html#id68638">Pattern Matching</a></li>
<li title="Function Calls"><a href="functions.html#id68868">Function Calls</a></li>
<li title="Memory Usage in Recursion"><a href="functions.html#id69008">Memory Usage in Recursion</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Tables and Databases" expanded="true">Tables and Databases<ul>
<li><a href="tablesDatabases.html">
              Top of chapter
            </a></li>
<li title="Ets, Dets, and Mnesia"><a href="tablesDatabases.html#id69098">Ets, Dets, and Mnesia</a></li>
<li title="Ets-Specific"><a href="tablesDatabases.html#id69496">Ets-Specific</a></li>
<li title="Mnesia-Specific"><a href="tablesDatabases.html#id69606">Mnesia-Specific</a></li>
</ul>
</li>
<li id="no" title="Processes" expanded="false">Processes<ul>
<li><a href="processes.html">
              Top of chapter
            </a></li>
<li title="Creating an Erlang Process"><a href="processes.html#id69726">Creating an Erlang Process</a></li>
<li title="Process Messages"><a href="processes.html#id69887">Process Messages</a></li>
<li title="SMP Emulator"><a href="processes.html#id70096">SMP Emulator</a></li>
</ul>
</li>
<li id="no" title="Drivers" expanded="false">Drivers<ul>
<li><a href="drivers.html">
              Top of chapter
            </a></li>
<li title="Drivers and Concurrency"><a href="drivers.html#id70202">Drivers and Concurrency</a></li>
<li title="Avoiding Copying Binaries When Calling a Driver"><a href="drivers.html#id70243">Avoiding Copying Binaries When Calling a Driver</a></li>
<li title="Returning Small Binaries from a Driver"><a href="drivers.html#id70318">Returning Small Binaries from a Driver</a></li>
<li title="Returning Large Binaries without Copying from a Driver"><a href="drivers.html#id70353">Returning Large Binaries without Copying from a Driver</a></li>
</ul>
</li>
<li id="no" title="Advanced" expanded="false">Advanced<ul>
<li><a href="advanced.html">
              Top of chapter
            </a></li>
<li title="Memory"><a href="advanced.html#id70488">Memory</a></li>
<li title="System Limits"><a href="advanced.html#id70924">System Limits</a></li>
</ul>
</li>
<li id="no" title="Profiling" expanded="false">Profiling<ul>
<li><a href="profiling.html">
              Top of chapter
            </a></li>
<li title="Do Not Guess About Performance - Profile"><a href="profiling.html#id71474">Do Not Guess About Performance - Profile</a></li>
<li title="Large Systems"><a href="profiling.html#id71572">Large Systems</a></li>
<li title="What to Look For"><a href="profiling.html#id71592">What to Look For</a></li>
<li title="Tools"><a href="profiling.html#id71649">Tools</a></li>
<li title="Benchmarking"><a href="profiling.html#id72188">Benchmarking</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>7 Tables and Databases</h1>
  

  <h3><a name="id69098">7.1 
        Ets, Dets, and Mnesia</a></h3>
    
    <p>Every example using Ets has a corresponding example in
      Mnesia. In general, all Ets examples also apply to Dets tables.</p>

    <h4>Select/Match Operations</h4>
      
      <p>Select/match operations on Ets and Mnesia tables can become
        very expensive operations. They usually need to scan the complete
        table. Try to structure the data to minimize the need for select/match
        operations. However, if you require a select/match operation,
	it is still more efficient than using <span class="code">tab2list</span>.
	Examples of this and of how to avoid select/match are provided in
        the following sections. The functions
        <span class="code">ets:select/2</span> and <span class="code">mnesia:select/3</span> are to be preferred
	over <span class="code">ets:match/2</span>, <span class="code">ets:match_object/2</span>, and
      <span class="code">mnesia:match_object/3</span>.</p>
      <p>In some circumstances, the select/match operations do not need
        to scan the complete table.
	For example, if part of the key is bound when searching an
	<span class="code">ordered_set</span> table, or if it is a Mnesia
	table and there is a secondary index on the field that is
	selected/matched. If the key is fully bound, there is
	no point in doing a select/match, unless you have a bag table
	and are only interested in a subset of the elements with
        the specific key.</p>
      <p>When creating a record to be used in a select/match operation, you
        want most of the fields to have the value "_". The easiest and
	fastest way to do that is as follows:</p>
      <div class="example"><pre>
#person{age = 42, _ = '_'}. </pre></div>
    

    <h4>Deleting an Element</h4>
      
      <p>The <span class="code">delete</span> operation is considered
        successful if the element was not present in the table. Hence
        all attempts to check that the element is present in the
        Ets/Mnesia table before deletion are unnecessary. Here follows
        an example for Ets tables:</p>
      <p><strong>DO</strong></p>
      <div class="example"><pre>
...
ets:delete(Tab, Key),
...</pre></div>
      <p><strong>DO NOT</strong></p>
      <div class="example"><pre>
...
case ets:lookup(Tab, Key) of
    [] -&gt;
        ok;
    [_|_] -&gt;
        ets:delete(Tab, Key)
end,
...</pre></div>
    

    <h4>Fetching Data</h4>
      
      <p>Do not fetch data that you already have.</p>
      <p>Consider that you have a module that handles the abstract data
      type <span class="code">Person</span>. You export the interface function
      <span class="code">print_person/1</span>, which uses the internal functions
      <span class="code">print_name/1</span>, <span class="code">print_age/1</span>, and
      <span class="code">print_occupation/1</span>.</p>
      <div class="note">
<div class="label">Note</div>
<div class="content"><p>
        <p>If the function <span class="code">print_name/1</span>, and so on, had been interface
          functions, the situation would have been different, as you
          do not want the user of the interface to know about the
          internal data representation. </p>
      </p></div>
</div>
      <p><strong>DO</strong></p>
      <div class="example"><pre>
%%% Interface function
print_person(PersonId) -&gt;
    %% Look up the person in the named table person,
    case ets:lookup(person, PersonId) of
        [Person] -&gt;
            print_name(Person),
            print_age(Person),
            print_occupation(Person);
        [] -&gt;
            io:format("No person with ID = ~p~n", [PersonID])
    end.

%%% Internal functions
print_name(Person) -&gt; 
    io:format("No person ~p~n", [Person#person.name]).
                      
print_age(Person) -&gt; 
    io:format("No person ~p~n", [Person#person.age]).

print_occupation(Person) -&gt; 
    io:format("No person ~p~n", [Person#person.occupation]).</pre></div>
      <p><strong>DO NOT</strong></p>
      <div class="example"><pre>
%%% Interface function
print_person(PersonId) -&gt;
    %% Look up the person in the named table person,
    case ets:lookup(person, PersonId) of
        [Person] -&gt;
            print_name(PersonID),
            print_age(PersonID),
            print_occupation(PersonID);
        [] -&gt;
            io:format("No person with ID = ~p~n", [PersonID])
    end.

%%% Internal functionss
print_name(PersonID) -&gt; 
    [Person] = ets:lookup(person, PersonId),
    io:format("No person ~p~n", [Person#person.name]).

print_age(PersonID) -&gt; 
    [Person] = ets:lookup(person, PersonId),
    io:format("No person ~p~n", [Person#person.age]).

print_occupation(PersonID) -&gt; 
    [Person] = ets:lookup(person, PersonId),
    io:format("No person ~p~n", [Person#person.occupation]).</pre></div>
    

    <h4>Non-Persistent Database Storage</h4>
      
      <p>For non-persistent database storage, prefer Ets tables over
        Mnesia <span class="code">local_content</span> tables. Even the Mnesia <span class="code">dirty_write</span>
        operations carry a fixed overhead compared to Ets writes.
        Mnesia must check if the table is replicated or has indices,
        this involves at least one Ets lookup for each
        <span class="code">dirty_write</span>. Thus, Ets writes is always faster than
        Mnesia writes.</p>
    

    <h4>tab2list</h4>
      
      <p>Assuming an Ets table that uses <span class="code">idno</span> as key
        and contains the following:</p>
      <div class="example"><pre>
[#person{idno = 1, name = "Adam",  age = 31, occupation = "mailman"},
 #person{idno = 2, name = "Bryan", age = 31, occupation = "cashier"},
 #person{idno = 3, name = "Bryan", age = 35, occupation = "banker"},
 #person{idno = 4, name = "Carl",  age = 25, occupation = "mailman"}]</pre></div>
      <p>If you <strong>must</strong> return all data stored in the Ets table, you
        can use <span class="code">ets:tab2list/1</span>.  However, usually you are only
        interested in a subset of the information in which case
        <span class="code">ets:tab2list/1</span> is expensive. If you only want to extract
        one field from each record, for example, the age of every person,
        then:</p>
      <p><strong>DO</strong></p>
      <div class="example"><pre>
...
ets:select(Tab,[{ #person{idno='_', 
                          name='_', 
                          age='$1', 
                          occupation = '_'},
                [],
                ['$1']}]),
...</pre></div>
      <p><strong>DO NOT</strong></p>
      <div class="example"><pre>
...
TabList = ets:tab2list(Tab),
lists:map(fun(X) -&gt; X#person.age end, TabList),
...</pre></div>
      <p>If you are only interested in the age of all persons named
        "Bryan", then:</p>
      <p><strong>DO</strong></p>
      <div class="example"><pre>
...
ets:select(Tab,[{ #person{idno='_', 
                          name="Bryan", 
                          age='$1', 
                          occupation = '_'},
                [],
                ['$1']}]),
...</pre></div>
      <p><strong>DO NOT</strong></p>
      <div class="example"><pre>
...
TabList = ets:tab2list(Tab),
lists:foldl(fun(X, Acc) -&gt; case X#person.name of
                                "Bryan" -&gt;
                                    [X#person.age|Acc];
                                 _ -&gt;
                                     Acc
                           end
             end, [], TabList),
...</pre></div>
      <p><strong>REALLY DO NOT</strong></p>
      <div class="example"><pre>
...
TabList = ets:tab2list(Tab),
BryanList = lists:filter(fun(X) -&gt; X#person.name == "Bryan" end,
                         TabList),
lists:map(fun(X) -&gt; X#person.age end, BryanList),
...</pre></div>
      <p>If you need all information stored in the Ets table about
        persons named "Bryan", then:</p>
      <p><strong>DO</strong></p>
      <div class="example"><pre>
...
ets:select(Tab, [{#person{idno='_', 
                          name="Bryan", 
                          age='_', 
                          occupation = '_'}, [], ['$_']}]),
...</pre></div>
      <p><strong>DO NOT</strong></p>
      <div class="example"><pre>
...
TabList = ets:tab2list(Tab),
lists:filter(fun(X) -&gt; X#person.name == "Bryan" end, TabList),
...</pre></div>
    

    <h4>Ordered_set Tables</h4>
      
      <p>If the data in the table is to be accessed so that the order
        of the keys in the table is significant, the table type
        <span class="code">ordered_set</span> can be used instead of the more usual
        <span class="code">set</span> table type. An <span class="code">ordered_set</span> is always
        traversed in Erlang term order regarding the key field
        so that the return values from functions such as <span class="code">select</span>,
        <span class="code">match_object</span>, and <span class="code">foldl</span> are ordered by the key
        values. Traversing an <span class="code">ordered_set</span> with the <span class="code">first</span> and
        <span class="code">next</span> operations also returns the keys ordered.</p>
      <div class="note">
<div class="label">Note</div>
<div class="content"><p>
        <p>An <span class="code">ordered_set</span> only guarantees that
          objects are processed in <strong>key</strong> order.
	  Results from functions such as
          <span class="code">ets:select/2</span> appear in <strong>key</strong> order even if
          the key is not included in the result.</p>
      </p></div>
</div>
    
  

  <h3><a name="id69496">7.2 
        Ets-Specific</a></h3>
    

    <h4>Using Keys of Ets Table</h4>
      
      <p>An Ets table is a single-key table (either a hash table or a
        tree ordered by the key) and is to be used as one. In other
        words, use the key to look up things whenever possible. A
        lookup by a known key in a <span class="code">set</span> Ets table is constant and for
        an <span class="code">ordered_set</span> Ets table it is O(logN). A key lookup is always
        preferable to a call where the whole table has to be
        scanned. In the previous examples, the field <span class="code">idno</span> is the
        key of the table and all lookups where only the name is known
        result in a complete scan of the (possibly large) table
        for a matching result.</p>
      <p>A simple solution would be to use the <span class="code">name</span> field as
        the key instead of the <span class="code">idno</span> field, but that would cause
        problems if the names were not unique. A more general solution would
        be to create a second table with <span class="code">name</span> as key and
        <span class="code">idno</span> as data, that is, to index (invert) the table regarding
        the <span class="code">name</span> field. Clearly, the second table would have to be
        kept consistent with the master table. Mnesia can do this
        for you, but a home brew index table can be very efficient
        compared to the overhead involved in using Mnesia.</p>
      <p>An index table for the table in the previous examples would
        have to be a bag (as keys would appear more than once) and can
        have the following contents:</p>
      <div class="example"><pre>
[#index_entry{name="Adam", idno=1},
 #index_entry{name="Bryan", idno=2},
 #index_entry{name="Bryan", idno=3},
 #index_entry{name="Carl", idno=4}]</pre></div>
      <p>Given this index table, a lookup of the <span class="code">age</span> fields for
        all persons named "Bryan" can be done as follows:</p>
      <div class="example"><pre>
...
MatchingIDs = ets:lookup(IndexTable,"Bryan"),
lists:map(fun(#index_entry{idno = ID}) -&gt;
                 [#person{age = Age}] = ets:lookup(PersonTable, ID),
                 Age
          end,
          MatchingIDs),
...</pre></div>
      <p>Notice that this code never uses <span class="code">ets:match/2</span> but
        instead uses the <span class="code">ets:lookup/2</span> call. The
        <span class="code">lists:map/2</span> call is only used to traverse the <span class="code">idno</span>s
        matching the name "Bryan" in the table; thus the number of lookups
        in the master table is minimized.</p>
      <p>Keeping an index table introduces some overhead when
        inserting records in the table. The number of operations gained
        from the table must therefore be compared against the number of
        operations inserting objects in the table. However, notice that the
	gain is significant when the key can be used to lookup elements.</p>
    
  

  <h3><a name="id69606">7.3 
        Mnesia-Specific</a></h3>
    

    <h4>Secondary Index</h4>
      
      <p>If you frequently do a lookup on a field that is not the
        key of the table, you lose performance using
        "mnesia:select/match_object" as this function traverses the
        whole table. You can create a secondary index instead and
        use "mnesia:index_read" to get faster access, however this
        requires more memory.</p>
	<p><strong>Example</strong></p>
      <div class="example"><pre>
-record(person, {idno, name, age, occupation}).
        ...
{atomic, ok} = 
mnesia:create_table(person, [{index,[#person.age]},
                              {attributes,
                                    record_info(fields, person)}]),
{atomic, ok} = mnesia:add_table_index(person, age), 
...

PersonsAge42 =
     mnesia:dirty_index_read(person, 42, #person.age),
...</pre></div>
    

    <h4>Transactions </h4>
      
      <p>Using transactions is a way to guarantee that the distributed
        Mnesia database remains consistent, even when many different
        processes update it in parallel. However, if you have
        real-time requirements it is recommended to use <span class="code">dirty</span>
        operations instead of transactions. When using <span class="code">dirty</span>
        operations, you lose the consistency guarantee; this is usually
        solved by only letting one process update the table. Other
        processes must send update requests to that process.</p>
	<p><strong>Example</strong></p>
      <div class="example"><pre>
...
% Using transaction

Fun = fun() -&gt;
          [mnesia:read({Table, Key}),
           mnesia:read({Table2, Key2})]
      end, 

{atomic, [Result1, Result2]}  = mnesia:transaction(Fun),
...

% Same thing using dirty operations
...

Result1 = mnesia:dirty_read({Table, Key}),
Result2 = mnesia:dirty_read({Table2, Key2}),
...</pre></div>
    
  
</div>
<div class="footer">
<hr>
<p>Copyright © 2001-2017 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
