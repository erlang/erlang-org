<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- erl_connect</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/erl_interface/users_guide.html">User's Guide</a><br><a href="../apps/erl_interface/index.html">Reference Manual</a><br><a href="../apps/erl_interface/release_notes.html">Release Notes</a><br><a href="../apps/erl_interface/erl_interface.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Erl_Interface</strong><br><strong>Reference Manual</strong><br><small>Version 3.9.3</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li id="no" title="ei " expanded="false">ei<ul>
<li><a href="ei.html">
                  Top of manual page
                </a></li>
    <li title="ei_decode_atom"><a href="ei.html#ei_decode_atom">ei_decode_atom()
                </a></li>
<li title="ei_decode_atom_as"><a href="ei.html#ei_decode_atom_as">ei_decode_atom_as()
                </a></li>
<li title="ei_decode_bignum"><a href="ei.html#ei_decode_bignum">ei_decode_bignum()
                </a></li>
<li title="ei_decode_binary"><a href="ei.html#ei_decode_binary">ei_decode_binary()
                </a></li>
<li title="ei_decode_boolean"><a href="ei.html#ei_decode_boolean">ei_decode_boolean()
                </a></li>
<li title="ei_decode_char"><a href="ei.html#ei_decode_char">ei_decode_char()
                </a></li>
<li title="ei_decode_double"><a href="ei.html#ei_decode_double">ei_decode_double()
                </a></li>
<li title="ei_decode_ei_term"><a href="ei.html#ei_decode_ei_term">ei_decode_ei_term()
                </a></li>
<li title="ei_decode_fun"><a href="ei.html#ei_decode_fun">ei_decode_fun()
                </a></li>
<li title="ei_decode_list_header"><a href="ei.html#ei_decode_list_header">ei_decode_list_header()
                </a></li>
<li title="ei_decode_long"><a href="ei.html#ei_decode_long">ei_decode_long()
                </a></li>
<li title="ei_decode_longlong"><a href="ei.html#ei_decode_longlong">ei_decode_longlong()
                </a></li>
<li title="ei_decode_map_header"><a href="ei.html#ei_decode_map_header">ei_decode_map_header()
                </a></li>
<li title="ei_decode_pid"><a href="ei.html#ei_decode_pid">ei_decode_pid()
                </a></li>
<li title="ei_decode_port"><a href="ei.html#ei_decode_port">ei_decode_port()
                </a></li>
<li title="ei_decode_ref"><a href="ei.html#ei_decode_ref">ei_decode_ref()
                </a></li>
<li title="ei_decode_string"><a href="ei.html#ei_decode_string">ei_decode_string()
                </a></li>
<li title="ei_decode_term"><a href="ei.html#ei_decode_term">ei_decode_term()
                </a></li>
<li title="ei_decode_trace"><a href="ei.html#ei_decode_trace">ei_decode_trace()
                </a></li>
<li title="ei_decode_tuple_header"><a href="ei.html#ei_decode_tuple_header">ei_decode_tuple_header()
                </a></li>
<li title="ei_decode_ulong"><a href="ei.html#ei_decode_ulong">ei_decode_ulong()
                </a></li>
<li title="ei_decode_ulonglong"><a href="ei.html#ei_decode_ulonglong">ei_decode_ulonglong()
                </a></li>
<li title="ei_decode_version"><a href="ei.html#ei_decode_version">ei_decode_version()
                </a></li>
<li title="ei_encode_atom"><a href="ei.html#ei_encode_atom">ei_encode_atom()
                </a></li>
<li title="ei_encode_atom_as"><a href="ei.html#ei_encode_atom_as">ei_encode_atom_as()
                </a></li>
<li title="ei_encode_atom_len"><a href="ei.html#ei_encode_atom_len">ei_encode_atom_len()
                </a></li>
<li title="ei_encode_atom_len_as"><a href="ei.html#ei_encode_atom_len_as">ei_encode_atom_len_as()
                </a></li>
<li title="ei_encode_bignum"><a href="ei.html#ei_encode_bignum">ei_encode_bignum()
                </a></li>
<li title="ei_encode_binary"><a href="ei.html#ei_encode_binary">ei_encode_binary()
                </a></li>
<li title="ei_encode_boolean"><a href="ei.html#ei_encode_boolean">ei_encode_boolean()
                </a></li>
<li title="ei_encode_char"><a href="ei.html#ei_encode_char">ei_encode_char()
                </a></li>
<li title="ei_encode_double"><a href="ei.html#ei_encode_double">ei_encode_double()
                </a></li>
<li title="ei_encode_empty_list"><a href="ei.html#ei_encode_empty_list">ei_encode_empty_list()
                </a></li>
<li title="ei_encode_fun"><a href="ei.html#ei_encode_fun">ei_encode_fun()
                </a></li>
<li title="ei_encode_list_header"><a href="ei.html#ei_encode_list_header">ei_encode_list_header()
                </a></li>
<li title="ei_encode_long"><a href="ei.html#ei_encode_long">ei_encode_long()
                </a></li>
<li title="ei_encode_longlong"><a href="ei.html#ei_encode_longlong">ei_encode_longlong()
                </a></li>
<li title="ei_encode_map_header"><a href="ei.html#ei_encode_map_header">ei_encode_map_header()
                </a></li>
<li title="ei_encode_pid"><a href="ei.html#ei_encode_pid">ei_encode_pid()
                </a></li>
<li title="ei_encode_port"><a href="ei.html#ei_encode_port">ei_encode_port()
                </a></li>
<li title="ei_encode_ref"><a href="ei.html#ei_encode_ref">ei_encode_ref()
                </a></li>
<li title="ei_encode_string"><a href="ei.html#ei_encode_string">ei_encode_string()
                </a></li>
<li title="ei_encode_string_len"><a href="ei.html#ei_encode_string_len">ei_encode_string_len()
                </a></li>
<li title="ei_encode_term"><a href="ei.html#ei_encode_term">ei_encode_term()
                </a></li>
<li title="ei_encode_trace"><a href="ei.html#ei_encode_trace">ei_encode_trace()
                </a></li>
<li title="ei_encode_tuple_header"><a href="ei.html#ei_encode_tuple_header">ei_encode_tuple_header()
                </a></li>
<li title="ei_encode_ulong"><a href="ei.html#ei_encode_ulong">ei_encode_ulong()
                </a></li>
<li title="ei_encode_ulonglong"><a href="ei.html#ei_encode_ulonglong">ei_encode_ulonglong()
                </a></li>
<li title="ei_encode_version"><a href="ei.html#ei_encode_version">ei_encode_version()
                </a></li>
<li title="ei_get_type"><a href="ei.html#ei_get_type">ei_get_type()
                </a></li>
<li title="ei_print_term"><a href="ei.html#ei_print_term">ei_print_term()
                </a></li>
<li title="ei_s_print_term"><a href="ei.html#ei_s_print_term">ei_s_print_term()
                </a></li>
<li title="ei_skip_term"><a href="ei.html#ei_skip_term">ei_skip_term()
                </a></li>
<li title="ei_x_append"><a href="ei.html#ei_x_append">ei_x_append()
                </a></li>
<li title="ei_x_append_buf"><a href="ei.html#ei_x_append_buf">ei_x_append_buf()
                </a></li>
<li title="ei_x_encode_atom"><a href="ei.html#ei_x_encode_atom">ei_x_encode_atom()
                </a></li>
<li title="ei_x_encode_atom_as"><a href="ei.html#ei_x_encode_atom_as">ei_x_encode_atom_as()
                </a></li>
<li title="ei_x_encode_atom_len"><a href="ei.html#ei_x_encode_atom_len">ei_x_encode_atom_len()
                </a></li>
<li title="ei_x_encode_atom_len_as"><a href="ei.html#ei_x_encode_atom_len_as">ei_x_encode_atom_len_as()
                </a></li>
<li title="ei_x_encode_bignum"><a href="ei.html#ei_x_encode_bignum">ei_x_encode_bignum()
                </a></li>
<li title="ei_x_encode_binary"><a href="ei.html#ei_x_encode_binary">ei_x_encode_binary()
                </a></li>
<li title="ei_x_encode_boolean"><a href="ei.html#ei_x_encode_boolean">ei_x_encode_boolean()
                </a></li>
<li title="ei_x_encode_char"><a href="ei.html#ei_x_encode_char">ei_x_encode_char()
                </a></li>
<li title="ei_x_encode_double"><a href="ei.html#ei_x_encode_double">ei_x_encode_double()
                </a></li>
<li title="ei_x_encode_empty_list"><a href="ei.html#ei_x_encode_empty_list">ei_x_encode_empty_list()
                </a></li>
<li title="ei_x_encode_fun"><a href="ei.html#ei_x_encode_fun">ei_x_encode_fun()
                </a></li>
<li title="ei_x_encode_list_header"><a href="ei.html#ei_x_encode_list_header">ei_x_encode_list_header()
                </a></li>
<li title="ei_x_encode_long"><a href="ei.html#ei_x_encode_long">ei_x_encode_long()
                </a></li>
<li title="ei_x_encode_longlong"><a href="ei.html#ei_x_encode_longlong">ei_x_encode_longlong()
                </a></li>
<li title="ei_x_encode_map_header"><a href="ei.html#ei_x_encode_map_header">ei_x_encode_map_header()
                </a></li>
<li title="ei_x_encode_pid"><a href="ei.html#ei_x_encode_pid">ei_x_encode_pid()
                </a></li>
<li title="ei_x_encode_port"><a href="ei.html#ei_x_encode_port">ei_x_encode_port()
                </a></li>
<li title="ei_x_encode_ref"><a href="ei.html#ei_x_encode_ref">ei_x_encode_ref()
                </a></li>
<li title="ei_x_encode_string"><a href="ei.html#ei_x_encode_string">ei_x_encode_string()
                </a></li>
<li title="ei_x_encode_string_len"><a href="ei.html#ei_x_encode_string_len">ei_x_encode_string_len()
                </a></li>
<li title="ei_x_encode_term"><a href="ei.html#ei_x_encode_term">ei_x_encode_term()
                </a></li>
<li title="ei_x_encode_trace"><a href="ei.html#ei_x_encode_trace">ei_x_encode_trace()
                </a></li>
<li title="ei_x_encode_tuple_header"><a href="ei.html#ei_x_encode_tuple_header">ei_x_encode_tuple_header()
                </a></li>
<li title="ei_x_encode_ulong"><a href="ei.html#ei_x_encode_ulong">ei_x_encode_ulong()
                </a></li>
<li title="ei_x_encode_ulonglong"><a href="ei.html#ei_x_encode_ulonglong">ei_x_encode_ulonglong()
                </a></li>
<li title="ei_x_encode_version"><a href="ei.html#ei_x_encode_version">ei_x_encode_version()
                </a></li>
<li title="ei_x_format"><a href="ei.html#ei_x_format">ei_x_format()
                </a></li>
<li title="ei_x_format_wo_ver"><a href="ei.html#ei_x_format_wo_ver">ei_x_format_wo_ver()
                </a></li>
<li title="ei_x_free"><a href="ei.html#ei_x_free">ei_x_free()
                </a></li>
<li title="ei_x_new"><a href="ei.html#ei_x_new">ei_x_new()
                </a></li>
<li title="ei_x_new_with_version"><a href="ei.html#ei_x_new_with_version">ei_x_new_with_version()
                </a></li>
<li title="ei_set_compat_rel"><a href="ei.html#ei_set_compat_rel">ei_set_compat_rel()
                </a></li>
<li title="free_fun"><a href="ei.html#free_fun">free_fun()
                </a></li>
</ul>
</li>
<li id="no" title="ei_connect " expanded="false">ei_connect<ul>
<li><a href="ei_connect.html">
                  Top of manual page
                </a></li>
    <li title="ei_thisalivename"><a href="ei_connect.html#ei_thisalivename">ei_thisalivename()
                </a></li>
<li title="ei_thishostname"><a href="ei_connect.html#ei_thishostname">ei_thishostname()
                </a></li>
<li title="ei_thisnodename"><a href="ei_connect.html#ei_thisnodename">ei_thisnodename()
                </a></li>
<li title="ei_self"><a href="ei_connect.html#ei_self">ei_self()
                </a></li>
<li title="ei_accept"><a href="ei_connect.html#ei_accept">ei_accept()
                </a></li>
<li title="ei_accept_tmo"><a href="ei_connect.html#ei_accept_tmo">ei_accept_tmo()
                </a></li>
<li title="ei_connect"><a href="ei_connect.html#ei_connect">ei_connect()
                </a></li>
<li title="ei_connect_init"><a href="ei_connect.html#ei_connect_init">ei_connect_init()
                </a></li>
<li title="ei_connect_tmo"><a href="ei_connect.html#ei_connect_tmo">ei_connect_tmo()
                </a></li>
<li title="ei_connect_xinit"><a href="ei_connect.html#ei_connect_xinit">ei_connect_xinit()
                </a></li>
<li title="ei_get_tracelevel"><a href="ei_connect.html#ei_get_tracelevel">ei_get_tracelevel()
                </a></li>
<li title="ei_publish"><a href="ei_connect.html#ei_publish">ei_publish()
                </a></li>
<li title="ei_publish_tmo"><a href="ei_connect.html#ei_publish_tmo">ei_publish_tmo()
                </a></li>
<li title="ei_receive"><a href="ei_connect.html#ei_receive">ei_receive()
                </a></li>
<li title="ei_receive_encoded"><a href="ei_connect.html#ei_receive_encoded">ei_receive_encoded()
                </a></li>
<li title="ei_receive_encoded_tmo"><a href="ei_connect.html#ei_receive_encoded_tmo">ei_receive_encoded_tmo()
                </a></li>
<li title="ei_receive_msg"><a href="ei_connect.html#ei_receive_msg">ei_receive_msg()
                </a></li>
<li title="ei_receive_msg_tmo"><a href="ei_connect.html#ei_receive_msg_tmo">ei_receive_msg_tmo()
                </a></li>
<li title="ei_receive_tmo"><a href="ei_connect.html#ei_receive_tmo">ei_receive_tmo()
                </a></li>
<li title="ei_reg_send"><a href="ei_connect.html#ei_reg_send">ei_reg_send()
                </a></li>
<li title="ei_reg_send_tmo"><a href="ei_connect.html#ei_reg_send_tmo">ei_reg_send_tmo()
                </a></li>
<li title="ei_rpc"><a href="ei_connect.html#ei_rpc">ei_rpc()
                </a></li>
<li title="ei_rpc_from"><a href="ei_connect.html#ei_rpc_from">ei_rpc_from()
                </a></li>
<li title="ei_rpc_to"><a href="ei_connect.html#ei_rpc_to">ei_rpc_to()
                </a></li>
<li title="ei_send"><a href="ei_connect.html#ei_send">ei_send()
                </a></li>
<li title="ei_send_encoded"><a href="ei_connect.html#ei_send_encoded">ei_send_encoded()
                </a></li>
<li title="ei_send_encoded_tmo"><a href="ei_connect.html#ei_send_encoded_tmo">ei_send_encoded_tmo()
                </a></li>
<li title="ei_send_reg_encoded"><a href="ei_connect.html#ei_send_reg_encoded">ei_send_reg_encoded()
                </a></li>
<li title="ei_send_reg_encoded_tmo"><a href="ei_connect.html#ei_send_reg_encoded_tmo">ei_send_reg_encoded_tmo()
                </a></li>
<li title="ei_send_tmo"><a href="ei_connect.html#ei_send_tmo">ei_send_tmo()
                </a></li>
<li title="ei_unpublish"><a href="ei_connect.html#ei_unpublish">ei_unpublish()
                </a></li>
<li title="ei_unpublish_tmo"><a href="ei_connect.html#ei_unpublish_tmo">ei_unpublish_tmo()
                </a></li>
<li title="ei_xconnect"><a href="ei_connect.html#ei_xconnect">ei_xconnect()
                </a></li>
<li title="ei_xconnect_tmo"><a href="ei_connect.html#ei_xconnect_tmo">ei_xconnect_tmo()
                </a></li>
<li title="ei_xreceive_msg"><a href="ei_connect.html#ei_xreceive_msg">ei_xreceive_msg()
                </a></li>
<li title="ei_xreceive_msg_tmo"><a href="ei_connect.html#ei_xreceive_msg_tmo">ei_xreceive_msg_tmo()
                </a></li>
<li title="*ei_gethostbyaddr"><a href="ei_connect.html#*ei_gethostbyaddr">*ei_gethostbyaddr()
                </a></li>
<li title="*ei_gethostbyaddr_r"><a href="ei_connect.html#*ei_gethostbyaddr_r">*ei_gethostbyaddr_r()
                </a></li>
<li title="*ei_gethostbyname"><a href="ei_connect.html#*ei_gethostbyname">*ei_gethostbyname()
                </a></li>
<li title="*ei_gethostbyname_r"><a href="ei_connect.html#*ei_gethostbyname_r">*ei_gethostbyname_r()
                </a></li>
<li title="ei_set_tracelevel"><a href="ei_connect.html#ei_set_tracelevel">ei_set_tracelevel()
                </a></li>
</ul>
</li>
<li id="no" title="registry " expanded="false">registry<ul>
<li><a href="registry.html">
                  Top of manual page
                </a></li>
    <li title="ei_reg_getsval"><a href="registry.html#ei_reg_getsval">ei_reg_getsval()
                </a></li>
<li title="ei_reg_getpval"><a href="registry.html#ei_reg_getpval">ei_reg_getpval()
                </a></li>
<li title="ei_reg_getfval"><a href="registry.html#ei_reg_getfval">ei_reg_getfval()
                </a></li>
<li title="ei_reg_open"><a href="registry.html#ei_reg_open">ei_reg_open()
                </a></li>
<li title="ei_reg_close"><a href="registry.html#ei_reg_close">ei_reg_close()
                </a></li>
<li title="ei_reg_delete"><a href="registry.html#ei_reg_delete">ei_reg_delete()
                </a></li>
<li title="ei_reg_dump"><a href="registry.html#ei_reg_dump">ei_reg_dump()
                </a></li>
<li title="ei_reg_getival"><a href="registry.html#ei_reg_getival">ei_reg_getival()
                </a></li>
<li title="ei_reg_getval"><a href="registry.html#ei_reg_getval">ei_reg_getval()
                </a></li>
<li title="ei_reg_markdirty"><a href="registry.html#ei_reg_markdirty">ei_reg_markdirty()
                </a></li>
<li title="ei_reg_purge"><a href="registry.html#ei_reg_purge">ei_reg_purge()
                </a></li>
<li title="ei_reg_resize"><a href="registry.html#ei_reg_resize">ei_reg_resize()
                </a></li>
<li title="ei_reg_restore"><a href="registry.html#ei_reg_restore">ei_reg_restore()
                </a></li>
<li title="ei_reg_setfval"><a href="registry.html#ei_reg_setfval">ei_reg_setfval()
                </a></li>
<li title="ei_reg_setival"><a href="registry.html#ei_reg_setival">ei_reg_setival()
                </a></li>
<li title="ei_reg_setpval"><a href="registry.html#ei_reg_setpval">ei_reg_setpval()
                </a></li>
<li title="ei_reg_setsval"><a href="registry.html#ei_reg_setsval">ei_reg_setsval()
                </a></li>
<li title="ei_reg_setval"><a href="registry.html#ei_reg_setval">ei_reg_setval()
                </a></li>
<li title="ei_reg_stat"><a href="registry.html#ei_reg_stat">ei_reg_stat()
                </a></li>
<li title="ei_reg_tabstat"><a href="registry.html#ei_reg_tabstat">ei_reg_tabstat()
                </a></li>
</ul>
</li>
<li id="loadscrollpos" title="erl_connect " expanded="true">erl_connect<ul>
<li><a href="erl_connect.html">
                  Top of manual page
                </a></li>
    <li title="erl_thisalivename"><a href="erl_connect.html#erl_thisalivename">erl_thisalivename()
                </a></li>
<li title="erl_thiscookie"><a href="erl_connect.html#erl_thiscookie">erl_thiscookie()
                </a></li>
<li title="erl_thishostname"><a href="erl_connect.html#erl_thishostname">erl_thishostname()
                </a></li>
<li title="erl_thisnodename"><a href="erl_connect.html#erl_thisnodename">erl_thisnodename()
                </a></li>
<li title="erl_accept"><a href="erl_connect.html#erl_accept">erl_accept()
                </a></li>
<li title="erl_close_connection"><a href="erl_connect.html#erl_close_connection">erl_close_connection()
                </a></li>
<li title="erl_connect"><a href="erl_connect.html#erl_connect">erl_connect()
                </a></li>
<li title="erl_connect_init"><a href="erl_connect.html#erl_connect_init">erl_connect_init()
                </a></li>
<li title="erl_connect_xinit"><a href="erl_connect.html#erl_connect_xinit">erl_connect_xinit()
                </a></li>
<li title="erl_publish"><a href="erl_connect.html#erl_publish">erl_publish()
                </a></li>
<li title="erl_receive"><a href="erl_connect.html#erl_receive">erl_receive()
                </a></li>
<li title="erl_receive_msg"><a href="erl_connect.html#erl_receive_msg">erl_receive_msg()
                </a></li>
<li title="erl_reg_send"><a href="erl_connect.html#erl_reg_send">erl_reg_send()
                </a></li>
<li title="erl_rpc_from"><a href="erl_connect.html#erl_rpc_from">erl_rpc_from()
                </a></li>
<li title="erl_rpc_to"><a href="erl_connect.html#erl_rpc_to">erl_rpc_to()
                </a></li>
<li title="erl_send"><a href="erl_connect.html#erl_send">erl_send()
                </a></li>
<li title="erl_unpublish"><a href="erl_connect.html#erl_unpublish">erl_unpublish()
                </a></li>
<li title="erl_xconnect"><a href="erl_connect.html#erl_xconnect">erl_xconnect()
                </a></li>
<li title="erl_xreceive_msg"><a href="erl_connect.html#erl_xreceive_msg">erl_xreceive_msg()
                </a></li>
<li title="erl_thiscreation"><a href="erl_connect.html#erl_thiscreation">erl_thiscreation()
                </a></li>
<li title="*erl_gethostbyaddr"><a href="erl_connect.html#*erl_gethostbyaddr">*erl_gethostbyaddr()
                </a></li>
<li title="*erl_gethostbyaddr_r"><a href="erl_connect.html#*erl_gethostbyaddr_r">*erl_gethostbyaddr_r()
                </a></li>
<li title="*erl_gethostbyname"><a href="erl_connect.html#*erl_gethostbyname">*erl_gethostbyname()
                </a></li>
<li title="*erl_gethostbyname_r"><a href="erl_connect.html#*erl_gethostbyname_r">*erl_gethostbyname_r()
                </a></li>
<li title="erl_rpc"><a href="erl_connect.html#erl_rpc">erl_rpc()
                </a></li>
</ul>
</li>
<li id="no" title="erl_error " expanded="false">erl_error<ul>
<li><a href="erl_error.html">
                  Top of manual page
                </a></li>
    <li title="erl_err_msg"><a href="erl_error.html#erl_err_msg">erl_err_msg()
                </a></li>
<li title="erl_err_quit"><a href="erl_error.html#erl_err_quit">erl_err_quit()
                </a></li>
<li title="erl_err_ret"><a href="erl_error.html#erl_err_ret">erl_err_ret()
                </a></li>
<li title="erl_err_sys"><a href="erl_error.html#erl_err_sys">erl_err_sys()
                </a></li>
<li title=""><a href="erl_error.html#">erl_errno()
                </a></li>
</ul>
</li>
<li id="no" title="erl_eterm " expanded="false">erl_eterm<ul>
<li><a href="erl_eterm.html">
                  Top of manual page
                </a></li>
    <li title="erl_iolist_to_string"><a href="erl_eterm.html#erl_iolist_to_string">erl_iolist_to_string()
                </a></li>
<li title="erl_iolist_length"><a href="erl_eterm.html#erl_iolist_length">erl_iolist_length()
                </a></li>
<li title="erl_length"><a href="erl_eterm.html#erl_length">erl_length()
                </a></li>
<li title="erl_print_term"><a href="erl_eterm.html#erl_print_term">erl_print_term()
                </a></li>
<li title="erl_size"><a href="erl_eterm.html#erl_size">erl_size()
                </a></li>
<li title="erl_init"><a href="erl_eterm.html#erl_init">erl_init()
                </a></li>
<li title="erl_set_compat_rel"><a href="erl_eterm.html#erl_set_compat_rel">erl_set_compat_rel()
                </a></li>
<li title="erl_cons"><a href="erl_eterm.html#erl_cons">erl_cons()
                </a></li>
<li title="erl_copy_term"><a href="erl_eterm.html#erl_copy_term">erl_copy_term()
                </a></li>
<li title="erl_element"><a href="erl_eterm.html#erl_element">erl_element()
                </a></li>
<li title="erl_hd"><a href="erl_eterm.html#erl_hd">erl_hd()
                </a></li>
<li title="erl_iolist_to_binary"><a href="erl_eterm.html#erl_iolist_to_binary">erl_iolist_to_binary()
                </a></li>
<li title="erl_mk_atom"><a href="erl_eterm.html#erl_mk_atom">erl_mk_atom()
                </a></li>
<li title="erl_mk_binary"><a href="erl_eterm.html#erl_mk_binary">erl_mk_binary()
                </a></li>
<li title="erl_mk_empty_list"><a href="erl_eterm.html#erl_mk_empty_list">erl_mk_empty_list()
                </a></li>
<li title="erl_mk_estring"><a href="erl_eterm.html#erl_mk_estring">erl_mk_estring()
                </a></li>
<li title="erl_mk_float"><a href="erl_eterm.html#erl_mk_float">erl_mk_float()
                </a></li>
<li title="erl_mk_int"><a href="erl_eterm.html#erl_mk_int">erl_mk_int()
                </a></li>
<li title="erl_mk_list"><a href="erl_eterm.html#erl_mk_list">erl_mk_list()
                </a></li>
<li title="erl_mk_long_ref"><a href="erl_eterm.html#erl_mk_long_ref">erl_mk_long_ref()
                </a></li>
<li title="erl_mk_pid"><a href="erl_eterm.html#erl_mk_pid">erl_mk_pid()
                </a></li>
<li title="erl_mk_port"><a href="erl_eterm.html#erl_mk_port">erl_mk_port()
                </a></li>
<li title="erl_mk_ref"><a href="erl_eterm.html#erl_mk_ref">erl_mk_ref()
                </a></li>
<li title="erl_mk_string"><a href="erl_eterm.html#erl_mk_string">erl_mk_string()
                </a></li>
<li title="erl_mk_tuple"><a href="erl_eterm.html#erl_mk_tuple">erl_mk_tuple()
                </a></li>
<li title="erl_mk_uint"><a href="erl_eterm.html#erl_mk_uint">erl_mk_uint()
                </a></li>
<li title="erl_mk_var"><a href="erl_eterm.html#erl_mk_var">erl_mk_var()
                </a></li>
<li title="erl_tl"><a href="erl_eterm.html#erl_tl">erl_tl()
                </a></li>
<li title="erl_var_content"><a href="erl_eterm.html#erl_var_content">erl_var_content()
                </a></li>
</ul>
</li>
<li id="no" title="erl_format " expanded="false">erl_format<ul>
<li><a href="erl_format.html">
                  Top of manual page
                </a></li>
    <li title="erl_match"><a href="erl_format.html#erl_match">erl_match()
                </a></li>
<li title="erl_format"><a href="erl_format.html#erl_format">erl_format()
                </a></li>
</ul>
</li>
<li id="no" title="erl_global " expanded="false">erl_global<ul>
<li><a href="erl_global.html">
                  Top of manual page
                </a></li>
    <li title="erl_global_names"><a href="erl_global.html#erl_global_names">erl_global_names()
                </a></li>
<li title="erl_global_register"><a href="erl_global.html#erl_global_register">erl_global_register()
                </a></li>
<li title="erl_global_unregister"><a href="erl_global.html#erl_global_unregister">erl_global_unregister()
                </a></li>
<li title="erl_global_whereis"><a href="erl_global.html#erl_global_whereis">erl_global_whereis()
                </a></li>
</ul>
</li>
<li id="no" title="erl_malloc " expanded="false">erl_malloc<ul>
<li><a href="erl_malloc.html">
                  Top of manual page
                </a></li>
    <li title="erl_eterm_release"><a href="erl_malloc.html#erl_eterm_release">erl_eterm_release()
                </a></li>
<li title="erl_eterm_statistics"><a href="erl_malloc.html#erl_eterm_statistics">erl_eterm_statistics()
                </a></li>
<li title="erl_free"><a href="erl_malloc.html#erl_free">erl_free()
                </a></li>
<li title="erl_free_array"><a href="erl_malloc.html#erl_free_array">erl_free_array()
                </a></li>
<li title="erl_free_compound"><a href="erl_malloc.html#erl_free_compound">erl_free_compound()
                </a></li>
<li title="erl_free_term"><a href="erl_malloc.html#erl_free_term">erl_free_term()
                </a></li>
<li title="erl_malloc"><a href="erl_malloc.html#erl_malloc">erl_malloc()
                </a></li>
<li title="erl_alloc_eterm"><a href="erl_malloc.html#erl_alloc_eterm">erl_alloc_eterm()
                </a></li>
</ul>
</li>
<li id="no" title="erl_marshal " expanded="false">erl_marshal<ul>
<li><a href="erl_marshal.html">
                  Top of manual page
                </a></li>
    <li title="erl_compare_ext"><a href="erl_marshal.html#erl_compare_ext">erl_compare_ext()
                </a></li>
<li title="erl_encode"><a href="erl_marshal.html#erl_encode">erl_encode()
                </a></li>
<li title="erl_encode_buf"><a href="erl_marshal.html#erl_encode_buf">erl_encode_buf()
                </a></li>
<li title="erl_ext_size"><a href="erl_marshal.html#erl_ext_size">erl_ext_size()
                </a></li>
<li title="erl_term_len"><a href="erl_marshal.html#erl_term_len">erl_term_len()
                </a></li>
<li title="erl_peek_ext"><a href="erl_marshal.html#erl_peek_ext">erl_peek_ext()
                </a></li>
<li title="erl_ext_type"><a href="erl_marshal.html#erl_ext_type">erl_ext_type()
                </a></li>
<li title="erl_decode"><a href="erl_marshal.html#erl_decode">erl_decode()
                </a></li>
<li title="erl_decode_buf"><a href="erl_marshal.html#erl_decode_buf">erl_decode_buf()
                </a></li>
</ul>
</li>
<li title="erl_call"><a href="erl_call.html">erl_call</a></li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>erl_connect</h1></center>
  
  <h3>C LIBRARY</h3>
<div class="REFBODY">erl_connect</div>
  <h3>LIBRARY SUMMARY</h3>
<div class="REFBODY">Communicate with distributed Erlang.</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>This module provides support for communication between distributed
      Erlang nodes and C-nodes, in a manner that is transparent to Erlang
      processes.</p>

    <p>A C-node appears to Erlang as a <strong>hidden node</strong>.
      That is, Erlang processes that know the name of the
      C-node can communicate with it in a normal manner, but
      the node name does not appear in the listing provided by
      <span class="bold_code"><a href="erlang.html#nodes-0"><span class="code">erlang:nodes/0</span></a></span>
      in <span class="code">ERTS</span>.</p>
  </p></div>

  <h3>EXPORTS</h3>
    <p><a name="erl_accept"><span class="bold_code">int erl_accept(listensock, conp)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int listensock;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ErlConnect *conp;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function is used by a server process to accept a
          connection from a client process.</p>
        <ul>
          <li>
<span class="code">listensock</span> is an open socket descriptor on
            which <span class="code">listen()</span> has previously been called.</li>
          <li>
<span class="code">conp</span> is a pointer to an
            <span class="code">ErlConnect</span> struct, described as follows:</li>
        </ul>
        <div class="example"><pre>
typedef struct {
  char ipadr[4];
  char nodename[MAXNODELEN];
} ErlConnect;
        </pre></div>
        <p>On success, <span class="code">conp</span> is filled in with the address and
          node name of the connecting client and a file descriptor is
          returned. On failure, <span class="code">ERL_ERROR</span> is returned and
          <span class="code">erl_errno</span> is set to <span class="code">EIO</span>.</p>
      </p></div>

    <p><a name="erl_close_connection"><span class="bold_code">int erl_close_connection(fd)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Closes an open connection to an Erlang node.</p>
        <p><span class="code">Fd</span> is a file descriptor obtained from
          <span class="code">erl_connect()</span> or
          <span class="code">erl_xconnect()</span>.</p>
        <p>Returns <span class="code">0</span> on success. If the call fails, a non-zero value
          is returned, and the reason for the error can be obtained with the
          appropriate platform-dependent call.</p>
      </p></div>

    <p><a name="erl_connect"><span class="bold_code">int erl_connect(node)</span></a><br><a name="erl_xconnect"><span class="bold_code">int erl_xconnect(addr, alive)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">char *node, *alive;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">struct in_addr *addr;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Sets up a connection to an Erlang node.</p>
        <p><span class="code">erl_xconnect()</span> requires the IP address of the
          remote host and the alivename of the remote node to be
          specified. <span class="code">erl_connect()</span> provides an alternative
          interface, and determines the information from the node name
          provided.</p>
        <ul>
          <li>
<span class="code">addr</span> is the 32-bit IP address of the remote
            host.</li>
          <li>
<span class="code">alive</span> is the alivename of the remote node.
          </li>
          <li>
<span class="code">node</span> is the name of the remote node.</li>
        </ul>
        <p>Returns an open file descriptor on success, otherwise a negative
          value. In the latter case <span class="code">erl_errno</span> is set to one
          of:</p>
        <dl>
          <dt><strong><span class="code">EHOSTUNREACH</span></strong></dt>
          <dd>The remote host <span class="code">node</span> is unreachable.</dd>
          <dt><strong><span class="code">ENOMEM</span></strong></dt>
          <dd>No more memory is available.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
        <p>Also, <span class="code">errno</span> values from
          <span class="code">socket</span><strong>(2)</strong> and
          <span class="code">connect</span><strong>(2)</strong>
          system calls can be propagated into <span class="code">erl_errno</span>.</p>
        <p><strong>Example:</strong></p>
        <div class="example"><pre>
#define NODE   "madonna@chivas.du.etx.ericsson.se"
#define ALIVE  "madonna"
#define IP_ADDR "150.236.14.75"

/*** Variant 1 ***/
erl_connect( NODE );

/*** Variant 2 ***/
struct in_addr addr;
addr = inet_addr(IP_ADDR);
erl_xconnect( &amp;addr , ALIVE );
        </pre></div>
      </p></div>

    <p><a name="erl_connect_init"><span class="bold_code">int erl_connect_init(number, cookie, creation)</span></a><br><a name="erl_connect_xinit"><span class="bold_code">int erl_connect_xinit(host, alive, node, addr, cookie, creation)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int number;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">char *cookie;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">short creation;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">char *host,*alive,*node;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">struct in_addr *addr;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Initializes the <span class="code">erl_connect</span> module.
          In particular, these functions are used to identify the name of the
          C-node from which they are called. One of these functions must
          be called before any of the other functions in the <span class="code">erl_connect</span>
          module are used.</p>
        <p><span class="code">erl_connect_xinit()</span> stores for later use
          information about:</p>
        <ul>
          <li>Hostname of the node, <span class="code">host</span>
</li>
          <li>Alivename, <span class="code">alive</span>
</li>
          <li>Node name, <span class="code">node</span>
</li>
          <li>IP address, <span class="code">addr</span>
</li>
          <li>Cookie, <span class="code">cookie</span>
</li>
          <li>Creation number, <span class="code">creation</span>
</li>
        </ul>
        <p><span class="code">erl_connect_init()</span>
          provides an alternative interface that does not require as much
          information from the caller. Instead,
          <span class="code">erl_connect_init()</span>
          uses <span class="code">gethostbyname()</span> to obtain default values.</p>
        <p>If you use <span class="code">erl_connect_init()</span>, your node will
          have a short name, that is, it will not be fully qualified. If you
          need to use fully qualified (long) names, use
          <span class="code">erl_connect_xinit()</span> instead.</p>
        <ul>
          <li>
            <p><span class="code">host</span> is the name of the host on which the node
              is running.</p>
          </li>
          <li>
            <p><span class="code">alive</span> is the alivename of the node.</p>
          </li>
          <li>
            <p><span class="code">node</span> is the node name. It is to
                be of the form <strong>alivename@hostname</strong>.</p>
          </li>
          <li>
            <p><span class="code">addr</span> is the 32-bit IP address of
              <span class="code">host</span>.</p>
          </li>
          <li>
            <p><span class="code">cookie</span> is the authorization string required
              for access to the remote node. If <span class="code">NULL</span>, the user
              <span class="code">HOME</span> directory is searched for a cookie file
              <span class="code">.erlang.cookie</span>. The path to
              the home directory is retrieved from environment variable
              <span class="code">HOME</span> on Unix and from the
              <span class="code">HOMEDRIVE</span> and
              <span class="code">HOMEPATH</span> variables on Windows. For more
              details, see the <span class="bold_code"><a href="auth.html"><span class="code">auth</span></a></span> module in Kernel.</p>
          </li>
          <li>
            <p><span class="code">creation</span> helps identifying a particular
              instance of a C-node. In particular, it can help prevent us from
              receiving messages sent to an earlier process with the same
              registered name.</p>
          </li>
        </ul>
        <p>A C-node acting as a server is assigned a creation number
          when it calls <span class="code">erl_publish()</span>.</p>
        <p><span class="code">number</span> is used by
          <span class="code">erl_connect_init()</span> to
          construct the actual node name. In Example 2
          below, <strong>"c17@a.DNS.name"</strong> is the resulting node name.</p>
        <p><strong>Example 1:</strong></p>
        <div class="example"><pre>
struct in_addr addr;
addr = inet_addr("150.236.14.75");
if (!erl_connect_xinit("chivas",
                       "madonna",
                       "madonna@chivas.du.etx.ericsson.se",
                       &amp;addr;
                       "samplecookiestring..."),
                       0)
  erl_err_quit("&lt;ERROR&gt; when initializing !");
        </pre></div>
        <p><strong>Example 2:</strong></p>
        <div class="example"><pre>
if (!erl_connect_init(17, "samplecookiestring...", 0))
  erl_err_quit("&lt;ERROR&gt; when initializing !");
        </pre></div>
      </p></div>

    <p><a name="erl_publish"><span class="bold_code">int erl_publish(port)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int port;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function is used by a server process to register
          with the local name server EPMD, thereby allowing
          other processes to send messages by using the registered name.
          Before calling this function, the process should
          have called <span class="code">bind()</span> and <span class="code">listen()</span>
          on an open socket.</p>
        <p><span class="code">port</span> is the local name to register, and is to be
          the same as the port number that was previously bound to the
          socket.</p>
        <p>To unregister with EPMD, simply close the returned descriptor.</p>
        <p>On success, a descriptor connecting the calling process to EPMD is
          returned. On failure, <span class="code">-1</span> is returned and
          <span class="code">erl_errno</span> is set to:</p>
        <dl>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
        <p>Also, <span class="code">errno</span> values from
          <span class="code">socket</span><strong>(2)</strong>
          and <span class="code">connect</span><strong>(2)</strong> system calls can be
          propagated into <span class="code">erl_errno</span>.</p>
      </p></div>

    <p><a name="erl_receive"><span class="bold_code">int erl_receive(fd, bufp, bufsize)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">char *bufp;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int bufsize;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Receives a message consisting of a sequence
          of bytes in the Erlang external format.</p>
        <ul>
          <li>
<span class="code">fd</span> is an open descriptor to an Erlang
            connection.</li>
          <li>
<span class="code">bufp</span> is a buffer large enough to hold the
            expected message.</li>
          <li>
<span class="code">bufsize</span> indicates the size of
            <span class="code">bufp</span>.</li>
        </ul>
        <p>If a <strong>tick</strong> occurs, that is, the Erlang node on the
          other end of the connection has polled this node to see if it
          is still alive, the function returns <span class="code">ERL_TICK</span> and
          no message is placed in the buffer. Also,
          <span class="code">erl_errno</span> is set to <span class="code">EAGAIN</span>.</p>
        <p>On success, the message is placed in the specified buffer
          and the function returns the number of bytes actually read. On
          failure, the function returns a negative value and sets
          <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">EAGAIN</span></strong></dt>
          <dd>Temporary error: Try again.</dd>
          <dt><strong><span class="code">EMSGSIZE</span></strong></dt>
          <dd>Buffer is too small.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
      </p></div>

    <p><a name="erl_receive_msg"><span class="bold_code">int erl_receive_msg(fd, bufp, bufsize, emsg)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">unsigned char *bufp;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int bufsize;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ErlMessage *emsg;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Receives the message into the specified buffer
          and decodes into <span class="code">(ErlMessage *) emsg</span>.</p>
        <ul>
          <li>
<span class="code">fd</span> is an open descriptor to an Erlang
            connection.</li>
          <li>
<span class="code">bufp</span> is a buffer large enough to hold the
            expected message.</li>
          <li>
<span class="code">bufsize</span> indicates the size of
            <span class="code">bufp</span>.</li>
          <li>&gt;<span class="code">emsg</span> is a pointer to an
            <span class="code">ErlMessage</span> structure
            into which the message will be decoded.
            <span class="code">ErlMessage</span> is defined as follows:</li>
        </ul>
        <div class="example"><pre>
typedef struct {
  int type;
  ETERM *msg;
  ETERM *to;
  ETERM *from;
  char to_name[MAXREGLEN];
} ErlMessage;
        </pre></div>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>The definition of <span class="code">ErlMessage</span> has changed since
            earlier versions of <span class="code">Erl_Interface</span>.</p>
        </p></div>
</div>
        <p><span class="code">type</span> identifies the type of message, one of the
          following:</p>
        <dl>
          <dt><strong><span class="code">ERL_SEND</span></strong></dt>
          <dd>
            <p>An ordinary send operation has occurred and
              <span class="code">emsg-&gt;to</span> contains the pid of the recipient.
              The message is in <span class="code">emsg-&gt;msg</span>.</p>
          </dd>
          <dt><strong><span class="code">ERL_REG_SEND</span></strong></dt>
          <dd>
            <p>A registered send operation has occurred and
              <span class="code">emsg-&gt;from</span> contains the pid of the sender.
              The message is in <span class="code">emsg-&gt;msg</span>.</p>
          </dd>
          <dt><strong><span class="code">ERL_LINK</span> or <span class="code">ERL_UNLINK</span>
          </strong></dt>
          <dd>
            <p><span class="code">emsg-&gt;to</span> and <span class="code">emsg-&gt;from</span>
              contain the pids of the sender and recipient of the link or
              unlink. <span class="code">emsg-&gt;msg</span> is not used.</p>
          </dd>
          <dt><strong><span class="code">ERL_EXIT</span></strong></dt>
          <dd>
            <p>A link is broken. <span class="code">emsg-&gt;to</span> and
              <span class="code">emsg-&gt;from</span> contain the pids of the linked
              processes, and <span class="code">emsg-&gt;msg</span> contains the reason
              for the exit.</p>
          </dd>
        </dl>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>It is the caller's responsibility to release the
            memory pointed to by <span class="code">emsg-&gt;msg</span>,
            <span class="code">emsg-&gt;to</span>, and
            <span class="code">emsg-&gt;from</span>.</p>
        </p></div>
</div>
        <p>If a <strong>tick</strong> occurs, that is, the Erlang node on the
          other end of the connection has polled this node to see if it
          is still alive, the function returns <span class="code">ERL_TICK</span>
          indicating that the tick has been received and responded to,
          but no message is placed in the buffer. In this case you
          are to call <span class="code">erl_receive_msg()</span> again.</p>
        <p>On success, the function returns <span class="code">ERL_MSG</span> and the
          <span class="code">Emsg</span> struct is initialized as described above, or
          <span class="code">ERL_TICK</span>, in which case no message is returned. On
          failure, the function returns <span class="code">ERL_ERROR</span> and sets
          <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">EMSGSIZE</span></strong></dt>
          <dd>Buffer is too small.</dd>
          <dt><strong><span class="code">ENOMEM</span></strong></dt>
          <dd>No more memory is available.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
      </p></div>

    <p><a name="erl_reg_send"><span class="bold_code">int erl_reg_send(fd, to, msg)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">char *to;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ETERM *msg;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Sends an Erlang term to a registered process.</p>
        <ul>
          <li>
<span class="code">fd</span> is an open descriptor to an Erlang
            connection.</li>
          <li>
<span class="code">to</span> is a string containing the registered name
            of the intended recipient of the message.</li>
          <li>
<span class="code">msg</span> is the Erlang term to be sent.</li>
        </ul>
        <p>Returns <span class="code">1</span> on success, otherwise <span class="code">0</span>. In
          the latter case <span class="code">erl_errno</span> is set to one of:</p>
        <dl>
          <dt><strong><span class="code">ENOMEM</span></strong></dt>
          <dd>No more memory is available.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
      </p></div>

    <p><a name="erl_rpc"><span class="bold_code">ETERM *erl_rpc(fd, mod, fun, args)</span></a><br><a name="erl_rpc_from"><span class="bold_code">int erl_rpc_from(fd, timeout, emsg)</span></a><br><a name="erl_rpc_to"><span class="bold_code">int erl_rpc_to(fd, mod, fun, args)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd, timeout;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">char *mod, *fun;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ETERM *args;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ErlMessage *emsg;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Supports calling Erlang functions on remote nodes.
          <span class="code">erl_rpc_to()</span> sends an RPC request to a remote node
          and <span class="code">erl_rpc_from()</span> receives the results of such a
          call. <span class="code">erl_rpc()</span> combines the functionality of
          these two functions by sending an RPC request and waiting for the
          results. See also <span class="bold_code"><a href="rpc.html#call-4"><span class="code">rpc:call/4</span></a></span> in <span class="code">Kernel</span>.</p>
        <ul>
          <li>
<span class="code">fd</span> is an open descriptor to an Erlang
            connection.</li>
          <li>
<span class="code">timeout</span> is the maximum time (in milliseconds)
            to wait for
            results. To wait forever, specify <span class="code">ERL_NO_TIMEOUT</span>.
            When <span class="code">erl_rpc()</span> calls <span class="code">erl_rpc_from()</span>, the call will
            never timeout.</li>
          <li>
<span class="code">mod</span> is the name of the module containing the
            function to be run on the remote node.</li>
          <li>
<span class="code">fun</span> is the name of the function to run.
          </li>
          <li>
<span class="code">args</span> is an Erlang list, containing the
            arguments to be passed to the function.</li>
          <li>
<span class="code">emsg</span> is a message containing the result of
            the function call.</li>
        </ul>
        <p>The actual message returned by the RPC server
          is a 2-tuple <span class="code">{rex,Reply}</span>. If you use
          <span class="code">erl_rpc_from()</span> in your code, this is the message
          you will need to parse. If you use <span class="code">erl_rpc()</span>, the
          tuple itself is parsed for you, and the message returned to your
          program is the Erlang term containing <span class="code">Reply</span> only.
          Replies to RPC requests are always <span class="code">ERL_SEND</span> messages.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>It is the caller's responsibility to free the returned
            <span class="code">ETERM</span> structure and the memory pointed to by
            <span class="code">emsg-&gt;msg</span> and <span class="code">emsg-&gt;to</span>.</p>
        </p></div>
</div>
        <p><span class="code">erl_rpc()</span> returns the remote function's return
          value on success, otherwise <span class="code">NULL</span>.</p>
        <p><span class="code">erl_rpc_to()</span> returns <span class="code">0</span> on
          success, otherwise a negative number.</p>
        <p><span class="code">erl_rcp_from()</span> returns <span class="code">ERL_MSG</span>
          on success (with <span class="code">Emsg</span> now
          containing the reply tuple), otherwise one of
          <span class="code">ERL_TICK</span>, <span class="code">ERL_TIMEOUT</span>, or
          <span class="code">ERL_ERROR</span>.</p>
        <p>When failing,
          all three functions set <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">ENOMEM</span></strong></dt>
          <dd>No more memory is available.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
          <dt><strong><span class="code">ETIMEDOUT</span></strong></dt>
          <dd>Timeout has expired.</dd>
          <dt><strong><span class="code">EAGAIN</span></strong></dt>
          <dd>Temporary error: Try again.</dd>
        </dl>
      </p></div>

    <p><a name="erl_send"><span class="bold_code">int erl_send(fd, to, msg)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ETERM *to, *msg;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Sends an Erlang term to a process.</p>
        <ul>
          <li>
<span class="code">fd</span> is an open descriptor to an Erlang
            connection.</li>
          <li>
<span class="code">to</span> is an Erlang term containing the pid of
            the intended recipient of the message.</li>
          <li>&gt;<span class="code">msg</span> is the Erlang term to be sent.</li>
        </ul>
        <p>Returns <span class="code">1</span> on success, otherwise <span class="code">0</span>. In
          the latter case <span class="code">erl_errno</span> is set to one of:</p>
        <dl>
          <dt><strong><span class="code">EINVAL</span></strong></dt>
          <dd>Invalid argument: <span class="code">to</span> is not a valid Erlang
            pid.</dd>
          <dt><strong><span class="code">ENOMEM</span></strong></dt>
          <dd>No more memory is available.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
      </p></div>

    <p><a name="erl_thisalivename"><span class="bold_code">const char *erl_thisalivename()</span></a><br><a name="erl_thiscookie"><span class="bold_code">const char *erl_thiscookie()</span></a><br><a name="erl_thiscreation"><span class="bold_code">short erl_thiscreation()</span></a><br><a name="erl_thishostname"><span class="bold_code">const char *erl_thishostname()</span></a><br><a name="erl_thisnodename"><span class="bold_code">const char *erl_thisnodename()</span></a><br></p>
<div class="REFBODY"><p>
        <p>Retrieves information about
          the C-node. These values are initially set with
          <span class="code">erl_connect_init()</span> or
          <span class="code">erl_connect_xinit()</span>.</p>
      </p></div>

    <p><a name="erl_unpublish"><span class="bold_code">int erl_unpublish(alive)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">char *alive;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
       <p>This function can be called by a process to unregister a
          specified node from EPMD on the local host. This is, however, usually
          not allowed, unless EPMD was started with flag
          <span class="code">-relaxed_command_check</span>, which it normally is not.</p>
        <p>To unregister a node you have published, you should instead
          close the descriptor that was returned by
          <span class="code">ei_publish()</span>.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>This function is deprecated and will be removed in a future
            release.</p>
        </p></div>
</div>
        <p><span class="code">alive</span> is the name of the node to unregister, that
          is, the first component of the node name, without
          <span class="code">@hostname</span>.</p>
        <p>If the node was successfully unregistered from EPMD, <span class="code">0</span> is
          returned, otherwise <span class="code">-1</span> is returned and
          <span class="code">erl_errno</span> is set to <span class="code">EIO</span>.</p>
      </p></div>

    <p><a name="erl_xreceive_msg"><span class="bold_code">int erl_xreceive_msg(fd, bufpp, bufsizep, emsg)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">int fd;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">unsigned char **bufpp;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int *bufsizep;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ErlMessage *emsg;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Similar to <span class="code">erl_receive_msg</span>. The difference is
          that <span class="code">erl_xreceive_msg</span> expects the buffer to
          have been allocated by <span class="code">malloc</span>, and reallocates it
          if the received
          message does not fit into the original buffer. Therefore
          both buffer and buffer length are given as pointers; their values
          can change by the call.</p>
        <p>On success, the function returns <span class="code">ERL_MSG</span> and the
          <span class="code">Emsg</span> struct is initialized as described above, or
          <span class="code">ERL_TICK</span>, in which case no message is returned. On
          failure, the function returns <span class="code">ERL_ERROR</span> and sets
          <span class="code">erl_errno</span> to one of:</p>
        <dl>
          <dt><strong><span class="code">EMSGSIZE</span></strong></dt>
          <dd>Buffer is too small.</dd>
          <dt><strong><span class="code">ENOMEM</span></strong></dt>
          <dd>No more memory is available.</dd>
          <dt><strong><span class="code">EIO</span></strong></dt>
          <dd>I/O error.</dd>
        </dl>
      </p></div>

    <p><a name="*erl_gethostbyaddr"><span class="bold_code">struct hostent *erl_gethostbyaddr(addr, length, type)</span></a><br><a name="*erl_gethostbyaddr_r"><span class="bold_code">struct hostent *erl_gethostbyaddr_r(addr, length, type, hostp, buffer, buflen, h_errnop)</span></a><br><a name="*erl_gethostbyname"><span class="bold_code">struct hostent *erl_gethostbyname(name)</span></a><br><a name="*erl_gethostbyname_r"><span class="bold_code">struct hostent *erl_gethostbyname_r(name, hostp, buffer, buflen, h_errnop)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">const char *name;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">const char *addr;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int length;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int type;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">struct hostent *hostp;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">char *buffer;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int buflen;</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">int *h_errnop;</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Convenience functions for some common name lookup functions.</p>
      </p></div>
  

  <h3><a name="id85944">Debug Information</a></h3>
<div class="REFBODY">
    
    <p>If a connection attempt fails, the following can be checked:</p>

    <ul>
      <li><span class="code">erl_errno</span></li>
      <li>That the correct cookie was used</li>
      <li>That EPMD is running</li>
      <li>That the remote Erlang node on the other side is running the same
        version of Erlang as the <span class="code">erl_interface</span> library</li>
    </ul>
  </div>
</div>
<div class="footer">
<hr>
<p>Copyright © 1998-2017 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
