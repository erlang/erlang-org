<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Getting Started</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="index.html">Reference Manual</a><br><a href="release_notes.html">Release Notes</a><br><a href="mnesia.pdf">PDF</a><br><a href="../../index.html">Top</a></small><p><strong>Mnesia</strong><br><strong>User's Guide</strong><br><small>Version 4.14.3</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="Mnesia_chap1.html">
              Top of chapter
            </a></li>
<li title="Scope"><a href="Mnesia_chap1.html#id61644">Scope</a></li>
<li title="Prerequisites"><a href="Mnesia_chap1.html#id61417">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="Mnesia" expanded="false">Mnesia<ul>
<li><a href="Mnesia_overview.html">
              Top of chapter
            </a></li>
<li title="Mnesia Database Management System (DBMS)"><a href="Mnesia_overview.html#id71288">Mnesia Database Management System (DBMS)</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Getting Started" expanded="true">Getting Started<ul>
<li><a href="Mnesia_chap2.html">
              Top of chapter
            </a></li>
<li title="Starting Mnesia for the First Time"><a href="Mnesia_chap2.html#id62055">Starting Mnesia for the First Time</a></li>
<li title="Example"><a href="Mnesia_chap2.html#id61610">Example</a></li>
</ul>
</li>
<li id="no" title="Build a Mnesia Database" expanded="false">Build a Mnesia Database<ul>
<li><a href="Mnesia_chap3.html">
              Top of chapter
            </a></li>
<li title="Define a Schema"><a href="Mnesia_chap3.html#id66423">Define a Schema</a></li>
<li title="Data Model"><a href="Mnesia_chap3.html#id66740">Data Model</a></li>
<li title="Start Mnesia"><a href="Mnesia_chap3.html#id70785">Start Mnesia</a></li>
<li title="Create Tables"><a href="Mnesia_chap3.html#id71247">Create Tables</a></li>
</ul>
</li>
<li id="no" title="Transactions and Other Access Contexts" expanded="false">Transactions and Other Access Contexts<ul>
<li><a href="Mnesia_chap4.html">
              Top of chapter
            </a></li>
<li title="Transaction Properties"><a href="Mnesia_chap4.html#id76498">Transaction Properties</a></li>
<li title="Locking"><a href="Mnesia_chap4.html#id76760">Locking</a></li>
<li title="Dirty Operations"><a href="Mnesia_chap4.html#id77333">Dirty Operations</a></li>
<li title="Record Names versus Table Names"><a href="Mnesia_chap4.html#id77796">Record Names versus Table Names</a></li>
<li title="Activity Concept and Various Access Contexts"><a href="Mnesia_chap4.html#id77894">Activity Concept and Various Access Contexts</a></li>
<li title="Nested Transactions"><a href="Mnesia_chap4.html#id78433">Nested Transactions</a></li>
<li title="Pattern Matching"><a href="Mnesia_chap4.html#id78524">Pattern Matching</a></li>
<li title="Iteration"><a href="Mnesia_chap4.html#id78993">Iteration</a></li>
</ul>
</li>
<li id="no" title="Miscellaneous Mnesia Features" expanded="false">Miscellaneous Mnesia Features<ul>
<li><a href="Mnesia_chap5.html">
              Top of chapter
            </a></li>
<li title="Indexing"><a href="Mnesia_chap5.html#id79417">Indexing</a></li>
<li title="Distribution and Fault Tolerance"><a href="Mnesia_chap5.html#id79556">Distribution and Fault Tolerance</a></li>
<li title="Table Fragmentation"><a href="Mnesia_chap5.html#id79716">Table Fragmentation</a></li>
<li title="Local Content Tables"><a href="Mnesia_chap5.html#id80725">Local Content Tables</a></li>
<li title="Disc-Less Nodes"><a href="Mnesia_chap5.html#id80752">Disc-Less Nodes</a></li>
<li title="More about Schema Management"><a href="Mnesia_chap5.html#id80974">More about Schema Management</a></li>
<li title="Mnesia Event Handling"><a href="Mnesia_chap5.html#id81276">Mnesia Event Handling</a></li>
<li title="Debugging Mnesia Applications"><a href="Mnesia_chap5.html#id82045">Debugging Mnesia Applications</a></li>
<li title="Concurrent Processes in Mnesia"><a href="Mnesia_chap5.html#id82194">Concurrent Processes in Mnesia</a></li>
<li title="Prototyping"><a href="Mnesia_chap5.html#id82246">Prototyping</a></li>
<li title="Object-Based Programming with Mnesia"><a href="Mnesia_chap5.html#id82386">Object-Based Programming with Mnesia</a></li>
</ul>
</li>
<li id="no" title="Mnesia System Information" expanded="false">Mnesia System Information<ul>
<li><a href="Mnesia_chap7.html">
              Top of chapter
            </a></li>
<li title="Database Configuration Data"><a href="Mnesia_chap7.html#id82718">Database Configuration Data</a></li>
<li title="Core Dumps"><a href="Mnesia_chap7.html#id82763">Core Dumps</a></li>
<li title="Dumping Tables"><a href="Mnesia_chap7.html#id82795">Dumping Tables</a></li>
<li title="Checkpoints"><a href="Mnesia_chap7.html#id82843">Checkpoints</a></li>
<li title="Startup Files, Log File, and Data Files"><a href="Mnesia_chap7.html#id83104">Startup Files, Log File, and Data Files</a></li>
<li title="Loading Tables at Startup"><a href="Mnesia_chap7.html#id83618">Loading Tables at Startup</a></li>
<li title="Recovery from Communication Failure"><a href="Mnesia_chap7.html#id83837">Recovery from Communication Failure</a></li>
<li title="Recovery of Transactions"><a href="Mnesia_chap7.html#id84021">Recovery of Transactions</a></li>
<li title="Backup, Restore, Fallback, and Disaster Recovery"><a href="Mnesia_chap7.html#id84205">Backup, Restore, Fallback, and Disaster Recovery</a></li>
</ul>
</li>
<li id="no" title="Combine Mnesia with SNMP" expanded="false">Combine Mnesia with SNMP<ul>
<li><a href="Mnesia_chap8.html">
              Top of chapter
            </a></li>
<li title="Combine Mnesia and SNMP"><a href="Mnesia_chap8.html#id85168">Combine Mnesia and SNMP</a></li>
</ul>
</li>
<li id="no" title="Appendix A: Backup Callback Interface" expanded="false">Appendix A: Backup Callback Interface<ul>
<li><a href="Mnesia_App_A.html">
              Top of chapter
            </a></li>
<li title="mnesia_backup Callback Behavior"><a href="Mnesia_App_A.html#id85278">mnesia_backup Callback Behavior</a></li>
</ul>
</li>
<li id="no" title="Appendix B: Activity Access Callback Interface" expanded="false">Appendix B: Activity Access Callback Interface<ul>
<li><a href="Mnesia_App_B.html">
              Top of chapter
            </a></li>
<li title="mnesia_access Callback Behavior"><a href="Mnesia_App_B.html#id85398">mnesia_access Callback Behavior</a></li>
</ul>
</li>
<li id="no" title="Appendix C: Fragmented Table Hashing Callback Interface" expanded="false">Appendix C: Fragmented Table Hashing Callback Interface<ul>
<li><a href="Mnesia_App_C.html">
              Top of chapter
            </a></li>
<li title="mnesia_frag_hash Callback Behavior"><a href="Mnesia_App_C.html#id85542">mnesia_frag_hash Callback Behavior</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>3Â Getting Started</h1>
  
    <a name="getting_started"></a>
  <p>This section introduces <span class="code">Mnesia</span> with an example database.
    This example is referenced in the
    following sections, where the example is modified to
    illustrate various program constructs. This section illustrates
    the following mandatory procedures through examples:</p>
  <ul>
    <li>Starting the Erlang session.
    </li>
    <li>Specifying the <span class="code">Mnesia</span> directory where the database
      is to be stored.
    </li>
    <li>Initializing a new database schema with an attribute that
      specifies on which node, or nodes, that database is to operate.
    </li>
    <li>Starting <span class="code">Mnesia</span>.
    </li>
    <li>Creating and populating the database tables.
    </li>
  </ul>

  <h3><a name="id62055">3.1Â 
        Starting Mnesia for the First Time</a></h3>
    
    <p>This section provides a simplified demonstration of a <span class="code">Mnesia</span>
      system startup. The dialogue from the Erlang shell is as follows:</p>
    <div class="example"><pre>
        unix&gt;  erl -mnesia dir '"/tmp/funky"'
        Erlang (BEAM) emulator version 4.9
        
        Eshell V4.9  (abort with ^G)
        1&gt; 
        1&gt; mnesia:create_schema([node()]).
        ok
        2&gt; mnesia:start().
        ok
        3&gt; mnesia:create_table(funky, []).
        {atomic,ok}
        4&gt; mnesia:info().
        ---&gt; Processes holding locks &lt;--- 
        ---&gt; Processes waiting for locks &lt;--- 
        ---&gt; Pending (remote) transactions &lt;--- 
        ---&gt; Active (local) transactions &lt;---
        ---&gt; Uncertain transactions &lt;--- 
        ---&gt; Active tables &lt;--- 
        funky          : with 0 records occupying 269 words of mem 
        schema         : with 2 records occupying 353 words of mem 
        ===&gt; System info in version "1.0", debug level = none &lt;===
        opt_disc. Directory "/tmp/funky" is used.
        use fall-back at restart = false
        running db nodes = [nonode@nohost]
        stopped db nodes = [] 
        remote           = []
        ram_copies       = [funky]
        disc_copies      = [schema]
        disc_only_copies = []
        [{nonode@nohost,disc_copies}] = [schema]
        [{nonode@nohost,ram_copies}] = [funky]
        1 transactions committed, 0 aborted, 0 restarted, 1 logged to disc
        0 held locks, 0 in queue; 0 local transactions, 0 remote
        0 transactions waits for other nodes: []
        ok      
    </pre></div>
    <p>In this example, the following actions are performed:</p>
    <ul>
      <li>
<strong>Step 1:</strong> The Erlang system is started from the UNIX
       prompt with a flag <span class="code">-mnesia dir '"/tmp/funky"'</span>, which indicates
       in which directory to store the data.
      </li>
      <li>
<strong>Step 2:</strong> A new empty schema is initialized on the local
       node by evaluating
       <span class="bold_code"><a href="../../man/mnesia.html#create_schema-1">mnesia:create_schema([node()])</a></span>.
       The schema contains information about the database in general.
       This is explained in detail later.
      </li>
      <li>
<strong>Step 3:</strong> The DBMS is started by evaluating
       <span class="bold_code"><a href="../../man/mnesia.html#start-0">mnesia:start()</a></span>.
      </li>
      <li>
<strong>Step 4:</strong> A first table is created, called <span class="code">funky</span>,
       by evaluating the expression <span class="code">mnesia:create_table(funky, [])</span>.
       The table is given default properties.
      </li>
      <li>
<strong>Step 5:</strong> <span class="bold_code"><a href="../../man/mnesia.html#info-0">mnesia:info()</a></span>
       is evaluated to
       display information on the terminal about the status of the database.
      </li>
    </ul>
  

  <h3><a name="id61610">3.2Â 
        Example</a></h3>
    
    <p>A <span class="code">Mnesia</span> database is organized as a set of tables.
      Each table is populated with instances (Erlang records).
      A table has also a number of properties, such as location and
      persistence.</p>

    <h4>Database</h4>
      
    
    <p>This example shows how to create a database called <span class="code">Company</span>
      and the relationships shown in the following diagram:</p>
    <img alt="IMAGE MISSING" src="company.gif"><br>
      <p><em>Figure
        3.1:
        Â 
        Company Entity-Relation Diagram</em></p>
    
    <p>The database model is as follows:</p>
    <ul>
      <li>There are three entities: department, employee, and project.
      </li>
      <li>
        <p>There are three relationships between these entities:</p>
        <ul>
          <li>A department is managed by an employee,
            hence the <span class="code">manager</span> relationship.
          </li>
          <li>An employee works at a department, hence the
            <span class="code">at_dep</span> relationship.
          </li>
          <li>Each employee works on a number of projects,
            hence the <span class="code">in_proj</span> relationship.
          </li>
        </ul>
      </li>
    </ul>

    <h4>Defining Structure and Content</h4>
      
      <p>First the record definitions are entered into a text file
        named <span class="code">company.hrl</span>. This file defines the following
        structure for the example database: </p>
<div class="example"><pre>

-record(employee, {emp_no,
                   name,
                   salary,
                   sex,
                   phone,
                   room_no}).

-record(dept, {id, 
               name}).

-record(project, {name,
                  number}).


-record(manager, {emp,
                  dept}).

-record(at_dep, {emp,
                 dept_id}).

-record(in_proj, {emp,
                  proj_name}).
</pre></div>      <p>The structure defines six tables in the database. In <span class="code">Mnesia</span>,
        the function
        <span class="bold_code"><a href="../../man/mnesia.html#create_table-2">mnesia:create_table(Name, ArgList)</a></span>
        creates tables. <span class="code">Name</span> is the table name.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>The current version of <span class="code">Mnesia</span> does not require that
        the name of the table is the same as the record name, see
        <span class="bold_code"><a href="Mnesia_chap4.html#recordnames_tablenames">Record Names versus Table Names.</a></span>.</p></p></div>
</div>
      <p>For example, the table for employees is created with the
        function <span class="code">mnesia:create_table(employee,
        [{attributes, record_info(fields, employee)}])</span>. The table
        name <span class="code">employee</span> matches the name for records specified
        in <span class="code">ArgList</span>. The expression
        <span class="code">record_info(fields, RecordName)</span> is processed by the Erlang
        preprocessor and evaluates to a list containing the names of the
        different fields for a record.</p>
    

    <h4>Program</h4>
      
      <p>The following shell interaction starts <span class="code">Mnesia</span> and
        initializes the schema for the <span class="code">Company</span> database:</p>
      <div class="example"><pre>
        % <span class="bold_code">erl -mnesia dir '"/ldisc/scratch/Mnesia.Company"'</span>
         Erlang (BEAM) emulator version 4.9
          
          Eshell V4.9  (abort with ^G)
          1&gt; mnesia:create_schema([node()]).
          ok
          2&gt; mnesia:start().
          ok</pre></div>
      <p>The following program module creates and populates previously
        defined tables:</p>
<div class="example"><pre>


-include_lib("stdlib/include/qlc.hrl").
-include("company.hrl").

init() -&gt;
    mnesia:create_table(employee,
                        [{attributes, record_info(fields, employee)}]),
    mnesia:create_table(dept,
                        [{attributes, record_info(fields, dept)}]),
    mnesia:create_table(project,
                        [{attributes, record_info(fields, project)}]),
    mnesia:create_table(manager, [{type, bag}, 
                                  {attributes, record_info(fields, manager)}]),
    mnesia:create_table(at_dep,
                         [{attributes, record_info(fields, at_dep)}]),
    mnesia:create_table(in_proj, [{type, bag}, 
                                  {attributes, record_info(fields, in_proj)}]).
</pre></div>    

    <h4>Program Explained</h4>
      
      <p>The following commands and functions are used to initiate the
        <span class="code">Company</span> database:</p>
      <ul>
        <li>
<span class="code">% erl -mnesia dir '"/ldisc/scratch/Mnesia.Company"'</span>.
         This is a UNIX
         command-line entry that starts the Erlang system. The flag
         <span class="code">-mnesia dir Dir</span> specifies the location of the
         database directory. The system responds and waits for
         further input with the prompt <span class="code">1&gt;</span>.
        </li>
        <li>
        <span class="bold_code"><a href="../../man/mnesia.html#create_schema-1">mnesia:create_schema([node()])</a></span>.
         This function
         has the format <span class="code">mnesia:create_schema(DiscNodeList)</span> and
         initiates a new schema. In this example, a non-distributed system
         using only one node is created. Schemas are fully explained in
         <span class="bold_code"><a href="Mnesia_chap3.html#def_schema">Define a Schema</a></span>.
        </li>
        <li>
<span class="bold_code"><a href="../../man/mnesia.html#start-0">mnesia:start()</a></span>.
         This function starts <span class="code">Mnesia</span> and is fully explained in
         <span class="bold_code"><a href="Mnesia_chap3.html#start_mnesia">Start Mnesia</a></span>.
        </li>
      </ul>
      <p>Continuing the dialogue with the Erlang shell produces the
        following:</p>
      <div class="example"><pre>
        3&gt; company:init().
        {atomic,ok}
        4&gt; mnesia:info().
        ---&gt; Processes holding locks &lt;--- 
        ---&gt; Processes waiting for locks &lt;--- 
        ---&gt; Pending (remote) transactions &lt;--- 
        ---&gt; Active (local) transactions &lt;---
        ---&gt; Uncertain transactions &lt;--- 
        ---&gt; Active tables &lt;--- 
        in_proj        : with 0 records occuping 269 words of mem 
        at_dep         : with 0 records occuping 269 words of mem 
        manager        : with 0 records occuping 269 words of mem 
        project        : with 0 records occuping 269 words of mem 
        dept           : with 0 records occuping 269 words of mem 
        employee       : with 0 records occuping 269 words of mem 
        schema         : with 7 records occuping 571 words of mem 
        ===&gt; System info in version "1.0", debug level = none &lt;===
        opt_disc. Directory "/ldisc/scratch/Mnesia.Company" is used.
        use fall-back at restart = false
        running db nodes = [nonode@nohost]
        stopped db nodes = [] 
        remote           = []
        ram_copies       =
            [at_dep,dept,employee,in_proj,manager,project]
        disc_copies      = [schema]
        disc_only_copies = []
        [{nonode@nohost,disc_copies}] = [schema]
        [{nonode@nohost,ram_copies}] =
            [employee,dept,project,manager,at_dep,in_proj]
        6 transactions committed, 0 aborted, 0 restarted, 6 logged to disc
        0 held locks, 0 in queue; 0 local transactions, 0 remote
        0 transactions waits for other nodes: []
        ok
      </pre></div>
      <p>A set of tables is created. The function
        <span class="bold_code"><a href="../../man/mnesia.html#create_table-2">mnesia:create_table(Name, ArgList)</a></span>
        creates the required database tables. The
        options available with <span class="code">ArgList</span> are explained in
        <span class="bold_code"><a href="Mnesia_chap3.html#create_tables">Create New Tables</a></span>.</p>
      <p>The function <span class="code">company:init/0</span> creates the tables. Two tables
        are of type <span class="code">bag</span>. This is the <span class="code">manager</span> relation as well
        the <span class="code">in_proj</span> relation. This is interpreted as: an
        employee can be manager over several departments, and an employee
        can participate in several projects. However, the <span class="code">at_dep</span>
        relation is <span class="code">set</span>, as an employee can only work in one department.
        In this data model, there are examples of relations that are 1-to-1
        (<span class="code">set</span>) and  1-to-many (<span class="code">bag</span>).</p>
      <p><span class="bold_code"><a href="../../man/mnesia.html#info-0">mnesia:info()</a></span>
        now indicates that a database has seven
        local tables, where six are the user-defined tables and one is
        the schema. Six transactions have been committed, as six successful
        transactions were run when creating the tables.</p>
      <p>To write a function that inserts an employee record into the
        database, there must be an <span class="code">at_dep</span> record and a set of
        <span class="code">in_proj</span> records inserted. Examine the following
        code used to complete this action:</p>
<div class="example"><pre>


insert_emp(Emp, DeptId, ProjNames) -&gt;
    Ename = Emp#employee.name,
    Fun = fun() -&gt;
                  mnesia:write(Emp),
                  AtDep = #at_dep{emp = Ename, dept_id = DeptId},
                  mnesia:write(AtDep),
                  mk_projs(Ename, ProjNames)
          end,
    mnesia:transaction(Fun).


mk_projs(Ename, [ProjName|Tail]) -&gt;
    mnesia:write(#in_proj{emp = Ename, proj_name = ProjName}),
    mk_projs(Ename, Tail);
mk_projs(_, []) -&gt; ok.
    
</pre></div>      <ul>
        <li>
          <p>The <span class="code">insert_emp/3</span> arguments are as follows:</p>
          <ul>
            <li>
<span class="code">Emp</span> is an employee record.
            </li>
            <li>
<span class="code">DeptId</span> is the identity of the department where
             the employee works.
            </li>
            <li>
<span class="code">ProjNames</span> is a list of the names of the projects
             where the employee works.</li>
          </ul>
        </li>
      </ul>
      <p>The function <span class="code">insert_emp/3</span> creates a Functional Object (Fun).
        <span class="code">Fun</span> is passed
        as a single argument to the function
        <span class="bold_code"><a href="../../man/mnesia.html#transaction-2">mnesia:transaction(Fun)</a></span>.
        This means that <span class="code">Fun</span> is
        run as a transaction with the following properties:</p>
      <ul>
        <li>A <span class="code">Fun</span> either succeeds or fails.
        </li>
        <li>Code that manipulates the same data records can be
         run concurrently without the different processes interfering
         with each other. 
        </li>
      </ul>
      <p>The function can be used as follows:</p>
      <div class="example"><pre>
          Emp  = #employee{emp_no= 104732,
                           name = klacke,
                           salary = 7,
                           sex = male,
                           phone = 98108,
                           room_no = {221, 015}},
        insert_emp(Emp, 'B/SFR', [Erlang, mnesia, otp]).</pre></div>
      <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>For information about Funs, see "Fun Expressions" in
        section <span class="code">Erlang Reference Manual</span> in System
        Documentation..</p>
      </p></div>
</div>
    

    <h4>Initial Database Content</h4>
      
      <p>After the insertion of the  employee named <span class="code">klacke</span>,
        the databse has the following records:</p>
      <a name="table2_1"></a>
      <table border="1" cellpadding="2" cellspacing="0">
<tr>
          <td align="left" valign="middle">emp_no</td>
          <td align="left" valign="middle">name</td>
          <td align="left" valign="middle">salary</td>
          <td align="left" valign="middle">sex</td>
          <td align="left" valign="middle">phone</td>
          <td align="left" valign="middle">room_no</td>
        </tr>
<tr>
          <td align="left" valign="middle">104732</td>
          <td align="left" valign="middle">klacke</td>
          <td align="left" valign="middle">7</td>
          <td align="left" valign="middle">male</td>
          <td align="left" valign="middle">98108</td>
          <td align="left" valign="middle">{221, 015}</td>
        </tr>
</table>
<em>Table
        3.1:
        Â 
        employee Database Record</em>
      <p>This <span class="code">employee</span> record has the Erlang record/tuple
        representation
        <span class="code">{employee, 104732, klacke, 7, male, 98108, {221, 015}}</span>.</p>
      <a name="table2_2"></a>
      <table border="1" cellpadding="2" cellspacing="0">
<tr>
          <td align="left" valign="middle">emp</td>
          <td align="left" valign="middle">dept_name</td>
        </tr>
<tr>
          <td align="left" valign="middle">klacke</td>
          <td align="left" valign="middle">B/SFR</td>
        </tr>
</table>
<em>Table
        3.2:
        Â 
        at_dep Database Record</em>
      <p>This <span class="code">at_dep</span> record has the Erlang tuple representation
        <span class="code">{at_dep, klacke, 'B/SFR'}</span>.</p>
      <a name="table3_3"></a>
      <table border="1" cellpadding="2" cellspacing="0">
<tr>
          <td align="left" valign="middle">emp</td>
          <td align="left" valign="middle">proj_name</td>
        </tr>
<tr>
          <td align="left" valign="middle">klacke</td>
          <td align="left" valign="middle">Erlang</td>
        </tr>
<tr>
          <td align="left" valign="middle">klacke</td>
          <td align="left" valign="middle">otp</td>
        </tr>
<tr>
          <td align="left" valign="middle">klacke</td>
          <td align="left" valign="middle">mnesia</td>
        </tr>
</table>
<em>Table
        3.3:
        Â 
        in_proj Database Record</em>
      <p>This <span class="code">in_proj</span> record has the Erlang tuple representation
        <span class="code">{in_proj, klacke, 'Erlang', klacke, 'otp', klacke,
        'mnesia'}</span>.</p>
      <p>There is no difference between rows in a table and <span class="code">Mnesia</span>
        records. Both concepts are the same and are used
        interchangeably throughout this User's Guide.</p>
      <p>A <span class="code">Mnesia</span> table is populated by <span class="code">Mnesia</span> records. For
        example, the tuple <span class="code">{boss, klacke, bjarne}</span> is a record. The
        second element in this tuple is the key. To identify a table
        uniquely, both the key and the table name is needed.
        The term Object Identifier (OID) is
        sometimes used for the arity two tuple {Tab, Key}. The OID for
        the record <span class="code">{boss, klacke, bjarne}</span> is the arity two
        tuple <span class="code">{boss, klacke}</span>. The first element of the tuple is
        the type of the record and the second element is the key. An
        OID can lead to zero, one, or more records depending on
        whether the table type is <span class="code">set</span> or <span class="code">bag</span>.</p>
      <p>The record <span class="code">{boss, klacke, bjarne}</span> can also be inserted.
        This record contains an implicit reference to
        another employee that does not yet exist in the
        database. <span class="code">Mnesia</span> does not enforce this.</p>
    

    <h4>Adding Records and Relationships to Database</h4>
      
      <p>After adding more records to the <span class="code">Company</span> database, the
        result can be the following records:</p>
      <p><span class="code">employees</span>:</p>
      <div class="example"><pre>
        {employee, 104465, "Johnson Torbjorn",   1, male,  99184, {242,038}}.
        {employee, 107912, "Carlsson Tuula",     2, female,94556, {242,056}}.
        {employee, 114872, "Dacker Bjarne",      3, male,  99415, {221,035}}.
        {employee, 104531, "Nilsson Hans",       3, male,  99495, {222,026}}.
        {employee, 104659, "Tornkvist Torbjorn", 2, male,  99514, {222,022}}.
        {employee, 104732, "Wikstrom Claes",     2, male,  99586, {221,015}}.
        {employee, 117716, "Fedoriw Anna",       1, female,99143, {221,031}}.
        {employee, 115018, "Mattsson Hakan",     3, male,  99251, {203,348}}.</pre></div>
      <p><span class="code">dept</span>:</p>
      <div class="example"><pre>
        {dept, 'B/SF',  "Open Telecom Platform"}.
        {dept, 'B/SFP', "OTP - Product Development"}.
        {dept, 'B/SFR', "Computer Science Laboratory"}.</pre></div>
      <p><span class="code">projects</span>:</p>
      <div class="example"><pre>
        %% projects
        {project, erlang, 1}.
        {project, otp, 2}.
        {project, beam, 3}.
        {project, mnesia, 5}.
        {project, wolf, 6}.
        {project, documentation, 7}.
        {project, www, 8}.</pre></div>
      <p>These three tables, <span class="code">employees</span>, <span class="code">dept</span>, and
        <span class="code">projects</span>, are
        made up of real records. The following database content is
        stored in the tables and is built on
        relationships. These tables are <span class="code">manager</span>,
        <span class="code">at_dep</span>, and <span class="code">in_proj</span>.</p>
      <p><span class="code">manager</span>:</p>
      <div class="example"><pre>
        {manager, 104465, 'B/SF'}.
        {manager, 104465, 'B/SFP'}.
        {manager, 114872, 'B/SFR'}.</pre></div>
      <p><span class="code">at_dep</span>:</p>
      <div class="example"><pre>
        {at_dep, 104465, 'B/SF'}.
        {at_dep, 107912, 'B/SF'}.
        {at_dep, 114872, 'B/SFR'}.
        {at_dep, 104531, 'B/SFR'}.
        {at_dep, 104659, 'B/SFR'}.
        {at_dep, 104732, 'B/SFR'}.
        {at_dep, 117716, 'B/SFP'}.
        {at_dep, 115018, 'B/SFP'}.</pre></div>
      <p><span class="code">in_proj</span>:</p>
      <div class="example"><pre>
        {in_proj, 104465, otp}.
        {in_proj, 107912, otp}.
        {in_proj, 114872, otp}.
        {in_proj, 104531, otp}.
        {in_proj, 104531, mnesia}.
        {in_proj, 104545, wolf}.
        {in_proj, 104659, otp}.
        {in_proj, 104659, wolf}.
        {in_proj, 104732, otp}.
        {in_proj, 104732, mnesia}.
        {in_proj, 104732, erlang}.
        {in_proj, 117716, otp}.
        {in_proj, 117716, documentation}.
        {in_proj, 115018, otp}.
        {in_proj, 115018, mnesia}.</pre></div>
      <p>The room number is an attribute of the employee
        record. This is a structured attribute that consists of a
        tuple. The first element of the tuple identifies a corridor,
        and the second element identifies the room in that
        corridor. An alternative is to represent this as a record
        <span class="code">-record(room, {corr, no}).</span> instead of an anonymous
        tuple representation.</p>
      <p>The <span class="code">Company</span> database is now initialized and contains
        data.</p>
    

    <h4>Writing Queries</h4>
      
      <p>Retrieving data from DBMS is usually to be done with the
        functions
        <span class="bold_code"><a href="../../man/mnesia.html#read-3">mnesia:read/3</a></span> or
        <span class="bold_code"><a href="../../man/mnesia.html#read-2">mnesia:read/1</a></span>.
        The following function raises the salary:</p>
<div class="example"><pre>

raise(Eno, Raise) -&gt;
    F = fun() -&gt;
                [E] = mnesia:read(employee, Eno, write),
                Salary = E#employee.salary + Raise,
                New = E#employee{salary = Salary},
                mnesia:write(New)
        end,
    mnesia:transaction(F).</pre></div>      <p>Since it is desired to update the record using the function
        <span class="bold_code"><a href="../../man/mnesia.html#write-1">mnesia:write/1</a></span>
        after the salary has been increased, a write
        lock (third argument to <span class="code">read</span>) is acquired when the record from
        the table is read.</p>
      <p>To read the values from the table directly is not always possible.
        It can be needed to search one or more tables to get the
        wanted data, and this is done by writing database queries. Queries
        are always more expensive operations than direct lookups done with
        <span class="code">mnesia:read</span>. Therefore, avoid queries in
        performance-critical code.</p>
      <p>Two methods are available for writing database queries:</p>
      <ul>
        <li>
<span class="code">Mnesia</span> functions</li>
        <li>QLC</li>
      </ul>

      <h5>Using Mnesia Functions</h5>
        
        <p>The following function extracts the names of the female employees
          stored in the database:</p>
        <div class="example"><pre>
mnesia:select(employee, [{#employee{sex = female, name = '$1', _ = '_'},[], ['$1']}]).</pre></div>
        <p><span class="code">select</span> must always run within an activity, such as a
          transaction. The following function can be constructed to call
          from the shell:</p>
<div class="example"><pre>

all_females() -&gt;
    F = fun() -&gt;
		Female = #employee{sex = female, name = '$1', _ = '_'},
		mnesia:select(employee, [{Female, [], ['$1']}])
        end,
    mnesia:transaction(F).</pre></div>        <p>The <span class="code">select</span> expression matches all entries in table
          employee with the field <span class="code">sex</span> set to <span class="code">female</span>.</p>
        <p>This function can be called from the shell as follows:</p>
        <div class="example"><pre>
          (klacke@gin)1&gt; <span class="bold_code">company:all_females().</span>
          {atomic,  ["Carlsson Tuula", "Fedoriw Anna"]}</pre></div>
        <p>For a description of <span class="code">select</span> and its syntax, see
          <span class="bold_code"><a href="Mnesia_chap4.html#matching">Pattern Matching</a></span>.
	</p>
      

      <h5>Using QLC </h5>
        
        <p>This section contains simple introductory examples only. For
          a full description of the QLC query language, see the
          <span class="bold_code"><a href="../../man/qlc.html">qlc</a></span> manual page in
          <span class="code">STDLIB</span>.</p>
        <p>Using QLC can be more expensive than using <span class="code">Mnesia</span>
          functions directly but offers a nice syntax.</p>
        <p>The following function extracts a list of female employees
          from the database:</p>
        <div class="example"><pre>
          Q = qlc:q([E#employee.name || E &lt;- mnesia:table(employee),
                                E#employee.sex == female]),
          qlc:e(Q),</pre></div>
        <p>Accessing <span class="code">Mnesia</span> tables from a QLC list comprehension must
          always be done within a transaction. Consider the following
          function:</p>
<div class="example"><pre>

females() -&gt;
    F = fun() -&gt;
		Q = qlc:q([E#employee.name || E &lt;- mnesia:table(employee),
					      E#employee.sex == female]),
		qlc:e(Q)
	end,
    mnesia:transaction(F).</pre></div>        <p>This function can be called from the shell as follows:</p>
        <div class="example"><pre>
          (klacke@gin)1&gt; <span class="bold_code">company:females().</span>
          {atomic, ["Carlsson Tuula", "Fedoriw Anna"]}</pre></div>
        <p>In traditional relational database terminology, this
          operation is called a selection, followed by a projection.</p>
        <p>The previous list comprehension expression contains a
          number of syntactical elements:</p>
        <ul>
          <li>The first <span class="code">[</span> bracket is read as "build the
           list".
          </li>
          <li>The <span class="code">||</span> "such that" and the arrow <span class="code">&lt;-</span>
           is read as "taken from".
          </li>
        </ul>
        <p>Hence, the previous list comprehension demonstrates the
          formation of the list <span class="code">E#employee.name</span> such that <span class="code">E</span> is
          taken from the table of employees, and attribute <span class="code">sex</span>
          of each record is equal to the atom <span class="code">female</span>.</p>
        <p>The whole list comprehension must be given to the function
          <span class="code">qlc:q/1</span>.</p>
        <p>List comprehensions with low-level <span class="code">Mnesia</span> functions
          can be combined in the same transaction. To raise the
          salary of all female employees, execute the following:</p>
<div class="example"><pre>

raise_females(Amount) -&gt;
    F = fun() -&gt;
                Q = qlc:q([E || E &lt;- mnesia:table(employee),
                                E#employee.sex == female]),
		Fs = qlc:e(Q),
                over_write(Fs, Amount)
        end,
    mnesia:transaction(F).

over_write([E|Tail], Amount) -&gt;
    Salary = E#employee.salary + Amount,
    New = E#employee{salary = Salary},
    mnesia:write(New),
    1 + over_write(Tail, Amount);
over_write([], _) -&gt;
    0.</pre></div>        <p>The function <span class="code">raise_females/1</span> returns the tuple
          <span class="code">{atomic, Number}</span>, where <span class="code">Number</span> is the number of
          female employees who received a salary increase. If an error
          occurs, the value <span class="code">{aborted, Reason}</span> is returned, and
          <span class="code">Mnesia</span> guarantees that the salary is not
          raised for any employee.</p>
        <p><strong>Example:</strong></p>
        <div class="example"><pre>
          33&gt;<span class="bold_code">company:raise_females(33).</span>
          {atomic,2}</pre></div>
      
    
  
</div>
<div class="footer">
<hr>
<p>Copyright Â© 1997-2017 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
