<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- The Jinterface Package</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="index.html">Reference Manual</a><br><a href="release_notes.html">Release Notes</a><br><a href="jinterface.pdf">PDF</a><br><a href="../../index.html">Top</a></small><p><strong>jinterface</strong><br><strong>User's Guide</strong><br><small>Version 1.6.1</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../../js/flipmenu"><li id="loadscrollpos" title="The Jinterface Package" expanded="true">The Jinterface Package<ul>
<li><a href="jinterface_users_guide.html">
              Top of chapter
            </a></li>
<li title="Mapping of Basic Erlang Types to Java"><a href="jinterface_users_guide.html#id56838">Mapping of Basic Erlang Types to Java</a></li>
<li title="Special Mapping Issues"><a href="jinterface_users_guide.html#id60370">Special Mapping Issues</a></li>
<li title="Nodes"><a href="jinterface_users_guide.html#id61176">Nodes</a></li>
<li title="Mailboxes"><a href="jinterface_users_guide.html#id61212">Mailboxes</a></li>
<li title="Connections"><a href="jinterface_users_guide.html#id60830">Connections</a></li>
<li title="Transport Factory"><a href="jinterface_users_guide.html#id61286">Transport Factory</a></li>
<li title="Sending and Receiving Messages"><a href="jinterface_users_guide.html#id61304">Sending and Receiving Messages</a></li>
<li title="Sending Arbitrary Data"><a href="jinterface_users_guide.html#id61449">Sending Arbitrary Data</a></li>
<li title="Linking to Remote Processes"><a href="jinterface_users_guide.html#id56900">Linking to Remote Processes</a></li>
<li title="Using EPMD"><a href="jinterface_users_guide.html#id56966">Using EPMD</a></li>
<li title="Remote Procedure Calls"><a href="jinterface_users_guide.html#id60558">Remote Procedure Calls</a></li>
<li title="Compiling and Loading Your Code"><a href="jinterface_users_guide.html#id60599">Compiling and Loading Your Code</a></li>
<li title="Tracing"><a href="jinterface_users_guide.html#id60476">Tracing</a></li>
</ul>
</li></ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>1 The Jinterface Package</h1>
  
  <p>The <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/package-summary.html">Jinterface</a></span> package provides 
    a set of tools for communication with Erlang processes. It can also be used for communication with 
    other Java processes using the same package, as well as C processes using the Erl_Interface library.  </p>
  <p>The set of classes in the package can be divided into two categories:
    those that provide the actual communication, and those that provide a
    Java representation of the Erlang data types. The latter are all
    subclasses of OtpErlangObject, and they are identified by the
    OtpErlang prefix.</p>
  <p>Since this package provides a mechanism for communicating with Erlang,
    message recipients can be Erlang processes or instances of
    com.ericsson.otp.erlang.OtpMbox, both of which are identified with
    pids and possibly registered names. When pids or mailboxes are
    mentioned as message senders or recipients in this section, it should
    assumed that even Erlang processes are included, unless specified
    otherwise.
    The classes in
    <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/package-summary.html">Jinterface</a></span> support the following:</p>
  <ul>
    <li>manipulation of data represented as Erlang data types</li>
    <li>conversion of data between Java and Erlang formats</li>
    <li>encoding and decoding of Erlang data types for transmission or storage</li>
    <li>communication between Java nodes and Erlang processes</li>
  </ul>
  <p>In the following sections, these topics are described:</p>
  <ul>
    <li>mapping of Erlang types to Java</li>
    <li>encoding, decoding, and sending Erlang terms</li>
    <li>connecting to a distributed Erlang node</li>
    <li>using nodes, mailboxes and EPMD</li>
    <li>sending and receiving Erlang messages and data</li>
    <li>remote procedure calls</li>
    <li>linking to remote processes</li>
    <li>compiling your code for use with Jinterface</li>
    <li>tracing message flow</li>
  </ul>

  <h3><a name="id56838">1.1 
        Mapping of Basic Erlang Types to Java</a></h3>
    
    <p>This section describes the mapping of Erlang basic types to Java. </p>
    <table border="1" cellpadding="2" cellspacing="0">
<tr>
        <td align="left" valign="middle">Erlang type</td>
        <td align="left" valign="middle">Java type</td>
      </tr>
<tr>
        <td align="left" valign="middle">atom</td>
        <td align="left" valign="middle"><span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangAtom.html">OtpErlangAtom</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle">binary</td>
        <td align="left" valign="middle"><span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangBinary.html">OtpErlangBinary</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle">floating point types</td>
        <td align="left" valign="middle">
<span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangFloat.html">OtpErlangFloat</a></span>or <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangDouble.html">OtpErlangDouble</a></span>, depending on the floating point value size</td>
      </tr>
<tr>
        <td align="left" valign="middle">integral types</td>
        <td align="left" valign="middle">One of <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangByte.html">OtpErlangByte</a></span>,<span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangChar.html">OtpErlangChar</a></span>,<span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangShort.html">OtpErlangShort</a></span>,<span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangUShort.html">OtpErlangUShort</a></span>,<span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangInt.html">OtpErlangInt</a></span>,<span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangUInt.html">OtpErlangUInt</a></span>or<span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangLong.html">OtpErlangLong</a></span>, depending on the integral value size and sign</td>
      </tr>
<tr>
        <td align="left" valign="middle">list</td>
        <td align="left" valign="middle"><span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangList.html">OtpErlangList</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle">pid</td>
        <td align="left" valign="middle"><span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangPid.html">OtpErlangPid</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle">port</td>
        <td align="left" valign="middle"><span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangPort.html">OtpErlangPort</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle">ref</td>
        <td align="left" valign="middle"><span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangRef.html">OtpErlangRef</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle">tuple</td>
        <td align="left" valign="middle"><span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangTuple.html">OtpErlangTuple</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle">map</td>
        <td align="left" valign="middle"><span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangMap.html">OtpErlangMap</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle">term</td>
        <td align="left" valign="middle"><span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangObject.html">OtpErlangObject</a></span></td>
      </tr>
</table>
<em>Table
        1.1:
         
        Mapping of Erlang basic types to Java</em>
  

  <h3><a name="id60370">1.2 
        Special Mapping Issues</a></h3>
    
    <p>The atoms <span class="code">true</span> and <span class="code">false</span> are special atoms, used as boolean values. 
      The class <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangBoolean.html">OtpErlangBoolean</a></span> can be used to represent these.</p>
    <p>Lists in Erlang are also used to describe sequences of printable characters (strings).
      A convenience class <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangString.html">OtpErlangString</a></span>
      is provided to represent Erlang strings.</p>
  

  <h3><a name="id61176">1.3 
        Nodes</a></h3>
    
    <p>A node as defined by Erlang/OTP is an instance of the Erlang Runtime
      System, a virtual machine roughly equivalent to a JVM. Each node has a
      unique name in the form of an identifier composed partly of the
      hostname on which the node is running, e.g "gurka@sallad.com". Several
      such nodes can run on the same host as long as their names are unique.
      The class <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpNode.html">OtpNode</a></span> 
      represents an Erlang node. It is created with a name
      and optionally a port number on which it listens for incoming
      connections. Before creating an instance of 
      <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpNode.html">OtpNode</a></span>, 
      ensure that Epmd is running on the host machine. See the Erlang documentation 
      for more information about Epmd. In this example, the host name is appended
      automatically to the identifier, and the port number is chosen by the
      underlying system:</p>
    <div class="example"><pre>
OtpNode node = new OtpNode("gurka");    </pre></div>
  

  <h3><a name="id61212">1.4 
        Mailboxes</a></h3>
    
    <p>Erlang processes running on an Erlang node are identified by process
      identifiers (pids) and, optionally, by registered names unique within
      the node. Each Erlang process has an implicit mailbox that is used to
      receive messages; the mailbox is identified with the pid of the
      process.</p>
    <p>Jinterface provides a similar mechanism with the class 
      <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpMbox.html">OtpMbox</a></span>, a
      mailbox that can be used to send and receive messages asynchronously.
      Each OtpMbox is identified with a unique pid and , optionally, a registered 
      name unique within the 
      <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpNode.html">OtpNode</a></span>. </p>
    <p>Applications are free to create mailboxes as necessary. This is done
      as follows:</p>
    <div class="example"><pre>
        OtpMbox mbox = node.createMbox();    </pre></div>
    <p>The mailbox created in the above example has no registered name,
      although it does have a pid. The pid can be obtained from the mailbox
      and included in messages sent from the mailbox, so that remote
      processes are able to respond. </p>
    <p>An application can register a name for a mailbox, either when the
      mailbox is initially created:</p>
    <div class="example"><pre>
        OtpMbox mbox = node.createMbox("server");    </pre></div>
    <p>or later on, as necessary:</p>
    <div class="example"><pre>
        OtpMbox mbox = node.createMbox();
        mbox.registerName("server");    </pre></div>
    <p>Registered names are usually necessary in order to start
      communication, since it is impossible to know in advance the pid of a
      remote process. If a well-known name for one of the processes is
      chosen in advance and known by all communicating parties within an
      application, each mailbox can send an initial message to the named
      mailbox, which then can identify the sender pid.</p>
  

  <h3><a name="id60830">1.5 
        Connections</a></h3>
    
    <p>It is not necessary to explicitly set up communication with a remote
      node. Simply sending a message to a mailbox on that node will cause
      the OtpNode to create a connection if one does not already exist. Once
      the connection is established, subsequent messages to the same node
      will reuse the same connection.</p>
    <p>It is possible to check for the existence of a remote node before
      attempting to communicate with it. Here we send a ping message to the
      remote node to see if it is alive and accepting connections:</p>
    <div class="example"><pre>
        if (node.ping("remote",2000)) {
          System.out.println("remote is up");
        }
        else {
          System.out.println("remote is not up");
       }    </pre></div>
    <p>If the call to ping() succeeds, a connection to the remote node has
      been established. Note that it is not necessary to ping remote nodes
      before communicating with them, but by using ping you can determine if
      the remote exists before attempting to communicate with it.</p>
    <p>Connections are only permitted by nodes using the same security
      cookie. The cookie is a short string provided either as an argument
      when creating OtpNode objects, or found in the user's home directory
      in the file <span class="code">.erlang.cookie</span>. When a connection attempt is made, the
      string is used as part of the authentication process. If you are
      having trouble getting communication to work, use the trace facility
      (described later in this document) to show the connection
      establishment. A likely problem is that the cookies are different.</p>
    <p>Connections are never broken explicitly. If a node fails or is closed,
      a connection may be broken however.</p>
  

  <h3><a name="id61286">1.6 
        Transport Factory</a></h3>
    
    <p>All necessary connections are made using methods of
    <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpTransportFactory.html">OtpTransportFactory</a></span>
    interface. Default OtpTransportFactory implementation is based on standard Socket class.
    User may provide custom transport factory as needed. See java doc for details.</p>
  

  <h3><a name="id61304">1.7 
        Sending and Receiving Messages</a></h3>
    
    <p>Messages sent with this package must be instances of 
      <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangObject.html">OtpErlangObject</a></span>
      or one of its subclasses. Message can be sent to processes or pids,
      either by specifying the pid of the remote, or its registered name and
      node.</p>
    <p>In this example, we create a message containing our own pid so the
      echo process can reply:</p>
    <div class="example"><pre>
        OtpErlangObject[] msg = new OtpErlangObject[2];
        msg[0] = mbox.self();
        msg[1] = new OtpErlangAtom("hello, world");
        OtpErlangTuple tuple = new OtpErlangTuple(msg);    </pre></div>
    <p>When we send the message, a connection will be created:</p>
    <div class="example"><pre>
        mbox.send("echo", "gurka@sallad.com", tuple);    </pre></div>
    <p>And here we receive the reply:</p>
    <div class="example"><pre>
        OtpErlangObject reply = mbox.receive();    </pre></div>
    <p>Messages are sent asynchronously, so the call to <span class="code">send()</span> returns as
      soon as the message has been dispatched to the underlying
      communication layer. This means that you receive no indication whether
      the operation completed successfully or the remote even existed. If
      you need this kind of confirmation, you should wait for a response
      from the remote process.</p>
    <p>The echo server itself might look like this:</p>
    <div class="example"><pre>
    OtpNode self = new OtpNode("gurka");
    OtpMbox mbox = self.createMbox("echo");
    OtpErlangObject o;
    OtpErlangTuple msg;
    OtpErlangPid from;
    
    while (true) {
      try {
        o = mbox.receive();
        if (o instanceof OtpErlangTuple) {
          msg = (OtpErlangTuple)o;
          from = (OtpErlangPid)(msg.elementAt(0));
          mbox.send(from,msg.elementAt(1));
      }
      catch (Exception e) {
        System.out.println("" + e);
      }
    }    </pre></div>
    <p>In the examples above, only one mailbox was created on each node.
      however you are free to create as many mailboxes on each node as you
      like. You are also free to create as many nodes as you like on each
      JVM, however because each node uses some limited system resources such
      as file descriptors, it is recommended that you create only a small
      number of nodes (such as one) on each JVM.</p>
  

  <h3><a name="id61449">1.8 
        Sending Arbitrary Data</a></h3>
    
    <p>This package was originally intended to be used for communicating
      between Java and Erlang, and for that reason the send and receive
      methods all use Java representations of Erlang data types. </p>
    <p>However it is possible to use the package to communicate with remote
      processes written in Java as well, and in these cases it may be
      desirable to send other data types.</p>
    <p>The simplest way to do this is to encapsulate arbitrary data in
      messages of type 
      <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpErlangBinary.html">OtpErlangBinary</a></span>. 
      The OtpErlangBinary class can be created from arbitrary Java objects that implement the 
      Serializable or Externalizable interface:</p>
    <div class="example"><pre>
        o = new MyClass(foo);
        mbox.send(remote,new OtpErlangBinary(o));    </pre></div>
    <p>The example above will cause the object to be serialized and
      encapsulated in an OtpErlangBinary before being sent. The recipient
      will receive an OtpErlangBinary but can extract the original object
      from it:</p>
    <div class="example"><pre>
        msg = mbox.receive();
        if (msg instanceof OtpErlangBinary) {
           OtpErlangBinary b = (OtpErlangBinary)msg;
           MyClass o = (MyClass)(b.getObject());
        }    </pre></div>
  

  <h3><a name="id56900">1.9 
        Linking to Remote Processes</a></h3>
    
    <p>Erlang defines a concept known as linked processes. A link is an
      implicit connection between two processes that causes an exception to
      be raised in one of the processes if the other process terminates for
      any reason. Links are bidirectional: it does not matter which of the
      two processes created the link or which of the linked processes
      eventually terminates; an exception will be raised in the remaining
      process. Links are also idempotent: at most one link can exist between
      two given processes, only one operation is necessary to remove the
      link.</p>
    <p>Jinterface provides a similar mechanism. Also here, no distinction is
      made between mailboxes and Erlang processes. A link can be created to
      a remote mailbox or process when its pid is known:</p>
    <div class="example"><pre>
        mbox.link(remote);    </pre></div>
    <p>The link can be removed by either of the processes in a similar manner:</p>
    <div class="example"><pre>
        mbox.unlink(remote);    </pre></div>
    <p>If the remote process terminates while the link is still in place, an
      exception will be raised on a subsequent call to receive():</p>
    <div class="example"><pre>
        try {
          msg = mbox.receive();
        }
        catch (OtpErlangExit e) {
          System.out.println("Remote pid " + e.pid() + " has terminated");
        }
        catch (OtpErlangDecodeException f) {
          System.out.println("Received message could not be decoded: " + f);
        }    </pre></div>
    <p>When a mailbox is explicitly closed, exit messages will be sent in
      order to break any outstanding links. If a mailbox is never closed but
      instead goes out of scope, the objects <span class="code">finalize()</span> method will call
      <span class="code">close()</span>. However since Java provides no guarantees about when or even
      if finalize() will be called, it is important that your application
      explicitly closes mailboxes when they are no longer needed if you
      want links to work in a timely manner. 
      </p>
  

  <h3><a name="id56966">1.10 
        Using EPMD</a></h3>
    
    <p>Epmd is the Erlang Port Mapper Daemon. Distributed Erlang nodes
      register with epmd on the localhost to indicate to other nodes that
      they exist and can accept connections. Epmd maintains a register of
      node and port number information, and when a node wishes to connect to
      another node, it first contacts epmd in order to find out the correct
      port number to connect to.</p>
    <p>The basic interaction with EPMD is done through instances of 
      <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpEpmd.html">OtpEpmd</a></span> class.
      Nodes wishing to contact other nodes must first request information 
      from Epmd before a connection can be set up, however this is done automatically 
      by <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpSelf.html#connect(com.ericsson.otp.erlang.OtpPeer)">OtpSelf.connect()</a></span> when necessary. </p>
    <p>When you use <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpSelf.html#connect(com.ericsson.otp.erlang.OtpPeer)">OtpSelf.connect()</a></span> to connect to an Erlang node, 
      a connection is first made to epmd and, if the node is known, a
      connection is then made to the Erlang node.</p>
    <p>Java nodes can also register themselves with epmd if they want other
      nodes in the system to be able to find and connect to them.
      This is done by call to method <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpEpmd.html#publishPort(com.ericsson.otp.erlang.OtpLocalNode)">OtpEpmd.publishPort()</a></span>.</p>
    <p>Be aware that on some systems (such as VxWorks), a failed node will
      not be detected by this mechanism since the operating system does not
      automatically close descriptors that were left open when the node
      failed. If a node has failed in this way, epmd will prevent you from
      registering a new node with the old name, since it thinks that the old
      name is still in use. In this case, you must unregister the name
      explicitly, by using <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpEpmd.html#unPublishPort(com.ericsson.otp.erlang.OtpLocalNode)">OtpEpmd.unPublishPort()</a></span></p>
    <p>This will cause epmd to close the connection from the far end. Note
      that if the name was in fact still in use by a node, the results of
      this operation are unpredictable. Also, doing this does not cause the
      local end of the connection to close, so resources may be consumed.</p>
  

  <h3><a name="id60558">1.11 
        Remote Procedure Calls</a></h3>
    
    <p>An Erlang node acting as a client to another Erlang node
      typically sends a request and waits for a reply. Such a request is
      included in a function call at a remote node and is called a remote
      procedure call. Remote procedure calls are supported through the class
      <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpConnection.html">OtpConnection</a></span>.
      The following example shows how the
      <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpConnection.html">OtpConnection</a></span> 
      class is used for remote procedure calls:</p>
    <div class="example"><pre>

OtpSelf self = new OtpSelf("client", "hejsan" ); 
OtpPeer other  = new OtpPeer("server@balin"); 
OtpConnection connection = self.connect(other); 

connection.sendRPC("erlang","date",new OtpErlangList());
OtpErlangObject received = connection.receiveRPC(); 
    </pre></div>
    <p><span class="code">erlang:date/0</span> is just called to get the date tuple
      from a remote host. </p>
  

  <h3><a name="id60599">1.12 
        Compiling and Loading Your Code</a></h3>
    
    <p>In order to use any of the <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/package-summary.html">Jinterface</a></span> 
      classes, include the following line in your code:</p>
    <div class="example"><pre>
import com.ericsson.otp.erlang.*;    </pre></div>
    <p>Determine where the top directory of your OTP installation is. You
      can find this out by starting Erlang and entering the following
      command at the Eshell prompt:</p>
    <div class="example"><pre>
Eshell V4.9.1.2  (abort with ^G)
1&gt; code:root_dir().
/usr/local/otp    </pre></div>
    <p>To compile your code, make sure that your Java compiler knows where
      to find the file <span class="code">OtpErlang.jar</span> which contains the package.
      This is done by specifying an appropriate <span class="code">-classpath</span>
      argument on the command line, or by adding it to the <span class="code">CLASSPATH</span>
      definition in your <span class="code">Makefile</span>. The correct value for this path is
      <span class="code">$OTPROOT/lib/jinterface</span><strong>Vsn</strong><span class="code">/priv/OtpErlang.jar</span>, where <span class="code">$OTPROOT</span> 
      is the path reported by <span class="code">code:root_dir/0</span> in the above example and <strong>Vsn</strong> is the version of Jinterface, for example <span class="code">jinterface-1.2</span></p>
    <div class="example"><pre>
$ javac -classpath ".:/usr/local/otp/lib/jinterface-1.2/priv/OtpErlang.jar" 
                    myclass.java    </pre></div>
    <p>When running your program, you will also need to specify the path to
      <span class="code">OtpErlang.jar</span> in a similar way.</p>
    <div class="example"><pre>
$ java ".:/usr/local/otp/lib/jinterface-1.2/priv/OtpErlang.jar" myclass    </pre></div>
  

  <h3><a name="id60476">1.13 
        Tracing</a></h3>
    
    <p>Communication between nodes can be traced by setting a system property
      before the communication classes in this package are initialized. 
      The value system property "OtpConnection.trace" is the default trace
      level for all connections. Normally the default trace level is zero,
      i.e. no tracing is performed. By setting 
      <span class="bold_code"><a href="../../apps/jinterface/java/com/ericsson/otp/erlang/OtpConnection.html">OtpConnection.trace</a></span> 
      to some non-zero value, the communication protocol can be shown in more or
      less detail. The valid values are:</p>
    <ul>
      <li>0: no tracing is performed</li>
      <li>1: only ordinary send and reg-send messages are shown</li>
      <li>2: control messages such as link, unlink and exit are shown</li>
      <li>3: connection setup (handshake) is shown</li>
      <li>4: epmd requests are shown</li>
    </ul>
    <p>Each level also includes the information shown by all lower levels.</p>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 2000-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
