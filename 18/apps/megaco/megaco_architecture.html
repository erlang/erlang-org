<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Architecture</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="index.html">Reference Manual</a><br><a href="release_notes.html">Release Notes</a><br><a href="megaco.pdf">PDF</a><br><a href="../../index.html">Top</a></small><p><strong>Megaco/H.248</strong><br><strong>User's Guide</strong><br><small>Version 3.18</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="megaco_intro.html">
              Top of chapter
            </a></li>
<li title="Scope and Purpose"><a href="megaco_intro.html#id60802">Scope and Purpose</a></li>
<li title="Prerequisites"><a href="megaco_intro.html#id60440">Prerequisites</a></li>
<li title="About This Manual"><a href="megaco_intro.html#id60663">About This Manual</a></li>
<li title="Where to Find More Information"><a href="megaco_intro.html#id61675">Where to Find More Information</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Architecture" expanded="true">Architecture<ul>
<li><a href="megaco_architecture.html">
              Top of chapter
            </a></li>
<li title="Network view"><a href="megaco_architecture.html#id60397">Network view</a></li>
<li title="General"><a href="megaco_architecture.html#id61412">General</a></li>
<li title="Single node config"><a href="megaco_architecture.html#id56838">Single node config</a></li>
<li title="Distributed config"><a href="megaco_architecture.html#id61926">Distributed config</a></li>
<li title="Message round-trip call flow"><a href="megaco_architecture.html#id61457">Message round-trip call flow</a></li>
</ul>
</li>
<li id="no" title="Running the stack" expanded="false">Running the stack<ul>
<li><a href="megaco_run.html">
              Top of chapter
            </a></li>
<li title="Starting"><a href="megaco_run.html#id61789">Starting</a></li>
<li title="MGC startup call flow"><a href="megaco_run.html#id61842">MGC startup call flow</a></li>
<li title="MG startup call flow"><a href="megaco_run.html#id64761">MG startup call flow</a></li>
<li title="Configuring the Megaco stack"><a href="megaco_run.html#id64845">Configuring the Megaco stack</a></li>
<li title="Initial configuration"><a href="megaco_run.html#id62793">Initial configuration</a></li>
<li title="Changing the configuration"><a href="megaco_run.html#id62889">Changing the configuration</a></li>
<li title="The transaction sender"><a href="megaco_run.html#id62915">The transaction sender</a></li>
<li title="Segmentation of transaction replies"><a href="megaco_run.html#id64243">Segmentation of transaction replies</a></li>
</ul>
</li>
<li id="no" title="Internal form and its encodings" expanded="false">Internal form and its encodings<ul>
<li><a href="megaco_encode.html">
              Top of chapter
            </a></li>
<li title="Internal form of messages"><a href="megaco_encode.html#id64446">Internal form of messages</a></li>
<li title="The different encodings"><a href="megaco_encode.html#id65717">The different encodings</a></li>
<li title="Configuration of Erlang distribution encoding module"><a href="megaco_encode.html#id65849">Configuration of Erlang distribution encoding module</a></li>
<li title="Configuration of text encoding module(s)"><a href="megaco_encode.html#id65929">Configuration of text encoding module(s)</a></li>
<li title="Configuration of binary encoding module(s)"><a href="megaco_encode.html#id66146">Configuration of binary encoding module(s)</a></li>
<li title="Handling megaco versions"><a href="megaco_encode.html#id66212">Handling megaco versions</a></li>
<li title="Encoder callback functions"><a href="megaco_encode.html#id66460">Encoder callback functions</a></li>
</ul>
</li>
<li id="no" title="Transport mechanisms" expanded="false">Transport mechanisms<ul>
<li><a href="megaco_transport_mechanisms.html">
              Top of chapter
            </a></li>
<li title="Callback interface"><a href="megaco_transport_mechanisms.html#id66546">Callback interface</a></li>
<li title="Examples"><a href="megaco_transport_mechanisms.html#id66616">Examples</a></li>
</ul>
</li>
<li id="no" title="Implementation examples" expanded="false">Implementation examples<ul>
<li><a href="megaco_examples.html">
              Top of chapter
            </a></li>
<li title="A simple Media Gateway Controller"><a href="megaco_examples.html#id66705">A simple Media Gateway Controller</a></li>
<li title="A simple Media Gateway"><a href="megaco_examples.html#id66753">A simple Media Gateway</a></li>
</ul>
</li>
<li id="no" title="Megaco mib" expanded="false">Megaco mib<ul>
<li><a href="megaco_mib.html">
              Top of chapter
            </a></li>
<li title="Intro"><a href="megaco_mib.html#id66871">Intro</a></li>
<li title="Statistics counters"><a href="megaco_mib.html#id66897">Statistics counters</a></li>
<li title="Distribution"><a href="megaco_mib.html#id66933">Distribution</a></li>
</ul>
</li>
<li id="no" title="Performance comparison" expanded="false">Performance comparison<ul>
<li><a href="megaco_performance.html">
              Top of chapter
            </a></li>
<li title="Comparison of encoder/decoders"><a href="megaco_performance.html#id67011">Comparison of encoder/decoders</a></li>
<li title="System performance characteristics"><a href="megaco_performance.html#id67842">System performance characteristics</a></li>
<li title="Description of encoders/decoders"><a href="megaco_performance.html#id67879">Description of encoders/decoders</a></li>
<li title="Setup"><a href="megaco_performance.html#id67989">Setup</a></li>
<li title="Summary"><a href="megaco_performance.html#id68002">Summary</a></li>
</ul>
</li>
<li id="no" title="Testing and tools" expanded="false">Testing and tools<ul>
<li><a href="megaco_debug.html">
              Top of chapter
            </a></li>
<li title="Tracing"><a href="megaco_debug.html#id68132">Tracing</a></li>
<li title="Measurement and transformation"><a href="megaco_debug.html#id68176">Measurement and transformation</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>2 Architecture</h1>
  

  <h3><a name="id60397">2.1 
        Network view</a></h3>
    
    <p>Megaco is a (master/slave) protocol for control of gateway functions at 
      the edge of the packet network. Examples of this is IP-PSTN trunking 
      gateways and analog line gateways. The main function of Megaco is to 
      allow gateway decomposition into a call agent (call control) part (known
      as Media Gateway Controller, MGC) - master, and an gateway interface 
      part (known as Media Gateway, MG) - slave. The MG has no call control 
      knowledge and only handle making the connections and simple 
      configurations.</p>
    <p>SIP and H.323 are peer-to-peer protocols for call control (valid only 
      for some of the protocols within H.323), or more generally multi-media 
      session protocols. They both operate at a different level (call control) 
      from Megaco in a decomposed network, and are therefor not aware of 
      whether or not Megaco is being used underneath.</p>
    <img alt="IMAGE MISSING" src="megaco_sys_arch.gif"><br>
      <em>Figure
        2.1:
         
        Network architecture</em>
    
    <p>Megaco and peer protocols are complementary in nature and entirely
      compatible within the same system. At a system level, Megaco allows 
      for</p>
    <ul>
      <li>
        <p>overall network cost and performance optimization</p>
      </li>
      <li>
        <p>protection of investment by isolation of changes at the call 
          control layer</p>
      </li>
      <li>
        <p>freedom to geographically distribute both call function and 
          gateway function</p>
      </li>
      <li>
        <p>adaption of legacy equipment</p>
      </li>
    </ul>
  

  <h3><a name="id61412">2.2 
        General</a></h3>
    
    <p>This Erlang/OTP application supplies a framework for building
      applications that needs to utilize the Megaco/H.248 protocol.</p>
    <p>We have introduced the term "user" as a generic term for either
      an MG or an MGC, since most of the functionality we support, is
      common for both MG's and MGC's. A (local) user may be configured
      in various ways and it may establish any number of connections
      to its counterpart, the remote user. Once a connection has been
      established, the connection is supervised and it may be used for
      the purpose of sending messages. N.B. according to the standard
      an MG is connected to at most one MGC, while an MGC may be
      connected to any number of MG's.</p>
    <p>For the purpose of managing "virtual MG's", one Erlang node may
      host any number of MG's. In fact it may host a mix of MG's and
      MGC's. You may say that an Erlang node may host any number of
      "users".</p>
    <p>The protocol engine uses callback modules to handle various
      things:</p>
    <ul>
      <li>
        <p>encoding callback modules - handles the encoding and
          decoding of messages. Several modules for handling different
          encodings are included, such as ASN.1 BER, pretty well
          indented text, compact text and some others. Others may be
          written by you.</p>
      </li>
      <li>
        <p>transport callback modules - handles sending and receiving
          of messages. Transport modules for TCP/IP and UDP/IP are
          included and others may be written by you.</p>
      </li>
      <li>
        <p>user callback modules - the actual implementation of an MG
          or MGC. Most of the functions are intended for handling of a
          decoded transaction (request, reply, acknowledgement), but
          there are others that handles connect, disconnect and
          errors cases.</p>
      </li>
    </ul>
    <p>Each connection may have its own configuration of callback
      modules, re-send timers, transaction id ranges etc. and they may
      be re-configured on-the-fly.</p>
    <p>In the API of Megaco, a user may explicitly send action
      requests, but generation of transaction identifiers, the
      encoding and actual transport of the message to the remote user
      is handled automatically by the protocol engine according to the
      actual connection configuration. Megaco messages are not exposed
      in the API.</p>
    <p>On the receiving side the transport module receives the message
      and forwards it to the protocol engine, which decodes it and
      invokes user callback functions for each transaction. When a
      user has handled its action requests, it simply returns a list
      of action replies (or a message error) and the protocol engine
      uses the encoding module and transport module to compose and
      forward the message to the originating user.</p>
    <p>The protocol stack does also handle things like automatic
      sending of acknowledgements, pending transactions, re-send of
      messages, supervision of connections etc.</p>
    <p>In order to provide a solution for scalable implementations of
      MG's and MGC's, a user may be distributed over several Erlang
      nodes. One of the Erlang nodes is connected to the physical
      network interface, but messages may be sent from other nodes and
      the replies are automatically forwarded back to the originating
      node.</p>
  

  <h3><a name="id56838">2.3 
        Single node config</a></h3>
    
    <p>Here a system configuration with an MG and MGC residing
      in one Erlang node each is outlined:</p>
    <img alt="IMAGE MISSING" src="single_node_config.gif"><br>
      <em>Figure
        2.2:
         
        Single node config</em>
    
  

  <h3><a name="id61926">2.4 
        Distributed config</a></h3>
    
    <p>In a larger system with a user (in this case an MGC)
      distributed over several Erlang nodes, it looks a little bit
      different. Here the encoding is performed on the originating
      Erlang node (1) and the binary is forwarded to the node (2) with
      the physical network interface. When the potential message reply
      is received on the interface on node (2), it is decoded there
      and then different actions will be taken for each transaction in
      the message. The transaction reply will be forwarded in its
      decoded form to the originating node (1) while the other types
      of transactions will be handled locally on node (2).</p>
    <p>Timers and re-send of messages will be handled on locally on
      one node, that is node(1), in order to avoid unnecessary
      transfer of data between the Erlang nodes.
      </p>
    <p></p>
    <img alt="IMAGE MISSING" src="distr_node_config.gif"><br>
      <em>Figure
        2.3:
         
        Distributes node config</em>
    
  

  <h3><a name="id61457">2.5 
        Message round-trip call flow</a></h3>
    
    <p>The typical round-trip of a message can be viewed as
      follows. Firstly we view the call flow on the originating
      side:</p>
    <img alt="IMAGE MISSING" src="call_flow.gif"><br>
      <em>Figure
        2.4:
         
        Message Call Flow (originating side)</em>
    
    <p>Then we continue with the call flow on the destination
      side:</p>
    <img alt="IMAGE MISSING" src="call_flow_cont.gif"><br>
      <em>Figure
        2.5:
         
        Message Call Flow (destination side)</em>
    
  
</div>
<div class="footer">
<hr>
<p>Copyright © 2000-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
