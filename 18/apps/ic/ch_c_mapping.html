<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- IDL to C mapping</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="index.html">Reference Manual</a><br><a href="release_notes.html">Release Notes</a><br><a href="ic.pdf">PDF</a><br><a href="../../index.html">Top</a></small><p><strong>ic</strong><br><strong>User's Guide</strong><br><small>Version 4.4</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Using the IC Compiler" expanded="false">Using the IC Compiler<ul>
<li><a href="ch_introduction.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="ch_introduction.html#id63854">Introduction</a></li>
<li title="Compilation of IDL Files"><a href="ch_introduction.html#id60878">Compilation of IDL Files</a></li>
</ul>
</li>
<li id="no" title="OMG IDL" expanded="false">OMG IDL<ul>
<li><a href="ch_basic_idl.html">
              Top of chapter
            </a></li>
<li title="OMG IDL - Overview"><a href="ch_basic_idl.html#id56840">OMG IDL - Overview</a></li>
</ul>
</li>
<li id="no" title="IC Protocol" expanded="false">IC Protocol<ul>
<li><a href="ch_ic_protocol.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="ch_ic_protocol.html#id65391">Introduction</a></li>
<li title="Language mappings and IDL operations"><a href="ch_ic_protocol.html#id64033">Language mappings and IDL operations</a></li>
<li title="IC Protocol"><a href="ch_ic_protocol.html#id65429">IC Protocol</a></li>
<li title="Gen_server Protocol"><a href="ch_ic_protocol.html#id65485">Gen_server Protocol</a></li>
<li title="Erlang Distribution Protocol"><a href="ch_ic_protocol.html#id65532">Erlang Distribution Protocol</a></li>
</ul>
</li>
<li id="no" title="Using the Plain Erlang Back-end" expanded="false">Using the Plain Erlang Back-end<ul>
<li><a href="ch_erl_plain.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="ch_erl_plain.html#id64565">Introduction</a></li>
<li title="Compiling the Code"><a href="ch_erl_plain.html#id64579">Compiling the Code</a></li>
<li title="Writing the Implementation File"><a href="ch_erl_plain.html#id64598">Writing the Implementation File</a></li>
<li title="An Example"><a href="ch_erl_plain.html#id64653">An Example</a></li>
</ul>
</li>
<li id="no" title="Using the Erlang Generic Server Back-end" expanded="false">Using the Erlang Generic Server Back-end<ul>
<li><a href="ch_erl_genserver.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="ch_erl_genserver.html#id63678">Introduction</a></li>
<li title="Compiling the Code"><a href="ch_erl_genserver.html#id63696">Compiling the Code</a></li>
<li title="Writing the Implementation File"><a href="ch_erl_genserver.html#id63719">Writing the Implementation File</a></li>
<li title="An Example"><a href="ch_erl_genserver.html#id63774">An Example</a></li>
</ul>
</li>
<li id="loadscrollpos" title="IDL to C mapping" expanded="true">IDL to C mapping<ul>
<li><a href="ch_c_mapping.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="ch_c_mapping.html#id66146">Introduction</a></li>
<li title="C Mapping Characteristics"><a href="ch_c_mapping.html#id65603">C Mapping Characteristics</a></li>
<li title="Basic OMG IDL Types"><a href="ch_c_mapping.html#id65764">Basic OMG IDL Types</a></li>
<li title="Constructed OMG IDL Types"><a href="ch_c_mapping.html#id69682">Constructed OMG IDL Types</a></li>
<li title="OMG IDL Constants"><a href="ch_c_mapping.html#id69905">OMG IDL Constants</a></li>
<li title="OMG IDL Operations"><a href="ch_c_mapping.html#id71885">OMG IDL Operations</a></li>
<li title="Exceptions"><a href="ch_c_mapping.html#id72142">Exceptions</a></li>
<li title="Access to Attributes"><a href="ch_c_mapping.html#id72155">Access to Attributes</a></li>
<li title="Summary of Argument/Result Passing for the C-client"><a href="ch_c_mapping.html#id72166">Summary of Argument/Result Passing for the C-client</a></li>
<li title="Supported Memory Allocation Functions"><a href="ch_c_mapping.html#id73772">Supported Memory Allocation Functions</a></li>
<li title="Special Memory Deallocation Functions"><a href="ch_c_mapping.html#id73900">Special Memory Deallocation Functions</a></li>
<li title="Exception Access Functions"><a href="ch_c_mapping.html#id73940">Exception Access Functions</a></li>
<li title="Special Types"><a href="ch_c_mapping.html#id73979">Special Types</a></li>
<li title="A Mapping Example"><a href="ch_c_mapping.html#id74102">A Mapping Example</a></li>
</ul>
</li>
<li id="no" title="The C Client Back-end" expanded="false">The C Client Back-end<ul>
<li><a href="ch_c_client.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="ch_c_client.html#id74240">Introduction</a></li>
<li title="Generated Stub Files"><a href="ch_c_client.html#id74265">Generated Stub Files</a></li>
<li title="C Interface Functions"><a href="ch_c_client.html#id74316">C Interface Functions</a></li>
<li title="Generating, Compiling and Linking"><a href="ch_c_client.html#id74392">Generating, Compiling and Linking</a></li>
<li title="An Example"><a href="ch_c_client.html#id74457">An Example</a></li>
</ul>
</li>
<li id="no" title="The C Server Back-end" expanded="false">The C Server Back-end<ul>
<li><a href="ch_c_server.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="ch_c_server.html#id74584">Introduction</a></li>
<li title="Generated Stub Files"><a href="ch_c_server.html#id74610">Generated Stub Files</a></li>
<li title="C Skeleton Functions"><a href="ch_c_server.html#id74661">C Skeleton Functions</a></li>
<li title="The Server Loop"><a href="ch_c_server.html#id74719">The Server Loop</a></li>
<li title="Generating, Compiling and Linking"><a href="ch_c_server.html#id74747">Generating, Compiling and Linking</a></li>
<li title="An Example"><a href="ch_c_server.html#id74811">An Example</a></li>
</ul>
</li>
<li id="no" title="CORBA_Environment C Structure" expanded="false">CORBA_Environment C Structure<ul>
<li><a href="ch_c_corba_env.html">
              Top of chapter
            </a></li>
<li title="C Structure"><a href="ch_c_corba_env.html#id74944">C Structure</a></li>
<li title="The CORBA Compatibility Part"><a href="ch_c_corba_env.html#id75016">The CORBA Compatibility Part</a></li>
<li title="The External Part"><a href="ch_c_corba_env.html#id75069">The External Part</a></li>
<li title="The Internal Part"><a href="ch_c_corba_env.html#id75202">The Internal Part</a></li>
<li title="Creating and Initiating the CORBA_Environment Structure"><a href="ch_c_corba_env.html#id75324">Creating and Initiating the CORBA_Environment Structure</a></li>
<li title="Setting System Exceptions"><a href="ch_c_corba_env.html#id75634">Setting System Exceptions</a></li>
</ul>
</li>
<li id="no" title="IDL to Java language Mapping" expanded="false">IDL to Java language Mapping<ul>
<li><a href="ch_java.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="ch_java.html#id75746">Introduction</a></li>
<li title="Specialties in the Mapping"><a href="ch_java.html#id75807">Specialties in the Mapping</a></li>
<li title="Basic OMG IDL Types"><a href="ch_java.html#id75834">Basic OMG IDL Types</a></li>
<li title="Constructed OMG IDL Types"><a href="ch_java.html#id76241">Constructed OMG IDL Types</a></li>
<li title="Mapping for Constants"><a href="ch_java.html#id76307">Mapping for Constants</a></li>
<li title="Invocations of Operations"><a href="ch_java.html#id76318">Invocations of Operations</a></li>
<li title="Exceptions"><a href="ch_java.html#id76368">Exceptions</a></li>
<li title="Access to Attributes"><a href="ch_java.html#id76381">Access to Attributes</a></li>
<li title="Summary of Argument/Result Passing for Java"><a href="ch_java.html#id76392">Summary of Argument/Result Passing for Java</a></li>
<li title="Communication Toolbox"><a href="ch_java.html#id76450">Communication Toolbox</a></li>
<li title="The Package com.ericsson.otp.ic"><a href="ch_java.html#id76750">The Package com.ericsson.otp.ic</a></li>
<li title="The Term Class"><a href="ch_java.html#id77150">The Term Class</a></li>
<li title="Stub File Types"><a href="ch_java.html#id77428">Stub File Types</a></li>
<li title="Client Stub Initialization, Methods Exported"><a href="ch_java.html#id77492">Client Stub Initialization, Methods Exported</a></li>
<li title="Server Skeleton Initialization, Server Stub Implementation, Methods Exported"><a href="ch_java.html#id77673">Server Skeleton Initialization, Server Stub Implementation, Methods Exported</a></li>
<li title="A Mapping Example"><a href="ch_java.html#id77804">A Mapping Example</a></li>
<li title="Running the Compiled Code"><a href="ch_java.html#id77888">Running the Compiled Code</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>6 IDL to C mapping</h1>
  

  <h3><a name="id66146">6.1 
        Introduction</a></h3>
    
    <p>The IC C mapping (used by the C client and C server back-ends) follows
      the <strong>OMG C Language Mapping Specification</strong>. </p>
    <p>The C mapping supports the following:</p>
    <ul>
      <li>
        <p>All OMG IDL basic types except <span class="code">long double</span> and <span class="code">any</span>.</p>
      </li>
      <li>
        <p>All OMG IDL constructed types.</p>
      </li>
      <li>
        <p>OMG IDL constants.</p>
      </li>
      <li>
        <p>Operations with passing of parameters and receiving of
          results. <span class="code">inout</span> parameters are not supported.</p>
      </li>
    </ul>
    <p>The following is not supported:
      </p>
    <ul>
      <li>
        <p>Access to attributes.</p>
      </li>
      <li>
        <p>User defined exceptions.</p>
        <p></p>
      </li>
      <li>
        <p>User defined objects.</p>
        <p></p>
      </li>
    </ul>
  

  <h3><a name="id65603">6.2 
        C Mapping Characteristics</a></h3>
    

    <h4>Reserved Names</h4>
      
      <p>The IDL compiler reserves all identifiers starting with
        <span class="code">OE_</span> and <span class="code">oe_</span> for internal use.</p>
    

    <h4>Scoped Names</h4>
      
      <p>The C programmer must always use the global name for a type,
        constant or operation. The C global name corresponding to an
        OMG IDL global name is derived by converting occurrences of
        "::" to underscore, and eliminating the leading "::". So, for
        example, an operation <span class="code">op1</span> defined in interface
        <span class="code">I1</span> which is defined in module <span class="code">M1</span> would be
        written as <span class="code">M1::I1::op1</span> in IDL and as <span class="code">M1_I1_op1</span>
        in C.</p>
      <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
        <p>If underscores are used in IDL names it can lead to
          ambiguities due to the name mapping described above,
          therefore it is advisable to avoid underscores in
          identifiers.</p>
      </p></div>
</div>
    

    <h4>Generated Files</h4>
      
      <p>Two files will be generated for each scope. One set of files
        will be generated for each module and each interface scope.
        An extra set is generated for those definitions at top
        level scope. One of the files is a header file(<span class="code">.h</span>), and the 
        other file is a C source code file (<span class="code">.c</span>). In addition to these 
        files a number of C source files will be generated for type encodings,
        they are named according to the following template:
        <span class="code">oe_code_&lt;type&gt;.c</span>.</p>
      <p>For example:</p>
      <div class="example"><pre>
// IDL, in the file "spec.idl"
module m1 {

    typedef sequence&lt;long&gt; lseq;
   
    interface i1 {
        ...
    };
    ...
};
      </pre></div>
      <p>XXX This is C client specific.
        Will produce the files <span class="code">oe_spec.h</span> and
        <span class="code">oe_spec.c</span> for the top scope level. Then the files
        <span class="code">m1.h</span> and <span class="code">m1.c</span> for the module <span class="code">m1</span> and
        files <span class="code">m1_i1.h</span> and <span class="code">m1_i1.c</span> for the interface
        <span class="code">i1</span>. The typedef will produce <span class="code">oe_code_m1_lseq.c</span>.</p>
      <p>The header file contains type definitions for all
        <span class="code">struct</span> types and sequences and constants in the IDL file. The
        c file contains all operation stubs if the the scope is an interface.</p>
      <p>In addition to the scope-related files a C source file will
        be generated for encoding operations of all <span class="code">struct</span> and
        sequence types.</p>
    
  

  <h3><a name="id65764">6.3 
        Basic OMG IDL Types</a></h3>
    
    <p>The mapping of basic types is as follows.</p>
    <table border="1" cellpadding="2" cellspacing="0">
<tr>
        <td align="left" valign="middle"><strong>OMG IDL type</strong></td>
        <td align="left" valign="middle"><strong>C type</strong></td>
        <td align="left" valign="middle"><strong>Mapped to C type</strong></td>
      </tr>
<tr>
        <td align="left" valign="middle">float</td>
        <td align="left" valign="middle">CORBA_float</td>
        <td align="left" valign="middle">float</td>
      </tr>
<tr>
        <td align="left" valign="middle">double</td>
        <td align="left" valign="middle">CORBA_double</td>
        <td align="left" valign="middle">double</td>
      </tr>
<tr>
        <td align="left" valign="middle">short</td>
        <td align="left" valign="middle">CORBA_short</td>
        <td align="left" valign="middle">short</td>
      </tr>
<tr>
        <td align="left" valign="middle">unsigned short</td>
        <td align="left" valign="middle">CORBA_unsigned_short</td>
        <td align="left" valign="middle">unsigned short</td>
      </tr>
<tr>
        <td align="left" valign="middle">long</td>
        <td align="left" valign="middle">CORBA_long</td>
        <td align="left" valign="middle">long</td>
      </tr>
<tr>
        <td align="left" valign="middle">long long</td>
        <td align="left" valign="middle">CORBA_long_long</td>
        <td align="left" valign="middle">long</td>
      </tr>
<tr>
        <td align="left" valign="middle">unsigned long</td>
        <td align="left" valign="middle">CORBA_unsigned_long</td>
        <td align="left" valign="middle">unsigned long</td>
      </tr>
<tr>
        <td align="left" valign="middle">unsigned long long</td>
        <td align="left" valign="middle">CORBA_unsigned_long_long</td>
        <td align="left" valign="middle">unsigned long</td>
      </tr>
<tr>
        <td align="left" valign="middle">char</td>
        <td align="left" valign="middle">CORBA_char</td>
        <td align="left" valign="middle">char</td>
      </tr>
<tr>
        <td align="left" valign="middle">wchar</td>
        <td align="left" valign="middle">CORBA_wchar</td>
        <td align="left" valign="middle">unsigned long</td>
      </tr>
<tr>
        <td align="left" valign="middle">boolean</td>
        <td align="left" valign="middle">CORBA_boolean</td>
        <td align="left" valign="middle">unsigned char</td>
      </tr>
<tr>
        <td align="left" valign="middle">octet</td>
        <td align="left" valign="middle">CORBA_octet</td>
        <td align="left" valign="middle">char</td>
      </tr>
<tr>
        <td align="left" valign="middle">any</td>
        <td align="left" valign="middle">Not supported</td>
        <td align="left" valign="middle"></td>
      </tr>
<tr>
        <td align="left" valign="middle">long double</td>
        <td align="left" valign="middle">Not supported</td>
        <td align="left" valign="middle"></td>
      </tr>
<tr>
        <td align="left" valign="middle">Object</td>
        <td align="left" valign="middle">Not supported</td>
        <td align="left" valign="middle"></td>
      </tr>
<tr>
        <td align="left" valign="middle">void</td>
        <td align="left" valign="middle">void</td>
        <td align="left" valign="middle">void</td>
      </tr>
</table>
<em>Table
        6.1:
         
        OMG IDL Basic Types</em>
    <p>XXX Note that several mappings are not according to OMG C Language
      mapping.</p>
  

  <h3><a name="id69682">6.4 
        Constructed OMG IDL Types</a></h3>
    
    <p>Constructed types have mappings as shown in the following table.</p>
    <table border="1" cellpadding="2" cellspacing="0">
<tr>
        <td align="left" valign="middle">OMG IDL type</td>
        <td align="left" valign="middle">Mapped to C type</td>
      </tr>
<tr>
        <td align="left" valign="middle">string</td>
        <td align="left" valign="middle">CORBA_char*</td>
      </tr>
<tr>
        <td align="left" valign="middle">wstring</td>
        <td align="left" valign="middle">CORBA_wchar*</td>
      </tr>
<tr>
        <td align="left" valign="middle">struct</td>
        <td align="left" valign="middle">struct</td>
      </tr>
<tr>
        <td align="left" valign="middle">union</td>
        <td align="left" valign="middle">union</td>
      </tr>
<tr>
        <td align="left" valign="middle">enum</td>
        <td align="left" valign="middle">enum</td>
      </tr>
<tr>
        <td align="left" valign="middle">sequence</td>
        <td align="left" valign="middle">struct (see below)</td>
      </tr>
<tr>
        <td align="left" valign="middle">array</td>
        <td align="left" valign="middle">array</td>
      </tr>
</table>
<em>Table
        6.2:
         
        OMG IDL Constructed Types</em>
    <p>An OMG IDL sequence (an array of variable length), </p>
    <div class="example"><pre>
// IDL
typedef sequence &lt;IDL_TYPE&gt; NAME;
    </pre></div>
    <p>is mapped to a C struct as follows:</p>
    <div class="example"><pre>
/* C */
typedef struct {
  CORBA_unsigned_long _maximum;
  CORBA_unsigned_long _length;
  C_TYPE* _buffer;
} C_NAME;
    </pre></div>
    <p>where <span class="code">C_TYPE</span> is the mapping of <span class="code">IDL_TYPE</span>, and where
      <span class="code">C_NAME</span> is the scoped name of <span class="code">NAME</span>.</p>
  

  <h3><a name="id69905">6.5 
        OMG IDL Constants</a></h3>
    
    <p>An IDL constant is mapped to a C constant through a C
      <span class="code">#define</span> macro, where the name of the macro is scoped.
      Example:</p>
    <div class="example"><pre>
// IDL
module M1 {
    const long c1 = 99;
};
    </pre></div>
    <p>results in the following:</p>
    <div class="example"><pre>
/* C */
#define M1_c1 99
    </pre></div>
  

  <h3><a name="id71885">6.6 
        OMG IDL Operations</a></h3>
    
    <p>An OMG IDL operation is mapped to C function. Each C operation
      function has two mandatory parameters: a first parameter of
      <strong>interface object</strong> type, and a last parameter of
      <strong>environment</strong> type.</p>
    <p></p>
    <p>In a C operation function the the <span class="code">in</span> and <span class="code">out</span>
      parameters are located between the first and last parameters
      described above, and they appear in the same order as in the IDL
      operation declaration.</p>
    <p>Notice that <span class="code">inout</span> parameters are not supported. </p>
    <p></p>
    <p>The return value of an OMG IDL operation is mapped to a
      corresponding return value of the C operation function.</p>
    <p>Mandatory C operation function parameters:</p>
    <ul>
      <li>
<span class="code">CORBA_Object oe_obj</span> - the first parameter of a C
       operation function. This parameter is required by the <strong>OMG C Language Mapping Specification</strong>, but in the current
       implementation there is no particular use for it.</li>
      <li>
        <p><span class="code">CORBA_Environment* oe_env</span> - the last parameter of a C
          operation function. The parameter is defined in the C header
          file <span class="code">ic.h</span> and has the following public fields:</p>
        <ul>
          <li>
            <p><span class="code">CORBA_Exception_type _major</span> - indicates if an
              operation invocation was successful which will be one of
              the following:</p>
            <ul>
              <li>CORBA_NO_EXCEPTION</li>
              <li>CORBA_SYSTEM_EXCEPTION</li>
            </ul>
          </li>
          <li>int <strong>_fd</strong> - a file descriptor returned from
          <strong>erl_connect</strong> function.</li>
          <li>int <strong>_inbufsz</strong> - size of input buffer.</li>
          <li>char* <strong>_inbuf</strong> - pointer to a buffer used for
           input.</li>
          <li>int <strong>_outbufsz</strong> - size of output buffer.</li>
          <li>char* <strong>_outbuf</strong> - pointer to a buffer used for
           output.</li>
          <li>
            <p>int <strong>_memchunk</strong> - expansion unit size for the
              output buffer.  This is the size of memory chunks in
              bytes used for increasing the output in case of buffer
              expansion. The value of this field must be always set
              to &gt;= 32, should be at least 1024 for performance
              reasons.</p>
          </li>
          <li>char <strong>regname[256]</strong> - a registered name for a
           process.</li>
          <li>erlang_pid* <strong>_to_pid</strong> - an Erlang process
           identifier, is only used if  the registered_name parameter
           is the empty string.</li>
          <li>erlang_pid* <strong>_from_pid</strong> - your own process id so
           the answer can be  returned</li>
        </ul>
        <p>Beside the public fields, other private fields
          are internally used but are not mentioned here. </p>
      </li>
    </ul>
    <p>Example:</p>
    <div class="example"><pre>
// IDL
interface i1 {
    long op1(in long a); 
    long op2(in string s, out long count);
};
    </pre></div>
    <p>Is mapped to the following C functions</p>
    <div class="example"><pre>
/* C */ 
CORBA_long i1_op1(i1 oe_obj, CORBA_long a, CORBA_Environment* oe_env)
{
    ...
}
CORBA_long i1_op2(i1 oe_obj, CORBA_char* s, CORBA_long *count,
CORBA_Environment* oe_env)
{
    ...
}
    </pre></div>
    <a name="op_impl"></a>

    <h4>Operation Implementation</h4>
      
      <p>There is no  standard CORBA  mapping  for the C-server side,
        as it is  implementation-dependent but built in a similar way.
        The current server side mapping is different from the client
        side mapping in several ways:</p>
      <ul>
        <li>Argument mappings</li>
        <li>Result values</li>
        <li>Structure</li>
        <li>Usage</li>
        <li>Exception handling</li>
      </ul>
    
  

  <h3><a name="id72142">6.7 
        Exceptions</a></h3>
    
    <p>Although exception mapping is not implemented, the stubs will
      generate CORBA system exceptions in case of operation failure.
      Thus, the only exceptions propagated by the system are built in
      system exceptions.</p>
  

  <h3><a name="id72155">6.8 
        Access to Attributes</a></h3>
    
    <p>Not Supported</p>
  

  <h3><a name="id72166">6.9 
        Summary of Argument/Result Passing for the C-client</a></h3>
    
    <p>The user-defined parameters can only be <span class="code">in</span> or <span class="code">out</span>
      parameters, as 
      <span class="code">inout</span> parameters are not supported.</p>
    <p>This table summarize the types a client passes as arguments to
      a stub, and receives as a result.</p>
    <table border="1" cellpadding="2" cellspacing="0">
<tr>
        <td align="left" valign="middle">OMG IDL type</td>
        <td align="left" valign="middle">In</td>
        <td align="left" valign="middle">Out</td>
        <td align="left" valign="middle">Return</td>
      </tr>
<tr>
        <td align="left" valign="middle">short</td>
        <td align="left" valign="middle">CORBA_short</td>
        <td align="left" valign="middle">CORBA_short*</td>
        <td align="left" valign="middle">CORBA_short</td>
      </tr>
<tr>
        <td align="left" valign="middle">long</td>
        <td align="left" valign="middle">CORBA_long</td>
        <td align="left" valign="middle">CORBA_long*</td>
        <td align="left" valign="middle">CORBA_long</td>
      </tr>
<tr>
        <td align="left" valign="middle">long long</td>
        <td align="left" valign="middle">CORBA_long_long</td>
        <td align="left" valign="middle">CORBA_long_long*</td>
        <td align="left" valign="middle">CORBA_long_long</td>
      </tr>
<tr>
        <td align="left" valign="middle">unsigned short</td>
        <td align="left" valign="middle">CORBA_unsigned_short</td>
        <td align="left" valign="middle">CORBA_unsigned_short*</td>
        <td align="left" valign="middle">CORBA_unsigned_short</td>
      </tr>
<tr>
        <td align="left" valign="middle">unsigned long</td>
        <td align="left" valign="middle">CORBA_unsigned_long</td>
        <td align="left" valign="middle">CORBA_unsigned_long*</td>
        <td align="left" valign="middle">CORBA_unsigned_long</td>
      </tr>
<tr>
        <td align="left" valign="middle">unsigned long long</td>
        <td align="left" valign="middle">CORBA_unsigned_long_long</td>
        <td align="left" valign="middle">CORBA_unsigned_long_long*</td>
        <td align="left" valign="middle">CORBA_unsigned_long_long</td>
      </tr>
<tr>
        <td align="left" valign="middle">float</td>
        <td align="left" valign="middle">CORBA_float</td>
        <td align="left" valign="middle">CORBA_float*</td>
        <td align="left" valign="middle">CORBA_float</td>
      </tr>
<tr>
        <td align="left" valign="middle">double</td>
        <td align="left" valign="middle">CORBA_double</td>
        <td align="left" valign="middle">CORBA_double*</td>
        <td align="left" valign="middle">CORBA_double</td>
      </tr>
<tr>
        <td align="left" valign="middle">boolean</td>
        <td align="left" valign="middle">CORBA_boolean</td>
        <td align="left" valign="middle">CORBA_boolean*</td>
        <td align="left" valign="middle">CORBA_boolean</td>
      </tr>
<tr>
        <td align="left" valign="middle">char</td>
        <td align="left" valign="middle">CORBA_char</td>
        <td align="left" valign="middle">CORBA_char*</td>
        <td align="left" valign="middle">CORBA_char</td>
      </tr>
<tr>
        <td align="left" valign="middle">wchar</td>
        <td align="left" valign="middle">CORBA_wchar</td>
        <td align="left" valign="middle">CORBA_wchar*</td>
        <td align="left" valign="middle">CORBA_wchar</td>
      </tr>
<tr>
        <td align="left" valign="middle">octet</td>
        <td align="left" valign="middle">CORBA_octet</td>
        <td align="left" valign="middle">CORBA_octet*</td>
        <td align="left" valign="middle">CORBA_octet</td>
      </tr>
<tr>
        <td align="left" valign="middle">enum</td>
        <td align="left" valign="middle">CORBA_enum</td>
        <td align="left" valign="middle">CORBA_enum*</td>
        <td align="left" valign="middle">CORBA_enum</td>
      </tr>
<tr>
        <td align="left" valign="middle">struct, fixed</td>
        <td align="left" valign="middle">struct*</td>
        <td align="left" valign="middle">struct*</td>
        <td align="left" valign="middle">struct</td>
      </tr>
<tr>
        <td align="left" valign="middle">struct, variable</td>
        <td align="left" valign="middle">struct*</td>
        <td align="left" valign="middle">struct**</td>
        <td align="left" valign="middle">struct*</td>
      </tr>
<tr>
        <td align="left" valign="middle">union, fixed</td>
        <td align="left" valign="middle">union*</td>
        <td align="left" valign="middle">union*</td>
        <td align="left" valign="middle">union</td>
      </tr>
<tr>
        <td align="left" valign="middle">union, variable</td>
        <td align="left" valign="middle">union*</td>
        <td align="left" valign="middle">union**</td>
        <td align="left" valign="middle">union*</td>
      </tr>
<tr>
        <td align="left" valign="middle">string</td>
        <td align="left" valign="middle">CORBA_char*</td>
        <td align="left" valign="middle">CORBA_char**</td>
        <td align="left" valign="middle">CORBA_char*</td>
      </tr>
<tr>
        <td align="left" valign="middle">wstring</td>
        <td align="left" valign="middle">CORBA_wchar*</td>
        <td align="left" valign="middle">CORBA_wchar**</td>
        <td align="left" valign="middle">CORBA_wchar*</td>
      </tr>
<tr>
        <td align="left" valign="middle">sequence</td>
        <td align="left" valign="middle">sequence*</td>
        <td align="left" valign="middle">sequence**</td>
        <td align="left" valign="middle">sequence*</td>
      </tr>
<tr>
        <td align="left" valign="middle">array, fixed</td>
        <td align="left" valign="middle">array</td>
        <td align="left" valign="middle">array</td>
        <td align="left" valign="middle">array_slice*</td>
      </tr>
<tr>
        <td align="left" valign="middle">array, variable</td>
        <td align="left" valign="middle">array</td>
        <td align="left" valign="middle">array_slice**</td>
        <td align="left" valign="middle">array_slice*</td>
      </tr>
</table>
<em>Table
        6.3:
         
        Basic Argument and Result passing</em>
    <p>A client is responsible for providing storage of all arguments passed 
      as <strong>in</strong> arguments.</p>
    <table border="1" cellpadding="2" cellspacing="0">
<tr>
        <td align="left" valign="middle">OMG IDL type</td>
        <td align="left" valign="middle">Out</td>
        <td align="left" valign="middle">Return</td>
      </tr>
<tr>
        <td align="left" valign="middle">short</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">long</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">long long</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">unsigned short</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">unsigned long</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">unsigned long long</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">float</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">double</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">boolean</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">char</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">wchar</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">octet</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">enum</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">struct, fixed</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">1</td>
      </tr>
<tr>
        <td align="left" valign="middle">struct, variable</td>
        <td align="left" valign="middle">2</td>
        <td align="left" valign="middle">2</td>
      </tr>
<tr>
        <td align="left" valign="middle">string</td>
        <td align="left" valign="middle">2</td>
        <td align="left" valign="middle">2</td>
      </tr>
<tr>
        <td align="left" valign="middle">wstring</td>
        <td align="left" valign="middle">2</td>
        <td align="left" valign="middle">2</td>
      </tr>
<tr>
        <td align="left" valign="middle">sequence</td>
        <td align="left" valign="middle">2</td>
        <td align="left" valign="middle">2</td>
      </tr>
<tr>
        <td align="left" valign="middle">array, fixed</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">3</td>
      </tr>
<tr>
        <td align="left" valign="middle">array, variable</td>
        <td align="left" valign="middle">3</td>
        <td align="left" valign="middle">3</td>
      </tr>
</table>
<em>Table
        6.4:
         
        Client argument storage responsibility</em>
    <table border="1" cellpadding="2" cellspacing="0">
<tr>
        <td align="left" valign="middle">Case</td>
        <td align="left" valign="middle">Description</td>
      </tr>
<tr>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">Caller allocates all necessary storage, except that which may be encapsulated and managed within the parameter itself.</td>
      </tr>
<tr>
        <td align="left" valign="middle">2</td>
        <td align="left" valign="middle">The caller allocates a pointer and passes it by reference to the callee. The callee sets the pointer to point to a valid instance of the parameter's type. The caller is responsible for releasing the returned storage. Following completion of a request, the caller is  not allowed to modify any values in the returned storage. To do  so the caller must first copy the returned instance into a new  instance, then modify the new instance. </td>
      </tr>
<tr>
        <td align="left" valign="middle">3</td>
        <td align="left" valign="middle">The caller allocates a pointer to an array slice which has all the  same dimensions of the original array except the first, and passes  it by reference to the callee. The callee sets the pointer to point  to a valid instance of the array. The caller is responsible for  releasing the returned storage. Following completion of a request,  the caller is not allowed to modify any values in the returned  storage. To do so the caller must first copy the returned instance  into a new instance, then modify the new instance. </td>
      </tr>
</table>
<em>Table
        6.5:
         
        Argument passing cases</em>
    <p>The returned storage in case 2 and 3 is allocated as one block of memory
      so it is possible to deallocate it with one call of CORBA_free.</p>
  

  <h3><a name="id73772">6.10 
        Supported Memory Allocation Functions</a></h3>
    
    <ul>
      <li>
        <p><strong>CORBA_Environment</strong> can be allocated from the user by calling 
          <strong>CORBA_Environment_alloc()</strong>.</p>
        <p>The interface for this function is </p>
        <p><span class="code">CORBA_Environment *CORBA_Environment_alloc(int inbufsz, int outbufsz);</span></p>
        <p>where :</p>
        <ul>
          <li>
            <p><strong>inbufsz</strong> is the desired size of input buffer</p>
          </li>
          <li>
            <p><strong>outbufsz</strong> is the desired size of output buffer</p>
          </li>
          <li>
            <p>return value is a <strong>pointer</strong> to an allocated and initialized 
              <strong>CORBA_Environment</strong> structure</p>
            <p></p>
          </li>
        </ul>
      </li>
      <li>
        <p>Strings can be allocated from the user by calling <strong>CORBA_string_alloc()</strong>.</p>
        <p>The interface for this function is </p>
        <p><span class="code">CORBA_char *CORBA_string_alloc(CORBA_unsigned_long len);</span></p>
        <p>where :</p>
        <ul>
          <li>
            <p><strong>len</strong> is the length of the string to be allocated.</p>
          </li>
        </ul>
      </li>
    </ul>
    <p>Thus far, no other type allocation function is supported.</p>
  

  <h3><a name="id73900">6.11 
        Special Memory Deallocation Functions</a></h3>
    
    <ul>
      <li>
        <p><span class="code">void CORBA_free(void *storage)</span></p>
        <p>This function will free storage allocated by the stub.</p>
      </li>
      <li>
        <p><span class="code">void CORBA_exception_free(CORBA_environment *ev)</span></p>
        <p>This function will free storage allocated under exception propagation. </p>
      </li>
    </ul>
  

  <h3><a name="id73940">6.12 
        Exception Access Functions</a></h3>
    
    <ul>
      <li>
        <p><span class="code">CORBA_char *CORBA_exception_id(CORBA_Environment *ev)</span></p>
        <p>This function will return raised exception identity.</p>
      </li>
      <li>
        <p><span class="code">void *CORBA_exception_value(CORBA_Environment *ev)</span></p>
        <p>This function will return the value of a raised exception. </p>
      </li>
    </ul>
  

  <h3><a name="id73979">6.13 
        Special Types</a></h3>
    
    <ul>
      <li>
        <p>The erlang binary type has some special features.</p>
        <p></p>
        <p>While the <span class="code">erlang::binary</span> idl type has the same C-definition as 
          a generated sequence of octets :</p>
        <div class="example"><pre>
      module erlang
      {

      ....

      // an erlang binary
      typedef sequence&lt;octet&gt; binary;
      
      };
        </pre></div>
        <p>it provides a way on sending trasparent  data between C and Erlang.</p>
        <p>The C-definition (ic.h) for an erlang binary is :</p>
        <div class="example"><pre>
      typedef struct {
      CORBA_unsigned_long _maximum;
      CORBA_unsigned_long _length;
      CORBA_octet* _buffer;
      } erlang_binary;                        /* ERLANG BINARY */
        </pre></div>
        <p>The differences (between <span class="code">erlang::binary</span> and <span class="code">sequence&lt; octet &gt;</span>) are :</p>
        <ul>
          <li>
            <p>on the erlang side the user is sending/receiving typical 
              built in erlang binaries, using <span class="code">term_to_binary() / binary_to_term()</span> 
              to create / extract binary structures.</p>
          </li>
          <li>
            <p>no encoding/decoding functions are generated</p>
          </li>
          <li>
            <p>the underlying protocol is more efficient than usual sequences of
              octets</p>
          </li>
        </ul>
        <p>The erlang binary IDL type is defined in <span class="code">erlang.idl</span>, while its 
          C definition is located in the <span class="code">ic.h</span> header file, both in the 
          <span class="code">IC-&lt; vsn &gt;/include</span> directory.
          The user will have to include the file <span class="code">erlang.idl</span> in order to use the
          <span class="code">erlang::binary</span> type.</p>
      </li>
    </ul>
  

  <h3><a name="id74102">6.14 
        A Mapping Example</a></h3>
    
    <p>      <a name="stack_idl"></a>

      This is a small example of a simple stack. There are two
      operations on the stack, push and pop. The example shows all
      generated files as well as conceptual usage of the stack.</p>
    <div class="example"><pre>
// The source IDL file: stack.idl

struct s {
      long l;
      string s;
};

interface stack {
    void push(in s val);
    s pop();
};
    </pre></div>
    <p>When this file is compiled it produces four files, two for the
      top scope and two for the stack interface scope. The important parts 
      of the generated C code for the stack API is shown below.      <a name="stack_serv"></a>
</p>
    <p>stack.c</p>
    <div class="example"><pre>

void push(stack oe_obj, s val, CORBA_Environment* oe_env) {
  ...
}


s* pop(stack oe_obj, CORBA_Environment* oe_env) {
  ...
}
    </pre></div>
    <p>oe_stack.h</p>
    <div class="example"><pre>
#ifndef OE_STACK_H
#define OE_STACK_H 


/*------------------------------------------------------------
 * Struct definition: s
 */
typedef struct {
   long l;
   char *s;
} s;



#endif
    </pre></div>
    <p>stack.h just contains an include statement of <span class="code">oe_stack.h</span>.</p>
    <p>oe_code_s.c</p>
    <div class="example"><pre>

int oe_sizecalc_s(CORBA_Environment
      *oe_env, int* oe_size_count_index, int* oe_size) {
  ...
}

int oe_encode_s(CORBA_Environment *oe_env, s* oe_rec) {
  ...
}

int oe_decode_s(CORBA_Environment *oe_env, char *oe_first, 
                int* oe_outindex, s *oe_out) {
  ...
}
    </pre></div>
    <p>The only files that are really important are the <span class="code">.h</span>
      files and  the stack.c file.</p>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1998-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
