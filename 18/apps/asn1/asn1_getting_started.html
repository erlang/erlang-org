<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Getting Started</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="index.html">Reference Manual</a><br><a href="release_notes.html">Release Notes</a><br><a href="asn1.pdf">PDF</a><br><a href="../../index.html">Top</a></small><p><strong>ASN.1</strong><br><strong>User's Guide</strong><br><small>Version 4.0.2</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="asn1_introduction.html">
              Top of chapter
            </a></li>
<li title="Scope"><a href="asn1_introduction.html#id60767">Scope</a></li>
<li title="Prerequisites"><a href="asn1_introduction.html#id60441">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="ASN.1" expanded="false">ASN.1<ul>
<li><a href="asn1_overview.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="asn1_overview.html#id60864">Introduction</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Getting Started" expanded="true">Getting Started<ul>
<li><a href="asn1_getting_started.html">
              Top of chapter
            </a></li>
<li title="Example"><a href="asn1_getting_started.html#id60424">Example</a></li>
<li title="ASN.1 Application User Interface"><a href="asn1_getting_started.html#id59704">ASN.1 Application User Interface</a></li>
<li title="Multi-File Compilation"><a href="asn1_getting_started.html#id61978">Multi-File Compilation</a></li>
<li title="Remark about Tags"><a href="asn1_getting_started.html#id61202">Remark about Tags</a></li>
<li title="ASN.1 Types"><a href="asn1_getting_started.html#id61253">ASN.1 Types</a></li>
<li title="Naming of Records in .hrl Files"><a href="asn1_getting_started.html#id64025">Naming of Records in .hrl Files</a></li>
<li title="ASN.1 Values"><a href="asn1_getting_started.html#id62786">ASN.1 Values</a></li>
<li title="Macros"><a href="asn1_getting_started.html#id62869">Macros</a></li>
<li title="ASN.1 Information Objects (X.681)"><a href="asn1_getting_started.html#id62889">ASN.1 Information Objects (X.681)</a></li>
<li title="Parameterization (X.683)"><a href="asn1_getting_started.html#id68218">Parameterization (X.683)</a></li>
</ul>
</li>
<li id="no" title="Specialized Decodes" expanded="false">Specialized Decodes<ul>
<li><a href="asn1_spec.html">
              Top of chapter
            </a></li>
<li title="Exclusive Decode"><a href="asn1_spec.html#id68394">Exclusive Decode</a></li>
<li title="Selective Decode"><a href="asn1_spec.html#id68875">Selective Decode</a></li>
<li title="Performance"><a href="asn1_spec.html#id69358">Performance</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>3 Getting Started</h1>
  

  <h3><a name="id60424">3.1 
        Example</a></h3>
    
      <p>The following example demonstrates the basic functionality used to
      run the Erlang ASN.1 compiler.</p>
      <p>Create a file named <span class="code">People.asn</span> containing the following:</p>
      <div class="example"><pre>
People DEFINITIONS AUTOMATIC TAGS ::=
BEGIN
  Person ::= SEQUENCE {
    name PrintableString,
    location INTEGER {home(0),field(1),roving(2)},
    age INTEGER OPTIONAL
  }
END      </pre></div>
      <p>This file must be compiled before it can be used.
        The ASN.1 compiler checks that the syntax is correct and that the
        text represents proper ASN.1 code before generating an abstract
        syntax tree. The code-generator then uses the abstract syntax
        tree to generate code.</p>
      <p>The generated Erlang files are placed in the current directory or
        in the directory specified with option <span class="code">{outdir,Dir}</span>.</p>
      <p>The following shows how the compiler
        can be called from the  Erlang shell:</p>

      <div class="example"><pre>
1&gt;<span class="bold_code"> asn1ct:compile("People", [ber]).</span>
ok
2&gt;      </pre></div>

      <p>Option <span class="code">verbose</span> can be added to get information
      about the generated files:</p>
      <div class="example"><pre>
2&gt;<span class="bold_code"> asn1ct:compile("People", [ber,verbose]).</span>
Erlang ASN.1 compiling "People.asn" 
--{generated,"People.asn1db"}--
--{generated,"People.hrl"}--
--{generated,"People.erl"}--
ok
3&gt;      </pre></div>

      <p>ASN.1 module <span class="code">People</span> is now accepted and the
      abstract syntax tree is saved in file <span class="code">People.asn1db</span>.
      The generated Erlang code is compiled using the Erlang compiler
      and loaded into the Erlang runtime system. There is now an API
      for <span class="code">encode/2</span> and <span class="code">decode/2</span> in module
      <span class="code">People</span>, which is called like:<br>
      <span class="code">'People':encode(&lt;Type name&gt;, &lt;Value&gt;)</span>
      <br>
        or<br>
<span class="code">'People':decode(&lt;Type name&gt;, &lt;Value&gt;)</span></p>

      <p>Assume that there is a network
        application that receives instances of the ASN.1 defined
        type <span class="code">Person</span>, modifies, and sends them back again:</p>

      <div class="example"><pre>
receive
   {Port,{data,Bytes}} -&gt;
       case 'People':decode('Person',Bytes) of
           {ok,P} -&gt;
               {ok,Answer} = 'People':encode('Person',mk_answer(P)),
               Port ! {self(),{command,Answer}};
           {error,Reason} -&gt;
               exit({error,Reason})
       end
    end,      </pre></div>
      <p>In this example, a series of bytes is received from an
        external source and the bytes are then decoded into a valid
        Erlang term. This was achieved with the call
        <span class="code">'People':decode('Person',Bytes)</span>, which returned
        an Erlang value of the ASN.1 type <span class="code">Person</span>. Then an answer was
        constructed  and encoded using
        <span class="code">'People':encode('Person',Answer)</span>, which takes an
        instance of a defined ASN.1 type and transforms it to a
        binary according to the BER or PER encoding rules.</p>
        <p>The encoder and decoder can also be run from the shell:</p>
      <div class="example"><pre>
2&gt; <span class="bold_code">Rockstar = {'Person',"Some Name",roving,50}.</span>
{'Person',"Some Name",roving,50}
3&gt; <span class="bold_code">{ok,Bin} = 'People':encode('Person',Rockstar).</span>
{ok,&lt;&lt;243,17,19,9,83,111,109,101,32,78,97,109,101,2,1,2,
      2,1,50&gt;&gt;}
4&gt; <span class="bold_code">{ok,Person} = 'People':decode('Person',Bin).</span>
{ok,{'Person',"Some Name",roving,50}}
5&gt;      </pre></div>

    <h4>Module Dependencies</h4>
      
      <p>It is common that ASN.1 modules import defined types, values, and
        other entities from another ASN.1 module.</p>
      <p>Earlier versions of the ASN.1 compiler required that modules
        that were imported from had to be compiled before the module
        that imported. This caused problems when ASN.1 modules had circular
        dependencies.</p>
      <p>Referenced modules are now parsed when the compiler finds an
        entity that is imported. No code is generated for
        the referenced module. However, the compiled modules rely on
        that the referenced modules are also compiled.</p>
    
  

  <h3><a name="id59704">3.2 
        ASN.1 Application User Interface</a></h3>
    
    <p>The <span class="code">ASN.1</span> application provides the following two
    separate user interfaces:</p>
    <ul>
      <li>
        <p>The module <span class="code">asn1ct</span>, which provides the compile-time functions
          (including the compiler)</p>
      </li>
      <li>
        <p>The module <span class="code">asn1rt_nif</span>, which provides the runtime functions
         for the ASN.1 decoder for the BER back end</p>
      </li>
    </ul>
    <p>The reason for this division of the interfaces into compile-time
      and runtime
      is that only runtime modules (<span class="code">asn1rt*</span>) need to be loaded in
      an embedded system. 
      </p>

    <h4>Compile-Time Functions</h4>
      
      <p>The ASN.1 compiler can be started directly from the command line
        by the <span class="code">erlc</span> program. This is convenient when compiling
        many ASN.1 files from the command line or when using Makefiles.
        Some examples of how the <span class="code">erlc</span> command can be used to start
        the ASN.1 compiler:</p>
      <div class="example"><pre>
erlc Person.asn
erlc -bper Person.asn
erlc -bber ../Example.asn
erlc -o ../asnfiles -I ../asnfiles -I /usr/local/standards/asn1 Person.asn</pre></div>
      <p>Useful options for the ASN.1 compiler:</p>
      <dl>
        <dt><strong><span class="code">-b[ber | per | uper]</span></strong></dt>
        <dd>
          <p>Choice of encoding rules. If omitted, <span class="code">ber</span> is the
          default.</p>
        </dd>
        <dt><strong><span class="code">-o OutDirectory</span></strong></dt>
        <dd>
          <p>Where to put the generated files. Default is the current
            directory.</p>
        </dd>
        <dt><strong><span class="code">-I IncludeDir</span></strong></dt>
        <dd>
          <p>Where to search for <span class="code">.asn1db</span> files and ASN.1
            source specs to resolve references to other
            modules. This option can be repeated many times if there
            are several places to search in. The compiler
            searches the current directory first.</p>
        </dd>
        <dt><strong><span class="code">+der</span></strong></dt>
        <dd>
          <p>DER encoding rule. Only when using option <span class="code">-ber</span>.</p>
        </dd>
        <dt><strong><span class="code">+asn1config</span></strong></dt>
        <dd>
          <p>This functionality works together with option
            <span class="code">ber</span>. It enables the specialized decodes, see Section
            <span class="bold_code"><a href="asn1_spec.html">Specialized Decode</a></span>.</p>
        </dd>
        <dt><strong><span class="code">+undec_rest</span></strong></dt>
        <dd>
          <p>A buffer that holds a message being decoded can also have
          trailing bytes. If those trailing bytes are important, they
          can be returned along with the decoded value by compiling
          the ASN.1 specification with option <span class="code">+undec_rest</span>.
          The return value from the decoder is
          <span class="code">{ok,Value,Rest}</span> where <span class="code">Rest</span> is a binary
          containing the trailing bytes.</p>
        </dd>
        <dt><strong><span class="code">+'Any Erlc Option'</span></strong></dt>
        <dd>
          <p>Any option can be added to the Erlang compiler when
            compiling the generated Erlang files. Any option
            unrecognized by the ASN.1 compiler is passed to the
            Erlang compiler.</p>
        </dd>
      </dl>
      <p>For a complete description of <span class="code">erlc</span>, see
        ERTS Reference Manual.</p>
      <p>The compiler and other compile-time functions can also be started
        from the Erlang shell. Here follows a brief
        description of the primary functions. For a
        complete description of each function, see module <span class="code">asn1ct</span> in
        the <span class="bold_code"><a href="../../man/asn1ct.html">ASN.1 Reference Manual</a></span>.</p>
      <p>The compiler is started by <span class="code">asn1ct:compile/1</span> with
        default options, or <span class="code">asn1ct:compile/2</span> if explicit options
        are given.</p>
      <p>Example:</p>
      <div class="example"><pre>
asn1ct:compile("H323-MESSAGES.asn1").      </pre></div>
      <p>This equals:</p>
      <div class="example"><pre>
asn1ct:compile("H323-MESSAGES.asn1",[ber]).      </pre></div>
      <p>If PER encoding is wanted:</p>
      <div class="example"><pre>
asn1ct:compile("H323-MESSAGES.asn1",[per]).      </pre></div>
      <p>The generic encode and decode functions can be called
      as follows:</p>
      <div class="example"><pre>
'H323-MESSAGES':encode('SomeChoiceType',{call,&lt;&lt;"octetstring"&gt;&gt;}).
'H323-MESSAGES':decode('SomeChoiceType',Bytes).      </pre></div>
    

    <h4>Runtime Functions</h4>
      
      <p>When an ASN.1 specification is compiled with option <span class="code">ber</span>,
      the <span class="code">asn1rt_nif</span> module and the NIF library in
      <span class="code">asn1/priv_dir</span> are needed at runtime.</p>
      <p>By calling function <span class="code">info/0</span> in a generated module, you
      get information about which compiler options were used.</p>
    

    <h4>Errors</h4>
      
      <p>Errors detected at
        compile-time are displayed on the screen together with line
        numbers indicating where in the source file the respective error
        was detected. If no errors are found, an Erlang ASN.1 module is
        created.</p>
      <p>The runtime encoders and decoders execute within a catch and
      return <span class="code">{ok, Data}</span> or
        <span class="code">{error, {asn1, Description}}</span> where
        <span class="code">Description</span> is
        an Erlang term describing the error.</p>
    
  

  <h3><a name="id61978">3.3 
        Multi-File Compilation</a></h3>
    <a name="inlineExamples"></a>
    
    <p>There are various reasons for using multi-file compilation:</p>
    <ul>
      <li>To choose the name for the generated module, for
      example, because you need to compile the same specs for
      different encoding rules.</li>
      <li>You want only one resulting module.</li>
    </ul>
    <p>Specify which ASN.1 specs to compile in a module with extension
      <span class="code">.set.asn</span>. Choose a module name and provide the
      names of the ASN.1 specs. For example, if you have the specs
      <span class="code">File1.asn</span>, <span class="code">File2.asn</span>, and <span class="code">File3.asn</span>, your
      module <span class="code">MyModule.set.asn</span> looks as follows:</p>
    <div class="example"><pre>
File1.asn
File2.asn
File3.asn    </pre></div>
    <p>If you compile with the following, the result is one merged
    module <span class="code">MyModule.erl</span> with the generated code from the three
    ASN.1 specs:</p>
    <div class="example"><pre>
~&gt; erlc MyModule.set.asn    </pre></div>
  

  <h3><a name="id61202">3.4 
        Remark about Tags</a></h3>
    

    <p>Tags used to be important for all users of ASN.1, because it
    was necessary to add tags manually to certain constructs in order
    for the ASN.1 specification to be valid. Example of
    an old-style specification:</p>

    <div class="example"><pre>
Tags DEFINITIONS ::=
BEGIN
  Afters ::= CHOICE { cheese [0] IA5String,
                      dessert [1] IA5String }
END </pre></div>

    <p>Without the tags (the numbers in square brackets) the ASN.1
    compiler refused to compile the file.</p>

    <p>In 1994 the global tagging mode <span class="code">AUTOMATIC TAGS</span> was introduced.
    By putting <span class="code">AUTOMATIC TAGS</span> in the module header, the ASN.1
    compiler automatically adds tags when needed. The following is the
    same specification in <span class="code">AUTOMATIC TAGS</span> mode:</p>

    <div class="example"><pre>
Tags DEFINITIONS AUTOMATIC TAGS ::=
BEGIN
  Afters ::= CHOICE { cheese IA5String,
                      dessert IA5String }
END </pre></div>

    <p>Tags are not mentioned any more in this User's Guide.</p>
  

  <h3><a name="id61253">3.5 
        ASN.1 Types</a></h3>
    <a name="ASN1Types"></a>
    
    <p>This section describes the ASN.1 types including their
      functionality, purpose, and how values are assigned in Erlang.
      </p>
    <p>ASN.1 has both primitive and constructed types:</p>
    <p></p>
    <table border="1" cellpadding="2" cellspacing="0">
<tr>
        <td align="left" valign="middle"><strong>Primitive Types</strong></td>
        <td align="left" valign="middle"><strong>Constructed Types</strong></td>
      </tr>
<tr>
        <td align="left" valign="middle"><span class="bold_code"><a href="#BOOLEAN">BOOLEAN</a></span></td>
        <td align="left" valign="middle"><span class="bold_code"><a href="#SEQUENCE">SEQUENCE</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle"><span class="bold_code"><a href="#INTEGER">INTEGER</a></span></td>
        <td align="left" valign="middle"><span class="bold_code"><a href="#SET">SET</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle"><span class="bold_code"><a href="#REAL">REAL</a></span></td>
        <td align="left" valign="middle"><span class="bold_code"><a href="#CHOICE">CHOICE</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle"><span class="bold_code"><a href="#NULL">NULL</a></span></td>
        <td align="left" valign="middle"><span class="bold_code"><a href="#SOF">SET OF and SEQUENCE OF</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle"><span class="bold_code"><a href="#ENUMERATED">ENUMERATED</a></span></td>
        <td align="left" valign="middle"><span class="bold_code"><a href="#ANY">ANY</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle"><span class="bold_code"><a href="#BIT%20STRING">BIT STRING</a></span></td>
        <td align="left" valign="middle"><span class="bold_code"><a href="#ANY">ANY DEFINED BY</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle"><span class="bold_code"><a href="#OCTET%20STRING">OCTET STRING</a></span></td>
        <td align="left" valign="middle"><span class="bold_code"><a href="#NegotiationTypes">EXTERNAL</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle"><span class="bold_code"><a href="#Character%20Strings">Character Strings</a></span></td>
        <td align="left" valign="middle"><span class="bold_code"><a href="#NegotiationTypes">EMBEDDED PDV</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle"><span class="bold_code"><a href="#OBJECT%20IDENTIFIER">OBJECT IDENTIFIER</a></span></td>
        <td align="left" valign="middle"><span class="bold_code"><a href="#NegotiationTypes">CHARACTER STRING</a></span></td>
      </tr>
<tr>
        <td align="left" valign="middle"><span class="bold_code"><a href="#Object%20Descriptor">Object Descriptor</a></span></td>
        <td align="left" valign="middle"></td>
      </tr>
<tr>
        <td align="left" valign="middle"><span class="bold_code"><a href="#The%20TIME%20types">TIME Types</a></span></td>
        <td align="left" valign="middle"></td>
      </tr>
</table>
<em>Table
        3.1:
         
        Supported ASN.1 Types</em>
    <a name="TypeNameValue"></a>
    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>The values of each ASN.1 type have their own representation in Erlang, as
        described in the following sections. Users must provide
        these values for encoding according to the representation, as shown in the
        following example:</p>
    </p></div>
</div>
    <div class="example"><pre>
Operational ::= BOOLEAN --ASN.1 definition    </pre></div>
    <p>In Erlang code it can look as follows:</p>
    <div class="example"><pre>
Val = true,
{ok,Bytes} = MyModule:encode('Operational', Val),    </pre></div>

    <h4>BOOLEAN</h4>
      <a name="BOOLEAN"></a>
      
      <p>Booleans in ASN.1 express values that can be either
        <span class="code">TRUE</span> or <span class="code">FALSE</span>.
        The meanings assigned to <span class="code">TRUE</span> and <span class="code">FALSE</span> are outside the scope
        of this text.</p>
      <p>In ASN.1 it is possible to have:</p>
      <div class="example"><pre>
Operational ::= BOOLEAN</pre></div>
      <p>Assigning a value to type <span class="code">Operational</span> in Erlang is possible by
        using the following Erlang code:</p>
      <div class="example"><pre>
Myvar1 = true,</pre></div>
      <p>Thus, in Erlang the atoms <span class="code">true</span> and <span class="code">false</span> are used
        to encode a boolean value.</p>
    

    <h4>INTEGER</h4>
      <a name="INTEGER"></a>
      
      <p>ASN.1 itself specifies indefinitely large integers. Erlang
        systems with version 4.3 and higher support very large
        integers, in practice indefinitely large integers.</p>
      <p>The concept of subtyping can be applied to integers and
        to other ASN.1 types. The details of subtyping are not
        explained here; for more information, see X.680. Various
        syntaxes are allowed when defining a type as an integer:</p>
      <div class="example"><pre>
T1 ::= INTEGER
T2 ::= INTEGER (-2..7)
T3 ::= INTEGER (0..MAX)
T4 ::= INTEGER (0&lt;..MAX)
T5 ::= INTEGER (MIN&lt;..-99)
T6 ::= INTEGER {red(0),blue(1),white(2)}</pre></div>
      <p>The Erlang representation of an ASN.1 <span class="code">INTEGER</span> is an integer or
        an atom if a <span class="code">Named Number List</span> (see <span class="code">T6</span> in the previous
        list) is specified.</p>
      <p>The following is an example of Erlang code that assigns values for the
        types in the previous list:</p>
      <div class="example"><pre>
T1value = 0,
T2value = 6,
T6value1 = blue,
T6value2 = 0,
T6value3 = white</pre></div>
      <p>These Erlang variables are now bound to valid instances of
        ASN.1 defined types. This style of value can be passed directly
        to the encoder for transformation into a series of bytes.</p>
      <p>The decoder returns an atom if the value corresponds to a
        symbol in the <span class="code">Named Number List</span>.</p>
    

    <h4>REAL</h4>
      <a name="REAL"></a>
      
      <p>The following ASN.1 type is used for real numbers:</p>
      <div class="example"><pre>
R1 ::= REAL</pre></div>
      <p>It is assigned a value in Erlang as follows:</p>
      <div class="example"><pre>
R1value1 = "2.14",
R1value2 = {256,10,-2},</pre></div>
      <p>In the last line, notice that the tuple {256,10,-2} is the real number
        2.56 in a special notation, which encodes faster than simply
        stating the number as <span class="code">"2.56"</span>. The arity three tuple is
        <span class="code">{Mantissa,Base,Exponent}</span>, that is, Mantissa * Base^Exponent.</p>
    

    <h4>NULL</h4>
      <a name="NULL"></a>
      
      <p>The type <span class="code">NULL</span> is suitable where supply and recognition of a value
        is important but the actual value is not.</p>
      <div class="example"><pre>
Notype ::= NULL</pre></div>
      <p>This type is assigned in Erlang as follows:</p>
      <div class="example"><pre>
N1 = 'NULL',</pre></div>
      <p>The actual value is the quoted atom <span class="code">'NULL'</span>.</p>
    

    <h4>ENUMERATED</h4>
      <a name="ENUMERATED"></a>
      
      <p>The type <span class="code">ENUMERATED</span> can be used when the value you want to
        describe can only take one of a set of predefined values. Example:</p>
      <div class="example"><pre>
DaysOfTheWeek ::= ENUMERATED { 
    sunday(1),monday(2),tuesday(3),
    wednesday(4),thursday(5),friday(6),saturday(7) }</pre></div>
      <p>For example, to assign a weekday value in Erlang, use the same atom
        as in the <span class="code">Enumerations</span> of the type definition:</p>
      <div class="example"><pre>
Day1 = saturday,</pre></div>
      <p>The enumerated type is similar to an integer type, when
        defined with a set of predefined values. The difference is that
        an enumerated type can only have specified
        values, whereas an integer can have any value.</p>
    

    <h4>BIT STRING</h4>
      <a name="BIT%20STRING"></a>
      
      <p>The type <span class="code">BIT STRING</span> can be used to model information that
        is made up of arbitrary length series of bits. It is intended
        to be used for selection of flags, not for binary files.</p>
      <p>In ASN.1, <span class="code">BIT STRING</span> definitions can look as follows:</p>
      <div class="example"><pre>
Bits1 ::= BIT STRING
Bits2 ::= BIT STRING {foo(0),bar(1),gnu(2),gnome(3),punk(14)}</pre></div>
      <p>The following two notations are available for representation of <span class="code">BIT
        STRING</span> values in Erlang and as input to the encode functions:</p>
      <ul>
        <li>A bitstring. By default, a <span class="code">BIT STRING</span> with no
         symbolic names is decoded to an Erlang bitstring.</li>
        <li>A list of atoms corresponding to atoms in the <span class="code">NamedBitList</span>
         in the <span class="code">BIT STRING</span> definition. A <span class="code">BIT STRING</span> with symbolic
         names is always decoded to the format shown in the following
         example:</li>
      </ul>
      <div class="example"><pre>
Bits1Val1 = &lt;&lt;0:1,1:1,0:1,1:1,1:1&gt;&gt;,
Bits2Val1 = [gnu,punk],
Bits2Val2 = &lt;&lt;2#1110:4&gt;&gt;,
Bits2Val3 = [bar,gnu,gnome],</pre></div>
      <p><span class="code">Bits2Val2</span> and <span class="code">Bits2Val3</span> denote the same value.</p>
      <p><span class="code">Bits2Val1</span> is assigned symbolic values. The assignment means
        that the bits corresponding to <span class="code">gnu</span> and <span class="code">punk</span>, that is, bits
        2 and 14 are set to 1, and the rest are set to 0. The symbolic values
        are shown as a list of values. If a named value, which is not
        specified in the type definition, is shown, a runtime error occurs.</p>
      <p><span class="code">BIT STRING</span>s can also be subtyped with, for example, a <span class="code">SIZE</span>
        specification:</p>
      <div class="example"><pre>
Bits3 ::= BIT STRING (SIZE(0..31))      </pre></div>
      <p>This means that no bit higher than 31 can be set.</p>

      <h4>Deprecated Representations for BIT STRING</h4>
	
	<p>In addition to the representations described earlier, the
	following deprecated representations are available if the
	specification has been compiled with option
	<span class="code">legacy_erlang_types</span>:</p>
	<ul>
	  <li>Aa a list of binary digits (0 or 1). This format is
	  accepted as input to the encode functions, and a <span class="code">BIT STRING</span>
	  is decoded to this format if option
	  <strong>legacy_bit_string</strong> is given.
	  </li>
	  <li>As <span class="code">{Unused,Binary}</span> where <span class="code">Unused</span> denotes
	  how many trailing zero-bits 0-7 that are unused in the
	  least significant byte in <span class="code">Binary</span>. This format is
	  accepted as input to the encode functions, and a <span class="code">BIT
	  STRING</span> is decoded to this format if
	  <span class="code">compact_bit_string</span> has been given.
	  </li>
	  <li>As a hexadecimal number (or an integer). Avoid this
	  as it is easy to misinterpret a <span class="code">BIT
	  STRING</span> value in this format.
	  </li>
	</ul>
      
    

    <h4>OCTET STRING</h4>
      <a name="OCTET%20STRING"></a>
      
      <p><span class="code">OCTET STRING</span> is the simplest of all ASN.1 types. <span class="code">OCTET
      STRING</span> only moves or transfers, for example, binary files or other
      unstructured information complying with two rules: the
      bytes consist of octets and encoding is not required.</p>
      <p>It is possible to have the following ASN.1 type definitions:</p>
      <div class="example"><pre>
O1 ::= OCTET STRING
O2 ::= OCTET STRING (SIZE(28))      </pre></div>
      <p>With the following example assignments in Erlang:</p>
      <div class="example"><pre>
O1Val = &lt;&lt;17,13,19,20,0,0,255,254&gt;&gt;,
O2Val = &lt;&lt;"must be exactly 28 chars...."&gt;&gt;,</pre></div>
       <p>By default, an <span class="code">OCTET STRING</span> is always represented as
       an Erlang binary. If the specification has been compiled with
       option <span class="code">legacy_erlang_types</span>, the encode functions
       accept both lists and binaries, and the decode functions
       decode an <span class="code">OCTET STRING</span> to a list.</p>
    

    <h4>Character Strings</h4>
      <a name="Character%20Strings"></a>
      
      <p>ASN.1 supports a wide variety of character sets. The main difference
        between an <span class="code">OCTET STRING</span> and a character string is that the
        <span class="code">OCTET STRING</span> has no imposed semantics on the bytes delivered.</p>
      <p>However, when using, for example, IA5String (which closely
        resembles ASCII), byte 65 (in decimal
        notation) <strong>means</strong> character 'A'.
        </p>
      <p>For example, if a defined type is to be a VideotexString and
        an octet is received with the unsigned integer value <span class="code">X</span>,
        the octet is to be interpreted as specified in standard
        ITU-T T.100, T.101. 
        </p>
      <p>The  ASN.1 to Erlang compiler
        does not determine the correct interpretation of each BER
        string octet value with different character strings. The
        application is responsible for interpretation
        of octets. Therefore, from the BER
        string point of view, octets are very similar to
        character strings and are compiled in the same way.
        </p>
      <p>When PER is
        used, there is a significant difference in the encoding scheme
        between <span class="code">OCTET STRING</span>s and other strings. The constraints
        specified for a type are especially important for PER, where
        they affect the encoding.
        </p>
      <p>Examples:</p>
      <div class="example"><pre>
Digs ::= NumericString (SIZE(1..3))
TextFile ::= IA5String (SIZE(0..64000))      </pre></div>
      <p>The corresponding Erlang assignments:</p>
      <div class="example"><pre>
DigsVal1 = "456",
DigsVal2 = "123",
TextFileVal1 = "abc...xyz...",
TextFileVal2 = [88,76,55,44,99,121 .......... a lot of characters here ....]</pre></div>
      <p>The Erlang representation for "BMPString" and
        "UniversalString" is either a list of ASCII values or a list
        of quadruples. The quadruple representation associates to the
        Unicode standard representation of characters. The ASCII
        characters are all represented by quadruples beginning with
        three zeros like {0,0,0,65} for character 'A'. When
        decoding a value for these strings, the result is a list of
        quadruples, or integers when the value is an ASCII character.</p>

      <p>The following example shows how it works. Assume the following
        specification is in file <span class="code">PrimStrings.asn1</span>:</p>
       <div class="example"><pre>
PrimStrings DEFINITIONS AUTOMATIC TAGS ::=
BEGIN
   BMP ::= BMPString
END    </pre></div>

       <p>Encoding and decoding some strings:</p>

      <div class="example"><pre>
1&gt; <span class="bold_code">asn1ct:compile('PrimStrings', [ber]).</span>
ok
2&gt; <span class="bold_code">{ok,Bytes1} = 'PrimStrings':encode('BMP', [{0,0,53,53},{0,0,45,56}]).</span>
{ok,&lt;&lt;30,4,53,54,45,56&gt;&gt;}
3&gt; <span class="bold_code">'PrimStrings':decode('BMP', Bytes1).</span>
{ok,[{0,0,53,53},{0,0,45,56}]}
4&gt; <span class="bold_code">{ok,Bytes2} = 'PrimStrings':encode('BMP', [{0,0,53,53},{0,0,0,65}]).</span>
{ok,&lt;&lt;30,4,53,53,0,65&gt;&gt;}
5&gt; <span class="bold_code">'PrimStrings':decode('BMP', Bytes2).</span>
{ok,[{0,0,53,53},65]}
6&gt; <span class="bold_code">{ok,Bytes3} = 'PrimStrings':encode('BMP', "BMP string").</span>
{ok,&lt;&lt;30,20,0,66,0,77,0,80,0,32,0,115,0,116,0,114,0,105,0,110,0,103&gt;&gt;}
7&gt; <span class="bold_code">'PrimStrings':decode('BMP', Bytes3).</span>
{ok,"BMP string"}      </pre></div>

      <p>Type UTF8String is represented as a UTF-8 encoded binary in
      Erlang. Such binaries can be created directly using the binary syntax
      or by converting from a list of Unicode code points using function
      <span class="code">unicode:characters_to_binary/1</span>.</p>

      <p>The following shows examples of how UTF-8 encoded binaries can
      be created and manipulated:</p>
      <div class="example"><pre>
1&gt; <span class="bold_code">Gs = "Мой маленький Гном".</span>
[1052,1086,1081,32,1084,1072,1083,1077,1085,1100,1082,1080,
 1081,32,1043,1085,1086,1084]
2&gt; <span class="bold_code">Gbin = unicode:characters_to_binary(Gs).</span>
&lt;&lt;208,156,208,190,208,185,32,208,188,208,176,208,187,208,
  181,208,189,209,140,208,186,208,184,208,185,32,208,147,
  208,...&gt;&gt;
3&gt; <span class="bold_code">Gbin = &lt;&lt;"Мой маленький Гном"/utf8&gt;&gt;.</span>
&lt;&lt;208,156,208,190,208,185,32,208,188,208,176,208,187,208,
  181,208,189,209,140,208,186,208,184,208,185,32,208,147,
  208,...&gt;&gt;
4&gt; <span class="bold_code">Gs = unicode:characters_to_list(Gbin).</span>
[1052,1086,1081,32,1084,1072,1083,1077,1085,1100,1082,1080,
 1081,32,1043,1085,1086,1084]</pre></div>

      <p>For details, see the <span class="bold_code"><a href="../../man/unicode.html">unicode</a></span>
      module in <span class="code">stdlib</span>.</p>

      <p>In the following example, this ASN.1 specification is used:</p>
      <div class="example"><pre>
UTF DEFINITIONS AUTOMATIC TAGS ::=
BEGIN
   UTF ::= UTF8String
END   </pre></div>

      <p>Encoding and decoding a string with Unicode characters:</p>

      <div class="example"><pre>
5&gt; <span class="bold_code">asn1ct:compile('UTF', [ber]).</span>
ok
6&gt; <span class="bold_code">{ok,Bytes1} = 'UTF':encode('UTF', &lt;&lt;"Гном"/utf8&gt;&gt;).</span>
{ok,&lt;&lt;12,8,208,147,208,189,208,190,208,188&gt;&gt;}
7&gt; <span class="bold_code">{ok,Bin1} = 'UTF':decode('UTF', Bytes1).</span>
{ok,&lt;&lt;208,147,208,189,208,190,208,188&gt;&gt;}
8&gt; <span class="bold_code">io:format("~ts\n", [Bin1]).</span>
Гном
ok
9&gt; <span class="bold_code">unicode:characters_to_list(Bin1).</span>
[1043,1085,1086,1084]   </pre></div>
    

    <h4>OBJECT IDENTIFIER</h4>
      <a name="OBJECT%20IDENTIFIER"></a>
      
      <p>The type <span class="code">OBJECT IDENTIFIER</span> is used whenever a unique identity is
        required. An ASN.1 module, a transfer syntax, and so on, is identified
        with an <span class="code">OBJECT IDENTIFIER</span>. Assume the following example:</p>
      <div class="example"><pre>
Oid ::= OBJECT IDENTIFIER</pre></div>
      <p>Therefore, the following example is a valid Erlang instance of
        type 'Oid':</p>
      <div class="example"><pre>
OidVal1 = {1,2,55},</pre></div>
      <p>The <span class="code">OBJECT IDENTIFIER</span> value is simply a tuple with the
        consecutive values, which must be integers.
        </p>
      <p>The first value is limited to the values 0, 1, or 2. The
        second value must be in the range 0..39 when the first value
        is 0 or 1.
        </p>
      <p>The <span class="code">OBJECT IDENTIFIER</span> is an important type and it is
        widely used within different standards to identify various
        objects uniquely. Dubuisson: ASN.1 - Communication Between
        Heterogeneous Systems includes an
        easy-to-understand description of the use of
        <span class="code">OBJECT IDENTIFIER</span>.</p>
    

    <h4>Object Descriptor</h4>
      <a name="Object%20Descriptor"></a>
      
      <p>Values of this type can be assigned a value as an ordinary string
      as follows:</p>

      <div class="example"><pre>
      "This is the value of an Object descriptor"</pre></div>
    

    <h4>TIME Types</h4>
      <a name="The%20TIME%20types"></a>
      
      <p>Two time types are defined within ASN.1: Generalized
        Time and Universal Time Coordinated (UTC). Both are assigned a
        value as an ordinary string within double quotes, for example,
        "19820102070533.8".</p>
      <p>For DER encoding, the compiler does not check the validity
        of the time values. The DER requirements upon those strings are
        regarded as a matter for the application to fulfill.</p>
    

    <h4>SEQUENCE</h4>
      <a name="SEQUENCE"></a>
      
      <p>The structured types of ASN.1 are constructed from other types
        in a manner similar to the concepts of array and struct in  C.</p>
      <p>A <span class="code">SEQUENCE</span> in ASN.1 is
        comparable with a struct in C and a record in Erlang.
        A <span class="code">SEQUENCE</span> can be defined as follows:</p>
      <div class="example"><pre>
Pdu ::= SEQUENCE {
   a INTEGER,
   b REAL,
   c OBJECT IDENTIFIER,
   d NULL }      </pre></div>
      <p>This is a 4-component structure called <span class="code">Pdu</span>. The record format
        is the major format for representation of <span class="code">SEQUENCE</span> in Erlang.
        For each <span class="code">SEQUENCE</span> and <span class="code">SET</span> in an ASN.1 module an Erlang
        record declaration is generated. For <span class="code">Pdu</span>, a record
        like the following is defined:</p>
      <div class="example"><pre>
-record('Pdu',{a, b, c, d}).      </pre></div>
      <p>The record declarations for a module <span class="code">M</span> are placed in a
        separate <span class="code">M.hrl</span> file.</p>
      <p>Values can be assigned in Erlang as follows:</p>
      <div class="example"><pre>
MyPdu = #'Pdu'{a=22,b=77.99,c={0,1,2,3,4},d='NULL'}.      </pre></div>
      <p>The decode functions return a record as result when decoding
      a <span class="code">SEQUENCE</span> or a <span class="code">SET</span>.</p>

      <p>A <span class="code">SEQUENCE</span> and a <span class="code">SET</span> can contain a component
      with a <span class="code">DEFAULT</span> keyword followed by the actual value, which
      is the default value. The <span class="code">DEFAULT</span> keyword means that the
      application doing the encoding can omit encoding of the value, which
      results in fewer bytes to send to the receiving application.</p>

      <p>An application can use the atom <span class="code">asn1_DEFAULT</span> to indicate
      that the encoding is to be omitted for that position in
      the <span class="code">SEQUENCE</span>.</p>

      <p>Depending on the encoding rules, the encoder can also compare
      the given value to the default value and automatically omit the
      encoding if the values are equal. How much effort the encoder makes
      to compare the values depends on the encoding rules. The DER
      encoding rules forbid encoding a value equal to the default value,
      so it has a more thorough and time-consuming comparison than the
      encoders for the other encoding rules.</p>

      <p>In the following example, this ASN.1 specification is used:</p>
      <div class="example"><pre>
File DEFINITIONS AUTOMATIC TAGS ::=
BEGIN
Seq1 ::= SEQUENCE {
    a INTEGER DEFAULT 1,
    b Seq2 DEFAULT {aa TRUE, bb 15}
}

Seq2 ::= SEQUENCE {
    aa BOOLEAN,
    bb INTEGER
}

Seq3 ::= SEQUENCE {
    bs BIT STRING {a(0), b(1), c(2)} DEFAULT {a, c}
}
END </pre></div>
      <p>Example where the BER encoder is able to omit encoding
      of the default values:</p>
      <div class="example"><pre>
1&gt; <span class="bold_code">asn1ct:compile('File', [ber]).</span>
ok
2&gt; <span class="bold_code">'File':encode('Seq1', {'Seq1',asn1_DEFAULT,asn1_DEFAULT}).</span>
{ok,&lt;&lt;48,0&gt;&gt;}
3&gt; <span class="bold_code">'File':encode('Seq1', {'Seq1',1,{'Seq2',true,15}}).</span>
{ok,&lt;&lt;48,0&gt;&gt;}   </pre></div>

     <p>Example with a named <span class="code">BIT STRING</span> where the BER
     encoder does not omit the encoding:</p>
     <div class="example"><pre>
4&gt; <span class="bold_code">'File':encode('Seq3', {'Seq3',asn1_DEFAULT).</span>
{ok,&lt;&lt;48,0&gt;&gt;}
5&gt; <span class="bold_code">'File':encode('Seq3', {'Seq3',&lt;&lt;16#101:3&gt;&gt;).</span>
{ok,&lt;&lt;48,4,128,2,5,160&gt;&gt;}     </pre></div>

     <p>The DER encoder omits the encoding for the same <span class="code">BIT STRING</span>:</p>
     <div class="example"><pre>
6&gt; <span class="bold_code">asn1ct:compile('File', [ber,der]).</span>
ok
7&gt; <span class="bold_code">'File':encode('Seq3', {'Seq3',asn1_DEFAULT).</span>
{ok,&lt;&lt;48,0&gt;&gt;}
8&gt; <span class="bold_code">'File':encode('Seq3', {'Seq3',&lt;&lt;16#101:3&gt;&gt;).</span>
{ok,&lt;&lt;48,0&gt;&gt;}     </pre></div>
    

    <h4>SET</h4>
      <a name="SET"></a>
      
      <p>In Erlang, the <span class="code">SET</span> type is used exactly as <span class="code">SEQUENCE</span>.
      Notice that if BER or DER encoding rules are used, decoding a
      <span class="code">SET</span> is slower than decoding a <span class="code">SEQUENCE</span> because the
      components must be sorted.</p>
    

    <h4>Extensibility for SEQUENCE and SET</h4>
      
      <p>When a <span class="code">SEQUENCE</span> or <span class="code">SET</span> contains an extension marker
        and extension components as the following, the type can get more
        components in newer versions of the ASN.1 spec:</p>
      <div class="example"><pre>
SExt ::= SEQUENCE {
           a INTEGER,
           ...,
           b BOOLEAN }</pre></div>
      <p>In this case it has got a new
        component <span class="code">b</span>. Thus, incoming messages that are decoded
        can have more or fever components than this one.
        </p>
      <p>The component <span class="code">b</span> is treated as
        an original component when encoding a message. In this case, as
        it is not an optional element, it must be encoded.
        </p>
      <p>During decoding, the <span class="code">b</span> field of the record gets the decoded
        value of the <span class="code">b</span>
        component, if present, otherwise the value <span class="code">asn1_NOVALUE</span>.</p>
    

    <h4>CHOICE</h4>
      <a name="CHOICE"></a>
      
      <p>The type <span class="code">CHOICE</span> is a space saver and is similar to the
      concept of a 'union' in C.</p>
      <p>Assume the following:</p>
      <div class="example"><pre>
SomeModuleName DEFINITIONS AUTOMATIC TAGS ::=
BEGIN
T ::= CHOICE {
        x REAL,
        y INTEGER,
        z OBJECT IDENTIFIER }
END </pre></div>
      <p>It is then possible to assign values as follows:</p>
      <div class="example"><pre>
TVal1 = {y,17},
TVal2 = {z,{0,1,2}},</pre></div>
      <p>A <span class="code">CHOICE</span> value is always represented as the tuple
        <span class="code">{ChoiceAlternative, Val}</span> where <span class="code">ChoiceAlternative</span>
        is an atom denoting the selected choice alternative.
      </p>

      <h4>Extensible CHOICE</h4>
        
        <p>When a <span class="code">CHOICE</span> contains an extension marker and the
         decoder detects an unknown alternative of the <span class="code">CHOICE</span>,
         the value is represented as follows:</p>
        <div class="example"><pre>
{asn1_ExtAlt, BytesForOpenType}</pre></div>
        <p>Here <span class="code">BytesForOpenType</span> is a list of bytes constituting the
          encoding of the "unknown" <span class="code">CHOICE</span> alternative.</p>
      
    

    <h4>SET OF and SEQUENCE OF</h4>
      <a name="SOF"></a>
      
      <p>The types <span class="code">SET OF</span> and <span class="code">SEQUENCE OF</span> correspond
        to the concept of an array
        in several programming languages. The Erlang syntax for
        both types is straightforward, for example:</p>
      <div class="example"><pre>
Arr1 ::= SET SIZE (5) OF INTEGER (4..9) 
Arr2 ::= SEQUENCE OF OCTET STRING      </pre></div>
      <p>In Erlang the following can apply:</p>
      <div class="example"><pre>
Arr1Val = [4,5,6,7,8],
Arr2Val = ["abc",[14,34,54],"Octets"],      </pre></div>
      <p>Notice that the definition of type <span class="code">SET OF</span> implies that
        the order of the components is undefined, but in practice there is 
        no difference between <span class="code">SET OF</span> and <span class="code">SEQUENCE OF</span>.
        The ASN.1 compiler for Erlang does not randomize the order of the
        <span class="code">SET OF</span> components before encoding.</p>
      <p>However, for a value of type <span class="code">SET OF</span>, the DER
        encoding format requires the elements to be sent in ascending
        order of their encoding, which implies an expensive sorting
        procedure in runtime. Therefore it is recommended to
        use <span class="code">SEQUENCE OF</span> instead of <span class="code">SET OF</span> if possible.</p>
    

    <h4>ANY and ANY DEFINED BY</h4>
      <a name="ANY"></a>
      
      <p>The types <span class="code">ANY</span> and <span class="code">ANY DEFINED BY</span> have been removed
        from the standard since 1994. It is recommended not to use
        these types any more. They can, however, exist in some old ASN.1
        modules. The idea with this type was to leave a "hole" in a 
        definition where it was possible to
        put unspecified data of any kind, even non-ASN.1 data.</p>
      <p>A value of this type is encoded as an <span class="code">open type</span>.</p>
      <p>Instead of <span class="code">ANY</span> and <span class="code">ANY DEFINED BY</span>, it is
        recommended to use
        <span class="code">information object class</span>, <span class="code">table constraints</span>, and
        <span class="code">parameterization</span>. In particular the construct
        <span class="code">TYPE-IDENTIFIER.@Type</span> accomplish the same as the
        deprecated <span class="code">ANY</span>.</p>
      <p>See also
      <span class="bold_code"><a href="#Information%20Object">Information object</a></span>.</p>
    

    <h4>EXTERNAL, EMBEDDED PDV, and CHARACTER STRING</h4>
      <a name="NegotiationTypes"></a>
      
      <p>The types <span class="code">EXTERNAL</span>, <span class="code">EMBEDDED PDV</span>, and
      <span class="code">CHARACTER STRING</span> are used in presentation layer negotiation.
        They are encoded according to their associated type, see X.680.</p>
      <p>The type <span class="code">EXTERNAL</span> had a slightly different associated type
        before 1994. X.691 states that encoding must follow
        the older associated type. So, generated encode/decode
        functions convert values of the newer format to the older format
        before encoding. This implies that it is allowed to use
        <span class="code">EXTERNAL</span> type values of either format for encoding. Decoded
        values are always returned in the newer format.</p>
    

    <h4>Embedded Named Types</h4>
      
      <p>The structured types previously described can have other named
        types as their components. The general syntax to assign a value
        to component <span class="code">C</span> of a named ASN.1 type <span class="code">T</span> in Erlang
        is the record syntax <span class="code">#'T'{'C'=Value}</span>.
        Here <span class="code">Value</span> can be a value of yet another type <span class="code">T2</span>,
        for example:</p>
      <div class="example"><pre>
EmbeddedExample DEFINITIONS AUTOMATIC TAGS ::=
BEGIN
B ::= SEQUENCE {
        a Arr1,
        b T }

Arr1 ::= SET SIZE (5) OF INTEGER (4..9) 

T ::= CHOICE {
        x REAL,
        y INTEGER,
        z OBJECT IDENTIFIER }
        END      </pre></div>
      <p><span class="code">SEQUENCE</span> <span class="code">b</span> can be encoded as follows in Erlang:</p>
      <div class="example"><pre>
1&gt; 'EmbeddedExample':encode('B', {'B',[4,5,6,7,8],{x,"7.77"}}).
{ok,&lt;&lt;5,56,0,8,3,55,55,55,46,69,45,50&gt;&gt;} </pre></div>
    
  

  <h3><a name="id64025">3.6 
        Naming of Records in .hrl Files</a></h3>
    
    <p>When an ASN.1 specification is compiled, all defined types of type
      <span class="code">SET</span> or <span class="code">SEQUENCE</span> result in a corresponding record in the
      generated <span class="code">.hrl</span> file. This is because the values for
      <span class="code">SET</span> and <span class="code">SEQUENCE</span> are represented as records as
      mentioned earlier.</p>
    <p>Some special cases of this functionality are presented in the
      next section.</p>

    <h4>Embedded Structured Types</h4>
      
      <p>In ASN.1 it is also possible to have components that are themselves
        structured types.
        For example, it is possible to have the following:</p>
      <div class="example"><pre>
Emb ::= SEQUENCE {
    a SEQUENCE OF OCTET STRING,
    b SET {
       a INTEGER,
       b INTEGER DEFAULT 66},
    c CHOICE {
       a INTEGER,
       b FooType } }

FooType ::= [3] VisibleString      </pre></div>
      <p>The following records are generated because of type <span class="code">Emb</span>:</p>
      <div class="example"><pre>
-record('Emb,{a, b, c}).
-record('Emb_b',{a, b = asn1_DEFAULT}). % the embedded SET type </pre></div>
      <p>Values of type <span class="code">Emb</span> can be assigned as follows:</p>
      <div class="example"><pre>
V = #'Emb'{a=["qqqq",[1,2,255]], 
           b = #'Emb_b'{a=99}, 
           c ={b,"Can you see this"}}.</pre></div>
      <p>For an embedded type of type <span class="code">SEQUENCE</span>/<span class="code">SET</span> in a
        <span class="code">SEQUENCE</span>/<span class="code">SET</span>, the record name is extended with an
        underscore and the component name. If the embedded structure is
        deeper with the <span class="code">SEQUENCE</span>, <span class="code">SET</span>, or <span class="code">CHOICE</span>
        types in the line, each component name/alternative name is
        added to the record name.</p>
      <p>Example:</p>
      <div class="example"><pre>
Seq ::= SEQUENCE{
    a CHOICE{
        b SEQUENCE {
           c  INTEGER
        }
    }
}      </pre></div>
      <p>This results in the following record:</p>
      <div class="example"><pre>
-record('Seq_a_b',{c}).      </pre></div>
      <p>If the structured type has a component with an embedded
        <span class="code">SEQUENCE OF</span>/<span class="code">SET OF</span> which embedded type in turn
        is a <span class="code">SEQUENCE</span>/<span class="code">SET</span>, it gives a record with the
        <span class="code">SEQUENCE OF</span>/<span class="code">SET OF</span>
        addition as in the following example:</p>
      <div class="example"><pre>
Seq ::= SEQUENCE {
    a SEQUENCE OF SEQUENCE {
           b
               }
    c SET OF SEQUENCE {
           d
               }
}      </pre></div>
      <p>This results in the following records:</p>
      <div class="example"><pre>
-record('Seq_a_SEQOF'{b}).
-record('Seq_c_SETOF'{d}).      </pre></div>
      <p>A parameterized type is to be considered as an embedded
        type. Each time such a type is referenced, an instance of it is
        defined. Thus, in the following example a record with name
        <span class="code">'Seq_b'</span> is generated in the <span class="code">.hrl</span> file and is used
        to hold values:</p>
      <div class="example"><pre>
Seq ::= SEQUENCE {
    b PType{INTEGER}
}

PType{T} ::= SEQUENCE{
    id T
}      </pre></div>
    

    <h4>Recursive Types</h4>
      
      <p>Types that refer to themselves are called recursive types.
      Example:</p>
      <div class="example"><pre>
Rec ::= CHOICE {
     nothing NULL,
     something SEQUENCE {
          a INTEGER,
          b OCTET STRING,
          c Rec }}      </pre></div>
      <p>This is allowed in ASN.1 and the ASN.1-to-Erlang compiler
      supports this recursive type.
      A value for this type is assigned in Erlang as follows:</p>
      <div class="example"><pre>
V = {something,#'Rec_something'{a = 77, 
                                b = "some octets here", 
                                c = {nothing,'NULL'}}}.      </pre></div>
    
  

  <h3><a name="id62786">3.7 
        ASN.1 Values</a></h3>
    
    <p>Values can be assigned to an ASN.1 type within the ASN.1 code
      itself, as opposed to the actions in the previous section where
      a value was assigned to an ASN.1 type in Erlang. The full value
      syntax of ASN.1 is supported and X.680 describes in detail how
      to assign values in ASN.1. A short example:</p>
    <div class="example"><pre>
TT ::= SEQUENCE {
   a INTEGER,
   b SET OF OCTET STRING }

tt TT ::= {a 77,b {"kalle","kula"}}    </pre></div>
    <p>The value defined here can be used in several ways. It can, for
      example, be used as the value in some <span class="code">DEFAULT</span> component:</p>
    <div class="example"><pre>
SS ::= SET {
    s OBJECT IDENTIFIER,
    val TT DEFAULT tt }    </pre></div>
    <p>It can also be used from inside an Erlang program. If this ASN.1
      code is defined in ASN.1 module <span class="code">Values</span>, the ASN.1 value
      <span class="code">tt</span> can be reached from Erlang as a function call to
      <span class="code">'Values':tt()</span> as in the following example:</p>
    <div class="example"><pre>
1&gt; <span class="bold_code">Val = 'Values':tt().</span>
{'TT',77,["kalle","kula"]}
2&gt; <span class="bold_code">{ok,Bytes} = 'Values':encode('TT',Val).</span>
{ok,&lt;&lt;48,18,128,1,77,161,13,4,5,107,97,108,108,101,4,4,
      107,117,108,97&gt;&gt;}
4&gt; <span class="bold_code">'Values':decode('TT',Bytes).</span>
{ok,{'TT',77,["kalle","kula"]}}
5&gt;  </pre></div>
    <p>This example shows that a function is generated by the compiler
      that returns a valid Erlang representation of the value, although
      the value is of a complex type.</p>
    <p>Furthermore, a macro is generated for each value in the <span class="code">.hrl</span>
      file. So, the defined value <span class="code">tt</span> can also be extracted by
      <span class="code">?tt</span> in application code.</p>
  

  <h3><a name="id62869">3.8 
        Macros</a></h3>
    
    <p>The type <span class="code">MACRO</span> is not supported. It is no longer part of
    the ASN.1 standard.</p>
  

  <h3><a name="id62889">3.9 
        ASN.1 Information Objects (X.681)</a></h3>
    <a name="Information%20Object"></a>
    
    <p>Information Object Classes, Information Objects, and Information
      Object Sets (in the following called classes, objects, and
      object sets, respectively) are defined in the standard
      definition X.681. Only a brief explanation is given here.</p>
    <p>These constructs makes it possible to define open types, that
      is, values of that type can be of any ASN.1 type. Also,
      relationships can be defined between different types and
      values, as classes can hold types, values, objects, object
      sets, and other classes in their fields. A class can be
      defined in ASN.1 as follows:</p>
    <div class="example"><pre>
GENERAL-PROCEDURE ::= CLASS {
      &amp;Message,
      &amp;Reply               OPTIONAL,
      &amp;Error               OPTIONAL,
      &amp;id          PrintableString UNIQUE
}
WITH SYNTAX {
      NEW MESSAGE     &amp;Message
      [REPLY           &amp;Reply]
      [ERROR           &amp;Error]
      ADDRESS          &amp;id
}    </pre></div>
    <p>An object is an instance of a class. An object set is a set
      containing objects of a specified class. A definition can look
      as follows:</p>
    <div class="example"><pre>
object1 GENERAL-PROCEDURE ::= {
    NEW MESSAGE      PrintableString
    ADDRESS          "home"
}

object2 GENERAL-PROCEDURE ::= {
    NEW MESSAGE INTEGER
    ERROR INTEGER
    ADDRESS "remote"
}</pre></div>
    <p>The object <span class="code">object1</span> is an instance of the class
      <span class="code">GENERAL-PROCEDURE</span> and has one type field and one
      fixed type value field. The object <span class="code">object2</span> has also an
      optional field <span class="code">ERROR</span>, which is a type field. The field
      <span class="code">ADDRESS</span> is a <span class="code">UNIQUE</span> field. Objects in an object set
      must have unique values in their <span class="code">UNIQUE</span> field, as in
      <span class="code">GENERAL-PROCEDURES</span>:</p>
    <div class="example"><pre>
GENERAL-PROCEDURES GENERAL-PROCEDURE ::= {
    object1 | object2}    </pre></div>
    <p>You cannot encode a class, object, or object set, only refer to
      it when defining other ASN.1 entities. Typically you refer to a
      class as well as to object sets by table constraints and component
      relation constraints (X.682) in ASN.1 types, as in the following:</p>
    <div class="example"><pre>
StartMessage  ::= SEQUENCE {
    msgId  GENERAL-PROCEDURE.&amp;id  ({GENERAL-PROCEDURES}),
    content GENERAL-PROCEDURE.&amp;Message ({GENERAL-PROCEDURES}{@msgId}),
    }    </pre></div>
    <p>In type <span class="code">StartMessage</span>, the constraint following field
      <span class="code">content</span> tells that in a value of type
      <span class="code">StartMessage</span> the value in field <span class="code">content</span> must
      come from the same object that is chosen by field <span class="code">msgId</span>.</p>
    <p>So, the value
      <span class="code">#'StartMessage'{msgId="home",content="Any Printable String"}</span>
      is legal to encode as a <span class="code">StartMessage</span> value. However, the value
      <span class="code">#'StartMessage'{msgId="remote", content="Some String"}</span>
      is illegal as the constraint in <span class="code">StartMessage</span> tells that
      when you have chosen a value from a specific object in object
      set <span class="code">GENERAL-PROCEDURES</span> in field 
      <span class="code">msgId</span>, you must choose a value from that same object in
      the content field too. In this second case, it is to be
      any <span class="code">INTEGER</span> value.</p>
    <p><span class="code">StartMessage</span> can in field <span class="code">content</span> be
      encoded with a value of any type that an object in object set
      <span class="code">GENERAL-PROCEDURES</span> has in its <span class="code">NEW MESSAGE</span> field.
      This field refers to a type field
      <span class="code">&amp;Message</span> in the class. Field <span class="code">msgId</span> is always
      encoded as a <span class="code">PrintableString</span>, as the field refers to a
      fixed type in the class.</p>
    <p>In practice, object sets are usually declared to be extensible so
      that more objects can be added to the set later. Extensibility is
      indicated as follows:</p>
    <div class="example"><pre>
GENERAL-PROCEDURES GENERAL-PROCEDURE ::= {
    object1 | object2, ...}    </pre></div>
     <p>When decoding a type that uses an extensible set constraint,
     it is always possible that the value in field <span class="code">UNIQUE</span>
     is unknown (that is, the type has been encoded with a later
     version of the ASN.1 specification). The unencoded data is then
     returned wrapped in a tuple as follows:</p>

     <div class="example"><pre>
{asn1_OPENTYPE,Binary}</pre></div>

     <p>Here <span class="code">Binary</span> is an Erlang binary that contains the encoded
     data. (If option <span class="code">legacy_erlang_types</span> has been given,
     only the binary is returned.)</p>
  

  <h3><a name="id68218">3.10 
        Parameterization (X.683)</a></h3>
    
    <p>Parameterization, which is defined in X.683, can be used when
      defining types, values, value sets, classes, objects, or object sets.
      A part of a definition can be supplied as a parameter. For
      example, if a <span class="code">Type</span> is used in a definition with a certain
      purpose, you want the type name to express the intention. This
      can be done with parameterization.</p>
    <p>When many types (or another ASN.1 entity) only differ in some
      minor cases, but the structure of the types is similar, only
      one general type can be defined and the differences can be supplied
      through parameters.</p>
    <p>Example of use of parameterization:</p>
    <div class="example"><pre>
General{Type} ::= SEQUENCE
{
     number     INTEGER,
     string     Type
}
      
T1 ::= General{PrintableString}

T2 ::= General{BIT STRING}</pre></div>
    <p>An example of a value that can be encoded as type <span class="code">T1</span> is
      <span class="code">{12,"hello"}</span>.</p>
    <p>Notice that the compiler does not generate encode/decode functions
      for parameterized types, only for the instances of the parameterized
      types. Therefore, if a file contains the types <span class="code">General{}</span>,
      <span class="code">T1</span>, and <span class="code">T2</span> as in the previous example, encode/decode
      functions are only generated for <span class="code">T1</span> and <span class="code">T2</span>.
      </p>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
