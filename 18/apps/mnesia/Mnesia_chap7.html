<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Mnesia System Information</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="index.html">Reference Manual</a><br><a href="release_notes.html">Release Notes</a><br><a href="mnesia.pdf">PDF</a><br><a href="../../index.html">Top</a></small><p><strong>Mnesia</strong><br><strong>User's Guide</strong><br><small>Version 4.13.3</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="Mnesia_chap1.html">
              Top of chapter
            </a></li>
<li title="Scope"><a href="Mnesia_chap1.html#id62970">Scope</a></li>
<li title="Prerequisites"><a href="Mnesia_chap1.html#id61618">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="Mnesia" expanded="false">Mnesia<ul>
<li><a href="Mnesia_overview.html">
              Top of chapter
            </a></li>
<li title="Mnesia Database Management System (DBMS)"><a href="Mnesia_overview.html#id56828">Mnesia Database Management System (DBMS)</a></li>
</ul>
</li>
<li id="no" title="Getting Started" expanded="false">Getting Started<ul>
<li><a href="Mnesia_chap2.html">
              Top of chapter
            </a></li>
<li title="Starting Mnesia for the First Time"><a href="Mnesia_chap2.html#id61789">Starting Mnesia for the First Time</a></li>
<li title="Example"><a href="Mnesia_chap2.html#id66273">Example</a></li>
</ul>
</li>
<li id="no" title="Build a Mnesia Database" expanded="false">Build a Mnesia Database<ul>
<li><a href="Mnesia_chap3.html">
              Top of chapter
            </a></li>
<li title="Define a Schema"><a href="Mnesia_chap3.html#id66909">Define a Schema</a></li>
<li title="Data Model"><a href="Mnesia_chap3.html#id70360">Data Model</a></li>
<li title="Start Mnesia"><a href="Mnesia_chap3.html#id70422">Start Mnesia</a></li>
<li title="Create Tables"><a href="Mnesia_chap3.html#id75532">Create Tables</a></li>
</ul>
</li>
<li id="no" title="Transactions and Other Access Contexts" expanded="false">Transactions and Other Access Contexts<ul>
<li><a href="Mnesia_chap4.html">
              Top of chapter
            </a></li>
<li title="Transaction Properties"><a href="Mnesia_chap4.html#id76135">Transaction Properties</a></li>
<li title="Locking"><a href="Mnesia_chap4.html#id76396">Locking</a></li>
<li title="Dirty Operations"><a href="Mnesia_chap4.html#id76969">Dirty Operations</a></li>
<li title="Record Names versus Table Names"><a href="Mnesia_chap4.html#id77432">Record Names versus Table Names</a></li>
<li title="Activity Concept and Various Access Contexts"><a href="Mnesia_chap4.html#id77531">Activity Concept and Various Access Contexts</a></li>
<li title="Nested Transactions"><a href="Mnesia_chap4.html#id78070">Nested Transactions</a></li>
<li title="Pattern Matching"><a href="Mnesia_chap4.html#id78160">Pattern Matching</a></li>
<li title="Iteration"><a href="Mnesia_chap4.html#id78629">Iteration</a></li>
</ul>
</li>
<li id="no" title="Miscellaneous Mnesia Features" expanded="false">Miscellaneous Mnesia Features<ul>
<li><a href="Mnesia_chap5.html">
              Top of chapter
            </a></li>
<li title="Indexing"><a href="Mnesia_chap5.html#id79053">Indexing</a></li>
<li title="Distribution and Fault Tolerance"><a href="Mnesia_chap5.html#id79192">Distribution and Fault Tolerance</a></li>
<li title="Table Fragmentation"><a href="Mnesia_chap5.html#id79352">Table Fragmentation</a></li>
<li title="Local Content Tables"><a href="Mnesia_chap5.html#id80361">Local Content Tables</a></li>
<li title="Disc-Less Nodes"><a href="Mnesia_chap5.html#id80388">Disc-Less Nodes</a></li>
<li title="More about Schema Management"><a href="Mnesia_chap5.html#id80610">More about Schema Management</a></li>
<li title="Mnesia Event Handling"><a href="Mnesia_chap5.html#id80912">Mnesia Event Handling</a></li>
<li title="Debugging Mnesia Applications"><a href="Mnesia_chap5.html#id81682">Debugging Mnesia Applications</a></li>
<li title="Concurrent Processes in Mnesia"><a href="Mnesia_chap5.html#id81830">Concurrent Processes in Mnesia</a></li>
<li title="Prototyping"><a href="Mnesia_chap5.html#id81882">Prototyping</a></li>
<li title="Object-Based Programming with Mnesia"><a href="Mnesia_chap5.html#id82022">Object-Based Programming with Mnesia</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Mnesia System Information" expanded="true">Mnesia System Information<ul>
<li><a href="Mnesia_chap7.html">
              Top of chapter
            </a></li>
<li title="Database Configuration Data"><a href="Mnesia_chap7.html#id82354">Database Configuration Data</a></li>
<li title="Core Dumps"><a href="Mnesia_chap7.html#id82399">Core Dumps</a></li>
<li title="Dumping Tables"><a href="Mnesia_chap7.html#id82431">Dumping Tables</a></li>
<li title="Checkpoints"><a href="Mnesia_chap7.html#id82479">Checkpoints</a></li>
<li title="Startup Files, Log File, and Data Files"><a href="Mnesia_chap7.html#id82740">Startup Files, Log File, and Data Files</a></li>
<li title="Loading Tables at Startup"><a href="Mnesia_chap7.html#id83254">Loading Tables at Startup</a></li>
<li title="Recovery from Communication Failure"><a href="Mnesia_chap7.html#id83474">Recovery from Communication Failure</a></li>
<li title="Recovery of Transactions"><a href="Mnesia_chap7.html#id83657">Recovery of Transactions</a></li>
<li title="Backup, Restore, Fallback, and Disaster Recovery"><a href="Mnesia_chap7.html#id83842">Backup, Restore, Fallback, and Disaster Recovery</a></li>
</ul>
</li>
<li id="no" title="Combine Mnesia with SNMP" expanded="false">Combine Mnesia with SNMP<ul>
<li><a href="Mnesia_chap8.html">
              Top of chapter
            </a></li>
<li title="Combine Mnesia and SNMP"><a href="Mnesia_chap8.html#id84804">Combine Mnesia and SNMP</a></li>
</ul>
</li>
<li id="no" title="Appendix A: Backup Callback Interface" expanded="false">Appendix A: Backup Callback Interface<ul>
<li><a href="Mnesia_App_A.html">
              Top of chapter
            </a></li>
<li title="mnesia_backup Callback Behavior"><a href="Mnesia_App_A.html#id84928">mnesia_backup Callback Behavior</a></li>
</ul>
</li>
<li id="no" title="Appendix B: Activity Access Callback Interface" expanded="false">Appendix B: Activity Access Callback Interface<ul>
<li><a href="Mnesia_App_B.html">
              Top of chapter
            </a></li>
<li title="mnesia_access Callback Behavior"><a href="Mnesia_App_B.html#id85049">mnesia_access Callback Behavior</a></li>
</ul>
</li>
<li id="no" title="Appendix C: Fragmented Table Hashing Callback Interface" expanded="false">Appendix C: Fragmented Table Hashing Callback Interface<ul>
<li><a href="Mnesia_App_C.html">
              Top of chapter
            </a></li>
<li title="mnesia_frag_hash Callback Behavior"><a href="Mnesia_App_C.html#id85192">mnesia_frag_hash Callback Behavior</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>7 Mnesia System Information</h1>
  

  <p>The following topics are included:</p>
  <ul>
    <li>Database configuration data</li>
    <li>Core dumps</li>
    <li>Dumping tables</li>
    <li>Checkpoints</li>
    <li>Startup files, log file, and data files</li>
    <li>Loading tables at startup</li>
    <li>Recovery from communication failure</li>
    <li>Recovery of transactions</li>
    <li>Backup, restore, fallback, and disaster recovery</li>
  </ul>

  <h3><a name="id82354">7.1 
        Database Configuration Data</a></h3>
    
    <p>The following two functions can be used to retrieve system
      information. For details, see the Reference Manual.</p>
    <ul>
      <li>
<span class="bold_code"><a href="../../man/mnesia.html#table_info-2">mnesia:table_info(Tab, Key)
       -&gt; Info | exit({aborted,Reason})</a></span>
       returns information about one table, for example,
       the current size of the table and on which nodes it resides.
      </li>
      <li>
<span class="bold_code"><a href="../../man/mnesia.html#system_info-1">mnesia:system_info(Key)
       -&gt; Info | exit({aborted, Reason})</a></span>
       returns information about the <span class="code">Mnesia</span> system,
       for example, transaction statistics, <span class="code">db_nodes</span>, and
       configuration parameters.
      </li>
    </ul>
  

  <h3><a name="id82399">7.2 
        Core Dumps</a></h3>
    
    <p>If <span class="code">Mnesia</span> malfunctions, system information is dumped to
      file <span class="code">MnesiaCore.Node.When</span>. The type of system
      information contained in this file can also be generated with
      the function <span class="code">mnesia_lib:coredump()</span>. If a <span class="code">Mnesia</span>
      system behaves strangely, it is recommended that a <span class="code">Mnesia</span>
      core dump file is included in the bug report.</p>
  

  <h3><a name="id82431">7.3 
        Dumping Tables</a></h3>
    
    <p>Tables of type <span class="code">ram_copies</span> are by definition stored in
      memory only. However, these tables can be dumped to
      disc, either at regular intervals or before the system is
      shut down. The function
      <span class="bold_code"><a href="../../man/mnesia.html#dump_tables-1">mnesia:dump_tables(TabList)</a></span>
      dumps all replicas of a set of RAM tables to disc. The tables can be
      accessed while being dumped to disc. To dump the tables to disc,
      all replicas must have the storage type <span class="code">ram_copies</span>.</p>
    <p>The table content is placed in a <span class="code">.DCD</span> file on the
      disc. When the <span class="code">Mnesia</span> system is started, the RAM table
      is initially loaded with data from its <span class="code">.DCD</span> file.</p>
  

  <h3><a name="id82479">7.4 
        Checkpoints</a></h3>
    <a name="checkpoints"></a>
    
    <p>A checkpoint is a transaction consistent state that spans over
      one or more tables. When a checkpoint is activated, the system
      remembers the current content of the set of tables. The
      checkpoint retains a transaction consistent state of the tables,
      allowing the tables to be read and updated while the checkpoint
      is active. A checkpoint is typically used to
      back up tables to external media, but they are also used
      internally in <span class="code">Mnesia</span> for other purposes. Each checkpoint
      is independent and a table can be involved in several checkpoints
      simultaneously.</p>
    <p>Each table retains its old contents in a checkpoint retainer.
      For performance critical applications, it can be important
      to realize the processing overhead associated with checkpoints.
      In a worst case scenario, the checkpoint retainer consumes
      more memory than the table itself. Also, each update becomes
      slightly slower on those nodes where checkpoint
      retainers are attached to the tables.</p>
    <p>For each table, it is possible to choose if there is to be one
      checkpoint retainer attached to all replicas of the table, or if
      it is enough to have only one checkpoint retainer attached to a
      single replica. With a single checkpoint retainer per table, the
      checkpoint consumes less memory, but it is vulnerable
      to node crashes. With several redundant checkpoint retainers, the
      checkpoint survives as long as there is at least one active
      checkpoint retainer attached to each table.</p>
    <p>Checkpoints can be explicitly deactivated with the function
      <span class="bold_code"><a href="../../man/mnesia.html#deactivate_checkpoint-1">mnesia:deactivate_checkpoint(Name)</a></span>,
      where <span class="code">Name</span> is
      the name of an active checkpoint. This function returns
      <span class="code">ok</span> if successful or <span class="code">{error, Reason}</span> if there is
      an error. All tables in a checkpoint must be attached to at
      least one checkpoint retainer. The checkpoint is automatically
      deactivated by <span class="code">Mnesia</span>, when any table lacks a checkpoint
      retainer. This can occur when a node goes down or when a
      replica is deleted. Use arguments <span class="code">min</span> and
      <span class="code">max</span> (described in the following list) to control the
      degree of checkpoint retainer redundancy.</p>
    <a name="mnesia:chkpt(Args)"></a>
    <p>Checkpoints are activated with the function
      <span class="bold_code"><a href="../../man/mnesia.html#activate_checkpoint-1">mnesia:activate_checkpoint(Args)</a></span>,
      where <span class="code">Args</span> is a list of the following tuples:</p>
    <ul>
      <li>
<span class="code">{name,Name}</span>, where <span class="code">Name</span> specifies a temporary
       name of the checkpoint. The name can be reused when the checkpoint
       has been deactivated. If no name is specified, a name is
       generated automatically.
      </li>
      <li>
<span class="code">{max,MaxTabs}</span>, where <span class="code">MaxTabs</span> is a list of
       tables that are to be included in the checkpoint. Default is
       <span class="code">[]</span> (empty list). For these tables, the redundancy
       is maximized. The old content of the table is
       retained in the checkpoint retainer when the main table is
       updated by the applications. The checkpoint is more fault
       tolerant if the tables have several replicas. When new
       replicas are added by the schema manipulation function
       <span class="bold_code"><a href="../../man/mnesia.html#add_table_copy-3">mnesia:add_table_copy/3</a></span>
       it also attaches a local checkpoint retainer.
      </li>
      <li>
<span class="code">{min,MinTabs}</span>, where <span class="code">MinTabs</span> is a list of
       tables that are to be included in the checkpoint. Default
       is <span class="code">[]</span>. For these tables, the redundancy is minimized,
       and there is to be single checkpoint retainer per table,
       preferably at the local node.
      </li>
      <li>
<span class="code">{allow_remote,Bool}</span>, where <span class="code">false</span> means that
       all checkpoint retainers must be local. If a table does not
       reside locally, the checkpoint cannot be activated. <span class="code">true</span>
       allows checkpoint retainers to be allocated on any node.
       Default is <span class="code">true</span>.
      </li>
      <li>
<span class="code">{ram_overrides_dump,Bool}</span>. This argument only
       applies to tables of type <span class="code">ram_copies</span>. <span class="code">Bool</span>
       specifies if the table state in RAM is to override the table
       state on disc. <span class="code">true</span> means that the latest committed
       records in RAM are included in the checkpoint retainer. These
       are the records that the application accesses. <span class="code">false</span>
       means that the records on the disc <span class="code">.DAT</span> file are
       included in the checkpoint retainer. These records are
       loaded on startup. Default is <span class="code">false</span>.</li>
    </ul>
    <p>The function
      <span class="bold_code"><a href="../../man/mnesia.html#activate_checkpoint-1">mnesia:activate_checkpoint(Args)</a></span>
      returns one of the following values:</p>
    <ul>
      <li><span class="code">{ok, Name, Nodes}</span></li>
      <li><span class="code">{error, Reason}</span></li>
    </ul>
    <p><span class="code">Name</span> is the checkpoint name. <span class="code">Nodes</span> are
      the nodes where the checkpoint is known.</p>
    <p>A list of active checkpoints can be obtained with the following
      functions:</p>
    <ul>
      <li>
<span class="bold_code"><a href="../../man/mnesia.html#system_info-1">mnesia:system_info(checkpoints)</a></span>
       returns all active checkpoints on the current node.</li>
      <li>
<span class="bold_code"><a href="../../man/mnesia.html#table_info-2">mnesia:table_info(Tab, checkpoints)</a></span>
       returns active checkpoints on a specific table.</li>
    </ul>
  

  <h3><a name="id82740">7.5 
        Startup Files, Log File, and Data Files</a></h3>
    
    <p>This section describes the internal files that are created
      and maintained by the <span class="code">Mnesia</span> system. In particular,
      the workings of the <span class="code">Mnesia</span> log are described.</p>

    <h4>Startup Files</h4>
      
    <p><span class="bold_code"><a href="Mnesia_chap3.html#start_mnesia">Start Mnesia</a></span>
    states the following prerequisites
    for starting <span class="code">Mnesia</span>:</p>
    <ul>
      <li>An Erlang session must be started and a <span class="code">Mnesia</span>
       directory must be specified for the database.
      </li>
      <li>A database schema must be initiated, using the function
       <span class="bold_code"><a href="../../man/mnesia.html#create_schema-1">mnesia:create_schema/1</a></span>.
      </li>
    </ul>
    <p>The following example shows how these tasks are performed:</p>
    <p><strong>Step 1:</strong> Start an Erlang session and specify a
      <span class="code">Mnesia</span> directory for the database:</p>
    <div class="example"><pre>
% <span class="bold_code">erl -sname klacke -mnesia dir '"/ldisc/scratch/klacke"'</span></pre></div>
    <div class="example"><pre>
Erlang (BEAM) emulator version 4.9
 
Eshell V4.9  (abort with ^G)
(klacke@gin)1&gt; <span class="bold_code">mnesia:create_schema([node()]).</span>
ok
(klacke@gin)2&gt; 
<span class="bold_code">^Z</span>
Suspended</pre></div>
    <p><strong>Step 2:</strong> You can inspect the <span class="code">Mnesia</span> directory
      to see what files have been created:</p>
    <div class="example"><pre>
% <span class="bold_code">ls -l /ldisc/scratch/klacke</span>
-rw-rw-r--   1 klacke   staff       247 Aug 12 15:06 FALLBACK.BUP</pre></div>
    <p>The response shows that the file <span class="code">FALLBACK.BUP</span> has
      been created. This is called a backup file, and it contains
      an initial schema. If more than one node in the function
      <span class="bold_code"><a href="../../man/mnesia.html#create_schema-1">mnesia:create_schema/1</a></span>
      had been specified, identical
      backup files would have been created on all nodes.</p>
    <p><strong>Step 3:</strong> Start <span class="code">Mnesia</span>:</p>
    <div class="example"><pre>
(klacke@gin)3&gt;<span class="bold_code">mnesia:start( ).</span>
ok</pre></div>
    <p><strong>Step 4:</strong> You can see the following listing in
      the <span class="code">Mnesia</span> directory:</p>
    <div class="example"><pre>
-rw-rw-r--   1 klacke   staff         86 May 26 19:03 LATEST.LOG
-rw-rw-r--   1 klacke   staff      34507 May 26 19:03 schema.DAT</pre></div>
    <p>The schema in the backup file <span class="code">FALLBACK.BUP</span> has been
      used to generate the file <span class="code">schema.DAT</span>. Since there are
      no other disc resident tables than the schema, no other data
      files were created. The file <span class="code">FALLBACK.BUP</span> was removed
      after the successful "restoration". You also see some files
      that are for internal use by <span class="code">Mnesia</span>.</p>
    <p><strong>Step 5:</strong> Create a table:</p>
    <div class="example"><pre>
(klacke@gin)4&gt; <span class="bold_code">mnesia:create_table(foo,[{disc_copies, [node()]}]).</span>
{atomic,ok}</pre></div>
    <p><strong>Step 6:</strong> You can see the following listing in
      the <span class="code">Mnesia</span> directory:</p>
    <div class="example"><pre>
% <span class="bold_code">ls -l /ldisc/scratch/klacke</span>
-rw-rw-r-- 1 klacke staff    86 May 26 19:07 LATEST.LOG
-rw-rw-r-- 1 klacke staff    94 May 26 19:07 foo.DCD
-rw-rw-r-- 1 klacke staff  6679 May 26 19:07 schema.DAT</pre></div>
    <p>The file <span class="code">foo.DCD</span> has been created. This file will
      eventually store all data that is written into the
      <span class="code">foo</span> table.</p>
    

    <h4>Log File</h4>
      
      <p>When starting <span class="code">Mnesia</span>, a <span class="code">.LOG</span> file called
        <span class="code">LATEST.LOG</span> is created
        and placed in the database directory. This file is used by
        <span class="code">Mnesia</span> to log disc-based transactions. This includes all
        transactions that write at least one record in a table that is
        of storage type <span class="code">disc_copies</span> or <span class="code">disc_only_copies</span>.
        The file also includes all operations that
        manipulate the schema itself, such as creating new tables.
        The log format can vary with different implementations of
        <span class="code">Mnesia</span>. The <span class="code">Mnesia</span> log is currently implemented
        in the standard library module
        <span class="bold_code"><a href="../../man/disk_log.html">disk_log</a></span> in
        <span class="code">Kernel</span>.</p>
      <p>The log file grows continuously and must be dumped at
        regular intervals. "Dumping the log file" means that <span class="code">Mnesia</span>
        performs all the operations listed in the log and place the
        records in the corresponding <span class="code">.DAT</span>, <span class="code">.DCD</span>, and
        <span class="code">.DCL</span> data files. For example, if the operation "write
        record <span class="code">{foo, 4, elvis,  6}</span>" is listed in the log,
        <span class="code">Mnesia</span> inserts the operation into the file
        <span class="code">foo.DCL</span>. Later, when <span class="code">Mnesia</span> thinks that the
        <span class="code">.DCL</span> file is too large, the data is moved to the
        <span class="code">.DCD</span> file. The dumping operation can be time consuming
        if the log is large. Notice that the <span class="code">Mnesia</span> system
        continues to operate during log dumps.</p>
      <p>By default <span class="code">Mnesia</span> either dumps the log whenever
        100 records have
        been written in the log or when three minutes have passed.
        This is controlled by the two application parameters
        <span class="code">-mnesia dump_log_write_threshold WriteOperations</span> and
        <span class="code">-mnesia dump_log_time_threshold MilliSecs</span>.</p>
      <p>Before the log is dumped, the file <span class="code">LATEST.LOG</span> is
        renamed to <span class="code">PREVIOUS.LOG</span>, and a new <span class="code">LATEST.LOG</span> file
        is created. Once the log has been successfully dumped, the file
        <span class="code">PREVIOUS.LOG</span> is deleted.</p>
      <p>The log is also dumped at startup and whenever a schema
        operation is performed.</p>
    

    <h4>Data Files</h4>
      
      <p>The directory listing also contains one <span class="code">.DAT</span> file,
        which contains the schema itself, contained in the
        <span class="code">schema.DAT</span> file. The <span class="code">DAT</span> files are indexed
        files, and it is efficient to insert and search for records
        in these files with a specific key. The <span class="code">.DAT</span> files
        are used for the schema and for <span class="code">disc_only_copies</span>
        tables. The <span class="code">Mnesia</span> data files are currently implemented
        in the standard library module
        <span class="bold_code"><a href="../../man/dets.html">dets</a></span> in
        <span class="code">STDLIB</span>.</p>
      <p>All operations that can be performed on <span class="code">dets</span> files
        can also be performed on the <span class="code">Mnesia</span> data files. For
        example, <span class="code">dets</span> contains the function
        <span class="code">dets:traverse/2</span>, which can be used to view the
        contents of a <span class="code">Mnesia</span> <span class="code">DAT</span> file. However, this
        can only be done when <span class="code">Mnesia</span> is not running. So, to
        view the schema file, do as follows;</p>
      <div class="example"><pre>
{ok, N} = dets:open_file(schema, [{file, "./schema.DAT"},{repair,false}, 
{keypos, 2}]),
F = fun(X) -&gt; io:format("~p~n", [X]), continue end,
dets:traverse(N, F),
dets:close(N).</pre></div>
      <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
        <p>The <span class="code">DAT</span> files must always be opened with option
          <span class="code">{repair, false}</span>. This ensures that these files are not
          automatically repaired. Without this option, the database can
          become inconsistent, because <span class="code">Mnesia</span> can believe that
          the files were properly closed. For information about
          configuration parameter <span class="code">auto_repair</span>, see the
          Reference Manual.</p>
      </p></div>
</div>
      <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
        <p>It is recommended that the data files are not tampered
          with while <span class="code">Mnesia</span> is running. While not prohibited,
          the behavior of <span class="code">Mnesia</span> is unpredictable.</p>
      </p></div>
</div>
      <p>The <span class="code">disc_copies</span> tables are stored on disk with
        <span class="code">.DCL</span> and <span class="code">.DCD</span> files, which are standard
        <span class="code">disk_log</span> files.</p>
    
  

  <h3><a name="id83254">7.6 
        Loading Tables at Startup</a></h3>
    
    <p>At startup, <span class="code">Mnesia</span> loads tables to make them accessible
      for its applications. Sometimes <span class="code">Mnesia</span> decides to load
      all tables that reside locally, and sometimes the tables are
      not accessible until <span class="code">Mnesia</span> brings a copy of the table
      from another node.</p>
    <p>To understand the behavior of <span class="code">Mnesia</span> at startup, it is
      essential to understand how <span class="code">Mnesia</span> reacts when it loses
      contact with <span class="code">Mnesia</span> on another node. At this stage,
      <span class="code">Mnesia</span> cannot distinguish between a communication
      failure and a "normal" node-down. When this occurs,
      <span class="code">Mnesia</span> assumes that the other node is no longer running,
      whereas, in reality, the communication between the nodes has
      failed.</p>
    <p>To overcome this situation, try to restart the ongoing
      transactions that are accessing tables on the failing node,
      and write a <span class="code">mnesia_down</span> entry to a log file.</p>
    <p>At startup, notice that all tables residing on nodes
      without a <span class="code">mnesia_down</span> entry can have fresher replicas.
      Their replicas can have been updated after the termination of
      <span class="code">Mnesia</span> on the current node. To catch up with the latest
      updates, transfer a copy of the table from one of these other
      "fresh" nodes. If you are unlucky, other nodes can be down
      and you must wait for the table to be loaded on one of these
      nodes before receiving a fresh copy of the table.</p>
    <p>Before an application makes its first access to a table,
      <span class="bold_code"><a href="../../man/mnesia.html#wait_for_tables-2">mnesia:wait_for_tables(TabList, Timeout)</a></span>
      is to be executed
      to ensure that the table is accessible from the local node. If
      the function times out, the application can choose to force a
      load of the local replica with
      <span class="bold_code"><a href="../../man/mnesia.html#force_load_table-1">mnesia:force_load_table(Tab)</a></span>
      and deliberately lose all
      updates that can have been performed on the other nodes while
      the local node was down. If <span class="code">Mnesia</span>
      has loaded the table on another node already, or intends
      to do so, copy the table from that node to
      avoid unnecessary inconsistency.</p>
    <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
      <p>Only one table is loaded by
      <span class="bold_code"><a href="../../man/mnesia.html#force_load_table-1">mnesia:force_load_table(Tab)</a></span>.
        Since committed
        transactions can have caused updates in several tables, the
        tables can become inconsistent because of the forced load.</p>
    </p></div>
</div>
    <p>The allowed <span class="code">AccessMode</span> of a table can be defined to be
      <span class="code">read_only</span> or <span class="code">read_write</span>. It can be toggled with
      the function
      <span class="bold_code"><a href="../../man/mnesia.html#change_table_access_mode-2">
      mnesia:change_table_access_mode(Tab, AccessMode)</a></span>
      in runtime. <span class="code">read_only</span> tables and
      <span class="code">local_content</span> tables are always loaded locally, as
      there is no need for copying the table from other nodes. Other
      tables are primarily loaded remotely from active replicas on
      other nodes if the table has been loaded there already, or if
      the running <span class="code">Mnesia</span> has decided to load the table there
      already.</p>
    <p>At startup, <span class="code">Mnesia</span> assumes that its local replica is the
      most recent version and loads the table from disc if either of
      the following situations is detected:</p>
    <ul>
      <li>
<span class="code">mnesia_down</span> is returned from all other nodes that
       hold a disc resident replica of the table.</li>
      <li>All replicas are <span class="code">ram_copies</span>.</li>
    </ul>
    <p>This is normally a wise decision, but it can be disastrous
      if the nodes have been disconnected because of a communication
      failure, as the <span class="code">Mnesia</span> normal table load
      mechanism does not cope with communication failures.</p>
    <p>When <span class="code">Mnesia</span> loads many tables, the default load order
      is used. However, the load order
      can be affected, by explicitly changing property
      <span class="code">load_order</span> for the tables, with the function
      <span class="bold_code"><a href="../../man/mnesia.html#change_table_load_order-2">
      mnesia:change_table_load_order(Tab, LoadOrder)</a></span>.
      <span class="code">LoadOrder</span> is by default <span class="code">0</span> for all tables, but
      it can be set to any integer. The table with the highest
      <span class="code">load_order</span> is loaded first. Changing the load order is
      especially useful for applications that need to ensure early
      availability of fundamental tables. Large peripheral tables
      are to have a low load order value, perhaps less than <span class="code">0</span></p>
  

  <h3><a name="id83474">7.7 
        Recovery from Communication Failure</a></h3>
    
    <p>There are several occasions when <span class="code">Mnesia</span> can detect
      that the network has been partitioned because of a
      communication failure, for example:</p>
    <ul>
      <li>
<span class="code">Mnesia</span> is operational already and the Erlang nodes
       gain contact again. Then <span class="code">Mnesia</span> tries to contact
       <span class="code">Mnesia</span> on the other node to see if it also thinks that
       the network has been partitioned for a while. If <span class="code">Mnesia</span>
       on both nodes has logged <span class="code">mnesia_down</span> entries from each
       other, <span class="code">Mnesia</span> generates a system event, called
       <span class="code">{inconsistent_database, running_partitioned_network, Node}</span>,
       which is sent to the <span class="code">Mnesia</span> event handler and other
       possible subscribers. The default event
       handler reports an error to the error logger.
      </li>
      <li>If <span class="code">Mnesia</span> detects at startup that both the local
       node and another node received <span class="code">mnesia_down</span> from each
       other, <span class="code">Mnesia</span> generates an
       <span class="code">{inconsistent_database, starting_partitioned_network, Node}</span>
       system event and acts as described in the previous item.
      </li>
    </ul>
    <p>If the application detects that there has been a communication
      failure that can have caused an inconsistent database, it can
      use the function
      <span class="bold_code"><a href="../../man/mnesia.html#set_master_nodes-2">mnesia:set_master_nodes(Tab, Nodes)</a></span>
      to pinpoint from which nodes each table can be loaded.</p>
    <p>At startup, the <span class="code">Mnesia</span> normal table load algorithm is
      bypassed and the table is loaded from one of the master
      nodes defined for the table, regardless of potential
      <span class="code">mnesia_down</span> entries in the log. <span class="code">Nodes</span> can only
      contain nodes where the table has a replica. If <span class="code">Nodes</span>
      is empty, the master node recovery mechanism for the particular
      table is reset and the normal load mechanism is used at the
      next restart.</p>
    <p>The function
      <span class="bold_code"><a href="../../man/mnesia.html#set_master_nodes-1">mnesia:set_master_nodes(Nodes)</a></span>
      sets master
      nodes for all tables. For each table it determines its replica
      nodes and starts
      <span class="bold_code"><a href="../../man/mnesia.html#set_master_nodes-2">mnesia:set_master_nodes(Tab, TabNodes)</a></span>
      with those replica nodes that are included in the <span class="code">Nodes</span>
      list (that is, <span class="code">TabNodes</span> is the intersection of
      <span class="code">Nodes</span> and the replica nodes of the table). If the
      intersection is empty, the master node recovery mechanism for
      the particular table is reset and the normal load mechanism
      is used at the next restart.</p>
    <p>The functions
      <span class="bold_code"><a href="../../man/mnesia.html#system_info-1">mnesia:system_info(master_node_tables)</a></span>
      and
      <span class="bold_code"><a href="../../man/mnesia.html#table_info-2">mnesia:table_info(Tab, master_nodes)</a></span>
      can be used to
      obtain information about the potential master nodes.</p>
    <p>Determining what data to keep after a communication failure
      is outside the scope of <span class="code">Mnesia</span>. One approach is to
      determine which "island" contains most of the nodes. Using
      option <span class="code">{majority,true}</span> for critical tables can be a way
      to ensure that nodes that are not part of a "majority island"
      cannot update those tables. Notice that this constitutes a
      reduction in service on the minority nodes. This would be a
      tradeoff in favor of higher consistency guarantees.</p>
    <p>The function
      <span class="bold_code"><a href="../../man/mnesia.html#force_load_table-1">mnesia:force_load_table(Tab)</a></span>
      can be used to force load the table regardless of which table
      load mechanism that is activated.</p>
  

  <h3><a name="id83657">7.8 
        Recovery of Transactions</a></h3>
    
    <p>A <span class="code">Mnesia</span> table can reside on one or more nodes. When a
      table is updated, <span class="code">Mnesia</span> ensures that the updates are
      replicated to all nodes where the table resides. If a replica is
      inaccessible (for example, because of a temporary node-down),
      <span class="code">Mnesia</span> performs the replication later.</p>
    <p>On the node where the application is started, there is a
      transaction coordinator process. If the transaction is
      distributed, there is also a transaction participant process on
      all the other nodes where commit-work needs to be performed.</p>
    <p>Internally <span class="code">Mnesia</span> uses several commit protocols. The
      selected protocol depends on which table that has been updated
      in the transaction. If all the involved tables are symmetrically
      replicated (that is, they all have the same <span class="code">ram_nodes</span>,
      <span class="code">disc_nodes</span>, and <span class="code">disc_only_nodes</span> currently
      accessible from the coordinator node), a lightweight transaction
      commit protocol is used.</p>
    <p>The number of messages that the
      transaction coordinator and its participants need to exchange
      is few, as the <span class="code">Mnesia</span> table load mechanism takes care of
      the transaction recovery if the commit protocol gets
      interrupted. Since all involved tables are replicated
      symmetrically, the transaction is automatically recovered by
      loading the involved tables from the same node at startup of a
      failing node. It does not matter if the transaction was
      committed or terminated as long as the ACID properties can be
      ensured. The lightweight commit protocol is non-blocking,
      that is, the surviving participants and their coordinator
      finish the transaction, even if any node crashes in the
      middle of the commit protocol.</p>
    <p>If a node goes down in the middle of a dirty operation, the
      table load mechanism ensures that the update is
      performed on all replicas, or none. Both asynchronous dirty
      updates and synchronous dirty updates use the same recovery
      principle as lightweight transactions.</p>
    <p>If a transaction involves updates of asymmetrically replicated
      tables or updates of the schema table, a heavyweight commit
      protocol is used. This protocol can
      finish the transaction regardless of how the tables are
      replicated. The typical use of a heavyweight transaction is
      when a replica is to be moved from one node to another. Then
      ensure that the replica either is entirely moved or left as
      it was. Do never end up in a situation with replicas on both
      nodes, or on no node at all. Even if a node crashes in the middle
      of the commit protocol, the transaction must be guaranteed to be
      atomic. The heavyweight commit protocol involves more messages
      between the transaction coordinator and its participants than
      a lightweight protocol, and it performs recovery work at
      startup to finish the terminating or commit work.</p>
    <p>The heavyweight commit protocol is also non-blocking,
      which allows the surviving participants and their coordinator to
      finish the transaction regardless (even if a node crashes in the
      middle of the commit protocol). When a node fails at startup,
      <span class="code">Mnesia</span> determines the outcome of the transaction and
      recovers it. Lightweight protocols, heavyweight protocols, and
      dirty updates, are dependent on other nodes to be operational
      to make the correct heavyweight transaction recovery decision.</p>
    <p>If <span class="code">Mnesia</span> has not started on some of the nodes that
      are involved in the transaction <strong>and</strong> neither the
      local node nor any of the already running nodes know the
      outcome of the transaction, <span class="code">Mnesia</span> waits for one,
      by default. In the worst case scenario, all other involved
      nodes must start before <span class="code">Mnesia</span> can make the correct
      decision about the transaction and finish its startup.</p>
    <p>Thus, <span class="code">Mnesia</span> (on one node) can hang if a double fault
      occurs, that is, when two nodes crash simultaneously
      and one attempts to start when the other refuses to
      start, for example, because of a hardware error.</p>
    <p>The maximum time that <span class="code">Mnesia</span> waits for other nodes to
      respond with a transaction recovery decision can be specified.
      The configuration parameter <span class="code">max_wait_for_decision</span>
      defaults to <span class="code">infinity</span>, which can cause the indefinite
      hanging as mentioned earlier. However, if the parameter is
      set to a definite time period (for example, three minutes),
      <span class="code">Mnesia</span> then enforces a transaction recovery decision,
      if needed, to allow <span class="code">Mnesia</span> to continue with its startup
      procedure.</p>
    <p>The downside of an enforced transaction recovery decision is
      that the decision can be incorrect, because of insufficient
      information about the recovery decisions from the other nodes.
      This can result in an inconsistent database where <span class="code">Mnesia</span>
      has committed the transaction on some nodes but terminated it
      on others.</p>
    <p>In fortunate cases, the inconsistency is only visible in
      tables belonging to a specific application. However, if a
      schema transaction is inconsistently recovered because of
      the enforced transaction recovery decision, the
      effects of the inconsistency can be fatal.
      However, if the higher priority is availability rather than
      consistency, it can be worth the risk.</p>
    <p>If <span class="code">Mnesia</span> detects an inconsistent transaction decision,
      an <span class="code">{inconsistent_database, bad_decision, Node}</span> system event
      is generated to give the application a chance to install a
      fallback or other appropriate measures to resolve the
      inconsistency. The default behavior of the <span class="code">Mnesia</span>
      event handler is the same as if the database became
      inconsistent as a result of partitioned network (as
      described earlier).</p>
  

  <h3><a name="id83842">7.9 
        Backup, Restore, Fallback, and Disaster Recovery</a></h3>
    
    <p>The following functions are used to back up data, to install
      a backup as fallback, and for disaster recovery:</p>
    <ul>
      <li>
       <span class="bold_code"><a href="../../man/mnesia.html#backup_checkpoint-2">mnesia:backup_checkpoint(Name, Opaque, [Mod])</a></span>
       performs a backup of the tables included in the checkpoint.
      </li>
      <li>
       <span class="bold_code"><a href="../../man/mnesia.html#backup-1">mnesia:backup(Opaque, [Mod])</a></span>
       activates a new
       checkpoint that covers all <span class="code">Mnesia</span> tables and
       performs a backup. It is performed with maximum degree of
       redundancy (see also the function
       <span class="bold_code"><a href="#checkpoints">mnesia:activate_checkpoint(Args)</a></span>,
       <span class="code">{max, MaxTabs} and {min, MinTabs})</span>.
      </li>
      <li>
       <span class="bold_code"><a href="../../man/mnesia.html#traverse_backup-4">mnesia:traverse_backup(Source, [SourceMod,] Target, [TargetMod,] Fun, Acc)</a></span>
       can be used to read an existing backup, create a backup from an
       existing one, or to copy a backup from one type media to another.
      </li>
      <li>
       <span class="bold_code"><a href="../../man/mnesia.html#uninstall_fallback-0">mnesia:uninstall_fallback()</a></span>
       removes previously installed fallback files.
      </li>
      <li>
       <span class="bold_code"><a href="../../man/mnesia.html#restore-2">mnesia:restore(Opaque, Args)</a></span>
       restores a set of tables from a previous backup.
      </li>
      <li>
       <span class="bold_code"><a href="../../man/mnesia.html#install_fallback-1">mnesia:install_fallback(Opaque, [Mod])</a></span>
       can be configured to restart <span class="code">Mnesia</span> and the reload data
       tables, and possibly the schema tables, from an existing
       backup. This function is typically used for disaster recovery
       purposes, when data or schema tables are corrupted.
      </li>
    </ul>
    <p>These functions are explained in the following sections.
      See also <span class="bold_code"><a href="#checkpoints">Checkpoints</a></span>,
      which describes the two functions used
      to activate and deactivate checkpoints.</p>

    <h4>Backup</h4>
      
      <p>Backup operation are performed with the following functions:</p>
      <ul>
        <li>
         <span class="bold_code"><a href="../../man/mnesia.html#backup_checkpoint-2">mnesia:backup_checkpoint(Name, Opaque, [Mod])</a></span>
        </li>
        <li>
         <span class="bold_code"><a href="../../man/mnesia.html#backup-1">mnesia:backup(Opaque, [Mod])</a></span>
        </li>
        <li>
         <span class="bold_code"><a href="../../man/mnesia.html#traverse_backup-4">mnesia:traverse_backup(Source, [SourceMod,] Target, [TargetMod,] Fun, Acc)</a></span>
        </li>
      </ul>
      <p>By default, the actual access to the backup media is
        performed through module <span class="code">mnesia_backup</span> for both read
        and write. Currently <span class="code">mnesia_backup</span> is implemented with
        the standard library module <span class="code">disc_log</span>. However, you
        can write your own module with the same interface as
        <span class="code">mnesia_backup</span> and configure <span class="code">Mnesia</span> so that
        the alternative module performs the actual accesses to
        the backup media. The user can
        therefore put the backup on a media that <span class="code">Mnesia</span>
        does not know about, possibly on hosts where Erlang is not
        running. Use configuration parameter
        <span class="code">-mnesia backup_module &lt;module&gt;</span>
        for this purpose.</p>
      <p>The source for a backup is an activated checkpoint.
        The backup function
        <span class="bold_code"><a href="../../man/mnesia.html#backup_checkpoint-2">mnesia:backup_checkpoint(Name, Opaque,[Mod])</a></span>
        is most commonly used and returns <span class="code">ok</span> or
        <span class="code">{error,Reason}</span>. It has the following arguments:</p>
      <ul>
        <li>
<span class="code">Name</span> is the name of an activated checkpoint.
         For details on how to include table names in checkpoints,
         see the function <span class="code">mnesia:activate_checkpoint(ArgList)</span>
         in <span class="bold_code"><a href="#checkpoints">Checkpoints</a></span>.
        </li>
        <li>
<span class="code">Opaque</span>. <span class="code">Mnesia</span> does not interpret this
         argument, but it is forwarded to the backup module. The
         <span class="code">Mnesia</span> default backup module <span class="code">mnesia_backup</span>
         interprets this argument as a local filename.
        </li>
        <li>
<span class="code">Mod</span> is the name of an alternative backup module.
        </li>
      </ul>
      <p>The function
        <span class="bold_code"><a href="../../man/mnesia.html#backup-1">mnesia:backup(Opaque [,Mod])</a></span>
        activates a
        new checkpoint that covers all <span class="code">Mnesia</span> tables with
        maximum degree of redundancy and performs a backup. Maximum
        redundancy means that each table replica has a checkpoint
        retainer. Tables with property <span class="code">local_contents</span> are
        backed up as they look on the current node.</p>
      <p>You can iterate over a backup, either to transform it
        into a new backup, or only read it. The function
        <span class="bold_code"><a href="../../man/mnesia.html#traverse_backup-4">mnesia:traverse_backup(Source, [SourceMod,] Target, [TargetMod,] Fun, Acc)</a></span>,
        which normally returns <span class="code">{ok, LastAcc}</span>,
        is used for both of these purposes.</p>
      <p>Before the traversal starts, the source backup media is
        opened with <span class="code">SourceMod:open_read(Source)</span>, and the target
        backup media is opened with
        <span class="code">TargetMod:open_write(Target)</span>. The arguments are as
        follows:</p>
      <ul>
        <li>
<span class="code">SourceMod</span> and <span class="code">TargetMod</span> are module names.
        </li>
        <li>
<span class="code">Source</span> and <span class="code">Target</span> are opaque data used
         exclusively by the modules <span class="code">SourceMod</span> and
         <span class="code">TargetMod</span> for initializing the backup medias.
        </li>
        <li>
<span class="code">Acc</span> is an initial accumulator value.
        </li>
        <li>
<span class="code">Fun(BackupItems, Acc)</span> is applied to each item in
         the backup. The Fun must return a tuple
         <span class="code">{ValGoodBackupItems, NewAcc}</span>,
         where <span class="code">ValidBackupItems</span> is a list of valid
         backup items. <span class="code">NewAcc</span> is a new accumulator value.
         The <span class="code">ValidBackupItems</span> are written to the target backup
         with the function <span class="code">TargetMod:write/2</span>.
        </li>
        <li>
<span class="code">LastAcc</span> is the last accumulator value, that is,
         the last <span class="code">NewAcc</span> value that was returned by <span class="code">Fun</span>.
        </li>
      </ul>
      <p>Also, a read-only traversal of the source backup can be
        performed without updating a target backup. If
        <span class="code">TargetMod==read_only</span>, no target backup is accessed.</p>
      <p>By setting <span class="code">SourceMod</span> and <span class="code">TargetMod</span> to different
        modules, a backup can be copied from one backup
        media to another.</p>
      <p>Valid <span class="code">BackupItems</span> are the following tuples:</p>
      <ul>
        <li>
<span class="code">{schema, Tab}</span> specifies a table to be deleted.
        </li>
        <li>
<span class="code">{schema, Tab, CreateList}</span> specifies a table to be
         created. For more information about <span class="code">CreateList</span>, see
         <span class="bold_code"><a href="../../man/mnesia.html#create_table-2">mnesia:create_table/2</a></span>.
        </li>
        <li>
<span class="code">{Tab, Key}</span> specifies the full identity of a record
         to be deleted.
        </li>
        <li>
<span class="code">{Record}</span> specifies a record to be inserted. It
         can be a tuple with <span class="code">Tab</span> as first field. Notice that the
         record name is set to the table name regardless of what
         <span class="code">record_name</span> is set to.
        </li>
      </ul>
      <p>The backup data is divided into two sections. The first
        section contains information related to the schema. All
        schema-related items are tuples where the first field equals
        the atom schema. The second section is the record section.
        Schema records cannot be mixed with other records and all
        schema records must be located first in the backup.</p>
      <p>The schema itself is a table and is possibly included in
        the backup. Each node where the schema table resides is
        regarded as a <span class="code">db_node</span>.</p>
      <p>The following example shows how
        <span class="bold_code"><a href="../../man/mnesia.html#traverse_backup-4">mnesia:traverse_backup</a></span>
        can be used to rename a <span class="code">db_node</span> in a backup file:</p>
<div class="example"><pre>

change_node_name(Mod, From, To, Source, Target) -&gt;
    Switch =
        fun(Node) when Node == From -&gt; To;
           (Node) when Node == To -&gt; throw({error, already_exists});
           (Node) -&gt; Node
        end,
    Convert =
        fun({schema, db_nodes, Nodes}, Acc) -&gt;
                {[{schema, db_nodes, lists:map(Switch,Nodes)}], Acc};
           ({schema, version, Version}, Acc) -&gt;
                {[{schema, version, Version}], Acc};
           ({schema, cookie, Cookie}, Acc) -&gt;
                {[{schema, cookie, Cookie}], Acc};
           ({schema, Tab, CreateList}, Acc) -&gt;
                Keys = [ram_copies, disc_copies, disc_only_copies],
                OptSwitch =
                    fun({Key, Val}) -&gt;
                            case lists:member(Key, Keys) of
                                true -&gt; {Key, lists:map(Switch, Val)};
                                false-&gt; {Key, Val}
                            end
                    end,
                {[{schema, Tab, lists:map(OptSwitch, CreateList)}], Acc};
           (Other, Acc) -&gt;
                {[Other], Acc}
        end,
    mnesia:traverse_backup(Source, Mod, Target, Mod, Convert, switched).

view(Source, Mod) -&gt;
    View = fun(Item, Acc) -&gt;
                   io:format("~p.~n",[Item]),
                   {[Item], Acc + 1}
           end,
    mnesia:traverse_backup(Source, Mod, dummy, read_only, View, 0).</pre></div>    

    <h4>Restore</h4>
      
      <p>Tables can be restored online from a backup without
        restarting <span class="code">Mnesia</span>. A restore is performed with the
        function
        <span class="bold_code"><a href="../../man/mnesia.html#restore-2">mnesia:restore(Opaque, Args)</a></span>,
        where <span class="code">Args</span> can contain the following tuples:</p>
      <ul>
        <li>
<span class="code">{module,Mod}</span>. The backup module <span class="code">Mod</span> is
         used to access the backup media. If omitted, the default
         backup module is used.
        </li>
        <li>
<span class="code">{skip_tables, TableList}</span>, where <span class="code">TableList</span>
         is a list of tables, which is not to be read from the backup.
        </li>
        <li>
<span class="code">{clear_tables, TableList}</span>, where <span class="code">TableList</span>
         is a list of tables, which is to be cleared before the
         records from the backup are inserted. That is, all records in
         the tables are deleted before the tables are restored.
         Schema information about the tables is not cleared or read
         from the backup.
        </li>
        <li>
<span class="code">{keep_tables, TableList}</span>, where <span class="code">TableList</span>
         is a list of tables, which is not to be cleared before
         the records from the backup are inserted. That is, the records
         in the backup are added to the records in the table.
         Schema information about the tables is not cleared or read
         from the backup.
        </li>
        <li>
<span class="code">{recreate_tables, TableList}</span>, where <span class="code">TableList</span>
         is a list of tables, which is to be recreated before the
         records from the backup are inserted. The tables are first
         deleted and then created with the schema information from the
         backup. All the nodes in the backup need to be operational.
        </li>
        <li>
<span class="code">{default_op, Operation}</span>, where <span class="code">Operation</span> is
         one of the operations <span class="code">skip_tables</span>,
         <span class="code">clear_tables</span>, <span class="code">keep_tables</span>, or
         <span class="code">recreate_tables</span>. The default operation specifies
         which operation is to be used on tables from the backup
         that are not specified in any of the previous lists.
         If omitted, the operation <span class="code">clear_tables</span> is used.
        </li>
      </ul>
      <p>The argument <span class="code">Opaque</span> is forwarded to the backup module.
        It returns <span class="code">{atomic, TabList}</span> if successful, or the
        tuple <span class="code">{aborted, Reason}</span> if there is an error.
        <span class="code">TabList</span> is a list of the restored tables. Tables that
        are restored are write-locked during the restore
        operation. However, regardless of any lock conflict caused by
        this, applications can continue to do their work during the
        restore operation.</p>
      <p>The restoration is performed as a single transaction. If the
        database is large, it cannot always be restored
        online. The old database must then be restored by
        installing a fallback, followed by a restart.</p>
    

    <h4>Fallback</h4>
      
      <p>The function
        <span class="bold_code"><a href="../../man/mnesia.html#install_fallback-2">mnesia:install_fallback(Opaque, [Mod])</a></span>
        installs a backup as fallback. It uses the backup module
        <span class="code">Mod</span>, or the default backup module, to access the backup
        media. The function returns <span class="code">ok</span> if successful, or
        <span class="code">{error, Reason}</span> if there is an error.</p>
      <p>Installing a fallback is a distributed operation, which is
        <strong>only</strong> performed on all <span class="code">db_nodes</span>. The fallback
        restores the database the next time the system is started.
        If a <span class="code">Mnesia</span> node with a fallback installed detects that
        <span class="code">Mnesia</span> on another node has died, it
        unconditionally terminates itself.</p>
      <p>A fallback is typically used when a system upgrade is
        performed. A system typically involves the installation of new
        software versions, and <span class="code">Mnesia</span> tables are often transformed
        into new layouts. If the system crashes during an upgrade, it is
        highly probable that reinstallation of the old applications is
        required, and restoration of the database to its previous state.
        This can be done if a backup is performed and
        installed as a fallback before the system upgrade begins.</p>
      <p>If the system upgrade fails, <span class="code">Mnesia</span> must be restarted
        on all <span class="code">db_nodes</span> to restore the old database. The
        fallback is automatically deinstalled after a successful
        startup. The function
        <span class="bold_code"><a href="../../man/mnesia.html#uninstall_fallback-0">mnesia:uninstall_fallback()</a></span>
        can also be used to deinstall the fallback after a
        successful system upgrade. Again, this is a distributed
        operation that is either performed on all <span class="code">db_nodes</span> or
        none. Both the installation and deinstallation of fallbacks
        require Erlang to be operational on all <span class="code">db_nodes</span>, but
        it does not matter if <span class="code">Mnesia</span> is running or not.</p>
    

    <h4>Disaster Recovery</h4>
      
      <p>The system can become inconsistent as a result of a power
        failure. The UNIX feature <span class="code">fsck</span> can possibly repair the
        file system, but there is no guarantee that the file content
        is consistent.</p>
      <p>If <span class="code">Mnesia</span> detects that a file has not been properly
        closed, possibly as a result of a power failure, it tries to
        repair the bad file in a similar manner. Data can be lost, but
        <span class="code">Mnesia</span> can be restarted even if the data is inconsistent.
        Configuration parameter
        <span class="code">-mnesia auto_repair &lt;bool&gt;</span> can be used
        to control the behavior of <span class="code">Mnesia</span> at startup. If
        <span class="code">&lt;bool&gt;</span> has the value <span class="code">true</span>,
        <span class="code">Mnesia</span> tries to repair the file. If
        <span class="code">&lt;bool&gt;</span> has the value <span class="code">false</span>,
        <span class="code">Mnesia</span> does not restart if it detects a suspect file.
        This configuration parameter affects the repair behavior of log
        files, <span class="code">DAT</span> files, and the default backup media.</p>
      <p>Configuration parameter
        <span class="code">-mnesia dump_log_update_in_place &lt;bool&gt;</span>
        controls the safety level of the function
        <span class="bold_code"><a href="../../man/mnesia.html#dump_log-0">mnesia:dump_log()</a></span>
        By default, <span class="code">Mnesia</span> dumps the
        transaction log directly into the <span class="code">DAT</span> files. If a power
        failure occurs during the dump, this can cause the randomly
        accessed <span class="code">DAT</span> files to become corrupt. If the parameter
        is set to <span class="code">false</span>, <span class="code">Mnesia</span> copies the <span class="code">DAT</span>
        files and target the dump
        to the new temporary files. If the dump is successful, the
        temporary files are renamed to their normal <span class="code">DAT</span>
        suffixes. The possibility for unrecoverable inconsistencies in
        the data files becomes much smaller with this strategy.
        However, the actual dumping of the transaction log becomes
        considerably slower. The system designer must decide whether
        speed or safety is the higher priority.</p>
      <p>Replicas of type <span class="code">disc_only_copies</span> are only
        affected by this parameter during the initial dump of the log
        file at startup. When designing applications with
        <strong>very</strong> high requirements, it can be appropriate not to
        use <span class="code">disc_only_copies</span> tables at all. The reason for this
        is the random access nature of normal operating system files. If
        a node goes down for a reason such as a power
        failure, these files can be corrupted because they are not
        properly closed. The <span class="code">DAT</span> files for <span class="code">disc_only_copies</span>
        are updated on a per transaction basis.</p>
      <p>If a disaster occurs and the <span class="code">Mnesia</span> database is
        corrupted, it can be reconstructed from a backup. Regard
        this as a last resort, as the backup contains old data. The
        data is hopefully consistent, but data is definitely lost
        when an old backup is used to restore the database.</p>
    
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
