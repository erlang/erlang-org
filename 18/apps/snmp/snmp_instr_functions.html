<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Instrumentation Functions</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="index.html">Reference Manual</a><br><a href="release_notes.html">Release Notes</a><br><a href="snmp.pdf">PDF</a><br><a href="../../index.html">Top</a></small><p><strong>Simple Network Management Protocol (SNMP)</strong><br><strong>User's Guide</strong><br><small>Version 5.2.2</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="SNMP Introduction" expanded="false">SNMP Introduction<ul>
<li><a href="snmp_intro.html">
              Top of chapter
            </a></li>
<li title="Scope and Purpose"><a href="snmp_intro.html#id72703">Scope and Purpose</a></li>
<li title="Prerequisites"><a href="snmp_intro.html#id70413">Prerequisites</a></li>
<li title="Definitions"><a href="snmp_intro.html#id63365">Definitions</a></li>
<li title="About This Manual"><a href="snmp_intro.html#id66911">About This Manual</a></li>
<li title="Where to Find More Information"><a href="snmp_intro.html#id61470">Where to Find More Information</a></li>
</ul>
</li>
<li id="no" title="Agent Functional Description" expanded="false">Agent Functional Description<ul>
<li><a href="snmp_agent_funct_descr.html">
              Top of chapter
            </a></li>
<li title="Features"><a href="snmp_agent_funct_descr.html#id65275">Features</a></li>
<li title="SNMPv1, SNMPv2 and SNMPv3"><a href="snmp_agent_funct_descr.html#id62288">SNMPv1, SNMPv2 and SNMPv3</a></li>
<li title="Operation"><a href="snmp_agent_funct_descr.html#id71348">Operation</a></li>
<li title="Sub-agents and MIB Loading"><a href="snmp_agent_funct_descr.html#id74823">Sub-agents and MIB Loading</a></li>
<li title="Contexts and Communities"><a href="snmp_agent_funct_descr.html#id74903">Contexts and Communities</a></li>
<li title="Management of the Agent"><a href="snmp_agent_funct_descr.html#id75089">Management of the Agent</a></li>
<li title="Notifications"><a href="snmp_agent_funct_descr.html#id76350">Notifications</a></li>
<li title="Discovery"><a href="snmp_agent_funct_descr.html#id76696">Discovery</a></li>
</ul>
</li>
<li id="no" title="Manager Functional Description" expanded="false">Manager Functional Description<ul>
<li><a href="snmp_manager_funct_descr.html">
              Top of chapter
            </a></li>
<li title="Features"><a href="snmp_manager_funct_descr.html#id76840">Features</a></li>
<li title="Operation"><a href="snmp_manager_funct_descr.html#id76990">Operation</a></li>
<li title="MIB loading"><a href="snmp_manager_funct_descr.html#id77058">MIB loading</a></li>
</ul>
</li>
<li id="no" title="The MIB Compiler" expanded="false">The MIB Compiler<ul>
<li><a href="snmp_mib_compiler.html">
              Top of chapter
            </a></li>
<li title="Operation"><a href="snmp_mib_compiler.html#id77178">Operation</a></li>
<li title="Importing MIBs"><a href="snmp_mib_compiler.html#id77241">Importing MIBs</a></li>
<li title="MIB Consistency Checking"><a href="snmp_mib_compiler.html#id77312">MIB Consistency Checking</a></li>
<li title=".hrl File Generation"><a href="snmp_mib_compiler.html#id77349">.hrl File Generation</a></li>
<li title="Emacs Integration"><a href="snmp_mib_compiler.html#id77399">Emacs Integration</a></li>
<li title="Compiling from a Shell or a Makefile"><a href="snmp_mib_compiler.html#id77445">Compiling from a Shell or a Makefile</a></li>
<li title="Deviations from the Standard"><a href="snmp_mib_compiler.html#id77499">Deviations from the Standard</a></li>
</ul>
</li>
<li id="no" title="Running the application" expanded="false">Running the application<ul>
<li><a href="snmp_config.html">
              Top of chapter
            </a></li>
<li title="Configuring the application"><a href="snmp_config.html#id77756">Configuring the application</a></li>
<li title="Modifying the Configuration Files"><a href="snmp_config.html#id80541">Modifying the Configuration Files</a></li>
<li title="Starting the application"><a href="snmp_config.html#id80631">Starting the application</a></li>
<li title="Debugging the application"><a href="snmp_config.html#id80681">Debugging the application</a></li>
</ul>
</li>
<li id="no" title="Definition of Agent Configuration Files" expanded="false">Definition of Agent Configuration Files<ul>
<li><a href="snmp_agent_config_files.html">
              Top of chapter
            </a></li>
<li title="Agent Information"><a href="snmp_agent_config_files.html#id81171">Agent Information</a></li>
<li title="Contexts"><a href="snmp_agent_config_files.html#id81335">Contexts</a></li>
<li title="System Information"><a href="snmp_agent_config_files.html#id81392">System Information</a></li>
<li title="Communities"><a href="snmp_agent_config_files.html#id81467">Communities</a></li>
<li title="MIB Views for VACM"><a href="snmp_agent_config_files.html#id81570">MIB Views for VACM</a></li>
<li title="Security data for USM"><a href="snmp_agent_config_files.html#id81808">Security data for USM</a></li>
<li title="Notify Definitions"><a href="snmp_agent_config_files.html#id82023">Notify Definitions</a></li>
<li title="Target Address Definitions"><a href="snmp_agent_config_files.html#id82103">Target Address Definitions</a></li>
<li title="Target Parameters Definitions"><a href="snmp_agent_config_files.html#id82344">Target Parameters Definitions</a></li>
</ul>
</li>
<li id="no" title="Definition of Manager Configuration Files" expanded="false">Definition of Manager Configuration Files<ul>
<li><a href="snmp_manager_config_files.html">
              Top of chapter
            </a></li>
<li title="Manager Information"><a href="snmp_manager_config_files.html#id82573">Manager Information</a></li>
<li title="Users"><a href="snmp_manager_config_files.html#id82833">Users</a></li>
<li title="Agents"><a href="snmp_manager_config_files.html#id82934">Agents</a></li>
<li title="Security data for USM"><a href="snmp_manager_config_files.html#id83163">Security data for USM</a></li>
</ul>
</li>
<li id="no" title="Agent Implementation Example" expanded="false">Agent Implementation Example<ul>
<li><a href="snmp_impl_example_agent.html">
              Top of chapter
            </a></li>
<li title="MIB"><a href="snmp_impl_example_agent.html#id83411">MIB</a></li>
<li title="Default Implementation"><a href="snmp_impl_example_agent.html#id83451">Default Implementation</a></li>
<li title="Manual Implementation"><a href="snmp_impl_example_agent.html#id83531">Manual Implementation</a></li>
</ul>
</li>
<li id="no" title="Manager Implementation Example" expanded="false">Manager Implementation Example<ul>
<li><a href="snmp_impl_example_manager.html">
              Top of chapter
            </a></li>
<li title="The example manager"><a href="snmp_impl_example_manager.html#id83861">The example manager</a></li>
<li title="A simple standard test"><a href="snmp_impl_example_manager.html#id83951">A simple standard test</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Instrumentation Functions" expanded="true">Instrumentation Functions<ul>
<li><a href="snmp_instr_functions.html">
              Top of chapter
            </a></li>
<li title="Instrumentation Functions"><a href="snmp_instr_functions.html#id84091">Instrumentation Functions</a></li>
<li title="Using the ExtraArgument"><a href="snmp_instr_functions.html#id84706">Using the ExtraArgument</a></li>
<li title="Default Instrumentation"><a href="snmp_instr_functions.html#id84814">Default Instrumentation</a></li>
<li title="Atomic Set"><a href="snmp_instr_functions.html#id84919">Atomic Set</a></li>
</ul>
</li>
<li id="no" title="Definition of Instrumentation Functions" expanded="false">Definition of Instrumentation Functions<ul>
<li><a href="snmp_def_instr_functions.html">
              Top of chapter
            </a></li>
<li title="Variable Instrumentation"><a href="snmp_def_instr_functions.html#id85092">Variable Instrumentation</a></li>
<li title="Table Instrumentation"><a href="snmp_def_instr_functions.html#id85467">Table Instrumentation</a></li>
</ul>
</li>
<li id="no" title="Definition of Agent Net if" expanded="false">Definition of Agent Net if<ul>
<li><a href="snmp_agent_netif.html">
              Top of chapter
            </a></li>
<li title="Mandatory Functions"><a href="snmp_agent_netif.html#id86376">Mandatory Functions</a></li>
<li title="Messages"><a href="snmp_agent_netif.html#id86398">Messages</a></li>
</ul>
</li>
<li id="no" title="Definition of Manager Net if" expanded="false">Definition of Manager Net if<ul>
<li><a href="snmp_manager_netif.html">
              Top of chapter
            </a></li>
<li title="Mandatory Functions"><a href="snmp_manager_netif.html#id87236">Mandatory Functions</a></li>
<li title="Messages"><a href="snmp_manager_netif.html#id87253">Messages</a></li>
</ul>
</li>
<li id="no" title="Audit Trail Log" expanded="false">Audit Trail Log<ul>
<li><a href="snmp_audit_trail_log.html">
              Top of chapter
            </a></li>
<li title="Agent Logging"><a href="snmp_audit_trail_log.html#id87689">Agent Logging</a></li>
<li title="Manager Logging"><a href="snmp_audit_trail_log.html#id87732">Manager Logging</a></li>
</ul>
</li>
<li id="no" title="Advanced Agent Topics" expanded="false">Advanced Agent Topics<ul>
<li><a href="snmp_advanced_agent.html">
              Top of chapter
            </a></li>
<li title="When to use a Sub-agent"><a href="snmp_advanced_agent.html#id87878">When to use a Sub-agent</a></li>
<li title="Agent Semantics"><a href="snmp_advanced_agent.html#id87988">Agent Semantics</a></li>
<li title="Sub-agents and Dependencies "><a href="snmp_advanced_agent.html#id88053">Sub-agents and Dependencies </a></li>
<li title="Distributed Tables"><a href="snmp_advanced_agent.html#id88070">Distributed Tables</a></li>
<li title="Fault Tolerance"><a href="snmp_advanced_agent.html#id88127">Fault Tolerance</a></li>
<li title="Using Mnesia Tables as SNMP Tables"><a href="snmp_advanced_agent.html#id88200">Using Mnesia Tables as SNMP Tables</a></li>
<li title="Deviations from the Standard"><a href="snmp_advanced_agent.html#id88478">Deviations from the Standard</a></li>
</ul>
</li>
<li id="no" title="SNMP Appendix A" expanded="false">SNMP Appendix A<ul>
<li><a href="snmp_app_a.html">
              Top of chapter
            </a></li>
<li title="Appendix A"><a href="snmp_app_a.html#id88624">Appendix A</a></li>
</ul>
</li>
<li id="no" title="SNMP Appendix B" expanded="false">SNMP Appendix B<ul>
<li><a href="snmp_app_b.html">
              Top of chapter
            </a></li>
<li title="Appendix B"><a href="snmp_app_b.html#id89012">Appendix B</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>10 Instrumentation Functions</h1>
  
  <p>A user-defined instrumentation function for each object attaches
    the managed objects to real resources. This function is called by
    the agent on a <span class="code">get</span> or <span class="code">set</span> operation. The function
    could read some hardware register, perform a calculation, or
    whatever is necessary to implement the semantics associated with the
    conceptual variable. These functions must be written both for scalar
    variables and for tables. They are specified in the association
    file, which is a text file. In this file, the <span class="code">OBJECT IDENTIFIER</span>, or symbolic name for each managed object, is
    associated with an Erlang tuple <span class="code">{Module,</span><span class="code">Function</span>,
    <span class="code">ListOfExtraArguments}</span>.
    </p>
  <p>When a managed object is referenced in an SNMP operation, the
    associated <span class="code">{Module, Function, ListOfExtraArguments}</span> is
    called. The function is applied to some standard arguments (for
    example, the operation type) and the extra arguments supplied by the
    user.
    </p>
  <p>Instrumentation functions must be written for <span class="code">get</span> and
    <span class="code">set</span> for scalar variables and tables, and for <span class="code">get-next</span>
    for tables only.  The <span class="code">get-bulk</span> operation is translated into a
    series of calls to <span class="code">get-next</span>.
    </p>

  <h3><a name="id84091">10.1 
        Instrumentation Functions</a></h3>
    
    <p>The following sections describe how the instrumentation
      functions should be defined in Erlang for the different
      operations. In the following, <span class="code">RowIndex</span> is a list of key
      values for the table, and <span class="code">Column</span> is a column number.
      </p>
    <p>These functions are described in detail in 
      <span class="bold_code"><a href="snmp_def_instr_functions.html">Definition of Instrumentation Functions</a></span>.
      </p>

    <h4>New / Delete Operations</h4>
      
      <p>For scalar variables:
        </p>
      <div class="example"><pre>
variable_access(new [, ExtraArg1, ...])
variable_access(delete [, ExtraArg1, ...])
      </pre></div>
      <p>For tables:
        </p>
      <div class="example"><pre>
table_access(new [, ExtraArg1, ...])
table_access(delete [, ExtraArg1, ...])
      </pre></div>
      <p>These functions are called for each object in an MIB when the
        MIB is unloaded or loaded, respectively.</p>
    

    <h4>Get Operation</h4>
      
      <p>For scalar variables:
        </p>
      <div class="example"><pre>
variable_access(get [, ExtraArg1, ...])
      </pre></div>
      <p>For tables:
        </p>
      <div class="example"><pre>
table_access(get,RowIndex,Cols [,ExtraArg1, ...])
      </pre></div>
      <p><span class="code">Cols</span> is a list of <span class="code">Column</span>. The agent will sort
        incoming variables so that all operations on one row (same
        index) will be supplied at the same time. The reason for this is
        that a database normally retrieves information row by row.
        </p>
      <p>These functions must return the current values of the
        associated variables.</p>
    

    <h4>Set Operation</h4>
      
      <p>For scalar variables:
        </p>
      <div class="example"><pre>
variable_access(set, NewValue [, ExtraArg1, ...])
      </pre></div>
      <p>For tables:
        </p>
      <div class="example"><pre>
table_access(set, RowIndex, Cols [, ExtraArg1,..])
      </pre></div>
      <p><span class="code">Cols</span> is a list of tuples <span class="code">{Column, NewValue}</span>.
        </p>
      <p>These functions returns <span class="code">noError</span> if the assignment was
        successful, otherwise an error code.</p>
    

    <h4>Is-set-ok Operation</h4>
      
      <p>As a complement to the <span class="code">set</span> operation, it is possible
        to specify a test function. This function has the same syntax as
        the set operation above, except that the first argument is
        <span class="code">is_set_ok</span> instead of <span class="code">set</span>. This function is called
        before the variable is set. Its purpose is to ensure that it is
        permissible to set the variable to the new value.</p>
      <div class="example"><pre>
variable_access(is_set_ok, NewValue [, ExtraArg1, ...])
      </pre></div>
      <p>For tables:
        </p>
      <div class="example"><pre>
table_access(set, RowIndex, Cols [, ExtraArg1,..])
      </pre></div>
      <p><span class="code">Cols</span> is a list of tuples <span class="code">{Column, NewValue}</span>.
        </p>
    

    <h4>Undo Operation</h4>
      
      <p>A function which has been called with <span class="code">is_set_ok</span> will
        be called again, either with <span class="code">set</span> if there was no error,
        or with <span class="code">undo</span>, if an error occurred. In this way,
        resources can be reserved in the <span class="code">is_set_ok</span> operation,
        released in the <span class="code">undo</span> operation, or made permanent in the
        <span class="code">set</span> operation.</p>
      <div class="example"><pre>
variable_access(undo, NewValue [, ExtraArg1, ...])
      </pre></div>
      <p>For tables:
        </p>
      <div class="example"><pre>
table_access(set, RowIndex, Cols [, ExtraArg1,..])
      </pre></div>
      <p><span class="code">Cols</span> is a list of tuples <span class="code">{Column, NewValue}</span>.
        </p>
    

    <h4>GetNext Operation</h4>
      
      <p>The GetNext Operation operation should only be defined for 
        tables since the
        agent can find the next instance of plain variables in the MIB
        and call the instrumentation with the <span class="code">get</span> operation.
        </p>
      <div class="example"><pre>
table_access(get_next, RowIndex, Cols [, ExtraArg1, ...])
      </pre></div>
      <p><span class="code">Cols</span> is a list of integers, all greater than or equal
        to zero. This indicates that the instrumentation should find the
        next accessible instance. This function returns the tuple
        <span class="code">{NextOid, NextValue}</span>, or
        <span class="code">endOfTable</span>. <span class="code">NextOid</span> should be the
        lexicographically next accessible instance of a managed object
        in the table. It should be a list of integers, where the first
        integer is the column, and the rest of the list is the indices
        for the next row. If <span class="code">endOfTable</span> is returned, the agent
        continues to search for the next instance among the other
        variables and tables.
        </p>
      <p><span class="code">RowIndex</span> may be an empty list, an incompletely
        specified row index, or the index for an unspecified row.
        </p>
      <p>This operation is best described with an example.
        </p>

      <h4>GetNext Example</h4>
        
        <p>A table called <span class="code">myTable</span> has five columns. The first
          two are keys (not accessible), and the table has three
          rows. The instrumentation function for this table is called
          <span class="code">my_table</span>.</p>
        <a name="getnext1"></a>
        <img alt="IMAGE MISSING" src="getnext1.gif"><br>
          <em>Figure
        10.1:
         
        Contents of my_table</em>
        
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>N/A means not accessible.</p>
        </p></div>
</div>
        <p>The manager issues the following <span class="code">getNext</span> request:
          </p>
        <div class="example"><pre>
getNext{ myTable.myTableEntry.3.1.1,
         myTable.myTableEntry.5.1.1 } 
        </pre></div>
        <p>Since both operations involve the 1.1 index, this is
          transformed into one call to <span class="code">my_table</span>:
          </p>
        <div class="example"><pre>
my_table(get_next, [1, 1], [3, 5])
        </pre></div>
        <p>In this call, <span class="code">[1, 1]</span> is the <span class="code">RowIndex</span>, where
          key 1 has value 1, and key 2 has value 1, and <span class="code">[3, 5]</span> is
          the list of requested columns. The function should now return
          the lexicographically next elements:
          </p>
        <div class="example"><pre>
[{[3, 1, 2], d}, {[5, 1, 2], f}]
        </pre></div>
        <p>This is illustrated in the following table:
          </p>
        <p></p>
        <a name="getnext2"></a>
        <img alt="IMAGE MISSING" src="getnext2.gif"><br>
          <em>Figure
        10.2:
         
        GetNext from [3,1,1] and [5,1,1].</em>
        
        <p>The manager now issues the following <span class="code">getNext</span> request:
          </p>
        <div class="example"><pre>
getNext{ myTable.myTableEntry.3.2.1,
         myTable.myTableEntry.5.2.1 } 
        </pre></div>
        <p>This is transformed into one call to <span class="code">my_table</span>:
          </p>
        <div class="example"><pre>
my_table(get_next, [2, 1], [3, 5])
        </pre></div>
        <p>The function should now return:
          </p>
        <div class="example"><pre>
[{[4, 1, 1], b}, endOfTable]
        </pre></div>
        <p>This is illustrated in the following table:
          </p>
        <p></p>
        <a name="getnext3"></a>
        <img alt="IMAGE MISSING" src="getnext3.gif"><br>
          <em>Figure
        10.3:
         
        GetNext from [3,2,1] and [5,2,1].</em>
        
        <p>The manager now issues the following <span class="code">getNext</span> request:
          </p>
        <div class="example"><pre>
getNext{ myTable.myTableEntry.3.1.2,
         myTable.myTableEntry.4.1.2 } 
        </pre></div>
        <p>This will be transform into one call to <span class="code">my_table</span>:
          </p>
        <div class="example"><pre>
my_table(get_next, [1, 2], [3, 4])
        </pre></div>
        <p>The function should now return:
          </p>
        <div class="example"><pre>
[{[3, 2, 1], g}, {[5, 1, 1], c}]
        </pre></div>
        <p>This is illustrated in the following table:
          </p>
        <p></p>
        <a name="getnext4"></a>
        <img alt="IMAGE MISSING" src="getnext4.gif"><br>
          <em>Figure
        10.4:
         
        GetNext from [3,1,2] and [4,1,2].</em>
        
        <p>The manager now issues the following <span class="code">getNext</span> request:
          </p>
        <div class="example"><pre>
getNext{ myTable.myTableEntry,
         myTable.myTableEntry.1.3.2 } 
        </pre></div>
        <p>This will be transform into two calls to <span class="code">my_table</span>:
          </p>
        <div class="example"><pre>
my_table(get_next, [], [0]) and
my_table(get_next, [3, 2], [1])
        </pre></div>
        <p>The function should now return:
          </p>
        <div class="example"><pre>
[{[3, 1, 1], a}] and
[{[3, 1, 1], a}]
        </pre></div>
        <p>In both cases, the first accessible element in the table
          should be returned. As the key columns are not accessible,
          this means that the third column is the first row.</p>
        <div class="note">
<div class="label">Note</div>
<div class="content"><p>
          <p>Normally, the functions described above behave exactly as
            shown, but they are free to perform other actions. For
            example, a get-request may have side effects such as setting
            some other variable, perhaps a global <span class="code">lastAccessed</span>
            variable.</p>
        </p></div>
</div>
      
    
  

  <h3><a name="id84706">10.2 
        Using the ExtraArgument</a></h3>
    
    <p>The <span class="code">ListOfExtraArguments</span> can be used to write generic
      functions. This list is appended to the standard arguments for
      each function. Consider two read-only variables for a device,
      <span class="code">ipAdr</span> and <span class="code">name</span> with object identifiers 1.1.23.4 and
      1.1.7 respectively. To access these variables, one could implement
      the two Erlang functions <span class="code">ip_access</span> and <span class="code">name_access</span>,
      which will be in the MIB. The functions could be specified in a
      text file as follows:
      </p>
    <p></p>
    <div class="example"><pre>
{ipAdr, {my_module, ip_access, []}}.
% Or using the oid syntax for 'name'
{[1,1,7], {my_module, name_access, []}}.
    </pre></div>
    <p>The <span class="code">ExtraArgument</span> parameter is the empty list. For
      example, when the agent receives a get-request for the
      <span class="code">ipAdr</span> variable, a call will be made to
      <span class="code">ip_access(get)</span>. The value returned by this function is the
      answer to the get-request.
      </p>
    <p>If <span class="code">ip_access</span> and <span class="code">name_access</span> are implemented
      similarly, we could write a <span class="code">generic_access</span> function using
      the <span class="code">ListOfExtraArguments</span>:
      </p>
    <div class="example"><pre>
{ipAdr, {my_module, generic_access, ['IPADR']}}.
% The mnemonic 'name' is more convenient than 1.1.7
{name, {my_module, generic_access, ['NAME']}}.
    </pre></div>
    <p>When the agent receives the same get-request as above, a call
      will be made to <span class="code">generic_access(get, </span>'<span class="code">IPADR')</span>.
      </p>
    <p>Yet another possibility, closer to the hardware, could be:
      </p>
    <div class="example"><pre>
{ipAdr, {my_module, generic_access, [16#2543]}}.
{name, {my_module, generic_access, [16#A2B3]}}.
    </pre></div>
  

  <h3><a name="id84814">10.3 
        Default Instrumentation</a></h3>
    
    <a name="snmp_3"></a>
    <p>When the MIB definition work is finished, there are two major
      issues left.
      </p>
    <ul>
      <li>Implementing the MIB
      </li>
      <li>Implementing a Manager Application.</li>
    </ul>
    <p>Implementing an MIB can be a tedious task. Most probably, there
      is a need to test the agent before all tables and variables are
      implemented. In this case, the default instrumentation functions
      are useful. The toolkit can generate default instrumentation
      functions for variables as well as for tables. Consequently, a
      running prototype agent, which can handle <span class="code">set</span>, <span class="code">get</span>,
      <span class="code">get-next</span> and table operations, is generated without any
      programming.
      </p>
    <p>The agent stores the values in an internal volatile database,
      which is based on the standard module <span class="code">ets</span>. However, it is
      possible to let the MIB compiler generate functions which use an
      internal, persistent database, or the Mnesia DBMS. Refer to the
      Mnesia User Guide and the Reference Manual, section SNMP, module
      <span class="code">snmp_generic</span> for more information.
      </p>
    <p>When parts of the MIB are implemented, you recompile it and
      continue on by using default functions. With this approach, the
      SNMP agent can be developed incrementally.
      </p>
    <p>The default instrumentation allows the application on the
      manager side to be developed and tested simultaneously with the
      agent. As soon as the ASN.1 file is completed, let the MIB
      compiler generate a default implementation and develop the
      management application from this.
      </p>

    <h4>Table Operations</h4>
      
      <p>The generation of default functions for tables works for
        tables which use the <span class="code">RowStatus</span> textual convention from
        SNMPv2, defined in STANDARD-MIB and SNMPv2-TC.
        </p>
      <div class="note">
<div class="label">Note</div>
<div class="content"><p>
        <p>We strongly encourage the use of the <span class="code">RowStatus</span>
          convention for every table that can be modified from the
          manager, even for newly designed SNMPv1 MIBs. In SNMPv1,
          everybody has invented their own scheme for emulating table
          operations, which has led to numerous inconsistencies. The
          convention in SNMPv2 is flexible and powerful and has been
          tested successfully. If the table is read only, no RowStatus
          column should be used.
          </p>
      </p></div>
</div>
    
  

  <h3><a name="id84919">10.4 
        Atomic Set</a></h3>
    
    <p>In SNMP, the <span class="code">set</span> operation is atomic. Either all
      variables which are specified in a <span class="code">set</span> operation are
      changed, or none are changed. Therefore, the <span class="code">set</span> operation
      is divided into two phases. In the first phase, the new value of
      each variable is checked against the definition of the variable in
      the MIB. The following definitions are checked:
      </p>
    <ul>
      <li>the type</li>
      <li>the length</li>
      <li>the range</li>
      <li>the variable is writable and within the MIB view.
      </li>
    </ul>
    <p>At
      the end of phase one, the user defined <span class="code">is_set_ok</span> functions
      are called for each scalar variable, and for each group of table
      operations.
      </p>
    <p>If no error occurs, the second phase is performed. This phase
      calls the user defined <span class="code">set</span> function for all variables.
      </p>
    <p>If an error occurs, either in the <span class="code">is_set_ok</span> phase, or in
      the <span class="code">set</span> phase, all functions which were called with
      <span class="code">is_set_ok</span> but not <span class="code">set</span>, are called with <span class="code">undo</span>.
      </p>
    <p>There are limitations with this transaction mechanism. If
      complex dependencies exist between variables, for example between
      <span class="code">month</span> and <span class="code">day</span>, another mechanism is needed. Setting
      the date to 'Feb 31' can be avoided by a somewhat more generic
      transaction mechanism. You can continue and find more and more
      complex situations and construct an N-phase set-mechanism. This
      toolkit only contains a trivial mechanism.
      </p>
    <p>The most common application of transaction mechanisms is to
      keep row operations together. Since our agent sorts row
      operations, the mechanism implemented in combination with the
      RowStatus (particularly 'createAndWait' value) solve most
      problems elegantly.
      </p>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
