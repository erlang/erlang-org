<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- erl_nif</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/erts/users_guide.html">User's Guide</a><br><a href="../apps/erts/index.html">Reference Manual</a><br><a href="../apps/erts/release_notes.html">Release Notes</a><br><a href="../apps/erts/erts.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Erlang Run-Time System Application (ERTS)</strong><br><strong>Reference Manual</strong><br><small>Version 7.3</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li id="no" title="erl_prim_loader " expanded="false">erl_prim_loader<ul>
<li><a href="erl_prim_loader.html">
                  Top of manual page
                </a></li>
<li title="start-3"><a href="erl_prim_loader.html#start-3">start/3</a></li>
<li title="get_file-1"><a href="erl_prim_loader.html#get_file-1">get_file/1</a></li>
<li title="get_path-0"><a href="erl_prim_loader.html#get_path-0">get_path/0</a></li>
<li title="list_dir-1"><a href="erl_prim_loader.html#list_dir-1">list_dir/1</a></li>
<li title="read_file_info-1"><a href="erl_prim_loader.html#read_file_info-1">read_file_info/1</a></li>
<li title="read_link_info-1"><a href="erl_prim_loader.html#read_link_info-1">read_link_info/1</a></li>
<li title="set_path-1"><a href="erl_prim_loader.html#set_path-1">set_path/1</a></li>
</ul>
</li>
<li id="no" title="erlang " expanded="false">erlang<ul>
<li><a href="erlang.html">
                  Top of manual page
                </a></li>
<li title="abs-1"><a href="erlang.html#abs-1">abs/1</a></li>
<li title="adler32-1"><a href="erlang.html#adler32-1">adler32/1</a></li>
<li title="adler32-2"><a href="erlang.html#adler32-2">adler32/2</a></li>
<li title="adler32_combine-3"><a href="erlang.html#adler32_combine-3">adler32_combine/3</a></li>
<li title="append_element-2"><a href="erlang.html#append_element-2">append_element/2</a></li>
<li title="apply-2"><a href="erlang.html#apply-2">apply/2</a></li>
<li title="apply-3"><a href="erlang.html#apply-3">apply/3</a></li>
<li title="atom_to_binary-2"><a href="erlang.html#atom_to_binary-2">atom_to_binary/2</a></li>
<li title="atom_to_list-1"><a href="erlang.html#atom_to_list-1">atom_to_list/1</a></li>
<li title="binary_part-2"><a href="erlang.html#binary_part-2">binary_part/2</a></li>
<li title="binary_part-3"><a href="erlang.html#binary_part-3">binary_part/3</a></li>
<li title="binary_to_atom-2"><a href="erlang.html#binary_to_atom-2">binary_to_atom/2</a></li>
<li title="binary_to_existing_atom-2"><a href="erlang.html#binary_to_existing_atom-2">binary_to_existing_atom/2</a></li>
<li title="binary_to_float-1"><a href="erlang.html#binary_to_float-1">binary_to_float/1</a></li>
<li title="binary_to_integer-1"><a href="erlang.html#binary_to_integer-1">binary_to_integer/1</a></li>
<li title="binary_to_integer-2"><a href="erlang.html#binary_to_integer-2">binary_to_integer/2</a></li>
<li title="binary_to_list-1"><a href="erlang.html#binary_to_list-1">binary_to_list/1</a></li>
<li title="binary_to_list-3"><a href="erlang.html#binary_to_list-3">binary_to_list/3</a></li>
<li title="bitstring_to_list-1"><a href="erlang.html#bitstring_to_list-1">bitstring_to_list/1</a></li>
<li title="binary_to_term-1"><a href="erlang.html#binary_to_term-1">binary_to_term/1</a></li>
<li title="binary_to_term-2"><a href="erlang.html#binary_to_term-2">binary_to_term/2</a></li>
<li title="bit_size-1"><a href="erlang.html#bit_size-1">bit_size/1</a></li>
<li title="bump_reductions-1"><a href="erlang.html#bump_reductions-1">bump_reductions/1</a></li>
<li title="byte_size-1"><a href="erlang.html#byte_size-1">byte_size/1</a></li>
<li title="cancel_timer-2"><a href="erlang.html#cancel_timer-2">cancel_timer/2</a></li>
<li title="cancel_timer-1"><a href="erlang.html#cancel_timer-1">cancel_timer/1</a></li>
<li title="check_old_code-1"><a href="erlang.html#check_old_code-1">check_old_code/1</a></li>
<li title="check_process_code-2"><a href="erlang.html#check_process_code-2">check_process_code/2</a></li>
<li title="check_process_code-3"><a href="erlang.html#check_process_code-3">check_process_code/3</a></li>
<li title="convert_time_unit-3"><a href="erlang.html#convert_time_unit-3">convert_time_unit/3</a></li>
<li title="crc32-1"><a href="erlang.html#crc32-1">crc32/1</a></li>
<li title="crc32-2"><a href="erlang.html#crc32-2">crc32/2</a></li>
<li title="crc32_combine-3"><a href="erlang.html#crc32_combine-3">crc32_combine/3</a></li>
<li title="date-0"><a href="erlang.html#date-0">date/0</a></li>
<li title="decode_packet-3"><a href="erlang.html#decode_packet-3">decode_packet/3</a></li>
<li title="delete_element-2"><a href="erlang.html#delete_element-2">delete_element/2</a></li>
<li title="delete_module-1"><a href="erlang.html#delete_module-1">delete_module/1</a></li>
<li title="demonitor-1"><a href="erlang.html#demonitor-1">demonitor/1</a></li>
<li title="demonitor-2"><a href="erlang.html#demonitor-2">demonitor/2</a></li>
<li title="disconnect_node-1"><a href="erlang.html#disconnect_node-1">disconnect_node/1</a></li>
<li title="display-1"><a href="erlang.html#display-1">display/1</a></li>
<li title="element-2"><a href="erlang.html#element-2">element/2</a></li>
<li title="erase-0"><a href="erlang.html#erase-0">erase/0</a></li>
<li title="erase-1"><a href="erlang.html#erase-1">erase/1</a></li>
<li title="error-1"><a href="erlang.html#error-1">error/1</a></li>
<li title="error-2"><a href="erlang.html#error-2">error/2</a></li>
<li title="exit-1"><a href="erlang.html#exit-1">exit/1</a></li>
<li title="exit-2"><a href="erlang.html#exit-2">exit/2</a></li>
<li title="external_size-1"><a href="erlang.html#external_size-1">external_size/1</a></li>
<li title="external_size-2"><a href="erlang.html#external_size-2">external_size/2</a></li>
<li title="float-1"><a href="erlang.html#float-1">float/1</a></li>
<li title="float_to_binary-1"><a href="erlang.html#float_to_binary-1">float_to_binary/1</a></li>
<li title="float_to_binary-2"><a href="erlang.html#float_to_binary-2">float_to_binary/2</a></li>
<li title="float_to_list-1"><a href="erlang.html#float_to_list-1">float_to_list/1</a></li>
<li title="float_to_list-2"><a href="erlang.html#float_to_list-2">float_to_list/2</a></li>
<li title="fun_info-1"><a href="erlang.html#fun_info-1">fun_info/1</a></li>
<li title="fun_info-2"><a href="erlang.html#fun_info-2">fun_info/2</a></li>
<li title="fun_to_list-1"><a href="erlang.html#fun_to_list-1">fun_to_list/1</a></li>
<li title="function_exported-3"><a href="erlang.html#function_exported-3">function_exported/3</a></li>
<li title="garbage_collect-0"><a href="erlang.html#garbage_collect-0">garbage_collect/0</a></li>
<li title="garbage_collect-1"><a href="erlang.html#garbage_collect-1">garbage_collect/1</a></li>
<li title="garbage_collect-2"><a href="erlang.html#garbage_collect-2">garbage_collect/2</a></li>
<li title="get-0"><a href="erlang.html#get-0">get/0</a></li>
<li title="get-1"><a href="erlang.html#get-1">get/1</a></li>
<li title="get_cookie-0"><a href="erlang.html#get_cookie-0">get_cookie/0</a></li>
<li title="get_keys-0"><a href="erlang.html#get_keys-0">get_keys/0</a></li>
<li title="get_keys-1"><a href="erlang.html#get_keys-1">get_keys/1</a></li>
<li title="get_stacktrace-0"><a href="erlang.html#get_stacktrace-0">get_stacktrace/0</a></li>
<li title="group_leader-0"><a href="erlang.html#group_leader-0">group_leader/0</a></li>
<li title="group_leader-2"><a href="erlang.html#group_leader-2">group_leader/2</a></li>
<li title="halt-0"><a href="erlang.html#halt-0">halt/0</a></li>
<li title="halt-1"><a href="erlang.html#halt-1">halt/1</a></li>
<li title="halt-2"><a href="erlang.html#halt-2">halt/2</a></li>
<li title="hash-2"><a href="erlang.html#hash-2">hash/2</a></li>
<li title="hd-1"><a href="erlang.html#hd-1">hd/1</a></li>
<li title="hibernate-3"><a href="erlang.html#hibernate-3">hibernate/3</a></li>
<li title="insert_element-3"><a href="erlang.html#insert_element-3">insert_element/3</a></li>
<li title="integer_to_binary-1"><a href="erlang.html#integer_to_binary-1">integer_to_binary/1</a></li>
<li title="integer_to_binary-2"><a href="erlang.html#integer_to_binary-2">integer_to_binary/2</a></li>
<li title="integer_to_list-1"><a href="erlang.html#integer_to_list-1">integer_to_list/1</a></li>
<li title="integer_to_list-2"><a href="erlang.html#integer_to_list-2">integer_to_list/2</a></li>
<li title="iolist_to_binary-1"><a href="erlang.html#iolist_to_binary-1">iolist_to_binary/1</a></li>
<li title="iolist_size-1"><a href="erlang.html#iolist_size-1">iolist_size/1</a></li>
<li title="is_alive-0"><a href="erlang.html#is_alive-0">is_alive/0</a></li>
<li title="is_atom-1"><a href="erlang.html#is_atom-1">is_atom/1</a></li>
<li title="is_binary-1"><a href="erlang.html#is_binary-1">is_binary/1</a></li>
<li title="is_bitstring-1"><a href="erlang.html#is_bitstring-1">is_bitstring/1</a></li>
<li title="is_boolean-1"><a href="erlang.html#is_boolean-1">is_boolean/1</a></li>
<li title="is_builtin-3"><a href="erlang.html#is_builtin-3">is_builtin/3</a></li>
<li title="is_float-1"><a href="erlang.html#is_float-1">is_float/1</a></li>
<li title="is_function-1"><a href="erlang.html#is_function-1">is_function/1</a></li>
<li title="is_function-2"><a href="erlang.html#is_function-2">is_function/2</a></li>
<li title="is_integer-1"><a href="erlang.html#is_integer-1">is_integer/1</a></li>
<li title="is_list-1"><a href="erlang.html#is_list-1">is_list/1</a></li>
<li title="is_map-1"><a href="erlang.html#is_map-1">is_map/1</a></li>
<li title="is_number-1"><a href="erlang.html#is_number-1">is_number/1</a></li>
<li title="is_pid-1"><a href="erlang.html#is_pid-1">is_pid/1</a></li>
<li title="is_port-1"><a href="erlang.html#is_port-1">is_port/1</a></li>
<li title="is_process_alive-1"><a href="erlang.html#is_process_alive-1">is_process_alive/1</a></li>
<li title="is_record-2"><a href="erlang.html#is_record-2">is_record/2</a></li>
<li title="is_record-3"><a href="erlang.html#is_record-3">is_record/3</a></li>
<li title="is_reference-1"><a href="erlang.html#is_reference-1">is_reference/1</a></li>
<li title="is_tuple-1"><a href="erlang.html#is_tuple-1">is_tuple/1</a></li>
<li title="length-1"><a href="erlang.html#length-1">length/1</a></li>
<li title="link-1"><a href="erlang.html#link-1">link/1</a></li>
<li title="list_to_atom-1"><a href="erlang.html#list_to_atom-1">list_to_atom/1</a></li>
<li title="list_to_binary-1"><a href="erlang.html#list_to_binary-1">list_to_binary/1</a></li>
<li title="list_to_bitstring-1"><a href="erlang.html#list_to_bitstring-1">list_to_bitstring/1</a></li>
<li title="list_to_existing_atom-1"><a href="erlang.html#list_to_existing_atom-1">list_to_existing_atom/1</a></li>
<li title="list_to_float-1"><a href="erlang.html#list_to_float-1">list_to_float/1</a></li>
<li title="list_to_integer-1"><a href="erlang.html#list_to_integer-1">list_to_integer/1</a></li>
<li title="list_to_integer-2"><a href="erlang.html#list_to_integer-2">list_to_integer/2</a></li>
<li title="list_to_pid-1"><a href="erlang.html#list_to_pid-1">list_to_pid/1</a></li>
<li title="list_to_tuple-1"><a href="erlang.html#list_to_tuple-1">list_to_tuple/1</a></li>
<li title="load_module-2"><a href="erlang.html#load_module-2">load_module/2</a></li>
<li title="load_nif-2"><a href="erlang.html#load_nif-2">load_nif/2</a></li>
<li title="loaded-0"><a href="erlang.html#loaded-0">loaded/0</a></li>
<li title="localtime-0"><a href="erlang.html#localtime-0">localtime/0</a></li>
<li title="localtime_to_universaltime-1"><a href="erlang.html#localtime_to_universaltime-1">localtime_to_universaltime/1</a></li>
<li title="localtime_to_universaltime-2"><a href="erlang.html#localtime_to_universaltime-2">localtime_to_universaltime/2</a></li>
<li title="make_ref-0"><a href="erlang.html#make_ref-0">make_ref/0</a></li>
<li title="make_tuple-2"><a href="erlang.html#make_tuple-2">make_tuple/2</a></li>
<li title="make_tuple-3"><a href="erlang.html#make_tuple-3">make_tuple/3</a></li>
<li title="map_size-1"><a href="erlang.html#map_size-1">map_size/1</a></li>
<li title="max-2"><a href="erlang.html#max-2">max/2</a></li>
<li title="md5-1"><a href="erlang.html#md5-1">md5/1</a></li>
<li title="md5_final-1"><a href="erlang.html#md5_final-1">md5_final/1</a></li>
<li title="md5_init-0"><a href="erlang.html#md5_init-0">md5_init/0</a></li>
<li title="md5_update-2"><a href="erlang.html#md5_update-2">md5_update/2</a></li>
<li title="memory-0"><a href="erlang.html#memory-0">memory/0</a></li>
<li title="memory-1"><a href="erlang.html#memory-1">memory/1</a></li>
<li title="min-2"><a href="erlang.html#min-2">min/2</a></li>
<li title="module_loaded-1"><a href="erlang.html#module_loaded-1">module_loaded/1</a></li>
<li title="monitor-2"><a href="erlang.html#monitor-2">monitor/2</a></li>
<li title="monitor_node-2"><a href="erlang.html#monitor_node-2">monitor_node/2</a></li>
<li title="monitor_node-3"><a href="erlang.html#monitor_node-3">monitor_node/3</a></li>
<li title="monotonic_time-0"><a href="erlang.html#monotonic_time-0">monotonic_time/0</a></li>
<li title="monotonic_time-1"><a href="erlang.html#monotonic_time-1">monotonic_time/1</a></li>
<li title="nif_error-1"><a href="erlang.html#nif_error-1">nif_error/1</a></li>
<li title="nif_error-2"><a href="erlang.html#nif_error-2">nif_error/2</a></li>
<li title="node-0"><a href="erlang.html#node-0">node/0</a></li>
<li title="node-1"><a href="erlang.html#node-1">node/1</a></li>
<li title="nodes-0"><a href="erlang.html#nodes-0">nodes/0</a></li>
<li title="nodes-1"><a href="erlang.html#nodes-1">nodes/1</a></li>
<li title="now-0"><a href="erlang.html#now-0">now/0</a></li>
<li title="open_port-2"><a href="erlang.html#open_port-2">open_port/2</a></li>
<li title="phash-2"><a href="erlang.html#phash-2">phash/2</a></li>
<li title="phash2-1"><a href="erlang.html#phash2-1">phash2/1</a></li>
<li title="phash2-2"><a href="erlang.html#phash2-2">phash2/2</a></li>
<li title="pid_to_list-1"><a href="erlang.html#pid_to_list-1">pid_to_list/1</a></li>
<li title="port_close-1"><a href="erlang.html#port_close-1">port_close/1</a></li>
<li title="port_command-2"><a href="erlang.html#port_command-2">port_command/2</a></li>
<li title="port_command-3"><a href="erlang.html#port_command-3">port_command/3</a></li>
<li title="port_connect-2"><a href="erlang.html#port_connect-2">port_connect/2</a></li>
<li title="port_control-3"><a href="erlang.html#port_control-3">port_control/3</a></li>
<li title="port_call-3"><a href="erlang.html#port_call-3">port_call/3</a></li>
<li title="port_info-1"><a href="erlang.html#port_info-1">port_info/1</a></li>
<li title="port_info-2"><a href="erlang.html#port_info-2">port_info/2</a></li>
<li title="port_to_list-1"><a href="erlang.html#port_to_list-1">port_to_list/1</a></li>
<li title="ports-0"><a href="erlang.html#ports-0">ports/0</a></li>
<li title="pre_loaded-0"><a href="erlang.html#pre_loaded-0">pre_loaded/0</a></li>
<li title="process_display-2"><a href="erlang.html#process_display-2">process_display/2</a></li>
<li title="process_flag-2"><a href="erlang.html#process_flag-2">process_flag/2</a></li>
<li title="process_flag-3"><a href="erlang.html#process_flag-3">process_flag/3</a></li>
<li title="process_info-1"><a href="erlang.html#process_info-1">process_info/1</a></li>
<li title="process_info-2"><a href="erlang.html#process_info-2">process_info/2</a></li>
<li title="processes-0"><a href="erlang.html#processes-0">processes/0</a></li>
<li title="purge_module-1"><a href="erlang.html#purge_module-1">purge_module/1</a></li>
<li title="put-2"><a href="erlang.html#put-2">put/2</a></li>
<li title="raise-3"><a href="erlang.html#raise-3">raise/3</a></li>
<li title="read_timer-2"><a href="erlang.html#read_timer-2">read_timer/2</a></li>
<li title="read_timer-1"><a href="erlang.html#read_timer-1">read_timer/1</a></li>
<li title="ref_to_list-1"><a href="erlang.html#ref_to_list-1">ref_to_list/1</a></li>
<li title="register-2"><a href="erlang.html#register-2">register/2</a></li>
<li title="registered-0"><a href="erlang.html#registered-0">registered/0</a></li>
<li title="resume_process-1"><a href="erlang.html#resume_process-1">resume_process/1</a></li>
<li title="round-1"><a href="erlang.html#round-1">round/1</a></li>
<li title="self-0"><a href="erlang.html#self-0">self/0</a></li>
<li title="send-2"><a href="erlang.html#send-2">send/2</a></li>
<li title="send-3"><a href="erlang.html#send-3">send/3</a></li>
<li title="send_after-4"><a href="erlang.html#send_after-4">send_after/4</a></li>
<li title="send_after-3"><a href="erlang.html#send_after-3">send_after/3</a></li>
<li title="send_nosuspend-2"><a href="erlang.html#send_nosuspend-2">send_nosuspend/2</a></li>
<li title="send_nosuspend-3"><a href="erlang.html#send_nosuspend-3">send_nosuspend/3</a></li>
<li title="set_cookie-2"><a href="erlang.html#set_cookie-2">set_cookie/2</a></li>
<li title="setelement-3"><a href="erlang.html#setelement-3">setelement/3</a></li>
<li title="size-1"><a href="erlang.html#size-1">size/1</a></li>
<li title="spawn-1"><a href="erlang.html#spawn-1">spawn/1</a></li>
<li title="spawn-2"><a href="erlang.html#spawn-2">spawn/2</a></li>
<li title="spawn-3"><a href="erlang.html#spawn-3">spawn/3</a></li>
<li title="spawn-4"><a href="erlang.html#spawn-4">spawn/4</a></li>
<li title="spawn_link-1"><a href="erlang.html#spawn_link-1">spawn_link/1</a></li>
<li title="spawn_link-2"><a href="erlang.html#spawn_link-2">spawn_link/2</a></li>
<li title="spawn_link-3"><a href="erlang.html#spawn_link-3">spawn_link/3</a></li>
<li title="spawn_link-4"><a href="erlang.html#spawn_link-4">spawn_link/4</a></li>
<li title="spawn_monitor-1"><a href="erlang.html#spawn_monitor-1">spawn_monitor/1</a></li>
<li title="spawn_monitor-3"><a href="erlang.html#spawn_monitor-3">spawn_monitor/3</a></li>
<li title="spawn_opt-2"><a href="erlang.html#spawn_opt-2">spawn_opt/2</a></li>
<li title="spawn_opt-3"><a href="erlang.html#spawn_opt-3">spawn_opt/3</a></li>
<li title="spawn_opt-4"><a href="erlang.html#spawn_opt-4">spawn_opt/4</a></li>
<li title="spawn_opt-5"><a href="erlang.html#spawn_opt-5">spawn_opt/5</a></li>
<li title="split_binary-2"><a href="erlang.html#split_binary-2">split_binary/2</a></li>
<li title="start_timer-4"><a href="erlang.html#start_timer-4">start_timer/4</a></li>
<li title="start_timer-3"><a href="erlang.html#start_timer-3">start_timer/3</a></li>
<li title="statistics-1"><a href="erlang.html#statistics-1">statistics/1</a></li>
<li title="suspend_process-2"><a href="erlang.html#suspend_process-2">suspend_process/2</a></li>
<li title="suspend_process-1"><a href="erlang.html#suspend_process-1">suspend_process/1</a></li>
<li title="system_flag-2"><a href="erlang.html#system_flag-2">system_flag/2</a></li>
<li title="system_info-1"><a href="erlang.html#system_info-1">system_info/1</a></li>
<li title="system_monitor-0"><a href="erlang.html#system_monitor-0">system_monitor/0</a></li>
<li title="system_monitor-1"><a href="erlang.html#system_monitor-1">system_monitor/1</a></li>
<li title="system_monitor-2"><a href="erlang.html#system_monitor-2">system_monitor/2</a></li>
<li title="system_profile-0"><a href="erlang.html#system_profile-0">system_profile/0</a></li>
<li title="system_profile-2"><a href="erlang.html#system_profile-2">system_profile/2</a></li>
<li title="system_time-0"><a href="erlang.html#system_time-0">system_time/0</a></li>
<li title="system_time-1"><a href="erlang.html#system_time-1">system_time/1</a></li>
<li title="term_to_binary-1"><a href="erlang.html#term_to_binary-1">term_to_binary/1</a></li>
<li title="term_to_binary-2"><a href="erlang.html#term_to_binary-2">term_to_binary/2</a></li>
<li title="throw-1"><a href="erlang.html#throw-1">throw/1</a></li>
<li title="time-0"><a href="erlang.html#time-0">time/0</a></li>
<li title="time_offset-0"><a href="erlang.html#time_offset-0">time_offset/0</a></li>
<li title="time_offset-1"><a href="erlang.html#time_offset-1">time_offset/1</a></li>
<li title="timestamp-0"><a href="erlang.html#timestamp-0">timestamp/0</a></li>
<li title="tl-1"><a href="erlang.html#tl-1">tl/1</a></li>
<li title="trace-3"><a href="erlang.html#trace-3">trace/3</a></li>
<li title="trace_delivered-1"><a href="erlang.html#trace_delivered-1">trace_delivered/1</a></li>
<li title="trace_info-2"><a href="erlang.html#trace_info-2">trace_info/2</a></li>
<li title="trace_pattern-2"><a href="erlang.html#trace_pattern-2">trace_pattern/2</a></li>
<li title="trace_pattern-3"><a href="erlang.html#trace_pattern-3">trace_pattern/3</a></li>
<li title="trunc-1"><a href="erlang.html#trunc-1">trunc/1</a></li>
<li title="tuple_size-1"><a href="erlang.html#tuple_size-1">tuple_size/1</a></li>
<li title="tuple_to_list-1"><a href="erlang.html#tuple_to_list-1">tuple_to_list/1</a></li>
<li title="universaltime-0"><a href="erlang.html#universaltime-0">universaltime/0</a></li>
<li title="universaltime_to_localtime-1"><a href="erlang.html#universaltime_to_localtime-1">universaltime_to_localtime/1</a></li>
<li title="unique_integer-0"><a href="erlang.html#unique_integer-0">unique_integer/0</a></li>
<li title="unique_integer-1"><a href="erlang.html#unique_integer-1">unique_integer/1</a></li>
<li title="unlink-1"><a href="erlang.html#unlink-1">unlink/1</a></li>
<li title="unregister-1"><a href="erlang.html#unregister-1">unregister/1</a></li>
<li title="whereis-1"><a href="erlang.html#whereis-1">whereis/1</a></li>
<li title="yield-0"><a href="erlang.html#yield-0">yield/0</a></li>
</ul>
</li>
<li id="no" title="init " expanded="false">init<ul>
<li><a href="init.html">
                  Top of manual page
                </a></li>
<li title="boot-1"><a href="init.html#boot-1">boot/1</a></li>
<li title="get_argument-1"><a href="init.html#get_argument-1">get_argument/1</a></li>
<li title="get_arguments-0"><a href="init.html#get_arguments-0">get_arguments/0</a></li>
<li title="get_plain_arguments-0"><a href="init.html#get_plain_arguments-0">get_plain_arguments/0</a></li>
<li title="get_status-0"><a href="init.html#get_status-0">get_status/0</a></li>
<li title="reboot-0"><a href="init.html#reboot-0">reboot/0</a></li>
<li title="restart-0"><a href="init.html#restart-0">restart/0</a></li>
<li title="script_id-0"><a href="init.html#script_id-0">script_id/0</a></li>
<li title="stop-0"><a href="init.html#stop-0">stop/0</a></li>
<li title="stop-1"><a href="init.html#stop-1">stop/1</a></li>
</ul>
</li>
<li id="no" title="zlib " expanded="false">zlib<ul>
<li><a href="zlib.html">
                  Top of manual page
                </a></li>
<li title="open-0"><a href="zlib.html#open-0">open/0</a></li>
<li title="close-1"><a href="zlib.html#close-1">close/1</a></li>
<li title="deflateInit-1"><a href="zlib.html#deflateInit-1">deflateInit/1</a></li>
<li title="deflateInit-2"><a href="zlib.html#deflateInit-2">deflateInit/2</a></li>
<li title="deflateInit-6"><a href="zlib.html#deflateInit-6">deflateInit/6</a></li>
<li title="deflate-2"><a href="zlib.html#deflate-2">deflate/2</a></li>
<li title="deflate-3"><a href="zlib.html#deflate-3">deflate/3</a></li>
<li title="deflateSetDictionary-2"><a href="zlib.html#deflateSetDictionary-2">deflateSetDictionary/2</a></li>
<li title="deflateReset-1"><a href="zlib.html#deflateReset-1">deflateReset/1</a></li>
<li title="deflateParams-3"><a href="zlib.html#deflateParams-3">deflateParams/3</a></li>
<li title="deflateEnd-1"><a href="zlib.html#deflateEnd-1">deflateEnd/1</a></li>
<li title="inflateInit-1"><a href="zlib.html#inflateInit-1">inflateInit/1</a></li>
<li title="inflateInit-2"><a href="zlib.html#inflateInit-2">inflateInit/2</a></li>
<li title="inflate-2"><a href="zlib.html#inflate-2">inflate/2</a></li>
<li title="inflateChunk-2"><a href="zlib.html#inflateChunk-2">inflateChunk/2</a></li>
<li title="inflateChunk-1"><a href="zlib.html#inflateChunk-1">inflateChunk/1</a></li>
<li title="inflateSetDictionary-2"><a href="zlib.html#inflateSetDictionary-2">inflateSetDictionary/2</a></li>
<li title="inflateReset-1"><a href="zlib.html#inflateReset-1">inflateReset/1</a></li>
<li title="inflateEnd-1"><a href="zlib.html#inflateEnd-1">inflateEnd/1</a></li>
<li title="setBufSize-2"><a href="zlib.html#setBufSize-2">setBufSize/2</a></li>
<li title="getBufSize-1"><a href="zlib.html#getBufSize-1">getBufSize/1</a></li>
<li title="crc32-1"><a href="zlib.html#crc32-1">crc32/1</a></li>
<li title="crc32-2"><a href="zlib.html#crc32-2">crc32/2</a></li>
<li title="crc32-3"><a href="zlib.html#crc32-3">crc32/3</a></li>
<li title="crc32_combine-4"><a href="zlib.html#crc32_combine-4">crc32_combine/4</a></li>
<li title="adler32-2"><a href="zlib.html#adler32-2">adler32/2</a></li>
<li title="adler32-3"><a href="zlib.html#adler32-3">adler32/3</a></li>
<li title="adler32_combine-4"><a href="zlib.html#adler32_combine-4">adler32_combine/4</a></li>
<li title="compress-1"><a href="zlib.html#compress-1">compress/1</a></li>
<li title="uncompress-1"><a href="zlib.html#uncompress-1">uncompress/1</a></li>
<li title="zip-1"><a href="zlib.html#zip-1">zip/1</a></li>
<li title="unzip-1"><a href="zlib.html#unzip-1">unzip/1</a></li>
<li title="gzip-1"><a href="zlib.html#gzip-1">gzip/1</a></li>
<li title="gunzip-1"><a href="zlib.html#gunzip-1">gunzip/1</a></li>
</ul>
</li>
<li title="epmd"><a href="epmd.html">epmd</a></li>
<li title="erl"><a href="erl.html">erl</a></li>
<li title="erlc"><a href="erlc.html">erlc</a></li>
<li title="werl"><a href="werl.html">werl</a></li>
<li title="escript"><a href="escript.html">escript</a></li>
<li title="erlsrv"><a href="erlsrv.html">erlsrv</a></li>
<li title="start_erl"><a href="start_erl.html">start_erl</a></li>
<li title="run_erl"><a href="run_erl.html">run_erl</a></li>
<li title="start"><a href="start.html">start</a></li>
<li id="no" title="erl_driver " expanded="false">erl_driver<ul>
<li><a href="erl_driver.html">
                  Top of manual page
                </a></li>
<li title="driver_system_info"><a href="erl_driver.html#driver_system_info">driver_system_info()
                </a></li>
<li title="driver_output"><a href="erl_driver.html#driver_output">driver_output()
                </a></li>
<li title="driver_output2"><a href="erl_driver.html#driver_output2">driver_output2()
                </a></li>
<li title="driver_output_binary"><a href="erl_driver.html#driver_output_binary">driver_output_binary()
                </a></li>
<li title="driver_outputv"><a href="erl_driver.html#driver_outputv">driver_outputv()
                </a></li>
<li title="driver_vec_to_buf"><a href="erl_driver.html#driver_vec_to_buf">driver_vec_to_buf()
                </a></li>
<li title="driver_set_timer"><a href="erl_driver.html#driver_set_timer">driver_set_timer()
                </a></li>
<li title="driver_cancel_timer"><a href="erl_driver.html#driver_cancel_timer">driver_cancel_timer()
                </a></li>
<li title="driver_read_timer"><a href="erl_driver.html#driver_read_timer">driver_read_timer()
                </a></li>
<li title="driver_get_now"><a href="erl_driver.html#driver_get_now">driver_get_now()
                </a></li>
<li title="driver_select"><a href="erl_driver.html#driver_select">driver_select()
                </a></li>
<li title="driver_alloc"><a href="erl_driver.html#driver_alloc">driver_alloc()
                </a></li>
<li title="driver_realloc"><a href="erl_driver.html#driver_realloc">driver_realloc()
                </a></li>
<li title="driver_free"><a href="erl_driver.html#driver_free">driver_free()
                </a></li>
<li title="driver_alloc_binary"><a href="erl_driver.html#driver_alloc_binary">driver_alloc_binary()
                </a></li>
<li title="driver_realloc_binary"><a href="erl_driver.html#driver_realloc_binary">driver_realloc_binary()
                </a></li>
<li title="driver_free_binary"><a href="erl_driver.html#driver_free_binary">driver_free_binary()
                </a></li>
<li title="driver_binary_get_refc"><a href="erl_driver.html#driver_binary_get_refc">driver_binary_get_refc()
                </a></li>
<li title="driver_binary_inc_refc"><a href="erl_driver.html#driver_binary_inc_refc">driver_binary_inc_refc()
                </a></li>
<li title="driver_binary_dec_refc"><a href="erl_driver.html#driver_binary_dec_refc">driver_binary_dec_refc()
                </a></li>
<li title="driver_enq"><a href="erl_driver.html#driver_enq">driver_enq()
                </a></li>
<li title="driver_pushq"><a href="erl_driver.html#driver_pushq">driver_pushq()
                </a></li>
<li title="driver_deq"><a href="erl_driver.html#driver_deq">driver_deq()
                </a></li>
<li title="driver_sizeq"><a href="erl_driver.html#driver_sizeq">driver_sizeq()
                </a></li>
<li title="driver_enq_bin"><a href="erl_driver.html#driver_enq_bin">driver_enq_bin()
                </a></li>
<li title="driver_pushq_bin"><a href="erl_driver.html#driver_pushq_bin">driver_pushq_bin()
                </a></li>
<li title="driver_peekqv"><a href="erl_driver.html#driver_peekqv">driver_peekqv()
                </a></li>
<li title="driver_peekq"><a href="erl_driver.html#driver_peekq">driver_peekq()
                </a></li>
<li title="driver_enqv"><a href="erl_driver.html#driver_enqv">driver_enqv()
                </a></li>
<li title="driver_pushqv"><a href="erl_driver.html#driver_pushqv">driver_pushqv()
                </a></li>
<li title="driver_pdl_create"><a href="erl_driver.html#driver_pdl_create">driver_pdl_create()
                </a></li>
<li title="driver_pdl_lock"><a href="erl_driver.html#driver_pdl_lock">driver_pdl_lock()
                </a></li>
<li title="driver_pdl_unlock"><a href="erl_driver.html#driver_pdl_unlock">driver_pdl_unlock()
                </a></li>
<li title="driver_pdl_get_refc"><a href="erl_driver.html#driver_pdl_get_refc">driver_pdl_get_refc()
                </a></li>
<li title="driver_pdl_inc_refc"><a href="erl_driver.html#driver_pdl_inc_refc">driver_pdl_inc_refc()
                </a></li>
<li title="driver_pdl_dec_refc"><a href="erl_driver.html#driver_pdl_dec_refc">driver_pdl_dec_refc()
                </a></li>
<li title="driver_monitor_process"><a href="erl_driver.html#driver_monitor_process">driver_monitor_process()
                </a></li>
<li title="driver_demonitor_process"><a href="erl_driver.html#driver_demonitor_process">driver_demonitor_process()
                </a></li>
<li title="driver_get_monitored_process"><a href="erl_driver.html#driver_get_monitored_process">driver_get_monitored_process()
                </a></li>
<li title="driver_compare_monitors"><a href="erl_driver.html#driver_compare_monitors">driver_compare_monitors()
                </a></li>
<li title="add_driver_entry"><a href="erl_driver.html#add_driver_entry">add_driver_entry()
                </a></li>
<li title="remove_driver_entry"><a href="erl_driver.html#remove_driver_entry">remove_driver_entry()
                </a></li>
<li title="erl_errno_id"><a href="erl_driver.html#erl_errno_id">erl_errno_id()
                </a></li>
<li title="erl_drv_busy_msgq_limits"><a href="erl_driver.html#erl_drv_busy_msgq_limits">erl_drv_busy_msgq_limits()
                </a></li>
<li title="set_busy_port"><a href="erl_driver.html#set_busy_port">set_busy_port()
                </a></li>
<li title="set_port_control_flags"><a href="erl_driver.html#set_port_control_flags">set_port_control_flags()
                </a></li>
<li title="driver_failure_eof"><a href="erl_driver.html#driver_failure_eof">driver_failure_eof()
                </a></li>
<li title="driver_failure_atom"><a href="erl_driver.html#driver_failure_atom">driver_failure_atom()
                </a></li>
<li title="driver_failure_posix"><a href="erl_driver.html#driver_failure_posix">driver_failure_posix()
                </a></li>
<li title="driver_failure"><a href="erl_driver.html#driver_failure">driver_failure()
                </a></li>
<li title="driver_connected"><a href="erl_driver.html#driver_connected">driver_connected()
                </a></li>
<li title="driver_caller"><a href="erl_driver.html#driver_caller">driver_caller()
                </a></li>
<li title="erl_drv_output_term"><a href="erl_driver.html#erl_drv_output_term">erl_drv_output_term()
                </a></li>
<li title="driver_output_term"><a href="erl_driver.html#driver_output_term">driver_output_term()
                </a></li>
<li title="driver_mk_atom"><a href="erl_driver.html#driver_mk_atom">driver_mk_atom()
                </a></li>
<li title="driver_mk_port"><a href="erl_driver.html#driver_mk_port">driver_mk_port()
                </a></li>
<li title="erl_drv_send_term"><a href="erl_driver.html#erl_drv_send_term">erl_drv_send_term()
                </a></li>
<li title="driver_send_term"><a href="erl_driver.html#driver_send_term">driver_send_term()
                </a></li>
<li title="driver_async "><a href="erl_driver.html#driver_async%20">driver_async ()
                </a></li>
<li title="driver_async_port_key "><a href="erl_driver.html#driver_async_port_key%20">driver_async_port_key ()
                </a></li>
<li title="driver_lock_driver"><a href="erl_driver.html#driver_lock_driver">driver_lock_driver()
                </a></li>
<li title="driver_create_port"><a href="erl_driver.html#driver_create_port">driver_create_port()
                </a></li>
<li title="erl_drv_thread_create"><a href="erl_driver.html#erl_drv_thread_create">erl_drv_thread_create()
                </a></li>
<li title="erl_drv_thread_opts_create"><a href="erl_driver.html#erl_drv_thread_opts_create">erl_drv_thread_opts_create()
                </a></li>
<li title="erl_drv_thread_opts_destroy"><a href="erl_driver.html#erl_drv_thread_opts_destroy">erl_drv_thread_opts_destroy()
                </a></li>
<li title="erl_drv_thread_exit"><a href="erl_driver.html#erl_drv_thread_exit">erl_drv_thread_exit()
                </a></li>
<li title="erl_drv_thread_join"><a href="erl_driver.html#erl_drv_thread_join">erl_drv_thread_join()
                </a></li>
<li title="erl_drv_thread_self"><a href="erl_driver.html#erl_drv_thread_self">erl_drv_thread_self()
                </a></li>
<li title="erl_drv_equal_tids"><a href="erl_driver.html#erl_drv_equal_tids">erl_drv_equal_tids()
                </a></li>
<li title="erl_drv_mutex_create"><a href="erl_driver.html#erl_drv_mutex_create">erl_drv_mutex_create()
                </a></li>
<li title="erl_drv_mutex_destroy"><a href="erl_driver.html#erl_drv_mutex_destroy">erl_drv_mutex_destroy()
                </a></li>
<li title="erl_drv_mutex_lock"><a href="erl_driver.html#erl_drv_mutex_lock">erl_drv_mutex_lock()
                </a></li>
<li title="erl_drv_mutex_trylock"><a href="erl_driver.html#erl_drv_mutex_trylock">erl_drv_mutex_trylock()
                </a></li>
<li title="erl_drv_mutex_unlock"><a href="erl_driver.html#erl_drv_mutex_unlock">erl_drv_mutex_unlock()
                </a></li>
<li title="erl_drv_cond_create"><a href="erl_driver.html#erl_drv_cond_create">erl_drv_cond_create()
                </a></li>
<li title="erl_drv_cond_destroy"><a href="erl_driver.html#erl_drv_cond_destroy">erl_drv_cond_destroy()
                </a></li>
<li title="erl_drv_cond_signal"><a href="erl_driver.html#erl_drv_cond_signal">erl_drv_cond_signal()
                </a></li>
<li title="erl_drv_cond_broadcast"><a href="erl_driver.html#erl_drv_cond_broadcast">erl_drv_cond_broadcast()
                </a></li>
<li title="erl_drv_cond_wait"><a href="erl_driver.html#erl_drv_cond_wait">erl_drv_cond_wait()
                </a></li>
<li title="erl_drv_rwlock_create"><a href="erl_driver.html#erl_drv_rwlock_create">erl_drv_rwlock_create()
                </a></li>
<li title="erl_drv_rwlock_destroy"><a href="erl_driver.html#erl_drv_rwlock_destroy">erl_drv_rwlock_destroy()
                </a></li>
<li title="erl_drv_rwlock_rlock"><a href="erl_driver.html#erl_drv_rwlock_rlock">erl_drv_rwlock_rlock()
                </a></li>
<li title="erl_drv_rwlock_tryrlock"><a href="erl_driver.html#erl_drv_rwlock_tryrlock">erl_drv_rwlock_tryrlock()
                </a></li>
<li title="erl_drv_rwlock_runlock"><a href="erl_driver.html#erl_drv_rwlock_runlock">erl_drv_rwlock_runlock()
                </a></li>
<li title="erl_drv_rwlock_rwlock"><a href="erl_driver.html#erl_drv_rwlock_rwlock">erl_drv_rwlock_rwlock()
                </a></li>
<li title="erl_drv_rwlock_tryrwlock"><a href="erl_driver.html#erl_drv_rwlock_tryrwlock">erl_drv_rwlock_tryrwlock()
                </a></li>
<li title="erl_drv_rwlock_rwunlock"><a href="erl_driver.html#erl_drv_rwlock_rwunlock">erl_drv_rwlock_rwunlock()
                </a></li>
<li title="erl_drv_tsd_key_create"><a href="erl_driver.html#erl_drv_tsd_key_create">erl_drv_tsd_key_create()
                </a></li>
<li title="erl_drv_tsd_key_destroy"><a href="erl_driver.html#erl_drv_tsd_key_destroy">erl_drv_tsd_key_destroy()
                </a></li>
<li title="erl_drv_tsd_set"><a href="erl_driver.html#erl_drv_tsd_set">erl_drv_tsd_set()
                </a></li>
<li title="erl_drv_tsd_get"><a href="erl_driver.html#erl_drv_tsd_get">erl_drv_tsd_get()
                </a></li>
<li title="erl_drv_putenv"><a href="erl_driver.html#erl_drv_putenv">erl_drv_putenv()
                </a></li>
<li title="erl_drv_getenv"><a href="erl_driver.html#erl_drv_getenv">erl_drv_getenv()
                </a></li>
<li title="erl_drv_consume_timeslice"><a href="erl_driver.html#erl_drv_consume_timeslice">erl_drv_consume_timeslice()
                </a></li>
<li title="erl_drv_cond_name"><a href="erl_driver.html#erl_drv_cond_name">erl_drv_cond_name()
                </a></li>
<li title="erl_drv_mutex_name"><a href="erl_driver.html#erl_drv_mutex_name">erl_drv_mutex_name()
                </a></li>
<li title="erl_drv_rwlock_name"><a href="erl_driver.html#erl_drv_rwlock_name">erl_drv_rwlock_name()
                </a></li>
<li title="erl_drv_thread_name"><a href="erl_driver.html#erl_drv_thread_name">erl_drv_thread_name()
                </a></li>
<li title="erl_drv_monotonic_time"><a href="erl_driver.html#erl_drv_monotonic_time">erl_drv_monotonic_time()
                </a></li>
<li title="erl_drv_time_offset"><a href="erl_driver.html#erl_drv_time_offset">erl_drv_time_offset()
                </a></li>
<li title="erl_drv_convert_time_unit"><a href="erl_driver.html#erl_drv_convert_time_unit">erl_drv_convert_time_unit()
                </a></li>
</ul>
</li>
<li title="driver_entry"><a href="driver_entry.html">driver_entry</a></li>
<li title="erts_alloc"><a href="erts_alloc.html">erts_alloc</a></li>
<li id="loadscrollpos" title="erl_nif " expanded="true">erl_nif<ul>
<li><a href="erl_nif.html">
                  Top of manual page
                </a></li>
<li title="enif_alloc"><a href="erl_nif.html#enif_alloc">enif_alloc()
                </a></li>
<li title="enif_alloc_binary"><a href="erl_nif.html#enif_alloc_binary">enif_alloc_binary()
                </a></li>
<li title="enif_alloc_env"><a href="erl_nif.html#enif_alloc_env">enif_alloc_env()
                </a></li>
<li title="enif_alloc_resource"><a href="erl_nif.html#enif_alloc_resource">enif_alloc_resource()
                </a></li>
<li title="enif_clear_env"><a href="erl_nif.html#enif_clear_env">enif_clear_env()
                </a></li>
<li title="enif_compare"><a href="erl_nif.html#enif_compare">enif_compare()
                </a></li>
<li title="enif_cond_broadcast"><a href="erl_nif.html#enif_cond_broadcast">enif_cond_broadcast()
                </a></li>
<li title="enif_cond_create"><a href="erl_nif.html#enif_cond_create">enif_cond_create()
                </a></li>
<li title="enif_cond_destroy"><a href="erl_nif.html#enif_cond_destroy">enif_cond_destroy()
                </a></li>
<li title="enif_cond_signal"><a href="erl_nif.html#enif_cond_signal">enif_cond_signal()
                </a></li>
<li title="enif_cond_wait"><a href="erl_nif.html#enif_cond_wait">enif_cond_wait()
                </a></li>
<li title="enif_consume_timeslice"><a href="erl_nif.html#enif_consume_timeslice">enif_consume_timeslice()
                </a></li>
<li title="enif_equal_tids"><a href="erl_nif.html#enif_equal_tids">enif_equal_tids()
                </a></li>
<li title="enif_free"><a href="erl_nif.html#enif_free">enif_free()
                </a></li>
<li title="enif_free_env"><a href="erl_nif.html#enif_free_env">enif_free_env()
                </a></li>
<li title="enif_get_atom"><a href="erl_nif.html#enif_get_atom">enif_get_atom()
                </a></li>
<li title="enif_get_atom_length"><a href="erl_nif.html#enif_get_atom_length">enif_get_atom_length()
                </a></li>
<li title="enif_get_double"><a href="erl_nif.html#enif_get_double">enif_get_double()
                </a></li>
<li title="enif_get_int"><a href="erl_nif.html#enif_get_int">enif_get_int()
                </a></li>
<li title="enif_get_int64"><a href="erl_nif.html#enif_get_int64">enif_get_int64()
                </a></li>
<li title="enif_get_local_pid"><a href="erl_nif.html#enif_get_local_pid">enif_get_local_pid()
                </a></li>
<li title="enif_get_list_cell"><a href="erl_nif.html#enif_get_list_cell">enif_get_list_cell()
                </a></li>
<li title="enif_get_list_length"><a href="erl_nif.html#enif_get_list_length">enif_get_list_length()
                </a></li>
<li title="enif_get_long"><a href="erl_nif.html#enif_get_long">enif_get_long()
                </a></li>
<li title="enif_get_map_size"><a href="erl_nif.html#enif_get_map_size">enif_get_map_size()
                </a></li>
<li title="enif_get_map_value"><a href="erl_nif.html#enif_get_map_value">enif_get_map_value()
                </a></li>
<li title="enif_get_resource"><a href="erl_nif.html#enif_get_resource">enif_get_resource()
                </a></li>
<li title="enif_get_string"><a href="erl_nif.html#enif_get_string">enif_get_string()
                </a></li>
<li title="enif_get_tuple"><a href="erl_nif.html#enif_get_tuple">enif_get_tuple()
                </a></li>
<li title="enif_get_uint"><a href="erl_nif.html#enif_get_uint">enif_get_uint()
                </a></li>
<li title="enif_get_uint64"><a href="erl_nif.html#enif_get_uint64">enif_get_uint64()
                </a></li>
<li title="enif_get_ulong"><a href="erl_nif.html#enif_get_ulong">enif_get_ulong()
                </a></li>
<li title="enif_getenv"><a href="erl_nif.html#enif_getenv">enif_getenv()
                </a></li>
<li title="enif_has_pending_exception"><a href="erl_nif.html#enif_has_pending_exception">enif_has_pending_exception()
                </a></li>
<li title="enif_inspect_binary"><a href="erl_nif.html#enif_inspect_binary">enif_inspect_binary()
                </a></li>
<li title="enif_inspect_iolist_as_binary"><a href="erl_nif.html#enif_inspect_iolist_as_binary">enif_inspect_iolist_as_binary()
                </a></li>
<li title="enif_is_atom"><a href="erl_nif.html#enif_is_atom">enif_is_atom()
                </a></li>
<li title="enif_is_binary"><a href="erl_nif.html#enif_is_binary">enif_is_binary()
                </a></li>
<li title="enif_is_empty_list"><a href="erl_nif.html#enif_is_empty_list">enif_is_empty_list()
                </a></li>
<li title="enif_is_exception"><a href="erl_nif.html#enif_is_exception">enif_is_exception()
                </a></li>
<li title="enif_is_map"><a href="erl_nif.html#enif_is_map">enif_is_map()
                </a></li>
<li title="enif_is_number"><a href="erl_nif.html#enif_is_number">enif_is_number()
                </a></li>
<li title="enif_is_fun"><a href="erl_nif.html#enif_is_fun">enif_is_fun()
                </a></li>
<li title="enif_is_identical"><a href="erl_nif.html#enif_is_identical">enif_is_identical()
                </a></li>
<li title="enif_is_on_dirty_scheduler"><a href="erl_nif.html#enif_is_on_dirty_scheduler">enif_is_on_dirty_scheduler()
                </a></li>
<li title="enif_is_pid"><a href="erl_nif.html#enif_is_pid">enif_is_pid()
                </a></li>
<li title="enif_is_port"><a href="erl_nif.html#enif_is_port">enif_is_port()
                </a></li>
<li title="enif_is_ref"><a href="erl_nif.html#enif_is_ref">enif_is_ref()
                </a></li>
<li title="enif_is_tuple"><a href="erl_nif.html#enif_is_tuple">enif_is_tuple()
                </a></li>
<li title="enif_is_list"><a href="erl_nif.html#enif_is_list">enif_is_list()
                </a></li>
<li title="enif_keep_resource"><a href="erl_nif.html#enif_keep_resource">enif_keep_resource()
                </a></li>
<li title="enif_make_atom"><a href="erl_nif.html#enif_make_atom">enif_make_atom()
                </a></li>
<li title="enif_make_atom_len"><a href="erl_nif.html#enif_make_atom_len">enif_make_atom_len()
                </a></li>
<li title="enif_make_badarg"><a href="erl_nif.html#enif_make_badarg">enif_make_badarg()
                </a></li>
<li title="enif_make_binary"><a href="erl_nif.html#enif_make_binary">enif_make_binary()
                </a></li>
<li title="enif_make_copy"><a href="erl_nif.html#enif_make_copy">enif_make_copy()
                </a></li>
<li title="enif_make_double"><a href="erl_nif.html#enif_make_double">enif_make_double()
                </a></li>
<li title="enif_make_existing_atom"><a href="erl_nif.html#enif_make_existing_atom">enif_make_existing_atom()
                </a></li>
<li title="enif_make_existing_atom_len"><a href="erl_nif.html#enif_make_existing_atom_len">enif_make_existing_atom_len()
                </a></li>
<li title="enif_make_int"><a href="erl_nif.html#enif_make_int">enif_make_int()
                </a></li>
<li title="enif_make_int64"><a href="erl_nif.html#enif_make_int64">enif_make_int64()
                </a></li>
<li title="enif_make_list"><a href="erl_nif.html#enif_make_list">enif_make_list()
                </a></li>
<li title="enif_make_list1"><a href="erl_nif.html#enif_make_list1">enif_make_list1()
                </a></li>
<li title="enif_make_list2"><a href="erl_nif.html#enif_make_list2">enif_make_list2()
                </a></li>
<li title="enif_make_list3"><a href="erl_nif.html#enif_make_list3">enif_make_list3()
                </a></li>
<li title="enif_make_list4"><a href="erl_nif.html#enif_make_list4">enif_make_list4()
                </a></li>
<li title="enif_make_list5"><a href="erl_nif.html#enif_make_list5">enif_make_list5()
                </a></li>
<li title="enif_make_list6"><a href="erl_nif.html#enif_make_list6">enif_make_list6()
                </a></li>
<li title="enif_make_list7"><a href="erl_nif.html#enif_make_list7">enif_make_list7()
                </a></li>
<li title="enif_make_list8"><a href="erl_nif.html#enif_make_list8">enif_make_list8()
                </a></li>
<li title="enif_make_list9"><a href="erl_nif.html#enif_make_list9">enif_make_list9()
                </a></li>
<li title="enif_make_list_cell"><a href="erl_nif.html#enif_make_list_cell">enif_make_list_cell()
                </a></li>
<li title="enif_make_list_from_array"><a href="erl_nif.html#enif_make_list_from_array">enif_make_list_from_array()
                </a></li>
<li title="enif_make_long"><a href="erl_nif.html#enif_make_long">enif_make_long()
                </a></li>
<li title="enif_make_new_binary"><a href="erl_nif.html#enif_make_new_binary">enif_make_new_binary()
                </a></li>
<li title="enif_make_new_map"><a href="erl_nif.html#enif_make_new_map">enif_make_new_map()
                </a></li>
<li title="enif_make_map_put"><a href="erl_nif.html#enif_make_map_put">enif_make_map_put()
                </a></li>
<li title="enif_make_map_update"><a href="erl_nif.html#enif_make_map_update">enif_make_map_update()
                </a></li>
<li title="enif_make_map_remove"><a href="erl_nif.html#enif_make_map_remove">enif_make_map_remove()
                </a></li>
<li title="enif_make_pid"><a href="erl_nif.html#enif_make_pid">enif_make_pid()
                </a></li>
<li title="enif_make_ref"><a href="erl_nif.html#enif_make_ref">enif_make_ref()
                </a></li>
<li title="enif_make_resource"><a href="erl_nif.html#enif_make_resource">enif_make_resource()
                </a></li>
<li title="enif_make_resource_binary"><a href="erl_nif.html#enif_make_resource_binary">enif_make_resource_binary()
                </a></li>
<li title="enif_make_reverse_list"><a href="erl_nif.html#enif_make_reverse_list">enif_make_reverse_list()
                </a></li>
<li title="enif_make_string"><a href="erl_nif.html#enif_make_string">enif_make_string()
                </a></li>
<li title="enif_make_string_len"><a href="erl_nif.html#enif_make_string_len">enif_make_string_len()
                </a></li>
<li title="enif_make_sub_binary"><a href="erl_nif.html#enif_make_sub_binary">enif_make_sub_binary()
                </a></li>
<li title="enif_make_tuple"><a href="erl_nif.html#enif_make_tuple">enif_make_tuple()
                </a></li>
<li title="enif_make_tuple1"><a href="erl_nif.html#enif_make_tuple1">enif_make_tuple1()
                </a></li>
<li title="enif_make_tuple2"><a href="erl_nif.html#enif_make_tuple2">enif_make_tuple2()
                </a></li>
<li title="enif_make_tuple3"><a href="erl_nif.html#enif_make_tuple3">enif_make_tuple3()
                </a></li>
<li title="enif_make_tuple4"><a href="erl_nif.html#enif_make_tuple4">enif_make_tuple4()
                </a></li>
<li title="enif_make_tuple5"><a href="erl_nif.html#enif_make_tuple5">enif_make_tuple5()
                </a></li>
<li title="enif_make_tuple6"><a href="erl_nif.html#enif_make_tuple6">enif_make_tuple6()
                </a></li>
<li title="enif_make_tuple7"><a href="erl_nif.html#enif_make_tuple7">enif_make_tuple7()
                </a></li>
<li title="enif_make_tuple8"><a href="erl_nif.html#enif_make_tuple8">enif_make_tuple8()
                </a></li>
<li title="enif_make_tuple9"><a href="erl_nif.html#enif_make_tuple9">enif_make_tuple9()
                </a></li>
<li title="enif_make_tuple_from_array"><a href="erl_nif.html#enif_make_tuple_from_array">enif_make_tuple_from_array()
                </a></li>
<li title="enif_make_uint"><a href="erl_nif.html#enif_make_uint">enif_make_uint()
                </a></li>
<li title="enif_make_uint64"><a href="erl_nif.html#enif_make_uint64">enif_make_uint64()
                </a></li>
<li title="enif_make_ulong"><a href="erl_nif.html#enif_make_ulong">enif_make_ulong()
                </a></li>
<li title="enif_map_iterator_create"><a href="erl_nif.html#enif_map_iterator_create">enif_map_iterator_create()
                </a></li>
<li title="enif_map_iterator_destroy"><a href="erl_nif.html#enif_map_iterator_destroy">enif_map_iterator_destroy()
                </a></li>
<li title="enif_map_iterator_get_pair"><a href="erl_nif.html#enif_map_iterator_get_pair">enif_map_iterator_get_pair()
                </a></li>
<li title="enif_map_iterator_is_head"><a href="erl_nif.html#enif_map_iterator_is_head">enif_map_iterator_is_head()
                </a></li>
<li title="enif_map_iterator_is_tail"><a href="erl_nif.html#enif_map_iterator_is_tail">enif_map_iterator_is_tail()
                </a></li>
<li title="enif_map_iterator_next"><a href="erl_nif.html#enif_map_iterator_next">enif_map_iterator_next()
                </a></li>
<li title="enif_map_iterator_prev"><a href="erl_nif.html#enif_map_iterator_prev">enif_map_iterator_prev()
                </a></li>
<li title="enif_mutex_create"><a href="erl_nif.html#enif_mutex_create">enif_mutex_create()
                </a></li>
<li title="enif_mutex_destroy"><a href="erl_nif.html#enif_mutex_destroy">enif_mutex_destroy()
                </a></li>
<li title="enif_mutex_lock"><a href="erl_nif.html#enif_mutex_lock">enif_mutex_lock()
                </a></li>
<li title="enif_mutex_trylock"><a href="erl_nif.html#enif_mutex_trylock">enif_mutex_trylock()
                </a></li>
<li title="enif_mutex_unlock"><a href="erl_nif.html#enif_mutex_unlock">enif_mutex_unlock()
                </a></li>
<li title="enif_open_resource_type"><a href="erl_nif.html#enif_open_resource_type">enif_open_resource_type()
                </a></li>
<li title="enif_priv_data"><a href="erl_nif.html#enif_priv_data">enif_priv_data()
                </a></li>
<li title="enif_raise_exception"><a href="erl_nif.html#enif_raise_exception">enif_raise_exception()
                </a></li>
<li title="enif_realloc_binary"><a href="erl_nif.html#enif_realloc_binary">enif_realloc_binary()
                </a></li>
<li title="enif_release_binary"><a href="erl_nif.html#enif_release_binary">enif_release_binary()
                </a></li>
<li title="enif_release_resource"><a href="erl_nif.html#enif_release_resource">enif_release_resource()
                </a></li>
<li title="enif_rwlock_create"><a href="erl_nif.html#enif_rwlock_create">enif_rwlock_create()
                </a></li>
<li title="enif_rwlock_destroy"><a href="erl_nif.html#enif_rwlock_destroy">enif_rwlock_destroy()
                </a></li>
<li title="enif_rwlock_rlock"><a href="erl_nif.html#enif_rwlock_rlock">enif_rwlock_rlock()
                </a></li>
<li title="enif_rwlock_runlock"><a href="erl_nif.html#enif_rwlock_runlock">enif_rwlock_runlock()
                </a></li>
<li title="enif_rwlock_rwlock"><a href="erl_nif.html#enif_rwlock_rwlock">enif_rwlock_rwlock()
                </a></li>
<li title="enif_rwlock_rwunlock"><a href="erl_nif.html#enif_rwlock_rwunlock">enif_rwlock_rwunlock()
                </a></li>
<li title="enif_rwlock_tryrlock"><a href="erl_nif.html#enif_rwlock_tryrlock">enif_rwlock_tryrlock()
                </a></li>
<li title="enif_rwlock_tryrwlock"><a href="erl_nif.html#enif_rwlock_tryrwlock">enif_rwlock_tryrwlock()
                </a></li>
<li title="enif_schedule_nif"><a href="erl_nif.html#enif_schedule_nif">enif_schedule_nif()
                </a></li>
<li title="enif_self"><a href="erl_nif.html#enif_self">enif_self()
                </a></li>
<li title="enif_send"><a href="erl_nif.html#enif_send">enif_send()
                </a></li>
<li title="enif_sizeof_resource"><a href="erl_nif.html#enif_sizeof_resource">enif_sizeof_resource()
                </a></li>
<li title="enif_system_info"><a href="erl_nif.html#enif_system_info">enif_system_info()
                </a></li>
<li title="enif_thread_create"><a href="erl_nif.html#enif_thread_create">enif_thread_create()
                </a></li>
<li title="enif_thread_exit"><a href="erl_nif.html#enif_thread_exit">enif_thread_exit()
                </a></li>
<li title="enif_thread_join"><a href="erl_nif.html#enif_thread_join">enif_thread_join()
                </a></li>
<li title="enif_thread_opts_create"><a href="erl_nif.html#enif_thread_opts_create">enif_thread_opts_create()
                </a></li>
<li title="enif_thread_opts_destroy"><a href="erl_nif.html#enif_thread_opts_destroy">enif_thread_opts_destroy()
                </a></li>
<li title="enif_thread_self"><a href="erl_nif.html#enif_thread_self">enif_thread_self()
                </a></li>
<li title="enif_tsd_key_create"><a href="erl_nif.html#enif_tsd_key_create">enif_tsd_key_create()
                </a></li>
<li title="enif_tsd_key_destroy"><a href="erl_nif.html#enif_tsd_key_destroy">enif_tsd_key_destroy()
                </a></li>
<li title="enif_tsd_get"><a href="erl_nif.html#enif_tsd_get">enif_tsd_get()
                </a></li>
<li title="enif_tsd_set"><a href="erl_nif.html#enif_tsd_set">enif_tsd_set()
                </a></li>
<li title="enif_monotonic_time"><a href="erl_nif.html#enif_monotonic_time">enif_monotonic_time()
                </a></li>
<li title="enif_time_offset"><a href="erl_nif.html#enif_time_offset">enif_time_offset()
                </a></li>
<li title="enif_convert_time_unit"><a href="erl_nif.html#enif_convert_time_unit">enif_convert_time_unit()
                </a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>erl_nif</h1></center>
  
  <h3>C LIBRARY</h3>
<div class="REFBODY">erl_nif</div>
  <h3>LIBRARY SUMMARY</h3>
<div class="REFBODY">API functions for an Erlang NIF library</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>A NIF library contains native implementation of some functions
    of an Erlang module. The native implemented functions (NIFs) are
    called like any other functions without any difference to the
    caller. Each NIF must also have an implementation in Erlang that
    will be invoked if the function is called before the NIF library
    has been successfully loaded. A typical such stub implementation
    is to throw an exception. But it can also be used as a fallback
    implementation if the NIF library is not implemented for some
    architecture.</p>     
    <a name="WARNING"></a>
      <div class="warning">
<div class="label">Warning</div>
<div class="content"><p><p><strong>Use this functionality with extreme care!</strong></p>
      <p>A native function is executed as a direct extension of the
      native code of the VM. Execution is not made in a safe environment.
      The VM can <strong>not</strong> provide the same services as provided when
      executing Erlang code, such as preemptive scheduling or memory
      protection. If the native function doesn't behave well, the whole
      VM will misbehave.</p>
      <ul>
	<li><p>A native function that crash will crash the whole VM.</p></li>
	<li><p>An erroneously implemented native function might cause
	a VM internal state inconsistency which may cause a crash of the VM,
	or miscellaneous misbehaviors of the VM at any point after the call
	to the native function.</p></li>
	<li><p>A native function that do <span class="bold_code"><a href="#lengthy_work">lengthy
	work</a></span> before returning will degrade responsiveness of the VM,
	and may cause miscellaneous strange behaviors. Such strange behaviors
	include, but are not limited to, extreme memory usage, and bad load
	balancing between schedulers. Strange behaviors that might occur due
	to lengthy work may also vary between OTP releases.</p></li>
      </ul>
      </p></div>
</div>

    <p>A minimal example of a NIF library can look like this:</p>
      <p></p>
      <div class="example"><pre>
/* niftest.c */
#include "erl_nif.h"

static ERL_NIF_TERM hello(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    return enif_make_string(env, "Hello world!", ERL_NIF_LATIN1);
}

static ErlNifFunc nif_funcs[] =
{
    {"hello", 0, hello}
};

ERL_NIF_INIT(niftest,nif_funcs,NULL,NULL,NULL,NULL)
</pre></div>

    <p>and the Erlang module would have to look something like
    this:</p>
      <p></p>
      <div class="example"><pre>
-module(niftest).

-export([init/0, hello/0]).

init() -&gt;
      erlang:load_nif("./niftest", 0).

hello() -&gt;
      "NIF library not loaded".
</pre></div>
    <p>and compile and test something like this (on Linux):</p>
      <p></p>
      <div class="example"><pre>
$&gt; gcc -fPIC -shared -o niftest.so niftest.c -I $ERL_ROOT/usr/include/
$&gt; erl

1&gt; c(niftest).
{ok,niftest}
2&gt; niftest:hello().
"NIF library not loaded"
3&gt; niftest:init().
ok
4&gt; niftest:hello().
"Hello world!"
</pre></div>

     <p>A better solution for a real module is to take advantage of
     the new directive <span class="bold_code"><a href="../reference_manual/code_loading.html#on_load">on_load</a></span> to automatically
     load the NIF library when the module is loaded.</p>
     <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>A NIF does not have to be exported, it can be local to the module.
     Note however that unused local stub functions will be optimized
     away by the compiler causing loading of the NIF library to fail.</p>
    </p></div>
</div>
     <p>A loaded NIF library is tied to the Erlang module code version
     that loaded it. If the module is upgraded with a new version, the
     new Erlang code will have to load its own NIF library (or maybe choose not
     to). The new code version can however choose to load the exact
     same NIF library as the old code if it wants to. Sharing the same
     dynamic library will mean that static data defined by the library
     will be shared as well. To avoid unintentionally shared static
     data, each Erlang module code can keep its own private data. This
     private data can be set when the NIF library is loaded and
     then retrieved by calling <span class="bold_code"><a href="#enif_priv_data">enif_priv_data</a></span>.</p>
    <p>There is no way to explicitly unload a NIF library. A library will be
     automatically unloaded when the module code that it belongs to is purged
     by the code server.</p>

     <p><a name="lengthy_work"></a>
     As mentioned in the <span class="bold_code"><a href="#WARNING">warning</a></span> text at
     the beginning of this document it is of vital importance that a native function
     return relatively quickly. It is hard to give an exact maximum amount
     of time that a native function is allowed to work, but as a rule of thumb
     a well-behaving native function should return to its caller before a
     millisecond has passed. This can be achieved using different approaches.
     If you have full control over the code to execute in the native
     function, the best approach is to divide the work into multiple chunks of
     work and call the native function multiple times, either directly from Erlang code
     or by having a native function schedule a future NIF call via the
     <span class="bold_code"><a href="#enif_schedule_nif"> enif_schedule_nif</a></span> function. Function
     <span class="bold_code"><a href="#enif_consume_timeslice">enif_consume_timeslice</a></span> can be
     used to help with such work division. In some cases, however, this might not
     be possible, e.g. when calling third-party libraries. Then you typically want
     to dispatch the work to another thread, return
     from the native function, and wait for the result. The thread can send
     the result back to the calling thread using message passing. Information
     about thread primitives can be found below. If you have built your system
     with <strong>the currently experimental</strong> support for dirty schedulers,
     you may want to try out this functionality by dispatching the work to a
     <span class="bold_code"><a href="#dirty_nifs">dirty NIF</a></span>,
     which does not have the same duration restriction as a normal NIF.</p>
  </p></div>
  <h3><a name="id197653">FUNCTIONALITY</a></h3>
<div class="REFBODY">
  
  <p>All functions that a NIF library needs to do with Erlang are
      performed through the NIF API functions. There are functions
      for the following functionality:</p>
    <dl>
      <dt><strong>Read and write Erlang terms</strong></dt>
      <dd>
<p>Any Erlang terms can be passed to a NIF as function arguments and
      be returned as function return values. The terms are of C-type
      <span class="bold_code"><a href="#ERL_NIF_TERM">ERL_NIF_TERM</a></span>
      and can only be read or written using API functions. Most functions to read
      the content of a term are prefixed <span class="code">enif_get_</span> and usually return
      true (or false) if the term was of the expected type (or not).    
      The functions to write terms are all prefixed <span class="code">enif_make_</span> and usually
      return the created <span class="code">ERL_NIF_TERM</span>. There are also some functions
      to query terms, like <span class="code">enif_is_atom</span>, <span class="code">enif_is_identical</span> and
      <span class="code">enif_compare</span>.</p>
      <p>All terms of type <span class="code">ERL_NIF_TERM</span> belong to an environment of type
      <span class="bold_code"><a href="#ErlNifEnv">ErlNifEnv</a></span>. The lifetime of a term is
      controlled by the lifetime of its environment object. All API functions that read
      or write terms has the environment, that the term belongs to, as the first
      function argument.</p>
</dd>
      <dt><strong>Binaries</strong></dt>
      <dd>
<p>Terms of type binary are accessed with the help of the struct type
      <span class="bold_code"><a href="#ErlNifBinary">ErlNifBinary</a></span>    
      that contains a pointer (<span class="code">data</span>) to the raw binary data and the length
      (<span class="code">size</span>) of the data in bytes. Both <span class="code">data</span> and <span class="code">size</span> are
      read-only and should only be written using calls to API functions.
      Instances of <span class="code">ErlNifBinary</span> are however always allocated by the user
      (usually as local variables).</p>
      <p>The raw data pointed to by <span class="code">data</span> is only mutable after a call to
      <span class="bold_code"><a href="#enif_alloc_binary">enif_alloc_binary</a></span> or
      <span class="bold_code"><a href="#enif_realloc_binary">enif_realloc_binary</a></span>.
      All other functions that operates on a binary will leave the data as read-only.
      A mutable binary must in the end either be freed with
      <span class="bold_code"><a href="#enif_release_binary">enif_release_binary</a></span>
      or made read-only by transferring it to an Erlang term with
      <span class="bold_code"><a href="#enif_make_binary">enif_make_binary</a></span>.
      But it does not have to happen in the same NIF call. Read-only binaries
      do not have to be released.</p>
      <p><span class="bold_code"><a href="#enif_make_new_binary">enif_make_new_binary</a></span>
      can be used as a shortcut to allocate and return a binary in the same NIF call.</p>
      <p>Binaries are sequences of whole bytes. Bitstrings with an arbitrary
      bit length have no support yet.</p>
       </dd>
      <dt><strong>Resource objects</strong></dt>
      <dd>
<p>The use of resource objects is a safe way to return pointers to
      native data structures from a NIF. A resource object is
      just a block of memory allocated with
      <span class="bold_code"><a href="#enif_alloc_resource">enif_alloc_resource</a></span>.
      A handle ("safe pointer") to this memory block can then be returned to Erlang by the use of
      <span class="bold_code"><a href="#enif_make_resource">enif_make_resource</a></span>.
      The term returned by <span class="code">enif_make_resource</span>
      is totally opaque in nature. It can be stored and passed between processes
      on the same node, but the only real end usage is to pass it back as an argument to a NIF.
      The NIF can then call <span class="bold_code"><a href="#enif_get_resource">enif_get_resource</a></span>
      and get back a pointer to the memory block that is guaranteed to still be
      valid. A resource object will not be deallocated until the last handle term
      has been garbage collected by the VM and the resource has been
      released with <span class="bold_code"><a href="#enif_release_resource">enif_release_resource</a></span>
      (not necessarily in that order).</p>      
      <p>All resource objects are created as instances of some <strong>resource type</strong>.
      This makes resources from different modules to be distinguishable. 
      A resource type is created by calling
      <span class="bold_code"><a href="#enif_open_resource_type">enif_open_resource_type</a></span>
      when a library is loaded. Objects of that resource type can then later be allocated
      and <span class="code">enif_get_resource</span> verifies that the resource is of the expected type.
      A resource type can have a user supplied destructor function that is
      automatically called when resources of that type are released (by either
      the garbage collector or <span class="code">enif_release_resource</span>). Resource types
      are uniquely identified by a supplied name string and the name of the
      implementing module.</p>
      <a name="enif_resource_example"></a><p>Here is a template example of how to create and return a resource object.</p>
      <p></p>
      <div class="example"><pre>
    ERL_NIF_TERM term;
    MyStruct* obj = enif_alloc_resource(my_resource_type, sizeof(MyStruct));

    /* initialize struct ... */

    term = enif_make_resource(env, obj);

    if (keep_a_reference_of_our_own) {
        /* store 'obj' in static variable, private data or other resource object */
    }
    else {
        enif_release_resource(obj);
        /* resource now only owned by "Erlang" */
    }
    return term;
    </pre></div>
      <p>Note that once <span class="code">enif_make_resource</span> creates the term to
      return to Erlang, the code can choose to either keep its own
      native pointer to the allocated struct and release it later, or
      release it immediately and rely solely on the garbage collector
      to eventually deallocate the resource object when it collects
      the term.</p> 
      <p>Another usage of resource objects is to create binary terms with
      user defined memory management.
      <span class="bold_code"><a href="#enif_make_resource_binary">enif_make_resource_binary</a></span>
      will create a binary term that is connected to a resource object. The
      destructor of the resource will be called when the binary is garbage
      collected, at which time the binary data can be released. An example of
      this can be a binary term consisting of data from a <span class="code">mmap</span>'ed file.
      The destructor can then do <span class="code">munmap</span> to release the memory
      region.</p>
      <p>Resource types support upgrade in runtime by allowing a loaded NIF
      library to takeover an already existing resource type and thereby
      "inherit" all existing objects of that type. The destructor of the new
      library will thereafter be called for the inherited objects and the
      library with the old destructor function can be safely unloaded. Existing
      resource objects, of a module that is upgraded, must either be deleted
      or taken over by the new NIF library. The unloading of a library will be
      postponed as long as there exist resource objects with a destructor
      function in the library.
      </p>
      </dd>
      <dt><strong>Threads and concurrency</strong></dt>
      <dd>
<p>A NIF is thread-safe without any explicit synchronization as
      long as it acts as a pure function and only reads the supplied
      arguments. As soon as you write towards a shared state either through
      static variables or <span class="bold_code"><a href="#enif_priv_data">enif_priv_data</a></span>
      you need to supply your own explicit synchronization. This includes terms
      in process independent environments that are shared between threads.
      Resource objects will also require synchronization if you treat them as
      mutable.</p>
      <p>The library initialization callbacks <span class="code">load</span>, <span class="code">reload</span> and
      <span class="code">upgrade</span> are all thread-safe even for shared state data.</p>
      </dd>

      <dt><strong><a name="version_management"></a>Version Management</strong></dt>
      <dd>
<p>
      When a NIF library is built, information about NIF API version
      is compiled into the library. When a NIF library is loaded the
      runtime system verifies that the library is of a compatible version.
      <span class="code">erl_nif.h</span> defines <span class="code">ERL_NIF_MAJOR_VERSION</span>, and
      <span class="code">ERL_NIF_MINOR_VERSION</span>. <span class="code">ERL_NIF_MAJOR_VERSION</span> will be
      incremented when NIF library incompatible changes are made to the
      Erlang runtime system. Normally it will suffice to recompile the NIF
      library when the <span class="code">ERL_NIF_MAJOR_VERSION</span> has changed, but it
      could, under rare circumstances, mean that NIF libraries have to
      be slightly modified. If so, this will of course be documented.
      <span class="code">ERL_NIF_MINOR_VERSION</span> will be incremented when
      new features are added. The runtime system uses the minor version
      to determine what features to use.
      </p>
<p>
      The runtime system will normally refuse to load a NIF library if
      the major versions differ, or if the major versions are equal and
      the minor version used by the NIF library is greater than the one
      used by the runtime system. Old NIF libraries with lower major
      versions will however be allowed after a bump of the major version
      during a transition period of two major releases. Such old NIF
      libraries might however fail if deprecated features are used.
      </p>
</dd>

      <dt><strong><a name="time_measurement"></a>Time Measurement</strong></dt>
      <dd>
<p>Support for time measurement in NIF libraries:
      <ul>
	<li><span class="bold_code"><a href="#ErlNifTime"><span class="code">ErlNifTime</span></a></span></li>
	<li><span class="bold_code"><a href="#ErlNifTimeUnit"><span class="code">ErlNifTimeUnit</span></a></span></li>
	<li><span class="bold_code"><a href="#enif_monotonic_time"><span class="code">enif_monotonic_time()</span></a></span></li>
	<li><span class="bold_code"><a href="#enif_time_offset"><span class="code">enif_time_offset()</span></a></span></li>
	<li><span class="bold_code"><a href="#enif_convert_time_unit"><span class="code">enif_convert_time_unit()</span></a></span></li>
      </ul></p>
      </dd>

      <dt><strong>Long-running NIFs</strong></dt>
      <dd>
<p><a name="dirty_nifs"></a>Native functions
      <span class="bold_code"><a href="#lengthy_work">
      must normally run quickly</a></span>, as explained earlier in this document. They
      generally should execute for no more than a millisecond. But not all native functions
      can execute so quickly; for example, functions that encrypt large blocks of data or
      perform lengthy file system operations can often run for tens of seconds or more.</p>
      <p>If the functionality of a long-running NIF can be split so that its work can be
      achieved through a series of shorter NIF calls, the application can either make that series
      of NIF calls from the Erlang level, or it can call a NIF that first performs a chunk of the
      work, then invokes the <span class="bold_code"><a href="#enif_schedule_nif">enif_schedule_nif</a></span>
      function to schedule another NIF call to perform the next chunk. The final call scheduled
      in this manner can then return the overall result. Breaking up a long-running function in
      this manner enables the VM to regain control between calls to the NIFs, thereby avoiding
      degraded responsiveness, scheduler load balancing problems, and other strange behaviours.</p>
      <p>A NIF that cannot be split and cannot execute in a millisecond or less is called a "dirty NIF"
      because it performs work that the Erlang runtime cannot handle cleanly.
      <strong>Note that the dirty NIF functionality described here is experimental</strong> and that you have to
      enable support for dirty schedulers when building OTP in order to try the functionality out.
      Applications that make use of such functions must indicate to the runtime that the functions are
      dirty so they can be handled specially. To schedule a dirty NIF for execution, the
      appropriate flags value can be set for the NIF in its <span class="bold_code"><a href="#ErlNifFunc">ErlNifFunc</a></span>
      entry, or the application can call <span class="bold_code"><a href="#enif_schedule_nif">enif_schedule_nif</a></span>,
      passing to it a pointer to the dirty NIF to be executed and indicating with the <span class="code">flags</span>
      argument whether it expects the operation to be CPU-bound or I/O-bound.</p>
      <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>Dirty NIF support is available only when the emulator is configured with dirty
      schedulers enabled. This feature is currently disabled by default. To determine whether
      the dirty NIF API is available, native code can check to see if the C preprocessor macro
      <span class="code">ERL_NIF_DIRTY_SCHEDULER_SUPPORT</span> is defined. Also, if the Erlang runtime was built
      without threading support, dirty schedulers are disabled. To check at runtime for the presence
      of dirty scheduler threads, code can use the <span class="bold_code"><a href="#enif_system_info"><span class="code">
      enif_system_info()</span></a></span> API function.</p></p></div>
</div>
      </dd>
    </dl>
  </div>
  <h3><a name="id198164">INITIALIZATION</a></h3>
<div class="REFBODY">
    
    <dl>
      <dt><strong><a name="ERL_NIF_INIT"></a>ERL_NIF_INIT(MODULE, ErlNifFunc funcs[], load, reload, upgrade, unload)</strong></dt>
      <dd>
<p>This is the magic macro to initialize a NIF library. It
      should be evaluated in global file scope.</p>
      <p><span class="code">MODULE</span> is the name of the Erlang module as an
      identifier without string quotations. It will be stringified by
      the macro.</p>
      <p><span class="code">funcs</span> is a static array of function descriptors for
      all the implemented NIFs in this library.</p>
      <p><span class="code">load</span>, <span class="code">reload</span>, <span class="code">upgrade</span> and <span class="code">unload</span>
      are pointers to functions. One of <span class="code">load</span>, <span class="code">reload</span> or
      <span class="code">upgrade</span> will be called to initialize the library.
      <span class="code">unload</span> is called to release the library. They are all
      described individually below.</p>
      <p>If compiling a nif for static inclusion via --enable-static-nifs you
      have to define STATIC_ERLANG_NIF before the ERL_NIF_INIT declaration.</p>
      </dd>

      <dt><strong><a name="load"></a>int (*load)(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info)</strong></dt>
       <dd>
<p><span class="code">load</span> is called when the NIF library is loaded
        and there is no previously loaded library for this module.</p>
        <p><span class="code">*priv_data</span> can be set to point to some private data
           that the library needs in order to keep a state between NIF
           calls. <span class="code">enif_priv_data</span> will return this pointer.
           <span class="code">*priv_data</span> will be initialized to NULL when <span class="code">load</span> is
           called.</p> 
        <p><span class="code">load_info</span> is the second argument to <span class="bold_code"><a href="erlang.html#load_nif-2">erlang:load_nif/2</a></span>.</p>
        <p>The library will fail to load if <span class="code">load</span> returns
           anything other than 0. <span class="code">load</span> can be NULL in case no
           initialization is needed.</p> 
       </dd>

      <dt><strong><a name="upgrade"></a>int (*upgrade)(ErlNifEnv* env, void** priv_data, void** old_priv_data, ERL_NIF_TERM load_info)</strong></dt>
       <dd>
<p><span class="code">upgrade</span> is called when the NIF library is loaded
        and there is old code of this module with a loaded NIF library.</p>
        <p>Works the same as <span class="code">load</span>. The only difference is that
        <span class="code">*old_priv_data</span> already contains the value set by the
         last call to <span class="code">load</span> or <span class="code">reload</span> for the old module
         code. <span class="code">*priv_data</span> will be initialized to NULL when <span class="code">upgrade</span>
         is called. It is allowed to write to both *priv_data and *old_priv_data.</p> 
        <p>The library will fail to load if <span class="code">upgrade</span> returns
           anything other than 0 or if <span class="code">upgrade</span> is NULL.</p>
      </dd>

      <dt><strong><a name="unload"></a>void (*unload)(ErlNifEnv* env, void* priv_data)</strong></dt>
       <dd>
<p><span class="code">unload</span> is called when the module code that
       the NIF library belongs to is purged as old. New code
       of the same module may or may not exist. Note that <span class="code">unload</span> is not
       called for a replaced library as a consequence of <span class="code">reload</span>.</p>
      </dd>

      <dt><strong><a name="reload"></a>int (*reload)(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info)</strong></dt>
     <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>The reload mechanism is <strong>deprecated</strong>. It was only intended
     as a development feature. Do not use it as an upgrade method for
     live production systems. It might be removed in future releases. Be sure
     to pass <span class="code">reload</span> as <span class="code">NULL</span> to <span class="bold_code"><a href="#ERL_NIF_INIT">ERL_NIF_INIT</a></span>
     to disable it when not used.</p>
     </p></div>
</div>
       <dd>
<p><span class="code">reload</span> is called when the NIF library is loaded
        and there is already a previously loaded library for this
        module code.</p>
        <p>Works the same as <span class="code">load</span>. The only difference is that
        <span class="code">*priv_data</span> already contains the value set by the
        previous call to <span class="code">load</span> or <span class="code">reload</span>.</p>
        <p>The library will fail to load if <span class="code">reload</span> returns
           anything other than 0 or if <span class="code">reload</span> is NULL.</p> 
      </dd>

    </dl>
  </div>

  <h3><a name="id198455">DATA TYPES</a></h3>
<div class="REFBODY">
    

    <dl>
      <dt><strong><a name="ERL_NIF_TERM"></a>ERL_NIF_TERM</strong></dt>
       <dd>
        <p>Variables of type <span class="code">ERL_NIF_TERM</span> can refer to any Erlang term.
        This is an opaque type and values of it can only by used either as
        arguments to API functions or as return values from NIFs. All
        <span class="code">ERL_NIF_TERM</span>'s belong to an environment
        (<span class="bold_code"><a href="#ErlNifEnv">ErlNifEnv</a></span>). A term can not be
        destructed individually, it is valid until its environment is destructed.</p>
      </dd>
     <dt><strong><a name="ErlNifEnv"></a>ErlNifEnv</strong></dt>
      <dd>
        <p><span class="code">ErlNifEnv</span> represents an environment that can host Erlang terms.
        All terms in an environment are valid as long as the environment is valid.
        <span class="code">ErlNifEnv</span> is an opaque type and pointers to it can only be passed
        on to API functions. There are two types of environments; process
        bound and process independent.</p>
        <p>A <strong>process bound environment</strong> is passed as the first argument to all NIFs.
        All function arguments passed to a NIF will belong to that environment.
        The return value from a NIF must also be a term belonging to the same
        environment.
        In addition a process bound environment contains transient information
        about the calling Erlang process. The environment is only valid in the 
        thread where it was supplied as argument until the NIF returns. It is
        thus useless and dangerous to store pointers to process bound
        environments between NIF calls. </p>
        <p>A <strong>process independent environment</strong> is created by calling
        <span class="bold_code"><a href="#enif_alloc_env">enif_alloc_env</a></span>. It can be
        used to store terms between NIF calls and to send terms with
        <span class="bold_code"><a href="#enif_send">enif_send</a></span>. A process
        independent environment with all its terms is valid until you explicitly
        invalidates it with <span class="bold_code"><a href="#enif_free_env">enif_free_env</a></span>
        or <span class="code">enif_send</span>.</p>
        <p>All contained terms of a list/tuple/map must belong to the same
	environment as the list/tuple/map itself. Terms can be copied between
	environments with
        <span class="bold_code"><a href="#enif_make_copy">enif_make_copy</a></span>.</p>
      </dd>
    <dt><strong><a name="ErlNifFunc"></a>ErlNifFunc</strong></dt>
     <dd>
      <p></p>
      <div class="example"><pre>
typedef struct {
    const char* <strong>name</strong>;
    unsigned <strong>arity</strong>;
    ERL_NIF_TERM (*<strong>fptr</strong>)(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
    unsigned flags;
} ErlNifFunc;
</pre></div>
        <p>Describes a NIF by its name, arity and implementation.
        <span class="code">fptr</span> is a pointer to the function that implements the
        NIF. The argument <span class="code">argv</span> of a NIF will contain the
        function arguments passed to the NIF and <span class="code">argc</span> is the
        length of the array, i.e. the function arity. <span class="code">argv[N-1]</span>
        will thus denote the Nth argument to the NIF. Note that the
        <span class="code">argc</span> argument allows for the same C function to
        implement several Erlang functions with different arity (but
        same name probably). For a regular NIF, <span class="code">flags</span> is 0 (and
        so its value can be omitted for statically initialized <span class="code">ErlNifFunc</span>
        instances), or it can be used to indicate that the NIF is a <span class="bold_code"><a href="#dirty_nifs">dirty NIF</a></span> that should be executed
        on a dirty scheduler thread (<strong>note that the dirty NIF functionality
        described here is experimental</strong> and that you have to enable
        support for dirty schedulers when building OTP in order to try the
        functionality out). If the dirty NIF is expected to be
        CPU-bound, its <span class="code">flags</span> field should be set to
        <span class="code">ERL_NIF_DIRTY_JOB_CPU_BOUND</span>, or for I/O-bound jobs,
        <span class="code">ERL_NIF_DIRTY_JOB_IO_BOUND</span>.</p>
      </dd>
    <dt><strong><a name="ErlNifBinary"></a>ErlNifBinary</strong></dt>
     <dd>
      <p></p>
      <div class="example"><pre>
typedef struct {
    unsigned <strong>size</strong>;
    unsigned char* <strong>data</strong>;
} ErlNifBinary;
</pre></div>
        <p><span class="code">ErlNifBinary</span> contains transient information about an
          inspected binary term. <span class="code">data</span> is a pointer to a buffer
          of <span class="code">size</span> bytes with the raw content of the binary.</p>
          <p>Note that <span class="code">ErlNifBinary</span> is a semi-opaque type and you are
          only allowed to read fields <span class="code">size</span> and <span class="code">data</span>.</p>
      </dd>
      <dt><strong><a name="ErlNifPid"></a>ErlNifPid</strong></dt>
       <dd>
          <p><span class="code">ErlNifPid</span> is a process identifier (pid). In contrast to
          pid terms (instances of <span class="code">ERL_NIF_TERM</span>), <span class="code">ErlNifPid</span>'s are self
          contained and not bound to any
          <span class="bold_code"><a href="#ErlNifEnv">environment</a></span>. <span class="code">ErlNifPid</span>
          is an opaque type.</p>
        </dd>

      <dt><strong><a name="ErlNifResourceType"></a>ErlNifResourceType</strong></dt>
       <dd>
          <p>Each instance of <span class="code">ErlNifResourceType</span> represent a class of
          memory managed resource objects that can be garbage collected.
          Each resource type has a unique name and a destructor function that
          is called when objects of its type are released.</p>
        </dd>
        <dt><strong><a name="ErlNifResourceDtor"></a>ErlNifResourceDtor</strong></dt>
         <dd>
           <p></p>
           <div class="example"><pre>
typedef void ErlNifResourceDtor(ErlNifEnv* env, void* obj);
</pre></div>
            <p>The function prototype of a resource destructor function.
            A destructor function is not allowed to call any term-making functions.</p>
          </dd>
          <dt><strong><a name="ErlNifCharEncoding"></a>ErlNifCharEncoding</strong></dt>
           <dd>
             <p></p>
             <div class="example"><pre>
typedef enum {
    ERL_NIF_LATIN1
}ErlNifCharEncoding;
</pre></div>
              <p>The character encoding used in strings and atoms. The only
              supported encoding is currently <span class="code">ERL_NIF_LATIN1</span> for
              iso-latin-1 (8-bit ascii).</p>
            </dd>
            <dt><strong><a name="ErlNifSysInfo"></a>ErlNifSysInfo</strong></dt>
             <dd>
                <p>Used by <span class="bold_code"><a href="#enif_system_info">enif_system_info</a></span>
                to return information about the runtime system. Contains currently
                the exact same content as <span class="bold_code"><a href="erl_driver.html#ErlDrvSysInfo">ErlDrvSysInfo</a></span>.</p>
              </dd>
              <dt><strong><a name="ErlNifSInt64"></a>ErlNifSInt64</strong></dt>
               <dd><p>A native signed 64-bit integer type.</p></dd>
              <dt><strong><a name="ErlNifUInt64"></a>ErlNifUInt64</strong></dt>
               <dd><p>A native unsigned 64-bit integer type.</p></dd>
	       
      <dt><strong><a name="ErlNifTime"></a>ErlNifTime</strong></dt>
      <dd>
        <p>A signed 64-bit integer type for representation of time.</p>
      </dd>
      <dt><strong><a name="ErlNifTimeUnit"></a>ErlNifTimeUnit</strong></dt>
      <dd>
        <p>An enumeration of time units supported by the NIF API:</p>
	<dl>
	  <dt><strong><span class="code">ERL_NIF_SEC</span></strong></dt>
	  <dd><p>Seconds</p></dd>
	  <dt><strong><span class="code">ERL_NIF_MSEC</span></strong></dt>
	  <dd><p>Milliseconds</p></dd>
	  <dt><strong><span class="code">ERL_NIF_USEC</span></strong></dt>
	  <dd><p>Microseconds</p></dd>
	  <dt><strong><span class="code">ERL_NIF_NSEC</span></strong></dt>
	  <dd><p>Nanoseconds</p></dd>
	</dl>
      </dd>

    </dl>
  </div>

  <h3>EXPORTS</h3>
    <p><a name="enif_alloc"><span class="bold_code">void *enif_alloc(size_t size)</span></a><br></p>
<div class="REFBODY"><p><p>Allocate memory of <span class="code">size</span> bytes. Return NULL if allocation failed.</p></p></div>
    <p><a name="enif_alloc_binary"><span class="bold_code">int enif_alloc_binary(size_t size, ErlNifBinary* bin)</span></a><br></p>
<div class="REFBODY"><p><p>Allocate a new binary of size <span class="code">size</span>
      bytes. Initialize the structure pointed to by <span class="code">bin</span> to
      refer to the allocated binary. The binary must either be released by 
      <span class="bold_code"><a href="#enif_release_binary">enif_release_binary</a></span> 
      or ownership transferred to an Erlang term with 
      <span class="bold_code"><a href="#enif_make_binary">enif_make_binary</a></span>. 
      An allocated (and owned) <span class="code">ErlNifBinary</span> can be kept between NIF
      calls.</p>
        <p>Return true on success or false if allocation failed.</p>
      </p></div>
    <p><a name="enif_alloc_env"><span class="bold_code">ErlNifEnv *enif_alloc_env()</span></a><br></p>
<div class="REFBODY"><p><p>Allocate a new process independent environment. The environment can
      be used to hold terms that is not bound to any process. Such terms can
      later be copied to a process environment with
      <span class="bold_code"><a href="#enif_make_copy">enif_make_copy</a></span>
      or be sent to a process as a message with <span class="bold_code"><a href="#enif_send">enif_send</a></span>.</p>
      <p>Return pointer to the new environment.</p>
      </p></div>
    <p><a name="enif_alloc_resource"><span class="bold_code">void *enif_alloc_resource(ErlNifResourceType* type, unsigned size)</span></a><br></p>
<div class="REFBODY"><p><p>Allocate a memory managed resource object of type <span class="code">type</span> and size <span class="code">size</span> bytes.</p></p></div>
    <p><a name="enif_clear_env"><span class="bold_code">void enif_clear_env(ErlNifEnv* env)</span></a><br></p>
<div class="REFBODY"><p><p>Free all terms in an environment and clear it for reuse. The environment must
      have been allocated with <span class="bold_code"><a href="#enif_alloc_env">enif_alloc_env</a></span>.
      </p></p></div>
    <p><a name="enif_compare"><span class="bold_code">int enif_compare(ERL_NIF_TERM lhs, ERL_NIF_TERM rhs)</span></a><br></p>
<div class="REFBODY"><p><p>Return an integer less than, equal to, or greater than
      zero if <span class="code">lhs</span> is found, respectively, to be less than,
      equal, or greater than <span class="code">rhs</span>. Corresponds to the Erlang
      operators <span class="code">==</span>, <span class="code">/=</span>, <span class="code">=&lt;</span>, <span class="code">&lt;</span>,
      <span class="code">&gt;=</span> and <span class="code">&gt;</span> (but <strong>not</strong> <span class="code">=:=</span> or <span class="code">=/=</span>).</p></p></div>
    <p><a name="enif_cond_broadcast"><span class="bold_code">void enif_cond_broadcast(ErlNifCond *cnd)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_cond_broadcast">erl_drv_cond_broadcast</a></span>.
          </p></p></div>
    <p><a name="enif_cond_create"><span class="bold_code">ErlNifCond *enif_cond_create(char *name)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_cond_create">erl_drv_cond_create</a></span>.
          </p></p></div>
    <p><a name="enif_cond_destroy"><span class="bold_code">void enif_cond_destroy(ErlNifCond *cnd)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_cond_destroy">erl_drv_cond_destroy</a></span>.
          </p></p></div>
    <p><a name="enif_cond_signal"><span class="bold_code">void enif_cond_signal(ErlNifCond *cnd)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_cond_signal">erl_drv_cond_signal</a></span>.
          </p></p></div>
    <p><a name="enif_cond_wait"><span class="bold_code">void enif_cond_wait(ErlNifCond *cnd, ErlNifMutex *mtx)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_cond_wait">erl_drv_cond_wait</a></span>.
          </p></p></div>
    <p><a name="enif_consume_timeslice"><span class="bold_code">int enif_consume_timeslice(ErlNifEnv *env, int percent)</span></a><br></p>
<div class="REFBODY"><p><p>Give the runtime system a hint about how much CPU time the current NIF call has consumed
    since last hint, or since the start of the NIF if no previous hint has been given.
    The time is given as a <span class="code">percent</span> of the timeslice that a process is allowed to execute Erlang
    code until it may be suspended to give time for other runnable processes.
    The scheduling timeslice is not an exact entity, but can usually be
    approximated to about 1 millisecond.</p>
    <p>Note that it is up to the runtime system to determine if and how to use this information.
    Implementations on some platforms may use other means in order to determine consumed
    CPU time. Lengthy NIFs should regardless of this frequently call <span class="code">enif_consume_timeslice</span>
    in order to determine if it is allowed to continue execution or not.</p>

    <p>Returns 1 if the timeslice is exhausted, or 0 otherwise. If 1 is returned the NIF should return
    as soon as possible in order for the process to yield.</p>
    <p>Argument <span class="code">percent</span> must be an integer between 1 and 100. This function
    must only be called from a NIF-calling thread and argument <span class="code">env</span> must be
    the environment of the calling process.</p>
    <p>This function is provided to better support co-operative scheduling, improve system responsiveness,
    and make it easier to prevent misbehaviors of the VM due to a NIF monopolizing a scheduler thread.
    It can be used to divide <span class="bold_code"><a href="#lengthy_work">length work</a></span> into
    a number of repeated NIF-calls without the need to create threads.
    See also the <span class="bold_code"><a href="#WARNING">warning</a></span> text at the beginning of this document.</p>
    </p></div>
    <p><a name="enif_equal_tids"><span class="bold_code">int enif_equal_tids(ErlNifTid tid1, ErlNifTid tid2)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_equal_tids">erl_drv_equal_tids</a></span>.
          </p></p></div>
    <p><a name="enif_free"><span class="bold_code">void enif_free(void* ptr)</span></a><br></p>
<div class="REFBODY"><p><p>Free memory allocated by <span class="code">enif_alloc</span>.</p></p></div>
    <p><a name="enif_free_env"><span class="bold_code">void enif_free_env(ErlNifEnv* env)</span></a><br></p>
<div class="REFBODY"><p><p>Free an environment allocated with <span class="bold_code"><a href="#enif_alloc_env">enif_alloc_env</a></span>.
      All terms created in the environment will be freed as well.</p></p></div>
    <p><a name="enif_get_atom"><span class="bold_code">int enif_get_atom(ErlNifEnv* env, ERL_NIF_TERM term, char* buf, unsigned size, ErlNifCharEncoding encode)</span></a><br></p>
<div class="REFBODY"><p><p>Write a null-terminated string, in the buffer pointed to by
              <span class="code">buf</span> of size <span class="code">size</span>, consisting of the string 
              representation of the atom <span class="code">term</span> with encoding
              <span class="bold_code"><a href="#ErlNifCharEncoding">encode</a></span>. Return
              the number of bytes written (including terminating null character) or 0 if
              <span class="code">term</span> is not an atom with maximum length of 
              <span class="code">size-1</span>.</p></p></div>
    <p><a name="enif_get_atom_length"><span class="bold_code">int enif_get_atom_length(ErlNifEnv* env, ERL_NIF_TERM term, unsigned* len, ErlNifCharEncoding encode)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*len</span> to the length (number of bytes excluding
      terminating null character) of the atom <span class="code">term</span> with encoding
      <span class="code">encode</span>. Return true on success or false if <span class="code">term</span> is not an
      atom.</p></p></div>
    <p><a name="enif_get_double"><span class="bold_code">int enif_get_double(ErlNifEnv* env, ERL_NIF_TERM term, double* dp)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*dp</span> to the floating point value of
      <span class="code">term</span>. Return true on success or false if <span class="code">term</span> is not a float.</p></p></div>
    <p><a name="enif_get_int"><span class="bold_code">int enif_get_int(ErlNifEnv* env, ERL_NIF_TERM term, int* ip)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*ip</span> to the integer value of
      <span class="code">term</span>. Return true on success or false if <span class="code">term</span> is not an
      integer or is outside the bounds of type <span class="code">int</span>.</p></p></div>
    <p><a name="enif_get_int64"><span class="bold_code">int enif_get_int64(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifSInt64* ip)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*ip</span> to the integer value of
      <span class="code">term</span>. Return true on success or false if <span class="code">term</span> is not an
      integer or is outside the bounds of a signed 64-bit integer.</p></p></div>
    <p><a name="enif_get_local_pid"><span class="bold_code">int enif_get_local_pid(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifPid* pid)</span></a><br></p>
<div class="REFBODY"><p><p>If <span class="code">term</span> is the pid of a node local process, initialize the
    pid variable <span class="code">*pid</span> from it and return true. Otherwise return false.
    No check if the process is alive is done.</p></p></div>
    <p><a name="enif_get_list_cell"><span class="bold_code">int enif_get_list_cell(ErlNifEnv* env, ERL_NIF_TERM list, ERL_NIF_TERM* head, ERL_NIF_TERM* tail)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*head</span> and <span class="code">*tail</span> from
      <span class="code">list</span> and return true, or return false if <span class="code">list</span> is not a
      non-empty list.</p></p></div>
    <p><a name="enif_get_list_length"><span class="bold_code">int enif_get_list_length(ErlNifEnv* env, ERL_NIF_TERM term, unsigned* len)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*len</span> to the length of list <span class="code">term</span> and return true,
      or return false if <span class="code">term</span> is not a list.</p></p></div>
    <p><a name="enif_get_long"><span class="bold_code">int enif_get_long(ErlNifEnv* env, ERL_NIF_TERM term, long int* ip)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*ip</span> to the long integer value of <span class="code">term</span> and
      return true, or return false if <span class="code">term</span> is not an integer or is
      outside the bounds of type <span class="code">long int</span>.</p></p></div>
    <p><a name="enif_get_map_size"><span class="bold_code">int enif_get_map_size(ErlNifEnv* env, ERL_NIF_TERM term, size_t *size)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*size</span> to the number of key-value pairs in the map <span class="code">term</span> and
      return true, or return false if <span class="code">term</span> is not a map.</p></p></div>
    <p><a name="enif_get_map_value"><span class="bold_code">int enif_get_map_value(ErlNifEnv* env, ERL_NIF_TERM map, ERL_NIF_TERM key, ERL_NIF_TERM* value)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*value</span> to the value associated with <span class="code">key</span> in the
      map <span class="code">map</span> and return true. Return false if <span class="code">map</span> is not a map
      or if <span class="code">map</span> does not contain <span class="code">key</span>.</p></p></div>
   <p><a name="enif_get_resource"><span class="bold_code">int enif_get_resource(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifResourceType* type, void** objp)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*objp</span> to point to the resource object referred to by <span class="code">term</span>.</p>
      <p>Return true on success or false if <span class="code">term</span> is not a handle to a resource object
      of type <span class="code">type</span>.</p></p></div>
    <p><a name="enif_get_string"><span class="bold_code">int enif_get_string(ErlNifEnv* env, 
                                ERL_NIF_TERM list, char* buf, unsigned size,
                                ErlNifCharEncoding encode)</span></a><br></p>
<div class="REFBODY"><p><p>Write a null-terminated string, in the buffer pointed to by
              <span class="code">buf</span> with size <span class="code">size</span>, consisting of the characters
              in the string <span class="code">list</span>. The characters are written using encoding
              <span class="bold_code"><a href="#ErlNifCharEncoding">encode</a></span>.
              Return the number of bytes written (including terminating null
              character), or <span class="code">-size</span> if the string was truncated due to
              buffer space, or 0 if <span class="code">list</span> is not a string that can be
              encoded with <span class="code">encode</span> or if <span class="code">size</span> was less than 1.              
              The written string is always null-terminated unless buffer
              <span class="code">size</span> is less than 1.</p></p></div>
    <p><a name="enif_get_tuple"><span class="bold_code">int enif_get_tuple(ErlNifEnv* env, ERL_NIF_TERM term, int* arity, const ERL_NIF_TERM** array)</span></a><br></p>
<div class="REFBODY"><p><p>If <span class="code">term</span> is a tuple, set <span class="code">*array</span> to point
      to an array containing the elements of the tuple and set
      <span class="code">*arity</span> to the number of elements. Note that the array
      is read-only and <span class="code">(*array)[N-1]</span> will be the Nth element of
      the tuple. <span class="code">*array</span> is undefined if the arity of the tuple
      is zero.</p><p>Return true on success or false if <span class="code">term</span> is not a
      tuple.</p></p></div>
    <p><a name="enif_get_uint"><span class="bold_code">int enif_get_uint(ErlNifEnv* env, ERL_NIF_TERM term, unsigned int* ip)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*ip</span> to the unsigned integer value of <span class="code">term</span> and
      return true, or return false if <span class="code">term</span> is not an unsigned integer or
      is outside the bounds of type <span class="code">unsigned int</span>.</p></p></div>
    <p><a name="enif_get_uint64"><span class="bold_code">int enif_get_uint64(ErlNifEnv* env, ERL_NIF_TERM term, ErlNifUInt64* ip)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*ip</span> to the unsigned integer value of <span class="code">term</span> and
      return true, or return false if <span class="code">term</span> is not an unsigned integer or
      is outside the bounds of an unsigned 64-bit integer.</p></p></div>
    <p><a name="enif_get_ulong"><span class="bold_code">int enif_get_ulong(ErlNifEnv* env, ERL_NIF_TERM term, unsigned long* ip)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*ip</span> to the unsigned long integer value of <span class="code">term</span>
      and return true, or return false if <span class="code">term</span> is not an unsigned integer or is
      outside the bounds of type <span class="code">unsigned long</span>.</p></p></div>
    <p><a name="enif_getenv"><span class="bold_code">int enif_getenv(const char* key, char* value, size_t *value_size)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_getenv">erl_drv_getenv</a></span>.</p></p></div>
    <p><a name="enif_has_pending_exception"><span class="bold_code">int enif_has_pending_exception(ErlNifEnv* env, ERL_NIF_TERM* reason)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if a pending exception is associated
      with the environment <span class="code">env</span>. If <span class="code">reason</span> is a null pointer, ignore it.
      Otherwise, if there's a pending exception associated with <span class="code">env</span>, set the ERL_NIF_TERM
      to which <span class="code">reason</span> points to the value of the exception's term. For example, if
      <span class="bold_code"><a href="#enif_make_badarg">enif_make_badarg</a></span> is called to set a
      pending <span class="code">badarg</span> exception, a subsequent call to <span class="code">enif_has_pending_exception(env, &amp;reason)</span>
      will set <span class="code">reason</span> to the atom <span class="code">badarg</span>, then return true.</p>
      <p>See also: <span class="bold_code"><a href="#enif_make_badarg">enif_make_badarg</a></span>
      and <span class="bold_code"><a href="#enif_raise_exception">enif_raise_exception</a></span>.</p>
      </p></div>
    <p><a name="enif_inspect_binary"><span class="bold_code">int enif_inspect_binary(ErlNifEnv* env, ERL_NIF_TERM bin_term, ErlNifBinary* bin)</span></a><br></p>
<div class="REFBODY"><p><p>Initialize the structure pointed to by <span class="code">bin</span> with 
              information about the binary term
      <span class="code">bin_term</span>. Return true on success or false if <span class="code">bin_term</span> is not a binary.</p></p></div>
    <p><a name="enif_inspect_iolist_as_binary"><span class="bold_code">int enif_inspect_iolist_as_binary(ErlNifEnv* 
                                env, ERL_NIF_TERM term, ErlNifBinary* bin)
                              </span></a><br></p>
<div class="REFBODY"><p><p>Initialize the structure pointed to by <span class="code">bin</span> with one
      continuous buffer with the same byte content as <span class="code">iolist</span>. As with 
      inspect_binary, the data pointed to by <span class="code">bin</span> is transient and does 
      not need to be released. Return true on success or false if <span class="code">iolist</span> is not an
      iolist.</p>
      </p></div>
    <p><a name="enif_is_atom"><span class="bold_code">int enif_is_atom(ErlNifEnv* env, ERL_NIF_TERM term)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if <span class="code">term</span> is an atom.</p></p></div>
    <p><a name="enif_is_binary"><span class="bold_code">int enif_is_binary(ErlNifEnv* env, ERL_NIF_TERM term)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if <span class="code">term</span> is a binary</p></p></div>
    <p><a name="enif_is_empty_list"><span class="bold_code">int enif_is_empty_list(ErlNifEnv* env, ERL_NIF_TERM term)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if <span class="code">term</span> is an empty list.</p></p></div>
    <p><a name="enif_is_exception"><span class="bold_code">int enif_is_exception(ErlNifEnv* env, ERL_NIF_TERM term)</span></a><br></p>
<div class="REFBODY"><p><a name="enif_is_exception"></a>
        <p>Return true if <span class="code">term</span> is an exception.</p></p></div>
    <p><a name="enif_is_map"><span class="bold_code">int enif_is_map(ErlNifEnv* env, ERL_NIF_TERM term)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if <span class="code">term</span> is a map, false otherwise.</p></p></div>
    <p><a name="enif_is_number"><span class="bold_code">int enif_is_number(ErlNifEnv* env, ERL_NIF_TERM term)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if <span class="code">term</span> is a number.</p></p></div>
    <p><a name="enif_is_fun"><span class="bold_code">int enif_is_fun(ErlNifEnv* env, ERL_NIF_TERM term)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if <span class="code">term</span> is a fun.</p></p></div>
    <p><a name="enif_is_identical"><span class="bold_code">int enif_is_identical(ERL_NIF_TERM lhs, ERL_NIF_TERM rhs)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if the two terms are identical. Corresponds to the
      Erlang operators <span class="code">=:=</span> and
      <span class="code">=/=</span>.</p></p></div>
    <p><a name="enif_is_on_dirty_scheduler"><span class="bold_code">int enif_is_on_dirty_scheduler(ErlNifEnv* env)</span></a><br></p>
<div class="REFBODY"><p>
          <p>Check to see if the current NIF is executing on a dirty scheduler thread. If the
          emulator is built with threading support, calling <span class="code">enif_is_on_dirty_scheduler</span>
          from within a dirty NIF returns true. It returns false when the calling NIF is a regular
          NIF running on a normal scheduler thread, or when the emulator is built without threading
          support.</p>
          <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>This function is available only when the emulator is configured with dirty
          schedulers enabled. This feature is currently disabled by default. To determine whether
          the dirty NIF API is available, native code can check to see if the C preprocessor macro
          <span class="code">ERL_NIF_DIRTY_SCHEDULER_SUPPORT</span> is defined.</p></p></div>
</div>
      </p></div>
    <p><a name="enif_is_pid"><span class="bold_code">int enif_is_pid(ErlNifEnv* env, ERL_NIF_TERM term)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if <span class="code">term</span> is a pid.</p></p></div>
    <p><a name="enif_is_port"><span class="bold_code">int enif_is_port(ErlNifEnv* env, ERL_NIF_TERM term)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if <span class="code">term</span> is a port.</p></p></div>
    <p><a name="enif_is_ref"><span class="bold_code">int enif_is_ref(ErlNifEnv* env, ERL_NIF_TERM term)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if <span class="code">term</span> is a reference.</p></p></div>
    <p><a name="enif_is_tuple"><span class="bold_code">int enif_is_tuple(ErlNifEnv* env, ERL_NIF_TERM term)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if <span class="code">term</span> is a tuple.</p></p></div>
    <p><a name="enif_is_list"><span class="bold_code">int enif_is_list(ErlNifEnv* env, ERL_NIF_TERM term)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if <span class="code">term</span> is a list.</p></p></div>
    <p><a name="enif_keep_resource"><span class="bold_code">int enif_keep_resource(void* obj)</span></a><br></p>
<div class="REFBODY"><p><p>Add a reference to resource object <span class="code">obj</span> obtained from
      <span class="bold_code"><a href="#enif_alloc_resource">enif_alloc_resource</a></span>.
      Each call to <span class="code">enif_keep_resource</span> for an object must be balanced by
      a call to <span class="bold_code"><a href="#enif_release_resource">enif_release_resource</a></span>
      before the object will be destructed.</p></p></div>
    <p><a name="enif_make_atom"><span class="bold_code">ERL_NIF_TERM enif_make_atom(ErlNifEnv* env, const char* name)</span></a><br></p>
<div class="REFBODY"><p><p>Create an atom term from the null-terminated C-string <span class="code">name</span>
      with iso-latin-1 encoding. If the length of <span class="code">name</span> exceeds the maximum length
      allowed for an atom (255 characters), <span class="code">enif_make_atom</span> invokes
      <span class="bold_code"><a href="#enif_make_badarg">enif_make_badarg</a></span>.
      </p></p></div>
    <p><a name="enif_make_atom_len"><span class="bold_code">ERL_NIF_TERM enif_make_atom_len(ErlNifEnv* env, const char* name, size_t len)</span></a><br></p>
<div class="REFBODY"><p><p>Create an atom term from the string <span class="code">name</span> with length <span class="code">len</span>.
      Null-characters are treated as any other characters. If <span class="code">len</span> is greater than the maximum length
      allowed for an atom (255 characters), <span class="code">enif_make_atom</span> invokes
      <span class="bold_code"><a href="#enif_make_badarg">enif_make_badarg</a></span>.
      </p></p></div>
    <p><a name="enif_make_badarg"><span class="bold_code">ERL_NIF_TERM enif_make_badarg(ErlNifEnv* env)</span></a><br></p>
<div class="REFBODY"><p><p>Make a badarg exception to be returned from a NIF, and associate
      it with the environment <span class="code">env</span>. Once a NIF or any function
      it calls invokes <span class="code">enif_make_badarg</span>, the runtime ensures that a
      <span class="code">badarg</span> exception is raised when the NIF returns, even if the NIF
      attempts to return a non-exception term instead.
      The return value from <span class="code">enif_make_badarg</span> may be used only as the
      return value from the NIF that invoked it (directly or indirectly)
      or be passed to
      <span class="bold_code"><a href="#enif_is_exception">enif_is_exception</a></span>, but
      not to any other NIF API function.</p>
      <p>See also: <span class="bold_code"><a href="#enif_has_pending_exception">enif_has_pending_exception</a></span>
      and <span class="bold_code"><a href="#enif_raise_exception">enif_raise_exception</a></span>
      </p>
      <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>In earlier versions (older than erts-7.0, OTP 18) the return value
      from <span class="code">enif_make_badarg</span> had to be returned from the NIF. This
      requirement is now lifted as the return value from the NIF is ignored
      if <span class="code">enif_make_badarg</span> has been invoked.</p></p></div>
</div></p></div>
    <p><a name="enif_make_binary"><span class="bold_code">ERL_NIF_TERM enif_make_binary(ErlNifEnv* env, ErlNifBinary* bin)</span></a><br></p>
<div class="REFBODY"><p><p>Make a binary term from <span class="code">bin</span>. Any ownership of 
              the binary data will be transferred to the created term and
              <span class="code">bin</span> should be considered read-only for the rest of the NIF
              call and then as released.</p></p></div>
    <p><a name="enif_make_copy"><span class="bold_code">ERL_NIF_TERM enif_make_copy(ErlNifEnv* dst_env, ERL_NIF_TERM src_term)</span></a><br></p>
<div class="REFBODY"><p><p>Make a copy of term <span class="code">src_term</span>. The copy will be created in
      environment <span class="code">dst_env</span>. The source term may be located in any
      environment.</p></p></div>
    <p><a name="enif_make_double"><span class="bold_code">ERL_NIF_TERM enif_make_double(ErlNifEnv* env, double d)</span></a><br></p>
<div class="REFBODY"><p><p>Create a floating-point term from a <span class="code">double</span>. If the <span class="code">double</span> argument is
      not finite or is NaN, <span class="code">enif_make_double</span> invokes
      <span class="bold_code"><a href="#enif_make_badarg">enif_make_badarg</a></span>.
      </p></p></div>
    <p><a name="enif_make_existing_atom"><span class="bold_code">int enif_make_existing_atom(ErlNifEnv* env, const char* name, ERL_NIF_TERM* atom, ErlNifCharEncoding encode)</span></a><br></p>
<div class="REFBODY"><p><p>Try to create the term of an already existing atom from
      the null-terminated C-string <span class="code">name</span> with encoding
      <span class="bold_code"><a href="#ErlNifCharEncoding">encode</a></span>. If the atom
      already exists store the term in <span class="code">*atom</span> and return true, otherwise
      return false. If the length of <span class="code">name</span> exceeds the maximum length
      allowed for an atom (255 characters), <span class="code">enif_make_existing_atom</span>
      returns false.</p></p></div>
    <p><a name="enif_make_existing_atom_len"><span class="bold_code">int enif_make_existing_atom_len(ErlNifEnv* env, const char* name, size_t len, ERL_NIF_TERM* atom, ErlNifCharEncoding encoding)</span></a><br></p>
<div class="REFBODY"><p><p>Try to create the term of an already existing atom from the
      string <span class="code">name</span> with length <span class="code">len</span> and encoding
      <span class="bold_code"><a href="#ErlNifCharEncoding">encode</a></span>. Null-characters
      are treated as any other characters. If the atom already exists store the term
      in <span class="code">*atom</span> and return true, otherwise return false. If <span class="code">len</span> is greater
      than the maximum length allowed for an atom (255 characters),
      <span class="code">enif_make_existing_atom_len</span> returns false.</p></p></div>
    <p><a name="enif_make_int"><span class="bold_code">ERL_NIF_TERM enif_make_int(ErlNifEnv* env, int i)</span></a><br></p>
<div class="REFBODY"><p><p>Create an integer term.</p></p></div>
    <p><a name="enif_make_int64"><span class="bold_code">ERL_NIF_TERM enif_make_int64(ErlNifEnv* env, ErlNifSInt64 i)</span></a><br></p>
<div class="REFBODY"><p><p>Create an integer term from a signed 64-bit integer.</p></p></div>
    <p><a name="enif_make_list"><span class="bold_code">ERL_NIF_TERM enif_make_list(ErlNifEnv* env, unsigned cnt, ...)</span></a><br></p>
<div class="REFBODY"><p><p>Create an ordinary list term of length <span class="code">cnt</span>. Expects
      <span class="code">cnt</span> number of arguments (after <span class="code">cnt</span>) of type ERL_NIF_TERM as the
      elements of the list. An empty list is returned if <span class="code">cnt</span> is 0.</p></p></div>
    <p><a name="enif_make_list1"><span class="bold_code">ERL_NIF_TERM enif_make_list1(ErlNifEnv* env, ERL_NIF_TERM e1)</span></a><br><a name="enif_make_list2"><span class="bold_code">ERL_NIF_TERM enif_make_list2(ErlNifEnv* env, ERL_NIF_TERM e1, ERL_NIF_TERM e2)</span></a><br><a name="enif_make_list3"><span class="bold_code">ERL_NIF_TERM enif_make_list3(ErlNifEnv* env, ERL_NIF_TERM e1, ERL_NIF_TERM e2, ERL_NIF_TERM e3)</span></a><br><a name="enif_make_list4"><span class="bold_code">ERL_NIF_TERM enif_make_list4(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e4)</span></a><br><a name="enif_make_list5"><span class="bold_code">ERL_NIF_TERM enif_make_list5(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e5)</span></a><br><a name="enif_make_list6"><span class="bold_code">ERL_NIF_TERM enif_make_list6(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e6)</span></a><br><a name="enif_make_list7"><span class="bold_code">ERL_NIF_TERM enif_make_list7(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e7)</span></a><br><a name="enif_make_list8"><span class="bold_code">ERL_NIF_TERM enif_make_list8(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e8)</span></a><br><a name="enif_make_list9"><span class="bold_code">ERL_NIF_TERM enif_make_list9(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e9)</span></a><br></p>
<div class="REFBODY"><p><p>Create an ordinary list term with length indicated by the
      function name. Prefer these functions (macros) over the variadic
      <span class="code">enif_make_list</span>  to get a compile time error if the number of
      arguments does not match.</p></p></div>
    <p><a name="enif_make_list_cell"><span class="bold_code">ERL_NIF_TERM enif_make_list_cell(ErlNifEnv* env, ERL_NIF_TERM head, ERL_NIF_TERM tail)</span></a><br></p>
<div class="REFBODY"><p><p>Create a list cell <span class="code">[head | tail]</span>.</p></p></div>
    <p><a name="enif_make_list_from_array"><span class="bold_code">ERL_NIF_TERM enif_make_list_from_array(ErlNifEnv* env, const ERL_NIF_TERM arr[], unsigned cnt)</span></a><br></p>
<div class="REFBODY"><p><p>Create an ordinary list containing the elements of array <span class="code">arr</span>
      of length <span class="code">cnt</span>. An empty list is returned if <span class="code">cnt</span> is 0.</p></p></div>
    <p><a name="enif_make_long"><span class="bold_code">ERL_NIF_TERM enif_make_long(ErlNifEnv* env, long int i)</span></a><br></p>
<div class="REFBODY"><p><p>Create an integer term from a <span class="code">long int</span>.</p></p></div>
    <p><a name="enif_make_new_binary"><span class="bold_code">unsigned char *enif_make_new_binary(ErlNifEnv* env, size_t size, ERL_NIF_TERM* termp)</span></a><br></p>
<div class="REFBODY"><p><p>Allocate a binary of size <span class="code">size</span> bytes and create an owning
      term. The binary data is mutable until the calling NIF returns. This is a
      quick way to create a new binary without having to use
      <span class="bold_code"><a href="#ErlNifBinary">ErlNifBinary</a></span>. The drawbacks are
      that the binary can not be kept between NIF calls and it can not be
      reallocated.</p><p>Return a pointer to the raw binary data and set
      <span class="code">*termp</span> to the binary term.</p></p></div>
    <p><a name="enif_make_new_map"><span class="bold_code">ERL_NIF_TERM enif_make_new_map(ErlNifEnv* env)</span></a><br></p>
<div class="REFBODY"><p><p>Make an empty map term.</p></p></div>
    <p><a name="enif_make_map_put"><span class="bold_code">int enif_make_map_put(ErlNifEnv* env, ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM value, ERL_NIF_TERM* map_out)</span></a><br></p>
<div class="REFBODY"><p><p>Make a copy of map <span class="code">map_in</span> and insert <span class="code">key</span> with
      <span class="code">value</span>. If <span class="code">key</span> already exists in <span class="code">map_in</span>, the old
      associated value is replaced by <span class="code">value</span>. If successful set
      <span class="code">*map_out</span> to the new map and return true. Return false if
      <span class="code">map_in</span> is not a map.</p>
      <p>The <span class="code">map_in</span> term must belong to the environment <span class="code">env</span>.</p></p></div>
    <p><a name="enif_make_map_update"><span class="bold_code">int enif_make_map_update(ErlNifEnv* env, ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM new_value, ERL_NIF_TERM* map_out)</span></a><br></p>
<div class="REFBODY"><p><p>Make a copy of map <span class="code">map_in</span> and replace the old associated
      value for <span class="code">key</span> with <span class="code">new_value</span>. If successful set
      <span class="code">*map_out</span> to the new map and return true. Return false if
      <span class="code">map_in</span> is not a map or if it does no contain <span class="code">key</span>.</p>
      <p>The <span class="code">map_in</span> term must belong to the environment <span class="code">env</span>.</p></p></div>
    <p><a name="enif_make_map_remove"><span class="bold_code">int enif_make_map_remove(ErlNifEnv* env, ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM* map_out)</span></a><br></p>
<div class="REFBODY"><p><p>If map <span class="code">map_in</span> contains <span class="code">key</span>, make a copy of
      <span class="code">map_in</span> in <span class="code">*map_out</span> and remove <span class="code">key</span> and associated
      value. If map <span class="code">map_in</span> does not contain <span class="code">key</span>, set
      <span class="code">*map_out</span> to <span class="code">map_in</span>. Return true for success or false if
      <span class="code">map_in</span> is not a map.</p>
      <p>The <span class="code">map_in</span> term must belong to the environment <span class="code">env</span>.</p></p></div>
    <p><a name="enif_make_pid"><span class="bold_code">ERL_NIF_TERM enif_make_pid(ErlNifEnv* env, const ErlNifPid* pid)</span></a><br></p>
<div class="REFBODY"><p><p>Make a pid term from <span class="code">*pid</span>.</p></p></div>
    <p><a name="enif_make_ref"><span class="bold_code">ERL_NIF_TERM enif_make_ref(ErlNifEnv* env)</span></a><br></p>
<div class="REFBODY"><p><p>Create a reference like <span class="bold_code"><a href="erlang.html#make_ref-0">erlang:make_ref/0</a></span>.</p></p></div>
    <p><a name="enif_make_resource"><span class="bold_code">ERL_NIF_TERM enif_make_resource(ErlNifEnv* env, void* obj)</span></a><br></p>
<div class="REFBODY"><p><p>Create an opaque handle to a memory managed resource object
      obtained by <span class="bold_code"><a href="#enif_alloc_resource">enif_alloc_resource</a></span>.
      No ownership transfer is done, as the resource object still needs to be released by
      <span class="bold_code"><a href="#enif_release_resource">enif_release_resource</a></span>,
      but note that the call to <span class="code">enif_release_resource</span> can occur
      immediately after obtaining the term from <span class="code">enif_make_resource</span>,
      in which case the resource object will be deallocated when the
      term is garbage collected. See the
      <span class="bold_code"><a href="#enif_resource_example">example of creating and
      returning a resource object</a></span> for more details.</p> 
      <p>Note that the only defined behaviour of using a resource term in
      an Erlang program is to store it and send it between processes on the
      same node. Other operations such as matching or <span class="code">term_to_binary</span>
      will have unpredictable (but harmless) results.</p></p></div>
    <p><a name="enif_make_resource_binary"><span class="bold_code">ERL_NIF_TERM enif_make_resource_binary(ErlNifEnv* env, void* obj, const void* data, size_t size)</span></a><br></p>
<div class="REFBODY"><p><p>Create a binary term that is memory managed by a resource object
      <span class="code">obj</span> obtained by <span class="bold_code"><a href="#enif_alloc_resource">enif_alloc_resource</a></span>.
      The returned binary term will consist of <span class="code">size</span> bytes pointed to
      by <span class="code">data</span>. This raw binary data must be kept readable and unchanged
      until the destructor of the resource is called. The binary data may be
      stored external to the resource object in which case it is the responsibility
      of the destructor to release the data.</p>
      <p>Several binary terms may be managed by the same resource object. The
      destructor will not be called until the last binary is garbage collected.
      This can be useful as a way to return different parts of a larger binary
      buffer.</p>
      <p>As with <span class="bold_code"><a href="#enif_make_resource">enif_make_resource</a></span>,
      no ownership transfer is done. The resource still needs to be released with
      <span class="bold_code"><a href="#enif_release_resource">enif_release_resource</a></span>.</p>
      </p></div>
    <p><a name="enif_make_reverse_list"><span class="bold_code">int enif_make_reverse_list(ErlNifEnv* env, ERL_NIF_TERM list_in, ERL_NIF_TERM *list_out)</span></a><br></p>
<div class="REFBODY"><p><p>Set <span class="code">*list_out</span> to the reverse list of the list <span class="code">list_in</span> and return true,
      or return false if <span class="code">list_in</span> is not a list. This function should only be used on
      short lists as a copy will be created of the list which will not be released until after the
      nif returns.</p>
      <p>The <span class="code">list_in</span> term must belong to the environment <span class="code">env</span>.</p></p></div>
    <p><a name="enif_make_string"><span class="bold_code">ERL_NIF_TERM enif_make_string(ErlNifEnv* env, const char* string, ErlNifCharEncoding encoding)</span></a><br></p>
<div class="REFBODY"><p><p>Create a list containing the characters of the
      null-terminated string <span class="code">string</span> with encoding <span class="bold_code"><a href="#ErlNifCharEncoding">encoding</a></span>.</p></p></div>
    <p><a name="enif_make_string_len"><span class="bold_code">ERL_NIF_TERM enif_make_string_len(ErlNifEnv* env, const char* string, size_t len, ErlNifCharEncoding encoding)</span></a><br></p>
<div class="REFBODY"><p><p>Create a list containing the characters of the string <span class="code">string</span> with
      length <span class="code">len</span> and encoding <span class="bold_code"><a href="#ErlNifCharEncoding">encoding</a></span>.
      Null-characters are treated as any other characters.</p></p></div>
    <p><a name="enif_make_sub_binary"><span class="bold_code">ERL_NIF_TERM enif_make_sub_binary(ErlNifEnv* 
      env, ERL_NIF_TERM bin_term, size_t pos, size_t size)</span></a><br></p>
<div class="REFBODY"><p><p>Make a subbinary of binary <span class="code">bin_term</span>, starting at 
              zero-based position <span class="code">pos</span> with a length of <span class="code">size</span> bytes. 
              <span class="code">bin_term</span> must be a binary or bitstring and
              <span class="code">pos+size</span> must be less or equal to the number of whole
              bytes in <span class="code">bin_term</span>.</p></p></div>
    <p><a name="enif_make_tuple"><span class="bold_code">ERL_NIF_TERM enif_make_tuple(ErlNifEnv* env, unsigned cnt, ...)</span></a><br></p>
<div class="REFBODY"><p><p>Create a tuple term of arity <span class="code">cnt</span>. Expects
      <span class="code">cnt</span> number of arguments (after <span class="code">cnt</span>) of type ERL_NIF_TERM as the
      elements of the tuple.</p></p></div>
    <p><a name="enif_make_tuple1"><span class="bold_code">ERL_NIF_TERM enif_make_tuple1(ErlNifEnv* env, ERL_NIF_TERM e1)</span></a><br><a name="enif_make_tuple2"><span class="bold_code">ERL_NIF_TERM enif_make_tuple2(ErlNifEnv* env, ERL_NIF_TERM e1, ERL_NIF_TERM e2)</span></a><br><a name="enif_make_tuple3"><span class="bold_code">ERL_NIF_TERM enif_make_tuple3(ErlNifEnv* env, ERL_NIF_TERM e1, ERL_NIF_TERM e2, ERL_NIF_TERM e3)</span></a><br><a name="enif_make_tuple4"><span class="bold_code">ERL_NIF_TERM enif_make_tuple4(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e4)</span></a><br><a name="enif_make_tuple5"><span class="bold_code">ERL_NIF_TERM enif_make_tuple5(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e5)</span></a><br><a name="enif_make_tuple6"><span class="bold_code">ERL_NIF_TERM enif_make_tuple6(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e6)</span></a><br><a name="enif_make_tuple7"><span class="bold_code">ERL_NIF_TERM enif_make_tuple7(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e7)</span></a><br><a name="enif_make_tuple8"><span class="bold_code">ERL_NIF_TERM enif_make_tuple8(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e8)</span></a><br><a name="enif_make_tuple9"><span class="bold_code">ERL_NIF_TERM enif_make_tuple9(ErlNifEnv* env, ERL_NIF_TERM e1, ..., ERL_NIF_TERM e9)</span></a><br></p>
<div class="REFBODY"><p><p>Create a tuple term with length indicated by the
      function name. Prefer these functions (macros) over the variadic
      <span class="code">enif_make_tuple</span>  to get a compile time error if the number of
      arguments does not match.</p></p></div>
    <p><a name="enif_make_tuple_from_array"><span class="bold_code">ERL_NIF_TERM enif_make_tuple_from_array(ErlNifEnv* env, const ERL_NIF_TERM arr[], unsigned cnt)</span></a><br></p>
<div class="REFBODY"><p><p>Create a tuple containing the elements of array <span class="code">arr</span>
      of length <span class="code">cnt</span>.</p></p></div>
    <p><a name="enif_make_uint"><span class="bold_code">ERL_NIF_TERM enif_make_uint(ErlNifEnv* env, unsigned int i)</span></a><br></p>
<div class="REFBODY"><p><p>Create an integer term from an <span class="code">unsigned int</span>.</p></p></div>
    <p><a name="enif_make_uint64"><span class="bold_code">ERL_NIF_TERM enif_make_uint64(ErlNifEnv* env, ErlNifUInt64 i)</span></a><br></p>
<div class="REFBODY"><p><p>Create an integer term from an unsigned 64-bit integer.</p></p></div>
    <p><a name="enif_make_ulong"><span class="bold_code">ERL_NIF_TERM enif_make_ulong(ErlNifEnv* env, unsigned long i)</span></a><br></p>
<div class="REFBODY"><p><p>Create an integer term from an <span class="code">unsigned long int</span>.</p></p></div>
    <p><a name="enif_map_iterator_create"><span class="bold_code">int enif_map_iterator_create(ErlNifEnv *env, ERL_NIF_TERM map, ErlNifMapIterator *iter, ErlNifMapIteratorEntry entry)</span></a><br></p>
<div class="REFBODY"><p><p>Create an iterator for the map <span class="code">map</span> by initializing the
      structure pointed to by <span class="code">iter</span>. The <span class="code">entry</span> argument determines
      the start position of the iterator: <span class="code">ERL_NIF_MAP_ITERATOR_FIRST</span> or
      <span class="code">ERL_NIF_MAP_ITERATOR_LAST</span>. Return true on success or false if
      <span class="code">map</span> is not a map.</p>
      <p>A map iterator is only useful during the lifetime of the environment
      <span class="code">env</span> that the <span class="code">map</span> belongs to. The iterator must be destroyed by
      calling <span class="bold_code"><a href="#enif_map_iterator_destroy">
      enif_map_iterator_destroy</a></span>.</p>
      <div class="example"><pre>
ERL_NIF_TERM key, value;
ErlNifMapIterator iter;
enif_map_iterator_create(env, my_map, &amp;iter, ERL_NIF_MAP_ITERATOR_FIRST);

while (enif_map_iterator_get_pair(env, &amp;iter, &amp;key, &amp;value)) {
    do_something(key,value);
    enif_map_iterator_next(env, &amp;iter);
}
enif_map_iterator_destroy(env, &amp;iter);
      </pre></div>
     <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>The key-value pairs of a map have no defined iteration
     order. The only guarantee is that the iteration order of a single map
     instance is preserved during the lifetime of the environment that the map
     belongs to.</p>
    </p></div>
</div>
      </p></div>
    <p><a name="enif_map_iterator_destroy"><span class="bold_code">void enif_map_iterator_destroy(ErlNifEnv *env, ErlNifMapIterator *iter)</span></a><br></p>
<div class="REFBODY"><p><p>Destroy a map iterator created by
      <span class="bold_code"><a href="#enif_map_iterator_create">enif_map_iterator_create</a></span>.
      </p></p></div>
    <p><a name="enif_map_iterator_get_pair"><span class="bold_code">int enif_map_iterator_get_pair(ErlNifEnv *env, ErlNifMapIterator *iter, ERL_NIF_TERM *key, ERL_NIF_TERM *value)</span></a><br></p>
<div class="REFBODY"><p><p>Get key and value terms at current map iterator position.
      On success set <span class="code">*key</span> and <span class="code">*value</span> and return true.
      Return false if the iterator is positioned at head (before first entry)
      or tail (beyond last entry).</p></p></div>
    <p><a name="enif_map_iterator_is_head"><span class="bold_code">int enif_map_iterator_is_head(ErlNifEnv *env, ErlNifMapIterator *iter)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if map iterator <span class="code">iter</span> is positioned
      before first entry.</p></p></div>
    <p><a name="enif_map_iterator_is_tail"><span class="bold_code">int enif_map_iterator_is_tail(ErlNifEnv *env, ErlNifMapIterator *iter)</span></a><br></p>
<div class="REFBODY"><p><p>Return true if map iterator <span class="code">iter</span> is positioned
      after last entry.</p></p></div>
    <p><a name="enif_map_iterator_next"><span class="bold_code">int enif_map_iterator_next(ErlNifEnv *env, ErlNifMapIterator *iter)</span></a><br></p>
<div class="REFBODY"><p><p>Increment map iterator to point to next key-value entry.
      Return true if the iterator is now positioned at a valid key-value entry,
      or false if the iterator is positioned at the tail (beyond the last
      entry).</p></p></div>
    <p><a name="enif_map_iterator_prev"><span class="bold_code">int enif_map_iterator_prev(ErlNifEnv *env, ErlNifMapIterator *iter)</span></a><br></p>
<div class="REFBODY"><p><p>Decrement map iterator to point to previous key-value entry.
      Return true if the iterator is now positioned at a valid key-value entry,
      or false if the iterator is positioned at the head (before the first
      entry).</p></p></div>
    <p><a name="enif_mutex_create"><span class="bold_code">ErlNifMutex *enif_mutex_create(char *name)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_mutex_create">erl_drv_mutex_create</a></span>.
    </p></p></div>
    <p><a name="enif_mutex_destroy"><span class="bold_code">void enif_mutex_destroy(ErlNifMutex *mtx)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_mutex_destroy">erl_drv_mutex_destroy</a></span>.
          </p></p></div>
    <p><a name="enif_mutex_lock"><span class="bold_code">void enif_mutex_lock(ErlNifMutex *mtx)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_mutex_lock">erl_drv_mutex_lock</a></span>.
          </p></p></div>
    <p><a name="enif_mutex_trylock"><span class="bold_code">int enif_mutex_trylock(ErlNifMutex *mtx)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_mutex_trylock">erl_drv_mutex_trylock</a></span>.
          </p></p></div>
    <p><a name="enif_mutex_unlock"><span class="bold_code">void enif_mutex_unlock(ErlNifMutex *mtx)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_mutex_unlock">erl_drv_mutex_unlock</a></span>.
          </p></p></div>
    <p><a name="enif_open_resource_type"><span class="bold_code">ErlNifResourceType *enif_open_resource_type(ErlNifEnv* env,
                             const char* module_str, const char* name,
                             ErlNifResourceDtor* dtor, ErlNifResourceFlags flags, ErlNifResourceFlags* tried)</span></a><br></p>
<div class="REFBODY"><p><p>Create or takeover a resource type identified by the string
      <span class="code">name</span> and give it the destructor function pointed to by <span class="bold_code"><a href="#ErlNifResourceDtor">dtor</a></span>.
      Argument <span class="code">flags</span> can have the following values:</p>
      <dl>
        <dt><strong><span class="code">ERL_NIF_RT_CREATE</span></strong></dt>
              <dd>Create a new resource type that does not already exist.</dd>
        <dt><strong><span class="code">ERL_NIF_RT_TAKEOVER</span></strong></dt>
              <dd>Open an existing resource type and take over ownership of all its instances.
               The supplied destructor <span class="code">dtor</span> will be called both for existing instances
               as well as new instances not yet created by the calling NIF library.</dd>            
      </dl>
      <p>The two flag values can be combined with bitwise-or. The name of the
      resource type is local to the calling module. Argument <span class="code">module_str</span>
      is not (yet) used and must be NULL. The <span class="code">dtor</span> may  be <span class="code">NULL</span>
      in case no destructor is needed.</p>
      <p>On success, return a pointer to the resource type and <span class="code">*tried</span>
      will be set to either <span class="code">ERL_NIF_RT_CREATE</span> or
      <span class="code">ERL_NIF_RT_TAKEOVER</span> to indicate what was actually done.
       On failure, return <span class="code">NULL</span> and set <span class="code">*tried</span> to <span class="code">flags</span>.
       It is allowed to set <span class="code">tried</span> to <span class="code">NULL</span>.</p>
       <p>Note that <span class="code">enif_open_resource_type</span> is only allowed to be called in the three callbacks
       <span class="bold_code"><a href="#load">load</a></span>, <span class="bold_code"><a href="#reload">reload</a></span>
       and <span class="bold_code"><a href="#upgrade">upgrade</a></span>.</p>
      </p></div>
    <p><a name="enif_priv_data"><span class="bold_code">void *enif_priv_data(ErlNifEnv* env)</span></a><br></p>
<div class="REFBODY"><p><p>Return the pointer to the private data that was set by <span class="code">load</span>,
      <span class="code">reload</span> or <span class="code">upgrade</span>.</p>
      <p>Was previously named <span class="code">enif_get_data</span>.</p></p></div>
    <p><a name="enif_raise_exception"><span class="bold_code">ERL_NIF_TERM enif_raise_exception(ErlNifEnv* env, ERL_NIF_TERM reason)</span></a><br></p>
<div class="REFBODY"><p><p>Create an error exception with the term <span class="code">reason</span> to be returned from a NIF,
      and associate it with the environment <span class="code">env</span>. Once a NIF or any function it calls
      invokes <span class="code">enif_raise_exception</span>, the runtime ensures that the exception it creates
      is raised when the NIF returns, even if the NIF attempts to return a non-exception
      term instead. The return value from <span class="code">enif_raise_exception</span> may be used only as
      the return value from the NIF that invoked it (directly or indirectly) or be passed
      to <span class="bold_code"><a href="#enif_is_exception">enif_is_exception</a></span>, but
      not to any other NIF API function.</p>
      <p>See also: <span class="bold_code"><a href="#enif_has_pending_exception">enif_has_pending_exception</a></span>
      and <span class="bold_code"><a href="#enif_make_badarg">enif_make_badarg</a></span>.</p></p></div>
    <p><a name="enif_realloc_binary"><span class="bold_code">int enif_realloc_binary(ErlNifBinary* bin, size_t size)</span></a><br></p>
<div class="REFBODY"><p><p>Change the size of a binary <span class="code">bin</span>. The source binary
      may be read-only, in which case it will be left untouched and
      a mutable copy is allocated and assigned to <span class="code">*bin</span>. Return true on success,
      false if memory allocation failed.</p></p></div>
    <p><a name="enif_release_binary"><span class="bold_code">void enif_release_binary(ErlNifBinary* bin)</span></a><br></p>
<div class="REFBODY"><p><p>Release a binary obtained from <span class="code">enif_alloc_binary</span>.</p></p></div>
    <p><a name="enif_release_resource"><span class="bold_code">void enif_release_resource(void* obj)</span></a><br></p>
<div class="REFBODY"><p><p>Remove a reference to resource object <span class="code">obj</span>obtained from
      <span class="bold_code"><a href="#enif_alloc_resource">enif_alloc_resource</a></span>.
      The resource object will be destructed when the last reference is removed.
      Each call to <span class="code">enif_release_resource</span> must correspond to a previous
      call to <span class="code">enif_alloc_resource</span> or
      <span class="bold_code"><a href="#enif_keep_resource">enif_keep_resource</a></span>.
      References made by <span class="bold_code"><a href="#enif_make_resource">enif_make_resource</a></span>
      can only be removed by the garbage collector.</p></p></div>
    <p><a name="enif_rwlock_create"><span class="bold_code">ErlNifRWLock *enif_rwlock_create(char *name)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_rwlock_create">erl_drv_rwlock_create</a></span>.
          </p></p></div>
    <p><a name="enif_rwlock_destroy"><span class="bold_code">void enif_rwlock_destroy(ErlNifRWLock *rwlck)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_rwlock_destroy">erl_drv_rwlock_destroy</a></span>.
          </p></p></div>
    <p><a name="enif_rwlock_rlock"><span class="bold_code">void enif_rwlock_rlock(ErlNifRWLock *rwlck)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_rwlock_rlock">erl_drv_rwlock_rlock</a></span>.
          </p></p></div>
    <p><a name="enif_rwlock_runlock"><span class="bold_code">void enif_rwlock_runlock(ErlNifRWLock *rwlck)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_rwlock_runlock">erl_drv_rwlock_runlock</a></span>.
          </p></p></div>
    <p><a name="enif_rwlock_rwlock"><span class="bold_code">void enif_rwlock_rwlock(ErlNifRWLock *rwlck)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_rwlock_rwlock">erl_drv_rwlock_rwlock</a></span>.
          </p></p></div>
    <p><a name="enif_rwlock_rwunlock"><span class="bold_code">void enif_rwlock_rwunlock(ErlNifRWLock *rwlck)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_rwlock_rwunlock">erl_drv_rwlock_rwunlock</a></span>.
          </p></p></div>
    <p><a name="enif_rwlock_tryrlock"><span class="bold_code">int enif_rwlock_tryrlock(ErlNifRWLock *rwlck)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_rwlock_tryrlock">erl_drv_rwlock_tryrlock</a></span>.
          </p></p></div>
    <p><a name="enif_rwlock_tryrwlock"><span class="bold_code">int enif_rwlock_tryrwlock(ErlNifRWLock *rwlck)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_rwlock_tryrwlock">erl_drv_rwlock_tryrwlock</a></span>.
          </p></p></div>
    <p><a name="enif_schedule_nif"><span class="bold_code">ERL_NIF_TERM enif_schedule_nif(ErlNifEnv* env, const char* fun_name, int flags, ERL_NIF_TERM (*fp)(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]), int argc, const ERL_NIF_TERM argv[])</span></a><br></p>
<div class="REFBODY"><p>
          <p>Schedule NIF <span class="code">fp</span> to execute. This function allows an application to break up long-running
          work into multiple regular NIF calls or to schedule a <span class="bold_code"><a href="#dirty_nifs">dirty NIF</a></span>
          to execute on a dirty scheduler thread (<strong>note that the dirty NIF functionality described here is
          experimental</strong> and that you have to enable support for dirty schedulers when building OTP in
          order to try the functionality out).</p>
          <p>The <span class="code">fun_name</span> argument provides a name for the NIF being scheduled for execution. If it cannot
          be converted to an atom, <span class="code">enif_schedule_nif</span> returns a <span class="code">badarg</span> exception.</p>
          <p>The <span class="code">flags</span> argument must be set to 0 for a regular NIF, or if the emulator was built the
          experimental dirty scheduler support enabled, <span class="code">flags</span> can be set to either <span class="code">ERL_NIF_DIRTY_JOB_CPU_BOUND</span>
          if the job is expected to be primarily CPU-bound, or <span class="code">ERL_NIF_DIRTY_JOB_IO_BOUND</span> for jobs that will
          be I/O-bound. If dirty scheduler threads are not available in the emulator, a try to schedule such a job
          will result in a <span class="code">badarg</span> exception.</p>

          <p>The <span class="code">argc</span> and <span class="code">argv</span> arguments can either be the originals passed into the calling NIF, or
          they can be values created by the calling NIF.</p>
          <p>The calling NIF must use the return value of <span class="code">enif_schedule_nif</span> as its own return value.</p>
          <p>Be aware that <span class="code">enif_schedule_nif</span>, as its name implies, only schedules the
          NIF for future execution. The calling NIF does not block waiting for the scheduled NIF to
          execute and return, which means that the calling NIF can't expect to receive the scheduled NIF
          return value and use it for further operations.</p>
      </p></div>
    <p><a name="enif_self"><span class="bold_code">ErlNifPid *enif_self(ErlNifEnv* caller_env, ErlNifPid* pid)</span></a><br></p>
<div class="REFBODY"><p><p>Initialize the pid variable <span class="code">*pid</span> to represent the
      calling process. Return <span class="code">pid</span>.</p></p></div>
    <p><a name="enif_send"><span class="bold_code">int enif_send(ErlNifEnv* env, ErlNifPid* to_pid, ErlNifEnv* msg_env, ERL_NIF_TERM msg)</span></a><br></p>
<div class="REFBODY"><p><p>Send a message to a process.</p>
      <dl>
        <dt><strong><span class="code">env</span></strong></dt>
              <dd>The environment of the calling process. Must be NULL if and
              only if calling from a created thread.</dd>
        <dt><strong><span class="code">*to_pid</span></strong></dt>
              <dd>The pid of the receiving process. The pid should refer to a process on the local node.</dd>
        <dt><strong><span class="code">msg_env</span></strong></dt>
              <dd>The environment of the message term. Must be a process
              independent environment allocated with
               <span class="bold_code"><a href="#enif_alloc_env">enif_alloc_env</a></span>.</dd>
        <dt><strong><span class="code">msg</span></strong></dt>
              <dd>The message term to send.</dd>
      </dl>
      <p>Return true on success, or false if <span class="code">*to_pid</span> does not refer to an alive local process.</p>
      <p>The message environment <span class="code">msg_env</span> with all its terms (including
      <span class="code">msg</span>) will be invalidated by a successful call to <span class="code">enif_send</span>. The environment
      should either be freed with <span class="bold_code"><a href="#enif_free_env">enif_free_env</a></span>
      of cleared for reuse with <span class="bold_code"><a href="#enif_clear_env">enif_clear_env</a></span>.</p>
      <p>This function is only thread-safe when the emulator with SMP support is used.
      It can only be used in a non-SMP emulator from a NIF-calling thread.</p>
      </p></div>
    <p><a name="enif_sizeof_resource"><span class="bold_code">unsigned enif_sizeof_resource(void* obj)</span></a><br></p>
<div class="REFBODY"><p><p>Get the byte size of a resource object <span class="code">obj</span> obtained by
      <span class="bold_code"><a href="#enif_alloc_resource">enif_alloc_resource</a></span>.</p></p></div>
    <p><a name="enif_system_info"><span class="bold_code">void enif_system_info(ErlNifSysInfo *sys_info_ptr, size_t size)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#driver_system_info">driver_system_info</a></span>.
            </p></p></div>
    <p><a name="enif_thread_create"><span class="bold_code">int enif_thread_create(char *name,ErlNifTid *tid,void * (*func)(void *),void *args,ErlNifThreadOpts *opts)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_thread_create">erl_drv_thread_create</a></span>.
          </p></p></div>
    <p><a name="enif_thread_exit"><span class="bold_code">void enif_thread_exit(void *resp)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_thread_exit">erl_drv_thread_exit</a></span>.
          </p></p></div>
    <p><a name="enif_thread_join"><span class="bold_code">int enif_thread_join(ErlNifTid, void **respp)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_thread_join">erl_drv_thread_join </a></span>.
          </p></p></div>
    <p><a name="enif_thread_opts_create"><span class="bold_code">ErlNifThreadOpts *enif_thread_opts_create(char *name)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_thread_opts_create">erl_drv_thread_opts_create</a></span>.
          </p></p></div>
    <p><a name="enif_thread_opts_destroy"><span class="bold_code">void enif_thread_opts_destroy(ErlNifThreadOpts *opts)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_thread_opts_destroy">erl_drv_thread_opts_destroy</a></span>.
          </p></p></div>
    <p><a name="enif_thread_self"><span class="bold_code">ErlNifTid enif_thread_self(void)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_thread_self">erl_drv_thread_self</a></span>.
          </p></p></div>
    <p><a name="enif_tsd_key_create"><span class="bold_code">int enif_tsd_key_create(char *name, ErlNifTSDKey *key)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_tsd_key_create">erl_drv_tsd_key_create</a></span>.
          </p></p></div>
    <p><a name="enif_tsd_key_destroy"><span class="bold_code">void enif_tsd_key_destroy(ErlNifTSDKey key)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_tsd_key_destroy">erl_drv_tsd_key_destroy</a></span>.
          </p></p></div>
    <p><a name="enif_tsd_get"><span class="bold_code">void *enif_tsd_get(ErlNifTSDKey key)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_tsd_get">erl_drv_tsd_get</a></span>.
          </p></p></div>
    <p><a name="enif_tsd_set"><span class="bold_code">void enif_tsd_set(ErlNifTSDKey key, void *data)</span></a><br></p>
<div class="REFBODY"><p><p>Same as <span class="bold_code"><a href="erl_driver.html#erl_drv_tsd_set">erl_drv_tsd_set</a></span>.
          </p></p></div>


    <p><a name="enif_monotonic_time"><span class="bold_code">ErlNifTime enif_monotonic_time(ErlNifTimeUnit time_unit)</span></a><br></p>
<div class="REFBODY"><p>
	<a name="enif_monotonic_time"></a>
	<p>Arguments:</p>
	<dl>
	  <dt><strong><span class="code">time_unit</span></strong></dt>
	  <dd>Time unit of returned value.</dd>
	</dl>
	<p>
	  Returns
	  <span class="bold_code"><a href="../apps/erts/time_correction.html#Erlang_Monotonic_Time">Erlang
	  monotonic time</a></span>. Note that it is not uncommon with
	  negative values.
	</p>
	<p>Returns <span class="code">ERL_NIF_TIME_ERROR</span> if called with an invalid
	time unit argument, or if called from a thread that is not a
	scheduler thread.</p>
	<p>See also:</p>
	<ul>
	  <li><span class="bold_code"><a href="#ErlNifTime"><span class="code">ErlNifTime</span></a></span></li>
	  <li><span class="bold_code"><a href="#ErlNifTimeUnit"><span class="code">ErlNifTimeUnit</span></a></span></li>
	</ul>
      </p></div>

    <p><a name="enif_time_offset"><span class="bold_code">ErlNifTime enif_time_offset(ErlNifTimeUnit time_unit)</span></a><br></p>
<div class="REFBODY"><p>
	<a name="enif_time_offset"></a>
	<p>Arguments:</p>
	<dl>
	  <dt><strong><span class="code">time_unit</span></strong></dt>
	  <dd>Time unit of returned value.</dd>
	</dl>
	<p>Returns the current time offset between
	<span class="bold_code"><a href="../apps/erts/time_correction.html#Erlang_Monotonic_Time">Erlang monotonic time</a></span>
	and
	<span class="bold_code"><a href="../apps/erts/time_correction.html#Erlang_System_Time">Erlang system time</a></span>
	converted into the <span class="code">time_unit</span> passed as argument.</p>
	<p>Returns <span class="code">ERL_NIF_TIME_ERROR</span> if called with an invalid
	time unit argument, or if called from a thread that is not a
	scheduler thread.</p>
	<p>See also:</p>
	<ul>
	  <li><span class="bold_code"><a href="#ErlNifTime"><span class="code">ErlNifTime</span></a></span></li>
	  <li><span class="bold_code"><a href="#ErlNifTimeUnit"><span class="code">ErlNifTimeUnit</span></a></span></li>
	</ul>
      </p></div>

    <p><a name="enif_convert_time_unit"><span class="bold_code">ErlNifTime enif_convert_time_unit(ErlNifTime val, ErlNifTimeUnit from, ErlNifTimeUnit to)</span></a><br></p>
<div class="REFBODY"><p>
	<a name="enif_convert_time_unit"></a>
	<p>Arguments:</p>
	<dl>
	  <dt><strong><span class="code">val</span></strong></dt>
	  <dd>Value to convert time unit for.</dd>
	  <dt><strong><span class="code">from</span></strong></dt>
	  <dd>Time unit of <span class="code">val</span>.</dd>
	  <dt><strong><span class="code">to</span></strong></dt>
	  <dd>Time unit of returned value.</dd>
	</dl>
	<p>Converts the <span class="code">val</span> value of time unit <span class="code">from</span> to
	the corresponding value of time unit <span class="code">to</span>. The result is
	rounded using the floor function.</p>
	<p>Returns <span class="code">ERL_NIF_TIME_ERROR</span> if called with an invalid
	time unit argument.</p>
	<p>See also:</p>
	<ul>
	  <li><span class="bold_code"><a href="#ErlNifTime"><span class="code">ErlNifTime</span></a></span></li>
	  <li><span class="bold_code"><a href="#ErlNifTimeUnit"><span class="code">ErlNifTimeUnit</span></a></span></li>
	</ul>
      </p></div>

  
  <h3><a name="id203581">SEE ALSO</a></h3>
<div class="REFBODY">
    
    <p><span class="bold_code"><a href="erlang.html#load_nif-2">erlang:load_nif/2</a></span></p>
  </div>
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2016 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
