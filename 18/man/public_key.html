<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- public_key</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/public_key/users_guide.html">User's Guide</a><br><a href="../apps/public_key/index.html">Reference Manual</a><br><a href="../apps/public_key/release_notes.html">Release Notes</a><br><a href="../apps/public_key/public_key.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>public_key</strong><br><strong>Reference Manual</strong><br><small>Version 1.1.1</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu"><li id="loadscrollpos" title="public_key " expanded="true">public_key<ul>
<li><a href="public_key.html">
                  Top of manual page
                </a></li>
<li title="compute_key-2"><a href="public_key.html#compute_key-2">compute_key/2</a></li>
<li title="compute_key-3"><a href="public_key.html#compute_key-3">compute_key/3</a></li>
<li title="decrypt_private-2"><a href="public_key.html#decrypt_private-2">decrypt_private/2</a></li>
<li title="decrypt_private-3"><a href="public_key.html#decrypt_private-3">decrypt_private/3</a></li>
<li title="decrypt_public-2"><a href="public_key.html#decrypt_public-2">decrypt_public/2</a></li>
<li title="decrypt_public-3"><a href="public_key.html#decrypt_public-3">decrypt_public/3</a></li>
<li title="der_decode-2"><a href="public_key.html#der_decode-2">der_decode/2</a></li>
<li title="der_encode-2"><a href="public_key.html#der_encode-2">der_encode/2</a></li>
<li title="dh_gex_group-4"><a href="public_key.html#dh_gex_group-4">dh_gex_group/4</a></li>
<li title="encrypt_private-2"><a href="public_key.html#encrypt_private-2">encrypt_private/2</a></li>
<li title="encrypt_public-2"><a href="public_key.html#encrypt_public-2">encrypt_public/2</a></li>
<li title="generate_key-1"><a href="public_key.html#generate_key-1">generate_key/1</a></li>
<li title="pem_decode-1"><a href="public_key.html#pem_decode-1">pem_decode/1</a></li>
<li title="pem_encode-1"><a href="public_key.html#pem_encode-1">pem_encode/1</a></li>
<li title="pem_entry_decode-1"><a href="public_key.html#pem_entry_decode-1">pem_entry_decode/1</a></li>
<li title="pem_entry_decode-2"><a href="public_key.html#pem_entry_decode-2">pem_entry_decode/2</a></li>
<li title="pem_entry_encode-2"><a href="public_key.html#pem_entry_encode-2">pem_entry_encode/2</a></li>
<li title="pem_entry_encode-3"><a href="public_key.html#pem_entry_encode-3">pem_entry_encode/3</a></li>
<li title="pkix_decode_cert-2"><a href="public_key.html#pkix_decode_cert-2">pkix_decode_cert/2</a></li>
<li title="pkix_encode-3"><a href="public_key.html#pkix_encode-3">pkix_encode/3</a></li>
<li title="pkix_is_issuer-2"><a href="public_key.html#pkix_is_issuer-2">pkix_is_issuer/2</a></li>
<li title="pkix_is_fixed_dh_cert-1"><a href="public_key.html#pkix_is_fixed_dh_cert-1">pkix_is_fixed_dh_cert/1</a></li>
<li title="pkix_is_self_signed-1"><a href="public_key.html#pkix_is_self_signed-1">pkix_is_self_signed/1</a></li>
<li title="pkix_issuer_id-2"><a href="public_key.html#pkix_issuer_id-2">pkix_issuer_id/2</a></li>
<li title="pkix_normalize_name-1"><a href="public_key.html#pkix_normalize_name-1">pkix_normalize_name/1</a></li>
<li title="pkix_path_validation-3"><a href="public_key.html#pkix_path_validation-3">pkix_path_validation/3</a></li>
<li title="pkix_crl_issuer-1"><a href="public_key.html#pkix_crl_issuer-1">pkix_crl_issuer/1</a></li>
<li title="pkix_crls_validate-3"><a href="public_key.html#pkix_crls_validate-3">pkix_crls_validate/3</a></li>
<li title="pkix_crl_verify-2"><a href="public_key.html#pkix_crl_verify-2">pkix_crl_verify/2</a></li>
<li title="pkix_dist_point-1"><a href="public_key.html#pkix_dist_point-1">pkix_dist_point/1</a></li>
<li title="pkix_dist_points-1"><a href="public_key.html#pkix_dist_points-1">pkix_dist_points/1</a></li>
<li title="pkix_sign-2"><a href="public_key.html#pkix_sign-2">pkix_sign/2</a></li>
<li title="pkix_sign_types-1"><a href="public_key.html#pkix_sign_types-1">pkix_sign_types/1</a></li>
<li title="pkix_verify-2"><a href="public_key.html#pkix_verify-2">pkix_verify/2</a></li>
<li title="sign-3"><a href="public_key.html#sign-3">sign/3</a></li>
<li title="ssh_decode-2"><a href="public_key.html#ssh_decode-2">ssh_decode/2</a></li>
<li title="ssh_encode-2"><a href="public_key.html#ssh_encode-2">ssh_encode/2</a></li>
<li title="verify-4"><a href="public_key.html#verify-4">verify/4</a></li>
</ul>
</li></ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>public_key</h1></center>
  
  <h3>MODULE</h3>
<div class="REFBODY">public_key</div>
  <h3>MODULE SUMMARY</h3>
<div class="REFBODY">API module for public-key infrastructure.</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>This module provides functions to handle public-key infrastructure. It can
    encode/decode different file formats (PEM, OpenSSH), sign and verify digital signatures, 
    and validate certificate paths and certificate revocation lists.
    </p>
  </p></div>

  <h3><a name="id66174">public_key</a></h3>
<div class="REFBODY">
    

    <ul>
      <li> Public Key requires the Crypto and ASN1 applications, 
      the latter as OTP R16 (hopefully the runtime dependency on ASN1 will
      be removed again in the future).</li>

      <li>Supports <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280 </a></span> -
      Internet X.509 Public-Key Infrastructure Certificate and Certificate Revocation List 
      (CRL) Profile </li>
      <li>Supports <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc3447.txt"> PKCS-1 </a></span> - 
      RSA Cryptography Standard </li>
      <li>Supports <span class="bold_code"><a href="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf"> DSS</a></span> - 
      Digital Signature Standard (DSA - Digital Signature Algorithm)</li>
      <li>Supports 
      <span class="bold_code"><a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-3-diffie-hellman-key-agreement-standar.htm"> PKCS-3 </a></span> - 
      Diffie-Hellman Key Agreement Standard </li>
      <li>Supports <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc2898.txt"> PKCS-5</a></span> - 
      Password-Based Cryptography Standard </li>
      <li>Supports <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5208.txt"> PKCS-8</a></span> - 
      Private-Key Information Syntax Standard</li>
      <li>Supports <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5967.txt"> PKCS-10</a></span> - 
      Certification Request Syntax Standard</li>
    </ul>
  </div>

  <h3><a name="id65806">DATA TYPES</a></h3>
<div class="REFBODY">
     
    
    <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>All records used in this Reference Manual 
    
    are generated from ASN.1 specifications
    and are documented in the User's Guide. See <span class="bold_code"><a href="../apps/public_key/public_key_records.html">Public-key Records</a></span>.
    </p></p></div>
</div>
    
    <p>Use the following include directive to get access to the 
    records and constant macros described here and in the User's Guide:</p>
    
    <div class="example"><pre> -include_lib("public_key/include/public_key.hrl").</pre></div>

    <p>The following data types are used in the functions for <span class="code">public_key</span>:</p>

    <dl>
      <dt><strong><span class="code">oid()</span></strong></dt>
      <dd><p>Object identifier, a tuple of integers as generated by the <span class="code">ASN.1</span> compiler.</p></dd>

      <dt><strong><span class="code">boolean() =</span></strong></dt>
      <dd><p><span class="code">true | false</span></p></dd>
      
      <dt><strong><span class="code">string() =</span></strong></dt>
      <dd><p><span class="code">[bytes()]</span></p></dd>

      <dt><strong><span class="code">der_encoded() =</span></strong></dt>
      <dd><p><span class="code">binary()</span></p></dd>

      <dt><strong><span class="code">pki_asn1_type() =</span></strong></dt>
      <dd>
	<p><span class="code">'Certificate'</span></p>
	<p><span class="code">| 'RSAPrivateKey'</span></p>
	<p><span class="code">| 'RSAPublicKey'</span></p>
	<p><span class="code">| 'DSAPrivateKey'</span></p>
	<p><span class="code">| 'DSAPublicKey'</span></p>
	<p><span class="code">| 'DHParameter'</span></p>
	<p><span class="code">| 'SubjectPublicKeyInfo'</span></p>
	<p><span class="code">| 'PrivateKeyInfo'</span></p>
	<p><span class="code">| 'CertificationRequest'</span></p>
	<p><span class="code">| 'CertificateList'</span></p>
	<p><span class="code">| 'ECPrivateKey'</span></p>
	<p><span class="code">| 'EcpkParameters'</span></p>
      </dd>

      <dt><strong><span class="code">pem_entry () =</span></strong></dt>
      <dd>
<p><span class="code">{pki_asn1_type(), binary(), %% DER or encrypted DER</span></p>
      <p><span class="code"> not_encrypted | cipher_info()}</span></p>
</dd>
      
      <dt><strong><span class="code">cipher_info() = </span></strong></dt>
      <dd>
<p><span class="code">{"RC2-CBC" | "DES-CBC" | "DES-EDE3-CBC", crypto:rand_bytes(8)</span></p>
      <p><span class="code">| {#'PBEParameter{}, digest_type()} | #'PBES2-params'{}}</span></p>
      </dd>
      
      <dt><strong><span class="code">public_key() =</span></strong></dt>
      <dd><p><span class="code">rsa_public_key() | dsa_public_key() | ec_public_key()</span></p></dd>
      
      <dt><strong><span class="code">private_key() =</span></strong></dt>
      <dd><p><span class="code">rsa_private_key() | dsa_private_key() | ec_private_key()</span></p></dd>

      <dt><strong><span class="code">rsa_public_key() =</span></strong></dt>
      <dd><p><span class="code">#'RSAPublicKey'{}</span></p></dd>

      <dt><strong><span class="code">rsa_private_key() =</span></strong></dt>
      <dd><p><span class="code">#'RSAPrivateKey'{}</span></p></dd>

      <dt><strong><span class="code">dsa_public_key() =</span></strong></dt>
      <dd><p><span class="code">{integer(),  #'Dss-Parms'{}}</span></p></dd>

      <dt><strong><span class="code">dsa_private_key() =</span></strong></dt>
      <dd><p><span class="code">#'DSAPrivateKey'{}</span></p></dd>

      <dt><strong><span class="code">ec_public_key()</span></strong></dt>
      <dd><p>= <span class="code">{#'ECPoint'{}, #'EcpkParameters'{} | {namedCurve, oid()}}</span></p></dd>

      <dt><strong><span class="code">ec_private_key() =</span></strong></dt>
      <dd><p><span class="code">#'ECPrivateKey'{}</span></p></dd>

      <dt><strong><span class="code">public_crypt_options() =</span></strong></dt>
      <dd><p><span class="code">[{rsa_pad, rsa_padding()}]</span></p></dd>

      <dt><strong><span class="code">rsa_padding() =</span></strong></dt>
      <dd>
	<p><span class="code">'rsa_pkcs1_padding'</span></p>
	<p><span class="code">| 'rsa_pkcs1_oaep_padding'</span></p>
	<p><span class="code">| 'rsa_no_padding'</span></p>
      </dd>

      <dt><strong><span class="code">digest_type() = </span></strong></dt>
      <dd><p>Union of <span class="code">rsa_digest_type()</span>, <span class="code">dss_digest_type()</span>, 
      and <span class="code">ecdsa_digest_type()</span>.</p></dd>

      <dt><strong><span class="code">rsa_digest_type() = </span></strong></dt>
      <dd><p><span class="code">'md5' | 'sha' | 'sha224' | 'sha256' | 'sha384' | 'sha512'</span></p></dd>

      <dt><strong><span class="code">dss_digest_type() = </span></strong></dt>
      <dd><p><span class="code">'sha'</span></p></dd>

      <dt><strong><span class="code">ecdsa_digest_type() = </span></strong></dt>
      <dd><p><span class="code">'sha'| 'sha224' | 'sha256' | 'sha384' | 'sha512'</span></p></dd>
      
      <dt><strong><span class="code">crl_reason() = </span></strong></dt>
      <dd>
	<p><span class="code">unspecified</span></p>
	<p><span class="code">| keyCompromise</span></p>
	<p><span class="code">| cACompromise</span></p>
	<p><span class="code">| affiliationChanged</span></p>
	<p><span class="code">| superseded</span></p>
	<p><span class="code">| cessationOfOperation</span></p>
	<p><span class="code">| certificateHold</span></p>
	<p><span class="code">| privilegeWithdrawn</span></p>
	<p><span class="code">| aACompromise</span></p>
      </dd>

      <dt><strong><span class="code">issuer_name() =</span></strong></dt>
      <dd>
<p><span class="code">{rdnSequence,[#'AttributeTypeAndValue'{}]}</span></p>  
      </dd>
      
      <dt><strong><span class="code">ssh_file() =</span></strong></dt>
      <dd>
	<p><span class="code">openssh_public_key</span></p>
	<p><span class="code">| rfc4716_public_key</span></p>
	<p><span class="code">| known_hosts</span></p>
	<p><span class="code">| auth_keys</span></p>
      </dd>
    </dl>
    
    

    



	

    

      



      



      




      




  </div> 

<h3>EXPORTS</h3>    

  <p><a name="compute_key-2"><span class="bold_code">compute_key(OthersKey, MyKey)-&gt;</span></a><br><a name="compute_key-3"><span class="bold_code">compute_key(OthersKey, MyKey, Params)-&gt;</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">OthersKey = #'ECPoint'{} | binary(), MyKey = #'ECPrivateKey'{} | binary()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Params =  #'DHParameter'{}</span><br>
</div>
    </div>
<div class="REFBODY"><p>
    <p>Computes shared secret.</p>
  </p></div>

  <p><a name="decrypt_private-2"><span class="bold_code">decrypt_private(CipherText, Key) -&gt; binary()</span></a><br><a name="decrypt_private-3"><span class="bold_code">decrypt_private(CipherText, Key, Options) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">CipherText = binary()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_private_key()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Options = public_crypt_options()</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p>Public-key decryption using the private key. See also <span class="bold_code"><a href="crypto.html#private_decrypt-4">crypto:private_decrypt/4</a></span></p> 
  </p></div>

  <p><a name="decrypt_public-2"><span class="bold_code">decrypt_public(CipherText, Key) - &gt; binary()</span></a><br><a name="decrypt_public-3"><span class="bold_code">decrypt_public(CipherText, Key, Options) - &gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">CipherText = binary()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_public_key()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Options = public_crypt_options()</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p>Public-key decryption using the public key. See also <span class="bold_code"><a href="crypto.html#public_decrypt-4">crypto:public_decrypt/4</a></span></p> 
  </p></div> 

  <p><a name="der_decode-2"><span class="bold_code">der_decode(Asn1type, Der) -&gt; term()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Asn1Type = atom()</span><br>
</div>
      <div class="REFBODY">ASN.1 type present in the Public Key applications
      ASN.1 specifications.</div>
      <div class="REFTYPES">
<span class="bold_code">Der = der_encoded()</span><br>
</div>
    </div>
<div class="REFBODY"><p> 
      <p>Decodes a public-key ASN.1 DER encoded entity.</p>
    </p></div>
    
  <p><a name="der_encode-2"><span class="bold_code">der_encode(Asn1Type, Entity) -&gt; der_encoded()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Asn1Type = atom()</span><br>
</div>
      <div class="REFBODY">ASN.1 type present in the Public Key applications
	 ASN.1 specifications.</div>
      <div class="REFTYPES">
<span class="bold_code">Entity = term()</span><br>
</div>
      <div class="REFBODY">Erlang representation of <span class="code">Asn1Type</span>
</div>
  </div>
<div class="REFBODY"><p> 
    <p>Encodes a public-key entity with ASN.1 DER encoding.</p>
  </p></div>

  <p><a name="dh_gex_group-4"><span class="bold_code">dh_gex_group(MinSize, SuggestedSize, MaxSize, Groups) -&gt; {ok, {Size,Group}} | {error,Error}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">MinSize = positive_integer()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">SuggestedSize = positive_integer()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">MaxSize = positive_integer()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Groups = undefined | [{Size,[{G,P}]}]</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Size = positive_integer()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Group = {G,P}</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">G = positive_integer()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">P = positive_integer()</span><br>
</div>
    </div>
<div class="REFBODY"><p>
      <p>Selects a group for Diffie-Hellman key exchange with the key size in the range <span class="code">MinSize...MaxSize</span>
      and as close to <span class="code">SuggestedSize</span> as possible. If <span class="code">Groups == undefined</span> a default set will be
      used, otherwise the group is selected from <span class="code">Groups</span>.</p>
      <p>First a size, as close as possible to SuggestedSize, is selected. Then one group with that key size
      is randomly selected from the specified set of groups. If no size within the limits of <span class="code">MinSize</span>
      and <span class="code">MaxSize</span> is available, <span class="code">{error,no_group_found}</span> is returned.</p>
      <p>The default set of groups is listed in <span class="code">lib/public_key/priv/moduli</span>. This file may be regenerated like this:</p>
      <div class="example"><pre>
	$&gt; cd $ERL_TOP/lib/public_key/priv/
	$&gt; generate
         ---- wait until all background jobs has finished. It may take several days !
	$&gt; cat moduli-* &gt; moduli
	$&gt; cd ..; make 
      </pre></div>
    </p></div>

    <p><a name="encrypt_private-2"><span class="bold_code">encrypt_private(PlainText, Key) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">PlainText = binary()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_private_key()</span><br>
</div> 
  </div>
<div class="REFBODY"><p> 
    <p>Public-key encryption using the private key.
     See also <span class="bold_code"><a href="crypto.html#private_encrypt-4">crypto:private_encrypt/4</a></span>.</p> 
  </p></div>   

  <p><a name="encrypt_public-2"><span class="bold_code">encrypt_public(PlainText, Key) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">PlainText = binary()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_public_key()</span><br>
</div> 
  </div>
<div class="REFBODY"><p> 
    <p>Public-key encryption using the public key. See also <span class="bold_code"><a href="crypto.html#public_encrypt-4">crypto:public_encrypt/4</a></span>.</p> 
  </p></div>   
  
  <p><a name="generate_key-1"><span class="bold_code">generate_key(Params) -&gt; {Public::binary(), Private::binary()}  | #'ECPrivateKey'{} </span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Params = #'DHParameter'{} |  {namedCurve, oid()} |  #'ECParameters'{}</span><br>
</div>
    </div>
<div class="REFBODY"><p>
    <p>Generates a new keypair.</p>
  </p></div>

  <p><a name="pem_decode-1"><span class="bold_code">pem_decode(PemBin) -&gt; [pem_entry()]</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">PemBin = binary()</span><br>
</div>
      <div class="REFBODY">Example {ok, PemBin} = file:read_file("cert.pem").</div>
    </div>
<div class="REFBODY"><p> 
    <p>Decodes PEM binary data and returns
    entries as ASN.1 DER encoded entities.</p>
  </p></div> 
    
   <p><a name="pem_encode-1"><span class="bold_code">pem_encode(PemEntries) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code"> PemEntries = [pem_entry()] </span><br>
</div> 
  </div>
<div class="REFBODY"><p> 
    <p>Creates a PEM binary.</p> 
  </p></div>

   <p><a name="pem_entry_decode-1"><span class="bold_code">pem_entry_decode(PemEntry) -&gt; term()</span></a><br><a name="pem_entry_decode-2"><span class="bold_code">pem_entry_decode(PemEntry, Password) -&gt; term()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">PemEntry = pem_entry()</span><br>
</div> 
      <div class="REFTYPES">
<span class="bold_code">Password = string()</span><br>
</div> 
  </div>
<div class="REFBODY"><p> 
    <p>Decodes a PEM entry. <span class="code">pem_decode/1</span> returns a list of PEM
    entries. Notice that if the PEM entry is of type
    'SubjectPublickeyInfo', it is further decoded to an
    <span class="code">rsa_public_key()</span> or <span class="code">dsa_public_key()</span>.</p>
  </p></div>

   <p><a name="pem_entry_encode-2"><span class="bold_code">pem_entry_encode(Asn1Type, Entity) -&gt; pem_entry()</span></a><br><a name="pem_entry_encode-3"><span class="bold_code">pem_entry_encode(Asn1Type, Entity, {CipherInfo, Password}) -&gt; pem_entry()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Asn1Type = pki_asn1_type()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Entity = term()</span><br>
</div>
      <div class="REFBODY">Erlang representation of
      <span class="code">Asn1Type</span>.  If <span class="code">Asn1Type</span> is 'SubjectPublicKeyInfo',
      <span class="code">Entity</span> must be either an <span class="code">rsa_public_key()</span> or a
      <span class="code">dsa_public_key()</span> and this function creates the appropriate
      'SubjectPublicKeyInfo' entry.
      </div>
      <div class="REFTYPES">
<span class="bold_code">CipherInfo = cipher_info()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Password = string()</span><br>
</div> 
  </div>
<div class="REFBODY"><p> 
    <p>Creates a PEM entry that can be feed to <span class="code">pem_encode/1</span>.</p>
  </p></div>
  
  <p><a name="pkix_decode_cert-2"><span class="bold_code">pkix_decode_cert(Cert, otp|plain) -&gt;  #'Certificate'{} | #'OTPCertificate'{}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded()</span><br>
</div> 
  </div>
<div class="REFBODY"><p> 
    <p>Decodes an ASN.1 DER-encoded PKIX certificate. Option <span class="code">otp</span>
    uses the customized ASN.1 specification OTP-PKIX.asn1 for
    decoding and also recursively decode most of the standard
    parts.</p>
  </p></div>

  <p><a name="pkix_encode-3"><span class="bold_code">pkix_encode(Asn1Type, Entity, otp | plain) -&gt; der_encoded()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Asn1Type = atom()</span><br>
</div>
      <div class="REFBODY">The ASN.1 type can be 'Certificate', 'OTPCertificate' or a subtype of either.</div>
      <div class="REFTYPES">
<span class="bold_code">Entity = #'Certificate'{} | #'OTPCertificate'{} | a valid subtype</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p>DER encodes a PKIX x509 certificate or part of such a
    certificate. This function must be used for encoding certificates or parts of certificates
    that are decoded/created in the <span class="code">otp</span> format, whereas for the plain format this
    function directly calls <span class="code">der_encode/2</span>.</p> 
  </p></div>

 <p><a name="pkix_is_issuer-2"><span class="bold_code">pkix_is_issuer(Cert, IssuerCert) -&gt; boolean()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded() | #'OTPCertificate'{} | #'CertificateList'{}</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">IssuerCert = der_encoded() | #'OTPCertificate'{}</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p>Checks if <span class="code">IssuerCert</span> issued <span class="code">Cert</span>.</p> 
  </p></div>
  
  <p><a name="pkix_is_fixed_dh_cert-1"><span class="bold_code">pkix_is_fixed_dh_cert(Cert) -&gt; boolean()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded() | #'OTPCertificate'{}</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p>Checks if a certificate is a fixed Diffie-Hellman certificate.</p> 
  </p></div>  
  
  <p><a name="pkix_is_self_signed-1"><span class="bold_code">pkix_is_self_signed(Cert) -&gt; boolean()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded() | #'OTPCertificate'{}</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p>Checks if a certificate is self-signed.</p> 
  </p></div>

  <p><a name="pkix_issuer_id-2"><span class="bold_code">pkix_issuer_id(Cert, IssuedBy) -&gt; {ok, IssuerID} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded() | #'OTPCertificate'{}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">IssuedBy = self | other</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">IssuerID = {integer(), issuer_name()}</span><br>
</div>
	<div class="REFBODY">The issuer id consists of the serial number and the issuers name.</div>
	<div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
    </div>
<div class="REFBODY"><p> 
    <p>Returns the issuer id.</p> 
    </p></div>
  
 
  <p><a name="pkix_normalize_name-1"><span class="bold_code">pkix_normalize_name(Issuer) -&gt; Normalized</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Issuer = issuer_name()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Normalized = issuer_name()</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p>Normalizes an issuer name so that it can be easily
    compared to another issuer name.</p> 
  </p></div>
   
  <p><a name="pkix_path_validation-3"><span class="bold_code">pkix_path_validation(TrustedCert, CertChain, Options) -&gt; {ok, {PublicKeyInfo, PolicyTree}} | {error, {bad_cert, Reason}} </span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code">TrustedCert =  #'OTPCertificate'{} | der_encoded() | atom()</span><br>
</div>
       <div class="REFBODY">Normally a trusted certificate, but it can also be a path-validation
       error that can be discovered while
       constructing the input to this function and that is to be run through the <span class="code">verify_fun</span>.
       Examples are <span class="code">unknown_ca</span> and <span class="code">selfsigned_peer.</span>
       </div>
       <div class="REFTYPES">
<span class="bold_code">CertChain = [der_encoded()]</span><br>
</div>
       <div class="REFBODY">A list of DER-encoded certificates in trust order ending with the peer certificate.</div>
       <div class="REFTYPES">
<span class="bold_code">Options = proplists:proplist()</span><br>
</div>
       <div class="REFTYPES">
<span class="bold_code">PublicKeyInfo = {?'rsaEncryption' | ?'id-dsa',
       rsa_public_key() | integer(), 'NULL' | 'Dss-Parms'{}}</span><br>
</div>
       <div class="REFTYPES">
<span class="bold_code">PolicyTree = term()</span><br>
</div>
       <div class="REFBODY">At the moment this is always an empty list as policies are not currently supported.</div>
       <div class="REFTYPES">
<span class="bold_code">Reason = cert_expired | invalid_issuer | invalid_signature | name_not_permitted |
       missing_basic_constraint | invalid_key_usage | {revoked, crl_reason()} | atom()
       </span><br>
</div>
     </div>
<div class="REFBODY"><p>
       <p>
	 Performs a basic path validation according to
	 <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280.</a></span>
	 However, CRL validation is done separately by <span class="bold_code"><a href="#pkix_crls_validate-3">pkix_crls_validate/3 </a></span> and is to be called
	 from the supplied <span class="code">verify_fun</span>.
       </p>

       <p>Available options:</p>

       <dl>
	<dt><strong>{verify_fun, fun()}</strong></dt>
	<dd>
	  <p>The fun must be defined as:</p>

	  <div class="example"><pre>
fun(OtpCert :: #'OTPCertificate'{},
    Event :: {bad_cert, Reason :: atom() | {revoked, atom()}} |
             {extension, #'Extension'{}},
    InitialUserState :: term()) -&gt;
	{valid, UserState :: term()} |
	{valid_peer, UserState :: term()} |
	{fail, Reason :: term()} |
	{unknown, UserState :: term()}.
	  </pre></div>

	<p>If the verify callback fun returns <span class="code">{fail, Reason}</span>, the
	verification process is immediately stopped. If the verify
	callback fun returns <span class="code">{valid, UserState}</span>, the verification
	process is continued. This can be used to accept specific path
	validation errors, such as <span class="code">selfsigned_peer</span>, as well as
	verifying application-specific extensions. If called with an
	extension unknown to the user application, the return value
	<span class="code">{unknown, UserState}</span> is to be used.</p>

	</dd>
	<dt><strong>{max_path_length, integer()}</strong></dt>
	<dd>
	  The <span class="code">max_path_length</span> is the maximum number of non-self-issued
	  intermediate certificates that can follow the peer certificate
	  in a valid certification path. So, if <span class="code">max_path_length</span> is 0, the PEER must
	  be signed by the trusted ROOT-CA directly, if it is 1, the path can
	  be PEER, CA, ROOT-CA, if it is 2, the path can
	  be PEER, CA, CA, ROOT-CA, and so on.
	</dd>
      </dl>

      <p>Possible reasons for a bad certificate: </p>
      <dl>
	<dt><strong>cert_expired</strong></dt>
	<dd><p>Certificate is no longer valid as its expiration date has passed.</p></dd>

	<dt><strong>invalid_issuer</strong></dt>
	<dd><p>Certificate issuer name does not match the name of the issuer certificate in the chain.</p></dd>

	<dt><strong>invalid_signature</strong></dt>
	<dd><p>Certificate was not signed by its issuer certificate in the chain.</p></dd>

	<dt><strong>name_not_permitted</strong></dt>
	<dd><p>Invalid Subject Alternative Name extension.</p></dd>

	<dt><strong>missing_basic_constraint</strong></dt>
	<dd><p>Certificate, required to have the basic constraints extension, does not have
	a basic constraints extension.</p></dd>

	<dt><strong>invalid_key_usage</strong></dt>
	<dd><p>Certificate key is used in an invalid way according to the key-usage extension.</p></dd>

	<dt><strong>{revoked, crl_reason()}</strong></dt>
	<dd><p>Certificate has been revoked.</p></dd>

	<dt><strong>atom()</strong></dt>
	<dd><p>Application-specific error reason that is to be checked by the <span class="code">verify_fun</span>.</p></dd>
      </dl>

    </p></div>

    <p><a name="pkix_crl_issuer-1"><span class="bold_code">pkix_crl_issuer(CRL) -&gt; issuer_name()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">CRL = der_encoded() | #'CertificateList'{} </span><br>
</div> 
      </div>
<div class="REFBODY"><p> 
	<p>Returns the issuer of the <span class="code">CRL</span>.</p>
      </p></div> 
   
   <p><a name="pkix_crls_validate-3"><span class="bold_code">pkix_crls_validate(OTPCertificate, DPAndCRLs, Options) -&gt; CRLStatus()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code">OTPCertificate =  #'OTPCertificate'{}</span><br>
</div>
       <div class="REFTYPES">
<span class="bold_code">DPAndCRLs  = [{DP::#'DistributionPoint'{}, {DerCRL::der_encoded(), CRL::#'CertificateList'{}}}] </span><br>
</div>
       <div class="REFTYPES">
<span class="bold_code">Options = proplists:proplist()</span><br>
</div>
       <div class="REFTYPES">
<span class="bold_code">CRLStatus() =  valid | {bad_cert, revocation_status_undetermined} |
       {bad_cert, {revoked, crl_reason()}}</span><br>
</div>
     </div>
<div class="REFBODY"><p>
      <p>Performs CRL validation. It is intended to be called from
      the verify fun of  <span class="bold_code"><a href="#pkix_path_validation-3"> pkix_path_validation/3
       </a></span>.</p>

       <p>Available options:</p>

      <dl>
	
	<dt><strong>{update_crl, fun()}</strong></dt>
	<dd>
	  <p>The fun has the following type specification:</p>

	  <div class="example"><pre> fun(#'DistributionPoint'{}, #'CertificateList'{}) -&gt;
        #'CertificateList'{}</pre></div>

	  <p>The fun uses the information in the distribution point to access
	  the latest possible version of the CRL. If this fun is not specified,
	  Public Key uses the default implementation:
	  </p>
	  <div class="example"><pre> fun(_DP, CRL) -&gt; CRL end</pre></div>
	</dd>

	<dt><strong>{issuer_fun, fun()}</strong></dt>
	<dd>
	  <p>The fun has the following type specification:</p>

	  <div class="example"><pre>
fun(#'DistributionPoint'{}, #'CertificateList'{},
    {rdnSequence,[#'AttributeTypeAndValue'{}]}, term()) -&gt;
	{ok, #'OTPCertificate'{}, [der_encoded]}</pre></div>

	  <p>The fun returns the root certificate and certificate chain
	  that has signed the CRL. 
	  </p>
	  <div class="example"><pre> fun(DP, CRL, Issuer, UserState) -&gt; {ok, RootCert, CertChain}</pre></div>
	</dd>	
      </dl>
    </p></div>
   
   <p><a name="pkix_crl_verify-2"><span class="bold_code">pkix_crl_verify(CRL, Cert) -&gt; boolean()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code">CRL = der_encoded() | #'CertificateList'{} </span><br>
</div> 
       <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded() | #'OTPCertificate'{} </span><br>
</div> 
     </div>
<div class="REFBODY"><p> 
       <p>Verify that <span class="code">Cert</span> is the <span class="code">CRL</span> signer.</p>
     </p></div>

   <p><a name="pkix_dist_point-1"><span class="bold_code">pkix_dist_point(Cert) -&gt; DistPoint</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code"> Cert  = der_encoded() | #'OTPCertificate'{} </span><br>
</div> 
       <div class="REFTYPES">
<span class="bold_code"> DistPoint =  #'DistributionPoint'{}</span><br>
</div> 
     </div>
<div class="REFBODY"><p> 
       <p>Creates a distribution point for CRLs issued by the same issuer as <span class="code">Cert</span>.
       Can be used as input to <span class="bold_code"><a href="#pkix_crls_validate-3">pkix_crls_validate/3 </a></span>
       </p>
     </p></div>
   
   <p><a name="pkix_dist_points-1"><span class="bold_code">pkix_dist_points(Cert) -&gt; DistPoints</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code"> Cert  = der_encoded() | #'OTPCertificate'{} </span><br>
</div> 
       <div class="REFTYPES">
<span class="bold_code"> DistPoints =  [#'DistributionPoint'{}]</span><br>
</div> 
     </div>
<div class="REFBODY"><p> 
       <p> Extracts distribution points from the certificates extensions.</p>
     </p></div>
   
  <p><a name="pkix_sign-2"><span class="bold_code">pkix_sign(#'OTPTBSCertificate'{}, Key) -&gt; der_encoded()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_private_key() | dsa_private_key()</span><br>
</div> 
    </div>
<div class="REFBODY"><p> 
      <p>Signs an 'OTPTBSCertificate'. Returns the corresponding
      DER-encoded certificate.</p> 
    </p></div> 

  <p><a name="pkix_sign_types-1"><span class="bold_code">pkix_sign_types(AlgorithmId) -&gt; {DigestType, SignatureType}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">AlgorithmId = oid()</span><br>
</div>
      <div class="REFBODY">Signature OID from a certificate or a certificate revocation list.</div>
      <div class="REFTYPES">
<span class="bold_code">DigestType = rsa_digest_type() | dss_digest_type()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">SignatureType = rsa | dsa | ecdsa</span><br>
</div>
    </div>
<div class="REFBODY"><p>
      <p>Translates signature algorithm OID to Erlang digest and signature types.
      </p>
    </p></div>

  <p><a name="pkix_verify-2"><span class="bold_code">pkix_verify(Cert, Key) -&gt; boolean()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_public_key() | dsa_public_key() | ec_public_key()</span><br>
</div> 
    </div>
<div class="REFBODY"><p> 
    <p>Verifies PKIX x.509 certificate signature.</p>
  </p></div> 

  <p><a name="sign-3"><span class="bold_code">sign(Msg, DigestType, Key) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code">Msg = binary() | {digest,binary()}</span><br>
</div>
       <div class="REFBODY">The <span class="code">Msg</span> is either the binary "plain text" data to be
       signed or it is the hashed value of "plain text", that is, the
       digest.</div>
       <div class="REFTYPES">
<span class="bold_code">DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</span><br>
</div>
       <div class="REFTYPES">
<span class="bold_code">Key = rsa_private_key() | dsa_private_key() | ec_private_key()</span><br>
</div>
  </div>
<div class="REFBODY"><p>
    <p>Creates a digital signature.</p> 
  </p></div>   

  <p><a name="ssh_decode-2"><span class="bold_code">ssh_decode(SshBin,  Type) -&gt; [{public_key(), Attributes::list()}]</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">SshBin = binary()</span><br>
</div>
      <div class="REFBODY">Example <span class="code">{ok, SshBin} = file:read_file("known_hosts")</span>.</div>
      <div class="REFTYPES">
<span class="bold_code">Type = public_key | ssh_file()</span><br>
</div>
      <div class="REFBODY">If <span class="code">Type</span> is <span class="code">public_key</span> the binary can be either
      an RFC4716 public key or an OpenSSH public key.</div>
    </div>
<div class="REFBODY"><p>
    <p>Decodes an SSH file-binary. In the case of <span class="code">known_hosts</span> or
    <span class="code">auth_keys</span>, the binary can include one or more lines of the
    file. Returns a list of public keys and their attributes, possible
    attribute values depends on the file type represented by the
    binary.
    </p>

    <dl>
      <dt><strong>RFC4716 attributes - see RFC 4716.</strong></dt>
      <dd><p>{headers, [{string(), utf8_string()}]}</p></dd>
      <dt><strong>auth_key attributes - see manual page for sshd.</strong></dt>
      <dd>{comment, string()}</dd>
      <dd>{options, [string()]}</dd>
      <dd><p>{bits, integer()} - In SSH version 1 files.</p></dd>
      <dt><strong>known_host attributes - see manual page for sshd.</strong></dt>
      <dd>{hostnames, [string()]}</dd>
      <dd>{comment, string()}</dd>
      <dd><p>{bits, integer()} - In SSH version 1 files.</p></dd>
    </dl>

  </p></div>

  <p><a name="ssh_encode-2"><span class="bold_code">ssh_encode([{Key, Attributes}], Type) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Key = public_key()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Attributes = list()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Type = ssh_file()</span><br>
</div>
    </div>
<div class="REFBODY"><p>
    <p>Encodes a list of SSH file entries (public keys and attributes) to a binary. Possible
    attributes depend on the file type, see <span class="bold_code"><a href="#ssh_decode-2"> ssh_decode/2 </a></span>.</p>
  </p></div>

  <p><a name="verify-4"><span class="bold_code">verify(Msg, DigestType, Signature, Key) -&gt; boolean()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Msg = binary() | {digest,binary()}</span><br>
</div>
       <div class="REFBODY">The <span class="code">Msg</span> is either the binary "plain text" data 
        or it is the hashed value of "plain text", that is, the digest.</div>
      <div class="REFTYPES">
<span class="bold_code">DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Signature = binary()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_public_key() | dsa_public_key() | ec_public_key()</span><br>
</div>
  </div>
<div class="REFBODY"><p>
    <p>Verifies a digital signature.</p>
  </p></div>
  


</div>
<div class="footer">
<hr>
<p>Copyright © 2008-2016 Ericsson AB, All Rights Reserved</p>
</div>
</div>
</div></body>
</html>
