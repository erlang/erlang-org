<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- How to Build Erlang/OTP on Windows</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="../pdf/otp-system-documentation.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Installation Guide</strong><br><strong>User's Guide</strong><br><small>Version 6.4</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../js/flipmenu">
<li id="no" title="Installing the Binary Release" expanded="false">Installing the Binary Release<ul>
<li><a href="install-binary.html">
              Top of chapter
            </a></li>
<li title="Windows"><a href="install-binary.html#id61678">Windows</a></li>
</ul>
</li>
<li id="no" title="Building and Installing Erlang/OTP" expanded="false">Building and Installing Erlang/OTP<ul>
<li><a href="INSTALL.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="INSTALL.html#id57724">Introduction</a></li>
<li title="Required Utilities"><a href="INSTALL.html#id60548">Required Utilities</a></li>
<li title="Optional Utilities"><a href="INSTALL.html#id63854">Optional Utilities</a></li>
<li title="How to Build and Install Erlang/OTP"><a href="INSTALL.html#id63836">How to Build and Install Erlang/OTP</a></li>
<li title="Advanced configuration and build of Erlang/OTP"><a href="INSTALL.html#id60719">Advanced configuration and build of Erlang/OTP</a></li>
<li title="Known platform issues"><a href="INSTALL.html#id70897">Known platform issues</a></li>
<li title="Daily Build and Test"><a href="INSTALL.html#id71075">Daily Build and Test</a></li>
<li title="Authors"><a href="INSTALL.html#id71296">Authors</a></li>
<li title="Copyright and License"><a href="INSTALL.html#id71324">Copyright and License</a></li>
</ul>
</li>
<li id="no" title="Cross Compiling Erlang/OTP" expanded="false">Cross Compiling Erlang/OTP<ul>
<li><a href="INSTALL-CROSS.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="INSTALL-CROSS.html#id71679">Introduction</a></li>
<li title="Build and Install Procedure"><a href="INSTALL-CROSS.html#id71984">Build and Install Procedure</a></li>
<li title="Building and Installing the Documentation"><a href="INSTALL-CROSS.html#id72685">Building and Installing the Documentation</a></li>
<li title="Testing the cross compiled system"><a href="INSTALL-CROSS.html#id72716">Testing the cross compiled system</a></li>
<li title="Currently Used Configuration Variables"><a href="INSTALL-CROSS.html#id72800">Currently Used Configuration Variables</a></li>
<li title="Copyright and License"><a href="INSTALL-CROSS.html#id74002">Copyright and License</a></li>
</ul>
</li>
<li id="loadscrollpos" title="How to Build Erlang/OTP on Windows" expanded="true">How to Build Erlang/OTP on Windows<ul>
<li><a href="INSTALL-WIN32.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="INSTALL-WIN32.html#id74185">Introduction</a></li>
<li title="Frequently Asked Questions"><a href="INSTALL-WIN32.html#id74291">Frequently Asked Questions</a></li>
<li title="Tools you Need and Their Environment"><a href="INSTALL-WIN32.html#id74664">Tools you Need and Their Environment</a></li>
<li title="The Shell Environment"><a href="INSTALL-WIN32.html#id75421">The Shell Environment</a></li>
<li title="Building and Installing"><a href="INSTALL-WIN32.html#id75567">Building and Installing</a></li>
<li title="Development"><a href="INSTALL-WIN32.html#id75868">Development</a></li>
<li title="Using GIT"><a href="INSTALL-WIN32.html#id76110">Using GIT</a></li>
<li title="Final Words"><a href="INSTALL-WIN32.html#id76145">Final Words</a></li>
<li title="Copyright and License"><a href="INSTALL-WIN32.html#id76182">Copyright and License</a></li>
</ul>
</li>
<li id="no" title="Patching OTP Applications" expanded="false">Patching OTP Applications<ul>
<li><a href="OTP-PATCH-APPLY.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="OTP-PATCH-APPLY.html#id76278">Introduction</a></li>
<li title="Prerequisites"><a href="OTP-PATCH-APPLY.html#id76337">Prerequisites</a></li>
<li title="Using otp_patch_apply"><a href="OTP-PATCH-APPLY.html#id76379">Using otp_patch_apply</a></li>
<li title="Sanity check"><a href="OTP-PATCH-APPLY.html#id76587">Sanity check</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>4 How to Build Erlang/OTP on Windows</h1>

<p><strong>Table of Contents</strong></p>
  <ul>
<li>
      <span class="bold_code"><a href="#Introduction">Introduction</a></span>
    </li>
<li>
      <span class="bold_code"><a href="#Frequently-Asked-Questions">Frequently Asked Questions</a></span>
    </li>
<li>
      <span class="bold_code"><a href="#Tools-you-Need-and-Their-Environment">Tools you Need and Their Environment</a></span>
    </li>
<li>
      <span class="bold_code"><a href="#The-Shell-Environment">The Shell Environment</a></span>
    </li>
<li>
      <span class="bold_code"><a href="#Building-and-Installing">Building and Installing</a></span>
    </li>
<li>
      <span class="bold_code"><a href="#Development">Development</a></span>
    </li>
<li>
      <span class="bold_code"><a href="#Using-GIT">Using GIT</a></span>
    </li>
<li>
      <span class="bold_code"><a href="#Final-Words">Final Words</a></span>
    </li>
<li>
      <span class="bold_code"><a href="#Copyright-and-License">Copyright and License</a></span>
  </li>
</ul>

<a name="Introduction"></a>
<h3><a name="id74185">4.1 
        Introduction</a></h3>


<p>
This file describes how to build the Erlang emulator and the OTP
libraries on Windows. The instructions apply to versions of Windows
supporting the Cygwin emulated gnuish environment for Windows or the
Msys ditto. We've built on the following platforms: Windows 2003
server, Windows XP Home/Professional, Windows Vista and Windows 7 (32
and 64 bit). You can probably build on Windows 2000, but you will not
be able to install the latest Microsoft SDK, so you have to go back to
some earlier compiler. Any Windows95'ish platform will surely get you
into trouble, what I'm not sure of, but it certainly will...
</p>

<p>
The procedure described uses either Cygwin or Msys as a build
environment, you run the bash shell in Cygwin/Msys and use gnu
make/configure/autoconf etc to do the build. The emulator C-source
code is, however, mostly compiled with Microsoft Visual C++™,
producing a native Windows binary. This is the same procedure as we
use to build the pre-built binaries. The fact that we use VC++ and not
gcc is explained further in the FAQ section.
</p>

<p>
I describe the build procedure to make it possible for open source
customers to build the emulator, given that they have the needed
tools. The binary Windows releases is still a preferred alternative if
one does not have Microsoft's development tools and/or don't want to
install Cygwin or Msys.
</p>

<p>
To use Cygwin/Msys, one needs basic experience from a Unix environment, if
one does not know how to set environment variables, run programs etc
in a Unix environment, one will be quite lost in the Cygwin os Msys
ditto. I can unfortunately not teach all the world how to use
Cygwin and bash, neither how to install Cygwin nor perform basic tasks
on a computer. Please refer to other documentation on the net for
help, or use the binary release instead if you have problems using the
tools.
</p>

<p>
However, if you feel comfortable with the environment and build
system, and have all the necessary tools, you have a great opportunity
to make the Erlang/OTP distribution for Windows better. Please submit
any suggestions and patches to the appropriate <span class="bold_code"><a href="http://www.erlang.org/faq.html">mailing lists</a></span> to let
them find their way into the next version of Erlang. If making changes
to the build system (like makefiles etc) please bear in mind that the
same makefiles are used on Unix/VxWorks, so that your changes
don't break other platforms. That of course goes for C-code too, system
specific code resides in the <span class="code">$ERL_TOP/erts/emulator/sys/win32</span> and
<span class="code">$ERL_TOP/erts/etc/win32</span> directories mostly. The
<span class="code">$ERL_TOP/erts/emulator/beam</span> directory is for common code.
</p>

<p>
Before the R9C release of Erlang/OTP, the Windows release was built
partly on a Unix (Solaris) box and partly on a Windows box, using Perl
hacks to communicate and sync between the two machines. R9C was the
first release ever built solely on Windows, where no Unix machine is
needed at all. Now we've used this build procedure for a couple of
releases, and it has worked fine for us. Still, there might be all
sorts of troubles on different machines and with different
setups. I'll try to give hints wherever I've encountered difficulties,
but please share your experiences by using the <span class="bold_code"><a href="http://www.erlang.org/faq.html">erlang-questions</a></span>
mailing list. I cannot of course help everyone with all
their problems, please try to solve the problems and submit
solutions/workarounds. Remember, it's all about sharing, not about
demanding...
</p>

<p>
Starting with R15B, our build system runs both on Cygwin and Msys
(MinGW's fork of an early cygwin version). Msys is a smaller package
to install and may on some machines run slightly faster. If Cygwin
gives you trouble, try Msys instead, and v.v. Beginning with R15B
there is also a native 64bit version of Erlang for 64bit Windows 7
(only). These instructions apply to both the 32bit VM and the 64bit
ditto.
</p>

<p>
Note that even if you build a 64bit VM, most of the directories and
files involved are still named win32. You can view the name win32 as
meaning any windows version not beeing 16bit. A few occurences of the
name Win64 are however present in the system, for example the
installation file for a 64 bit windows version of Erlang is by default
named <span class="code">otp_win64_&lt;version&gt;.exe</span>.
</p>

<p>
Lets go then, I'll start with a little FAQ, based on in house questions
and misunderstandings.
</p>



<a name="Frequently-Asked-Questions"></a>
<h3><a name="id74291">4.2 
        Frequently Asked Questions</a></h3>


<ul>
<li>
<p>Q: So, now I can build Erlang using GCC on Windows?
</p>

<p>A: No, unfortunately not. You'll need Microsoft's Visual C++
still, a Bourne-shell script (cc.sh) wraps the Visual C++ compiler
and runs it from within the Cygwin environment. All other tools
needed to build Erlang are free-ware/open source, but not the C
compiler. The Windows SDK is however enough to build Erlang, you
do not need to buy Visual C++, just download the SDK (SDK version
7.1 == Visual studio 2010).
</p>

</li>
<li>
<p>Q: Why haven't you got rid of VC++ then, you ******?
</p>

<p>A: Well, partly because it's a good compiler - really! Actually it's
been possible in late R11-releases to build using mingw instead of
visual C++ (you might see the remnants of that in some scripts and
directories). Unfortunately the development of the SMP version for
Windows broke the mingw build and we chose to focus on the VC++ build
as the performance has been much better in the VC++ versions. The
mingw build will possibly be back, but as long as VC++ gives better
performance, the commercial build will be a VC++ one.
</p>

</li>
<li>
<p>Q: OK, you need VC++, but now you've started to demand a very recent
(and expensive) version of Visual studio, not the old and stable VC++
6.0 that was used in earlier versions. Why?
</p>

<p>A: Well, it's not expensive, it's free (as in free beer). Just
download and install the latest Windows SDK from Microsoft and all
the tools you need are there. The included debugger (WinDbg) is
also quite usable, it's what I used when porting Erlang to 64bit
Windows. Another reason to use the latest Microsoft compilers is
DLL compatibility. DLL's using a new version of the standard
library might not load if the VM is compiled with an old VC++
version, why we should aim to use the latest freely available SDK
and compiler.
</p>

</li>
<li>
<p>Q: Can/will I build a Cygwin binary with the procedure you describe?
</p>

<p>A: No, the result will be a pure Windows binary, and as far as I know,
it's not possible to make a Cygwin binary yet. That is of course
something desirable, but there are still some problems with the
dynamic linking (dynamic Erlang driver loading) as well as the TCP/IP
emulation in Cygwin, which, I'm sure of, will improve, but still has
some problems. Fixing those problems might be easy or might be hard.
I suggest you try yourself and share your experience. No one would be
happier if a simple <span class="code">./configure &amp;&amp; make</span> would produce a fully fledged
Cygwin binary. Ericsson does however not pay me to do a Cygwin port, so
such a port would have to happen in spare time, which is a limited
resource...
</p>

</li>
<li>
<p>Q: Hah, I saw you, you used GCC even though you said you didn't!
</p>

<p>A: OK, I admit, one of the files is compiled using Cygwin's or
MinGW's GCC and the resulting object code is then converted to MS
VC++ compatible coff using a small C hack. It's because that
particular file, <span class="code">beam_emu.c</span> benefits immensely from being able
to use the GCC labels-as-values extension, which boosts emulator
performance by up to 50%. That does unfortunately not (yet) mean
that all of OTP could be compiled using GCC, that particular
source code does not do anything system specific and actually is
adopted to the fact that GCC is used to compile it on Windows.
</p>

</li>
<li>
<p>Q: So now there's a MS VC++ project file somewhere and I can build OTP
using the nifty VC++ GUI?
</p>

<p>A: No, never. The hassle of keeping the project files up to date and
do all the steps that constitute an OTP build from within the VC++ GUI
is simply not worth it, maybe even impossible. A VC++ project
file for Erlang/OTP will never happen, at least I will never make
one. Clicking around in super-multi-tab'd dialogs to add a file or
compiler option when it's so much easier in a makefile is simply not
my style.
</p>

</li>
<li>
<p>Q: So how does it all work then?
</p>

<p>A: Cygwin or Msys is the environment, which closely resembles the
environments found on any Unix machine. It's almost like you had a
virtual Unix machine inside Windows. Configure, given certain
parameters, then creates makefiles that are used by the
Cygwin/Msys gnu-make to built the system. Most of the actual
compilers etc are not, however, Cygwin/Msys tools, so I've written
a couple of wrappers (Bourne-shell scripts), which reside in
<span class="code">$ERL_TOP/etc/win32/cygwin_tools</span> and
<span class="code">$ERL_TOP/etc/win32/msys_tools</span>. They all do conversion of
parameters and switches common in the Unix environment to fit the
native Windows tools. Most notable is of course the paths, which
in Cygwin/Msys are Unix-like paths with "forward slashes" (/) and
no drive letters, the Cygwin specific command <span class="code">cygpath</span> is used
for most of the path conversions in a Cygwin environment, other
tools are used (when needed) in the corresponding Msys
environment. Luckily most compilers accept forward slashes instead
of backslashes as path separators, but one still have to get the drive
letters etc right, though. The wrapper scripts are not general in
the sense that, for example, cc.sh would understand and translates
every possible gcc option and passes correct options to
cl.exe. The principle is that the scripts are powerful enough to
allow building of Erlang/OTP, no more, no less. They might need
extensions to cope with changes during the development of Erlang,
that's one of the reasons I made them into shell-scripts and not
Perl-scripts, I believe they are easier to understand and change
that way. I might be wrong though, cause another reason I didn't
write them in Perl is because I've never liked Perl and my Perl
code is no pleasant reading...
</p>

<p>In <span class="code">$ERL_TOP</span>, there is a script called <span class="code">otp_build</span>. That script handles
the hassle of giving all the right parameters to <span class="code">configure</span>/<span class="code">make</span> and
also helps you set up the correct environment variables to work with
the Erlang source under Cygwin.
</p>

</li>
<li>
<p>Q: You use and need Cygwin, but then you haven't taken the time to
port Erlang to the Cygwin environment but instead focus on your
commercial release, is that really ethical?
</p>

<p>A: No, not really, but see this as a step in the right direction. I'm
aiming at GCC compiled emulators and a Cygwin version, but I really
need to do other things as well... In time, but don't hold your
breath...
</p>

</li>
<li>
<p>Q: Can I build something that looks exactly as the commercial release?
</p>

<p>A: Yes, we use the exactly same build procedure.
</p>

</li>
<li>
<p>Q: Which version of Cygwin/Msys and other tools do you use then?
</p>

<p>A: For Cygwin and Msys alike, we try to use the latest releases
available when building. What versions you use shouldn't really
matter, I try to include workarounds for the bugs I've found in
different Cygwin/Msys releases, please help me add workarounds
for new Cygwin/Msys-related bugs as soon as you encounter
them. Also please do submit bug reports to the appropriate Cygwin
and/or Msys developers. The GCC we used for 17 was version
4.7.0 (MinGW 64bit) and 4.3.4 (Cygwin 32bit). We used VC++ 10.0
(i.e. Visual studio 2010), Sun's JDK 1.5.0_17 (32bit) and Sun's
JDK 1.7.0_1 (64bit), NSIS 2.46, and Win32 OpenSSL 0.9.8r. Please
read the next section for details on what you need.
</p>

</li>
<li>
<p>Q: Can you help me setup X in Cygwin?
</p>

<p>A: No, unfortunately I haven't got time to help with Cygwin related
user problems, please read Cygwin related web sites, newsgroups and
mailing lists.
</p>

</li>
<li>
<p>Q: Why is the instruction so long? Is it really that complicated?
</p>

<p>A: Partly it's long because I babble too much, partly because I've
described as much as I could about the installation of the needed
tools. Once the tools are installed, building is quite easy. I also
have tried to make this instruction understandable for people with
limited Unix experience. Cygwin/Msys is a whole new environment to some
Windows users, why careful explanation of environment variables etc
seemed to be in place. The short story, for the experienced and
impatient is:
</p>

<ul>
<li>
<p>Get and install complete Cygwin (latest) or complete MinGW with msys
</p>

</li>
<li>
<p>Install Microsofts Windows SDK 7.1 (and .Net 4)
</p>

</li>
<li>
<p>Get and install Sun's JDK 1.5.0 or higher
</p>

</li>
<li>
<p>Get and install NSIS 2.01 or higher (up to 2.46 tried and working)
</p>

</li>
<li>
<p>Get, build and install OpenSSL 0.9.8r or higher (up to 1.0.0a
tried &amp; working) with static libs.
</p>

</li>
<li>
<p>Get the Erlang source distribution (from
<span class="bold_code"><a href="http://www.erlang.org/download.html">http://www.erlang.org/download.html</a></span>) and unpack with Cygwin's <span class="code">tar</span>.
</p>

</li>
<li>
<p>Set <span class="code">ERL_TOP</span> to where you unpacked the source distribution
</p>

</li>
<li>
<p><span class="code">$ cd $ERL_TOP</span>
</p>

</li>
<li>
<p>Get (from <span class="bold_code"><a href="http://www.erlang.org/download/tcltk85_win32_bin.tar.gz">http://www.erlang.org/download/tcltk85_win32_bin.tar.gz</a></span>)
and unpack the prebuilt TCL/TK binaries for windows with cygwin tar,
standing in <span class="code">$ERL_TOP</span>
</p>

</li>
<li>
<p>Modify PATH and other environment variables so that all these tools
are runnable from a bash shell. Still standing in <span class="code">$ERL_TOP</span>, issue
the following commands:
</p>

<div class="example"><pre>
$ eval `./otp_build env_win32`
$ ./otp_build autoconf
$ ./otp_build configure
$ ./otp_build boot -a
$ ./otp_build release -a
$ ./otp_build installer_win32
$ release/win32/otp_win32_17 /S
</pre></div>
</li>
</ul>
<p>Voila! <span class="code">Start-&gt;Programs-&gt;Erlang OTP 17-&gt;Erlang</span> starts the Erlang
Windows shell.
</p>
</li>
</ul>


<a name="Tools-you-Need-and-Their-Environment"></a>
<h3><a name="id74664">4.3 
        Tools you Need and Their Environment</a></h3>


<p>
You need some tools to be able to build Erlang/OTP on Windows. Most
notably you'll need Cygwin or Msys and Microsofts Windows SDK, but
you also might want a Java compiler, the NSIS install system and
OpenSSL. Well' here's the list:
</p>

<ul>
<li>
<p>Cygwin, the very latest is usually best. Get all the development
tools and of course all the basic ditto. In fact getting the complete
package might be a good idea, as you'll start to love Cygwin after a
while if you're accustomed to Unix. Make sure to get jar and also make
sure <strong>not</strong> to install a Cygwin'ish Java... The Cygwin jar command is
used but Sun's Java compiler and virtual machine...
</p>

<p>If you are going to build a 64bit Windows version, you should make
sure to get MinGW's 64bit gcc installed with cygwin. It's in one of
the development packages.
</p>

<p>URL: <span class="bold_code"><a href="http://www.cygwin.com">http://www.cygwin.com</a></span>
</p>

<p>Get the installer from the web site and use that to install
Cygwin. Be sure to have fair privileges. If you're on a NT domain you
should consider running <span class="code">mkpasswd -d</span> and <span class="code">mkgroup -d</span> after the
installation to get the user databases correct. See their respective
manual pages.
</p>

<p>When you start you first bash shell, you will get an awful prompt. You
might also have a <span class="code">PATH</span> environment variable that contains backslashes
and such. Edit <span class="code">$HOME/.profile</span> and <span class="code">$HOME/.bashrc</span> to set fair prompts
and set a correct PATH. Also do a <span class="code">export SHELL</span> in <span class="code">.profile</span>. For some
non-obvious reason the environment variable <span class="code">$SHELL</span> is not exported in
bash. Also note that <span class="code">.profile</span> is run at login time and <span class="code">.bashrc</span> when
sub shells are created. You'll need to explicitly source <span class="code">.bashrc</span> from
<span class="code">.profile</span> if you want the commands there to be run at login time (like
setting up aliases, shell functions and the like). I personally
usually do like this at the end of <span class="code">.profile</span>:
</p>

<div class="example"><pre>
ENV=$HOME/.bashrc
export ENV
. $ENV
</pre></div>
<p>You might also, if you're a hard core type of person at least, want to
setup X-windows (XFree86), that might be as easy as running startx
from the command prompt and it might be much harder. Use Google to
find help...
</p>

<p>If you don't use X-windows, you might want to setup the Windows
console window by selecting properties in the console system menu
(upper left corner of the window, the Cygwin icon in the title
bar). Especially setting a larger screen buffer size (lines) is useful
as it gets you a scrollbar so you can see whatever error messages
that might appear...
</p>

<p>If you want to use (t)csh instead of bash you're on your own, I
haven't tried and know of no one that has. I expect
that you use bash in all shell examples.
</p>

</li>
<li>
<p>Alternatively you download MinGW and Msys. You'll find the latest
installer at:
</p>

<p>URL: <span class="bold_code"><a href="http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/">http://sourceforge.net/projects/mingw/files/Installer/mingw-get-inst/</a></span>
</p>

<p>Make sure to install everything they've got. 
</p>

<p>To be able to build the 64bit VM, you will also need the 64bit
MinGW compiler from:
</p>

<p>URL: <span class="bold_code"><a href="http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Automated%20Builds/">http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Automated%20Builds/</a></span>
</p>

<p>The latest version should do it. Make sure you download the
<span class="code">mingw-w64-bin_i686-mingw_&lt;something&gt;.zip</span>, not a linux
version. You unzip the package on top of your MinGW installation
(<span class="code">c:\MinGW</span>) and that's it.
</p>

<p>Setting up your environment in Msys is similar to setting it up in
Cygwin.
</p>

</li>
<li>
<p>Microsofts Windows SDK version 7.1 (corresponding to VC++ 10.0 and
Visual Studio 2010). You'll find it here:
</p>

<p>URL: <span class="bold_code"><a href="http://www.microsoft.com/download/en/details.aspx?id=8279">http://www.microsoft.com/download/en/details.aspx?id=8279</a></span>
</p>

<p>but before you install that, you need to have .Net 4 installed,
you'll find that here:
</p>

<p>URL: <span class="bold_code"><a href="http://www.microsoft.com/download/en/details.aspx?id=17851">http://www.microsoft.com/download/en/details.aspx?id=17851</a></span>
</p>

<p>Use the web installer for the SDK, at least when I tried
downloading the whole package as an image, I got SDK 7.0 instead,
which is not what you want...
</p>

<p>There will be a Windows command file in <span class="code">%PROGRAMFILES%\Mirosoft
SDKs\Windows\v7.1\Bin\SetEnv.cmd</span> that set's the appropriate
environment for a Windows command prompt. This is not appropriate
for bash, so you'll need to convert it to bash-style environments
by editing your <span class="code">.bash_profile</span>. In my case, where the SDK is
installed in the default directory and <span class="code">%PROGRAMFILES%</span> is
<span class="code">C:\Program Files</span>, the commands for setting up a 32bit build
environment (on a 64bit or 32bit machine) look like this (in cygwin):
</p>

<div class="example"><pre>
# Some common paths
C_DRV=/cygdrive/c
PRG_FLS=$C_DRV/Program\ Files

# nsis
NSIS_BIN=$PRG_FLS/NSIS
# java
JAVA_BIN=$PRG_FLS/Java/jdk1.6.0_16/bin

##
## MS SDK
##

CYGWIN=nowinsymlinks
MVS10="$PRG_FILES/Microsoft Visual Studio 10.0"
WIN_MVS10="C:\\Program Files\\Microsoft Visual Studio 10.0"
SDK10="$PRG_FILES/Microsoft SDKs/Windows/v7.1"
WIN_SDK10="C:\\Program Files\\Microsoft SDKs\\Windows\\v7.1"

PATH="$NSIS_BIN:\
$MVS10/Common7/IDE:\
$MVS10/Common7/Tools:\
$MVS10/VC/Bin:\
$MVS10/VC/Bin/VCPackages:\
$SDK10/Bin/NETFX 4.0 Tools:\
$SDK10/Bin:\
/usr/local/bin:/usr/bin:/bin:\
/cygdrive/c/WINDOWS/system32:/cygdrive/c/WINDOWS:\
/cygdrive/c/WINDOWS/system32/Wbem:\
$JAVA_BIN"

LIBPATH="$WIN_MVS10\\VC\\LIB"

LIB="$WIN_MVS10\\VC\\LIB;$WIN_SDK10\\LIB"

INCLUDE="$WIN_MVS10\\VC\\INCLUDE;$WIN_SDK10\\INCLUDE;$WIN_SDK10\\INCLUDE\\gl"

export CYGWIN PATH LIBPATH LIB INCLUDE 
</pre></div>
<p>If you're using Msys instead, the only thing you need to change is
the <span class="code">C_DRV</span> setting, which would read:
</p>

<div class="example"><pre>
C_DRV=/c
</pre></div>
<p>And of course you might need to change <span class="code">C:\Program Files</span> etc if
you're using a non-english version of Windows (XP). Note that in
later versions of Windows, the national adoptions of the program
files directories etc are not on the file system but only in the
explorer, so even if explorer says that your programs reside in
e.g. <span class="code">C:\Program</span>, they might still reside in <span class="code">C:\Program Files</span>
in reality...
</p>

<p>If you are building a 64 bit version of Erlang, you should set up
PATHs etc a little differently. I use the following script to
make things work in both Cygwin and Msys:
</p>

<div class="example"><pre>
 make_winpath()
 {
        P=$1
        if [ "$IN_CYGWIN" = "true" ]; then 
           cygpath -d "$P"
        else
           (cd "$P" &amp;&amp; /bin/cmd //C "for %i in (".") do @echo %~fsi")
        fi
 }

 make_upath()
 {
        P=$1
        if [ "$IN_CYGWIN" = "true" ]; then 
           cygpath "$P"
        else
           echo "$P" | /bin/sed 's,^\([a-zA-Z]\):\\,/\L\1/,;s,\\,/,g'
        fi
 }

 # Some common paths
 if [ -x /usr/bin/msysinfo ]; then
    # Without this the path conversion won't work
    COMSPEC='C:\Windows\SysWOW64\cmd.exe'
    MSYSTEM=MINGW32
    export MSYSTEM COMSPEC
    IN_CYGWIN=false
 else
    CYGWIN=nowinsymlinks
    export CYGWIN
    IN_CYGWIN=true
 fi

 if [ "$IN_CYGWIN" = "true" ]; then 
    PATH=/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:\
    /cygdrive/c/windows/system32:/cygdrive/c/windows:/cygdrive/c/windows/system32/Wbem
 else
    PATH=/usr/local/bin:/mingw/bin:/bin:/c/Windows/system32:/c/Windows:\
    /c/Windows/System32/Wbem
 fi

 if [ "$IN_CYGWIN" = "true" ]; then 
    C_DRV=/cygdrive/c
 else
    C_DRV=/c
 fi

 PRG_FLS64=$C_DRV/Program\ Files
 PRG_FLS32=$C_DRV/Program\ Files\ \(x86\)
 VISUAL_STUDIO_ROOT32=$PRG_FLS32/Microsoft\ Visual\ Studio\ 10.0
 MS_SDK_ROOT64=$PRG_FLS64/Microsoft\ SDKs/Windows/v7.1

 # Okay, now mangle the paths and get rid of spaces by using short names
 WIN_VCROOT32=`make_winpath "$VISUAL_STUDIO_ROOT32"`
 VCROOT32=`make_upath $WIN_VCROOT32`
 WIN_SDKROOT64=`make_winpath "$MS_SDK_ROOT64"`
 SDKROOT64=`make_upath $WIN_SDKROOT64`
 WIN_PROGRAMFILES32=`make_winpath "$PRG_FLS32"`
 PROGRAMFILES32=`make_upath $WIN_PROGRAMFILES32`

 WIN_PROGRAMFILES64=`make_winpath "$PRG_FLS64"`
 PROGRAMFILES64=`make_upath $WIN_PROGRAMFILES64`

 # nsis
 NSIS_BIN=$PROGRAMFILES32/NSIS
 # java
 JAVA_BIN=$PROGRAMFILES64/Java/jdk1.7.0_01/bin

 ## The PATH variable should be Unix'ish
 VCPATH=$VCROOT32/Common7/IDE:$VCROOT32/VC/BIN/amd64:$VCROOT32/Common7/Tools:\
 $VCROOT32/VC/VCPackages:$SDKROOT64/bin/NETFX4~1.0TO/x64:$SDKROOT64/bin/x64:\
 $SDKROOT64/bin

 ## Microsoft SDK libs

 LIBPATH=$WIN_VCROOT32\\VC\\LIB\\amd64
 LIB=$WIN_VCROOT32\\VC\\LIB\\amd64\;$WIN_SDKROOT64\\LIB\\X64
 INCLUDE=$WIN_VCROOT32\\VC\\INCLUDE\;$WIN_SDKROOT64\\include\;\
 $WIN_SDKROOT64\\include\\gl

 # Put nsis, c compiler and java in path
 PATH=$NSIS_BIN:$VCPATH:$PATH:$JAVA_BIN

 # Make sure LIB and INCLUDE is available for others
 export PATH LIBPATH LIB INCLUDE
</pre></div>
<p>All this is derived from the SetEnv.cmd command file mentioned
earlier. The bottom line is to set the PATH so that NSIS and
Microsoft SDK is found before the Msys/Cygwin tools and that Java
is last in the PATH.
</p>

<p>Make a simple hello world (maybe one that prints out 
<span class="code">sizeof(void *)</span>) and try to compile it with the <span class="code">cl</span> command from within
bash. If that does not work, your environment needs fixing. Also
remember to fix up the PATH environment, especially old Erlang
installations might have inserted quoted paths that Cygwin/Msys
does not understand. Remove or correct such paths. There should be
no backslashes in your path environment variable in Cygwin bash,
but LIB and INCLUDE should contain Windows style paths with
semicolon, drive letters and backslashes.
</p>

</li>
<li>
<p>Sun's Java JDK 1.5.0 or higher. Our Java code (jinterface, ic) is
written for JDK 1.5.0. Get it for Windows and install it, the JRE is
not enough. If you don't care about Java, you can skip this step, the
result will be that jinterface is not built.
</p>

<p>URL: <span class="bold_code"><a href="http://java.sun.com">http://java.sun.com</a></span>
</p>

<p>Add javac <strong>LAST</strong> to your path environment in bash, in my case this means:
</p>

<div class="example"><pre>
`PATH="$PATH:/cygdrive/c/Program Files/Java/jdk1.5.0_17/bin"`
</pre></div>
<p>No <span class="code">CLASSPATH</span> or anything is needed. Type <span class="code">javac</span> at the bash prompt
and you should get a list of available Java options. Make sure by
typing <span class="code">type java</span> that you use the Java you installed. Note however that
Cygwin's <span class="code">jar.exe</span> is used, that's why the JDK bin-directory should be
added last in the <span class="code">PATH</span>.
</p>

</li>
<li>
<p>Nullsoft NSIS installer system. You need this to build the self
installing package. It's a free open source installer that's much
nicer to use than the commercial Wise and Install shield
installers. This is the installer we use for commercial releases as
well from R9C an on.
</p>

<p>URL: <span class="bold_code"><a href="http://www.nullsoft.com/free/nsis">http://www.nullsoft.com/free/nsis</a></span>
</p>

<p>Install the lot, especially the modern user interface components, as
it's definitely needed. Put <span class="code">makensis</span> in your path, in my case:
</p>

<div class="example"><pre>
PATH=/cygdrive/c/Program\ Files/NSIS:$PATH
</pre></div>
<p>type makensis at the bash prompt and you should get a list of options
if everything is OK.
</p>

</li>
<li>
<p>OpenSSL. This is if you want the SSL and crypto applications to
compile (and run). There are prebuilt binaries available, but I
strongly recommend building this yourself. It's quite easy.
</p>

<p>First get the source from 
</p>

<p>URL: <span class="bold_code"><a href="http://openssl.org/source/">http://openssl.org/source/</a></span>
</p>

<p>I would recommend using 0.9.8r. 
</p>

<p>Download the tar file and unpack it (using your bash prompt) into
a directory of your choise.
</p>

<p>You will need a Windowish Perl for the build. ActiveState has one:
</p>

<p>URL: <span class="bold_code"><a href="http://www.activestate.com/activeperl/downloads">http://www.activestate.com/activeperl/downloads</a></span>
</p>

<p>Download and install that. Disable options to associate it with
the .pl suffix and/or adding things to PATH, they are not needed. 
</p>

<p>Now fire up the Microsoft Windows SDK command prompt in RELEASE
mode for the architecture you are going to build. The easiest is
to copy the shortcut from the SDKs start menu item and edit the
command line in the shortcut (Right click-&gt;Properties) to end with
<span class="code">/Release</span>. Make sure the banner when you double click your
shortcut (the text in the resulting command window) says
<span class="code">Targeting Windows XP x64 Release</span> if you are going to do a 64 bit
build and <span class="code">Targeting Windows XP x86 Release</span> if you are building a
32 bit version.
</p>

<p>Now cd to where you unpacked the OpenSSL source using your Release
Windows command prompt (it should be on the same drive as where
you are going to install it if everything is to work smothly).
</p>

<div class="example"><pre>
C:\&gt; cd &lt;some dir&gt;
</pre></div>
<p>Add ActiveState (or some other windows perl, not cygwins) to your PATH:
</p>

<div class="example"><pre>
C:\...\&gt; set PATH=C:\Perl\bin;%PATH%
</pre></div>
<p>Or if you installed the 64bit perl:
</p>

<div class="example"><pre>
C:\...\&gt; set PATH=C:\Perl64\bin;%PATH%
</pre></div>
<p>Configure OpenSSL for 32 bit:
</p>

<div class="example"><pre>
C:\...\&gt; perl Configure VC-WIN32 --prefix=/OpenSSL
</pre></div>
<p>Or for 64 bit:
</p>

<div class="example"><pre>
C:\...\&gt; perl Configure VC-WIN64A --prefix=/OpenSSL-Win64
</pre></div>
<p>Do some setup (for 32 bit):
</p>

<div class="example"><pre>
C:\...\&gt; ms\do_ms
</pre></div>
<p>The same for 64 bit:
</p>

<div class="example"><pre>
C:\...\&gt; ms\do_win64a
</pre></div>
<p>Then build static libraries and install:
</p>

<div class="example"><pre>
C:\...\&gt; nmake -f ms\nt.mak
C:\...\&gt; nmake -f ms\nt.mak install
</pre></div>
<p>That's it - you now have your perfectly consistent static build of
openssl. If you want to get rid of any possibly patented
algorithms in the lib, just read up on the OpenSSL FAQ and follow
the instructions.
</p>

<p>The installation locations chosen are where configure will look
for OpenSSL, so try to keep them as is.
</p>

</li>
<li>
<p>Building with wxWidgets. Download wxWidgets-2.8.9 or higher patch
release (2.9.*  is a developer release which currently does not work
with wxErlang).
</p>

<p>Install or unpack it to <span class="code">DRIVE:/PATH/cygwin/opt/local/pgm</span>.
</p>

<p>edit:  <span class="code">C:\cygwin\opt\local\pgm\wxMSW-2.8.11\include\wx\msw\setup.h</span>
enable <span class="code">wxUSE_GLCANVAS</span>, <span class="code">wxUSE_POSTSCRIPT</span> and <span class="code">wxUSE_GRAPHICS_CONTEXT</span>
</p>

<p>build: From a command prompt with the VC tools available (See the
instructions for OpenSSL build above for help on starting the
proper command prompt in RELEASE mode):
</p>

<div class="example"><pre>
C:\...\&gt; cd C:\cygwin\opt\local\pgm\wxMSW-2.8.11\build\msw
C:\...\&gt; nmake BUILD=release SHARED=0 UNICODE=1 USE_OPENGL=1 USE_GDIPLUS=1 DIR_SUFFIX_CPU= -f makefile.vc
C:\...\&gt; cd C:\cygwin\opt\local\pgm\wxMSW-2.8.11\contrib\build\stc
C:\...\&gt; nmake BUILD=release SHARED=0 UNICODE=1 USE_OPENGL=1 USE_GDIPLUS=1 DIR_SUFFIX_CPU= -f makefile.vc
</pre></div>
<p>Or - if building a 64bit version:
</p>

<div class="example"><pre>
C:\...\&gt; cd C:\cygwin\opt\local\pgm\wxMSW-2.8.11\build\msw
C:\...\&gt; nmake TARGET_CPU=amd64 BUILD=release SHARED=0 UNICODE=1 USE_OPENGL=1 USE_GDIPLUS=1 DIR_SUFFIX_CPU= -f makefile.vc
C:\...\&gt; cd C:\cygwin\opt\local\pgm\wxMSW-2.8.11\contrib\build\stc
C:\...\&gt; nmake TARGET_CPU=amd64 BUILD=release SHARED=0 UNICODE=1 USE_OPENGL=1 USE_GDIPLUS=1 DIR_SUFFIX_CPU= -f makefile.vc
</pre></div>
</li>
<li>
<p>The Erlang source distribution (from <span class="bold_code"><a href="http://www.erlang.org/download.html">http://www.erlang.org/download.html</a></span>).
The same as for Unix platforms. Preferably use tar from within Cygwin to
unpack the source tar.gz (<span class="code">tar zxf otp_src_17.tar.gz</span>).
</p>

<p>set the environment <span class="code">ERL_TOP</span> to point to the root directory of the
source distribution. Let's say I stood in <span class="code">$HOME/src</span> and unpacked
<span class="code">otp_src_17.tar.gz</span>, I then add the following to <span class="code">.profile</span>:
</p>

<div class="example"><pre>
ERL_TOP=$HOME/src/otp_src_17
export $ERL_TOP
</pre></div>
</li>
<li>
<p>The TCL/TK binaries. You could compile Tcl/Tk for windows yourself,
but you can get a stripped down version from our website which is
suitable to include in the final binary package. If you want to supply
tcl/tk yourself, read the instructions about how the tcl/tk tar file
used in the build is constructed under <span class="code">$ERL_TOP/lib/gs/tcl</span>. The easy
way is to download <span class="bold_code"><a href="http://www.erlang.org/download/tcltk85_win32_bin.tar.gz">http://www.erlang.org/download/tcltk85_win32_bin.tar.gz</a></span>
and unpack it standing in the <span class="code">$ERL_TOP</span> directory. This will create the
file <span class="code">win32.tar.gz</span> in <span class="code">$ERL_TOP/lib/gs/tcl/binaries</span>.
</p>

<p>One last alternative is to create a file named <span class="code">SKIP</span> in the
<span class="code">$ERL_TOP/lib/gs/</span> after configure is run, but that will give you an
erlang system without gs (which might be okay as you probably will use
wx anyway).
</p>

<p>Note that there is no special 64bit version of TCL/TK needed, you
can use the 32bit program even for a 64bit build.
</p>
</li>
</ul>


<a name="The-Shell-Environment"></a>
<h3><a name="id75421">4.4 
        The Shell Environment</a></h3>


<p>
So, if you have followed the instructions above, when you start a bash
shell, you should have an INCLUDE environment with a Windows style
path, a LIB environment variable also in Windows style, and finally a
PATH that let's you reach cl, makensis, javac etc from the
command prompt (use <span class="code">which cl</span> etc to verify from bash).
</p>

<p>
You should also have an <span class="code">ERL_TOP</span> environment variable that is <strong>Cygwin
style</strong>, and points to a directory containing, among other files, the
script <span class="code">otp_build</span>.
</p>

<p>
A final massage of the environment is needed, and that is done by
the script <span class="code">$ERL_TOP/otp_build</span>. Start bash and do the following, note
the "back-ticks" (`), can be quite hard to get on some keyboards, but
pressing the back-tick key followed by the space bar might do it...
</p>

<div class="example"><pre>
$ cd $ERL_TOP
$ eval `./otp_build env_win32`
</pre></div>
<p>
If you're unable to produce back-ticks on your keyboard, you can use
the ksh variant:
</p>

<div class="example"><pre>
$ cd $ERL_TOP
$ eval $(./otp_build env_win32)
</pre></div>
<p>
If you are building a 64 bit version, you supply <span class="code">otp_build</span> with an architecture parameter:
</p>

<div class="example"><pre>
$ cd $ERL_TOP
$ eval `./otp_build env_win32 x64`
</pre></div>
<p>
This should do the final touch to the environment and building should
be easy after this. You could run <span class="code">./otp_build env_win32</span> without
<span class="code">eval</span> just to see what it does, and to see that the environment it
sets seems OK. The path is cleaned of spaces if possible (using DOS
style short names instead), the variables <span class="code">OVERRIDE_TARGET</span>, <span class="code">CC</span>, <span class="code">CXX</span>,
<span class="code">AR</span> and <span class="code">RANLIB</span> are set to their respective wrappers and the directories
<span class="code">$ERL_TOP/erts/etc/win32/cygwin_tools/vc</span> and
<span class="code">$ERL_TOP/erts/etc/win32/cygwin_tool</span> are added first in the PATH.
</p>

<p>
Try now a <span class="code">type erlc</span>. That should result in the erlc wrapper script
(which does not have the .sh extension, for reasons best kept
untold...). It should reside in <span class="code">$ERL_TOP/erts/etc/win32/cygwin_tools</span>
or <span class="code">$ERL_TOP/erts/etc/win32/msys_tools</span>.  You could also try <span class="code">which
cc.sh</span>, which <span class="code">ar.sh</span> etc.
</p>

<p>
Now you're ready to build...
</p>



<a name="Building-and-Installing"></a>
<h3><a name="id75567">4.5 
        Building and Installing</a></h3>


<p>
Now it's assumed that you have executed <span class="code"> eval `./otp_build env_win32` </span> or 
<span class="code"> eval `./otp_build env_win32 x64` </span> for this particular shell...
</p>

<p>
Building is easiest using the <span class="code">otp_build</span> script. That script takes care
of running configure, bootstrapping etc on Windows in a simple
way. The <span class="code">otp_build</span> script is the utility we use ourselves to build on
different platforms and it therefore contains code for all sorts of
platforms. The principle is, however, that for non-Unix platforms, one
uses <span class="code">./otp_build env_&lt;target&gt;</span> to set up environment and then the
script knows how to build on the platform "by itself". You've already
run <span class="code">./otp_build env_win32</span> in the step above, so now it's mostly like
we build on any platform. OK, here are then steps; Assuming you will
want to build a full installation executable with NSIS, you can omit
<span class="code">&lt;installation directory&gt;</span> and the release will be copied to
<span class="code">$ERL_TOP/release/win32</span>: and there is where the packed self installing
executable will reside too.
</p>

<div class="example"><pre>
$ ./otp_build autoconf # Ignore the warning blob about versions of autoconf
$ ./otp_build configure &lt;optional configure options&gt;
$ ./otp_build boot -a
$ ./otp_build release -a &lt;installation directory&gt;
$ ./otp_build installer_win32 &lt;installation directory&gt; # optional
</pre></div>
<p>
Now you will have a file called <span class="code">otp_win32_R12B.exe</span> in the
<span class="code">&lt;installation directory&gt;</span>, i.e. <span class="code">$ERL_TOP/release/win32</span>.
</p>

<p>
Lets get into more detail:
</p>

<ul>
<li>
<p><span class="code">$ ./otp_build autoconf</span> - This step rebuilds the configure scripts
to work correctly in the cygwin environment. In an ideal world, this
would not be needed, but alas, we have encountered several
incompatibilities between our distributed configure scripts (generated
on a Linux platform) and the cygwin environment over the
years. Running autoconf on cygwin ensures that the configure scripts
are generated in a cygwin-compatible way and that they will work well
in the next step.
</p>

</li>
<li>
<p><span class="code">$ ./otp_build configure</span> - This runs the newly generated configure
scripts with options making configure behave nicely. The target machine
type is plainly <span class="code">win32</span>, so a lot of the configure-scripts recognize
this awkward target name and behave accordingly. The CC variable also
makes the compiler be <span class="code">cc.sh</span>, which wraps MSVC++, so all configure
tests regarding the C compiler gets to run the right compiler. A lot of
the tests are not needed on Windows, but I thought it best to run the
whole configure anyway. The only configure option you might want to
supply is <span class="code">--with-ssl</span>, which might be needed if you have built your
own OpenSSL distribution. The Shining Lights distribution should be
found automatically by <span class="code">configure</span>, if that fails, add a
<span class="code">--with-ssl=&lt;dir&gt;</span> that specifies the root directory of your OpenSSL
installation.
</p>

</li>
<li>
<p><span class="code">$ ./otp_build boot -a</span> - This uses the bootstrap directory (shipped
with the source, <span class="code">$ERL_TOP/bootstrap</span>) to build a complete OTP
system. It first builds an emulator and sets up a minimal OTP system
under <span class="code">$ERL_TOP/bootstrap</span>, then starts to compile the different OTP
compilers to make the <span class="code">$ERL_TOP/bootstrap</span> system potent enough to be
able to compile all Erlang code in OTP. Then, all Erlang and C code
under <span class="code">$ERL_TOP/lib</span> is built using the bootstrap system, giving a
complete OTP system (although not installed). When this is done, one
can run Erlang from within the source tree, just type <span class="code">$ERL_TOP/bin/erl</span>
and you should have a prompt. If you omit the -a flag, you'll get a
smaller system, that might be useful during development. Now
exit from Erlang and start making a release of the thing:
</p>

</li>
<li>
<p><span class="code">$ ./otp_build release -a</span> - Builds a commercial release tree from the
source tree, default is to put it in <span class="code">$ERL_TOP/release/win32</span>, you can
give any directory as parameter (Cygwin style), but it doesn't really
matter if you're going to build a self extracting installer too. You
could of course build release to the final directory and then run
<span class="code">./Install.exe</span> standing in the directory where the release was put,
that will create a fully functional OTP installation. But let's make
the nifty installer:
</p>

</li>
<li>
<p><span class="code">$ ./otp_build installer_win32</span> - Create the self extracting installer
executable. The executable <span class="code">otp_win32_17.exe</span> will be placed
in the top directory of the release created in the previous step. If
no release directory is specified, the release is expected to have
been built to <span class="code">$ERL_TOP/release/win32</span>, which also will be the place
where the installer executable will be placed. If you specified some
other directory for the release (i.e. <span class="code">./otp_build release -a
/tmp/erl_release</span>), you're expected to give the same parameter here,
(i.e. <span class="code">./otp_build installer_win32 /tmp/erl_release</span>). You need to have
a full NSIS installation and <span class="code">makensis.exe</span> in your path for this to
work of course. Once you have created the installer, you can run it to
install Erlang/OTP in the regular way, just run the executable and
follow the steps in the installation wizard. To get all default settings
in the installation without any questions asked, you run the executable
with the parameter <span class="code">/S</span> (capital S) like in:
</p>

<div class="example"><pre>
$ cd $ERL_TOP
$ release/win32/otp_win32_17 /S
...
</pre></div>
<p>or
</p>

<div class="example"><pre>
$ cd $ERL_TOP
$ release/win32/otp_win64_17 /S
...
</pre></div>
<p>and after a while Erlang/OTP-17 will have been installed in
<span class="code">C:\Program Files\erl6.4\</span>, with shortcuts in the menu etc.
</p>

<p>The necessary setup of an Erlang installation is actually done by the
program <span class="code">Install.exe</span>, which resides in the release top. That program
creates <span class="code">.ini</span>-files and copies the correct boot scripts. If one has
the correct directory tree (like after a <span class="code">./otp_build release -a</span>), only
the running of <span class="code">Install.exe</span> is necessary to get a fully functional
OTP. What the self extracting installer adds is (of course) the
possibility to distribute the binary easily, together with adding
shortcuts to the Windows start menu. There is also some adding of
entries in the registry, to associate <span class="code">.erl</span> and <span class="code">.beam</span> files with
Erlang and get nifty icons, but that's not something you'll really need
to run Erlang. The registry is also used to store uninstall information,
but if one has not used the self extracting installer, one cannot
(need not) do any uninstall, one just scratches the release directory
and everything is gone. Erlang/OTP does not <strong>need</strong> to put anything
in the Windows registry at all, and does not if you don't use the self
extracting installer. In other words the installer is pure cosmetics.
</p>

</li>
</ul>
<div class="note">
<div class="label">Note</div>
<div class="content"><p>
<p>
Beginning with R9C, the Windows installer does <strong>not</strong> add Erlang
 to the system wide path. If one wants to have Erlang in the path, one
 has to add it by hand.
</p>
</p></div>
</div>



<a name="Development"></a>
<h3><a name="id75868">4.6 
        Development</a></h3>


<p>
Once the system is built, you might want to change it. Having a test
release in some nice directory might be useful, but you also can run
Erlang from within the source tree. The target <span class="code">local_setup</span>, makes
the program <span class="code">$ERL_TOP/bin/erl.exe</span> usable and it also uses all the OTP
libraries in the source tree.
</p>

<p>
If you hack the emulator, you can then build the emulator executable
by standing in <span class="code">$ERL_TOP/erts/emulator</span> and do a simple
</p>

<div class="example"><pre>
$ make opt
</pre></div>
<p>
Note that you need to have run <span class="code">(cd $ERL_TOP &amp;&amp; eval `./otp_build env_win32`)</span>
in the particular shell before building anything on Windows. After
doing a make opt you can test your result by running <span class="code">$ERL_TOP/bin/erl</span>.
If you want to copy the result to a release directory (say
<span class="code">/tmp/erl_release</span>), you do this (still in  <span class="code">$ERL_TOP/erts/emulator</span>)
</p>

<div class="example"><pre>
$ make TESTROOT=/tmp/erl_release release
</pre></div>
<p>
That will copy the emulator executables.
</p>

<p>
To make a debug build of the emulator, you need to recompile both
<span class="code">beam.dll</span> (the actual runtime system) and <span class="code">erlexec.dll</span>. Do like this
</p>

<div class="example"><pre>
$ cd $ERL_TOP
$ rm bin/win32/erlexec.dll
$ cd erts/emulator
$ make debug
$ cd ../etc
$ make debug
</pre></div>
<p>
and sometimes
</p>

<div class="example"><pre>
$ cd $ERL_TOP
$ make local_setup
</pre></div>
<p>
So now when you run <span class="code">$ERL_TOP/erl.exe</span>, you should have a debug compiled
emulator, which you will see if you do a:
</p>

<div class="example"><pre>
1&gt; erlang:system_info(system_version).
</pre></div>
<p>
in the erlang shell. If the returned string contains <span class="code">[debug]</span>, you
got a debug compiled emulator.
</p>

<p>
To hack the erlang libraries, you simply do a <span class="code">make opt</span> in the
specific "applications" directory, like:
</p>

<div class="example"><pre>
$ cd $ERL_TOP/lib/stdlib
$ make opt
</pre></div>
<p>
or even in the source directory...
</p>

<div class="example"><pre>
$ cd $ERL_TOP/lib/stdlib/src
$ make opt
</pre></div>
<p>
Note that you're expected o have a fresh Erlang in your path when
doing this, preferably the plain 17 you have built in the previous
steps. You could also add <span class="code">$ERL_TOP/bootstrap/bin</span> to your <span class="code">PATH</span> before
rebuilding specific libraries, that would give you a good enough
Erlang system to compile any OTP erlang code.  Setting up the path
correctly is a little bit tricky, you still need to have
<span class="code">$ERL_TOP/erts/etc/win32/cygwin_tools/vc</span> and
<span class="code">$ERL_TOP/erts/etc/win32/cygwin_tools</span> <strong>before</strong> the actual emulator
in the path. A typical setting of the path for using the bootstrap
compiler would be:
</p>

<div class="example"><pre>
$ export PATH=$ERL_TOP/erts/etc/win32/cygwin_tools/vc\
:$ERL_TOP/erts/etc/win32/cygwin_tools:$ERL_TOP/bootstrap/bin:$PATH
</pre></div>
<p>
That should make it possible to rebuild any library without hassle...
</p>

<p>
If you want to copy a library (an application) newly built, to a
release area, you do like with the emulator:
</p>

<div class="example"><pre>
$ cd $ERL_TOP/lib/stdlib
$ make TESTROOT=/tmp/erlang_release release
</pre></div>
<p>
Remember that:
</p>

<ul>
<li>
<p>Windows specific C-code goes in the <span class="code">$ERL_TOP/erts/emulator/sys/win32</span>,
<span class="code">$ERL_TOP/erts/emulator/drivers/win32</span> or <span class="code">$ERL_TOP/erts/etc/win32</span>.
</p>

</li>
<li>
<p>Windows specific erlang code should be used conditionally and the
host OS tested in <strong>runtime</strong>, the exactly same beam files should be
distributed for every platform! So write code like:
</p>

<div class="example"><pre>
case os:type() of
    {win32,_} -&gt;
        do_windows_specific();
    Other -&gt;
        do_fallback_or_exit()
end,
</pre></div>
</li>
</ul>
<p>
That's basically all you need to get going.
</p>



<a name="Using-GIT"></a>
<h3><a name="id76110">4.7 
        Using GIT</a></h3>


<p>
You might want to check out versions of the source code from GitHUB. That is possible directly in cygwin, but not in Msys. There is a project MsysGIT:
</p>

<p>
URL:<span class="bold_code"><a href="http://code.google.com/p/msysgit/">http://code.google.com/p/msysgit/</a></span>
</p>

<p>
that makes a nice Git port. The msys prompt you get from MsysGIT is
however not compatible with the full version from MinGW, so you will
need to check out files using MsysGIT's command prompt and then switch
to a common Msys command prompt for building. Also all test suites
cannot be built as MsysGIT/Msys does not handle symbolic links. To
build test suites on Windows, you will need Cygwin for now. Hopefully
all symbolic links will disappear from our repository soon and this
issue will disappear.
</p>



<a name="Final-Words"></a>
<h3><a name="id76145">4.8 
        Final Words</a></h3>

My hope is that the possibility to build the whole system on Windows
will open up for free development on this platform too. There are many
things one might want to do better in the Windows version, like the
window-style command prompt as well as pure Cygwin porting. Although i
realize it's a much larger step to start building on Windows (with all
the software you need) than for instance on Linux, I sincerely hope
that some of you will make the effort and start submitting Windows
friendly patches.

<p>
The first build system for Erlang using Cygwin on Windows was created
by Per Bergkvist. I haven't used his build system, but it's rumored to
be good. The idea to do this came from his work, so credit is well
deserved.
</p>

<p>
Of course this would have been completely impossible without the
excellent Cygwin. The guys at Cygnus solutions and
Redhat deserve a huge THANKS! as well as all the other people in the
free software community who have helped in creating the magnificent
software that constitutes Cygwin.
</p>

<p>
Also the people developing the alternative command prompt Msys and
the MinGW compiler are worth huge THANKS! The 64bit port would have
been impossible without the 64bit MinGW compiler.
</p>

<p>
Good luck and Happy Hacking,
Patrik, OTP
</p>



<a name="Copyright-and-License"></a>
<h3><a name="id76182">4.9 
        Copyright and License</a></h3>


<p>
Copyright Ericsson AB 2003-2014. All Rights Reserved.
</p>

<p>
The contents of this file are subject to the Erlang Public License,
Version 1.1, (the "License"); you may not use this file except in
compliance with the License. You should have received a copy of the
Erlang Public License along with this software. If not, it can be
retrieved online at http://www.erlang.org/.
</p>

<p>
Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
the License for the specific language governing rights and limitations
under the License.
</p>




</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2015 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
