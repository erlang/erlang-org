<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Performance comparison</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="index.html">Reference Manual</a><br><a href="release_notes.html">Release Notes</a><br><a href="megaco.pdf">PDF</a><br><a href="../../index.html">Top</a></small><p><strong>Megaco/H.248</strong><br><strong>User's Guide</strong><br><small>Version 3.17.3</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="megaco_intro.html">
              Top of chapter
            </a></li>
<li title="Scope and Purpose"><a href="megaco_intro.html#id64364">Scope and Purpose</a></li>
<li title="Prerequisites"><a href="megaco_intro.html#id60340">Prerequisites</a></li>
<li title="About This Manual"><a href="megaco_intro.html#id57680">About This Manual</a></li>
<li title="Where to Find More Information"><a href="megaco_intro.html#id60680">Where to Find More Information</a></li>
</ul>
</li>
<li id="no" title="Architecture" expanded="false">Architecture<ul>
<li><a href="megaco_architecture.html">
              Top of chapter
            </a></li>
<li title="Network view"><a href="megaco_architecture.html#id60847">Network view</a></li>
<li title="General"><a href="megaco_architecture.html#id60883">General</a></li>
<li title="Single node config"><a href="megaco_architecture.html#id62760">Single node config</a></li>
<li title="Distributed config"><a href="megaco_architecture.html#id61110">Distributed config</a></li>
<li title="Message round-trip call flow"><a href="megaco_architecture.html#id61306">Message round-trip call flow</a></li>
</ul>
</li>
<li id="no" title="Running the stack" expanded="false">Running the stack<ul>
<li><a href="megaco_run.html">
              Top of chapter
            </a></li>
<li title="Starting"><a href="megaco_run.html#id64455">Starting</a></li>
<li title="MGC startup call flow"><a href="megaco_run.html#id62962">MGC startup call flow</a></li>
<li title="MG startup call flow"><a href="megaco_run.html#id63670">MG startup call flow</a></li>
<li title="Configuring the Megaco stack"><a href="megaco_run.html#id62914">Configuring the Megaco stack</a></li>
<li title="Initial configuration"><a href="megaco_run.html#id64152">Initial configuration</a></li>
<li title="Changing the configuration"><a href="megaco_run.html#id62565">Changing the configuration</a></li>
<li title="The transaction sender"><a href="megaco_run.html#id62591">The transaction sender</a></li>
<li title="Segmentation of transaction replies"><a href="megaco_run.html#id62721">Segmentation of transaction replies</a></li>
</ul>
</li>
<li id="no" title="Internal form and its encodings" expanded="false">Internal form and its encodings<ul>
<li><a href="megaco_encode.html">
              Top of chapter
            </a></li>
<li title="Internal form of messages"><a href="megaco_encode.html#id63908">Internal form of messages</a></li>
<li title="The different encodings"><a href="megaco_encode.html#id65447">The different encodings</a></li>
<li title="Configuration of Erlang distribution encoding module"><a href="megaco_encode.html#id65585">Configuration of Erlang distribution encoding module</a></li>
<li title="Configuration of text encoding module(s)"><a href="megaco_encode.html#id65666">Configuration of text encoding module(s)</a></li>
<li title="Configuration of binary encoding module(s)"><a href="megaco_encode.html#id65882">Configuration of binary encoding module(s)</a></li>
<li title="Handling megaco versions"><a href="megaco_encode.html#id65948">Handling megaco versions</a></li>
<li title="Encoder callback functions"><a href="megaco_encode.html#id66196">Encoder callback functions</a></li>
</ul>
</li>
<li id="no" title="Transport mechanisms" expanded="false">Transport mechanisms<ul>
<li><a href="megaco_transport_mechanisms.html">
              Top of chapter
            </a></li>
<li title="Callback interface"><a href="megaco_transport_mechanisms.html#id66283">Callback interface</a></li>
<li title="Examples"><a href="megaco_transport_mechanisms.html#id66352">Examples</a></li>
</ul>
</li>
<li id="no" title="Implementation examples" expanded="false">Implementation examples<ul>
<li><a href="megaco_examples.html">
              Top of chapter
            </a></li>
<li title="A simple Media Gateway Controller"><a href="megaco_examples.html#id66442">A simple Media Gateway Controller</a></li>
<li title="A simple Media Gateway"><a href="megaco_examples.html#id66490">A simple Media Gateway</a></li>
</ul>
</li>
<li id="no" title="Megaco mib" expanded="false">Megaco mib<ul>
<li><a href="megaco_mib.html">
              Top of chapter
            </a></li>
<li title="Intro"><a href="megaco_mib.html#id66608">Intro</a></li>
<li title="Statistics counters"><a href="megaco_mib.html#id66633">Statistics counters</a></li>
<li title="Distribution"><a href="megaco_mib.html#id66669">Distribution</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Performance comparison" expanded="true">Performance comparison<ul>
<li><a href="megaco_performance.html">
              Top of chapter
            </a></li>
<li title="Comparison of encoder/decoders"><a href="megaco_performance.html#id66747">Comparison of encoder/decoders</a></li>
<li title="System performance characteristics"><a href="megaco_performance.html#id67579">System performance characteristics</a></li>
<li title="Description of encoders/decoders"><a href="megaco_performance.html#id67616">Description of encoders/decoders</a></li>
<li title="Setup"><a href="megaco_performance.html#id67726">Setup</a></li>
<li title="Summary"><a href="megaco_performance.html#id67739">Summary</a></li>
</ul>
</li>
<li id="no" title="Testing and tools" expanded="false">Testing and tools<ul>
<li><a href="megaco_debug.html">
              Top of chapter
            </a></li>
<li title="Tracing"><a href="megaco_debug.html#id67868">Tracing</a></li>
<li title="Measurement and transformation"><a href="megaco_debug.html#id67913">Measurement and transformation</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>8 Performance comparison</h1>
  

  <h3><a name="id66747">8.1 
        Comparison of encoder/decoders</a></h3>
    
    <p>The Megaco/H.248 standard defines both a plain text encoding and a 
      binary encoding (ASN.1 BER) and we have implemented encoders and 
      decoders for both. We do supply a bunch of different encoding/decoding 
      modules and the user may in fact implement their own (like our erl_dist 
      module). Using a non-standard encoding format has its obvious drawbacks, 
      but may be useful in some configurations.</p>

    <p>We have made four different measurements of our Erlang/OTP 
      implementation of the Megaco/H.248 protocol stack, in order to compare 
      our different encoders/decoders. The result of each one is summarized 
      in the table below.</p>

    <p>The result above are the fastest 
      of these configurations for each codec. The figures presented are 
      the average of all used messages.</p>

    <p>For comparison, also included are first, performance figures with
      megaco (including the measurement software) and asn1 applications 
      hipe-compiled (second figure in the time columns, note that per bin 
      decode had some issues so those figures are not included), and second, 
      performance figures where the flex driver was built as 
      <span class="code">non-reentrant</span> flex
      (third figure in the time columns, 
      only valid for text codecs using the flex-scanner, 
      figures within parenthesis). </p>

    <table border="1" cellpadding="2" cellspacing="0">
<tr>
        <td align="left" valign="middle"><strong>Codec and config</strong></td>
        <td align="left" valign="middle"><strong>Size</strong></td>
        <td align="left" valign="middle"><strong>Encode</strong></td>
        <td align="left" valign="middle"><strong>Decode</strong></td>
        <td align="left" valign="middle"><strong>Total</strong></td>
      </tr>
<tr>
        <td align="left" valign="middle">pretty</td>
        <td align="left" valign="middle">336</td>
        <td align="left" valign="middle">20 / 13</td>
        <td align="left" valign="middle">75 / 40</td>
        <td align="left" valign="middle">95 / 53</td>
      </tr>
<tr>
        <td align="left" valign="middle">pretty [flex]</td>
        <td align="left" valign="middle">336</td>
        <td align="left" valign="middle">20 / 13 / 20</td>
        <td align="left" valign="middle">39 / 33 / 38</td>
        <td align="left" valign="middle">59 / 46 / 58</td>
      </tr>
<tr>
        <td align="left" valign="middle">compact</td>
        <td align="left" valign="middle">181</td>
        <td align="left" valign="middle">17 / 10</td>
        <td align="left" valign="middle">62 / 35</td>
        <td align="left" valign="middle">79 / 45</td>
      </tr>
<tr>
        <td align="left" valign="middle">compact [flex]</td>
        <td align="left" valign="middle">181</td>
        <td align="left" valign="middle">17 / 10 / 17</td>
        <td align="left" valign="middle">37 / 31 / 36</td>
	<td align="left" valign="middle">54 / 41 / 53</td>
      </tr>
<tr>
        <td align="left" valign="middle">per bin</td>
        <td align="left" valign="middle">91</td>
        <td align="left" valign="middle">60 / 29</td>
        <td align="left" valign="middle">64 / -</td>
        <td align="left" valign="middle">124 / -</td>
      </tr>
<tr>
        <td align="left" valign="middle">per bin [driver]</td>
        <td align="left" valign="middle">91</td>
        <td align="left" valign="middle">39 / 24</td>
        <td align="left" valign="middle">42 / 26</td>
        <td align="left" valign="middle">81 / 50</td>
      </tr>
<tr>
        <td align="left" valign="middle">per bin [native]</td>
        <td align="left" valign="middle">91</td>
        <td align="left" valign="middle">45 / 21</td>
        <td align="left" valign="middle">48 / -</td>
        <td align="left" valign="middle">93 / -</td>
      </tr>
<tr>
        <td align="left" valign="middle">per bin [driver,native]</td>
        <td align="left" valign="middle">91</td>
        <td align="left" valign="middle">25 / 15</td>
        <td align="left" valign="middle">27 / 18</td>
        <td align="left" valign="middle">52 / 33</td>
      </tr>
<tr>
        <td align="left" valign="middle">ber bin</td>
        <td align="left" valign="middle">165</td>
        <td align="left" valign="middle">32 / 19</td>
        <td align="left" valign="middle">38 / 21</td>
        <td align="left" valign="middle">70 / 40</td>
      </tr>
<tr>
        <td align="left" valign="middle">ber bin [driver]</td>
        <td align="left" valign="middle">165</td>
        <td align="left" valign="middle">32 / 19</td>
        <td align="left" valign="middle">33 / 20</td>
        <td align="left" valign="middle">65 / 39</td>
      </tr>
<tr>
        <td align="left" valign="middle">ber bin [native]</td>
        <td align="left" valign="middle">165</td>
        <td align="left" valign="middle">17 / 11</td>
        <td align="left" valign="middle">25 / 13</td>
        <td align="left" valign="middle">42 / 24</td>
      </tr>
<tr>
        <td align="left" valign="middle">ber bin [driver,native]</td>
        <td align="left" valign="middle">165</td>
        <td align="left" valign="middle">17 / 11</td>
        <td align="left" valign="middle">17 / 12</td>
        <td align="left" valign="middle">34 / 23</td>
      </tr>
<tr>
        <td align="left" valign="middle">erl_dist</td>
        <td align="left" valign="middle">875</td>
        <td align="left" valign="middle">5  /  5</td>
        <td align="left" valign="middle">10 / 10</td>
        <td align="left" valign="middle">15 / 15</td>
      </tr>
<tr>
        <td align="left" valign="middle">erl_dist [megaco_compressed]</td>
        <td align="left" valign="middle">405</td>
        <td align="left" valign="middle">6  / 4</td>
        <td align="left" valign="middle">7  / 4</td>
        <td align="left" valign="middle">13 / 8</td>
      </tr>
<tr>
        <td align="left" valign="middle">erl_dist [compressed]</td>
        <td align="left" valign="middle">345</td>
        <td align="left" valign="middle">47 / 47</td>
        <td align="left" valign="middle">20 / 20</td>
        <td align="left" valign="middle">67 / 67</td>
      </tr>
<tr>
        <td align="left" valign="middle">erl_dist [megaco_compressed,compressed]</td>
        <td align="left" valign="middle">200</td>
        <td align="left" valign="middle">34 / 33</td>
        <td align="left" valign="middle">11 /  9</td>
        <td align="left" valign="middle">45 / 42</td>
      </tr>
</table>
<em>Table
        8.1:
         
        Codec performance</em>
  

  <h3><a name="id67579">8.2 
        System performance characteristics</a></h3>
    
    <p>This is primarily a way to show the effects of using the 
      reentrant flex scanner instead of the non-reentrant. </p>
    <p>As can be seen from the figures above there is no real difference 
      between a non-reentrant and an reentrant flex scanner when it 
      comes to the decode times of an individual message. </p>
    <p>The real difference is instead in system characteristics, which 
      is best shown with the mstone1 test. </p>
    <p>When running SMP erlang on a multi-core machine the "throughput"
      is significantly higher. The mstone1 test is an extreme test,
      but it shows what is gained by using the reentrant flex-scanner. </p>
    <img alt="IMAGE MISSING" src="mstone1.jpg"><br>
        <em>Figure
        8.1:
         
        MStone1 with mstone1.sh -d flex -s 4</em>
    
  

  <h3><a name="id67616">8.3 
        Description of encoders/decoders</a></h3>
    
    <p>In Appendix A of the Megaco/H.248 specification (RFC 3525), there are 
      about 30 messages that shows a representative call flow. We have also 
      added a few extra version 1, version 2 and version 3 messages. 
      We have used these messages as basis for our measurements. 
      Our figures have not been weighted in regard to how frequent 
      the different kinds of messages that are sent between the media 
      gateway and its controller.</p>
    <p>The test compares the following encoder/decoders:</p>
    <ul>
      <li>
        <p><strong>pretty</strong> - pretty printed text. In the text encoding, 
          the protocol stack implementors have the choice of using a 
          mix of short and long keywords. It is also possible to add 
          white spaces to improve readability. The pretty text encoding 
          utilizes long keywords and an indentation style like the 
          text examples in the Megaco/H.248 specification.</p>
      </li>
      <li>
        <p><strong>compact</strong> - the compact text encoding uses the shortest 
          possible keywords and no optional white spaces.</p>
      </li>
      <li>
        <p><strong>ber</strong> - ASN.1 BER.</p>
      </li>
      <li>
        <p><strong>per</strong> - ASN.1 PER. Not standardized as a valid 
          Megaco/H.248 encoding, but included for the matter of completeness 
          as its encoding is extremely compact.</p>
      </li>
      <li>
        <p><strong>erl_dist</strong> - Erlang's native distribution format. Not 
          standardized as a valid Megaco/H.248 encoding, but included 
          as a reference due to its well known performance characteristics. 
          Erlang is a dynamically typed language and any Erlang data 
          structure may be serialized to the erl_dist format by using 
          built-in functions.</p>
      </li>
    </ul>
    <p>The actual encoded messages have been collected in one directory per 
      encoding type, containing one file per encoded message.</p>
    <p>Here follows an example of a text message to give a feeling of the 
      difference between the pretty and compact versions of text messages. 
      First the pretty printed, well indented version with long keywords:</p>
    <p></p>
    <div class="example"><pre>
MEGACO/1 [124.124.124.222] 
  Transaction = 9998 { 
    Context = - { 
      ServiceChange = ROOT { 
        Services { 
          Method = Restart, 
          ServiceChangeAddress = 55555, 
          Profile = ResGW/1, 
          Reason = "901 MG Cold Boot"
        }
      }  
    }
  }    </pre></div>
    <p>Then the compact text version without indentation and with short 
      keywords:</p>
    <div class="example"><pre>
!/1 [124.124.124.222] T=9998{
  C=-{SC=ROOT{SV{MT=RS,AD=55555,PF=ResGW/1,RE="901 MG Cold Boot"}}}}    </pre></div>
  

  <h3><a name="id67726">8.4 
        Setup</a></h3>
    
    <p>The measurements has been performed on a 
      HP xw4600 Workstation with 
      a Intel(R) Core(TM)2 Quad CPU Q9550 @ 2.83GHz, with 4 GB memory and 
      running Ubuntu 10.04 x86_64, kernel 2.6.32-22-generic. 
      Software versions was open source OTP R13B04 (megaco-3.14).</p>
  

  <h3><a name="id67739">8.5 
        Summary</a></h3>
    
    <p>In our measurements we have seen that there are no significant 
      differences in message sizes between ASN.1 BER and the compact 
      text format. Some care should be taken when using the pretty text 
      style (which is used in all the examples included in the protocol 
      specification and preferred during debugging sessions) since the 
      messages can then be quite large. If the message size really is a 
      serious issue, our per encoder should be used, as the ASN.1 PER 
      format is much more compact than all the other alternatives. Its 
      major drawback is that it is has not been approved as a valid 
      Megaco/H.248 message encoding.</p>

    <p>When it comes to pure encode/decode performance, it turns out that:</p>
    <ul> 
      <li>
        <p>our fastest binary encoder (ber) is about equal 
          to our fastest text encoder (compact). </p>
      </li>
      <li>
        <p>our fastest binary decoder (ber) is about 54% (61%) faster than our 
          fastest text decoder (compact). </p>
      </li>
    </ul> 

    <p>If the pure encode/decode performance really is a serious issue, our 
      erl_dist encoder could be used, as the encoding/decoding of the 
      erlang distribution format is much faster than all the other 
      alternatives. Its major drawback is that it is has not been approved 
      as a valid Megaco/H.248 message encoding.</p>

    <p>There is no performance advantage of building (and using) a 
      non-reentrant flex scanner over a reentrant flex scanner (if flex
      supports building such a scanner). </p>

    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>Please, observe that these performance figures are related to our 
        implementation in Erlang/OTP. Measurements of other implementations 
        using other tools and techniques may of course result in other 
        figures. </p>
    </p></div>
</div>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 2000-2015 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
