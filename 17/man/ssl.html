<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- ssl</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/ssl/users_guide.html">User's Guide</a><br><a href="../apps/ssl/index.html">Reference Manual</a><br><a href="../apps/ssl/release_notes.html">Release Notes</a><br><a href="../apps/ssl/ssl.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Secure Socket Layer </strong><br><strong>Reference Manual</strong><br><small>Version 6.0</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li title="ssl (App)"><a href="ssl_app.html">ssl (App)
                </a></li>
<li id="loadscrollpos" title="ssl " expanded="true">ssl<ul>
<li><a href="ssl.html">
                  Top of manual page
                </a></li>
<li title="cipher_suites-0"><a href="ssl.html#cipher_suites-0">cipher_suites/0</a></li>
<li title="cipher_suites-1"><a href="ssl.html#cipher_suites-1">cipher_suites/1</a></li>
<li title="clear_pem_cache-0"><a href="ssl.html#clear_pem_cache-0">clear_pem_cache/0</a></li>
<li title="connect-2"><a href="ssl.html#connect-2">connect/2</a></li>
<li title="connect-3"><a href="ssl.html#connect-3">connect/3</a></li>
<li title="connect-3"><a href="ssl.html#connect-3">connect/3</a></li>
<li title="connect-4"><a href="ssl.html#connect-4">connect/4</a></li>
<li title="close-1"><a href="ssl.html#close-1">close/1</a></li>
<li title="controlling_process-2"><a href="ssl.html#controlling_process-2">controlling_process/2</a></li>
<li title="connection_info-1"><a href="ssl.html#connection_info-1">connection_info/1</a></li>
<li title="format_error-1"><a href="ssl.html#format_error-1">format_error/1</a></li>
<li title="getopts-2"><a href="ssl.html#getopts-2">getopts/2</a></li>
<li title="listen-2"><a href="ssl.html#listen-2">listen/2</a></li>
<li title="peercert-1"><a href="ssl.html#peercert-1">peercert/1</a></li>
<li title="peername-1"><a href="ssl.html#peername-1">peername/1</a></li>
<li title="recv-2"><a href="ssl.html#recv-2">recv/2</a></li>
<li title="recv-3"><a href="ssl.html#recv-3">recv/3</a></li>
<li title="prf-5"><a href="ssl.html#prf-5">prf/5</a></li>
<li title="renegotiate-1"><a href="ssl.html#renegotiate-1">renegotiate/1</a></li>
<li title="send-2"><a href="ssl.html#send-2">send/2</a></li>
<li title="setopts-2"><a href="ssl.html#setopts-2">setopts/2</a></li>
<li title="shutdown-2"><a href="ssl.html#shutdown-2">shutdown/2</a></li>
<li title="ssl_accept-1"><a href="ssl.html#ssl_accept-1">ssl_accept/1</a></li>
<li title="ssl_accept-2"><a href="ssl.html#ssl_accept-2">ssl_accept/2</a></li>
<li title="ssl_accept-2"><a href="ssl.html#ssl_accept-2">ssl_accept/2</a></li>
<li title="ssl_accept-3"><a href="ssl.html#ssl_accept-3">ssl_accept/3</a></li>
<li title="sockname-1"><a href="ssl.html#sockname-1">sockname/1</a></li>
<li title="start-0"><a href="ssl.html#start-0">start/0</a></li>
<li title="start-1"><a href="ssl.html#start-1">start/1</a></li>
<li title="stop-0"><a href="ssl.html#stop-0">stop/0</a></li>
<li title="transport_accept-1"><a href="ssl.html#transport_accept-1">transport_accept/1</a></li>
<li title="transport_accept-2"><a href="ssl.html#transport_accept-2">transport_accept/2</a></li>
<li title="versions-0"><a href="ssl.html#versions-0">versions/0</a></li>
<li title="negotiated_next_protocol-1"><a href="ssl.html#negotiated_next_protocol-1">negotiated_next_protocol/1</a></li>
</ul>
</li>
<li id="no" title="ssl_session_cache_api " expanded="false">ssl_session_cache_api<ul>
<li><a href="ssl_session_cache_api.html">
                  Top of manual page
                </a></li>
<li title="delete-2"><a href="ssl_session_cache_api.html#delete-2">delete/2</a></li>
<li title="foldl-3"><a href="ssl_session_cache_api.html#foldl-3">foldl/3</a></li>
<li title="init-0"><a href="ssl_session_cache_api.html#init-0">init/0</a></li>
<li title="lookup-2"><a href="ssl_session_cache_api.html#lookup-2">lookup/2</a></li>
<li title="select_session-2"><a href="ssl_session_cache_api.html#select_session-2">select_session/2</a></li>
<li title="terminate-1"><a href="ssl_session_cache_api.html#terminate-1">terminate/1</a></li>
<li title="update-3"><a href="ssl_session_cache_api.html#update-3">update/3</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>ssl</h1></center>
  
  <h3>MODULE</h3>
<div class="REFBODY">ssl</div>
  <h3>MODULE SUMMARY</h3>
<div class="REFBODY">Interface Functions for Secure Socket Layer</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>This module contains interface functions to the Secure Socket
      Layer. 
    </p>
  </p></div>
  
  <h3><a name="id57576">SSL</a></h3>
<div class="REFBODY">
    

    <ul>
      <li>ssl requires the crypto and public_key applications.</li>
      <li>Supported SSL/TLS-versions are SSL-3.0, TLS-1.0,
      TLS-1.1 and TLS-1.2.</li>
      <li>For security reasons sslv2 is not supported.</li>
      <li>Ephemeral Diffie-Hellman cipher suites are supported
      but not Diffie Hellman Certificates cipher suites.</li>
      <li>Elliptic Curve cipher suites are supported if crypto
      supports it and named curves are used.
      </li>
      <li>Export cipher suites are not supported as the
      U.S. lifted its export restrictions in early 2000.</li>
      <li>IDEA cipher suites are not supported as they have
      become deprecated by the latest TLS spec so there is not any
      real motivation to implement them.</li>
      <li>CRL and policy certificate extensions are not supported
      yet. However CRL verification is supported by public_key, only not integrated
      in ssl yet. </li>
      <li>Support for 'Server Name Indication' extension client side
      (RFC 6066 section 3).</li>
    </ul>
 
  </div>
  
  <h3><a name="id61023">COMMON DATA TYPES</a></h3>
<div class="REFBODY">
    
    <p>The following data types are used in the functions below:
    </p>

    <p><span class="code">boolean() = true | false</span></p>

    <p><span class="code">option() = socketoption() | ssloption() | transportoption()</span></p>

     <p><span class="code">socketoption() = proplists:property() - The default socket options are
      [{mode,list},{packet, 0},{header, 0},{active, true}].
    </span></p>

    <p>For valid options
      see <span class="bold_code"><a href="inet.html">inet(3)</a></span> and
      <span class="bold_code"><a href="gen_tcp.html">gen_tcp(3)</a></span>.
    </p>
    
    <p><a name="type-ssloption"></a><span class="code">ssloption() = {verify, verify_type()} |
      {verify_fun, {fun(), term()}} |
      {fail_if_no_peer_cert, boolean()}
      {depth, integer()} |
      {cert, der_encoded()}| {certfile, path()} |
      {key, {'RSAPrivateKey'| 'DSAPrivateKey' | 'ECPrivateKey' |'PrivateKeyInfo', der_encoded()}} |
      {keyfile, path()} | {password, string()} |
      {cacerts, [der_encoded()]} | {cacertfile, path()} |
      |{dh, der_encoded()} | {dhfile, path()} | {ciphers, ciphers()} |
      {user_lookup_fun, {fun(), term()}}, {psk_identity, string()}, {srp_identity, {string(), string()}} |
      {ssl_imp, ssl_imp()} | {reuse_sessions, boolean()} | {reuse_session, fun()}
      {next_protocols_advertised, [binary()]} |
      {client_preferred_next_protocols, {client | server, [binary()]} | {client | server, [binary()], binary()}} |
      {log_alert, boolean()} | {server_name_indication, hostname() | disable}
    </span></p>

    <p><span class="code">transportoption() = {cb_info, {CallbackModule::atom(), DataTag::atom(), ClosedTag::atom(), ErrTag:atom()}}
	- defaults to {gen_tcp, tcp, tcp_closed, tcp_error}. Can be used to customize
	the transport layer. The callback module must implement a reliable transport
	protocol and behave as gen_tcp and in addition have functions corresponding to
	inet:setopts/2, inet:getopts/2, inet:peername/1, inet:sockname/1 and inet:port/1.
	The callback gen_tcp is treated specially and will call inet directly.
    </span></p>
    
    <p><span class="code">      CallbackModule =
	atom()</span>
    </p> <p><span class="code">      DataTag =
	atom() - tag used in socket data message.</span></p>
    <p><span class="code">      ClosedTag = atom() - tag used in
    socket close message.</span></p>

    <p><span class="code">verify_type() = verify_none | verify_peer</span></p>
    
    <p><span class="code">path() = string() - representing a file path.</span></p>

    <p><span class="code">der_encoded() = binary() -Asn1 DER encoded entity as an erlang binary.</span></p>
    
    <p><span class="code">host() = hostname() | ipaddress()</span></p>
        
    <p><span class="code">hostname() = string()</span></p>
    
    <p><span class="code">
      ip_address() = {N1,N2,N3,N4}  % IPv4
      | {K1,K2,K3,K4,K5,K6,K7,K8}  % IPv6    </span></p>

    <p><span class="code">sslsocket() - opaque to the user. </span></p>
    
    <p><span class="code">protocol() = sslv3 | tlsv1 | 'tlsv1.1' | 'tlsv1.2' </span></p>
    
    <p><span class="code">ciphers() = [ciphersuite()] | string() (according to old API)</span></p>
    
    <p><span class="code">ciphersuite() =
      {key_exchange(), cipher(), hash()}</span></p>
    
    <p><span class="code">key_exchange() =  rsa | dhe_dss | dhe_rsa | dh_anon
       | psk | dhe_psk | rsa_psk | srp_anon | srp_dss | srp_rsa
       | ecdh_anon | ecdh_ecdsa | ecdhe_ecdsa | ecdh_rsa | ecdhe_rsa
    </span></p>

   <p><span class="code">cipher() = rc4_128 | des_cbc | '3des_ede_cbc'
      | aes_128_cbc | aes_256_cbc </span></p>

   <p> <span class="code">hash() = md5 | sha
    </span></p>

    <p><span class="code">prf_random() =  client_random | server_random
    </span></p>

   <p><span class="code">srp_param_type() = srp_1024 | srp_1536 | srp_2048 | srp_3072
      | srp_4096 | srp_6144 | srp_8192</span></p>

  </div>

  <h3><a name="id58951">SSL OPTION DESCRIPTIONS - COMMON for SERVER and CLIENT</a></h3>
<div class="REFBODY">
    

    <p>Options described here are options that are have the same
    meaning in the client and the server.
    </p>
    
    <dl>

      <dt><strong>{cert, der_encoded()}</strong></dt>
      <dd> The DER encoded users certificate. If this option
      is supplied it will override the certfile option.</dd>
      
      <dt><strong>{certfile, path()}</strong></dt>
      <dd>Path to a file containing the user's PEM encoded certificate.</dd>
      
      <dt><strong>{key, {'RSAPrivateKey'| 'DSAPrivateKey' | 'ECPrivateKey' |'PrivateKeyInfo', der_encoded()}}</strong></dt>
      <dd> The DER encoded users private key. If this option
      is supplied it will override the keyfile option.</dd>
      
      <dt><strong>{keyfile, path()}</strong></dt>
      <dd>Path to file containing user's
      private PEM encoded key. As PEM-files may contain several
      entries this option defaults to the same file as given by
      certfile option.</dd>

      <dt><strong>{password, string()}</strong></dt>
      <dd>String containing the user's password.
	Only used if the private keyfile is password protected.
      </dd>

      <dt><strong>{cacerts, [der_encoded()]}</strong></dt>
      <dd> The DER encoded trusted certificates. If this option
      is supplied it will override the cacertfile option.</dd>

      <dt><strong>{ciphers, ciphers()}</strong></dt>
      <dd>The cipher suites that should be supported. The function
      <span class="code">cipher_suites/0</span> can be used to find all ciphers that are
      supported by default.  <span class="code">cipher_suites(all)</span> may be called
      to find all available cipher suites.   
      Pre-Shared Key (<span class="bold_code"><a href="http://www.ietf.org/rfc/rfc4279.txt">RFC 4279</a></span> and
      <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5487.txt">RFC 5487</a></span>), 
      Secure Remote Password (<span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5054.txt">RFC 5054</a></span>) 
      and anonymous cipher suites only work if explicitly enabled by
      this option and they are supported/enabled by the peer also.
      Note that anonymous cipher suites are supported for testing purposes
      only and should not be used when security matters.
      </dd>

      <dt><strong>{ssl_imp, new | old}</strong></dt>
      <dd>No longer has any meaning as the old implementation has
      been removed, it will be ignored.
      </dd>

      <dt><strong>{secure_renegotiate, boolean()}</strong></dt>
      <dd>Specifies if to reject renegotiation attempt that does
      not live up to <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5746.txt">RFC 5746</a></span>. By default secure_renegotiate is
      set to false i.e. secure renegotiation will be used if possible
      but it will fallback to unsecure renegotiation if the peer
      does not support <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5746.txt">RFC 5746</a></span>.
      </dd>

      <dt><strong>{depth, integer()}</strong></dt>
      <dd>
	The depth is the maximum number of non-self-issued
	intermediate certificates that may follow the peer certificate
	in a valid certification path.  So if depth is 0 the PEER must
	be signed by the trusted ROOT-CA directly, if 1 the path can
	be PEER, CA, ROOT-CA, if it is 2 PEER, CA, CA, ROOT-CA and so
	on.  The default value is 1.
      </dd>

      <dt><strong>{verify_fun, {Verifyfun :: fun(), InitialUserState :: term()}}</strong></dt>
      <dd>
	<p>The verification fun should be defined as:</p>

	<div class="example"><pre>
fun(OtpCert :: #'OTPCertificate'{}, Event :: {bad_cert, Reason :: atom() | {revoked, atom()}} |
	     {extension, #'Extension'{}}, InitialUserState :: term()) -&gt;
	{valid, UserState :: term()} | {valid_peer, UserState :: term()} |
	{fail, Reason :: term()} | {unknown, UserState :: term()}.
	</pre></div>

	<p>The verify fun will be called during the X509-path
	validation when an error or an extension unknown to the ssl
	application is encountered. Additionally it will be called
	when a certificate is considered valid by the path validation
	to allow access to each certificate in the path to the user
	application. Note that it will differentiate between the
	peer certificate and CA certificates by using valid_peer or
	valid as the second argument to the verify fun.  See <span class="bold_code"><a href="../apps/public_key/cert_records.html">the public_key User's
	Guide</a></span> for definition of #'OTPCertificate'{} and
	#'Extension'{}.</p>

	<p>If the verify callback fun returns {fail, Reason}, the
	verification process is immediately stopped and an alert is
	sent to the peer and the TLS/SSL handshake is terminated. If
	the verify callback fun returns {valid, UserState}, the
	verification process is continued.  If the verify callback fun
	always returns {valid, UserState}, the TLS/SSL handshake will
	not be terminated with respect to verification failures and
	the connection will be established. If called with an
	extension unknown to the user application, the return value
	{unknown, UserState} should be used.</p>

	<p>The default verify_fun option in verify_peer mode:</p>

      <div class="example"><pre>
{fun(_,{bad_cert, _} = Reason, _) -&gt;
	 {fail, Reason};
    (_,{extension, _}, UserState) -&gt;
	 {unknown, UserState};
    (_, valid, UserState) -&gt;
	 {valid, UserState};
    (_, valid_peer, UserState) -&gt;
         {valid, UserState}
 end, []}
      </pre></div>

      <p>The default verify_fun option in verify_none mode:</p>

       <div class="example"><pre>
{fun(_,{bad_cert, _}, UserState) -&gt;
	 {valid, UserState};
    (_,{extension, _}, UserState) -&gt;
	 {unknown, UserState};
    (_, valid, UserState) -&gt;
	 {valid, UserState};
    (_, valid_peer, UserState) -&gt;
         {valid, UserState}
 end, []}
      </pre></div>

      <p>Possible path validation errors are given on the form {bad_cert, Reason} where Reason is:</p>

      <dl>
	<dt><strong>unknown_ca</strong></dt>
	<dd>No trusted CA was found in the trusted store. The trusted CA is
	normally a so called ROOT CA that is a self-signed cert. Trust may
	be claimed for an intermediat CA (trusted anchor does not have to be self signed
	according to X-509) by using the option <span class="code">partial_chain</span>
</dd>

	<dt><strong>selfsigned_peer</strong></dt>
	<dd>The chain consisted only of one self-signed certificate.</dd>

	<dt><strong>PKIX X-509-path validation error</strong></dt>
	<dd> Possible such reasons see <span class="bold_code"><a href="public_key.html#pkix_path_validation-3"> public_key:pkix_path_validation/3 </a></span>
</dd>
      </dl>

      </dd>

      <dt><strong>{partial_chain, fun(Chain::[DerCert]) -&gt; {trusted_ca, DerCert} | unknown_ca </strong></dt>
      <dd>
	Claim an intermediat CA in the chain as trusted. TLS will then perform the public_key:pkix_path_validation/3
	with the selected CA as trusted anchor and the rest of the chain.
      </dd>

      <dt><strong>{versions, [protocol()]}</strong></dt>
      <dd>TLS protocol versions that will be supported by started clients and servers.
      This option overrides the application environment option <span class="code">protocol_version</span>. If the
      environment option is not set it defaults to all versions supported by the SSL application. See also
      <span class="bold_code"><a href="ssl_app.html">ssl(6)</a></span>
      </dd>

      <dt><strong>{hibernate_after, integer()|undefined}</strong></dt>
      <dd>When an integer-value is specified, the <span class="code">ssl_connection</span>
            will go into hibernation after the specified number of milliseconds
            of inactivity, thus reducing its memory footprint. When
            <span class="code">undefined</span> is specified (this is the default), the process
            will never go into hibernation.
      </dd>

      <dt><strong>{user_lookup_fun, {Lookupfun :: fun(), UserState :: term()}}</strong></dt>
      <dd>
	<p>The lookup fun should be defined as:</p>
	<div class="example"><pre>
fun(psk, PSKIdentity ::string(), UserState :: term()) -&gt;
	{ok, SharedSecret :: binary()} | error;
fun(srp, Username :: string(), UserState :: term()) -&gt;
	{ok, {SRPParams :: srp_param_type(), Salt :: binary(), DerivedKey :: binary()}} | error.
	</pre></div>

	<p>For Pre-Shared Key (PSK) cipher suites, the lookup fun will
	be called by the client and server to determine the shared
	secret. When called by the client, PSKIdentity will be set to the
	hint presented by the server or undefined. When called by the
	server, PSKIdentity is the identity presented by the client.
	</p>

	<p>For Secure Remote Password (SRP), the fun will only be used by the server to obtain
	parameters that it will use to generate its session keys. <span class="code">DerivedKey</span> should be 
	derived according to <span class="bold_code"><a href="http://tools.ietf.org/html/rfc2945#section-3"> RFC 2945</a></span> and
	 <span class="bold_code"><a href="http://tools.ietf.org/html/rfc5054#section-2.4"> RFC 5054</a></span>:
	<span class="code">crypto:sha([Salt, crypto:sha([Username, &lt;&lt;$:&gt;&gt;, Password])]) </span>
	</p>
      </dd>

      <dt><strong>{padding_check, boolean()}</strong></dt>
      <dd>
	<p> This option only affects TLS-1.0 connections.
	If set to false it disables the block cipher padding check
	to be able to interoperate with legacy software.
	</p>
	
	<div class="warning">
<div class="label">Warning</div>
<div class="content"><p><p> Using this option makes TLS vulnerable to
	the Poodle attack</p></p></div>
</div>
	
      </dd>
      
    </dl>
    
  </div>
  
  <h3><a name="id62107">SSL OPTION DESCRIPTIONS - CLIENT SIDE</a></h3>
<div class="REFBODY">
    

    <p>Options described here are client specific or has a slightly different
    meaning in the client than in the server.</p>

    <dl>
      <dt><strong>{verify, verify_type()}</strong></dt>
      <dd> In verify_none mode the default behavior will be to
      allow all x509-path validation errors. See also the verify_fun
      option.
      </dd>
      <dt><strong>{reuse_sessions, boolean()}</strong></dt>
      <dd>Specifies if client should try to reuse sessions
      when possible.
      </dd>
      
      <dt><strong>{cacertfile, path()}</strong></dt>
      <dd>The path to a file containing PEM encoded CA certificates. The CA 
      certificates are used during server authentication and when building the
      client certificate chain.
     </dd>
  
      <dt><strong>{client_preferred_next_protocols, {Precedence :: server | client, ClientPrefs :: [binary()]}}</strong></dt>
      <dt><strong>{client_preferred_next_protocols, {Precedence :: server | client, ClientPrefs :: [binary()], Default :: binary()}}</strong></dt>
	   <dd>
	   <p>Indicates the client will try to perform Next Protocol
	   Negotiation.</p>

	   <p>If precedence is server the negotiated protocol will be the
	   first protocol that appears on the server advertised list that is
	   also on the client preference list.</p>

	   <p>If precedence is client the negotiated protocol will be the
	   first protocol that appears on the client preference list that is
	   also on the server advertised list.</p>

	   <p>If the client does not support any of the server advertised
	   protocols or the server does not advertise any protocols the
	   client will fallback to the first protocol in its list or if a
	   default is supplied it will fallback to that instead. If the
	   server does not support Next Protocol Negotiation the
	   connection will be aborted if no default protocol is supplied.</p>
	   </dd>

      <dt><strong>{psk_identity, string()}</strong></dt>
      <dd>Specifies the identity the client presents to the server. The matching secret is
      found by calling the user_look_fun.
      </dd>
      <dt><strong>{srp_identity, {Username :: string(), Password :: string()}</strong></dt>
      <dd>Specifies the Username and Password to use to authenticate to the server.
      </dd>
      <dt><strong>{server_name_indication, hostname()}</strong></dt>
      <dt><strong>{server_name_indication, disable}</strong></dt>
      <dd>
        <p>This option can be specified when upgrading a TCP socket to a TLS
        socket to use the TLS Server Name Indication extension.</p>
        <p>When starting a TLS connection without upgrade the Server Name
        Indication extension will be sent if possible, this option may also be
        used to disable that behavior.</p>
      </dd>
      <dt><strong>{fallback, boolean()}</strong></dt>
      <dd>
	<p> Send special cipher suite TLS_FALLBACK_SCSV to avoid undesired TLS version downgrade.
	Defaults to false</p>
	<div class="warning">
<div class="label">Warning</div>
<div class="content"><p><p>Note this option is not needed in normal TLS usage and should not be used
	to implement new clients. But legacy clients that that retries connections in the following manner</p>

	<p><span class="code"> ssl:connect(Host, Port, [...{versions, ['tlsv2', 'tlsv1.1', 'tlsv1', 'sslv3']}])</span></p>
	<p><span class="code">  ssl:connect(Host, Port, [...{versions, [tlsv1.1', 'tlsv1', 'sslv3']}, {fallback, true}])</span></p>
	<p><span class="code">  ssl:connect(Host, Port, [...{versions, ['tlsv1', 'sslv3']}, {fallback, true}]) </span></p>
	<p><span class="code">  ssl:connect(Host, Port, [...{versions, ['sslv3']}, {fallback, true}]) </span></p>
	 
	 <p>may use it to avoid undesired TLS version downgrade. Note that TLS_FALLBACK_SCSV must also
	 be supported by the server for the prevention to work.
	</p></p></div>
</div>
      </dd>
      
    </dl>
   </div>

  <h3><a name="id56625">SSL OPTION DESCRIPTIONS - SERVER SIDE</a></h3>
<div class="REFBODY">
    

    <p>Options described here are server specific or has a slightly different
    meaning in the server than in the client.</p>

    <dl>
      
      <dt><strong>{cacertfile, path()}</strong></dt>
      <dd>The path to a file containing PEM encoded CA
      certificates. The CA certificates are used to build the server
      certificate chain, and for client authentication.  Also the CAs
      are used in the list of acceptable client CAs passed to the
      client when a certificate is requested. May be omitted if there
      is no need to verify the client and if there are not any
      intermediate CAs for the server certificate.
      </dd>
  
      <dt><strong>{dh, der_encoded()}</strong></dt>
      <dd>The DER encoded Diffie Hellman parameters. If this option
      is supplied it will override the dhfile option.
      </dd>

      <dt><strong>{dhfile, path()}</strong></dt>
      <dd>Path to file containing PEM encoded Diffie Hellman parameters,
      for the server to use if a cipher suite using Diffie Hellman key exchange
      is negotiated. If not specified default parameters will be used.
      </dd>

      <dt><strong>{verify, verify_type()}</strong></dt>
      <dd>Servers only do the x509-path validation in verify_peer
      mode, as it then will send a certificate request to the client
      (this message is not sent if the verify option is verify_none)
      and you may then also want to specify the option
      fail_if_no_peer_cert.
      </dd>

      <dt><strong>{fail_if_no_peer_cert, boolean()}</strong></dt>
      <dd>Used together with {verify, verify_peer} by an ssl server.
      If set to true, the server will fail if the client does not have
      a certificate to send, i.e. sends a empty certificate, if set to
      false it will only fail if the client sends an invalid
      certificate (an empty certificate is considered valid).
      </dd>

      <dt><strong>{reuse_sessions, boolean()}</strong></dt>
      <dd>Specifies if the server should agree to reuse sessions
      when the clients request to do so. See also the reuse_session
      option.
      </dd>

      <dt><strong>{reuse_session, fun(SuggestedSessionId,
      PeerCert, Compression, CipherSuite) -&gt; boolean()}</strong></dt>
      <dd>Enables the ssl server to have a local policy
      for deciding if a session should be reused or not,
      only meaningful if <span class="code">reuse_sessions</span> is set to true.
      SuggestedSessionId is a binary(),  PeerCert is a DER encoded
      certificate, Compression is an enumeration integer
      and CipherSuite is of type ciphersuite().
    </dd>

      <dt><strong>{next_protocols_advertised, Protocols :: [binary()]}</strong></dt>
      <dd>The list of protocols to send to the client if the client indicates
      it supports the Next Protocol extension. The client may select a protocol
      that is not on this list. The list of protocols must not contain an empty
      binary. If the server negotiates a Next Protocol it can be accessed
      using <span class="code">negotiated_next_protocol/1</span> method.
      </dd>

      <dt><strong>{psk_identity, string()}</strong></dt>
      <dd>Specifies the server identity hint the server presents to the client.
      </dd>
      <dt><strong>{log_alert, boolean()}</strong></dt>
      <dd>If false, error reports will not be displayed.</dd>
      <dt><strong>{honor_cipher_order, boolean()}</strong></dt>
      <dd>If true, use the server's preference for cipher selection. If false
      (the default), use the client's preference.
      </dd>
    </dl>
  </div>
  
  <h3><a name="id56920">General</a></h3>
<div class="REFBODY">
    
      
    <p>When an ssl socket is in active mode (the default), data from the
      socket is delivered to the owner of the socket in the form of
      messages:
    </p>
    <ul>
      <li>{ssl, Socket, Data}
      </li>
      <li>{ssl_closed, Socket}
      </li>
      <li>
        {ssl_error, Socket, Reason}
      </li>
    </ul>
    
    <p>A <span class="code">Timeout</span> argument specifies a timeout in milliseconds. The 
      default value for a <span class="code">Timeout</span> argument is <span class="code">infinity</span>.
    </p>
  </div>
  
  <h3>EXPORTS</h3>
    <p><a name="cipher_suites-0"><span class="bold_code">cipher_suites() -&gt;</span></a><br><a name="cipher_suites-1"><span class="bold_code">cipher_suites(Type) -&gt; ciphers()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Type = erlang | openssl | all</span><br>
</div>

      </div>
<div class="REFBODY"><p><p>Returns a list of supported cipher suites.
	cipher_suites() is equivalent to cipher_suites(erlang).
	Type openssl is provided for backwards compatibility with
	old ssl that used openssl. cipher_suites(all) returns
	all available cipher suites. The cipher suites not present
	in cipher_suites(erlang) but in included in cipher_suites(all)
	will not be used unless explicitly configured by the user.
	</p>
    </p></div>

    <p><a name="clear_pem_cache-0"><span class="bold_code">clear_pem_cache() -&gt; ok </span></a><br></p>
<div class="REFBODY"><p><p>PEM files, used by ssl API-functions, are cached. The
      cache is regularly checked to see if any cache entries should be
      invalidated, however this function provides a way to
      unconditionally clear the whole cache.
      </p>
      </p></div>
   
    <p><a name="connect-2"><span class="bold_code">connect(Socket, SslOptions) -&gt; </span></a><br><a name="connect-3"><span class="bold_code">connect(Socket, SslOptions, Timeout) -&gt; {ok, SslSocket}
	| {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = socket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">SslOptions = [ssloption()]</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Timeout = integer() | infinity</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">SslSocket = sslsocket()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p> <p>Upgrades a gen_tcp, or equivalent,
	  connected socket to an ssl socket i.e. performs the
	  client-side ssl handshake.</p>
    </p></div>

    <p><a name="connect-3"><span class="bold_code">connect(Host, Port, Options) -&gt;</span></a><br><a name="connect-4"><span class="bold_code">connect(Host, Port, Options, Timeout) -&gt;
	  {ok, SslSocket} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	  <div class="REFTYPES">
<span class="bold_code">Host = host()</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">Port = integer()</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">Options = [option()]</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">Timeout = integer() | infinity</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">SslSocket = sslsocket()</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p> <p>Opens an ssl connection to Host, Port.</p> </p></div>

    <p><a name="close-1"><span class="bold_code">close(SslSocket) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	  <div class="REFTYPES">
<span class="bold_code">SslSocket = sslsocket()</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p><p>Close an ssl connection.</p>
      </p></div>

    <p><a name="controlling_process-2"><span class="bold_code">controlling_process(SslSocket, NewOwner) -&gt;
	ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	  <div class="REFTYPES">
<span class="bold_code">SslSocket = sslsocket()</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">NewOwner = pid()</span><br>
</div>
	  <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
	</div>
<div class="REFBODY"><p><p>Assigns a new controlling process to the ssl-socket. A
      controlling process is the owner of an ssl-socket, and receives
      all messages from the socket.</p>
      </p></div>

    <p><a name="connection_info-1"><span class="bold_code">connection_info(SslSocket) -&gt;
	  {ok, {ProtocolVersion, CipherSuite}} |  {error, Reason} </span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">CipherSuite = ciphersuite()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">ProtocolVersion = protocol()</span><br>
</div>
      </div>
<div class="REFBODY"><p><p>Returns the negotiated protocol version and cipher suite.</p> 
      </p></div>

     <p><a name="format_error-1"><span class="bold_code">format_error(Reason) -&gt; string()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Presents the error returned by an ssl function as a printable string.</p>
      </p></div>
   
    <p><a name="getopts-2"><span class="bold_code">getopts(Socket, OptionNames) -&gt;
	{ok, [socketoption()]} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">OptionNames = [atom()]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Get the value of the specified socket options.
	</p>
      </p></div>

    <p><a name="listen-2"><span class="bold_code">listen(Port, Options) -&gt;
	{ok, ListenSocket} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Port = integer()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Options = options()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">ListenSocket = sslsocket()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Creates an ssl listen socket.</p>
      </p></div>

    <p><a name="peercert-1"><span class="bold_code">peercert(Socket) -&gt; {ok, Cert} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Cert = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>The peer certificate is returned as a DER encoded binary.
	  The certificate can be decoded with <span class="code">public_key:pkix_decode_cert/2</span>.
        </p>
      </p></div>
    <p><a name="peername-1"><span class="bold_code">peername(Socket) -&gt; {ok, {Address, Port}} |
	{error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Address = ipaddress()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Port = integer()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Returns the address and port number of the peer.</p>
      </p></div>
    
    <p><a name="recv-2"><span class="bold_code">recv(Socket, Length) -&gt; </span></a><br><a name="recv-3"><span class="bold_code">recv(Socket, Length, Timeout) -&gt; {ok, Data} | {error,
	Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Length = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Timeout = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Data = [char()] | binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>This function receives a packet from a socket in passive
          mode. A closed socket is indicated by a return value
          <span class="code">{error, closed}</span>.</p>
        <p>The <span class="code">Length</span> argument is only meaningful when
          the socket is in <span class="code">raw</span> mode and denotes the number of
          bytes to read. If <span class="code">Length</span> = 0, all available bytes are
          returned. If <span class="code">Length</span> &gt; 0, exactly <span class="code">Length</span>
          bytes are returned, or an error; possibly discarding less
          than <span class="code">Length</span> bytes of data when the socket gets closed
          from the other side.</p>
        <p>The optional <span class="code">Timeout</span> parameter specifies a timeout in
          milliseconds. The default value is <span class="code">infinity</span>.</p>
      </p></div>
    
    <p><a name="prf-5"><span class="bold_code">prf(Socket, Secret, Label, Seed, WantedLength) -&gt; {ok, binary()} | {error, reason()}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Secret = binary() | master_secret</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Label = binary()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Seed = [binary() | prf_random()]</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">WantedLength = non_neg_integer()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Use the pseudo random function (PRF) of a TLS session to generate
	  additional key material. It either takes user generated values for
	  <span class="code">Secret</span> and <span class="code">Seed</span> or atoms directing it use a specific
	  value from the session security parameters.</p>
        <p>This function can only be used with TLS connections, <span class="code">{error, undefined}</span>
	  is returned for SSLv3 connections.</p>
      </p></div>

    <p><a name="renegotiate-1"><span class="bold_code">renegotiate(Socket) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
      </div>
<div class="REFBODY"><p><p>Initiates a new handshake. A notable return value is
      <span class="code">{error, renegotiation_rejected}</span> indicating that the peer
      refused to go through with the renegotiation but the connection
      is still active using the previously negotiated session.</p>
      </p></div>
    
    <p><a name="send-2"><span class="bold_code">send(Socket, Data) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Data = iodata()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Writes <span class="code">Data</span> to <span class="code">Socket</span>. </p>
        <p>A notable return value is <span class="code">{error, closed}</span> indicating that
          the socket is closed.</p>
      </p></div>

    <p><a name="setopts-2"><span class="bold_code">setopts(Socket, Options) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Options = [socketoption]()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Sets options according to <span class="code">Options</span> for the socket 
          <span class="code">Socket</span>. </p>
      </p></div>

    <p><a name="shutdown-2"><span class="bold_code">shutdown(Socket, How) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">How = read | write | read_write</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = reason()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Immediately close a socket in one or two directions.</p>
        <p><span class="code">How == write</span> means closing the socket for writing,
          reading from it is still possible.</p>
        <p>To be able to handle that the peer has done a shutdown on
          the write side, the <span class="code">{exit_on_close, false}</span> option
          is useful.</p>
      </p></div>
    
    <p><a name="ssl_accept-1"><span class="bold_code">ssl_accept(Socket) -&gt; </span></a><br><a name="ssl_accept-2"><span class="bold_code">ssl_accept(Socket, Timeout) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Timeout = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p> Performs the SSL/TLS server-side handshake <span class="code">Socket</span> is a socket as returned
	by  <span class="bold_code"><a href="#transport_accept-2">ssl:transport_accept/[1,2]</a></span>
	</p>
      </p></div>

    <p><a name="ssl_accept-2"><span class="bold_code">ssl_accept(Socket, SslOptions) -&gt; </span></a><br><a name="ssl_accept-3"><span class="bold_code">ssl_accept(Socket, SslOptions, Timeout) -&gt; {ok, Socket} | ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = socket() | sslsocket() </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">SslOptions = ssloptions()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Timeout = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p> If <span class="code">Socket</span> is a socket() - upgrades a gen_tcp, or equivalent, socket to an ssl socket
        i.e. performs the SSL/TLS server-side handshake and returns the ssl socket.
	</p>
	
	<div class="warning">
<div class="label">Warning</div>
<div class="content"><p><p>Note that the listen socket should be in {active, false} mode
	before telling the client that the server is ready to upgrade
	by calling this function, otherwise the upgrade may
	or may not succeed depending on timing.</p></p></div>
</div>
	
	<p> If <span class="code">Socket</span> is an sslsocket() - provides additional SSL/TLS options to those specified in <span class="bold_code"><a href="#listen-2">ssl:listen/2 </a></span> and then performs the SSL/TLS handshake.
	</p>
      </p></div>
    
    <p><a name="sockname-1"><span class="bold_code">sockname(Socket) -&gt; {ok, {Address, Port}} |
	{error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Address = ipaddress()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Port = integer()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Returns the local address and port number of the socket
          <span class="code">Socket</span>.</p>
      </p></div>
    
    <p><a name="start-0"><span class="bold_code">start() -&gt; </span></a><br><a name="start-1"><span class="bold_code">start(Type) -&gt; ok | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Type =  permanent | transient | temporary</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Starts the Ssl application. Default type
          is temporary.
          <span class="bold_code"><a href="application.html">application(3)</a></span></p>
      </p></div>
    <p><a name="stop-0"><span class="bold_code">stop() -&gt; ok </span></a><br></p>
<div class="REFBODY"><p>
        <p>Stops the Ssl application.
          <span class="bold_code"><a href="application.html">application(3)</a></span></p>
      </p></div>

    <p><a name="transport_accept-1"><span class="bold_code">transport_accept(ListenSocket) -&gt;</span></a><br><a name="transport_accept-2"><span class="bold_code">transport_accept(ListenSocket, Timeout) -&gt;
	{ok, NewSocket} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">ListenSocket = NewSocket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Timeout = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Reason = reason()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Accepts an incoming connection request on a listen socket.
	<span class="code">ListenSocket</span> must be a socket returned from
	<span class="bold_code"><a href="#listen-2"> ssl:listen/2</a></span>.
	The socket returned should be passed to
	<span class="bold_code"><a href="#ssl_accept-2"> ssl:ssl_accept[2,3]</a></span>
	to complete handshaking i.e
	establishing the SSL/TLS connection.</p>
        <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
          <p>The socket returned can only be used with
	  <span class="bold_code"><a href="#ssl_accept-2"> ssl:ssl_accept[2,3]</a></span>
	  no traffic can be sent or received before that call.</p>
        </p></div>
</div>
        <p>The accepted socket inherits the options set for
	<span class="code">ListenSocket</span> in <span class="bold_code"><a href="#listen-2"> ssl:listen/2</a></span>.</p>
	<p>The default
	value for <span class="code">Timeout</span> is <span class="code">infinity</span>. If
	<span class="code">Timeout</span> is specified, and no connection is accepted
	within the given time, <span class="code">{error, timeout}</span> is
	returned.</p>
      </p></div>
    
    <p><a name="versions-0"><span class="bold_code">versions() -&gt;
	[{SslAppVer, SupportedSslVer, AvailableSslVsn}]</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">SslAppVer = string()</span><br>
</div>
      	<div class="REFTYPES">
<span class="bold_code">SupportedSslVer = [protocol()]</span><br>
</div>
      	<div class="REFTYPES">
<span class="bold_code">AvailableSslVsn = [protocol()]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>
	  Returns version information relevant for the
	  ssl application.</p>
      </p></div>
    <p><a name="negotiated_next_protocol-1"><span class="bold_code">negotiated_next_protocol(Socket) -&gt; {ok, Protocol} | {error, next_protocol_not_negotiated}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Socket = sslsocket()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Protocol = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>
          Returns the Next Protocol negotiated.
        </p>
      </p></div>

   

  <h3><a name="id62749">SEE ALSO</a></h3>
<div class="REFBODY">
    
    <p><span class="bold_code"><a href="inet.html">inet(3) </a></span> and 
      <span class="bold_code"><a href="gen_tcp.html">gen_tcp(3) </a></span>
    </p>
  </div>

</div>
<div class="footer">
<hr>
<p>Copyright © 1999-2015 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
