<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- crypto</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/crypto/users_guide.html">User's Guide</a><br><a href="../apps/crypto/index.html">Reference Manual</a><br><a href="../apps/crypto/release_notes.html">Release Notes</a><br><a href="../apps/crypto/crypto.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>crypto</strong><br><strong>Reference Manual</strong><br><small>Version 3.5</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li title="crypto (App)"><a href="crypto_app.html">crypto (App)
                </a></li>
<li id="loadscrollpos" title="crypto " expanded="true">crypto<ul>
<li><a href="crypto.html">
                  Top of manual page
                </a></li>
<li title="block_encrypt-4"><a href="crypto.html#block_encrypt-4">block_encrypt/4</a></li>
<li title="block_decrypt-4"><a href="crypto.html#block_decrypt-4">block_decrypt/4</a></li>
<li title="bytes_to_integer-1"><a href="crypto.html#bytes_to_integer-1">bytes_to_integer/1</a></li>
<li title="compute_key-4"><a href="crypto.html#compute_key-4">compute_key/4</a></li>
<li title="exor-2"><a href="crypto.html#exor-2">exor/2</a></li>
<li title="generate_key-2"><a href="crypto.html#generate_key-2">generate_key/2</a></li>
<li title="generate_key-3"><a href="crypto.html#generate_key-3">generate_key/3</a></li>
<li title="hash-2"><a href="crypto.html#hash-2">hash/2</a></li>
<li title="hash_init-1"><a href="crypto.html#hash_init-1">hash_init/1</a></li>
<li title="hash_update-2"><a href="crypto.html#hash_update-2">hash_update/2</a></li>
<li title="hash_final-1"><a href="crypto.html#hash_final-1">hash_final/1</a></li>
<li title="hmac-3"><a href="crypto.html#hmac-3">hmac/3</a></li>
<li title="hmac-4"><a href="crypto.html#hmac-4">hmac/4</a></li>
<li title="hmac_init-2"><a href="crypto.html#hmac_init-2">hmac_init/2</a></li>
<li title="hmac_update-2"><a href="crypto.html#hmac_update-2">hmac_update/2</a></li>
<li title="hmac_final-1"><a href="crypto.html#hmac_final-1">hmac_final/1</a></li>
<li title="hmac_final_n-2"><a href="crypto.html#hmac_final_n-2">hmac_final_n/2</a></li>
<li title="info_lib-0"><a href="crypto.html#info_lib-0">info_lib/0</a></li>
<li title="mod_pow-3"><a href="crypto.html#mod_pow-3">mod_pow/3</a></li>
<li title="next_iv-2"><a href="crypto.html#next_iv-2">next_iv/2</a></li>
<li title="next_iv-3"><a href="crypto.html#next_iv-3">next_iv/3</a></li>
<li title="private_decrypt-4"><a href="crypto.html#private_decrypt-4">private_decrypt/4</a></li>
<li title="private_encrypt-4"><a href="crypto.html#private_encrypt-4">private_encrypt/4</a></li>
<li title="public_decrypt-4"><a href="crypto.html#public_decrypt-4">public_decrypt/4</a></li>
<li title="public_encrypt-4"><a href="crypto.html#public_encrypt-4">public_encrypt/4</a></li>
<li title="rand_bytes-1"><a href="crypto.html#rand_bytes-1">rand_bytes/1</a></li>
<li title="rand_seed-1"><a href="crypto.html#rand_seed-1">rand_seed/1</a></li>
<li title="rand_uniform-2"><a href="crypto.html#rand_uniform-2">rand_uniform/2</a></li>
<li title="sign-4"><a href="crypto.html#sign-4">sign/4</a></li>
<li title="start-0"><a href="crypto.html#start-0">start/0</a></li>
<li title="stop-0"><a href="crypto.html#stop-0">stop/0</a></li>
<li title="strong_rand_bytes-1"><a href="crypto.html#strong_rand_bytes-1">strong_rand_bytes/1</a></li>
<li title="stream_init-2"><a href="crypto.html#stream_init-2">stream_init/2</a></li>
<li title="stream_init-3"><a href="crypto.html#stream_init-3">stream_init/3</a></li>
<li title="stream_encrypt-2"><a href="crypto.html#stream_encrypt-2">stream_encrypt/2</a></li>
<li title="stream_decrypt-2"><a href="crypto.html#stream_decrypt-2">stream_decrypt/2</a></li>
<li title="supports-0"><a href="crypto.html#supports-0">supports/0</a></li>
<li title="ec_curves-0"><a href="crypto.html#ec_curves-0">ec_curves/0</a></li>
<li title="ec_curve-1"><a href="crypto.html#ec_curve-1">ec_curve/1</a></li>
<li title="verify-5"><a href="crypto.html#verify-5">verify/5</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>crypto</h1></center>
  
  <h3>MODULE</h3>
<div class="REFBODY">crypto</div>
  <h3>MODULE SUMMARY</h3>
<div class="REFBODY">Crypto Functions</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>This module provides a set of cryptographic functions.
      </p>
    <ul>
      <li>
	<p>Hash functions -
	<span class="bold_code"><a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf"> Secure Hash Standard</a></span>,
	<span class="bold_code"><a href="http://www.ietf.org/rfc/rfc1321.txt"> The MD5 Message Digest Algorithm (RFC 1321)</a></span> and
	<span class="bold_code"><a href="http://www.ietf.org/rfc/rfc1320.txt">The MD4 Message Digest Algorithm (RFC 1320)</a></span>
	</p>
      </li>
      <li>
        <p>Hmac functions - <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc2104.txt"> Keyed-Hashing for Message Authentication (RFC 2104) </a></span></p>
      </li>
      <li>
        <p>Block ciphers - <span class="bold_code"><a href="http://csrc.nist.gov/groups/ST/toolkit/block_ciphers.html"> </a></span> DES and AES in
        Block Cipher Modes - <span class="bold_code"><a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html"> ECB, CBC, CFB, OFB and CTR </a></span></p>
      </li>
      <li>
        <p><span class="bold_code"><a href="http://www.ietf.org/rfc/rfc1321.txt"> RSA encryption RFC 1321 </a></span> </p>
      </li>
      <li>
        <p>Digital signatures <span class="bold_code"><a href="http://csrc.nist.gov/publications/drafts/fips186-3/fips_186-3.pdf">Digital Signature Standard (DSS)</a></span> and<span class="bold_code"><a href="http://csrc.nist.gov/groups/STM/cavp/documents/dss2/ecdsa2vs.pdf"> Elliptic Curve Digital
	Signature Algorithm (ECDSA) </a></span> </p>
      </li>
      <li>
        <p><span class="bold_code"><a href="http://www.ietf.org/rfc/rfc2945.txt"> Secure Remote Password Protocol (SRP - RFC 2945) </a></span></p>
      </li>
    </ul>
  </p></div>

 <h3><a name="id59386">DATA TYPES </a></h3>
<div class="REFBODY">
    
    
    <p><div class="example"><pre>key_value()  = integer() | binary() </pre></div></p>
    <p>Always <span class="code">binary()</span> when used as return value</p>

    <p><div class="example"><pre>rsa_public()  = [key_value()] = [E, N]  </pre></div></p>
    <p> Where E is the public exponent and N is public modulus. </p>

    <p><div class="example"><pre>rsa_private() = [key_value()] = [E, N, D] | [E, N, D, P1, P2, E1, E2, C] </pre></div></p>
    <p>Where E is the public exponent, N is public modulus and D is
    the private exponent.The longer key format contains redundant
    information that will make the calculation faster. P1,P2 are first
    and second prime factors. E1,E2 are first and second exponents. C
    is the CRT coefficient. Terminology is taken from <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc3477.txt"> RFC 3447</a></span>.</p>

    <p><div class="example"><pre>dss_public() = [key_value()] = [P, Q, G, Y] </pre></div></p>
    <p>Where P, Q and G are the dss parameters and Y is the public key.</p>

    <p><div class="example"><pre>dss_private() =  [key_value()] = [P, Q, G, X] </pre></div></p>
    <p>Where P, Q and G are the dss parameters and X is the private key.</p>

    <p><div class="example"><pre>srp_public() = key_value() </pre></div></p>
    <p>Where is <span class="code">A</span> or <span class="code">B</span> from <span class="bold_code"><a href="http://srp.stanford.edu/design.html">SRP design</a></span></p>

    <p><div class="example"><pre>srp_private() = key_value() </pre></div></p>
    <p>Where is  <span class="code">a</span> or <span class="code">b</span> from <span class="bold_code"><a href="http://srp.stanford.edu/design.html">SRP design</a></span></p>

    <p>Where Verifier is <span class="code">v</span>, Generator is <span class="code">g</span> and Prime is<span class="code"> N</span>, DerivedKey is <span class="code">X</span>, and Scrambler is
    <span class="code">u</span> (optional will be generated if not provided) from <span class="bold_code"><a href="http://srp.stanford.edu/design.html">SRP design</a></span>
    Version = '3' |  '6' |  '6a'
    </p>

    <p><div class="example"><pre>dh_public() = key_value() </pre></div></p>

    <p><div class="example"><pre>dh_private() = key_value() </pre></div></p>

    <p><div class="example"><pre>dh_params() = [key_value()] = [P, G] </pre></div></p>

    <p><div class="example"><pre>ecdh_public() = key_value() </pre></div></p>

    <p><div class="example"><pre>ecdh_private() = key_value() </pre></div></p>

    <p><div class="example"><pre>ecdh_params() =  ec_named_curve() | ec_explicit_curve()</pre></div></p>

    <p><div class="example"><pre>ec_explicit_curve() =
    {ec_field(), Prime :: key_value(), Point :: key_value(), Order :: integer(), CoFactor :: none | integer()} </pre></div></p>

    <p><div class="example"><pre>ec_field() = {prime_field, Prime :: integer()} |
    {characteristic_two_field, M :: integer(), Basis :: ec_basis()}</pre></div></p>

    <p><div class="example"><pre>ec_basis() =  {tpbasis, K :: non_neg_integer()} |
    {ppbasis, K1 :: non_neg_integer(), K2 :: non_neg_integer(), K3 :: non_neg_integer()} |
    onbasis</pre></div></p>

    <p><div class="example"><pre>ec_named_curve() -&gt;
      sect571r1| sect571k1| sect409r1| sect409k1| secp521r1| secp384r1| secp224r1| secp224k1|
      secp192k1| secp160r2| secp128r2| secp128r1| sect233r1| sect233k1| sect193r2| sect193r1|
      sect131r2| sect131r1| sect283r1| sect283k1| sect163r2| secp256k1| secp160k1| secp160r1|
      secp112r2| secp112r1| sect113r2| sect113r1| sect239k1| sect163r1| sect163k1| secp256r1|
      secp192r1|
      brainpoolP160r1| brainpoolP160t1| brainpoolP192r1| brainpoolP192t1| brainpoolP224r1|
      brainpoolP224t1| brainpoolP256r1| brainpoolP256t1| brainpoolP320r1| brainpoolP320t1|
      brainpoolP384r1| brainpoolP384t1| brainpoolP512r1| brainpoolP512t1
    </pre></div>
    Note that the <strong>sect</strong> curves are GF2m (characteristic two) curves and are only supported if the
    underlying OpenSSL has support for them.
    See also <span class="bold_code"><a href="#supports-0">crypto:supports/0</a></span>
    </p>

     <p><div class="example"><pre>stream_cipher() = rc4 | aes_ctr </pre></div></p>

     <p><div class="example"><pre>block_cipher() =  aes_cbc128 | aes_cfb8 | aes_cfb128 | aes_ige256 | blowfish_cbc |
     blowfish_cfb64 | des_cbc | des_cfb | des3_cbc | des3_cbf
     | des_ede3 | rc2_cbc </pre></div></p>

     <p><div class="example"><pre>stream_key() =  aes_key() | rc4_key() </pre></div></p>

     <p><div class="example"><pre>block_key() =  aes_key() |  blowfish_key() | des_key()| des3_key() </pre></div></p>

     <p><div class="example"><pre>aes_key() = iodata() </pre></div> Key length is 128, 192 or 256 bits</p>

     <p><div class="example"><pre>rc4_key() = iodata() </pre></div> Variable key length from 8 bits up to 2048 bits (usually between 40 and 256)</p>

     <p><div class="example"><pre>blowfish_key() = iodata() </pre></div> Variable key length from 32 bits up to 448 bits</p>

     <p><div class="example"><pre>des_key() = iodata() </pre></div> Key length is 64 bits (in CBC mode only 8 bits are used)</p>

     <p><div class="example"><pre>des3_key() = [binary(), binary(), binary()] </pre></div> Each key part is 64 bits (in CBC mode only 8 bits are used)</p>

     <p><div class="example"><pre>digest_type() =  md5 | sha | sha224 | sha256 | sha384 | sha512</pre></div></p>

     <p><div class="example"><pre> hash_algorithms() =  md5 | ripemd160 | sha | sha224 | sha256 | sha384 | sha512 </pre></div> md4 is also supported for hash_init/1 and hash/2.
     Note that both md4 and md5 are recommended only for compatibility with existing applications.
     </p>
     <p><div class="example"><pre> cipher_algorithms() = des_cbc | des_cfb |  des3_cbc | des3_cbf | des_ede3 |
     blowfish_cbc | blowfish_cfb64 | aes_cbc128 | aes_cfb8 | aes_cfb128| aes_cbc256 | aes_ige256 | rc2_cbc | aes_ctr| rc4  </pre></div> </p>
     <p><div class="example"><pre> public_key_algorithms() =   rsa |dss | ecdsa | dh | ecdh | ec_gf2m</pre></div>
     Note that ec_gf2m is not strictly a public key algorithm, but a restriction on what curves are supported
     with ecdsa and ecdh.
     </p>

 </div>

  <h3>EXPORTS</h3>
      <p><a name="block_encrypt-4"><span class="bold_code">block_encrypt(Type, Key, Ivec, PlainText) -&gt; CipherText</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Type = block_cipher() </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Key = block_key() </span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">PlainText = iodata() </span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">IVec = CipherText = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Encrypt <span class="code">PlainText</span>according to <span class="code">Type</span> block cipher.
	<span class="code">IVec</span> is an arbitrary initializing vector.</p>
	<p>May throw exception <span class="code">notsup</span> in case the chosen <span class="code">Type</span>
	is not supported by the underlying OpenSSL implementation.</p>
      </p></div>

    <p><a name="block_decrypt-4"><span class="bold_code">block_decrypt(Type, Key, Ivec, CipherText) -&gt; PlainText</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Type = block_cipher() </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Key = block_key() </span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">PlainText = iodata() </span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">IVec = CipherText = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Decrypt <span class="code">CipherText</span>according to <span class="code">Type</span> block cipher.
	<span class="code">IVec</span> is an arbitrary initializing vector.</p>
	<p>May throw exception <span class="code">notsup</span> in case the chosen <span class="code">Type</span>
	is not supported by the underlying OpenSSL implementation.</p>
      </p></div>
    
     <p><a name="bytes_to_integer-1"><span class="bold_code">bytes_to_integer(Bin) -&gt; Integer </span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Bin = binary() - as returned by crypto functions</span><br>
</div>
	
        <div class="REFTYPES">
<span class="bold_code">Integer = integer() </span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Convert binary representation, of an integer, to an Erlang integer.
         </p>
      </p></div>

    <p><a name="compute_key-4"><span class="bold_code">compute_key(Type, OthersPublicKey, MyKey, Params) -&gt; SharedSecret</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code"> Type = dh | ecdh | srp </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">OthersPublicKey =  dh_public() | ecdh_public() | srp_public() </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">MyKey = dh_private() | ecdh_private() | {srp_public(),srp_private()}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Params = dh_params() | ecdh_params() | SrpUserParams | SrpHostParams</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">SrpUserParams = {user, [DerivedKey::binary(), Prime::binary(), Generator::binary(), Version::atom() | [Scrambler:binary()]]} </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">SrpHostParams = {host, [Verifier::binary(), Prime::binary(), Version::atom() | [Scrambler::binary]]} </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">SharedSecret = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Computes the shared secret from the private key and the other party's public key.
	 See also <span class="bold_code"><a href="public_key.html#compute_key-2">public_key:compute_key/2</a></span>
	</p>
      </p></div>

    <p><a name="exor-2"><span class="bold_code">exor(Data1, Data2) -&gt; Result</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Data1, Data2 = iodata()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Result = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Performs bit-wise XOR (exclusive or) on the data supplied.</p>
      </p></div>

   <p><a name="generate_key-2"><span class="bold_code">generate_key(Type, Params) -&gt; {PublicKey, PrivKeyOut} </span></a><br><a name="generate_key-3"><span class="bold_code">generate_key(Type, Params, PrivKeyIn) -&gt; {PublicKey, PrivKeyOut} </span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code"> Type = dh | ecdh | srp </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Params = dh_params() | ecdh_params() | SrpUserParams | SrpHostParams </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">SrpUserParams = {user, [Generator::binary(), Prime::binary(), Version::atom()]}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">SrpHostParams = {host, [Verifier::binary(), Generator::binary(), Prime::binary(), Version::atom()]}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">PublicKey =  dh_public() | ecdh_public() | srp_public() </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">PrivKeyIn = undefined | dh_private() | srp_private() </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">PrivKeyOut =  dh_private() | ecdh_private() | srp_private() </span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Generates public keys of type <span class="code">Type</span>.
	See also <span class="bold_code"><a href="public_key.html#generate_key-1">public_key:generate_key/1</a></span>
	</p>
      </p></div>

     <p><a name="hash-2"><span class="bold_code">hash(Type, Data) -&gt; Digest</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Type = md4 | hash_algorithms()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Data = iodata()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Digest = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Computes a message digest of type <span class="code">Type</span> from <span class="code">Data</span>.</p>
	<p>May throw exception <span class="code">notsup</span> in case the chosen <span class="code">Type</span>
	is not supported by the underlying OpenSSL implementation.</p>
      </p></div>

    <p><a name="hash_init-1"><span class="bold_code">hash_init(Type) -&gt; Context</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Type = md4 | hash_algorithms()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Initializes the context for streaming hash operations. <span class="code">Type</span> determines
        which digest to use. The returned context should be used as argument
	to <span class="bold_code"><a href="#hash_update-2">hash_update</a></span>.</p>
	<p>May throw exception <span class="code">notsup</span> in case the chosen <span class="code">Type</span>
	is not supported by the underlying OpenSSL implementation.</p>
      </p></div>

    <p><a name="hash_update-2"><span class="bold_code">hash_update(Context, Data) -&gt; NewContext</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Data = iodata()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Updates the digest represented by <span class="code">Context</span> using the given <span class="code">Data</span>. <span class="code">Context</span>
        must have been generated using <span class="bold_code"><a href="#hash_init-1">hash_init</a></span>
	or a previous call to this function. <span class="code">Data</span> can be any length. <span class="code">NewContext</span>
        must be passed into the next call to <span class="code">hash_update</span>
	or <span class="bold_code"><a href="#hash_final-1">hash_final</a></span>.</p>
      </p></div>
    <p><a name="hash_final-1"><span class="bold_code">hash_final(Context) -&gt; Digest</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Digest = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Finalizes the hash operation referenced by <span class="code">Context</span> returned
	from a previous call to <span class="bold_code"><a href="#hash_update-2">hash_update</a></span>.
	The size of <span class="code">Digest</span> is determined by the type of hash
	function used to generate it.</p>
      </p></div>

    <p><a name="hmac-3"><span class="bold_code">hmac(Type, Key, Data) -&gt; Mac</span></a><br><a name="hmac-4"><span class="bold_code">hmac(Type, Key, Data, MacLength) -&gt; Mac</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Type = hash_algorithms() - except ripemd160</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Key = iodata()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Data = iodata()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">MacLength = integer()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Mac = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Computes a HMAC of type <span class="code">Type</span> from <span class="code">Data</span> using
        <span class="code">Key</span> as the authentication key.</p> <span class="code">MacLength</span>
        will limit the size of the resultant <span class="code">Mac</span>.
      </p></div>

    <p><a name="hmac_init-2"><span class="bold_code">hmac_init(Type, Key) -&gt; Context</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Type = hash_algorithms() - except ripemd160</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Key = iodata()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Context = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Initializes the context for streaming HMAC operations. <span class="code">Type</span> determines
        which hash function to use in the HMAC operation. <span class="code">Key</span> is the authentication
        key. The key can be any length.</p>
      </p></div>

    <p><a name="hmac_update-2"><span class="bold_code">hmac_update(Context, Data) -&gt; NewContext</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Context = NewContext = binary()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Data = iodata()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Updates the HMAC represented by <span class="code">Context</span> using the given <span class="code">Data</span>. <span class="code">Context</span>
        must have been generated using an HMAC init function (such as 
        <span class="bold_code"><a href="#hmac_init-2">hmac_init</a></span>). <span class="code">Data</span> can be any length. <span class="code">NewContext</span>
        must be passed into the next call to <span class="code">hmac_update</span>
	or to one of the functions <span class="bold_code"><a href="#hmac_final-1">hmac_final</a></span> and
	<span class="bold_code"><a href="#hmac_final_n-2">hmac_final_n</a></span>
	</p>
	<div class="warning">
<div class="label">Warning</div>
<div class="content"><p><p>Do not use a <span class="code">Context</span> as argument in more than one
	call to	hmac_update or hmac_final. The semantics of reusing old contexts
	in any way is undefined and could even crash the VM in earlier releases.
	The reason for this limitation is a lack of support in the underlying
	OpenSSL	API.</p></p></div>
</div>
      </p></div>

    <p><a name="hmac_final-1"><span class="bold_code">hmac_final(Context) -&gt; Mac</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Context = Mac = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Finalizes the HMAC operation referenced by <span class="code">Context</span>. The size of the resultant MAC is
        determined by the type of hash function used to generate it.</p>
      </p></div>

    <p><a name="hmac_final_n-2"><span class="bold_code">hmac_final_n(Context, HashLen) -&gt; Mac</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Context = Mac = binary()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">HashLen = non_neg_integer()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Finalizes the HMAC operation referenced by <span class="code">Context</span>. <span class="code">HashLen</span> must be greater than
        zero. <span class="code">Mac</span> will be a binary with at most <span class="code">HashLen</span> bytes. Note that if HashLen is greater than the actual number of bytes returned from the underlying hash, the returned hash will have fewer than <span class="code">HashLen</span> bytes.</p>
      </p></div>

    <p><a name="info_lib-0"><span class="bold_code">info_lib() -&gt; [{Name,VerNum,VerStr}]</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Name = binary()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">VerNum = integer()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">VerStr = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Provides the name and version of the libraries used by crypto.</p>
        <p><span class="code">Name</span> is the name of the library. <span class="code">VerNum</span> is
        the numeric version according to the library's own versioning
        scheme. <span class="code">VerStr</span> contains a text variant of the version.</p>
        <div class="example"><pre>
&gt; <span class="bold_code">info_lib().</span>
[{&lt;&lt;"OpenSSL"&gt;&gt;,9469983,&lt;&lt;"OpenSSL 0.9.8a 11 Oct 2005"&gt;&gt;}]
        </pre></div>
	<div class="note">
<div class="label">Note</div>
<div class="content"><p><p>
	  From OTP R16 the <strong>numeric version</strong> represents the version of the OpenSSL
	  <strong>header files</strong> (<span class="code">openssl/opensslv.h</span>) used when crypto was compiled.
	  The text variant represents the OpenSSL library used at runtime.
	  In earlier OTP versions both numeric and text was taken from the library.
	</p></p></div>
</div>
      </p></div>

    <p><a name="mod_pow-3"><span class="bold_code">mod_pow(N, P, M) -&gt; Result</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">N, P, M = binary() | integer()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Result = binary() | error</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Computes the function <span class="code">N^P mod M</span>.</p>
      </p></div>

    <p><a name="next_iv-2"><span class="bold_code">next_iv(Type, Data) -&gt; NextIVec</span></a><br><a name="next_iv-3"><span class="bold_code">next_iv(Type, Data, IVec) -&gt; NextIVec</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
     <div class="REFTYPES">
<span class="bold_code">Type = des_cbc | des3_cbc | aes_cbc | des_cfb</span><br>
</div>
     <div class="REFTYPES">
<span class="bold_code">Data = iodata()</span><br>
</div>
     <div class="REFTYPES">
<span class="bold_code">IVec = NextIVec = binary()</span><br>
</div>
   </div>
<div class="REFBODY"><p>
     <p>Returns the initialization vector to be used in the next
     iteration of encrypt/decrypt of type <span class="code">Type</span>. <span class="code">Data</span> is the
     encrypted data from the previous iteration step. The <span class="code">IVec</span>
     argument is only needed for <span class="code">des_cfb</span> as the vector used
     in the previous iteration step.</p>
   </p></div>

    <p><a name="private_decrypt-4"><span class="bold_code">private_decrypt(Type, CipherText, PrivateKey, Padding) -&gt; PlainText</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Type = rsa</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">CipherText = binary()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">PrivateKey = rsa_private()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">PlainText = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Decrypts the <span class="code">CipherText</span>, encrypted with
	<span class="bold_code"><a href="#public_encrypt-4">public_encrypt/4</a></span> (or equivalent function)
	  using the <span class="code">PrivateKey</span>, and returns the
	  plaintext (message digest). This is a low level signature  verification operation
	used for instance by older versions of the SSL protocol.
	  See also <span class="bold_code"><a href="public_key.html#decrypt_private-2">public_key:decrypt_private/[2,3]</a></span>
	</p>
      </p></div>
    
    <p><a name="private_encrypt-4"><span class="bold_code">private_encrypt(Type, PlainText, PrivateKey, Padding) -&gt; CipherText</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Type = rsa</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">PlainText = binary()</span><br>
</div>
	<div class="REFBODY"> The size of the <span class="code">PlainText</span> must be less
	than <span class="code">byte_size(N)-11</span> if <span class="code">rsa_pkcs1_padding</span> is
	used, and <span class="code">byte_size(N)</span> if <span class="code">rsa_no_padding</span> is
	used, where N is public modulus of the RSA key.</div>
	<div class="REFTYPES">
<span class="bold_code">PrivateKey = rsa_private()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Padding = rsa_pkcs1_padding | rsa_no_padding</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">CipherText = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Encrypts the <span class="code">PlainText</span> using the <span class="code">PrivateKey</span>
	and returns the ciphertext. This is a low level signature operation
	used for instance by older versions of the SSL protocol. See
	also <span class="bold_code"><a href="public_key.html#encrypt_private-2">public_key:encrypt_private/[2,3]</a></span>
	</p>
      </p></div>
    <p><a name="public_decrypt-4"><span class="bold_code">public_decrypt(Type, CipherText, PublicKey, Padding) -&gt; PlainText</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Type = rsa</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">CipherText = binary()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">PublicKey =  rsa_public() </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Padding = rsa_pkcs1_padding | rsa_no_padding</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">PlainText = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Decrypts the <span class="code">CipherText</span>, encrypted with
	<span class="bold_code"><a href="#private_encrypt-4">private_encrypt/4</a></span>(or equivalent function)
	  using the <span class="code">PrivateKey</span>, and returns the
	  plaintext (message digest). This is a low level signature verification operation
	  used for instance by older versions of the SSL protocol.
	  See also <span class="bold_code"><a href="public_key.html#decrypt_public-2">public_key:decrypt_public/[2,3]</a></span>
	</p>
      </p></div>

    <p><a name="public_encrypt-4"><span class="bold_code">public_encrypt(Type, PlainText, PublicKey, Padding) -&gt; CipherText</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Type = rsa</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">PlainText = binary()</span><br>
</div>
	<div class="REFBODY"> The size of the <span class="code">PlainText</span> must be less
	than <span class="code">byte_size(N)-11</span> if <span class="code">rsa_pkcs1_padding</span> is
	used, and <span class="code">byte_size(N)</span> if <span class="code">rsa_no_padding</span> is
	used, where N is public modulus of the RSA key.</div>
	<div class="REFTYPES">
<span class="bold_code">PublicKey = rsa_public()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">CipherText = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Encrypts the <span class="code">PlainText</span> (message digest) using the <span class="code">PublicKey</span>
	and returns the <span class="code">CipherText</span>. This is a low level signature operation
	used for instance by older versions of the SSL protocol. See also <span class="bold_code"><a href="public_key.html#encrypt_public-2">public_key:encrypt_public/[2,3]</a></span>
	</p>
      </p></div>

    <p><a name="rand_bytes-1"><span class="bold_code">rand_bytes(N) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">N = integer()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Generates N bytes randomly uniform 0..255, and returns the
          result in a binary. Uses the <span class="code">crypto</span> library pseudo-random
          number generator.</p>
      </p></div>

    <p><a name="rand_seed-1"><span class="bold_code">rand_seed(Seed) -&gt; ok</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Seed = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Set the seed for PRNG to the given binary. This calls the
	RAND_seed function from openssl. Only use this if the system
	you are running on does not have enough "randomness" built in.
	Normally this is when <span class="bold_code"><a href="#strong_rand_bytes-1">
	stong_rand_bytes/1</a></span> returns <span class="code">low_entropy</span></p>
      </p></div>

     <p><a name="rand_uniform-2"><span class="bold_code">rand_uniform(Lo, Hi) -&gt; N</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Lo, Hi, N = integer()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Generate a random number <span class="code">N, Lo =&lt; N &lt; Hi.</span> Uses the
	<span class="code">crypto</span> library pseudo-random number generator.
	<span class="code">Hi</span> must be larger than <span class="code">Lo</span>.</p>
      </p></div>

    <p><a name="sign-4"><span class="bold_code">sign(Algorithm, DigestType, Msg, Key) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Algorithm = rsa | dss | ecdsa </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Msg = binary() | {digest,binary()}</span><br>
</div>
	<div class="REFBODY">The msg is either the binary "cleartext" data to be
	signed or it is the hashed value of "cleartext" i.e. the
	digest (plaintext).</div>
	<div class="REFTYPES">
<span class="bold_code">DigestType = digest_type()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Key = rsa_private() | dss_private() | [ecdh_private(),ecdh_params()]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Creates a digital signature.</p>
	<p>Algorithm <span class="code">dss</span> can only be used together with digest type
	<span class="code">sha</span>.</p>
	See also <span class="bold_code"><a href="public_key.html#sign-3">public_key:sign/3</a></span>
      </p></div>

    <p><a name="start-0"><span class="bold_code">start() -&gt; ok</span></a><br></p>
<div class="REFBODY"><p>
        <p> Equivalent to application:start(crypto).</p>
      </p></div>
    <p><a name="stop-0"><span class="bold_code">stop() -&gt; ok</span></a><br></p>
<div class="REFBODY"><p>
        <p> Equivalent to application:stop(crypto).</p>
      </p></div>

    <p><a name="strong_rand_bytes-1"><span class="bold_code">strong_rand_bytes(N) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">N = integer()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Generates N bytes randomly uniform 0..255, and returns the
        result in a binary. Uses a cryptographically secure prng seeded and
        periodically mixed with operating system provided entropy. By default
        this is the <span class="code">RAND_bytes</span> method from OpenSSL.</p>
	<p>May throw exception <span class="code">low_entropy</span> in case the random generator
	failed due to lack of secure "randomness".</p>
      </p></div>
    <p><a name="stream_init-2"><span class="bold_code">stream_init(Type, Key) -&gt; State</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Type = rc4 </span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">State = opaque() </span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Key = iodata()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Initializes the state for use in RC4 stream encryption
        <span class="bold_code"><a href="#stream_encrypt-2">stream_encrypt</a></span> and
        <span class="bold_code"><a href="#stream_decrypt-2">stream_decrypt</a></span></p>
      </p></div>

   <p><a name="stream_init-3"><span class="bold_code">stream_init(Type, Key, IVec) -&gt; State</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Type = aes_ctr </span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">State = opaque() </span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">Key = iodata()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">IVec = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Initializes the state for use in streaming AES encryption using Counter mode (CTR).
        <span class="code">Key</span> is the AES key and must be either 128, 192, or 256 bts long. <span class="code">IVec</span> is
        an arbitrary initializing vector of 128 bits (16 bytes). This state is for use with
        <span class="bold_code"><a href="#stream_encrypt-2">stream_encrypt</a></span> and
        <span class="bold_code"><a href="#stream_decrypt-2">stream_decrypt</a></span>.</p>
      </p></div>

    <p><a name="stream_encrypt-2"><span class="bold_code">stream_encrypt(State, PlainText) -&gt; { NewState, CipherText}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Text = iodata()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">CipherText = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Encrypts <span class="code">PlainText</span> according to the stream cipher <span class="code">Type</span> specified in stream_init/3.
	<span class="code">Text</span> can be any number of bytes. The initial <span class="code">State</span> is created using
        <span class="bold_code"><a href="#stream_init-2">stream_init</a></span>.
	<span class="code">NewState</span> must be passed into the next call to <span class="code">stream_encrypt</span>.</p>
      </p></div>

    <p><a name="stream_decrypt-2"><span class="bold_code">stream_decrypt(State, CipherText) -&gt; { NewState, PlainText }</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">CipherText = iodata()</span><br>
</div>
        <div class="REFTYPES">
<span class="bold_code">PlainText = binary()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Decrypts <span class="code">CipherText</span> according to the stream cipher <span class="code">Type</span> specified in stream_init/3.
	<span class="code">PlainText</span> can be any number of bytes. The initial <span class="code">State</span> is created using
        <span class="bold_code"><a href="#stream_init-2">stream_init</a></span>.
	<span class="code">NewState</span> must be passed into the next call to <span class="code">stream_decrypt</span>.</p>
      </p></div>

   <p><a name="supports-0"><span class="bold_code">supports() -&gt; AlgorithmList </span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code"> AlgorithmList =  [{hashs, [hash_algorithms()]},
                            {ciphers, [cipher_algorithms()]},
			    {public_keys, [public_key_algorithms()]}
      </span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p> Can be used to determine which crypto algorithms that are supported
	by the underlying OpenSSL library</p>
      </p></div>

    <p><a name="ec_curves-0"><span class="bold_code">ec_curves() -&gt; EllipticCurveList </span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">EllipticCurveList = [ec_named_curve()]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Can be used to determine which named elliptic curves are supported.</p>
      </p></div>

    <p><a name="ec_curve-1"><span class="bold_code">ec_curve(NamedCurve) -&gt; EllipticCurve </span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">NamedCurve = ec_named_curve()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">EllipticCurve = ec_explicit_curve()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
        <p>Return the defining parameters of a elliptic curve.</p>
      </p></div>

  <p><a name="verify-5"><span class="bold_code">verify(Algorithm, DigestType, Msg, Signature, Key) -&gt; boolean()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code"> Algorithm = rsa | dss | ecdsa </span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Msg = binary() | {digest,binary()}</span><br>
</div>
	<div class="REFBODY">The msg is either the binary "cleartext" data
        or it is the hashed value of "cleartext" i.e. the digest (plaintext).</div>
	<div class="REFTYPES">
<span class="bold_code">DigestType = digest_type()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Signature = binary()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Key = rsa_public() | dss_public() | [ecdh_public(),ecdh_params()]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Verifies a digital signature</p>
	<p>Algorithm <span class="code">dss</span> can only be used together with digest type
	<span class="code">sha</span>.</p>

	See also <span class="bold_code"><a href="public_key.html#verify-4">public_key:verify/4</a></span>
      </p></div>

 

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1999-2015 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
