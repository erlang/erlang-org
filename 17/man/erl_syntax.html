<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- erl_syntax</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/syntax_tools/users_guide.html">User's Guide</a><br><a href="../apps/syntax_tools/index.html">Reference Manual</a><br><a href="../apps/syntax_tools/release_notes.html">Release Notes</a><br><a href="../apps/syntax_tools/syntax_tools.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Syntax_Tools</strong><br><strong>Reference Manual</strong><br><small>Version 1.6.18</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li id="no" title="epp_dodger " expanded="false">epp_dodger<ul>
<li><a href="epp_dodger.html">
                  Top of manual page
                </a></li>
<li title="parse-1"><a href="epp_dodger.html#parse-1">parse/1</a></li>
<li title="parse-2"><a href="epp_dodger.html#parse-2">parse/2</a></li>
<li title="parse-3"><a href="epp_dodger.html#parse-3">parse/3</a></li>
<li title="parse_file-1"><a href="epp_dodger.html#parse_file-1">parse_file/1</a></li>
<li title="parse_file-2"><a href="epp_dodger.html#parse_file-2">parse_file/2</a></li>
<li title="parse_form-2"><a href="epp_dodger.html#parse_form-2">parse_form/2</a></li>
<li title="parse_form-3"><a href="epp_dodger.html#parse_form-3">parse_form/3</a></li>
<li title="quick_parse-1"><a href="epp_dodger.html#quick_parse-1">quick_parse/1</a></li>
<li title="quick_parse-2"><a href="epp_dodger.html#quick_parse-2">quick_parse/2</a></li>
<li title="quick_parse-3"><a href="epp_dodger.html#quick_parse-3">quick_parse/3</a></li>
<li title="quick_parse_file-1"><a href="epp_dodger.html#quick_parse_file-1">quick_parse_file/1</a></li>
<li title="quick_parse_file-2"><a href="epp_dodger.html#quick_parse_file-2">quick_parse_file/2</a></li>
<li title="quick_parse_form-2"><a href="epp_dodger.html#quick_parse_form-2">quick_parse_form/2</a></li>
<li title="quick_parse_form-3"><a href="epp_dodger.html#quick_parse_form-3">quick_parse_form/3</a></li>
<li title="tokens_to_string-1"><a href="epp_dodger.html#tokens_to_string-1">tokens_to_string/1</a></li>
</ul>
</li>
<li id="no" title="erl_comment_scan " expanded="false">erl_comment_scan<ul>
<li><a href="erl_comment_scan.html">
                  Top of manual page
                </a></li>
<li title="file-1"><a href="erl_comment_scan.html#file-1">file/1</a></li>
<li title="join_lines-1"><a href="erl_comment_scan.html#join_lines-1">join_lines/1</a></li>
<li title="scan_lines-1"><a href="erl_comment_scan.html#scan_lines-1">scan_lines/1</a></li>
<li title="string-1"><a href="erl_comment_scan.html#string-1">string/1</a></li>
</ul>
</li>
<li id="no" title="erl_prettypr " expanded="false">erl_prettypr<ul>
<li><a href="erl_prettypr.html">
                  Top of manual page
                </a></li>
<li title="best-1"><a href="erl_prettypr.html#best-1">best/1</a></li>
<li title="best-2"><a href="erl_prettypr.html#best-2">best/2</a></li>
<li title="format-1"><a href="erl_prettypr.html#format-1">format/1</a></li>
<li title="format-2"><a href="erl_prettypr.html#format-2">format/2</a></li>
<li title="get_ctxt_hook-1"><a href="erl_prettypr.html#get_ctxt_hook-1">get_ctxt_hook/1</a></li>
<li title="get_ctxt_linewidth-1"><a href="erl_prettypr.html#get_ctxt_linewidth-1">get_ctxt_linewidth/1</a></li>
<li title="get_ctxt_paperwidth-1"><a href="erl_prettypr.html#get_ctxt_paperwidth-1">get_ctxt_paperwidth/1</a></li>
<li title="get_ctxt_precedence-1"><a href="erl_prettypr.html#get_ctxt_precedence-1">get_ctxt_precedence/1</a></li>
<li title="get_ctxt_user-1"><a href="erl_prettypr.html#get_ctxt_user-1">get_ctxt_user/1</a></li>
<li title="layout-1"><a href="erl_prettypr.html#layout-1">layout/1</a></li>
<li title="layout-2"><a href="erl_prettypr.html#layout-2">layout/2</a></li>
<li title="set_ctxt_hook-2"><a href="erl_prettypr.html#set_ctxt_hook-2">set_ctxt_hook/2</a></li>
<li title="set_ctxt_linewidth-2"><a href="erl_prettypr.html#set_ctxt_linewidth-2">set_ctxt_linewidth/2</a></li>
<li title="set_ctxt_paperwidth-2"><a href="erl_prettypr.html#set_ctxt_paperwidth-2">set_ctxt_paperwidth/2</a></li>
<li title="set_ctxt_precedence-2"><a href="erl_prettypr.html#set_ctxt_precedence-2">set_ctxt_precedence/2</a></li>
<li title="set_ctxt_user-2"><a href="erl_prettypr.html#set_ctxt_user-2">set_ctxt_user/2</a></li>
</ul>
</li>
<li id="no" title="erl_recomment " expanded="false">erl_recomment<ul>
<li><a href="erl_recomment.html">
                  Top of manual page
                </a></li>
<li title="quick_recomment_forms-2"><a href="erl_recomment.html#quick_recomment_forms-2">quick_recomment_forms/2</a></li>
<li title="recomment_forms-2"><a href="erl_recomment.html#recomment_forms-2">recomment_forms/2</a></li>
<li title="recomment_tree-2"><a href="erl_recomment.html#recomment_tree-2">recomment_tree/2</a></li>
</ul>
</li>
<li id="loadscrollpos" title="erl_syntax " expanded="true">erl_syntax<ul>
<li><a href="erl_syntax.html">
                  Top of manual page
                </a></li>
<li title="abstract-1"><a href="erl_syntax.html#abstract-1">abstract/1</a></li>
<li title="add_ann-2"><a href="erl_syntax.html#add_ann-2">add_ann/2</a></li>
<li title="add_postcomments-2"><a href="erl_syntax.html#add_postcomments-2">add_postcomments/2</a></li>
<li title="add_precomments-2"><a href="erl_syntax.html#add_precomments-2">add_precomments/2</a></li>
<li title="application-2"><a href="erl_syntax.html#application-2">application/2</a></li>
<li title="application-3"><a href="erl_syntax.html#application-3">application/3</a></li>
<li title="application_arguments-1"><a href="erl_syntax.html#application_arguments-1">application_arguments/1</a></li>
<li title="application_operator-1"><a href="erl_syntax.html#application_operator-1">application_operator/1</a></li>
<li title="arity_qualifier-2"><a href="erl_syntax.html#arity_qualifier-2">arity_qualifier/2</a></li>
<li title="arity_qualifier_argument-1"><a href="erl_syntax.html#arity_qualifier_argument-1">arity_qualifier_argument/1</a></li>
<li title="arity_qualifier_body-1"><a href="erl_syntax.html#arity_qualifier_body-1">arity_qualifier_body/1</a></li>
<li title="atom-1"><a href="erl_syntax.html#atom-1">atom/1</a></li>
<li title="atom_literal-1"><a href="erl_syntax.html#atom_literal-1">atom_literal/1</a></li>
<li title="atom_name-1"><a href="erl_syntax.html#atom_name-1">atom_name/1</a></li>
<li title="atom_value-1"><a href="erl_syntax.html#atom_value-1">atom_value/1</a></li>
<li title="attribute-1"><a href="erl_syntax.html#attribute-1">attribute/1</a></li>
<li title="attribute-2"><a href="erl_syntax.html#attribute-2">attribute/2</a></li>
<li title="attribute_arguments-1"><a href="erl_syntax.html#attribute_arguments-1">attribute_arguments/1</a></li>
<li title="attribute_name-1"><a href="erl_syntax.html#attribute_name-1">attribute_name/1</a></li>
<li title="binary-1"><a href="erl_syntax.html#binary-1">binary/1</a></li>
<li title="binary_comp-2"><a href="erl_syntax.html#binary_comp-2">binary_comp/2</a></li>
<li title="binary_comp_body-1"><a href="erl_syntax.html#binary_comp_body-1">binary_comp_body/1</a></li>
<li title="binary_comp_template-1"><a href="erl_syntax.html#binary_comp_template-1">binary_comp_template/1</a></li>
<li title="binary_field-1"><a href="erl_syntax.html#binary_field-1">binary_field/1</a></li>
<li title="binary_field-2"><a href="erl_syntax.html#binary_field-2">binary_field/2</a></li>
<li title="binary_field-3"><a href="erl_syntax.html#binary_field-3">binary_field/3</a></li>
<li title="binary_field_body-1"><a href="erl_syntax.html#binary_field_body-1">binary_field_body/1</a></li>
<li title="binary_field_size-1"><a href="erl_syntax.html#binary_field_size-1">binary_field_size/1</a></li>
<li title="binary_field_types-1"><a href="erl_syntax.html#binary_field_types-1">binary_field_types/1</a></li>
<li title="binary_fields-1"><a href="erl_syntax.html#binary_fields-1">binary_fields/1</a></li>
<li title="binary_generator-2"><a href="erl_syntax.html#binary_generator-2">binary_generator/2</a></li>
<li title="binary_generator_body-1"><a href="erl_syntax.html#binary_generator_body-1">binary_generator_body/1</a></li>
<li title="binary_generator_pattern-1"><a href="erl_syntax.html#binary_generator_pattern-1">binary_generator_pattern/1</a></li>
<li title="block_expr-1"><a href="erl_syntax.html#block_expr-1">block_expr/1</a></li>
<li title="block_expr_body-1"><a href="erl_syntax.html#block_expr_body-1">block_expr_body/1</a></li>
<li title="case_expr-2"><a href="erl_syntax.html#case_expr-2">case_expr/2</a></li>
<li title="case_expr_argument-1"><a href="erl_syntax.html#case_expr_argument-1">case_expr_argument/1</a></li>
<li title="case_expr_clauses-1"><a href="erl_syntax.html#case_expr_clauses-1">case_expr_clauses/1</a></li>
<li title="catch_expr-1"><a href="erl_syntax.html#catch_expr-1">catch_expr/1</a></li>
<li title="catch_expr_body-1"><a href="erl_syntax.html#catch_expr_body-1">catch_expr_body/1</a></li>
<li title="char-1"><a href="erl_syntax.html#char-1">char/1</a></li>
<li title="char_literal-1"><a href="erl_syntax.html#char_literal-1">char_literal/1</a></li>
<li title="char_literal-2"><a href="erl_syntax.html#char_literal-2">char_literal/2</a></li>
<li title="char_value-1"><a href="erl_syntax.html#char_value-1">char_value/1</a></li>
<li title="class_qualifier-2"><a href="erl_syntax.html#class_qualifier-2">class_qualifier/2</a></li>
<li title="class_qualifier_argument-1"><a href="erl_syntax.html#class_qualifier_argument-1">class_qualifier_argument/1</a></li>
<li title="class_qualifier_body-1"><a href="erl_syntax.html#class_qualifier_body-1">class_qualifier_body/1</a></li>
<li title="clause-2"><a href="erl_syntax.html#clause-2">clause/2</a></li>
<li title="clause-3"><a href="erl_syntax.html#clause-3">clause/3</a></li>
<li title="clause_body-1"><a href="erl_syntax.html#clause_body-1">clause_body/1</a></li>
<li title="clause_guard-1"><a href="erl_syntax.html#clause_guard-1">clause_guard/1</a></li>
<li title="clause_patterns-1"><a href="erl_syntax.html#clause_patterns-1">clause_patterns/1</a></li>
<li title="comment-1"><a href="erl_syntax.html#comment-1">comment/1</a></li>
<li title="comment-2"><a href="erl_syntax.html#comment-2">comment/2</a></li>
<li title="comment_padding-1"><a href="erl_syntax.html#comment_padding-1">comment_padding/1</a></li>
<li title="comment_text-1"><a href="erl_syntax.html#comment_text-1">comment_text/1</a></li>
<li title="compact_list-1"><a href="erl_syntax.html#compact_list-1">compact_list/1</a></li>
<li title="concrete-1"><a href="erl_syntax.html#concrete-1">concrete/1</a></li>
<li title="cond_expr-1"><a href="erl_syntax.html#cond_expr-1">cond_expr/1</a></li>
<li title="cond_expr_clauses-1"><a href="erl_syntax.html#cond_expr_clauses-1">cond_expr_clauses/1</a></li>
<li title="conjunction-1"><a href="erl_syntax.html#conjunction-1">conjunction/1</a></li>
<li title="conjunction_body-1"><a href="erl_syntax.html#conjunction_body-1">conjunction_body/1</a></li>
<li title="cons-2"><a href="erl_syntax.html#cons-2">cons/2</a></li>
<li title="copy_ann-2"><a href="erl_syntax.html#copy_ann-2">copy_ann/2</a></li>
<li title="copy_attrs-2"><a href="erl_syntax.html#copy_attrs-2">copy_attrs/2</a></li>
<li title="copy_comments-2"><a href="erl_syntax.html#copy_comments-2">copy_comments/2</a></li>
<li title="copy_pos-2"><a href="erl_syntax.html#copy_pos-2">copy_pos/2</a></li>
<li title="data-1"><a href="erl_syntax.html#data-1">data/1</a></li>
<li title="disjunction-1"><a href="erl_syntax.html#disjunction-1">disjunction/1</a></li>
<li title="disjunction_body-1"><a href="erl_syntax.html#disjunction_body-1">disjunction_body/1</a></li>
<li title="eof_marker-0"><a href="erl_syntax.html#eof_marker-0">eof_marker/0</a></li>
<li title="error_marker-1"><a href="erl_syntax.html#error_marker-1">error_marker/1</a></li>
<li title="error_marker_info-1"><a href="erl_syntax.html#error_marker_info-1">error_marker_info/1</a></li>
<li title="flatten_form_list-1"><a href="erl_syntax.html#flatten_form_list-1">flatten_form_list/1</a></li>
<li title="float-1"><a href="erl_syntax.html#float-1">float/1</a></li>
<li title="float_literal-1"><a href="erl_syntax.html#float_literal-1">float_literal/1</a></li>
<li title="float_value-1"><a href="erl_syntax.html#float_value-1">float_value/1</a></li>
<li title="form_list-1"><a href="erl_syntax.html#form_list-1">form_list/1</a></li>
<li title="form_list_elements-1"><a href="erl_syntax.html#form_list_elements-1">form_list_elements/1</a></li>
<li title="fun_expr-1"><a href="erl_syntax.html#fun_expr-1">fun_expr/1</a></li>
<li title="fun_expr_arity-1"><a href="erl_syntax.html#fun_expr_arity-1">fun_expr_arity/1</a></li>
<li title="fun_expr_clauses-1"><a href="erl_syntax.html#fun_expr_clauses-1">fun_expr_clauses/1</a></li>
<li title="function-2"><a href="erl_syntax.html#function-2">function/2</a></li>
<li title="function_arity-1"><a href="erl_syntax.html#function_arity-1">function_arity/1</a></li>
<li title="function_clauses-1"><a href="erl_syntax.html#function_clauses-1">function_clauses/1</a></li>
<li title="function_name-1"><a href="erl_syntax.html#function_name-1">function_name/1</a></li>
<li title="generator-2"><a href="erl_syntax.html#generator-2">generator/2</a></li>
<li title="generator_body-1"><a href="erl_syntax.html#generator_body-1">generator_body/1</a></li>
<li title="generator_pattern-1"><a href="erl_syntax.html#generator_pattern-1">generator_pattern/1</a></li>
<li title="get_ann-1"><a href="erl_syntax.html#get_ann-1">get_ann/1</a></li>
<li title="get_attrs-1"><a href="erl_syntax.html#get_attrs-1">get_attrs/1</a></li>
<li title="get_pos-1"><a href="erl_syntax.html#get_pos-1">get_pos/1</a></li>
<li title="get_postcomments-1"><a href="erl_syntax.html#get_postcomments-1">get_postcomments/1</a></li>
<li title="get_precomments-1"><a href="erl_syntax.html#get_precomments-1">get_precomments/1</a></li>
<li title="has_comments-1"><a href="erl_syntax.html#has_comments-1">has_comments/1</a></li>
<li title="if_expr-1"><a href="erl_syntax.html#if_expr-1">if_expr/1</a></li>
<li title="if_expr_clauses-1"><a href="erl_syntax.html#if_expr_clauses-1">if_expr_clauses/1</a></li>
<li title="implicit_fun-1"><a href="erl_syntax.html#implicit_fun-1">implicit_fun/1</a></li>
<li title="implicit_fun-2"><a href="erl_syntax.html#implicit_fun-2">implicit_fun/2</a></li>
<li title="implicit_fun-3"><a href="erl_syntax.html#implicit_fun-3">implicit_fun/3</a></li>
<li title="implicit_fun_name-1"><a href="erl_syntax.html#implicit_fun_name-1">implicit_fun_name/1</a></li>
<li title="infix_expr-3"><a href="erl_syntax.html#infix_expr-3">infix_expr/3</a></li>
<li title="infix_expr_left-1"><a href="erl_syntax.html#infix_expr_left-1">infix_expr_left/1</a></li>
<li title="infix_expr_operator-1"><a href="erl_syntax.html#infix_expr_operator-1">infix_expr_operator/1</a></li>
<li title="infix_expr_right-1"><a href="erl_syntax.html#infix_expr_right-1">infix_expr_right/1</a></li>
<li title="integer-1"><a href="erl_syntax.html#integer-1">integer/1</a></li>
<li title="integer_literal-1"><a href="erl_syntax.html#integer_literal-1">integer_literal/1</a></li>
<li title="integer_value-1"><a href="erl_syntax.html#integer_value-1">integer_value/1</a></li>
<li title="is_atom-2"><a href="erl_syntax.html#is_atom-2">is_atom/2</a></li>
<li title="is_char-2"><a href="erl_syntax.html#is_char-2">is_char/2</a></li>
<li title="is_form-1"><a href="erl_syntax.html#is_form-1">is_form/1</a></li>
<li title="is_integer-2"><a href="erl_syntax.html#is_integer-2">is_integer/2</a></li>
<li title="is_leaf-1"><a href="erl_syntax.html#is_leaf-1">is_leaf/1</a></li>
<li title="is_list_skeleton-1"><a href="erl_syntax.html#is_list_skeleton-1">is_list_skeleton/1</a></li>
<li title="is_literal-1"><a href="erl_syntax.html#is_literal-1">is_literal/1</a></li>
<li title="is_proper_list-1"><a href="erl_syntax.html#is_proper_list-1">is_proper_list/1</a></li>
<li title="is_string-2"><a href="erl_syntax.html#is_string-2">is_string/2</a></li>
<li title="is_tree-1"><a href="erl_syntax.html#is_tree-1">is_tree/1</a></li>
<li title="join_comments-2"><a href="erl_syntax.html#join_comments-2">join_comments/2</a></li>
<li title="list-1"><a href="erl_syntax.html#list-1">list/1</a></li>
<li title="list-2"><a href="erl_syntax.html#list-2">list/2</a></li>
<li title="list_comp-2"><a href="erl_syntax.html#list_comp-2">list_comp/2</a></li>
<li title="list_comp_body-1"><a href="erl_syntax.html#list_comp_body-1">list_comp_body/1</a></li>
<li title="list_comp_template-1"><a href="erl_syntax.html#list_comp_template-1">list_comp_template/1</a></li>
<li title="list_elements-1"><a href="erl_syntax.html#list_elements-1">list_elements/1</a></li>
<li title="list_head-1"><a href="erl_syntax.html#list_head-1">list_head/1</a></li>
<li title="list_length-1"><a href="erl_syntax.html#list_length-1">list_length/1</a></li>
<li title="list_prefix-1"><a href="erl_syntax.html#list_prefix-1">list_prefix/1</a></li>
<li title="list_suffix-1"><a href="erl_syntax.html#list_suffix-1">list_suffix/1</a></li>
<li title="list_tail-1"><a href="erl_syntax.html#list_tail-1">list_tail/1</a></li>
<li title="macro-1"><a href="erl_syntax.html#macro-1">macro/1</a></li>
<li title="macro-2"><a href="erl_syntax.html#macro-2">macro/2</a></li>
<li title="macro_arguments-1"><a href="erl_syntax.html#macro_arguments-1">macro_arguments/1</a></li>
<li title="macro_name-1"><a href="erl_syntax.html#macro_name-1">macro_name/1</a></li>
<li title="make_tree-2"><a href="erl_syntax.html#make_tree-2">make_tree/2</a></li>
<li title="map_expr-1"><a href="erl_syntax.html#map_expr-1">map_expr/1</a></li>
<li title="map_expr-2"><a href="erl_syntax.html#map_expr-2">map_expr/2</a></li>
<li title="map_expr_argument-1"><a href="erl_syntax.html#map_expr_argument-1">map_expr_argument/1</a></li>
<li title="map_expr_fields-1"><a href="erl_syntax.html#map_expr_fields-1">map_expr_fields/1</a></li>
<li title="map_field_assoc-2"><a href="erl_syntax.html#map_field_assoc-2">map_field_assoc/2</a></li>
<li title="map_field_assoc_name-1"><a href="erl_syntax.html#map_field_assoc_name-1">map_field_assoc_name/1</a></li>
<li title="map_field_assoc_value-1"><a href="erl_syntax.html#map_field_assoc_value-1">map_field_assoc_value/1</a></li>
<li title="map_field_exact-2"><a href="erl_syntax.html#map_field_exact-2">map_field_exact/2</a></li>
<li title="map_field_exact_name-1"><a href="erl_syntax.html#map_field_exact_name-1">map_field_exact_name/1</a></li>
<li title="map_field_exact_value-1"><a href="erl_syntax.html#map_field_exact_value-1">map_field_exact_value/1</a></li>
<li title="match_expr-2"><a href="erl_syntax.html#match_expr-2">match_expr/2</a></li>
<li title="match_expr_body-1"><a href="erl_syntax.html#match_expr_body-1">match_expr_body/1</a></li>
<li title="match_expr_pattern-1"><a href="erl_syntax.html#match_expr_pattern-1">match_expr_pattern/1</a></li>
<li title="meta-1"><a href="erl_syntax.html#meta-1">meta/1</a></li>
<li title="module_qualifier-2"><a href="erl_syntax.html#module_qualifier-2">module_qualifier/2</a></li>
<li title="module_qualifier_argument-1"><a href="erl_syntax.html#module_qualifier_argument-1">module_qualifier_argument/1</a></li>
<li title="module_qualifier_body-1"><a href="erl_syntax.html#module_qualifier_body-1">module_qualifier_body/1</a></li>
<li title="named_fun_expr-2"><a href="erl_syntax.html#named_fun_expr-2">named_fun_expr/2</a></li>
<li title="named_fun_expr_arity-1"><a href="erl_syntax.html#named_fun_expr_arity-1">named_fun_expr_arity/1</a></li>
<li title="named_fun_expr_clauses-1"><a href="erl_syntax.html#named_fun_expr_clauses-1">named_fun_expr_clauses/1</a></li>
<li title="named_fun_expr_name-1"><a href="erl_syntax.html#named_fun_expr_name-1">named_fun_expr_name/1</a></li>
<li title="nil-0"><a href="erl_syntax.html#nil-0">nil/0</a></li>
<li title="normalize_list-1"><a href="erl_syntax.html#normalize_list-1">normalize_list/1</a></li>
<li title="operator-1"><a href="erl_syntax.html#operator-1">operator/1</a></li>
<li title="operator_literal-1"><a href="erl_syntax.html#operator_literal-1">operator_literal/1</a></li>
<li title="operator_name-1"><a href="erl_syntax.html#operator_name-1">operator_name/1</a></li>
<li title="parentheses-1"><a href="erl_syntax.html#parentheses-1">parentheses/1</a></li>
<li title="parentheses_body-1"><a href="erl_syntax.html#parentheses_body-1">parentheses_body/1</a></li>
<li title="prefix_expr-2"><a href="erl_syntax.html#prefix_expr-2">prefix_expr/2</a></li>
<li title="prefix_expr_argument-1"><a href="erl_syntax.html#prefix_expr_argument-1">prefix_expr_argument/1</a></li>
<li title="prefix_expr_operator-1"><a href="erl_syntax.html#prefix_expr_operator-1">prefix_expr_operator/1</a></li>
<li title="receive_expr-1"><a href="erl_syntax.html#receive_expr-1">receive_expr/1</a></li>
<li title="receive_expr-3"><a href="erl_syntax.html#receive_expr-3">receive_expr/3</a></li>
<li title="receive_expr_action-1"><a href="erl_syntax.html#receive_expr_action-1">receive_expr_action/1</a></li>
<li title="receive_expr_clauses-1"><a href="erl_syntax.html#receive_expr_clauses-1">receive_expr_clauses/1</a></li>
<li title="receive_expr_timeout-1"><a href="erl_syntax.html#receive_expr_timeout-1">receive_expr_timeout/1</a></li>
<li title="record_access-2"><a href="erl_syntax.html#record_access-2">record_access/2</a></li>
<li title="record_access-3"><a href="erl_syntax.html#record_access-3">record_access/3</a></li>
<li title="record_access_argument-1"><a href="erl_syntax.html#record_access_argument-1">record_access_argument/1</a></li>
<li title="record_access_field-1"><a href="erl_syntax.html#record_access_field-1">record_access_field/1</a></li>
<li title="record_access_type-1"><a href="erl_syntax.html#record_access_type-1">record_access_type/1</a></li>
<li title="record_expr-2"><a href="erl_syntax.html#record_expr-2">record_expr/2</a></li>
<li title="record_expr-3"><a href="erl_syntax.html#record_expr-3">record_expr/3</a></li>
<li title="record_expr_argument-1"><a href="erl_syntax.html#record_expr_argument-1">record_expr_argument/1</a></li>
<li title="record_expr_fields-1"><a href="erl_syntax.html#record_expr_fields-1">record_expr_fields/1</a></li>
<li title="record_expr_type-1"><a href="erl_syntax.html#record_expr_type-1">record_expr_type/1</a></li>
<li title="record_field-1"><a href="erl_syntax.html#record_field-1">record_field/1</a></li>
<li title="record_field-2"><a href="erl_syntax.html#record_field-2">record_field/2</a></li>
<li title="record_field_name-1"><a href="erl_syntax.html#record_field_name-1">record_field_name/1</a></li>
<li title="record_field_value-1"><a href="erl_syntax.html#record_field_value-1">record_field_value/1</a></li>
<li title="record_index_expr-2"><a href="erl_syntax.html#record_index_expr-2">record_index_expr/2</a></li>
<li title="record_index_expr_field-1"><a href="erl_syntax.html#record_index_expr_field-1">record_index_expr_field/1</a></li>
<li title="record_index_expr_type-1"><a href="erl_syntax.html#record_index_expr_type-1">record_index_expr_type/1</a></li>
<li title="remove_comments-1"><a href="erl_syntax.html#remove_comments-1">remove_comments/1</a></li>
<li title="revert-1"><a href="erl_syntax.html#revert-1">revert/1</a></li>
<li title="revert_forms-1"><a href="erl_syntax.html#revert_forms-1">revert_forms/1</a></li>
<li title="rule-2"><a href="erl_syntax.html#rule-2">rule/2</a></li>
<li title="rule_arity-1"><a href="erl_syntax.html#rule_arity-1">rule_arity/1</a></li>
<li title="rule_clauses-1"><a href="erl_syntax.html#rule_clauses-1">rule_clauses/1</a></li>
<li title="rule_name-1"><a href="erl_syntax.html#rule_name-1">rule_name/1</a></li>
<li title="set_ann-2"><a href="erl_syntax.html#set_ann-2">set_ann/2</a></li>
<li title="set_attrs-2"><a href="erl_syntax.html#set_attrs-2">set_attrs/2</a></li>
<li title="set_pos-2"><a href="erl_syntax.html#set_pos-2">set_pos/2</a></li>
<li title="set_postcomments-2"><a href="erl_syntax.html#set_postcomments-2">set_postcomments/2</a></li>
<li title="set_precomments-2"><a href="erl_syntax.html#set_precomments-2">set_precomments/2</a></li>
<li title="size_qualifier-2"><a href="erl_syntax.html#size_qualifier-2">size_qualifier/2</a></li>
<li title="size_qualifier_argument-1"><a href="erl_syntax.html#size_qualifier_argument-1">size_qualifier_argument/1</a></li>
<li title="size_qualifier_body-1"><a href="erl_syntax.html#size_qualifier_body-1">size_qualifier_body/1</a></li>
<li title="string-1"><a href="erl_syntax.html#string-1">string/1</a></li>
<li title="string_literal-1"><a href="erl_syntax.html#string_literal-1">string_literal/1</a></li>
<li title="string_literal-2"><a href="erl_syntax.html#string_literal-2">string_literal/2</a></li>
<li title="string_value-1"><a href="erl_syntax.html#string_value-1">string_value/1</a></li>
<li title="subtrees-1"><a href="erl_syntax.html#subtrees-1">subtrees/1</a></li>
<li title="text-1"><a href="erl_syntax.html#text-1">text/1</a></li>
<li title="text_string-1"><a href="erl_syntax.html#text_string-1">text_string/1</a></li>
<li title="tree-1"><a href="erl_syntax.html#tree-1">tree/1</a></li>
<li title="tree-2"><a href="erl_syntax.html#tree-2">tree/2</a></li>
<li title="try_after_expr-2"><a href="erl_syntax.html#try_after_expr-2">try_after_expr/2</a></li>
<li title="try_expr-2"><a href="erl_syntax.html#try_expr-2">try_expr/2</a></li>
<li title="try_expr-3"><a href="erl_syntax.html#try_expr-3">try_expr/3</a></li>
<li title="try_expr-4"><a href="erl_syntax.html#try_expr-4">try_expr/4</a></li>
<li title="try_expr_after-1"><a href="erl_syntax.html#try_expr_after-1">try_expr_after/1</a></li>
<li title="try_expr_body-1"><a href="erl_syntax.html#try_expr_body-1">try_expr_body/1</a></li>
<li title="try_expr_clauses-1"><a href="erl_syntax.html#try_expr_clauses-1">try_expr_clauses/1</a></li>
<li title="try_expr_handlers-1"><a href="erl_syntax.html#try_expr_handlers-1">try_expr_handlers/1</a></li>
<li title="tuple-1"><a href="erl_syntax.html#tuple-1">tuple/1</a></li>
<li title="tuple_elements-1"><a href="erl_syntax.html#tuple_elements-1">tuple_elements/1</a></li>
<li title="tuple_size-1"><a href="erl_syntax.html#tuple_size-1">tuple_size/1</a></li>
<li title="type-1"><a href="erl_syntax.html#type-1">type/1</a></li>
<li title="underscore-0"><a href="erl_syntax.html#underscore-0">underscore/0</a></li>
<li title="update_tree-2"><a href="erl_syntax.html#update_tree-2">update_tree/2</a></li>
<li title="variable-1"><a href="erl_syntax.html#variable-1">variable/1</a></li>
<li title="variable_literal-1"><a href="erl_syntax.html#variable_literal-1">variable_literal/1</a></li>
<li title="variable_name-1"><a href="erl_syntax.html#variable_name-1">variable_name/1</a></li>
<li title="warning_marker-1"><a href="erl_syntax.html#warning_marker-1">warning_marker/1</a></li>
<li title="warning_marker_info-1"><a href="erl_syntax.html#warning_marker_info-1">warning_marker_info/1</a></li>
</ul>
</li>
<li id="no" title="erl_syntax_lib " expanded="false">erl_syntax_lib<ul>
<li><a href="erl_syntax_lib.html">
                  Top of manual page
                </a></li>
<li title="analyze_application-1"><a href="erl_syntax_lib.html#analyze_application-1">analyze_application/1</a></li>
<li title="analyze_attribute-1"><a href="erl_syntax_lib.html#analyze_attribute-1">analyze_attribute/1</a></li>
<li title="analyze_export_attribute-1"><a href="erl_syntax_lib.html#analyze_export_attribute-1">analyze_export_attribute/1</a></li>
<li title="analyze_file_attribute-1"><a href="erl_syntax_lib.html#analyze_file_attribute-1">analyze_file_attribute/1</a></li>
<li title="analyze_form-1"><a href="erl_syntax_lib.html#analyze_form-1">analyze_form/1</a></li>
<li title="analyze_forms-1"><a href="erl_syntax_lib.html#analyze_forms-1">analyze_forms/1</a></li>
<li title="analyze_function-1"><a href="erl_syntax_lib.html#analyze_function-1">analyze_function/1</a></li>
<li title="analyze_function_name-1"><a href="erl_syntax_lib.html#analyze_function_name-1">analyze_function_name/1</a></li>
<li title="analyze_implicit_fun-1"><a href="erl_syntax_lib.html#analyze_implicit_fun-1">analyze_implicit_fun/1</a></li>
<li title="analyze_import_attribute-1"><a href="erl_syntax_lib.html#analyze_import_attribute-1">analyze_import_attribute/1</a></li>
<li title="analyze_module_attribute-1"><a href="erl_syntax_lib.html#analyze_module_attribute-1">analyze_module_attribute/1</a></li>
<li title="analyze_record_attribute-1"><a href="erl_syntax_lib.html#analyze_record_attribute-1">analyze_record_attribute/1</a></li>
<li title="analyze_record_expr-1"><a href="erl_syntax_lib.html#analyze_record_expr-1">analyze_record_expr/1</a></li>
<li title="analyze_record_field-1"><a href="erl_syntax_lib.html#analyze_record_field-1">analyze_record_field/1</a></li>
<li title="analyze_rule-1"><a href="erl_syntax_lib.html#analyze_rule-1">analyze_rule/1</a></li>
<li title="analyze_wild_attribute-1"><a href="erl_syntax_lib.html#analyze_wild_attribute-1">analyze_wild_attribute/1</a></li>
<li title="annotate_bindings-1"><a href="erl_syntax_lib.html#annotate_bindings-1">annotate_bindings/1</a></li>
<li title="annotate_bindings-2"><a href="erl_syntax_lib.html#annotate_bindings-2">annotate_bindings/2</a></li>
<li title="fold-3"><a href="erl_syntax_lib.html#fold-3">fold/3</a></li>
<li title="fold_subtrees-3"><a href="erl_syntax_lib.html#fold_subtrees-3">fold_subtrees/3</a></li>
<li title="foldl_listlist-3"><a href="erl_syntax_lib.html#foldl_listlist-3">foldl_listlist/3</a></li>
<li title="function_name_expansions-1"><a href="erl_syntax_lib.html#function_name_expansions-1">function_name_expansions/1</a></li>
<li title="is_fail_expr-1"><a href="erl_syntax_lib.html#is_fail_expr-1">is_fail_expr/1</a></li>
<li title="limit-2"><a href="erl_syntax_lib.html#limit-2">limit/2</a></li>
<li title="limit-3"><a href="erl_syntax_lib.html#limit-3">limit/3</a></li>
<li title="map-2"><a href="erl_syntax_lib.html#map-2">map/2</a></li>
<li title="map_subtrees-2"><a href="erl_syntax_lib.html#map_subtrees-2">map_subtrees/2</a></li>
<li title="mapfold-3"><a href="erl_syntax_lib.html#mapfold-3">mapfold/3</a></li>
<li title="mapfold_subtrees-3"><a href="erl_syntax_lib.html#mapfold_subtrees-3">mapfold_subtrees/3</a></li>
<li title="mapfoldl_listlist-3"><a href="erl_syntax_lib.html#mapfoldl_listlist-3">mapfoldl_listlist/3</a></li>
<li title="new_variable_name-1"><a href="erl_syntax_lib.html#new_variable_name-1">new_variable_name/1</a></li>
<li title="new_variable_name-2"><a href="erl_syntax_lib.html#new_variable_name-2">new_variable_name/2</a></li>
<li title="new_variable_names-2"><a href="erl_syntax_lib.html#new_variable_names-2">new_variable_names/2</a></li>
<li title="new_variable_names-3"><a href="erl_syntax_lib.html#new_variable_names-3">new_variable_names/3</a></li>
<li title="strip_comments-1"><a href="erl_syntax_lib.html#strip_comments-1">strip_comments/1</a></li>
<li title="to_comment-1"><a href="erl_syntax_lib.html#to_comment-1">to_comment/1</a></li>
<li title="to_comment-2"><a href="erl_syntax_lib.html#to_comment-2">to_comment/2</a></li>
<li title="to_comment-3"><a href="erl_syntax_lib.html#to_comment-3">to_comment/3</a></li>
<li title="variables-1"><a href="erl_syntax_lib.html#variables-1">variables/1</a></li>
</ul>
</li>
<li id="no" title="erl_tidy " expanded="false">erl_tidy<ul>
<li><a href="erl_tidy.html">
                  Top of manual page
                </a></li>
<li title="dir-0"><a href="erl_tidy.html#dir-0">dir/0</a></li>
<li title="dir-1"><a href="erl_tidy.html#dir-1">dir/1</a></li>
<li title="dir-2"><a href="erl_tidy.html#dir-2">dir/2</a></li>
<li title="file-1"><a href="erl_tidy.html#file-1">file/1</a></li>
<li title="file-2"><a href="erl_tidy.html#file-2">file/2</a></li>
<li title="module-1"><a href="erl_tidy.html#module-1">module/1</a></li>
<li title="module-2"><a href="erl_tidy.html#module-2">module/2</a></li>
</ul>
</li>
<li id="no" title="igor " expanded="false">igor<ul>
<li><a href="igor.html">
                  Top of manual page
                </a></li>
<li title="create_stubs-2"><a href="igor.html#create_stubs-2">create_stubs/2</a></li>
<li title="merge-2"><a href="igor.html#merge-2">merge/2</a></li>
<li title="merge-3"><a href="igor.html#merge-3">merge/3</a></li>
<li title="merge_files-3"><a href="igor.html#merge_files-3">merge_files/3</a></li>
<li title="merge_files-4"><a href="igor.html#merge_files-4">merge_files/4</a></li>
<li title="merge_sources-3"><a href="igor.html#merge_sources-3">merge_sources/3</a></li>
<li title="parse_transform-2"><a href="igor.html#parse_transform-2">parse_transform/2</a></li>
<li title="rename-2"><a href="igor.html#rename-2">rename/2</a></li>
<li title="rename-3"><a href="igor.html#rename-3">rename/3</a></li>
</ul>
</li>
<li id="no" title="prettypr " expanded="false">prettypr<ul>
<li><a href="prettypr.html">
                  Top of manual page
                </a></li>
<li title="above-2"><a href="prettypr.html#above-2">above/2</a></li>
<li title="beside-2"><a href="prettypr.html#beside-2">beside/2</a></li>
<li title="best-3"><a href="prettypr.html#best-3">best/3</a></li>
<li title="break-1"><a href="prettypr.html#break-1">break/1</a></li>
<li title="empty-0"><a href="prettypr.html#empty-0">empty/0</a></li>
<li title="floating-1"><a href="prettypr.html#floating-1">floating/1</a></li>
<li title="floating-3"><a href="prettypr.html#floating-3">floating/3</a></li>
<li title="follow-2"><a href="prettypr.html#follow-2">follow/2</a></li>
<li title="follow-3"><a href="prettypr.html#follow-3">follow/3</a></li>
<li title="format-1"><a href="prettypr.html#format-1">format/1</a></li>
<li title="format-2"><a href="prettypr.html#format-2">format/2</a></li>
<li title="format-3"><a href="prettypr.html#format-3">format/3</a></li>
<li title="nest-2"><a href="prettypr.html#nest-2">nest/2</a></li>
<li title="null_text-1"><a href="prettypr.html#null_text-1">null_text/1</a></li>
<li title="par-1"><a href="prettypr.html#par-1">par/1</a></li>
<li title="par-2"><a href="prettypr.html#par-2">par/2</a></li>
<li title="sep-1"><a href="prettypr.html#sep-1">sep/1</a></li>
<li title="text-1"><a href="prettypr.html#text-1">text/1</a></li>
<li title="text_par-1"><a href="prettypr.html#text_par-1">text_par/1</a></li>
<li title="text_par-2"><a href="prettypr.html#text_par-2">text_par/2</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>erl_syntax</h1></center>

<h3>MODULE</h3>
<div class="REFBODY">erl_syntax</div>
<h3>MODULE SUMMARY</h3>
<div class="REFBODY">Abstract Erlang syntax trees.</div>
<h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
<p>Abstract Erlang syntax trees.</p>
 
  <p>This module defines an abstract data type for representing Erlang
  source code as syntax trees, in a way that is backwards compatible
  with the data structures created by the Erlang standard library
  parser module <span class="code">erl_parse</span> (often referred to as "parse
  trees", which is a bit of a misnomer). This means that all
  <span class="code">erl_parse</span> trees are valid abstract syntax trees, but the
  reverse is not true: abstract syntax trees can in general not be used
  as input to functions expecting an <span class="code">erl_parse</span> tree.
  However, as long as an abstract syntax tree represents a correct
  Erlang program, the function <span class="bold_code"><a href="#revert-1">revert/1</a></span> should be able to
  transform it to the corresponding <span class="code">erl_parse</span>  
representation.</p>
 
  <p>A recommended starting point for the first-time user is the documentation
  of the <span class="bold_code"><a href="#type-syntaxTree">syntaxTree()</a></span> data type, and the function <span class="bold_code"><a href="#type-1">type/1</a></span>.</p>
 
  <p><strong><a name="NOTES:">NOTES:</a></strong></p>
 
  <p>This module deals with the composition and decomposition of
  <strong>syntactic</strong> entities (as opposed to semantic ones); its  
purpose is to hide all direct references to the data structures used  
to represent these entities. With few exceptions, the functions in  
this module perform no semantic interpretation of their inputs, and  
in general, the user is assumed to pass type-correct arguments - if  
this is not done, the effects are not defined.</p>
 
  <p>With the exception of the <span class="bold_code"><a href="#type-erl_parse">erl_parse()</a></span> data structures,
  the internal representations of abstract syntax trees are subject to
  change without notice, and should not be documented outside this
  module. Furthermore, we do not give any guarantees on how an abstract
  syntax tree may or may not be represented, <strong>with the following
  exceptions</strong>: no syntax tree is represented by a single atom, such
  as <span class="code">none</span>, by a list constructor <span class="code">[X | Y]</span>, or
  by the empty list <span class="code">[]</span>. This can be relied on when writing
  functions that operate on syntax trees.</p></p></div>
<h3><a name="id70987">DATA TYPES</a></h3>
<div class="REFBODY">
<a name="types"></a>

<dl>
<dt><strong><span class="code">encoding() = utf8 | unicode | latin1</span></strong></dt>
<dd>
<a name="type-encoding"></a> </dd>
<dt><strong><span class="code">erl_parse() = abstract_form() (see module erl_parse) | abstract_expr() (see module erl_parse)</span></strong></dt>
<dd>
<a name="type-erl_parse"></a>
<p>  The representation built by the Erlang standard library parser
  <span class="code">erl_parse</span>. This is a subset of the <span class="bold_code"><a href="#type-syntaxTree">syntaxTree()</a></span> type.</p>
</dd>
<dt><strong><span class="code">forms() = syntaxTree() | [syntaxTree()]</span></strong></dt>
<dd>
<a name="type-forms"></a> </dd>
<dt><strong><span class="code">guard() = none | syntaxTree() | [syntaxTree()] | [[syntaxTree()]]</span></strong></dt>
<dd>
<a name="type-guard"></a> </dd>
<dt><strong><span class="code">padding() = none | integer()</span></strong></dt>
<dd>
<a name="type-padding"></a> </dd>
<dt><strong><span class="code">syntaxTree()</span></strong></dt>
<dd>
<a name="type-syntaxTree"></a>
<p>An abstract syntax tree. The <span class="bold_code"><a href="#type-erl_parse">erl_parse()</a></span>
  "parse tree" representation is a proper subset of the <span class="code">syntaxTree()</span>  
representation.</p>
 
  <p>Every abstract syntax tree node has a <strong>type</strong>, given by the
  function <span class="bold_code"><a href="#type-1">type/1</a></span>. Each node also has associated
  <strong>attributes</strong>; see <span class="bold_code"><a href="#get_attrs-1">get_attrs/1</a></span> for details. The functions
  <span class="bold_code"><a href="#make_tree-2">make_tree/2</a></span> and <span class="bold_code"><a href="#subtrees-1">subtrees/1</a></span> are generic
  constructor/decomposition functions for abstract syntax trees. The
  functions <span class="bold_code"><a href="#abstract-1">abstract/1</a></span> and <span class="bold_code"><a href="#concrete-1">concrete/1</a></span> convert between
  constant Erlang terms and their syntactic representations. The set of
  syntax tree nodes is extensible through the <span class="bold_code"><a href="#tree-2">tree/2</a></span> function.</p>
 
  <p>A syntax tree can be transformed to the <span class="bold_code"><a href="#type-erl_parse">erl_parse()</a></span>
  representation with the <span class="bold_code"><a href="#revert-1">revert/1</a></span> function.</p>
</dd>
<dt><strong><span class="code">syntaxTreeAttributes()</span></strong></dt>
<dd>
<a name="type-syntaxTreeAttributes"></a>
<p>This is an abstract representation of
  syntax tree node attributes; see the function <span class="bold_code"><a href="#get_attrs-1">get_attrs/1</a></span>.
 </p>
</dd>
</dl>
</div>
<h3>EXPORTS</h3>
<p><a name="abstract-1"><span class="bold_code">abstract(T::term()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="abstract-1"></a>

<p>Returns the syntax tree corresponding to an Erlang term.
  <span class="code">Term</span> must be a literal term, i.e., one that can be
  represented as a source code literal. Thus, it may not contain a
  process identifier, port, reference, binary or function value as a
  subterm. The function recognises printable strings, in order to get a
  compact and readable representation. Evaluation fails with reason
  <span class="code">badarg</span> if <span class="code">Term</span> is not a literal term.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#concrete-1">concrete/1</a></span>, <span class="bold_code"><a href="#is_literal-1">is_literal/1</a></span>.</p>
</p></div>
<p><a name="add_ann-2"><span class="bold_code">add_ann(A::term(), Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="add_ann-2"></a>

<p>Appends the term <span class="code">Annotation</span> to the list of user
  annotations of <span class="code">Node</span>.</p>
 
  <p>Note: this is equivalent to <span class="code">set_ann(Node, [Annotation |
  get_ann(Node)])</span>, but potentially more efficient.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#get_ann-1">get_ann/1</a></span>, <span class="bold_code"><a href="#set_ann-2">set_ann/2</a></span>.</p>
</p></div>
<p><a name="add_postcomments-2"><span class="bold_code">add_postcomments(Cs::[syntaxTree()], Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="add_postcomments-2"></a>

<p>Appends <span class="code">Comments</span> to the post-comments of <span class="code">Node</span>.</p>
 
  <p>Note: This is equivalent to <span class="code">set_postcomments(Node,
  get_postcomments(Node) ++ Comments)</span>, but potentially more
  efficient.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#add_precomments-2">add_precomments/2</a></span>, <span class="bold_code"><a href="#comment-2">comment/2</a></span>, <span class="bold_code"><a href="#get_postcomments-1">get_postcomments/1</a></span>, <span class="bold_code"><a href="#join_comments-2">join_comments/2</a></span>, <span class="bold_code"><a href="#set_postcomments-2">set_postcomments/2</a></span>.</p>
</p></div>
<p><a name="add_precomments-2"><span class="bold_code">add_precomments(Cs::[syntaxTree()], Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="add_precomments-2"></a>

<p>Appends <span class="code">Comments</span> to the pre-comments of <span class="code">Node</span>.</p>
 
  <p>Note: This is equivalent to <span class="code">set_precomments(Node,
  get_precomments(Node) ++ Comments)</span>, but potentially more
  efficient.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#add_postcomments-2">add_postcomments/2</a></span>, <span class="bold_code"><a href="#comment-2">comment/2</a></span>, <span class="bold_code"><a href="#get_precomments-1">get_precomments/1</a></span>, <span class="bold_code"><a href="#join_comments-2">join_comments/2</a></span>, <span class="bold_code"><a href="#set_precomments-2">set_precomments/2</a></span>.</p>
</p></div>
<p><a name="application-2"><span class="bold_code">application(Operator::syntaxTree(), Arguments::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="application-2"></a>

<p>Creates an abstract function application expression. If
  <span class="code">Arguments</span> is <span class="code">[A1, ..., An]</span>, the result
  represents "<span class="code">Operator(A1, ...,
  An)</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#application-3">application/3</a></span>, <span class="bold_code"><a href="#application_arguments-1">application_arguments/1</a></span>, <span class="bold_code"><a href="#application_operator-1">application_operator/1</a></span>.</p>
</p></div>
<p><a name="application-3"><span class="bold_code">application(Module::none | syntaxTree(), Name::syntaxTree(), Arguments::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="application-3"></a>

<p>Creates an abstract function application expression. If
  <span class="code">Module</span> is <span class="code">none</span>, this is call is equivalent
  to <span class="code">application(Function, Arguments)</span>, otherwise it is
  equivalent to <span class="code">application(module_qualifier(Module, Function),
  Arguments)</span>.</p>
 
  <p>(This is a utility function.)
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#application-2">application/2</a></span>, <span class="bold_code"><a href="#module_qualifier-2">module_qualifier/2</a></span>.</p>
</p></div>
<p><a name="application_arguments-1"><span class="bold_code">application_arguments(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="application_arguments-1"></a>

<p>Returns the list of argument subtrees of an
  <span class="code">application</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#application-2">application/2</a></span>.</p>
</p></div>
<p><a name="application_operator-1"><span class="bold_code">application_operator(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="application_operator-1"></a>

<p>Returns the operator subtree of an <span class="code">application</span> node.</p>
 
  <p>Note: if <span class="code">Node</span> represents
  "<span class="code">M:F(...)</span>", then the result is the
  subtree representing "<span class="code">M:F</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#application-2">application/2</a></span>, <span class="bold_code"><a href="#module_qualifier-2">module_qualifier/2</a></span>.</p>
</p></div>
<p><a name="arity_qualifier-2"><span class="bold_code">arity_qualifier(Body::syntaxTree(), Arity::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="arity_qualifier-2"></a>

<p>Creates an abstract arity qualifier. The result represents
  "<span class="code">Body/Arity</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#arity_qualifier_argument-1">arity_qualifier_argument/1</a></span>, <span class="bold_code"><a href="#arity_qualifier_body-1">arity_qualifier_body/1</a></span>.</p>
</p></div>
<p><a name="arity_qualifier_argument-1"><span class="bold_code">arity_qualifier_argument(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="arity_qualifier_argument-1"></a>

<p>Returns the argument (the arity) subtree of an
  <span class="code">arity_qualifier</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#arity_qualifier-2">arity_qualifier/2</a></span>.</p>
</p></div>
<p><a name="arity_qualifier_body-1"><span class="bold_code">arity_qualifier_body(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="arity_qualifier_body-1"></a>

<p>Returns the body subtree of an <span class="code">arity_qualifier</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#arity_qualifier-2">arity_qualifier/2</a></span>.</p>
</p></div>
<p><a name="atom-1"><span class="bold_code">atom(Name::atom() | string()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="atom-1"></a>

<p>Creates an abstract atom literal. The print name of the atom is
  the character sequence represented by <span class="code">Name</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#atom_literal-1">atom_literal/1</a></span>, <span class="bold_code"><a href="#atom_name-1">atom_name/1</a></span>, <span class="bold_code"><a href="#atom_value-1">atom_value/1</a></span>, <span class="bold_code"><a href="#is_atom-2">is_atom/2</a></span>.</p>
</p></div>
<p><a name="atom_literal-1"><span class="bold_code">atom_literal(Node::syntaxTree()) -&gt; string()</span></a><br></p>
<div class="REFBODY"><p><a name="atom_literal-1"></a>

<p>Returns the literal string represented by an <span class="code">atom</span>  
node. This includes surrounding single-quote characters if necessary.</p>
 
  <p>Note that e.g. the result of <span class="code">atom("x\ny")</span> represents
  any and all of `x\ny'', `x\12y'',
  `x\012y'' and `x\^Jy\''; see <span class="bold_code"><a href="#string-1">string/1</a></span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#atom-1">atom/1</a></span>, <span class="bold_code"><a href="#string-1">string/1</a></span>.</p>
</p></div>
<p><a name="atom_name-1"><span class="bold_code">atom_name(Node::syntaxTree()) -&gt; string()</span></a><br></p>
<div class="REFBODY"><p><a name="atom_name-1"></a>

<p>Returns the printname of an <span class="code">atom</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#atom-1">atom/1</a></span>.</p>
</p></div>
<p><a name="atom_value-1"><span class="bold_code">atom_value(Node::syntaxTree()) -&gt; atom()</span></a><br></p>
<div class="REFBODY"><p><a name="atom_value-1"></a>

<p>Returns the value represented by an <span class="code">atom</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#atom-1">atom/1</a></span>.</p>
</p></div>
<p><a name="attribute-1"><span class="bold_code">attribute(Name::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="attribute-1"></a>
<p>Equivalent to <span class="bold_code"><a href="#attribute-2">attribute(Name, none)</a></span>.</p>
</p></div>
<p><a name="attribute-2"><span class="bold_code">attribute(Name::syntaxTree(), Args::none | [syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="attribute-2"></a>

<p>Creates an abstract program attribute. If
  <span class="code">Arguments</span> is <span class="code">[A1, ..., An]</span>, the result
  represents "<span class="code">-Name(A1, ...,
  An).</span>". Otherwise, if <span class="code">Arguments</span> is
  <span class="code">none</span>, the result represents
  "<span class="code">-Name.</span>". The latter form makes it possible
  to represent preprocessor directives such as
  "<span class="code">-endif.</span>". Attributes are source code forms.</p>
 
  <p>Note: The preprocessor macro definition directive
  "<span class="code">-define(Name, Body).</span>" has relatively
  few requirements on the syntactical form of <span class="code">Body</span> (viewed
  as a sequence of tokens). The <span class="code">text</span> node type can be used
  for a <span class="code">Body</span> that is not a normal Erlang construct.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#attribute-1">attribute/1</a></span>, <span class="bold_code"><a href="#attribute_arguments-1">attribute_arguments/1</a></span>, <span class="bold_code"><a href="#attribute_name-1">attribute_name/1</a></span>, <span class="bold_code"><a href="#is_form-1">is_form/1</a></span>, <span class="bold_code"><a href="#text-1">text/1</a></span>.</p>
</p></div>
<p><a name="attribute_arguments-1"><span class="bold_code">attribute_arguments(Node::syntaxTree()) -&gt; none | [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="attribute_arguments-1"></a>

<p>Returns the list of argument subtrees of an
  <span class="code">attribute</span> node, if any. If <span class="code">Node</span>
  represents "<span class="code">-Name.</span>", the result is
  <span class="code">none</span>. Otherwise, if <span class="code">Node</span> represents
  "<span class="code">-Name(E1, ..., En).</span>",
  <span class="code">[E1, ..., E1]</span> is returned.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#attribute-1">attribute/1</a></span>.</p>
</p></div>
<p><a name="attribute_name-1"><span class="bold_code">attribute_name(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="attribute_name-1"></a>

<p>Returns the name subtree of an <span class="code">attribute</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#attribute-1">attribute/1</a></span>.</p>
</p></div>
<p><a name="binary-1"><span class="bold_code">binary(List::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="binary-1"></a>

<p>Creates an abstract binary-object template. If
  <span class="code">Fields</span> is <span class="code">[F1, ..., Fn]</span>, the result
  represents "<span class="code">&lt;&lt;F1, ...,
  Fn&gt;&gt;</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary_field-2">binary_field/2</a></span>, <span class="bold_code"><a href="#binary_fields-1">binary_fields/1</a></span>.</p>
</p></div>
<p><a name="binary_comp-2"><span class="bold_code">binary_comp(Template::syntaxTree(), Body::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="binary_comp-2"></a>

<p>Creates an abstract binary comprehension. If <span class="code">Body</span> is
  <span class="code">[E1, ..., En]</span>, the result represents
  "<span class="code">&lt;&lt;Template || E1, ..., En&gt;&gt;</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary_comp_body-1">binary_comp_body/1</a></span>, <span class="bold_code"><a href="#binary_comp_template-1">binary_comp_template/1</a></span>, <span class="bold_code"><a href="#generator-2">generator/2</a></span>.</p>
</p></div>
<p><a name="binary_comp_body-1"><span class="bold_code">binary_comp_body(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="binary_comp_body-1"></a>

<p>Returns the list of body subtrees of a <span class="code">binary_comp</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary_comp-2">binary_comp/2</a></span>.</p>
</p></div>
<p><a name="binary_comp_template-1"><span class="bold_code">binary_comp_template(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="binary_comp_template-1"></a>

<p>Returns the template subtree of a <span class="code">binary_comp</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary_comp-2">binary_comp/2</a></span>.</p>
</p></div>
<p><a name="binary_field-1"><span class="bold_code">binary_field(Body::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="binary_field-1"></a>
<p>Equivalent to <span class="bold_code"><a href="#binary_field-2">binary_field(Body, [])</a></span>.</p>
</p></div>
<p><a name="binary_field-2"><span class="bold_code">binary_field(Body::syntaxTree(), Types::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="binary_field-2"></a>

<p>Creates an abstract binary template field. If
  <span class="code">Types</span> is the empty list, the result simply represents
  "<span class="code">Body</span>", otherwise, if <span class="code">Types</span> is
  <span class="code">[T1, ..., Tn]</span>, the result represents
  "<span class="code">Body/T1-...-Tn</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary-1">binary/1</a></span>, <span class="bold_code"><a href="#binary_field-1">binary_field/1</a></span>, <span class="bold_code"><a href="#binary_field-3">binary_field/3</a></span>, <span class="bold_code"><a href="#binary_field_body-1">binary_field_body/1</a></span>, <span class="bold_code"><a href="#binary_field_size-1">binary_field_size/1</a></span>, <span class="bold_code"><a href="#binary_field_types-1">binary_field_types/1</a></span>.</p>
</p></div>
<p><a name="binary_field-3"><span class="bold_code">binary_field(Body::syntaxTree(), Size::none | syntaxTree(), Types::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="binary_field-3"></a>

<p>Creates an abstract binary template field.
  If <span class="code">Size</span> is <span class="code">none</span>, this is equivalent to
  "<span class="code">binary_field(Body, Types)</span>", otherwise it is
  equivalent to "<span class="code">binary_field(size_qualifier(Body, Size),
  Types)</span>".</p>
 
  <p>(This is a utility function.)
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary-1">binary/1</a></span>, <span class="bold_code"><a href="#binary_field-2">binary_field/2</a></span>, <span class="bold_code"><a href="#size_qualifier-2">size_qualifier/2</a></span>.</p>
</p></div>
<p><a name="binary_field_body-1"><span class="bold_code">binary_field_body(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="binary_field_body-1"></a>

<p>Returns the body subtree of a <span class="code">binary_field</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary_field-2">binary_field/2</a></span>.</p>
</p></div>
<p><a name="binary_field_size-1"><span class="bold_code">binary_field_size(Node::syntaxTree()) -&gt; none | syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="binary_field_size-1"></a>

<p>Returns the size specifier subtree of a
  <span class="code">binary_field</span> node, if any. If <span class="code">Node</span>
  represents "<span class="code">Body:Size</span>" or
  "<span class="code">Body:Size/T1, ...,
  Tn</span>", the result is <span class="code">Size</span>, otherwise
  <span class="code">none</span> is returned.</p>
 
  <p>(This is a utility function.)
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary_field-2">binary_field/2</a></span>, <span class="bold_code"><a href="#binary_field-3">binary_field/3</a></span>.</p>
</p></div>
<p><a name="binary_field_types-1"><span class="bold_code">binary_field_types(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="binary_field_types-1"></a>

<p>Returns the list of type-specifier subtrees of a
  <span class="code">binary_field</span> node. If <span class="code">Node</span> represents
  "<span class="code">.../T1, ..., Tn</span>", the result is
  <span class="code">[T1, ..., Tn]</span>, otherwise the result is the empty list.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary_field-2">binary_field/2</a></span>.</p>
</p></div>
<p><a name="binary_fields-1"><span class="bold_code">binary_fields(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="binary_fields-1"></a>

<p>Returns the list of field subtrees of a <span class="code">binary</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary-1">binary/1</a></span>, <span class="bold_code"><a href="#binary_field-2">binary_field/2</a></span>.</p>
</p></div>
<p><a name="binary_generator-2"><span class="bold_code">binary_generator(Pattern::syntaxTree(), Body::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="binary_generator-2"></a>

<p>Creates an abstract binary_generator. The result represents
  "<span class="code">Pattern &lt;- Body</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary_comp-2">binary_comp/2</a></span>, <span class="bold_code"><a href="#binary_generator_body-1">binary_generator_body/1</a></span>, <span class="bold_code"><a href="#binary_generator_pattern-1">binary_generator_pattern/1</a></span>, <span class="bold_code"><a href="#list_comp-2">list_comp/2</a></span>.</p>
</p></div>
<p><a name="binary_generator_body-1"><span class="bold_code">binary_generator_body(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="binary_generator_body-1"></a>

<p>Returns the body subtree of a <span class="code">generator</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary_generator-2">binary_generator/2</a></span>.</p>
</p></div>
<p><a name="binary_generator_pattern-1"><span class="bold_code">binary_generator_pattern(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="binary_generator_pattern-1"></a>

<p>Returns the pattern subtree of a <span class="code">generator</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary_generator-2">binary_generator/2</a></span>.</p>
</p></div>
<p><a name="block_expr-1"><span class="bold_code">block_expr(Body::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="block_expr-1"></a>

<p>Creates an abstract block expression. If <span class="code">Body</span> is
  <span class="code">[B1, ..., Bn]</span>, the result represents "<span class="code">begin
  B1, ..., Bn end</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#block_expr_body-1">block_expr_body/1</a></span>.</p>
</p></div>
<p><a name="block_expr_body-1"><span class="bold_code">block_expr_body(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="block_expr_body-1"></a>

<p>Returns the list of body subtrees of a <span class="code">block_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#block_expr-1">block_expr/1</a></span>.</p>
</p></div>
<p><a name="case_expr-2"><span class="bold_code">case_expr(Argument::syntaxTree(), Clauses::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="case_expr-2"></a>

<p>Creates an abstract case-expression. If <span class="code">Clauses</span> is
  <span class="code">[C1, ..., Cn]</span>, the result represents "<span class="code">case
  Argument of C1; ...; Cn end</span>". More
  exactly, if each <span class="code">Ci</span> represents "<span class="code">(Pi)
  Gi -&gt; Bi</span>", then the result represents
  "<span class="code">case Argument of P1 G1 -&gt;
  B1; ...; Pn Gn -&gt; Bn end</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#case_expr_argument-1">case_expr_argument/1</a></span>, <span class="bold_code"><a href="#case_expr_clauses-1">case_expr_clauses/1</a></span>, <span class="bold_code"><a href="#clause-3">clause/3</a></span>, <span class="bold_code"><a href="#cond_expr-1">cond_expr/1</a></span>, <span class="bold_code"><a href="#if_expr-1">if_expr/1</a></span>.</p>
</p></div>
<p><a name="case_expr_argument-1"><span class="bold_code">case_expr_argument(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="case_expr_argument-1"></a>

<p>Returns the argument subtree of a <span class="code">case_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#case_expr-2">case_expr/2</a></span>.</p>
</p></div>
<p><a name="case_expr_clauses-1"><span class="bold_code">case_expr_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="case_expr_clauses-1"></a>

<p>Returns the list of clause subtrees of a <span class="code">case_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#case_expr-2">case_expr/2</a></span>.</p>
</p></div>
<p><a name="catch_expr-1"><span class="bold_code">catch_expr(Expr::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="catch_expr-1"></a>

<p>Creates an abstract catch-expression. The result represents
  "<span class="code">catch Expr</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#catch_expr_body-1">catch_expr_body/1</a></span>.</p>
</p></div>
<p><a name="catch_expr_body-1"><span class="bold_code">catch_expr_body(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="catch_expr_body-1"></a>

<p>Returns the body subtree of a <span class="code">catch_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#catch_expr-1">catch_expr/1</a></span>.</p>
</p></div>
<p><a name="char-1"><span class="bold_code">char(Char::char()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="char-1"></a>

<p>Creates an abstract character literal. The result represents
  "<span class="code">$Name</span>", where <span class="code">Name</span> corresponds to
  <span class="code">Value</span>.</p>
 
  <p>Note: the literal corresponding to a particular character value is
  not uniquely defined. E.g., the character "<span class="code">a</span>" can be
  written both as "<span class="code">$a</span>" and "<span class="code">$\141</span>", and a Tab
  character can be written as "<span class="code">$\11</span>", "<span class="code">$\011</span>"
  or "<span class="code">$\t</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#char_literal-1">char_literal/1</a></span>, <span class="bold_code"><a href="#char_literal-2">char_literal/2</a></span>, <span class="bold_code"><a href="#char_value-1">char_value/1</a></span>, <span class="bold_code"><a href="#is_char-2">is_char/2</a></span>.</p>
</p></div>
<p><a name="char_literal-1"><span class="bold_code">char_literal(Node::syntaxTree()) -&gt; nonempty_string()</span></a><br></p>
<div class="REFBODY"><p><a name="char_literal-1"></a>

<p>Returns the literal string represented by a <span class="code">char</span>
  node. This includes the leading "<span class="code">$</span>" character.
  Characters beyond 255 will be escaped.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#char-1">char/1</a></span>.</p>
</p></div>
<p><a name="char_literal-2"><span class="bold_code">char_literal(Node::syntaxTree(), X2::encoding()) -&gt; nonempty_string()</span></a><br></p>
<div class="REFBODY"><p><a name="char_literal-2"></a>

<p>Returns the literal string represented by a <span class="code">char</span>
  node. This includes the leading "<span class="code">$</span>" character.
  Depending on the encoding a character beyond 255 will be escaped
  ('latin1') or copied as is ('utf8').
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#char-1">char/1</a></span>.</p>
</p></div>
<p><a name="char_value-1"><span class="bold_code">char_value(Node::syntaxTree()) -&gt; char()</span></a><br></p>
<div class="REFBODY"><p><a name="char_value-1"></a>

<p>Returns the value represented by a <span class="code">char</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#char-1">char/1</a></span>.</p>
</p></div>
<p><a name="class_qualifier-2"><span class="bold_code">class_qualifier(Class::syntaxTree(), Body::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="class_qualifier-2"></a>

<p>Creates an abstract class qualifier. The result represents
  "<span class="code">Class:Body</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#class_qualifier_argument-1">class_qualifier_argument/1</a></span>, <span class="bold_code"><a href="#class_qualifier_body-1">class_qualifier_body/1</a></span>, <span class="bold_code"><a href="#try_expr-4">try_expr/4</a></span>.</p>
</p></div>
<p><a name="class_qualifier_argument-1"><span class="bold_code">class_qualifier_argument(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="class_qualifier_argument-1"></a>

<p>Returns the argument (the class) subtree of a
  <span class="code">class_qualifier</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#class_qualifier-2">class_qualifier/2</a></span>.</p>
</p></div>
<p><a name="class_qualifier_body-1"><span class="bold_code">class_qualifier_body(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="class_qualifier_body-1"></a>

<p>Returns the body subtree of a <span class="code">class_qualifier</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#class_qualifier-2">class_qualifier/2</a></span>.</p>
</p></div>
<p><a name="clause-2"><span class="bold_code">clause(Guard::guard(), Body::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="clause-2"></a>
<p>Equivalent to <span class="bold_code"><a href="#clause-3">clause([], Guard, Body)</a></span>.</p>
</p></div>
<p><a name="clause-3"><span class="bold_code">clause(Patterns::[syntaxTree()], Guard::guard(), Body::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="clause-3"></a>

<p>Creates an abstract clause. If <span class="code">Patterns</span> is
  <span class="code">[P1, ..., Pn]</span> and <span class="code">Body</span> is <span class="code">[B1, ...,
  Bm]</span>, then if <span class="code">Guard</span> is <span class="code">none</span>, the
  result represents "<span class="code">(P1, ..., Pn) -&gt;
  B1, ..., Bm</span>", otherwise, unless
  <span class="code">Guard</span> is a list, the result represents
  "<span class="code">(P1, ..., Pn) when Guard -&gt;
  B1, ..., Bm</span>".</p>
 
  <p>For simplicity, the <span class="code">Guard</span> argument may also be any
  of the following:
  </p><ul>
    <li><p>An empty list <span class="code">[]</span>. This is equivalent to passing
        <span class="code">none</span>.</p></li>
    <li><p>A nonempty list <span class="code">[E1, ..., Ej]</span> of syntax trees.
        This is equivalent to passing <span class="code">conjunction([E1, ...,
        Ej])</span>.</p></li>
    <li><p>A nonempty list of lists of syntax trees <span class="code">[[E1_1, ...,
        E1_k1], ..., [Ej_1, ..., Ej_kj]]</span>, which is equivalent
        to passing <span class="code">disjunction([conjunction([E1_1, ...,
        E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])</span>.</p></li>
  </ul><p>
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#clause-2">clause/2</a></span>, <span class="bold_code"><a href="#clause_body-1">clause_body/1</a></span>, <span class="bold_code"><a href="#clause_guard-1">clause_guard/1</a></span>, <span class="bold_code"><a href="#clause_patterns-1">clause_patterns/1</a></span>.</p>
</p></div>
<p><a name="clause_body-1"><span class="bold_code">clause_body(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="clause_body-1"></a>

<p>Return the list of body subtrees of a <span class="code">clause</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#clause-3">clause/3</a></span>.</p>
</p></div>
<p><a name="clause_guard-1"><span class="bold_code">clause_guard(Node::syntaxTree()) -&gt; none | syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="clause_guard-1"></a>

<p>Returns the guard subtree of a <span class="code">clause</span> node, if
  any. If <span class="code">Node</span> represents "<span class="code">(P1, ...,
  Pn) when Guard -&gt; B1, ...,
  Bm</span>", <span class="code">Guard</span> is returned. Otherwise, the
  result is <span class="code">none</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#clause-3">clause/3</a></span>.</p>
</p></div>
<p><a name="clause_patterns-1"><span class="bold_code">clause_patterns(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="clause_patterns-1"></a>

<p>Returns the list of pattern subtrees of a <span class="code">clause</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#clause-3">clause/3</a></span>.</p>
</p></div>
<p><a name="comment-1"><span class="bold_code">comment(Strings::[string()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="comment-1"></a>
<p>Equivalent to <span class="bold_code"><a href="#comment-2">comment(none, Strings)</a></span>.</p>
</p></div>
<p><a name="comment-2"><span class="bold_code">comment(Pad::padding(), Strings::[string()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="comment-2"></a>

<p>Creates an abstract comment with the given padding and text. If
  <span class="code">Strings</span> is a (possibly empty) list
  <span class="code">["Txt1", ..., "TxtN"]</span>, the result
  represents the source code text
  </p><div class="example"><pre>
     %Txt1
     ...
     %TxtN</pre></div><p>
  <span class="code">Padding</span> states the number of empty character positions
  to the left of the comment separating it horizontally from
  source code on the same line (if any). If <span class="code">Padding</span> is
  <span class="code">none</span>, a default positive number is used. If
  <span class="code">Padding</span> is an integer less than 1, there should be no
  separating space. Comments are in themselves regarded as source
  program forms.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#comment-1">comment/1</a></span>, <span class="bold_code"><a href="#is_form-1">is_form/1</a></span>.</p>
</p></div>
<p><a name="comment_padding-1"><span class="bold_code">comment_padding(Node::syntaxTree()) -&gt; padding()</span></a><br></p>
<div class="REFBODY"><p><a name="comment_padding-1"></a>

<p>Returns the amount of padding before the comment, or
  <span class="code">none</span>. The latter means that a default padding may be used.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#comment-2">comment/2</a></span>.</p>
</p></div>
<p><a name="comment_text-1"><span class="bold_code">comment_text(Node::syntaxTree()) -&gt; [string()]</span></a><br></p>
<div class="REFBODY"><p><a name="comment_text-1"></a>

<p>Returns the lines of text of the abstract comment.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#comment-2">comment/2</a></span>.</p>
</p></div>
<p><a name="compact_list-1"><span class="bold_code">compact_list(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="compact_list-1"></a>

<p>Yields the most compact form for an abstract list skeleton. The
  result either represents "<span class="code">[E1, ..., En |
  Tail]</span>", where <span class="code">Tail</span> is not a list
  skeleton, or otherwise simply "<span class="code">[E1, ...,
  En]</span>". Annotations on subtrees of <span class="code">Node</span>
  that represent list skeletons may be lost, but comments will be
  propagated to the result. Returns <span class="code">Node</span> itself if
  <span class="code">Node</span> does not represent a list skeleton.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#list-2">list/2</a></span>, <span class="bold_code"><a href="#normalize_list-1">normalize_list/1</a></span>.</p>
</p></div>
<p><a name="concrete-1"><span class="bold_code">concrete(Node::syntaxTree()) -&gt; term()</span></a><br></p>
<div class="REFBODY"><p><a name="concrete-1"></a>

<p>Returns the Erlang term represented by a syntax tree. Evaluation
  fails with reason <span class="code">badarg</span> if <span class="code">Node</span> does not  
represent a literal term.</p>
 
  <p>Note: Currently, the set of syntax trees which have a concrete
  representation is larger than the set of trees which can be built
  using the function <span class="bold_code"><a href="#abstract-1">abstract/1</a></span>. An abstract character
  will be concretised as an integer, while <span class="bold_code"><a href="#abstract-1">abstract/1</a></span> does
  not at present yield an abstract character for any input. (Use the
  <span class="bold_code"><a href="#char-1">char/1</a></span> function to explicitly create an abstract
  character.)
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#abstract-1">abstract/1</a></span>, <span class="bold_code"><a href="#char-1">char/1</a></span>, <span class="bold_code"><a href="#is_literal-1">is_literal/1</a></span>.</p>
</p></div>
<p><a name="cond_expr-1"><span class="bold_code">cond_expr(Clauses::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="cond_expr-1"></a>

<p>Creates an abstract cond-expression. If <span class="code">Clauses</span> is
  <span class="code">[C1, ..., Cn]</span>, the result represents "<span class="code">cond
  C1; ...; Cn end</span>". More exactly, if each
  <span class="code">Ci</span> represents "<span class="code">() Ei -&gt;
  Bi</span>", then the result represents "<span class="code">cond
  E1 -&gt; B1; ...; En -&gt; Bn
  end</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#case_expr-2">case_expr/2</a></span>, <span class="bold_code"><a href="#clause-3">clause/3</a></span>, <span class="bold_code"><a href="#cond_expr_clauses-1">cond_expr_clauses/1</a></span>.</p>
</p></div>
<p><a name="cond_expr_clauses-1"><span class="bold_code">cond_expr_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="cond_expr_clauses-1"></a>

<p>Returns the list of clause subtrees of a <span class="code">cond_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#cond_expr-1">cond_expr/1</a></span>.</p>
</p></div>
<p><a name="conjunction-1"><span class="bold_code">conjunction(Tests::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="conjunction-1"></a>

<p>Creates an abstract conjunction. If <span class="code">List</span> is
  <span class="code">[E1, ..., En]</span>, the result represents
  "<span class="code">E1, ..., En</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#conjunction_body-1">conjunction_body/1</a></span>, <span class="bold_code"><a href="#disjunction-1">disjunction/1</a></span>.</p>
</p></div>
<p><a name="conjunction_body-1"><span class="bold_code">conjunction_body(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="conjunction_body-1"></a>

<p>Returns the list of body subtrees of a
  <span class="code">conjunction</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#conjunction-1">conjunction/1</a></span>.</p>
</p></div>
<p><a name="cons-2"><span class="bold_code">cons(Head::syntaxTree(), Tail::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="cons-2"></a>

<p>"Optimising" list skeleton cons operation. Creates an abstract
  list skeleton whose first element is <span class="code">Head</span> and whose tail
  corresponds to <span class="code">Tail</span>. This is similar to
  <span class="code">list([Head], Tail)</span>, except that <span class="code">Tail</span> may
  not be <span class="code">none</span>, and that the result does not necessarily
  represent exactly "<span class="code">[Head | Tail]</span>", but
  may depend on the <span class="code">Tail</span> subtree. E.g., if
  <span class="code">Tail</span> represents <span class="code">[X, Y]</span>, the result may
  represent "<span class="code">[Head, X, Y]</span>", rather than
  "<span class="code">[Head | [X, Y]]</span>". Annotations on
  <span class="code">Tail</span> itself may be lost if <span class="code">Tail</span> represents
  a list skeleton, but comments on <span class="code">Tail</span> are propagated to
  the result.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#list-2">list/2</a></span>, <span class="bold_code"><a href="#list_head-1">list_head/1</a></span>, <span class="bold_code"><a href="#list_tail-1">list_tail/1</a></span>.</p>
</p></div>
<p><a name="copy_ann-2"><span class="bold_code">copy_ann(Source::syntaxTree(), Target::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="copy_ann-2"></a>

<p>Copies the list of user annotations from <span class="code">Source</span> to <span class="code">Target</span>.</p>
 
  <p>Note: this is equivalent to <span class="code">set_ann(Target,
  get_ann(Source))</span>, but potentially more efficient.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#get_ann-1">get_ann/1</a></span>, <span class="bold_code"><a href="#set_ann-2">set_ann/2</a></span>.</p>
</p></div>
<p><a name="copy_attrs-2"><span class="bold_code">copy_attrs(S::syntaxTree(), T::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="copy_attrs-2"></a>

<p>Copies the attributes from <span class="code">Source</span> to <span class="code">Target</span>.</p>
 
  <p>Note: this is equivalent to <span class="code">set_attrs(Target,
  get_attrs(Source))</span>, but potentially more efficient.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#get_attrs-1">get_attrs/1</a></span>, <span class="bold_code"><a href="#set_attrs-2">set_attrs/2</a></span>.</p>
</p></div>
<p><a name="copy_comments-2"><span class="bold_code">copy_comments(Source::syntaxTree(), Target::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="copy_comments-2"></a>

<p>Copies the pre- and postcomments from <span class="code">Source</span> to <span class="code">Target</span>.</p>
 
  <p>Note: This is equivalent to
  <span class="code">set_postcomments(set_precomments(Target,
  get_precomments(Source)), get_postcomments(Source))</span>, but
  potentially more efficient.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#comment-2">comment/2</a></span>, <span class="bold_code"><a href="#get_postcomments-1">get_postcomments/1</a></span>, <span class="bold_code"><a href="#get_precomments-1">get_precomments/1</a></span>, <span class="bold_code"><a href="#set_postcomments-2">set_postcomments/2</a></span>, <span class="bold_code"><a href="#set_precomments-2">set_precomments/2</a></span>.</p>
</p></div>
<p><a name="copy_pos-2"><span class="bold_code">copy_pos(Source::syntaxTree(), Target::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="copy_pos-2"></a>

<p>Copies the position information from <span class="code">Source</span> to <span class="code">Target</span>.</p>
 
  <p>This is equivalent to <span class="code">set_pos(Target,
  get_pos(Source))</span>, but potentially more efficient.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#get_pos-1">get_pos/1</a></span>, <span class="bold_code"><a href="#set_pos-2">set_pos/2</a></span>.</p>
</p></div>
<p><a name="data-1"><span class="bold_code">data(Tree::syntaxTree()) -&gt; term()</span></a><br></p>
<div class="REFBODY"><p><a name="data-1"></a>

<p><strong>For special purposes only</strong>. Returns the associated data
  of a syntax tree node. Evaluation fails with reason
  <span class="code">badarg</span> if <span class="code">is_tree(Node)</span> does not yield
  <span class="code">true</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#tree-2">tree/2</a></span>.</p>
</p></div>
<p><a name="disjunction-1"><span class="bold_code">disjunction(Tests::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="disjunction-1"></a>

<p>Creates an abstract disjunction. If <span class="code">List</span> is
  <span class="code">[E1, ..., En]</span>, the result represents
  "<span class="code">E1; ...; En</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#conjunction-1">conjunction/1</a></span>, <span class="bold_code"><a href="#disjunction_body-1">disjunction_body/1</a></span>.</p>
</p></div>
<p><a name="disjunction_body-1"><span class="bold_code">disjunction_body(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="disjunction_body-1"></a>

<p>Returns the list of body subtrees of a
  <span class="code">disjunction</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#disjunction-1">disjunction/1</a></span>.</p>
</p></div>
<p><a name="eof_marker-0"><span class="bold_code">eof_marker() -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="eof_marker-0"></a>

<p>Creates an abstract end-of-file marker. This represents the  
end of input when reading a sequence of source code forms. An  
end-of-file marker is itself regarded as a source code form  
(namely, the last in any sequence in which it occurs). It has no  
defined lexical form.</p>
 
  <p>Note: this is retained only for backwards compatibility with
  existing parsers and tools.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#error_marker-1">error_marker/1</a></span>, <span class="bold_code"><a href="#is_form-1">is_form/1</a></span>, <span class="bold_code"><a href="#warning_marker-1">warning_marker/1</a></span>.</p>
</p></div>
<p><a name="error_marker-1"><span class="bold_code">error_marker(Error::term()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="error_marker-1"></a>

<p>Creates an abstract error marker. The result represents an
  occurrence of an error in the source code, with an associated Erlang
  I/O ErrorInfo structure given by <span class="code">Error</span> (see module
  <span class="bold_code"><a href="io.html">io(3)</a></span> for details). Error markers are regarded as source  
code forms, but have no defined lexical form.</p>
 
  <p>Note: this is supported only for backwards compatibility with
  existing parsers and tools.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#eof_marker-0">eof_marker/0</a></span>, <span class="bold_code"><a href="#error_marker_info-1">error_marker_info/1</a></span>, <span class="bold_code"><a href="#is_form-1">is_form/1</a></span>, <span class="bold_code"><a href="#warning_marker-1">warning_marker/1</a></span>.</p>
</p></div>
<p><a name="error_marker_info-1"><span class="bold_code">error_marker_info(Node::syntaxTree()) -&gt; term()</span></a><br></p>
<div class="REFBODY"><p><a name="error_marker_info-1"></a>

<p>Returns the ErrorInfo structure of an <span class="code">error_marker</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#error_marker-1">error_marker/1</a></span>.</p>
</p></div>
<p><a name="flatten_form_list-1"><span class="bold_code">flatten_form_list(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="flatten_form_list-1"></a>

<p>Flattens sublists of a <span class="code">form_list</span> node. Returns
  <span class="code">Node</span> with all subtrees of type <span class="code">form_list</span>
  recursively expanded, yielding a single "flat" abstract form
  sequence.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#form_list-1">form_list/1</a></span>.</p>
</p></div>
<p><a name="float-1"><span class="bold_code">float(Value::float()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="float-1"></a>

<p>Creates an abstract floating-point literal. The lexical
  representation is the decimal floating-point numeral of <span class="code">Value</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#float_literal-1">float_literal/1</a></span>, <span class="bold_code"><a href="#float_value-1">float_value/1</a></span>.</p>
</p></div>
<p><a name="float_literal-1"><span class="bold_code">float_literal(Node::syntaxTree()) -&gt; string()</span></a><br></p>
<div class="REFBODY"><p><a name="float_literal-1"></a>

<p>Returns the numeral string represented by a <span class="code">float</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#float-1">float/1</a></span>.</p>
</p></div>
<p><a name="float_value-1"><span class="bold_code">float_value(Node::syntaxTree()) -&gt; float()</span></a><br></p>
<div class="REFBODY"><p><a name="float_value-1"></a>

<p>Returns the value represented by a <span class="code">float</span> node. Note
  that floating-point values should usually not be compared for
  equality.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#float-1">float/1</a></span>.</p>
</p></div>
<p><a name="form_list-1"><span class="bold_code">form_list(Forms::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="form_list-1"></a>

<p>Creates an abstract sequence of "source code forms". If
  <span class="code">Forms</span> is <span class="code">[F1, ..., Fn]</span>, where each
  <span class="code">Fi</span> is a form (see <span class="bold_code"><a href="#is_form-1">is_form/1</a></span>, the result
  represents
  </p><div class="example"><pre>
     F1
     ...
     Fn</pre></div><p>
  where the <span class="code">Fi</span> are separated by one or more line breaks. A
  node of type <span class="code">form_list</span> is itself regarded as a source
  code form; see <span class="bold_code"><a href="#flatten_form_list-1">flatten_form_list/1</a></span>.</p>
 
  <p>Note: this is simply a way of grouping source code forms as a
  single syntax tree, usually in order to form an Erlang module
  definition.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#flatten_form_list-1">flatten_form_list/1</a></span>, <span class="bold_code"><a href="#form_list_elements-1">form_list_elements/1</a></span>, <span class="bold_code"><a href="#is_form-1">is_form/1</a></span>.</p>
</p></div>
<p><a name="form_list_elements-1"><span class="bold_code">form_list_elements(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="form_list_elements-1"></a>

<p>Returns the list of subnodes of a <span class="code">form_list</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#form_list-1">form_list/1</a></span>.</p>
</p></div>
<p><a name="fun_expr-1"><span class="bold_code">fun_expr(Clauses::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="fun_expr-1"></a>

<p>Creates an abstract fun-expression. If <span class="code">Clauses</span> is
  <span class="code">[C1, ..., Cn]</span>, the result represents "<span class="code">fun
  C1; ...; Cn end</span>". More exactly, if each
  <span class="code">Ci</span> represents "<span class="code">(Pi1, ..., Pim)
  Gi -&gt; Bi</span>", then the result represents
  "<span class="code">fun (P11, ..., P1m) G1 -&gt;
  B1; ...; (Pn1, ..., Pnm) Gn -&gt;
  Bn end</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#fun_expr_arity-1">fun_expr_arity/1</a></span>, <span class="bold_code"><a href="#fun_expr_clauses-1">fun_expr_clauses/1</a></span>.</p>
</p></div>
<p><a name="fun_expr_arity-1"><span class="bold_code">fun_expr_arity(Node::syntaxTree()) -&gt; arity()</span></a><br></p>
<div class="REFBODY"><p><a name="fun_expr_arity-1"></a>

<p>Returns the arity of a <span class="code">fun_expr</span> node. The result is  
the number of parameter patterns in the first clause of the  
fun-expression; subsequent clauses are ignored.</p>
 
  <p>An exception is thrown if <span class="code">fun_expr_clauses(Node)</span>
  returns an empty list, or if the first element of that list is not a
  syntax tree <span class="code">C</span> of type <span class="code">clause</span> such that
  <span class="code">clause_patterns(C)</span> is a nonempty list.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#clause-3">clause/3</a></span>, <span class="bold_code"><a href="#clause_patterns-1">clause_patterns/1</a></span>, <span class="bold_code"><a href="#fun_expr-1">fun_expr/1</a></span>, <span class="bold_code"><a href="#fun_expr_clauses-1">fun_expr_clauses/1</a></span>.</p>
</p></div>
<p><a name="fun_expr_clauses-1"><span class="bold_code">fun_expr_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="fun_expr_clauses-1"></a>

<p>Returns the list of clause subtrees of a <span class="code">fun_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#fun_expr-1">fun_expr/1</a></span>.</p>
</p></div>
<p><a name="function-2"><span class="bold_code">function(Name::syntaxTree(), Clauses::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="function-2"></a>

<p>Creates an abstract function definition. If <span class="code">Clauses</span>
  is <span class="code">[C1, ..., Cn]</span>, the result represents
  "<span class="code">Name C1; ...; Name
  Cn.</span>". More exactly, if each <span class="code">Ci</span>
  represents "<span class="code">(Pi1, ..., Pim) Gi -&gt;
  Bi</span>", then the result represents
  "<span class="code">Name(P11, ..., P1m) G1 -&gt;
  B1; ...; Name(Pn1, ..., Pnm)
  Gn -&gt; Bn.</span>". Function definitions are source
  code forms.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#function_arity-1">function_arity/1</a></span>, <span class="bold_code"><a href="#function_clauses-1">function_clauses/1</a></span>, <span class="bold_code"><a href="#function_name-1">function_name/1</a></span>, <span class="bold_code"><a href="#is_form-1">is_form/1</a></span>, <span class="bold_code"><a href="#rule-2">rule/2</a></span>.</p>
</p></div>
<p><a name="function_arity-1"><span class="bold_code">function_arity(Node::syntaxTree()) -&gt; arity()</span></a><br></p>
<div class="REFBODY"><p><a name="function_arity-1"></a>

<p>Returns the arity of a <span class="code">function</span> node. The result  
is the number of parameter patterns in the first clause of the  
function; subsequent clauses are ignored.</p>
 
  <p>An exception is thrown if <span class="code">function_clauses(Node)</span>
  returns an empty list, or if the first element of that list is not
  a syntax tree <span class="code">C</span> of type <span class="code">clause</span> such that
  <span class="code">clause_patterns(C)</span> is a nonempty list.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#clause-3">clause/3</a></span>, <span class="bold_code"><a href="#clause_patterns-1">clause_patterns/1</a></span>, <span class="bold_code"><a href="#function-2">function/2</a></span>, <span class="bold_code"><a href="#function_clauses-1">function_clauses/1</a></span>.</p>
</p></div>
<p><a name="function_clauses-1"><span class="bold_code">function_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="function_clauses-1"></a>

<p>Returns the list of clause subtrees of a <span class="code">function</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#function-2">function/2</a></span>.</p>
</p></div>
<p><a name="function_name-1"><span class="bold_code">function_name(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="function_name-1"></a>

<p>Returns the name subtree of a <span class="code">function</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#function-2">function/2</a></span>.</p>
</p></div>
<p><a name="generator-2"><span class="bold_code">generator(Pattern::syntaxTree(), Body::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="generator-2"></a>

<p>Creates an abstract generator. The result represents
  "<span class="code">Pattern &lt;- Body</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#binary_comp-2">binary_comp/2</a></span>, <span class="bold_code"><a href="#generator_body-1">generator_body/1</a></span>, <span class="bold_code"><a href="#generator_pattern-1">generator_pattern/1</a></span>, <span class="bold_code"><a href="#list_comp-2">list_comp/2</a></span>.</p>
</p></div>
<p><a name="generator_body-1"><span class="bold_code">generator_body(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="generator_body-1"></a>

<p>Returns the body subtree of a <span class="code">generator</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#generator-2">generator/2</a></span>.</p>
</p></div>
<p><a name="generator_pattern-1"><span class="bold_code">generator_pattern(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="generator_pattern-1"></a>

<p>Returns the pattern subtree of a <span class="code">generator</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#generator-2">generator/2</a></span>.</p>
</p></div>
<p><a name="get_ann-1"><span class="bold_code">get_ann(Tree::syntaxTree()) -&gt; [term()]</span></a><br></p>
<div class="REFBODY"><p><a name="get_ann-1"></a>

<p>Returns the list of user annotations associated with a syntax
  tree node. For a newly created node, this is the empty list. The
  annotations may be any terms.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#get_attrs-1">get_attrs/1</a></span>, <span class="bold_code"><a href="#set_ann-2">set_ann/2</a></span>.</p>
</p></div>
<p><a name="get_attrs-1"><span class="bold_code">get_attrs(Tree::syntaxTree()) -&gt; syntaxTreeAttributes()</span></a><br></p>
<div class="REFBODY"><p><a name="get_attrs-1"></a>

<p>Returns a representation of the attributes associated with a
  syntax tree node. The attributes are all the extra information that
  can be attached to a node. Currently, this includes position
  information, source code comments, and user annotations. The result
  of this function cannot be inspected directly; only attached to
  another node (see <span class="bold_code"><a href="#set_attrs-2">set_attrs/2</a></span>).</p>
 
  <p>For accessing individual attributes, see <span class="bold_code"><a href="#get_pos-1">get_pos/1</a></span>,
  <span class="bold_code"><a href="#get_ann-1">get_ann/1</a></span>, <span class="bold_code"><a href="#get_precomments-1">get_precomments/1</a></span> and
  <span class="bold_code"><a href="#get_postcomments-1">get_postcomments/1</a></span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#get_ann-1">get_ann/1</a></span>, <span class="bold_code"><a href="#get_pos-1">get_pos/1</a></span>, <span class="bold_code"><a href="#get_postcomments-1">get_postcomments/1</a></span>, <span class="bold_code"><a href="#get_precomments-1">get_precomments/1</a></span>, <span class="bold_code"><a href="#set_attrs-2">set_attrs/2</a></span>.</p>
</p></div>
<p><a name="get_pos-1"><span class="bold_code">get_pos(Tree::syntaxTree()) -&gt; term()</span></a><br></p>
<div class="REFBODY"><p><a name="get_pos-1"></a>

<p>Returns the position information associated with
  <span class="code">Node</span>. This is usually a nonnegative integer (indicating
  the source code line number), but may be any term. By default, all
  new tree nodes have their associated position information set to the
  integer zero.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#get_attrs-1">get_attrs/1</a></span>, <span class="bold_code"><a href="#set_pos-2">set_pos/2</a></span>.</p>
</p></div>
<p><a name="get_postcomments-1"><span class="bold_code">get_postcomments(Tree::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="get_postcomments-1"></a>

<p>Returns the associated post-comments of a node. This is a
  possibly empty list of abstract comments, in top-down textual order.
  When the code is formatted, post-comments are typically displayed to
  the right of and/or below the node. For example:
  </p><div class="example"><pre>     {foo, X, Y}     % Post-comment of tuple</pre></div><p>
 
  If possible, the comment should be moved past any following
  separator characters on the same line, rather than placing the
  separators on the following line. E.g.:
  </p><div class="example"><pre>     foo([X | Xs], Y) -&gt;
         foo(Xs, bar(X));     % Post-comment of 'bar(X)' node
      ...</pre></div><p>
  (where the comment is moved past the rightmost "<span class="code">)</span>" and
  the "<span class="code">;</span>").
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#comment-2">comment/2</a></span>, <span class="bold_code"><a href="#get_attrs-1">get_attrs/1</a></span>, <span class="bold_code"><a href="#get_precomments-1">get_precomments/1</a></span>, <span class="bold_code"><a href="#set_postcomments-2">set_postcomments/2</a></span>.</p>
</p></div>
<p><a name="get_precomments-1"><span class="bold_code">get_precomments(Tree::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="get_precomments-1"></a>

<p>Returns the associated pre-comments of a node. This is a
  possibly empty list of abstract comments, in top-down textual order.
  When the code is formatted, pre-comments are typically displayed
  directly above the node. For example:
  </p><div class="example"><pre>     % Pre-comment of function
     foo(X) -&gt; {bar, X}.</pre></div><p>
 
  If possible, the comment should be moved before any preceding
  separator characters on the same line. E.g.:
  </p><div class="example"><pre>     foo([X | Xs]) -&gt;
         % Pre-comment of 'bar(X)' node
         [bar(X) | foo(Xs)];
     ...</pre></div><p>
  (where the comment is moved before the "<span class="code">[</span>").
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#comment-2">comment/2</a></span>, <span class="bold_code"><a href="#get_attrs-1">get_attrs/1</a></span>, <span class="bold_code"><a href="#get_postcomments-1">get_postcomments/1</a></span>, <span class="bold_code"><a href="#set_precomments-2">set_precomments/2</a></span>.</p>
</p></div>
<p><a name="has_comments-1"><span class="bold_code">has_comments(Tree::syntaxTree()) -&gt; boolean()</span></a><br></p>
<div class="REFBODY"><p><a name="has_comments-1"></a>

<p>Yields <span class="code">false</span> if the node has no associated
  comments, and <span class="code">true</span> otherwise.</p>
 
  <p>Note: This is equivalent to <span class="code">(get_precomments(Node) == [])
  and (get_postcomments(Node) == [])</span>, but potentially more
  efficient.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#get_postcomments-1">get_postcomments/1</a></span>, <span class="bold_code"><a href="#get_precomments-1">get_precomments/1</a></span>, <span class="bold_code"><a href="#remove_comments-1">remove_comments/1</a></span>.</p>
</p></div>
<p><a name="if_expr-1"><span class="bold_code">if_expr(Clauses::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="if_expr-1"></a>

<p>Creates an abstract if-expression. If <span class="code">Clauses</span> is
  <span class="code">[C1, ..., Cn]</span>, the result represents "<span class="code">if
  C1; ...; Cn end</span>". More exactly, if each
  <span class="code">Ci</span> represents "<span class="code">() Gi -&gt;
  Bi</span>", then the result represents "<span class="code">if
  G1 -&gt; B1; ...; Gn -&gt; Bn
  end</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#case_expr-2">case_expr/2</a></span>, <span class="bold_code"><a href="#clause-3">clause/3</a></span>, <span class="bold_code"><a href="#if_expr_clauses-1">if_expr_clauses/1</a></span>.</p>
</p></div>
<p><a name="if_expr_clauses-1"><span class="bold_code">if_expr_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="if_expr_clauses-1"></a>

<p>Returns the list of clause subtrees of an <span class="code">if_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#if_expr-1">if_expr/1</a></span>.</p>
</p></div>
<p><a name="implicit_fun-1"><span class="bold_code">implicit_fun(Name::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="implicit_fun-1"></a>

<p>Creates an abstract "implicit fun" expression. The result
  represents "<span class="code">fun Name</span>". <span class="code">Name</span> should
  represent either <span class="code">F/A</span> or
  <span class="code">M:F/A</span>
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#arity_qualifier-2">arity_qualifier/2</a></span>, <span class="bold_code"><a href="#implicit_fun-2">implicit_fun/2</a></span>, <span class="bold_code"><a href="#implicit_fun-3">implicit_fun/3</a></span>, <span class="bold_code"><a href="#implicit_fun_name-1">implicit_fun_name/1</a></span>, <span class="bold_code"><a href="#module_qualifier-2">module_qualifier/2</a></span>.</p>
</p></div>
<p><a name="implicit_fun-2"><span class="bold_code">implicit_fun(Name::syntaxTree(), Arity::none | syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="implicit_fun-2"></a>

<p>Creates an abstract "implicit fun" expression. If
  <span class="code">Arity</span> is <span class="code">none</span>, this is equivalent to
  <span class="code">implicit_fun(Name)</span>, otherwise it is equivalent to
  <span class="code">implicit_fun(arity_qualifier(Name, Arity))</span>.</p>
 
  <p>(This is a utility function.)
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#implicit_fun-1">implicit_fun/1</a></span>, <span class="bold_code"><a href="#implicit_fun-3">implicit_fun/3</a></span>.</p>
</p></div>
<p><a name="implicit_fun-3"><span class="bold_code">implicit_fun(Module::none | syntaxTree(), Name::syntaxTree(), Arity::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="implicit_fun-3"></a>

<p>Creates an abstract module-qualified "implicit fun" expression.
  If <span class="code">Module</span> is <span class="code">none</span>, this is equivalent to
  <span class="code">implicit_fun(Name, Arity)</span>, otherwise it is equivalent to
  <span class="code">implicit_fun(module_qualifier(Module, arity_qualifier(Name,
  Arity))</span>.</p>
 
  <p>(This is a utility function.)
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#implicit_fun-1">implicit_fun/1</a></span>, <span class="bold_code"><a href="#implicit_fun-2">implicit_fun/2</a></span>.</p>
</p></div>
<p><a name="implicit_fun_name-1"><span class="bold_code">implicit_fun_name(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="implicit_fun_name-1"></a>

<p>Returns the name subtree of an <span class="code">implicit_fun</span> node.</p>
 
  <p>Note: if <span class="code">Node</span> represents "<span class="code">fun
  N/A</span>" or "<span class="code">fun
  M:N/A</span>", then the result is the
  subtree representing "<span class="code">N/A</span>" or
  "<span class="code">M:N/A</span>", respectively.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#arity_qualifier-2">arity_qualifier/2</a></span>, <span class="bold_code"><a href="#implicit_fun-1">implicit_fun/1</a></span>, <span class="bold_code"><a href="#module_qualifier-2">module_qualifier/2</a></span>.</p>
</p></div>
<p><a name="infix_expr-3"><span class="bold_code">infix_expr(Left::syntaxTree(), Operator::syntaxTree(), Right::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="infix_expr-3"></a>

<p>Creates an abstract infix operator expression. The result
  represents "<span class="code">Left Operator
  Right</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#infix_expr_left-1">infix_expr_left/1</a></span>, <span class="bold_code"><a href="#infix_expr_operator-1">infix_expr_operator/1</a></span>, <span class="bold_code"><a href="#infix_expr_right-1">infix_expr_right/1</a></span>, <span class="bold_code"><a href="#prefix_expr-2">prefix_expr/2</a></span>.</p>
</p></div>
<p><a name="infix_expr_left-1"><span class="bold_code">infix_expr_left(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="infix_expr_left-1"></a>

<p>Returns the left argument subtree of an
  <span class="code">infix_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#infix_expr-3">infix_expr/3</a></span>.</p>
</p></div>
<p><a name="infix_expr_operator-1"><span class="bold_code">infix_expr_operator(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="infix_expr_operator-1"></a>

<p>Returns the operator subtree of an <span class="code">infix_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#infix_expr-3">infix_expr/3</a></span>.</p>
</p></div>
<p><a name="infix_expr_right-1"><span class="bold_code">infix_expr_right(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="infix_expr_right-1"></a>

<p>Returns the right argument subtree of an
  <span class="code">infix_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#infix_expr-3">infix_expr/3</a></span>.</p>
</p></div>
<p><a name="integer-1"><span class="bold_code">integer(Value::integer()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="integer-1"></a>

<p>Creates an abstract integer literal. The lexical representation
  is the canonical decimal numeral of <span class="code">Value</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#integer_literal-1">integer_literal/1</a></span>, <span class="bold_code"><a href="#integer_value-1">integer_value/1</a></span>, <span class="bold_code"><a href="#is_integer-2">is_integer/2</a></span>.</p>
</p></div>
<p><a name="integer_literal-1"><span class="bold_code">integer_literal(Node::syntaxTree()) -&gt; string()</span></a><br></p>
<div class="REFBODY"><p><a name="integer_literal-1"></a>

<p>Returns the numeral string represented by an <span class="code">integer</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#integer-1">integer/1</a></span>.</p>
</p></div>
<p><a name="integer_value-1"><span class="bold_code">integer_value(Node::syntaxTree()) -&gt; integer()</span></a><br></p>
<div class="REFBODY"><p><a name="integer_value-1"></a>

<p>Returns the value represented by an <span class="code">integer</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#integer-1">integer/1</a></span>.</p>
</p></div>
<p><a name="is_atom-2"><span class="bold_code">is_atom(Node::syntaxTree(), Value::atom()) -&gt; boolean()</span></a><br></p>
<div class="REFBODY"><p><a name="is_atom-2"></a>

<p>Returns <span class="code">true</span> if <span class="code">Node</span> has type
  <span class="code">atom</span> and represents <span class="code">Value</span>, otherwise <span class="code">false</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#atom-1">atom/1</a></span>.</p>
</p></div>
<p><a name="is_char-2"><span class="bold_code">is_char(Node::syntaxTree(), Value::char()) -&gt; boolean()</span></a><br></p>
<div class="REFBODY"><p><a name="is_char-2"></a>

<p>Returns <span class="code">true</span> if <span class="code">Node</span> has type
  <span class="code">char</span> and represents <span class="code">Value</span>, otherwise <span class="code">false</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#char-1">char/1</a></span>.</p>
</p></div>
<p><a name="is_form-1"><span class="bold_code">is_form(Node::syntaxTree()) -&gt; boolean()</span></a><br></p>
<div class="REFBODY"><p><a name="is_form-1"></a>

<p>Returns <span class="code">true</span> if <span class="code">Node</span> is a syntax tree
  representing a so-called "source code form", otherwise
  <span class="code">false</span>. Forms are the Erlang source code units which,  
placed in sequence, constitute an Erlang program. Current form types  
are:</p>
 
  <p>
   
    <span class="code">attribute</span>
    <span class="code">comment</span>
    <span class="code">error_marker</span>
    <span class="code">eof_marker</span>
    <span class="code">form_list</span>
   <br>
    <span class="code">function</span>
    <span class="code">rule</span>
    <span class="code">warning_marker</span>
    <span class="code">text</span>
   <br>
  
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#attribute-2">attribute/2</a></span>, <span class="bold_code"><a href="#comment-2">comment/2</a></span>, <span class="bold_code"><a href="#eof_marker-0">eof_marker/0</a></span>, <span class="bold_code"><a href="#error_marker-1">error_marker/1</a></span>, <span class="bold_code"><a href="#form_list-1">form_list/1</a></span>, <span class="bold_code"><a href="#function-2">function/2</a></span>, <span class="bold_code"><a href="#rule-2">rule/2</a></span>, <span class="bold_code"><a href="#type-1">type/1</a></span>, <span class="bold_code"><a href="#warning_marker-1">warning_marker/1</a></span>.</p>
</p></div>
<p><a name="is_integer-2"><span class="bold_code">is_integer(Node::syntaxTree(), Value::integer()) -&gt; boolean()</span></a><br></p>
<div class="REFBODY"><p><a name="is_integer-2"></a>

<p>Returns <span class="code">true</span> if <span class="code">Node</span> has type
  <span class="code">integer</span> and represents <span class="code">Value</span>, otherwise <span class="code">false</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#integer-1">integer/1</a></span>.</p>
</p></div>
<p><a name="is_leaf-1"><span class="bold_code">is_leaf(Node::syntaxTree()) -&gt; boolean()</span></a><br></p>
<div class="REFBODY"><p><a name="is_leaf-1"></a>

<p>Returns <span class="code">true</span> if <span class="code">Node</span> is a leaf node,
  otherwise <span class="code">false</span>. The currently recognised leaf node  
types are:</p>
 
  <p>
   
    <span class="code">atom</span>
    <span class="code">char</span>
    <span class="code">comment</span>
    <span class="code">eof_marker</span>
    <span class="code">error_marker</span>
   <br>
    <span class="code">float</span>
    <span class="code">integer</span>
    <span class="code">nil</span>
    <span class="code">operator</span>
    <span class="code">string</span>
   <br>
    <span class="code">text</span>
    <span class="code">underscore</span>
    <span class="code">variable</span>
    <span class="code">warning_marker</span>
   <br>
  </p>
 
  <p>A node of type <span class="code">tuple</span> is a leaf node if and only if its arity is zero.</p>
 
  <p>Note: not all literals are leaf nodes, and vice versa. E.g.,
  tuples with nonzero arity and nonempty lists may be literals, but are
  not leaf nodes. Variables, on the other hand, are leaf nodes but not
  literals.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#is_literal-1">is_literal/1</a></span>, <span class="bold_code"><a href="#type-1">type/1</a></span>.</p>
</p></div>
<p><a name="is_list_skeleton-1"><span class="bold_code">is_list_skeleton(Node::syntaxTree()) -&gt; boolean()</span></a><br></p>
<div class="REFBODY"><p><a name="is_list_skeleton-1"></a>

<p>Returns <span class="code">true</span> if <span class="code">Node</span> has type
  <span class="code">list</span> or <span class="code">nil</span>, otherwise <span class="code">false</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#list-2">list/2</a></span>, <span class="bold_code"><a href="#nil-0">nil/0</a></span>.</p>
</p></div>
<p><a name="is_literal-1"><span class="bold_code">is_literal(T::syntaxTree()) -&gt; boolean()</span></a><br></p>
<div class="REFBODY"><p><a name="is_literal-1"></a>

<p>Returns <span class="code">true</span> if <span class="code">Node</span> represents a
  literal term, otherwise <span class="code">false</span>. This function returns
  <span class="code">true</span> if and only if the value of
  <span class="code">concrete(Node)</span> is defined.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#abstract-1">abstract/1</a></span>, <span class="bold_code"><a href="#concrete-1">concrete/1</a></span>.</p>
</p></div>
<p><a name="is_proper_list-1"><span class="bold_code">is_proper_list(Node::syntaxTree()) -&gt; boolean()</span></a><br></p>
<div class="REFBODY"><p><a name="is_proper_list-1"></a>

<p>Returns <span class="code">true</span> if <span class="code">Node</span> represents a
  proper list, and <span class="code">false</span> otherwise. A proper list is a
  list skeleton either on the form "<span class="code">[]</span>" or
  "<span class="code">[E1, ..., En]</span>", or "<span class="code">[... |
  Tail]</span>" where recursively <span class="code">Tail</span> also  
represents a proper list.</p>
 
  <p>Note: Since <span class="code">Node</span> is a syntax tree, the actual
  run-time values corresponding to its subtrees may often be partially
  or completely unknown. Thus, if <span class="code">Node</span> represents e.g.
  "<span class="code">[... | Ns]</span>" (where <span class="code">Ns</span> is a variable), then
  the function will return <span class="code">false</span>, because it is not known
  whether <span class="code">Ns</span> will be bound to a list at run-time. If
  <span class="code">Node</span> instead represents e.g. "<span class="code">[1, 2, 3]</span>" or
  "<span class="code">[A | []]</span>", then the function will return
  <span class="code">true</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#list-2">list/2</a></span>.</p>
</p></div>
<p><a name="is_string-2"><span class="bold_code">is_string(Node::syntaxTree(), Value::string()) -&gt; boolean()</span></a><br></p>
<div class="REFBODY"><p><a name="is_string-2"></a>

<p>Returns <span class="code">true</span> if <span class="code">Node</span> has type
  <span class="code">string</span> and represents <span class="code">Value</span>, otherwise <span class="code">false</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#string-1">string/1</a></span>.</p>
</p></div>
<p><a name="is_tree-1"><span class="bold_code">is_tree(Tree::syntaxTree()) -&gt; boolean()</span></a><br></p>
<div class="REFBODY"><p><a name="is_tree-1"></a>

<p><strong>For special purposes only</strong>. Returns <span class="code">true</span> if
  <span class="code">Tree</span> is an abstract syntax tree and <span class="code">false</span>  
otherwise.</p>
 
  <p><strong>Note</strong>: this function yields <span class="code">false</span> for all
  "old-style" <span class="code">erl_parse</span>-compatible "parse trees".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#tree-2">tree/2</a></span>.</p>
</p></div>
<p><a name="join_comments-2"><span class="bold_code">join_comments(Source::syntaxTree(), Target::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="join_comments-2"></a>

<p>Appends the comments of <span class="code">Source</span> to the current
  comments of <span class="code">Target</span>.</p>
 
  <p>Note: This is equivalent to
  <span class="code">add_postcomments(get_postcomments(Source),
  add_precomments(get_precomments(Source), Target))</span>, but
  potentially more efficient.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#add_postcomments-2">add_postcomments/2</a></span>, <span class="bold_code"><a href="#add_precomments-2">add_precomments/2</a></span>, <span class="bold_code"><a href="#comment-2">comment/2</a></span>, <span class="bold_code"><a href="#get_postcomments-1">get_postcomments/1</a></span>, <span class="bold_code"><a href="#get_precomments-1">get_precomments/1</a></span>.</p>
</p></div>
<p><a name="list-1"><span class="bold_code">list(List::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="list-1"></a>
<p>Equivalent to <span class="bold_code"><a href="#list-2">list(List, none)</a></span>.</p>
</p></div>
<p><a name="list-2"><span class="bold_code">list(Elements::[syntaxTree()], Tail::none | syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="list-2"></a>

<p>Constructs an abstract list skeleton. The result has type
  <span class="code">list</span> or <span class="code">nil</span>. If <span class="code">List</span> is a
  nonempty list <span class="code">[E1, ..., En]</span>, the result has type
  <span class="code">list</span> and represents either "<span class="code">[E1, ...,
  En]</span>", if <span class="code">Tail</span> is <span class="code">none</span>, or
  otherwise "<span class="code">[E1, ..., En |
  Tail]</span>". If <span class="code">List</span> is the empty list,
  <span class="code">Tail</span> <strong>must</strong> be <span class="code">none</span>, and in that
  case the result has type <span class="code">nil</span> and represents
  "<span class="code">[]</span>" (see <span class="bold_code"><a href="#nil-0">nil/0</a></span>).</p>
 
  <p>The difference between lists as semantic objects (built up of  
individual "cons" and "nil" terms) and the various syntactic forms  
for denoting lists may be bewildering at first. This module provides  
functions both for exact control of the syntactic representation as  
well as for the simple composition and deconstruction in terms of  
cons and head/tail operations.</p>
 
  <p>Note: in <span class="code">list(Elements, none)</span>, the "nil" list
  terminator is implicit and has no associated information (see
  <span class="bold_code"><a href="#get_attrs-1">get_attrs/1</a></span>), while in the seemingly equivalent
  <span class="code">list(Elements, Tail)</span> when <span class="code">Tail</span> has type
  <span class="code">nil</span>, the list terminator subtree <span class="code">Tail</span> may
  have attached attributes such as position, comments, and annotations,
  which will be preserved in the result.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#compact_list-1">compact_list/1</a></span>, <span class="bold_code"><a href="#cons-2">cons/2</a></span>, <span class="bold_code"><a href="#get_attrs-1">get_attrs/1</a></span>, <span class="bold_code"><a href="#is_list_skeleton-1">is_list_skeleton/1</a></span>, <span class="bold_code"><a href="#is_proper_list-1">is_proper_list/1</a></span>, <span class="bold_code"><a href="#list-1">list/1</a></span>, <span class="bold_code"><a href="#list_elements-1">list_elements/1</a></span>, <span class="bold_code"><a href="#list_head-1">list_head/1</a></span>, <span class="bold_code"><a href="#list_length-1">list_length/1</a></span>, <span class="bold_code"><a href="#list_prefix-1">list_prefix/1</a></span>, <span class="bold_code"><a href="#list_suffix-1">list_suffix/1</a></span>, <span class="bold_code"><a href="#list_tail-1">list_tail/1</a></span>, <span class="bold_code"><a href="#nil-0">nil/0</a></span>, <span class="bold_code"><a href="#normalize_list-1">normalize_list/1</a></span>.</p>
</p></div>
<p><a name="list_comp-2"><span class="bold_code">list_comp(Template::syntaxTree(), Body::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="list_comp-2"></a>

<p>Creates an abstract list comprehension. If <span class="code">Body</span> is
  <span class="code">[E1, ..., En]</span>, the result represents
  "<span class="code">[Template || E1, ..., En]</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#generator-2">generator/2</a></span>, <span class="bold_code"><a href="#list_comp_body-1">list_comp_body/1</a></span>, <span class="bold_code"><a href="#list_comp_template-1">list_comp_template/1</a></span>.</p>
</p></div>
<p><a name="list_comp_body-1"><span class="bold_code">list_comp_body(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="list_comp_body-1"></a>

<p>Returns the list of body subtrees of a <span class="code">list_comp</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#list_comp-2">list_comp/2</a></span>.</p>
</p></div>
<p><a name="list_comp_template-1"><span class="bold_code">list_comp_template(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="list_comp_template-1"></a>

<p>Returns the template subtree of a <span class="code">list_comp</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#list_comp-2">list_comp/2</a></span>.</p>
</p></div>
<p><a name="list_elements-1"><span class="bold_code">list_elements(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="list_elements-1"></a>

<p>Returns the list of element subtrees of a list skeleton.
  <span class="code">Node</span> must represent a proper list. E.g., if
  <span class="code">Node</span> represents "<span class="code">[X1, X2 |
  [X3, X4 | []]</span>", then
  <span class="code">list_elements(Node)</span> yields the list <span class="code">[X1, X2, X3, X4]</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#is_proper_list-1">is_proper_list/1</a></span>, <span class="bold_code"><a href="#list-2">list/2</a></span>.</p>
</p></div>
<p><a name="list_head-1"><span class="bold_code">list_head(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="list_head-1"></a>

<p>Returns the head element subtree of a <span class="code">list</span> node. If
  <span class="code">Node</span> represents "<span class="code">[Head ...]</span>", the
  result will represent "<span class="code">Head</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#cons-2">cons/2</a></span>, <span class="bold_code"><a href="#list-2">list/2</a></span>, <span class="bold_code"><a href="#list_tail-1">list_tail/1</a></span>.</p>
</p></div>
<p><a name="list_length-1"><span class="bold_code">list_length(Node::syntaxTree()) -&gt; non_neg_integer()</span></a><br></p>
<div class="REFBODY"><p><a name="list_length-1"></a>

<p>Returns the number of element subtrees of a list skeleton.
  <span class="code">Node</span> must represent a proper list. E.g., if
  <span class="code">Node</span> represents "<span class="code">[X1 | [X2, X3 | [X4, X5,
  X6]]]</span>", then <span class="code">list_length(Node)</span> returns the  
integer 6.</p>
 
  <p>Note: this is equivalent to
  <span class="code">length(list_elements(Node))</span>, but potentially more
  efficient.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#is_proper_list-1">is_proper_list/1</a></span>, <span class="bold_code"><a href="#list-2">list/2</a></span>, <span class="bold_code"><a href="#list_elements-1">list_elements/1</a></span>.</p>
</p></div>
<p><a name="list_prefix-1"><span class="bold_code">list_prefix(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="list_prefix-1"></a>

<p>Returns the prefix element subtrees of a <span class="code">list</span> node.
  If <span class="code">Node</span> represents "<span class="code">[E1, ...,
  En]</span>" or "<span class="code">[E1, ..., En |
  Tail]</span>", the returned value is <span class="code">[E1, ...,
  En]</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#list-2">list/2</a></span>.</p>
</p></div>
<p><a name="list_suffix-1"><span class="bold_code">list_suffix(Node::syntaxTree()) -&gt; none | syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="list_suffix-1"></a>

<p>Returns the suffix subtree of a <span class="code">list</span> node, if one
  exists. If <span class="code">Node</span> represents "<span class="code">[E1, ...,
  En | Tail]</span>", the returned value is
  <span class="code">Tail</span>, otherwise, i.e., if <span class="code">Node</span> represents
  "<span class="code">[E1, ..., En]</span>", <span class="code">none</span> is  
returned.</p>
 
  <p>Note that even if this function returns some <span class="code">Tail</span>
  that is not <span class="code">none</span>, the type of <span class="code">Tail</span> can be
  <span class="code">nil</span>, if the tail has been given explicitly, and the list
  skeleton has not been compacted (see <span class="bold_code"><a href="#compact_list-1">compact_list/1</a></span>).
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#compact_list-1">compact_list/1</a></span>, <span class="bold_code"><a href="#list-2">list/2</a></span>, <span class="bold_code"><a href="#nil-0">nil/0</a></span>.</p>
</p></div>
<p><a name="list_tail-1"><span class="bold_code">list_tail(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="list_tail-1"></a>

<p>Returns the tail of a <span class="code">list</span> node. If
  <span class="code">Node</span> represents a single-element list
  "<span class="code">[E]</span>", then the result has type
  <span class="code">nil</span>, representing "<span class="code">[]</span>". If
  <span class="code">Node</span> represents "<span class="code">[E1, E2
  ...]</span>", the result will represent "<span class="code">[E2
  ...]</span>", and if <span class="code">Node</span> represents
  "<span class="code">[Head | Tail]</span>", the result will
  represent "<span class="code">Tail</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#cons-2">cons/2</a></span>, <span class="bold_code"><a href="#list-2">list/2</a></span>, <span class="bold_code"><a href="#list_head-1">list_head/1</a></span>.</p>
</p></div>
<p><a name="macro-1"><span class="bold_code">macro(Name::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="macro-1"></a>
<p>Equivalent to <span class="bold_code"><a href="#macro-2">macro(Name, none)</a></span>.</p>
</p></div>
<p><a name="macro-2"><span class="bold_code">macro(Name::syntaxTree(), Arguments::none | [syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="macro-2"></a>

<p>Creates an abstract macro application. If <span class="code">Arguments</span>
  is <span class="code">none</span>, the result represents
  "<span class="code">?Name</span>", otherwise, if <span class="code">Arguments</span>
  is <span class="code">[A1, ..., An]</span>, the result represents
  "<span class="code">?Name(A1, ..., An)</span>".</p>
 
  <p>Notes: if <span class="code">Arguments</span> is the empty list, the result
  will thus represent "<span class="code">?Name()</span>", including a pair  
of matching parentheses.</p>
 
  <p>The only syntactical limitation imposed by the preprocessor on the
  arguments to a macro application (viewed as sequences of tokens) is
  that they must be balanced with respect to parentheses, brackets,
  <span class="code">begin ... end</span>, <span class="code">case ... end</span>, etc. The
  <span class="code">text</span> node type can be used to represent arguments which
  are not regular Erlang constructs.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#macro-1">macro/1</a></span>, <span class="bold_code"><a href="#macro_arguments-1">macro_arguments/1</a></span>, <span class="bold_code"><a href="#macro_name-1">macro_name/1</a></span>, <span class="bold_code"><a href="#text-1">text/1</a></span>.</p>
</p></div>
<p><a name="macro_arguments-1"><span class="bold_code">macro_arguments(Node::syntaxTree()) -&gt; none | [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="macro_arguments-1"></a>

<p>Returns the list of argument subtrees of a <span class="code">macro</span>
  node, if any. If <span class="code">Node</span> represents
  "<span class="code">?Name</span>", <span class="code">none</span> is returned.
  Otherwise, if <span class="code">Node</span> represents
  "<span class="code">?Name(A1, ..., An)</span>",
  <span class="code">[A1, ..., An]</span> is returned.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#macro-2">macro/2</a></span>.</p>
</p></div>
<p><a name="macro_name-1"><span class="bold_code">macro_name(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="macro_name-1"></a>

<p>Returns the name subtree of a <span class="code">macro</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#macro-2">macro/2</a></span>.</p>
</p></div>
<p><a name="make_tree-2"><span class="bold_code">make_tree(X1::atom(), X2::[[syntaxTree()]]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="make_tree-2"></a>

<p>Creates a syntax tree with the given type and subtrees.
  <span class="code">Type</span> must be a node type name (see <span class="bold_code"><a href="#type-1">type/1</a></span>)
  that does not denote a leaf node type (see <span class="bold_code"><a href="#is_leaf-1">is_leaf/1</a></span>).
  <span class="code">Groups</span> must be a <strong>nonempty</strong> list of groups of
  syntax trees, representing the subtrees of a node of the given type,
  in left-to-right order as they would occur in the printed program
  text, grouped by category as done by <span class="bold_code"><a href="#subtrees-1">subtrees/1</a></span>.</p>
 
  <p>The result of <span class="code">copy_attrs(Node, make_tree(type(Node),
  subtrees(Node)))</span> (see <span class="bold_code"><a href="#update_tree-2">update_tree/2</a></span>) represents
  the same source code text as the original <span class="code">Node</span>, assuming
  that <span class="code">subtrees(Node)</span> yields a nonempty list. However, it
  does not necessarily have the same data representation as
  <span class="code">Node</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#copy_attrs-2">copy_attrs/2</a></span>, <span class="bold_code"><a href="#is_leaf-1">is_leaf/1</a></span>, <span class="bold_code"><a href="#subtrees-1">subtrees/1</a></span>, <span class="bold_code"><a href="#type-1">type/1</a></span>, <span class="bold_code"><a href="#update_tree-2">update_tree/2</a></span>.</p>
</p></div>
<p><a name="map_expr-1"><span class="bold_code">map_expr(Fields::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="map_expr-1"></a>
<p>Equivalent to <span class="bold_code"><a href="#map_expr-2">map_expr(none, Fields)</a></span>.</p>
</p></div>
<p><a name="map_expr-2"><span class="bold_code">map_expr(Argument::none | syntaxTree(), Fields::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="map_expr-2"></a>

<p>Creates an abstract map expression. If <span class="code">Fields</span> is
  <span class="code">[F1, ..., Fn]</span>, then if <span class="code">Argument</span> is <span class="code">none</span>, the result represents
  "<span class="code">#{F1, ..., Fn}</span>",
  otherwise it represents
  "<span class="code">Argument#{F1, ..., Fn}</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#map_expr-1">map_expr/1</a></span>, <span class="bold_code"><a href="#map_expr_argument-1">map_expr_argument/1</a></span>, <span class="bold_code"><a href="#map_expr_fields-1">map_expr_fields/1</a></span>, <span class="bold_code"><a href="#map_field_assoc-2">map_field_assoc/2</a></span>, <span class="bold_code"><a href="#map_field_exact-2">map_field_exact/2</a></span>.</p>
</p></div>
<p><a name="map_expr_argument-1"><span class="bold_code">map_expr_argument(Node::syntaxTree()) -&gt; none | syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="map_expr_argument-1"></a>

<p>Returns the argument subtree of a <span class="code">map_expr</span> node, if any. If <span class="code">Node</span>
  represents "<span class="code">#{...}</span>", <span class="code">none</span> is returned.
  Otherwise, if <span class="code">Node</span> represents "<span class="code">Argument#{...}</span>",
  <span class="code">Argument</span> is returned.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#map_expr-2">map_expr/2</a></span>.</p>
</p></div>
<p><a name="map_expr_fields-1"><span class="bold_code">map_expr_fields(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="map_expr_fields-1"></a>

<p>Returns the list of field subtrees of a <span class="code">map_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#map_expr-2">map_expr/2</a></span>.</p>
</p></div>
<p><a name="map_field_assoc-2"><span class="bold_code">map_field_assoc(Name::syntaxTree(), Value::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="map_field_assoc-2"></a>

<p>Creates an abstract map assoc field. The result represents
  "<span class="code">Name =&gt; Value</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#map_expr-2">map_expr/2</a></span>, <span class="bold_code"><a href="#map_field_assoc_name-1">map_field_assoc_name/1</a></span>, <span class="bold_code"><a href="#map_field_assoc_value-1">map_field_assoc_value/1</a></span>.</p>
</p></div>
<p><a name="map_field_assoc_name-1"><span class="bold_code">map_field_assoc_name(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="map_field_assoc_name-1"></a>

<p>Returns the name subtree of a <span class="code">map_field_assoc</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#map_field_assoc-2">map_field_assoc/2</a></span>.</p>
</p></div>
<p><a name="map_field_assoc_value-1"><span class="bold_code">map_field_assoc_value(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="map_field_assoc_value-1"></a>

<p>Returns the value subtree of a <span class="code">map_field_assoc</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#map_field_assoc-2">map_field_assoc/2</a></span>.</p>
</p></div>
<p><a name="map_field_exact-2"><span class="bold_code">map_field_exact(Name::syntaxTree(), Value::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="map_field_exact-2"></a>

<p>Creates an abstract map exact field. The result represents
  "<span class="code">Name := Value</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#map_expr-2">map_expr/2</a></span>, <span class="bold_code"><a href="#map_field_exact_name-1">map_field_exact_name/1</a></span>, <span class="bold_code"><a href="#map_field_exact_value-1">map_field_exact_value/1</a></span>.</p>
</p></div>
<p><a name="map_field_exact_name-1"><span class="bold_code">map_field_exact_name(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="map_field_exact_name-1"></a>

<p>Returns the name subtree of a <span class="code">map_field_exact</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#map_field_exact-2">map_field_exact/2</a></span>.</p>
</p></div>
<p><a name="map_field_exact_value-1"><span class="bold_code">map_field_exact_value(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="map_field_exact_value-1"></a>

<p>Returns the value subtree of a <span class="code">map_field_exact</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#map_field_exact-2">map_field_exact/2</a></span>.</p>
</p></div>
<p><a name="match_expr-2"><span class="bold_code">match_expr(Pattern::syntaxTree(), Body::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="match_expr-2"></a>

<p>Creates an abstract match-expression. The result represents
  "<span class="code">Pattern = Body</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#match_expr_body-1">match_expr_body/1</a></span>, <span class="bold_code"><a href="#match_expr_pattern-1">match_expr_pattern/1</a></span>.</p>
</p></div>
<p><a name="match_expr_body-1"><span class="bold_code">match_expr_body(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="match_expr_body-1"></a>

<p>Returns the body subtree of a <span class="code">match_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#match_expr-2">match_expr/2</a></span>.</p>
</p></div>
<p><a name="match_expr_pattern-1"><span class="bold_code">match_expr_pattern(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="match_expr_pattern-1"></a>

<p>Returns the pattern subtree of a <span class="code">match_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#match_expr-2">match_expr/2</a></span>.</p>
</p></div>
<p><a name="meta-1"><span class="bold_code">meta(T::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="meta-1"></a>

<p>Creates a meta-representation of a syntax tree. The result
  represents an Erlang expression "<span class="code">MetaTree</span>"
  which, if evaluated, will yield a new syntax tree representing the
  same source code text as <span class="code">Tree</span> (although the actual data
  representation may be different). The expression represented by
  <span class="code">MetaTree</span> is <strong>implementation independent</strong> with
  regard to the data structures used by the abstract syntax tree
  implementation. Comments attached to nodes of <span class="code">Tree</span> will  
be preserved, but other attributes are lost.</p>
 
  <p>Any node in <span class="code">Tree</span> whose node type is
  <span class="code">variable</span> (see <span class="bold_code"><a href="#type-1">type/1</a></span>), and whose list of
  annotations (see <span class="bold_code"><a href="#get_ann-1">get_ann/1</a></span>) contains the atom
  <span class="code">meta_var</span>, will remain unchanged in the resulting tree,
  except that exactly one occurrence of <span class="code">meta_var</span> is  
removed from its annotation list.</p>
 
  <p>The main use of the function <span class="code">meta/1</span> is to transform a
  data structure <span class="code">Tree</span>, which represents a piece of program
  code, into a form that is <strong>representation independent when
  printed</strong>. E.g., suppose <span class="code">Tree</span> represents a variable
  named "V". Then (assuming a function <span class="code">print/1</span> for
  printing syntax trees), evaluating <span class="code">print(abstract(Tree))</span>
  - simply using <span class="bold_code"><a href="#abstract-1">abstract/1</a></span> to map the actual data
  structure onto a syntax tree representation - would output a string
  that might look something like "<span class="code">{tree, variable, ..., "V",
  ...}</span>", which is obviously dependent on the implementation of
  the abstract syntax trees. This could e.g. be useful for caching a
  syntax tree in a file. However, in some situations like in a program
  generator generator (with two "generator"), it may be unacceptable.
  Using <span class="code">print(meta(Tree))</span> instead would output a
  <strong>representation independent</strong> syntax tree generating
  expression; in the above case, something like
  "<span class="code">erl_syntax:variable("V")</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#abstract-1">abstract/1</a></span>, <span class="bold_code"><a href="#get_ann-1">get_ann/1</a></span>, <span class="bold_code"><a href="#type-1">type/1</a></span>.</p>
</p></div>
<p><a name="module_qualifier-2"><span class="bold_code">module_qualifier(Module::syntaxTree(), Body::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="module_qualifier-2"></a>

<p>Creates an abstract module qualifier. The result represents
  "<span class="code">Module:Body</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#module_qualifier_argument-1">module_qualifier_argument/1</a></span>, <span class="bold_code"><a href="#module_qualifier_body-1">module_qualifier_body/1</a></span>.</p>
</p></div>
<p><a name="module_qualifier_argument-1"><span class="bold_code">module_qualifier_argument(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="module_qualifier_argument-1"></a>

<p>Returns the argument (the module) subtree of a
  <span class="code">module_qualifier</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#module_qualifier-2">module_qualifier/2</a></span>.</p>
</p></div>
<p><a name="module_qualifier_body-1"><span class="bold_code">module_qualifier_body(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="module_qualifier_body-1"></a>

<p>Returns the body subtree of a <span class="code">module_qualifier</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#module_qualifier-2">module_qualifier/2</a></span>.</p>
</p></div>
<p><a name="named_fun_expr-2"><span class="bold_code">named_fun_expr(Name::syntaxTree(), Clauses::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="named_fun_expr-2"></a>

<p>Creates an abstract named fun-expression. If <span class="code">Clauses</span> is
  <span class="code">[C1, ..., Cn]</span>, the result represents "<span class="code">fun
  Name C1; ...; Name Cn end</span>".
  More exactly, if each <span class="code">Ci</span> represents
  "<span class="code">(Pi1, ..., Pim) Gi -&gt; Bi</span>",
  then the result represents
  "<span class="code">fun Name(P11, ..., P1m) G1 -&gt;
  B1; ...; Name(Pn1, ..., Pnm)
  Gn -&gt; Bn end</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#named_fun_expr_arity-1">named_fun_expr_arity/1</a></span>, <span class="bold_code"><a href="#named_fun_expr_clauses-1">named_fun_expr_clauses/1</a></span>, <span class="bold_code"><a href="#named_fun_expr_name-1">named_fun_expr_name/1</a></span>.</p>
</p></div>
<p><a name="named_fun_expr_arity-1"><span class="bold_code">named_fun_expr_arity(Node::syntaxTree()) -&gt; arity()</span></a><br></p>
<div class="REFBODY"><p><a name="named_fun_expr_arity-1"></a>

<p>Returns the arity of a <span class="code">named_fun_expr</span> node. The result is  
the number of parameter patterns in the first clause of the  
named fun-expression; subsequent clauses are ignored.</p>
 
  <p>An exception is thrown if <span class="code">named_fun_expr_clauses(Node)</span>
  returns an empty list, or if the first element of that list is not a
  syntax tree <span class="code">C</span> of type <span class="code">clause</span> such that
  <span class="code">clause_patterns(C)</span> is a nonempty list.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#clause-3">clause/3</a></span>, <span class="bold_code"><a href="#clause_patterns-1">clause_patterns/1</a></span>, <span class="bold_code"><a href="#named_fun_expr-2">named_fun_expr/2</a></span>, <span class="bold_code"><a href="#named_fun_expr_clauses-1">named_fun_expr_clauses/1</a></span>.</p>
</p></div>
<p><a name="named_fun_expr_clauses-1"><span class="bold_code">named_fun_expr_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="named_fun_expr_clauses-1"></a>

<p>Returns the list of clause subtrees of a <span class="code">named_fun_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#named_fun_expr-2">named_fun_expr/2</a></span>.</p>
</p></div>
<p><a name="named_fun_expr_name-1"><span class="bold_code">named_fun_expr_name(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="named_fun_expr_name-1"></a>

<p>Returns the name subtree of a <span class="code">named_fun_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#named_fun_expr-2">named_fun_expr/2</a></span>.</p>
</p></div>
<p><a name="nil-0"><span class="bold_code">nil() -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="nil-0"></a>

<p>Creates an abstract empty list. The result represents
  "<span class="code">[]</span>". The empty list is traditionally called "nil".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#is_list_skeleton-1">is_list_skeleton/1</a></span>, <span class="bold_code"><a href="#list-2">list/2</a></span>.</p>
</p></div>
<p><a name="normalize_list-1"><span class="bold_code">normalize_list(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="normalize_list-1"></a>

<p>Expands an abstract list skeleton to its most explicit form. If
  <span class="code">Node</span> represents "<span class="code">[E1, ..., En |
  Tail]</span>", the result represents "<span class="code">[E1 |
  ... [En | Tail1] ... ]</span>", where
  <span class="code">Tail1</span> is the result of
  <span class="code">normalize_list(Tail)</span>. If <span class="code">Node</span> represents
  "<span class="code">[E1, ..., En]</span>", the result simply
  represents "<span class="code">[E1 | ... [En | []] ...
  ]</span>". If <span class="code">Node</span> does not represent a list skeleton,
  <span class="code">Node</span> itself is returned.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#compact_list-1">compact_list/1</a></span>, <span class="bold_code"><a href="#list-2">list/2</a></span>.</p>
</p></div>
<p><a name="operator-1"><span class="bold_code">operator(Name::atom() | string()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="operator-1"></a>

<p>Creates an abstract operator. The name of the operator is the
  character sequence represented by <span class="code">Name</span>. This is
  analogous to the print name of an atom, but an operator is never
  written within single-quotes; e.g., the result of
  <span class="code">operator(</span>++')' represents "<span class="code">++</span>" rather
  than "`++''".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#atom-1">atom/1</a></span>, <span class="bold_code"><a href="#operator_literal-1">operator_literal/1</a></span>, <span class="bold_code"><a href="#operator_name-1">operator_name/1</a></span>.</p>
</p></div>
<p><a name="operator_literal-1"><span class="bold_code">operator_literal(Node::syntaxTree()) -&gt; string()</span></a><br></p>
<div class="REFBODY"><p><a name="operator_literal-1"></a>

<p>Returns the literal string represented by an
  <span class="code">operator</span> node. This is simply the operator name as a string.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#operator-1">operator/1</a></span>.</p>
</p></div>
<p><a name="operator_name-1"><span class="bold_code">operator_name(Node::syntaxTree()) -&gt; atom()</span></a><br></p>
<div class="REFBODY"><p><a name="operator_name-1"></a>

<p>Returns the name of an <span class="code">operator</span> node. Note that
  the name is returned as an atom.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#operator-1">operator/1</a></span>.</p>
</p></div>
<p><a name="parentheses-1"><span class="bold_code">parentheses(Expr::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="parentheses-1"></a>

<p>Creates an abstract parenthesised expression. The result
  represents "<span class="code">(Body)</span>", independently of the
  context.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#parentheses_body-1">parentheses_body/1</a></span>.</p>
</p></div>
<p><a name="parentheses_body-1"><span class="bold_code">parentheses_body(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="parentheses_body-1"></a>

<p>Returns the body subtree of a <span class="code">parentheses</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#parentheses-1">parentheses/1</a></span>.</p>
</p></div>
<p><a name="prefix_expr-2"><span class="bold_code">prefix_expr(Operator::syntaxTree(), Argument::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="prefix_expr-2"></a>

<p>Creates an abstract prefix operator expression. The result
  represents "<span class="code">Operator Argument</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#infix_expr-3">infix_expr/3</a></span>, <span class="bold_code"><a href="#prefix_expr_argument-1">prefix_expr_argument/1</a></span>, <span class="bold_code"><a href="#prefix_expr_operator-1">prefix_expr_operator/1</a></span>.</p>
</p></div>
<p><a name="prefix_expr_argument-1"><span class="bold_code">prefix_expr_argument(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="prefix_expr_argument-1"></a>

<p>Returns the argument subtree of a <span class="code">prefix_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#prefix_expr-2">prefix_expr/2</a></span>.</p>
</p></div>
<p><a name="prefix_expr_operator-1"><span class="bold_code">prefix_expr_operator(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="prefix_expr_operator-1"></a>

<p>Returns the operator subtree of a <span class="code">prefix_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#prefix_expr-2">prefix_expr/2</a></span>.</p>
</p></div>
<p><a name="receive_expr-1"><span class="bold_code">receive_expr(Clauses::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="receive_expr-1"></a>
<p>Equivalent to <span class="bold_code"><a href="#receive_expr-3">receive_expr(Clauses, none, [])</a></span>.</p>
</p></div>
<p><a name="receive_expr-3"><span class="bold_code">receive_expr(Clauses::[syntaxTree()], Timeout::none | syntaxTree(), Action::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="receive_expr-3"></a>

<p>Creates an abstract receive-expression. If <span class="code">Timeout</span>
  is <span class="code">none</span>, the result represents "<span class="code">receive
  C1; ...; Cn end</span>" (the <span class="code">Action</span>
  argument is ignored). Otherwise, if <span class="code">Clauses</span> is
  <span class="code">[C1, ..., Cn]</span> and <span class="code">Action</span> is <span class="code">[A1, ...,
  Am]</span>, the result represents "<span class="code">receive C1; ...;
  Cn after Timeout -&gt; A1, ..., Am
  end</span>". More exactly, if each <span class="code">Ci</span> represents
  "<span class="code">(Pi) Gi -&gt; Bi</span>", then the
  result represents "<span class="code">receive P1 G1 -&gt;
  B1; ...; Pn Gn -&gt; Bn ...
  end</span>".</p>
 
  <p>Note that in Erlang, a receive-expression must have at least one
  clause if no timeout part is specified.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#case_expr-2">case_expr/2</a></span>, <span class="bold_code"><a href="#clause-3">clause/3</a></span>, <span class="bold_code"><a href="#receive_expr-1">receive_expr/1</a></span>, <span class="bold_code"><a href="#receive_expr_action-1">receive_expr_action/1</a></span>, <span class="bold_code"><a href="#receive_expr_clauses-1">receive_expr_clauses/1</a></span>, <span class="bold_code"><a href="#receive_expr_timeout-1">receive_expr_timeout/1</a></span>.</p>
</p></div>
<p><a name="receive_expr_action-1"><span class="bold_code">receive_expr_action(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="receive_expr_action-1"></a>

<p>Returns the list of action body subtrees of a
  <span class="code">receive_expr</span> node. If <span class="code">Node</span> represents
  "<span class="code">receive C1; ...; Cn end</span>", this is the
  empty list.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#receive_expr-3">receive_expr/3</a></span>.</p>
</p></div>
<p><a name="receive_expr_clauses-1"><span class="bold_code">receive_expr_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="receive_expr_clauses-1"></a>

<p>Returns the list of clause subtrees of a
  <span class="code">receive_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#receive_expr-3">receive_expr/3</a></span>.</p>
</p></div>
<p><a name="receive_expr_timeout-1"><span class="bold_code">receive_expr_timeout(Node::syntaxTree()) -&gt; none | syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="receive_expr_timeout-1"></a>

<p>Returns the timeout subtree of a <span class="code">receive_expr</span> node,
  if any. If <span class="code">Node</span> represents "<span class="code">receive C1;
  ...; Cn end</span>", <span class="code">none</span> is returned.
  Otherwise, if <span class="code">Node</span> represents "<span class="code">receive
  C1; ...; Cn after Timeout -&gt; ... end</span>",
  <span class="code">Timeout</span> is returned.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#receive_expr-3">receive_expr/3</a></span>.</p>
</p></div>
<p><a name="record_access-2"><span class="bold_code">record_access(Argument::syntaxTree(), Field::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_access-2"></a>
<p>Equivalent to <span class="bold_code"><a href="#record_access-3">record_access(Argument, none, Field)</a></span>.</p>
</p></div>
<p><a name="record_access-3"><span class="bold_code">record_access(Argument::syntaxTree(), Type::none | syntaxTree(), Field::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_access-3"></a>

<p>Creates an abstract record field access expression. If
  <span class="code">Type</span> is not <span class="code">none</span>, the result represents
  "<span class="code">Argument#Type.Field</span>".</p>
 
  <p>If <span class="code">Type</span> is <span class="code">none</span>, the result represents
  "<span class="code">Argument.Field</span>". This is a special
  form only allowed within Mnemosyne queries.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_access-2">record_access/2</a></span>, <span class="bold_code"><a href="#record_access_argument-1">record_access_argument/1</a></span>, <span class="bold_code"><a href="#record_access_field-1">record_access_field/1</a></span>, <span class="bold_code"><a href="#record_access_type-1">record_access_type/1</a></span>, <span class="bold_code"><a href="#record_expr-3">record_expr/3</a></span>.</p>
</p></div>
<p><a name="record_access_argument-1"><span class="bold_code">record_access_argument(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_access_argument-1"></a>

<p>Returns the argument subtree of a <span class="code">record_access</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_access-3">record_access/3</a></span>.</p>
</p></div>
<p><a name="record_access_field-1"><span class="bold_code">record_access_field(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_access_field-1"></a>

<p>Returns the field subtree of a <span class="code">record_access</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_access-3">record_access/3</a></span>.</p>
</p></div>
<p><a name="record_access_type-1"><span class="bold_code">record_access_type(Node::syntaxTree()) -&gt; none | syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_access_type-1"></a>

<p>Returns the type subtree of a <span class="code">record_access</span> node,
  if any. If <span class="code">Node</span> represents
  "<span class="code">Argument.Field</span>", <span class="code">none</span>
  is returned, otherwise if <span class="code">Node</span> represents
  "<span class="code">Argument#Type.Field</span>",
  <span class="code">Type</span> is returned.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_access-3">record_access/3</a></span>.</p>
</p></div>
<p><a name="record_expr-2"><span class="bold_code">record_expr(Type::syntaxTree(), Fields::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_expr-2"></a>
<p>Equivalent to <span class="bold_code"><a href="#record_expr-3">record_expr(none, Type, Fields)</a></span>.</p>
</p></div>
<p><a name="record_expr-3"><span class="bold_code">record_expr(Argument::none | syntaxTree(), Type::syntaxTree(), Fields::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_expr-3"></a>

<p>Creates an abstract record expression. If <span class="code">Fields</span> is
  <span class="code">[F1, ..., Fn]</span>, then if <span class="code">Argument</span> is
  <span class="code">none</span>, the result represents
  "<span class="code">#Type{F1, ..., Fn}</span>",
  otherwise it represents
  "<span class="code">Argument#Type{F1, ...,
  Fn}</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_access-3">record_access/3</a></span>, <span class="bold_code"><a href="#record_expr-2">record_expr/2</a></span>, <span class="bold_code"><a href="#record_expr_argument-1">record_expr_argument/1</a></span>, <span class="bold_code"><a href="#record_expr_fields-1">record_expr_fields/1</a></span>, <span class="bold_code"><a href="#record_expr_type-1">record_expr_type/1</a></span>, <span class="bold_code"><a href="#record_field-2">record_field/2</a></span>, <span class="bold_code"><a href="#record_index_expr-2">record_index_expr/2</a></span>.</p>
</p></div>
<p><a name="record_expr_argument-1"><span class="bold_code">record_expr_argument(Node::syntaxTree()) -&gt; none | syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_expr_argument-1"></a>

<p>Returns the argument subtree of a <span class="code">record_expr</span> node,
  if any. If <span class="code">Node</span> represents
  "<span class="code">#Type{...}</span>", <span class="code">none</span> is returned.
  Otherwise, if <span class="code">Node</span> represents
  "<span class="code">Argument#Type{...}</span>",
  <span class="code">Argument</span> is returned.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_expr-3">record_expr/3</a></span>.</p>
</p></div>
<p><a name="record_expr_fields-1"><span class="bold_code">record_expr_fields(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="record_expr_fields-1"></a>

<p>Returns the list of field subtrees of a
  <span class="code">record_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_expr-3">record_expr/3</a></span>.</p>
</p></div>
<p><a name="record_expr_type-1"><span class="bold_code">record_expr_type(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_expr_type-1"></a>

<p>Returns the type subtree of a <span class="code">record_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_expr-3">record_expr/3</a></span>.</p>
</p></div>
<p><a name="record_field-1"><span class="bold_code">record_field(Name::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_field-1"></a>
<p>Equivalent to <span class="bold_code"><a href="#record_field-2">record_field(Name, none)</a></span>.</p>
</p></div>
<p><a name="record_field-2"><span class="bold_code">record_field(Name::syntaxTree(), Value::none | syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_field-2"></a>

<p>Creates an abstract record field specification. If
  <span class="code">Value</span> is <span class="code">none</span>, the result represents
  simply "<span class="code">Name</span>", otherwise it represents
  "<span class="code">Name = Value</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_expr-3">record_expr/3</a></span>, <span class="bold_code"><a href="#record_field_name-1">record_field_name/1</a></span>, <span class="bold_code"><a href="#record_field_value-1">record_field_value/1</a></span>.</p>
</p></div>
<p><a name="record_field_name-1"><span class="bold_code">record_field_name(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_field_name-1"></a>

<p>Returns the name subtree of a <span class="code">record_field</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_field-2">record_field/2</a></span>.</p>
</p></div>
<p><a name="record_field_value-1"><span class="bold_code">record_field_value(Node::syntaxTree()) -&gt; none | syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_field_value-1"></a>

<p>Returns the value subtree of a <span class="code">record_field</span> node,
  if any. If <span class="code">Node</span> represents
  "<span class="code">Name</span>", <span class="code">none</span> is
  returned. Otherwise, if <span class="code">Node</span> represents
  "<span class="code">Name = Value</span>", <span class="code">Value</span>
  is returned.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_field-2">record_field/2</a></span>.</p>
</p></div>
<p><a name="record_index_expr-2"><span class="bold_code">record_index_expr(Type::syntaxTree(), Field::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_index_expr-2"></a>

<p>Creates an abstract record field index expression. The result
  represents "<span class="code">#Type.Field</span>".</p>
 
  <p>(Note: the function name <span class="code">record_index/2</span> is reserved
  by the Erlang compiler, which is why that name could not be used
  for this constructor.)
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_expr-3">record_expr/3</a></span>, <span class="bold_code"><a href="#record_index_expr_field-1">record_index_expr_field/1</a></span>, <span class="bold_code"><a href="#record_index_expr_type-1">record_index_expr_type/1</a></span>.</p>
</p></div>
<p><a name="record_index_expr_field-1"><span class="bold_code">record_index_expr_field(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_index_expr_field-1"></a>

<p>Returns the field subtree of a <span class="code">record_index_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_index_expr-2">record_index_expr/2</a></span>.</p>
</p></div>
<p><a name="record_index_expr_type-1"><span class="bold_code">record_index_expr_type(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="record_index_expr_type-1"></a>

<p>Returns the type subtree of a <span class="code">record_index_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#record_index_expr-2">record_index_expr/2</a></span>.</p>
</p></div>
<p><a name="remove_comments-1"><span class="bold_code">remove_comments(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="remove_comments-1"></a>

<p>Clears the associated comments of <span class="code">Node</span>.</p>
 
  <p>Note: This is equivalent to
  <span class="code">set_precomments(set_postcomments(Node, []), [])</span>, but
  potentially more efficient.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#set_postcomments-2">set_postcomments/2</a></span>, <span class="bold_code"><a href="#set_precomments-2">set_precomments/2</a></span>.</p>
</p></div>
<p><a name="revert-1"><span class="bold_code">revert(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="revert-1"></a>

<p>Returns an <span class="code">erl_parse</span>-compatible representation of a
  syntax tree, if possible. If <span class="code">Tree</span> represents a
  well-formed Erlang program or expression, the conversion should work
  without problems. Typically, <span class="bold_code"><a href="#is_tree-1">is_tree/1</a></span> yields
  <span class="code">true</span> if conversion failed (i.e., the result is still an
  abstract syntax tree), and <span class="code">false</span> otherwise.</p>
 
  <p>The <span class="bold_code"><a href="#is_tree-1">is_tree/1</a></span> test is not completely foolproof. For a
  few special node types (e.g. <span class="code">arity_qualifier</span>), if such a
  node occurs in a context where it is not expected, it will be left
  unchanged as a non-reverted subtree of the result. This can only
  happen if <span class="code">Tree</span> does not actually represent legal Erlang
  code.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="erl_parse.html">erl_parse(3)</a></span>, <span class="bold_code"><a href="#revert_forms-1">revert_forms/1</a></span>.</p>
</p></div>
<p><a name="revert_forms-1"><span class="bold_code">revert_forms(Forms::forms()) -&gt; [erl_parse()]</span></a><br></p>
<div class="REFBODY"><p><a name="revert_forms-1"></a>

<p>Reverts a sequence of Erlang source code forms. The sequence can
  be given either as a <span class="code">form_list</span> syntax tree (possibly
  nested), or as a list of "program form" syntax trees. If successful,
  the corresponding flat list of <span class="code">erl_parse</span>-compatible
  syntax trees is returned (see <span class="bold_code"><a href="#revert-1">revert/1</a></span>). If some program
  form could not be reverted, <span class="code">{error, Form}</span> is thrown.
  Standalone comments in the form sequence are discarded.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#form_list-1">form_list/1</a></span>, <span class="bold_code"><a href="#is_form-1">is_form/1</a></span>, <span class="bold_code"><a href="#revert-1">revert/1</a></span>.</p>
</p></div>
<p><a name="rule-2"><span class="bold_code">rule(Name::syntaxTree(), Clauses::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="rule-2"></a>

<p>Creates an abstract Mnemosyne rule. If <span class="code">Clauses</span> is
  <span class="code">[C1, ..., Cn]</span>, the results represents
  "<span class="code">Name C1; ...; Name
  Cn.</span>". More exactly, if each <span class="code">Ci</span>
  represents "<span class="code">(Pi1, ..., Pim) Gi -&gt;
  Bi</span>", then the result represents
  "<span class="code">Name(P11, ..., P1m) G1 :-
  B1; ...; Name(Pn1, ..., Pnm)
  Gn :- Bn.</span>". Rules are source code forms.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#function-2">function/2</a></span>, <span class="bold_code"><a href="#is_form-1">is_form/1</a></span>, <span class="bold_code"><a href="#rule_arity-1">rule_arity/1</a></span>, <span class="bold_code"><a href="#rule_clauses-1">rule_clauses/1</a></span>, <span class="bold_code"><a href="#rule_name-1">rule_name/1</a></span>.</p>
</p></div>
<p><a name="rule_arity-1"><span class="bold_code">rule_arity(Node::syntaxTree()) -&gt; arity()</span></a><br></p>
<div class="REFBODY"><p><a name="rule_arity-1"></a>

<p>Returns the arity of a <span class="code">rule</span> node. The result is the  
number of parameter patterns in the first clause of the rule;  
subsequent clauses are ignored.</p>
 
  <p>An exception is thrown if <span class="code">rule_clauses(Node)</span> returns
  an empty list, or if the first element of that list is not a syntax
  tree <span class="code">C</span> of type <span class="code">clause</span> such that
  <span class="code">clause_patterns(C)</span> is a nonempty list.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#clause-3">clause/3</a></span>, <span class="bold_code"><a href="#clause_patterns-1">clause_patterns/1</a></span>, <span class="bold_code"><a href="#rule-2">rule/2</a></span>, <span class="bold_code"><a href="#rule_clauses-1">rule_clauses/1</a></span>.</p>
</p></div>
<p><a name="rule_clauses-1"><span class="bold_code">rule_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="rule_clauses-1"></a>

<p>Returns the list of clause subtrees of a <span class="code">rule</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#rule-2">rule/2</a></span>.</p>
</p></div>
<p><a name="rule_name-1"><span class="bold_code">rule_name(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="rule_name-1"></a>

<p>Returns the name subtree of a <span class="code">rule</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#rule-2">rule/2</a></span>.</p>
</p></div>
<p><a name="set_ann-2"><span class="bold_code">set_ann(Node::syntaxTree(), As::[term()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="set_ann-2"></a>

<p>Sets the list of user annotations of <span class="code">Node</span> to <span class="code">Annotations</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#add_ann-2">add_ann/2</a></span>, <span class="bold_code"><a href="#copy_ann-2">copy_ann/2</a></span>, <span class="bold_code"><a href="#get_ann-1">get_ann/1</a></span>.</p>
</p></div>
<p><a name="set_attrs-2"><span class="bold_code">set_attrs(Node::syntaxTree(), Attr::syntaxTreeAttributes()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="set_attrs-2"></a>

<p>Sets the attributes of <span class="code">Node</span> to <span class="code">Attributes</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#copy_attrs-2">copy_attrs/2</a></span>, <span class="bold_code"><a href="#get_attrs-1">get_attrs/1</a></span>.</p>
</p></div>
<p><a name="set_pos-2"><span class="bold_code">set_pos(Node::syntaxTree(), Pos::term()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="set_pos-2"></a>

<p>Sets the position information of <span class="code">Node</span> to <span class="code">Pos</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#copy_pos-2">copy_pos/2</a></span>, <span class="bold_code"><a href="#get_pos-1">get_pos/1</a></span>.</p>
</p></div>
<p><a name="set_postcomments-2"><span class="bold_code">set_postcomments(Node::syntaxTree(), Cs::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="set_postcomments-2"></a>

<p>Sets the post-comments of <span class="code">Node</span> to
  <span class="code">Comments</span>. <span class="code">Comments</span> should be a possibly
  empty list of abstract comments, in top-down textual order
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#add_postcomments-2">add_postcomments/2</a></span>, <span class="bold_code"><a href="#comment-2">comment/2</a></span>, <span class="bold_code"><a href="#copy_comments-2">copy_comments/2</a></span>, <span class="bold_code"><a href="#get_postcomments-1">get_postcomments/1</a></span>, <span class="bold_code"><a href="#join_comments-2">join_comments/2</a></span>, <span class="bold_code"><a href="#remove_comments-1">remove_comments/1</a></span>, <span class="bold_code"><a href="#set_precomments-2">set_precomments/2</a></span>.</p>
</p></div>
<p><a name="set_precomments-2"><span class="bold_code">set_precomments(Node::syntaxTree(), Cs::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="set_precomments-2"></a>

<p>Sets the pre-comments of <span class="code">Node</span> to
  <span class="code">Comments</span>. <span class="code">Comments</span> should be a possibly
  empty list of abstract comments, in top-down textual order.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#add_precomments-2">add_precomments/2</a></span>, <span class="bold_code"><a href="#comment-2">comment/2</a></span>, <span class="bold_code"><a href="#copy_comments-2">copy_comments/2</a></span>, <span class="bold_code"><a href="#get_precomments-1">get_precomments/1</a></span>, <span class="bold_code"><a href="#join_comments-2">join_comments/2</a></span>, <span class="bold_code"><a href="#remove_comments-1">remove_comments/1</a></span>, <span class="bold_code"><a href="#set_postcomments-2">set_postcomments/2</a></span>.</p>
</p></div>
<p><a name="size_qualifier-2"><span class="bold_code">size_qualifier(Body::syntaxTree(), Size::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="size_qualifier-2"></a>

<p>Creates an abstract size qualifier. The result represents
  "<span class="code">Body:Size</span>".
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#size_qualifier_argument-1">size_qualifier_argument/1</a></span>, <span class="bold_code"><a href="#size_qualifier_body-1">size_qualifier_body/1</a></span>.</p>
</p></div>
<p><a name="size_qualifier_argument-1"><span class="bold_code">size_qualifier_argument(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="size_qualifier_argument-1"></a>

<p>Returns the argument subtree (the size) of a
  <span class="code">size_qualifier</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#size_qualifier-2">size_qualifier/2</a></span>.</p>
</p></div>
<p><a name="size_qualifier_body-1"><span class="bold_code">size_qualifier_body(Node::syntaxTree()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="size_qualifier_body-1"></a>

<p>Returns the body subtree of a <span class="code">size_qualifier</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#size_qualifier-2">size_qualifier/2</a></span>.</p>
</p></div>
<p><a name="string-1"><span class="bold_code">string(String::string()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="string-1"></a>

<p>Creates an abstract string literal. The result represents
  <span class="code">"Text"</span> (including the surrounding
  double-quotes), where <span class="code">Text</span> corresponds to the sequence
  of characters in <span class="code">Value</span>, but not representing a
  <strong>specific</strong> string literal.</p>
 
  <p>For example, the result of <span class="code">string("x\ny")</span> represents any and all of
  <span class="code">"x\ny"</span>, <span class="code">"x\12y"</span>, <span class="code">"x\012y"</span> and <span class="code">"x\^Jy"</span>; see <span class="bold_code"><a href="#char-1">char/1</a></span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#char-1">char/1</a></span>, <span class="bold_code"><a href="#is_string-2">is_string/2</a></span>, <span class="bold_code"><a href="#string_literal-1">string_literal/1</a></span>, <span class="bold_code"><a href="#string_literal-2">string_literal/2</a></span>, <span class="bold_code"><a href="#string_value-1">string_value/1</a></span>.</p>
</p></div>
<p><a name="string_literal-1"><span class="bold_code">string_literal(Node::syntaxTree()) -&gt; nonempty_string()</span></a><br></p>
<div class="REFBODY"><p><a name="string_literal-1"></a>

<p>Returns the literal string represented by a <span class="code">string</span>
  node. This includes surrounding double-quote characters.
  Characters beyond 255 will be escaped.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#string-1">string/1</a></span>.</p>
</p></div>
<p><a name="string_literal-2"><span class="bold_code">string_literal(Node::syntaxTree(), X2::encoding()) -&gt; nonempty_string()</span></a><br></p>
<div class="REFBODY"><p><a name="string_literal-2"></a>

<p>Returns the literal string represented by a <span class="code">string</span>
  node. This includes surrounding double-quote characters.
  Depending on the encoding characters beyond 255 will be escaped
  ('latin1') or copied as is ('utf8').
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#string-1">string/1</a></span>.</p>
</p></div>
<p><a name="string_value-1"><span class="bold_code">string_value(Node::syntaxTree()) -&gt; string()</span></a><br></p>
<div class="REFBODY"><p><a name="string_value-1"></a>

<p>Returns the value represented by a <span class="code">string</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#string-1">string/1</a></span>.</p>
</p></div>
<p><a name="subtrees-1"><span class="bold_code">subtrees(T::syntaxTree()) -&gt; [[syntaxTree()]]</span></a><br></p>
<div class="REFBODY"><p><a name="subtrees-1"></a>

<p>Returns the grouped list of all subtrees of a syntax tree. If
  <span class="code">Node</span> is a leaf node (see <span class="bold_code"><a href="#is_leaf-1">is_leaf/1</a></span>), this
  is the empty list, otherwise the result is always a nonempty list,
  containing the lists of subtrees of <span class="code">Node</span>, in  
left-to-right order as they occur in the printed program text, and  
grouped by category. Often, each group contains only a single  
subtree.</p>
 
  <p>Depending on the type of <span class="code">Node</span>, the size of some  
groups may be variable (e.g., the group consisting of all the  
elements of a tuple), while others always contain the same number of  
elements - usually exactly one (e.g., the group containing the  
argument expression of a case-expression). Note, however, that the  
exact structure of the returned list (for a given node type) should  
in general not be depended upon, since it might be subject to change  
without notice.</p>
 
  <p>The function <span class="bold_code"><a href="#subtrees-1">subtrees/1</a></span> and the constructor functions
  <span class="bold_code"><a href="#make_tree-2">make_tree/2</a></span> and <span class="bold_code"><a href="#update_tree-2">update_tree/2</a></span> can be a  
great help if one wants to traverse a syntax tree, visiting all its  
subtrees, but treat nodes of the tree in a uniform way in most or all  
cases. Using these functions makes this simple, and also assures that  
your code is not overly sensitive to extensions of the syntax tree  
data type, because any node types not explicitly handled by your code  
can be left to a default case.</p>
 
  <p>For example:
  </p><div class="example"><pre>     postorder(F, Tree) -&gt;
        F(case subtrees(Tree) of
            [] -&gt; Tree;
            List -&gt; update_tree(Tree,
                                [[postorder(F, Subtree)
                                  || Subtree &amp;lt;- Group]
                                 || Group &amp;lt;- List])
          end).</pre></div><p>
  maps the function <span class="code">F</span> on <span class="code">Tree</span> and all its
  subtrees, doing a post-order traversal of the syntax tree. (Note the
  use of <span class="bold_code"><a href="#update_tree-2">update_tree/2</a></span> to preserve node attributes.) For a
  simple function like:
  </p><div class="example"><pre>     f(Node) -&gt;
        case type(Node) of
            atom -&gt; atom("a_" ++ atom_name(Node));
            _ -&gt; Node
        end.</pre></div><p>
  the call <span class="code">postorder(fun f/1, Tree)</span> will yield a new
  representation of <span class="code">Tree</span> in which all atom names have been
  extended with the prefix "a_", but nothing else (including comments,
  annotations and line numbers) has been changed.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#copy_attrs-2">copy_attrs/2</a></span>, <span class="bold_code"><a href="#is_leaf-1">is_leaf/1</a></span>, <span class="bold_code"><a href="#make_tree-2">make_tree/2</a></span>, <span class="bold_code"><a href="#type-1">type/1</a></span>.</p>
</p></div>
<p><a name="text-1"><span class="bold_code">text(String::string()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="text-1"></a>

<p>Creates an abstract piece of source code text. The result
  represents exactly the sequence of characters in <span class="code">String</span>.
  This is useful in cases when one wants full control of the resulting
  output, e.g., for the appearance of floating-point numbers or macro
  definitions.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#text_string-1">text_string/1</a></span>.</p>
</p></div>
<p><a name="text_string-1"><span class="bold_code">text_string(Node::syntaxTree()) -&gt; string()</span></a><br></p>
<div class="REFBODY"><p><a name="text_string-1"></a>

<p>Returns the character sequence represented by a <span class="code">text</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#text-1">text/1</a></span>.</p>
</p></div>
<p><a name="tree-1"><span class="bold_code">tree(Type::atom()) -&gt; #tree{}</span></a><br></p>
<div class="REFBODY"><p><a name="tree-1"></a>
<p>Equivalent to <span class="bold_code"><a href="#tree-2">tree(Type, [])</a></span>.</p>
</p></div>
<p><a name="tree-2"><span class="bold_code">tree(Type::atom(), Data::term()) -&gt; #tree{}</span></a><br></p>
<div class="REFBODY"><p><a name="tree-2"></a>

<p><strong>For special purposes only</strong>. Creates an abstract syntax
  tree node with type tag <span class="code">Type</span> and associated data
  <span class="code">Data</span>.</p>
 
  <p>This function and the related <span class="bold_code"><a href="#is_tree-1">is_tree/1</a></span> and
  <span class="bold_code"><a href="#data-1">data/1</a></span> provide a uniform way to extend the set of
  <span class="code">erl_parse</span> node types. The associated data is any term,  
whose format may depend on the type tag.</p>
 
  <p><strong><a name="Notes:">Notes:</a></strong>
  </p><ul>
   <li><p>Any nodes created outside of this module must have type tags
       distinct from those currently defined by this module; see
       <span class="bold_code"><a href="#type-1">type/1</a></span> for a complete list.</p></li>
   <li><p>The type tag of a syntax tree node may also be used
       as a primary tag by the <span class="code">erl_parse</span> representation;
       in that case, the selector functions for that node type
       <strong>must</strong> handle both the abstract syntax tree and the
       <span class="code">erl_parse</span> form. The function <span class="code">type(T)</span>
       should return the correct type tag regardless of the
       representation of <span class="code">T</span>, so that the user sees no
       difference between <span class="code">erl_syntax</span> and
       <span class="code">erl_parse</span> nodes.</p></li>
  </ul><p>
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#data-1">data/1</a></span>, <span class="bold_code"><a href="#is_tree-1">is_tree/1</a></span>, <span class="bold_code"><a href="#type-1">type/1</a></span>.</p>
</p></div>
<p><a name="try_after_expr-2"><span class="bold_code">try_after_expr(Body::[syntaxTree()], After::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="try_after_expr-2"></a>
<p>Equivalent to <span class="bold_code"><a href="#try_expr-4">try_expr(Body, [], [], After)</a></span>.</p>
</p></div>
<p><a name="try_expr-2"><span class="bold_code">try_expr(Body::[syntaxTree()], Handlers::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="try_expr-2"></a>
<p>Equivalent to <span class="bold_code"><a href="#try_expr-3">try_expr(Body, [], Handlers)</a></span>.</p>
</p></div>
<p><a name="try_expr-3"><span class="bold_code">try_expr(Body::[syntaxTree()], Clauses::[syntaxTree()], Handlers::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="try_expr-3"></a>
<p>Equivalent to <span class="bold_code"><a href="#try_expr-4">try_expr(Body, Clauses, Handlers, [])</a></span>.</p>
</p></div>
<p><a name="try_expr-4"><span class="bold_code">try_expr(Body::[syntaxTree()], Clauses::[syntaxTree()], Handlers::[syntaxTree()], After::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="try_expr-4"></a>

<p>Creates an abstract try-expression. If <span class="code">Body</span> is
  <span class="code">[B1, ..., Bn]</span>, <span class="code">Clauses</span> is <span class="code">[C1, ...,
  Cj]</span>, <span class="code">Handlers</span> is <span class="code">[H1, ..., Hk]</span>, and
  <span class="code">After</span> is <span class="code">[A1, ..., Am]</span>, the result
  represents "<span class="code">try B1, ..., Bn of C1;
  ...; Cj catch H1; ...; Hk after
  A1, ..., Am end</span>". More exactly, if each
  <span class="code">Ci</span> represents "<span class="code">(CPi) CGi -&gt;
  CBi</span>", and each <span class="code">Hi</span> represents
  "<span class="code">(HPi) HGi -&gt; HBi</span>", then the
  result represents "<span class="code">try B1, ..., Bn of
  CP1 CG1 -&gt; CB1; ...; CPj
  CGj -&gt; CBj catch HP1 HG1 -&gt;
  HB1; ...; HPk HGk -&gt; HBk after
  A1, ..., Am end</span>"; see
  <span class="bold_code"><a href="#case_expr-2">case_expr/2</a></span>. If <span class="code">Clauses</span> is the empty list,
  the <span class="code">of ...</span> section is left out. If <span class="code">After</span> is
  the empty list, the <span class="code">after ...</span> section is left out. If
  <span class="code">Handlers</span> is the empty list, and <span class="code">After</span> is
  nonempty, the <span class="code">catch ...</span> section is left out.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#case_expr-2">case_expr/2</a></span>, <span class="bold_code"><a href="#class_qualifier-2">class_qualifier/2</a></span>, <span class="bold_code"><a href="#clause-3">clause/3</a></span>, <span class="bold_code"><a href="#try_after_expr-2">try_after_expr/2</a></span>, <span class="bold_code"><a href="#try_expr-2">try_expr/2</a></span>, <span class="bold_code"><a href="#try_expr-3">try_expr/3</a></span>, <span class="bold_code"><a href="#try_expr_after-1">try_expr_after/1</a></span>, <span class="bold_code"><a href="#try_expr_body-1">try_expr_body/1</a></span>, <span class="bold_code"><a href="#try_expr_clauses-1">try_expr_clauses/1</a></span>, <span class="bold_code"><a href="#try_expr_handlers-1">try_expr_handlers/1</a></span>.</p>
</p></div>
<p><a name="try_expr_after-1"><span class="bold_code">try_expr_after(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="try_expr_after-1"></a>

<p>Returns the list of "after" subtrees of a <span class="code">try_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#try_expr-4">try_expr/4</a></span>.</p>
</p></div>
<p><a name="try_expr_body-1"><span class="bold_code">try_expr_body(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="try_expr_body-1"></a>

<p>Returns the list of body subtrees of a <span class="code">try_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#try_expr-4">try_expr/4</a></span>.</p>
</p></div>
<p><a name="try_expr_clauses-1"><span class="bold_code">try_expr_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="try_expr_clauses-1"></a>

<p>Returns the list of case-clause subtrees of a
  <span class="code">try_expr</span> node. If <span class="code">Node</span> represents
  "<span class="code">try Body catch H1; ...; Hn
  end</span>", the result is the empty list.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#try_expr-4">try_expr/4</a></span>.</p>
</p></div>
<p><a name="try_expr_handlers-1"><span class="bold_code">try_expr_handlers(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="try_expr_handlers-1"></a>

<p>Returns the list of handler-clause subtrees of a
  <span class="code">try_expr</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#try_expr-4">try_expr/4</a></span>.</p>
</p></div>
<p><a name="tuple-1"><span class="bold_code">tuple(List::[syntaxTree()]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="tuple-1"></a>

<p>Creates an abstract tuple. If <span class="code">Elements</span> is
  <span class="code">[X1, ..., Xn]</span>, the result represents
  "<span class="code">{X1, ..., Xn}</span>".</p>
 
  <p>Note: The Erlang language has distinct 1-tuples, i.e.,
  <span class="code">{X}</span> is always distinct from <span class="code">X</span> itself.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#tuple_elements-1">tuple_elements/1</a></span>, <span class="bold_code"><a href="#tuple_size-1">tuple_size/1</a></span>.</p>
</p></div>
<p><a name="tuple_elements-1"><span class="bold_code">tuple_elements(Node::syntaxTree()) -&gt; [syntaxTree()]</span></a><br></p>
<div class="REFBODY"><p><a name="tuple_elements-1"></a>

<p>Returns the list of element subtrees of a <span class="code">tuple</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#tuple-1">tuple/1</a></span>.</p>
</p></div>
<p><a name="tuple_size-1"><span class="bold_code">tuple_size(Node::syntaxTree()) -&gt; non_neg_integer()</span></a><br></p>
<div class="REFBODY"><p><a name="tuple_size-1"></a>

<p>Returns the number of elements of a <span class="code">tuple</span> node.</p>
 
  <p>Note: this is equivalent to
  <span class="code">length(tuple_elements(Node))</span>, but potentially more
  efficient.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#tuple-1">tuple/1</a></span>, <span class="bold_code"><a href="#tuple_elements-1">tuple_elements/1</a></span>.</p>
</p></div>
<p><a name="type-1"><span class="bold_code">type(Tree::syntaxTree()) -&gt; atom()</span></a><br></p>
<div class="REFBODY"><p><a name="type-1"></a>

<p>Returns the type tag of <span class="code">Node</span>. If <span class="code">Node</span>
  does not represent a syntax tree, evaluation fails with reason
  <span class="code">badarg</span>. Node types currently defined by this module are:</p>
 
  <p>
   
    application
    arity_qualifier
    atom
    attribute
   <br>
    binary
    binary_field
    block_expr
    case_expr
   <br>
    catch_expr
    char
    class_qualifier
    clause
   <br>
    comment
    cond_expr
    conjunction
    disjunction
   <br>
    eof_marker
    error_marker
    float
    form_list
   <br>
    fun_expr
    function
    generator
    if_expr
   <br>
    implicit_fun
    infix_expr
    integer
    list
   <br>
    list_comp
    macro
    map_expr
    map_field_assoc
   <br>
    map_field_exact
    match_expr
    module_qualifier
    named_fun_expr
   <br>
    nil
    operator
    parentheses
    prefix_expr
   <br>
    receive_expr
    record_access
    record_expr
    record_field
   <br>
    record_index_expr
    rule
    size_qualifier
    string
   <br>
    text
    try_expr
    tuple
    underscore
   <br>
    variable
    warning_marker
    
    
   <br>
  </p>
 
  <p>The user may (for special purposes) create additional nodes
  with other type tags, using the <span class="bold_code"><a href="#tree-2">tree/2</a></span> function.</p>
 
  <p>Note: The primary constructor functions for a node type should
  always have the same name as the node type itself.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#application-3">application/3</a></span>, <span class="bold_code"><a href="#arity_qualifier-2">arity_qualifier/2</a></span>, <span class="bold_code"><a href="#atom-1">atom/1</a></span>, <span class="bold_code"><a href="#attribute-2">attribute/2</a></span>, <span class="bold_code"><a href="#binary-1">binary/1</a></span>, <span class="bold_code"><a href="#binary_field-2">binary_field/2</a></span>, <span class="bold_code"><a href="#block_expr-1">block_expr/1</a></span>, <span class="bold_code"><a href="#case_expr-2">case_expr/2</a></span>, <span class="bold_code"><a href="#catch_expr-1">catch_expr/1</a></span>, <span class="bold_code"><a href="#char-1">char/1</a></span>, <span class="bold_code"><a href="#class_qualifier-2">class_qualifier/2</a></span>, <span class="bold_code"><a href="#clause-3">clause/3</a></span>, <span class="bold_code"><a href="#comment-2">comment/2</a></span>, <span class="bold_code"><a href="#cond_expr-1">cond_expr/1</a></span>, <span class="bold_code"><a href="#conjunction-1">conjunction/1</a></span>, <span class="bold_code"><a href="#disjunction-1">disjunction/1</a></span>, <span class="bold_code"><a href="#eof_marker-0">eof_marker/0</a></span>, <span class="bold_code"><a href="#error_marker-1">error_marker/1</a></span>, <span class="bold_code"><a href="#float-1">float/1</a></span>, <span class="bold_code"><a href="#form_list-1">form_list/1</a></span>, <span class="bold_code"><a href="#fun_expr-1">fun_expr/1</a></span>, <span class="bold_code"><a href="#function-2">function/2</a></span>, <span class="bold_code"><a href="#generator-2">generator/2</a></span>, <span class="bold_code"><a href="#if_expr-1">if_expr/1</a></span>, <span class="bold_code"><a href="#implicit_fun-2">implicit_fun/2</a></span>, <span class="bold_code"><a href="#infix_expr-3">infix_expr/3</a></span>, <span class="bold_code"><a href="#integer-1">integer/1</a></span>, <span class="bold_code"><a href="#list-2">list/2</a></span>, <span class="bold_code"><a href="#list_comp-2">list_comp/2</a></span>, <span class="bold_code"><a href="#macro-2">macro/2</a></span>, <span class="bold_code"><a href="#map_expr-2">map_expr/2</a></span>, <span class="bold_code"><a href="#map_field_assoc-2">map_field_assoc/2</a></span>, <span class="bold_code"><a href="#map_field_exact-2">map_field_exact/2</a></span>, <span class="bold_code"><a href="#match_expr-2">match_expr/2</a></span>, <span class="bold_code"><a href="#module_qualifier-2">module_qualifier/2</a></span>, <span class="bold_code"><a href="#named_fun_expr-2">named_fun_expr/2</a></span>, <span class="bold_code"><a href="#nil-0">nil/0</a></span>, <span class="bold_code"><a href="#operator-1">operator/1</a></span>, <span class="bold_code"><a href="#parentheses-1">parentheses/1</a></span>, <span class="bold_code"><a href="#prefix_expr-2">prefix_expr/2</a></span>, <span class="bold_code"><a href="#receive_expr-3">receive_expr/3</a></span>, <span class="bold_code"><a href="#record_access-3">record_access/3</a></span>, <span class="bold_code"><a href="#record_expr-2">record_expr/2</a></span>, <span class="bold_code"><a href="#record_field-2">record_field/2</a></span>, <span class="bold_code"><a href="#record_index_expr-2">record_index_expr/2</a></span>, <span class="bold_code"><a href="#rule-2">rule/2</a></span>, <span class="bold_code"><a href="#size_qualifier-2">size_qualifier/2</a></span>, <span class="bold_code"><a href="#string-1">string/1</a></span>, <span class="bold_code"><a href="#text-1">text/1</a></span>, <span class="bold_code"><a href="#tree-2">tree/2</a></span>, <span class="bold_code"><a href="#try_expr-3">try_expr/3</a></span>, <span class="bold_code"><a href="#tuple-1">tuple/1</a></span>, <span class="bold_code"><a href="#underscore-0">underscore/0</a></span>, <span class="bold_code"><a href="#variable-1">variable/1</a></span>, <span class="bold_code"><a href="#warning_marker-1">warning_marker/1</a></span>.</p>
</p></div>
<p><a name="underscore-0"><span class="bold_code">underscore() -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="underscore-0"></a>

<p>Creates an abstract universal pattern ("<span class="code">_</span>"). The
  lexical representation is a single underscore character. Note that
  this is <strong>not</strong> a variable, lexically speaking.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#variable-1">variable/1</a></span>.</p>
</p></div>
<p><a name="update_tree-2"><span class="bold_code">update_tree(Node::syntaxTree(), Groups::[[syntaxTree()]]) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="update_tree-2"></a>

<p>Creates a syntax tree with the same type and attributes as the
  given tree. This is equivalent to <span class="code">copy_attrs(Node,
  make_tree(type(Node), Groups))</span>.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#copy_attrs-2">copy_attrs/2</a></span>, <span class="bold_code"><a href="#make_tree-2">make_tree/2</a></span>, <span class="bold_code"><a href="#type-1">type/1</a></span>.</p>
</p></div>
<p><a name="variable-1"><span class="bold_code">variable(Name::atom() | string()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="variable-1"></a>

<p>Creates an abstract variable with the given name.
  <span class="code">Name</span> may be any atom or string that represents a
  lexically valid variable name, but <strong>not</strong> a single underscore
  character; see <span class="bold_code"><a href="#underscore-0">underscore/0</a></span>.</p>
 
  <p>Note: no checking is done whether the character sequence
  represents a proper variable name, i.e., whether or not its first
  character is an uppercase Erlang character, or whether it does not
  contain control characters, whitespace, etc.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#underscore-0">underscore/0</a></span>, <span class="bold_code"><a href="#variable_literal-1">variable_literal/1</a></span>, <span class="bold_code"><a href="#variable_name-1">variable_name/1</a></span>.</p>
</p></div>
<p><a name="variable_literal-1"><span class="bold_code">variable_literal(Node::syntaxTree()) -&gt; string()</span></a><br></p>
<div class="REFBODY"><p><a name="variable_literal-1"></a>

<p>Returns the name of a <span class="code">variable</span> node as a string.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#variable-1">variable/1</a></span>.</p>
</p></div>
<p><a name="variable_name-1"><span class="bold_code">variable_name(Node::syntaxTree()) -&gt; atom()</span></a><br></p>
<div class="REFBODY"><p><a name="variable_name-1"></a>

<p>Returns the name of a <span class="code">variable</span> node as an atom.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#variable-1">variable/1</a></span>.</p>
</p></div>
<p><a name="warning_marker-1"><span class="bold_code">warning_marker(Warning::term()) -&gt; syntaxTree()</span></a><br></p>
<div class="REFBODY"><p><a name="warning_marker-1"></a>

<p>Creates an abstract warning marker. The result represents an
  occurrence of a possible problem in the source code, with an
  associated Erlang I/O ErrorInfo structure given by <span class="code">Error</span>
  (see module <span class="bold_code"><a href="io.html">io(3)</a></span> for details). Warning markers are  
regarded as source code forms, but have no defined lexical form.</p>
 
  <p>Note: this is supported only for backwards compatibility with
  existing parsers and tools.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#eof_marker-0">eof_marker/0</a></span>, <span class="bold_code"><a href="#error_marker-1">error_marker/1</a></span>, <span class="bold_code"><a href="#is_form-1">is_form/1</a></span>, <span class="bold_code"><a href="#warning_marker_info-1">warning_marker_info/1</a></span>.</p>
</p></div>
<p><a name="warning_marker_info-1"><span class="bold_code">warning_marker_info(Node::syntaxTree()) -&gt; term()</span></a><br></p>
<div class="REFBODY"><p><a name="warning_marker_info-1"></a>

<p>Returns the ErrorInfo structure of a <span class="code">warning_marker</span> node.
 </p>
<p><strong>See also:</strong> <span class="bold_code"><a href="#warning_marker-1">warning_marker/1</a></span>.</p>
</p></div>



Richard Carlsson
carlsson.richard@gmail.com</div>
<div class="footer">
<hr>
<p>Copyright © 2006-2015 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
