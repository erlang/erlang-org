<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- public_key</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/public_key/users_guide.html">User's Guide</a><br><a href="../apps/public_key/index.html">Reference Manual</a><br><a href="../apps/public_key/release_notes.html">Release Notes</a><br><a href="../apps/public_key/public_key.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>public_key</strong><br><strong>Reference Manual</strong><br><small>Version 0.23</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu"><li id="loadscrollpos" title="public_key " expanded="true">public_key<ul>
<li><a href="public_key.html">
                  Top of manual page
                </a></li>
<li title="compute_key-2"><a href="public_key.html#compute_key-2">compute_key/2</a></li>
<li title="compute_key-3"><a href="public_key.html#compute_key-3">compute_key/3</a></li>
<li title="decrypt_private-2"><a href="public_key.html#decrypt_private-2">decrypt_private/2</a></li>
<li title="decrypt_private-3"><a href="public_key.html#decrypt_private-3">decrypt_private/3</a></li>
<li title="decrypt_public-2"><a href="public_key.html#decrypt_public-2">decrypt_public/2</a></li>
<li title="decrypt_public-3"><a href="public_key.html#decrypt_public-3">decrypt_public/3</a></li>
<li title="der_decode-2"><a href="public_key.html#der_decode-2">der_decode/2</a></li>
<li title="der_encode-2"><a href="public_key.html#der_encode-2">der_encode/2</a></li>
<li title="generate_key-1"><a href="public_key.html#generate_key-1">generate_key/1</a></li>
<li title="pem_decode-1"><a href="public_key.html#pem_decode-1">pem_decode/1</a></li>
<li title="pem_encode-1"><a href="public_key.html#pem_encode-1">pem_encode/1</a></li>
<li title="pem_entry_decode-1"><a href="public_key.html#pem_entry_decode-1">pem_entry_decode/1</a></li>
<li title="pem_entry_decode-2"><a href="public_key.html#pem_entry_decode-2">pem_entry_decode/2</a></li>
<li title="pem_entry_encode-2"><a href="public_key.html#pem_entry_encode-2">pem_entry_encode/2</a></li>
<li title="pem_entry_encode-3"><a href="public_key.html#pem_entry_encode-3">pem_entry_encode/3</a></li>
<li title="encrypt_private-2"><a href="public_key.html#encrypt_private-2">encrypt_private/2</a></li>
<li title="encrypt_public-2"><a href="public_key.html#encrypt_public-2">encrypt_public/2</a></li>
<li title="pkix_decode_cert-2"><a href="public_key.html#pkix_decode_cert-2">pkix_decode_cert/2</a></li>
<li title="pkix_encode-3"><a href="public_key.html#pkix_encode-3">pkix_encode/3</a></li>
<li title="pkix_is_issuer-2"><a href="public_key.html#pkix_is_issuer-2">pkix_is_issuer/2</a></li>
<li title="pkix_is_fixed_dh_cert-1"><a href="public_key.html#pkix_is_fixed_dh_cert-1">pkix_is_fixed_dh_cert/1</a></li>
<li title="pkix_is_self_signed-1"><a href="public_key.html#pkix_is_self_signed-1">pkix_is_self_signed/1</a></li>
<li title="pkix_issuer_id-2"><a href="public_key.html#pkix_issuer_id-2">pkix_issuer_id/2</a></li>
<li title="pkix_normalize_name-1"><a href="public_key.html#pkix_normalize_name-1">pkix_normalize_name/1</a></li>
<li title="pkix_path_validation-3"><a href="public_key.html#pkix_path_validation-3">pkix_path_validation/3</a></li>
<li title="pkix_crl_issuer-1"><a href="public_key.html#pkix_crl_issuer-1">pkix_crl_issuer/1</a></li>
<li title="pkix_crls_validate-3"><a href="public_key.html#pkix_crls_validate-3">pkix_crls_validate/3</a></li>
<li title="pkix_crl_verify-2"><a href="public_key.html#pkix_crl_verify-2">pkix_crl_verify/2</a></li>
<li title="pkix_dist_point-1"><a href="public_key.html#pkix_dist_point-1">pkix_dist_point/1</a></li>
<li title="pkix_dist_points-1"><a href="public_key.html#pkix_dist_points-1">pkix_dist_points/1</a></li>
<li title="pkix_sign-2"><a href="public_key.html#pkix_sign-2">pkix_sign/2</a></li>
<li title="pkix_sign_types-1"><a href="public_key.html#pkix_sign_types-1">pkix_sign_types/1</a></li>
<li title="pkix_verify-2"><a href="public_key.html#pkix_verify-2">pkix_verify/2</a></li>
<li title="sign-3"><a href="public_key.html#sign-3">sign/3</a></li>
<li title="ssh_decode-2"><a href="public_key.html#ssh_decode-2">ssh_decode/2</a></li>
<li title="ssh_encode-2"><a href="public_key.html#ssh_encode-2">ssh_encode/2</a></li>
<li title="verify-4"><a href="public_key.html#verify-4">verify/4</a></li>
</ul>
</li></ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>public_key</h1></center>
  
  <h3>MODULE</h3>
<div class="REFBODY">public_key</div>
  <h3>MODULE SUMMARY</h3>
<div class="REFBODY"> API module for public key infrastructure.</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>This module provides functions to handle public key infrastructure. It can
    encode/decode different file formats (PEM, openssh), sign and verify digital signatures and validate
    certificate paths and certificate revocation lists.
    </p>
  </p></div>

  <h3><a name="id65000">public_key</a></h3>
<div class="REFBODY">
    

    <ul>
      <li>public_key requires the crypto and asn1 applications, the latter since R16 (hopefully the runtime dependency on asn1 will
      be removed again in the future).</li>

      <li>Supports <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280 </a></span> -
      Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile </li>
      <li>Supports <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc3447.txt"> PKCS-1 </a></span> - RSA Cryptography Standard </li>
      <li>Supports <span class="bold_code"><a href="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf"> DSS</a></span>- Digital Signature Standard (DSA - Digital Signature Algorithm)</li>
      <li>Supports <span class="bold_code"><a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-3-diffie-hellman-key-agreement-standar.htm"> PKCS-3 </a></span> - Diffie-Hellman Key Agreement Standard </li>
      <li>Supports <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc2898.txt"> PKCS-5</a></span> - Password-Based Cryptography Standard </li>
      <li>Supports <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5208.txt"> PKCS-8</a></span> - Private-Key Information Syntax Standard</li>
      <li>Supports <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5967.txt"> PKCS-10</a></span> - Certification Request Syntax Standard</li>
    </ul>
  </div>

  <h3><a name="id64531">COMMON DATA TYPES </a></h3>
<div class="REFBODY">
     
    
    <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>All records used in this manual 
    
    are generated from ASN.1 specifications
    and are documented in the User's Guide. See <span class="bold_code"><a href="../apps/public_key/public_key_records.html">Public key records</a></span> and <span class="bold_code"><a href="../apps/public_key/cert_records.html">X.509 Certificate records</a></span>. 
    </p></p></div>
</div>
    
    <p>Use the following include directive to get access to the 
    records and constant macros described here and in the User's Guide.</p>
    
    <div class="example"><pre> -include_lib("public_key/include/public_key.hrl").</pre></div>

    <p><strong>Data Types </strong></p>
    
    <p><div class="example"><pre>oid() - Object Identifier, a tuple of integers as generated by the ASN1 compiler.</pre></div></p>

    <p><div class="example"><pre>boolean() = true | false</pre></div></p>

    <p><div class="example"><pre>string() = [bytes()]</pre></div></p>

    <p><div class="example"><pre>der_encoded() = binary()</pre></div></p>
   
    <p><div class="example"><pre>pki_asn1_type() = 'Certificate' | 'RSAPrivateKey'| 'RSAPublicKey' |
    'DSAPrivateKey' | 'DSAPublicKey' | 'DHParameter' |
    'SubjectPublicKeyInfo' | 'PrivateKeyInfo' |
    'CertificationRequest' | 'ECPrivateKey' | 'EcpkParameters'</pre></div></p>
    
    <p><div class="example"><pre>pem_entry () = {pki_asn1_type(), binary(), %% DER or encrypted DER
    not_encrypted | cipher_info()}</pre></div></p>

    <p><div class="example"><pre>cipher_info()  =  {"RC2-CBC | "DES-CBC" | "DES-EDE3-CBC",
    crypto:rand_bytes(8) | {#'PBEParameter{}, digest_type()} |#'PBES2-params'{}}</pre></div></p>
	  
    <p><div class="example"><pre>public_key()  = rsa_public_key() | dsa_public_key() | ec_public_key()</pre></div></p>
    <p><div class="example"><pre>private_key() = rsa_private_key() | dsa_private_key() | ec_private_key()</pre></div></p>
    <p><div class="example"><pre>rsa_public_key()  = #'RSAPublicKey'{}</pre></div></p>

    <p><div class="example"><pre>rsa_private_key() = #'RSAPrivateKey'{}</pre></div></p>

    <p><div class="example"><pre>dsa_public_key()  = {integer(),  #'Dss-Parms'{}}</pre></div></p>

    <p><div class="example"><pre>dsa_private_key() = #'DSAPrivateKey'{}</pre></div></p>

    <p><div class="example"><pre>ec_public_key()   = {#'ECPoint'{}, #'EcpkParameters'{} |
    {namedCurve, oid()}}</pre></div></p>
    
    <p><div class="example"><pre>ec_private_key()  = #'ECPrivateKey'{}</pre></div></p>

    <p><div class="example"><pre>public_crypt_options() = [{rsa_pad, rsa_padding()}].</pre></div></p>

    <p><div class="example"><pre>rsa_padding() =  'rsa_pkcs1_padding' | 'rsa_pkcs1_oaep_padding' |
    'rsa_no_padding'</pre></div></p>

    <p><div class="example"><pre>digest_type() - Union of below digest types</pre></div></p>
    
    <p><div class="example"><pre>rsa_digest_type()   = 'md5' | 'sha' | 'sha224' | 'sha256' | 'sha384' |
    'sha512'</pre></div></p>

    <p><div class="example"><pre>dss_digest_type()   = 'sha'</pre></div></p>

    <p><div class="example"><pre>ecdsa_digest_type() = 'sha'| 'sha224' | 'sha256' | 'sha384' | 'sha512'</pre></div></p>

    <p><div class="example"><pre>crl_reason()  = unspecified | keyCompromise | cACompromise |
    affiliationChanged | superseded | cessationOfOperation |
    certificateHold | privilegeWithdrawn | aACompromise</pre></div></p>

    <p><div class="example"><pre>issuer_name() = {rdnSequence,[#'AttributeTypeAndValue'{}]} </pre></div> </p>

    <p><div class="example"><pre>ssh_file()  = openssh_public_key | rfc4716_public_key | known_hosts |
    auth_keys</pre></div></p>
    

    



	

    

      



      



      




      




  </div> 

<h3>EXPORTS</h3>    

  <p><a name="compute_key-2"><span class="bold_code">compute_key(OthersKey, MyKey)-&gt;</span></a><br><a name="compute_key-3"><span class="bold_code">compute_key(OthersKey, MyKey, Params)-&gt;</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">OthersKey = #'ECPoint'{} | binary(), MyKey = #'ECPrivateKey'{} | binary()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Params =  #'DHParameter'{}</span><br>
</div>
    </div>
<div class="REFBODY"><p>
    <p> Compute shared secret </p>
  </p></div>

  <p><a name="decrypt_private-2"><span class="bold_code">decrypt_private(CipherText, Key) -&gt; binary()</span></a><br><a name="decrypt_private-3"><span class="bold_code">decrypt_private(CipherText, Key, Options) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">CipherText = binary()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_private_key()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Options = public_crypt_options()</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p>Public key decryption using the private key. See also <span class="bold_code"><a href="crypto.html#private_decrypt-4">crypto:private_decrypt/4</a></span></p> 
  </p></div>

  <p><a name="decrypt_public-2"><span class="bold_code">decrypt_public(CipherText, Key) - &gt; binary()</span></a><br><a name="decrypt_public-3"><span class="bold_code">decrypt_public(CipherText, Key, Options) - &gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">CipherText = binary()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_public_key()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Options = public_crypt_options()</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p> Public key decryption using the public key. See also <span class="bold_code"><a href="crypto.html#public_decrypt-4">crypto:public_decrypt/4</a></span></p> 
  </p></div> 

  <p><a name="der_decode-2"><span class="bold_code">der_decode(Asn1type, Der) -&gt; term()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Asn1Type = atom()</span><br>
</div>
      <div class="REFBODY"> ASN.1 type present in the public_key applications
      asn1 specifications.</div>
      <div class="REFTYPES">
<span class="bold_code">Der = der_encoded()</span><br>
</div>
    </div>
<div class="REFBODY"><p> 
      <p> Decodes a public key ASN.1 DER encoded entity.</p>
    </p></div>
    
  <p><a name="der_encode-2"><span class="bold_code">der_encode(Asn1Type, Entity) -&gt; der_encoded()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Asn1Type = atom()</span><br>
</div>
      <div class="REFBODY"> Asn1 type present in the public_key applications
	 ASN.1 specifications.</div>
      <div class="REFTYPES">
<span class="bold_code">Entity = term()</span><br>
</div>
      <div class="REFBODY">The erlang representation of <span class="code">Asn1Type</span>
</div>
  </div>
<div class="REFBODY"><p> 
    <p> Encodes a public key entity with ASN.1 DER encoding.</p>
  </p></div>

  <p><a name="generate_key-1"><span class="bold_code">generate_key(Params) -&gt; {Public::binary(), Private::binary()}  | #'ECPrivateKey'{} </span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code"> Params = #'DHParameter'{} |  {namedCurve, oid()} |  #'ECParameters'{} </span><br>
</div>
    </div>
<div class="REFBODY"><p>
    <p>Generates a new keypair</p>
  </p></div>

  <p><a name="pem_decode-1"><span class="bold_code">pem_decode(PemBin) -&gt; [pem_entry()]</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">PemBin = binary()</span><br>
</div>
      <div class="REFBODY">Example {ok, PemBin} = file:read_file("cert.pem").</div>
    </div>
<div class="REFBODY"><p> 
    <p>Decode PEM binary data and return
    entries as ASN.1 DER encoded entities.</p>
  </p></div> 
    
   <p><a name="pem_encode-1"><span class="bold_code">pem_encode(PemEntries) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code"> PemEntries = [pem_entry()] </span><br>
</div> 
  </div>
<div class="REFBODY"><p> 
    <p>Creates a PEM binary</p> 
  </p></div>

   <p><a name="pem_entry_decode-1"><span class="bold_code">pem_entry_decode(PemEntry) -&gt; term()</span></a><br><a name="pem_entry_decode-2"><span class="bold_code">pem_entry_decode(PemEntry, Password) -&gt; term()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code"> PemEntry = pem_entry() </span><br>
</div> 
      <div class="REFTYPES">
<span class="bold_code"> Password = string() </span><br>
</div> 
  </div>
<div class="REFBODY"><p> 
    <p>Decodes a PEM entry. pem_decode/1 returns a list of PEM
    entries. Note that if the PEM entry is of type
    'SubjectPublickeyInfo' it will be further decoded to an
    rsa_public_key() or dsa_public_key().</p>
  </p></div>

   <p><a name="pem_entry_encode-2"><span class="bold_code">pem_entry_encode(Asn1Type, Entity) -&gt; pem_entry()</span></a><br><a name="pem_entry_encode-3"><span class="bold_code">pem_entry_encode(Asn1Type, Entity, {CipherInfo, Password}) -&gt; pem_entry()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Asn1Type = pki_asn1_type()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Entity = term()</span><br>
</div>
      <div class="REFBODY">The Erlang representation of
      <span class="code">Asn1Type</span>.  If <span class="code">Asn1Type</span> is 'SubjectPublicKeyInfo'
      then <span class="code">Entity</span> must be either an rsa_public_key() or a
      dsa_public_key() and this function will create the appropriate
      'SubjectPublicKeyInfo' entry.
      </div>
      <div class="REFTYPES">
<span class="bold_code">CipherInfo = cipher_info()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Password = string()</span><br>
</div> 
  </div>
<div class="REFBODY"><p> 
    <p> Creates a PEM entry that can be feed to pem_encode/1.</p>
  </p></div>

  <p><a name="encrypt_private-2"><span class="bold_code">encrypt_private(PlainText, Key) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">PlainText = binary()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_private_key()</span><br>
</div> 
  </div>
<div class="REFBODY"><p> 
    <p> Public key encryption using the private key.
     See also <span class="bold_code"><a href="crypto.html#private_encrypt-4">crypto:private_encrypt/4</a></span></p> 
  </p></div>   

  <p><a name="encrypt_public-2"><span class="bold_code">encrypt_public(PlainText, Key) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">PlainText = binary()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_public_key()</span><br>
</div> 
  </div>
<div class="REFBODY"><p> 
    <p> Public key encryption using the public key.  See also <span class="bold_code"><a href="crypto.html#public_encrypt-4">crypto:public_encrypt/4</a></span></p> 
  </p></div>   
  
  <p><a name="pkix_decode_cert-2"><span class="bold_code">pkix_decode_cert(Cert, otp|plain) -&gt;  #'Certificate'{} | #'OTPCertificate'{}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded()</span><br>
</div> 
  </div>
<div class="REFBODY"><p> 
    <p>Decodes an ASN.1 DER encoded PKIX certificate.  The otp option
    will use the customized ASN.1 specification OTP-PKIX.asn1 for
    decoding and also recursively decode most of the standard
    parts.</p>
  </p></div>

  <p><a name="pkix_encode-3"><span class="bold_code">pkix_encode(Asn1Type, Entity, otp | plain) -&gt; der_encoded()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Asn1Type = atom()</span><br>
</div>
      <div class="REFBODY">The ASN.1 type can be 'Certificate', 'OTPCertificate' or a subtype of either .</div>
      <div class="REFTYPES">
<span class="bold_code">Entity = #'Certificate'{} | #'OTPCertificate'{} | a valid subtype</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p>DER encodes a PKIX x509 certificate or part of such a
    certificate. This function must be used for encoding certificates or parts of certificates
    that are decoded/created in the otp format, whereas for the plain format this
    function will directly call der_encode/2. </p> 
  </p></div>

 <p><a name="pkix_is_issuer-2"><span class="bold_code">pkix_is_issuer(Cert, IssuerCert) -&gt; boolean()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded() | #'OTPCertificate'{}</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">IssuerCert = der_encoded() | #'OTPCertificate'{}</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p> Checks if <span class="code">IssuerCert</span> issued <span class="code">Cert</span> </p> 
  </p></div>
  
  <p><a name="pkix_is_fixed_dh_cert-1"><span class="bold_code">pkix_is_fixed_dh_cert(Cert) -&gt; boolean()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded() | #'OTPCertificate'{}</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p> Checks if a Certificate is a fixed Diffie-Hellman Cert.</p> 
  </p></div>  
  
  <p><a name="pkix_is_self_signed-1"><span class="bold_code">pkix_is_self_signed(Cert) -&gt; boolean()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded() | #'OTPCertificate'{}</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p> Checks if a Certificate is self signed.</p> 
  </p></div>

  <p><a name="pkix_issuer_id-2"><span class="bold_code">pkix_issuer_id(Cert, IssuedBy) -&gt; {ok, IssuerID} | {error, Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
        <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded() | #'OTPCertificate'{}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">IssuedBy = self | other</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">IssuerID = {integer(), issuer_name()}</span><br>
</div>
	<div class="REFBODY">The issuer id consists of the serial number and the issuers name.</div>
	<div class="REFTYPES">
<span class="bold_code">Reason = term()</span><br>
</div>
    </div>
<div class="REFBODY"><p> 
      <p> Returns the issuer id.</p> 
    </p></div>
  
 
  <p><a name="pkix_normalize_name-1"><span class="bold_code">pkix_normalize_name(Issuer) -&gt; Normalized</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Issuer = issuer_name()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Normalized = issuer_name()</span><br>
</div>
  </div>
<div class="REFBODY"><p> 
    <p>Normalizes a issuer name so that it can be easily
    compared to another issuer name.</p> 
  </p></div>
   
  <p><a name="pkix_path_validation-3"><span class="bold_code">pkix_path_validation(TrustedCert, CertChain, Options) -&gt; {ok, {PublicKeyInfo, PolicyTree}} | {error, {bad_cert, Reason}} </span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code"> TrustedCert =  #'OTPCertificate'{} | der_encoded() | atom()  </span><br>
</div>
       <div class="REFBODY">Normally a trusted certificate but it can also be a path validation
       error that can be discovered while
       constructing the input to this function and that should be run through the <span class="code">verify_fun</span>.
       For example <span class="code">unknown_ca </span> or <span class="code">selfsigned_peer </span>
       </div>
       <div class="REFTYPES">
<span class="bold_code"> CertChain = [der_encoded()]</span><br>
</div>
       <div class="REFBODY">A list of DER encoded certificates in trust order ending with the peer certificate.</div>
       <div class="REFTYPES">
<span class="bold_code"> Options = proplists:proplist()</span><br>
</div>
       <div class="REFTYPES">
<span class="bold_code">PublicKeyInfo = {?'rsaEncryption' | ?'id-dsa',
       rsa_public_key() | integer(), 'NULL' | 'Dss-Parms'{}}</span><br>
</div>
       <div class="REFTYPES">
<span class="bold_code"> PolicyTree = term() </span><br>
</div>
       <div class="REFBODY">At the moment this will always be an empty list as Policies are not currently supported</div>
       <div class="REFTYPES">
<span class="bold_code"> Reason = cert_expired | invalid_issuer | invalid_signature | name_not_permitted |
       missing_basic_constraint | invalid_key_usage | {revoked, crl_reason()} | atom()
       </span><br>
</div>
     </div>
<div class="REFBODY"><p>
       <p>
	 Performs a basic path validation according to
	 <span class="bold_code"><a href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280.</a></span>
	 However CRL validation is done separately by <span class="bold_code"><a href="#pkix_crls_validate-3">pkix_crls_validate/3 </a></span> and should be called
	 from the supplied <span class="code">verify_fun</span>
       </p>

       <dl>
	 <p> Available options are: </p>

	<dt><strong>{verify_fun, fun()}</strong></dt>
	<dd>
	  <p>The fun should be defined as:</p>

	  <div class="example"><pre>
fun(OtpCert :: #'OTPCertificate'{},
    Event :: {bad_cert, Reason :: atom() | {revoked, atom()}} |
             {extension, #'Extension'{}},
    InitialUserState :: term()) -&gt;
	{valid, UserState :: term()} |
	{valid_peer, UserState :: term()} |
	{fail, Reason :: term()} |
	{unknown, UserState :: term()}.
	  </pre></div>

	<p>If the verify callback fun returns {fail, Reason}, the
	verification process is immediately stopped. If the verify
	callback fun returns {valid, UserState}, the verification
	process is continued, this can be used to accept specific path
	validation errors such as <span class="code">selfsigned_peer</span> as well as
	verifying application specific extensions.  If called with an
	extension unknown to the user application the return value
	{unknown, UserState} should be used.</p>

	</dd>
	<dt><strong>{max_path_length, integer()}</strong></dt>
	<dd>
	  The <span class="code">max_path_length</span> is the maximum number of non-self-issued
	  intermediate certificates that may follow the peer certificate
	  in a valid certification path.  So if <span class="code">max_path_length</span> is 0 the PEER must
	  be signed by the trusted ROOT-CA directly, if 1 the path can
	  be PEER, CA, ROOT-CA, if it is 2 PEER, CA, CA, ROOT-CA and so
	  on.
	</dd>
      </dl>

      <p> Possible reasons for a bad certificate are: </p>
      <dl>
	<dt><strong>cert_expired</strong></dt>
	<dd>The certificate is no longer valid as its expiration date has passed.</dd>

	<dt><strong>invalid_issuer</strong></dt>
	<dd>The certificate issuer name does not match the name of the issuer certificate in the chain.</dd>

	<dt><strong>invalid_signature</strong></dt>
	<dd>The certificate was not signed by its issuer certificate in the chain.</dd>

	<dt><strong>name_not_permitted</strong></dt>
	<dd>Invalid Subject Alternative Name extension.</dd>

	<dt><strong>missing_basic_constraint</strong></dt>
	<dd>Certificate, required to have the basic constraints extension, does not have
	a basic constraints extension.</dd>

	<dt><strong>invalid_key_usage</strong></dt>
	<dd>Certificate key is used in an invalid way according to the key usage extension.</dd>

	<dt><strong>{revoked, crl_reason()}</strong></dt>
	<dd>Certificate has been revoked.</dd>

	<dt><strong>atom()</strong></dt>
	<dd>Application specific error reason that should be checked by the verify_fun</dd>
      </dl>

    </p></div>

    <p><a name="pkix_crl_issuer-1"><span class="bold_code">pkix_crl_issuer(CRL) -&gt; issuer_name()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">CRL = der_encoded() | #'CertificateList'{} </span><br>
</div> 
      </div>
<div class="REFBODY"><p> 
	<p>Returns the issuer of the <span class="code">CRL</span>.</p>
      </p></div> 
   
   <p><a name="pkix_crls_validate-3"><span class="bold_code">pkix_crls_validate(OTPCertificate, DPAndCRLs, Options) -&gt; CRLStatus()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code"> OTPCertificate =  #'OTPCertificate'{}</span><br>
</div>
       <div class="REFTYPES">
<span class="bold_code"> DPAndCRLs  = [{DP::#'DistributionPoint'{}, {DerCRL::der_encoded(), CRL::#'CertificateList'{}}}] </span><br>
</div>
       <div class="REFTYPES">
<span class="bold_code"> Options = proplists:proplist()</span><br>
</div>
       <div class="REFTYPES">
<span class="bold_code"> CRLStatus() =  valid | {bad_cert, revocation_status_undetermined} |
       {bad_cert, {revoked, crl_reason()}}</span><br>
</div>
     </div>
<div class="REFBODY"><p>
      <p> Performs CRL validation. It is intended to be called from
      the verify fun of  <span class="bold_code"><a href="#pkix_path_validation-3"> pkix_path_validation/3
       </a></span></p>
      <dl>
	<p> Available options are: </p>
	<dt><strong>{update_crl, fun()}</strong></dt>
	<dd>
	  <p>The fun has the following type spec:</p>

	  <div class="example"><pre> fun(#'DistributionPoint'{}, #'CertificateList'{}) -&gt;
        #'CertificateList'{}</pre></div>

	  <p>The fun should use the information in the distribution point to acesses
	  the lates possible version of the CRL. If this fun is not specified
	  public_key will use the default implementation:
	  </p>
	  <div class="example"><pre> fun(_DP, CRL) -&gt; CRL end</pre></div>
	</dd>

	<dt><strong>{issuer_fun, fun()}</strong></dt>
	<dd>
	  <p>The fun has the following type spec:</p>

	  <div class="example"><pre>
fun(#'DistributionPoint'{}, #'CertificateList'{},
    {rdnSequence,[#'AttributeTypeAndValue'{}]}, term()) -&gt;
	{ok, #'OTPCertificate'{}, [der_encoded]}</pre></div>

	  <p>The fun should return the root certificate and certificate chain
	  that has signed the CRL. 
	  </p>
	  <div class="example"><pre> fun(DP, CRL, Issuer, UserState) -&gt; {ok, RootCert, CertChain}</pre></div>
	</dd>	
      </dl>
    </p></div>
   
   <p><a name="pkix_crl_verify-2"><span class="bold_code">pkix_crl_verify(CRL, Cert) -&gt; boolean()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code">CRL = der_encoded() | #'CertificateList'{} </span><br>
</div> 
       <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded() | #'OTPCertificate'{} </span><br>
</div> 
     </div>
<div class="REFBODY"><p> 
       <p>Verify that <span class="code">Cert</span> is the <span class="code">CRL</span> signer.</p>
     </p></div>

   <p><a name="pkix_dist_point-1"><span class="bold_code">pkix_dist_point(Cert) -&gt; DistPoint</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code"> Cert  = der_encoded() | #'OTPCertificate'{} </span><br>
</div> 
       <div class="REFTYPES">
<span class="bold_code"> DistPoint =  #'DistributionPoint'{}</span><br>
</div> 
     </div>
<div class="REFBODY"><p> 
       <p>Creates a distribution point for CRLs issued by the same issuer as <span class="code">Cert</span>.
       Can be used as input to <span class="bold_code"><a href="#pkix_crls_validate-3">pkix_crls_validate/3 </a></span>
       </p>
     </p></div>
   
   <p><a name="pkix_dist_points-1"><span class="bold_code">pkix_dist_points(Cert) -&gt; DistPoints</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code"> Cert  = der_encoded() | #'OTPCertificate'{} </span><br>
</div> 
       <div class="REFTYPES">
<span class="bold_code"> DistPoints =  [#'DistributionPoint'{}]</span><br>
</div> 
     </div>
<div class="REFBODY"><p> 
       <p> Extracts distribution points from the certificates extensions.</p>
     </p></div>
   
  <p><a name="pkix_sign-2"><span class="bold_code">pkix_sign(#'OTPTBSCertificate'{}, Key) -&gt; der_encoded()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_public_key() | dsa_public_key()</span><br>
</div> 
    </div>
<div class="REFBODY"><p> 
      <p>Signs a 'OTPTBSCertificate'. Returns the corresponding
      der encoded certificate.</p> 
    </p></div> 

  <p><a name="pkix_sign_types-1"><span class="bold_code">pkix_sign_types(AlgorithmId) -&gt; {DigestType, SignatureType}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">AlgorithmId = oid()</span><br>
</div>
      <div class="REFBODY">Signature oid from a certificate or a certificate revocation list</div>
      <div class="REFTYPES">
<span class="bold_code">DigestType = rsa_digest_type() | dss_digest_type() </span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">SignatureType = rsa | dsa</span><br>
</div>
    </div>
<div class="REFBODY"><p>
      <p>Translates signature algorithm oid to erlang digest and signature types.
      </p>
    </p></div>

  <p><a name="pkix_verify-2"><span class="bold_code">pkix_verify(Cert, Key) -&gt; boolean()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Cert = der_encoded()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_public_key() | dsa_public_key()</span><br>
</div> 
    </div>
<div class="REFBODY"><p> 
    <p> Verify PKIX x.509 certificate signature.</p>
  </p></div> 

  <p><a name="sign-3"><span class="bold_code">sign(Msg, DigestType, Key) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
       <div class="REFTYPES">
<span class="bold_code">Msg = binary() | {digest,binary()}</span><br>
</div>
       <div class="REFBODY">The msg is either the binary "plain text" data to be
       signed or it is the hashed value of "plain text" i.e. the
       digest.</div>
       <div class="REFTYPES">
<span class="bold_code">DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</span><br>
</div>
       <div class="REFTYPES">
<span class="bold_code">Key = rsa_private_key() | dsa_private_key() | ec_private_key()</span><br>
</div>
  </div>
<div class="REFBODY"><p>
    <p> Creates a digital signature.</p> 
  </p></div>   

  <p><a name="ssh_decode-2"><span class="bold_code">ssh_decode(SshBin,  Type) -&gt; [{public_key(), Attributes::list()}]</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">SshBin = binary()</span><br>
</div>
      <div class="REFBODY">Example {ok, SshBin} = file:read_file("known_hosts").</div>
      <div class="REFTYPES">
<span class="bold_code"> Type = public_key | ssh_file()</span><br>
</div>
      <div class="REFBODY">If <span class="code">Type</span> is <span class="code">public_key</span> the binary may be either
      a rfc4716 public key or a openssh public key.</div>
    </div>
<div class="REFBODY"><p>
    <p> Decodes a ssh file-binary. In the case of know_hosts or
    auth_keys the binary may include one or more lines of the
    file. Returns a list of public keys and their attributes, possible
    attribute values depends on the file type represented by the
    binary.
    </p>

    <dl>
      <dt><strong>rfc4716 attributes - see RFC 4716</strong></dt>
      <dd>{headers, [{string(), utf8_string()}]}</dd>
      <dt><strong>auth_key attributes - see man sshd </strong></dt>
      <dd>{comment, string()}</dd>
      <dd>{options, [string()]}</dd>
      <dd>{bits, integer()} - In ssh version 1 files</dd>
      <dt><strong>known_host attributes - see man sshd</strong></dt>
      <dd>{hostnames, [string()]}</dd>
      <dd>{comment, string()}</dd>
      <dd>{bits, integer()} - In ssh version 1 files</dd>
    </dl>

  </p></div>

  <p><a name="ssh_encode-2"><span class="bold_code">ssh_encode([{Key, Attributes}], Type) -&gt; binary()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Key = public_key()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Attributes = list()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Type = ssh_file()</span><br>
</div>
    </div>
<div class="REFBODY"><p>
    <p>Encodes a list of ssh file entries (public keys and attributes) to a binary. Possible
    attributes depends on the file type, see <span class="bold_code"><a href="#ssh_decode-2"> ssh_decode/2 </a></span></p>
  </p></div>

  <p><a name="verify-4"><span class="bold_code">verify(Msg, DigestType, Signature, Key) -&gt; boolean()</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
      <div class="REFTYPES">
<span class="bold_code">Msg = binary() | {digest,binary()}</span><br>
</div>
       <div class="REFBODY">The msg is either the binary "plain text" data 
        or it is the hashed value of "plain text" i.e. the digest.</div>
      <div class="REFTYPES">
<span class="bold_code">DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Signature = binary()</span><br>
</div>
      <div class="REFTYPES">
<span class="bold_code">Key = rsa_public_key() | dsa_public_key() | ec_public_key()</span><br>
</div>
  </div>
<div class="REFBODY"><p>
    <p>Verifies a digital signature</p>
  </p></div>
  


</div>
<div class="footer">
<hr>
<p>Copyright © 2008-2015 Ericsson AB, All Rights Reserved</p>
</div>
</div>
</div></body>
</html>
