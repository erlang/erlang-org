<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- int</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="../apps/debugger/users_guide.html">User's Guide</a><br><a href="../apps/debugger/index.html">Reference Manual</a><br><a href="../apps/debugger/release_notes.html">Release Notes</a><br><a href="../apps/debugger/debugger.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Debugger</strong><br><strong>Reference Manual</strong><br><small>Version 4.0.3</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Table of Contents</strong></small></p>
<ul class="flipMenu">
<li id="no" title="debugger " expanded="false">debugger<ul>
<li><a href="debugger.html">
                  Top of manual page
                </a></li>
<li title="start-0"><a href="debugger.html#start-0">start/0</a></li>
<li title="start-1"><a href="debugger.html#start-1">start/1</a></li>
<li title="start-1"><a href="debugger.html#start-1">start/1</a></li>
<li title="start-2"><a href="debugger.html#start-2">start/2</a></li>
<li title="quick-3"><a href="debugger.html#quick-3">quick/3</a></li>
</ul>
</li>
<li id="no" title="i " expanded="false">i<ul>
<li><a href="i.html">
                  Top of manual page
                </a></li>
<li title="im-0"><a href="i.html#im-0">im/0</a></li>
<li title="ii-1"><a href="i.html#ii-1">ii/1</a></li>
<li title="ii-1"><a href="i.html#ii-1">ii/1</a></li>
<li title="ini-1"><a href="i.html#ini-1">ini/1</a></li>
<li title="ini-1"><a href="i.html#ini-1">ini/1</a></li>
<li title="iq-1"><a href="i.html#iq-1">iq/1</a></li>
<li title="inq-1"><a href="i.html#inq-1">inq/1</a></li>
<li title="il-0"><a href="i.html#il-0">il/0</a></li>
<li title="ip-0"><a href="i.html#ip-0">ip/0</a></li>
<li title="ic-0"><a href="i.html#ic-0">ic/0</a></li>
<li title="iaa-1"><a href="i.html#iaa-1">iaa/1</a></li>
<li title="iaa-2"><a href="i.html#iaa-2">iaa/2</a></li>
<li title="ist-1"><a href="i.html#ist-1">ist/1</a></li>
<li title="ia-1"><a href="i.html#ia-1">ia/1</a></li>
<li title="ia-3"><a href="i.html#ia-3">ia/3</a></li>
<li title="ia-2"><a href="i.html#ia-2">ia/2</a></li>
<li title="ia-4"><a href="i.html#ia-4">ia/4</a></li>
<li title="ib-2"><a href="i.html#ib-2">ib/2</a></li>
<li title="ib-3"><a href="i.html#ib-3">ib/3</a></li>
<li title="ir-0"><a href="i.html#ir-0">ir/0</a></li>
<li title="ir-1"><a href="i.html#ir-1">ir/1</a></li>
<li title="ir-2"><a href="i.html#ir-2">ir/2</a></li>
<li title="ir-3"><a href="i.html#ir-3">ir/3</a></li>
<li title="ibd-2"><a href="i.html#ibd-2">ibd/2</a></li>
<li title="ibe-2"><a href="i.html#ibe-2">ibe/2</a></li>
<li title="iba-3"><a href="i.html#iba-3">iba/3</a></li>
<li title="ibc-3"><a href="i.html#ibc-3">ibc/3</a></li>
<li title="ipb-0"><a href="i.html#ipb-0">ipb/0</a></li>
<li title="ipb-1"><a href="i.html#ipb-1">ipb/1</a></li>
<li title="iv-0"><a href="i.html#iv-0">iv/0</a></li>
<li title="help-0"><a href="i.html#help-0">help/0</a></li>
</ul>
</li>
<li id="loadscrollpos" title="int " expanded="true">int<ul>
<li><a href="int.html">
                  Top of manual page
                </a></li>
<li title="i-1"><a href="int.html#i-1">i/1</a></li>
<li title="i-1"><a href="int.html#i-1">i/1</a></li>
<li title="ni-1"><a href="int.html#ni-1">ni/1</a></li>
<li title="ni-1"><a href="int.html#ni-1">ni/1</a></li>
<li title="n-1"><a href="int.html#n-1">n/1</a></li>
<li title="nn-1"><a href="int.html#nn-1">nn/1</a></li>
<li title="interpreted-0"><a href="int.html#interpreted-0">interpreted/0</a></li>
<li title="file-1"><a href="int.html#file-1">file/1</a></li>
<li title="interpretable-1"><a href="int.html#interpretable-1">interpretable/1</a></li>
<li title="auto_attach-0"><a href="int.html#auto_attach-0">auto_attach/0</a></li>
<li title="auto_attach-1"><a href="int.html#auto_attach-1">auto_attach/1</a></li>
<li title="auto_attach-2"><a href="int.html#auto_attach-2">auto_attach/2</a></li>
<li title="stack_trace-0"><a href="int.html#stack_trace-0">stack_trace/0</a></li>
<li title="stack_trace-1"><a href="int.html#stack_trace-1">stack_trace/1</a></li>
<li title="break-2"><a href="int.html#break-2">break/2</a></li>
<li title="delete_break-2"><a href="int.html#delete_break-2">delete_break/2</a></li>
<li title="break_in-3"><a href="int.html#break_in-3">break_in/3</a></li>
<li title="del_break_in-3"><a href="int.html#del_break_in-3">del_break_in/3</a></li>
<li title="no_break-0"><a href="int.html#no_break-0">no_break/0</a></li>
<li title="no_break-1"><a href="int.html#no_break-1">no_break/1</a></li>
<li title="disable_break-2"><a href="int.html#disable_break-2">disable_break/2</a></li>
<li title="enable_break-2"><a href="int.html#enable_break-2">enable_break/2</a></li>
<li title="action_at_break-3"><a href="int.html#action_at_break-3">action_at_break/3</a></li>
<li title="test_at_break-3"><a href="int.html#test_at_break-3">test_at_break/3</a></li>
<li title="get_binding-2"><a href="int.html#get_binding-2">get_binding/2</a></li>
<li title="all_breaks-0"><a href="int.html#all_breaks-0">all_breaks/0</a></li>
<li title="all_breaks-1"><a href="int.html#all_breaks-1">all_breaks/1</a></li>
<li title="snapshot-0"><a href="int.html#snapshot-0">snapshot/0</a></li>
<li title="clear-0"><a href="int.html#clear-0">clear/0</a></li>
<li title="continue-1"><a href="int.html#continue-1">continue/1</a></li>
<li title="continue-3"><a href="int.html#continue-3">continue/3</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<!-- refpage --><center><h1>int</h1></center>
  
  <h3>MODULE</h3>
<div class="REFBODY">int</div>
  <h3>MODULE SUMMARY</h3>
<div class="REFBODY">Interpreter Interface</div>
  <h3>DESCRIPTION</h3>
<div class="REFBODY"><p>
    <p>The Erlang interpreter provides mechanisms for breakpoints and
      stepwise execution of code. It is mainly intended to be used by
      the <strong>Debugger</strong>, see Debugger User's Guide and
      <span class="code">debugger(3)</span>.</p>
    
    <p>From the shell, it is possible to:</p>
    <ul>
      <li>Specify which modules should be interpreted.</li>
      <li>Specify breakpoints.</li>
      <li>Monitor the current status of all processes executing code
	in interpreted modules, also processes at other Erlang nodes.
      </li>
    </ul>

    <p>By <strong>attaching to</strong> a process executing interpreted code, it
      is possible to examine variable bindings and order stepwise
      execution. This is done by sending and receiving information
      to/from the process via a third process, called the meta process.
      It is possible to implement your own attached process. See
      <span class="code">int.erl</span> for available functions and <span class="code">dbg_wx_trace.erl</span>
      for possible messages.</p>

    <p>The interpreter depends on the Kernel, STDLIB and GS
      applications, which means modules belonging to any of these
      applications are not allowed to be interpreted as it could lead
      to a deadlock or emulator crash. This also applies to modules
      belonging to the Debugger application itself.</p>
  </p></div>

  <h3><a name="id62012">Breakpoints</a></h3>
<div class="REFBODY">
    

    <p>Breakpoints are specified on a line basis. When a process
      executing code in an interpreted module reaches a breakpoint, it
      will stop. This means that that a breakpoint must be set at an
      executable line, that is, a line of code containing an executable
      expression.</p>

    <p>A breakpoint have a status, a trigger action and may have a
      condition associated with it. The status is either <strong>active</strong>
      or <strong>inactive</strong>. An inactive breakpoint is ignored. When a
      breakpoint is reached, the trigger action specifies if
      the breakpoint should continue to be active (<strong>enable</strong>), if
      it should become inactive (<strong>disable</strong>), or if it should be
      removed (<strong>delete</strong>). A condition is a tuple
      <span class="code">{Module,Name}</span>. When the breakpoint is reached,
      <span class="code">Module:Name(Bindings)</span> is called. If this evaluates to
      <span class="code">true</span>, execution will stop. If this evaluates to
      <span class="code">false</span>, the breakpoint is ignored. <span class="code">Bindings</span> contains
      the current variable bindings, use <span class="code">get_binding</span> to retrieve
      the value for a given variable.</p>

    <p>By default, a breakpoint is active, has trigger action
      <span class="code">enable</span> and has no condition associated with it. For more
      detailed information about breakpoints, refer to Debugger User's
      Guide.</p>
  </div>

  <h3>EXPORTS</h3>
    <p><a name="i-1"><span class="bold_code">i(AbsModule) -&gt; {module,Module} | error</span></a><br><a name="i-1"><span class="bold_code">i(AbsModules) -&gt; ok</span></a><br><a name="ni-1"><span class="bold_code">ni(AbsModule) -&gt; {module,Module} | error</span></a><br><a name="ni-1"><span class="bold_code">ni(AbsModules) -&gt; ok</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">AbsModules = [AbsModule]</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">AbsModule = Module | File | [Module | File]</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> Module = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> File = string()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Interprets the specified module(s). <span class="code">i/1</span> interprets
	  the module only at the current node. <span class="code">ni/1</span> interprets
	  the module at all known nodes.</p>

	<p>A module may be given by its module name (atom) or by its
	  file name. If given by its module name, the object code
	  <span class="code">Module.beam</span> is searched for in the current path.
	  The source code <span class="code">Module.erl</span> is searched for first in
	  the same directory as the object code, then in a <span class="code">src</span>
	  directory next to it.</p>

	<p>If given by its file name, the file name may include a path
	  and the <span class="code">.erl</span> extension may be omitted. The object code
	  <span class="code">Module.beam</span> is searched for first in the same directory
	  as the source code, then in an <span class="code">ebin</span> directory next to
	  it, and then in the current path.</p>

	<div class="note">
<div class="label">Note</div>
<div class="content"><p>
	  <p>The interpreter needs both the source code and the object
	    code, and the object code <strong>must</strong> include debug
	    information. That is, only modules compiled with the option
	    <span class="code">debug_info</span> set can be interpreted.</p>
	</p></div>
</div>

	<p>The functions returns <span class="code">{module,Module}</span> if the module
	  was interpreted, or <span class="code">error</span> if it was not.</p>

	<p>The argument may also be a list of modules/file names, in
	  which case the function tries to interpret each module as
	  specified above. The function then always returns <span class="code">ok</span>,
	  but prints some information to stdout if a module could not be
	  interpreted.</p>
      </p></div>
	
    <p><a name="n-1"><span class="bold_code">n(AbsModule) -&gt; ok</span></a><br><a name="nn-1"><span class="bold_code">nn(AbsModule) -&gt; ok</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">AbsModule = Module | File | [Module | File]</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> Module = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> File = string()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Stops interpreting the specified module. <span class="code">n/1</span> stops
	  interpreting the module only at the current node. <span class="code">nn/1</span>
	  stops interpreting the module at all known nodes.</p>

	<p>As for <span class="code">i/1</span> and <span class="code">ni/1</span>, a module may be given by
	  either its module name or its file name.</p>
      </p></div>

    <p><a name="interpreted-0"><span class="bold_code">interpreted() -&gt; [Module]</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Module = atom()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Returns a list with all interpreted modules.</p>
      </p></div>

    <p><a name="file-1"><span class="bold_code">file(Module) -&gt; File | {error,not_loaded}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Module = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">File = string()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Returns the source code file name <span class="code">File</span> for an
	  interpreted module <span class="code">Module</span>.</p>
      </p></div>

    <p><a name="interpretable-1"><span class="bold_code">interpretable(AbsModule) -&gt; true | {error,Reason}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">AbsModule = Module | File</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> Module = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> File = string()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Reason = no_src | no_beam | no_debug_info | badarg
	  | {app,App}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> App = atom()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Checks if a module is possible to interpret. The module can
	  be given by its module name <span class="code">Module</span> or its source file
	  name <span class="code">File</span>. If given by a module name, the module is
	  searched for in the code path.</p>

	<p>The function returns <span class="code">true</span> if both source code and
	  object code for the module is found, the module has been
	  compiled with the option <span class="code">debug_info</span> set and does not
	  belong to any of the applications Kernel, STDLIB, GS or
	  Debugger itself.</p>

	<p>The function returns <span class="code">{error,Reason}</span> if the module for
	  some reason is not possible to interpret.</p>
	
	<p><span class="code">Reason</span> is <span class="code">no_src</span> if no source code is found or
	  <span class="code">no_beam</span> if no object code is found. It is assumed that
	  the source- and object code are located either in the same
	  directory, or in <span class="code">src</span> and <span class="code">ebin</span> directories next
	  to each other.</p>

	<p><span class="code">Reason</span> is <span class="code">no_debug_info</span> if the module has not
	  been compiled with the option <span class="code">debug_info</span> set.</p>

	<p><span class="code">Reason</span> is <span class="code">badarg</span> if <span class="code">AbsModule</span> is not
	  found. This could be because the specified file does not
	  exist, or because <span class="code">code:which/1</span> does not return a
	  beam file name, which is the case not only for non-existing
	  modules but also for modules which are preloaded or cover
	  compiled.</p>

	<p><span class="code">Reason</span> is <span class="code">{app,App}</span> where <span class="code">App</span> is
	  <span class="code">kernel</span>, <span class="code">stdlib</span>, <span class="code">gs</span> or <span class="code">debugger</span> if
	  <span class="code">AbsModule</span> belongs to one of these applications.</p>

	<p>Note that the function can return <span class="code">true</span> for a module
	  which in fact is not interpretable in the case where
	  the module is marked as sticky or resides in a directory
	  marked as sticky, as this is not discovered until
	  the interpreter actually tries to load the module.</p>
      </p></div>

    <p><a name="auto_attach-0"><span class="bold_code">auto_attach() -&gt; false | {Flags,Function}</span></a><br><a name="auto_attach-1"><span class="bold_code">auto_attach(false)</span></a><br><a name="auto_attach-2"><span class="bold_code">auto_attach(Flags, Function)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Flags = [init | break | exit]</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Function = {Module,Name,Args}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> Module = Name = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> Args = [term()]</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Gets and sets when and how to automatically attach to a
	  process executing code in interpreted modules. <span class="code">false</span>
	  means never automatically attach, this is the default.
	  Otherwise automatic attach is defined by a list of flags and
	  a function. The following flags may be specified:</p>
	<ul>
	  <li>
<span class="code">init</span> - attach when a process for the very first
	    time calls an interpreted function.</li>
	  <li>
<span class="code">break</span> - attach whenever a process reaches a
	    breakpoint.</li>
	  <li>
<span class="code">exit</span> - attach when a process terminates.</li>
	</ul>

	<p>When the specified event occurs, the function <span class="code">Function</span>
	  will be called as:</p>
	<div class="example"><pre>
spawn(Module, Name, [Pid | Args])
	</pre></div>
	<p><span class="code">Pid</span> is the pid of the process executing interpreted
	  code.</p>
      </p></div>

    <p><a name="stack_trace-0"><span class="bold_code">stack_trace() -&gt; Flag</span></a><br><a name="stack_trace-1"><span class="bold_code">stack_trace(Flag)</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Flag = all | no_tail | false</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Gets and sets how to save call frames in the stack. Saving
	  call frames makes it possible to inspect the call chain of a
	  process, and is also used to emulate the stack trace if an
	  error (an exception of class error) occurs.</p>
	<ul>
	  <li>
<span class="code">all</span> - save information about all current calls,
	    that is, function calls that have not yet returned a value.
	    </li>
	  <li>
<span class="code">no_tail</span> - save information about current calls,
	    but discard previous information when a tail recursive call
	    is made. This option consumes less memory and may be
	    necessary to use for processes with long lifetimes and many
	    tail recursive calls. This is the default.</li>
	  <li>
<span class="code">false</span> - do not save any information about current
	    calls.</li>
	</ul>
      </p></div>

    <p><a name="break-2"><span class="bold_code">break(Module, Line) -&gt; ok | {error,break_exists}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Module = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Line = int()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Creates a breakpoint at <span class="code">Line</span> in <span class="code">Module</span>.</p>
      </p></div>

    <p><a name="delete_break-2"><span class="bold_code">delete_break(Module, Line) -&gt; ok</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Module = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Line = int()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Deletes the breakpoint located at <span class="code">Line</span> in
	  <span class="code">Module</span>.</p>
      </p></div>

    <p><a name="break_in-3"><span class="bold_code">break_in(Module, Name, Arity) -&gt; ok
	| {error,function_not_found}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Module = Name = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Arity = int()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Creates a breakpoint at the first line of every clause of 
	  the <span class="code">Module:Name/Arity</span> function.</p>
      </p></div>

    <p><a name="del_break_in-3"><span class="bold_code">del_break_in(Module, Name, Arity) -&gt; ok
	| {error,function_not_found}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Module = Name = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Arity = int()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Deletes the breakpoints at the first line of every clause of 
	  the <span class="code">Module:Name/Arity</span> function.
	</p>
      </p></div>

    <p><a name="no_break-0"><span class="bold_code">no_break() -&gt; ok</span></a><br><a name="no_break-1"><span class="bold_code">no_break(Module) -&gt; ok</span></a><br></p>
<div class="REFBODY"><p>
	<p>Deletes all breakpoints, or all breakpoints in <span class="code">Module</span>.
	</p>
      </p></div>

    <p><a name="disable_break-2"><span class="bold_code">disable_break(Module, Line) -&gt; ok</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Module = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Line = int()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Makes the breakpoint at <span class="code">Line</span> in <span class="code">Module</span>
	  inactive.</p>
      </p></div>

    <p><a name="enable_break-2"><span class="bold_code">enable_break(Module, Line) -&gt; ok</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Module = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Line = int()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Makes the breakpoint at <span class="code">Line</span> in <span class="code">Module</span> active.
	</p>
      </p></div>

    <p><a name="action_at_break-3"><span class="bold_code">action_at_break(Module, Line, Action) -&gt; ok</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Module = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Line = int()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Action = enable | disable | delete</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Sets the trigger action of the breakpoint at <span class="code">Line</span> in
	  <span class="code">Module</span> to <span class="code">Action</span>.</p>
      </p></div>

    <p><a name="test_at_break-3"><span class="bold_code">test_at_break(Module, Line, Function) -&gt; ok</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Module = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Line = int()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Function = {Module,Name}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> Name = atom()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Sets the conditional test of the breakpoint at <span class="code">Line</span> in
	  <span class="code">Module</span> to <span class="code">Function</span>. The function must
	  fulfill the requirements specified in the section
	  <strong>Breakpoints</strong> above.</p>
      </p></div>

    <p><a name="get_binding-2"><span class="bold_code">get_binding(Var, Bindings) -&gt; {value,Value} | unbound</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Var = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Bindings = term()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">Value = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Retrieves the binding of <span class="code">Var</span>. This function is
	  intended to be used by the conditional function of a
	  breakpoint.</p>
      </p></div>

    <p><a name="all_breaks-0"><span class="bold_code">all_breaks() -&gt; [Break]</span></a><br><a name="all_breaks-1"><span class="bold_code">all_breaks(Module) -&gt; [Break]</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Break = {Point,Options}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> Point = {Module,Line}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">  Module = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">  Line = int()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> Options = [Status,Trigger,null,Cond|]</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">  Status = active | inactive</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">  Trigger = enable | disable | delete</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">  Cond = null | Function</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">   Function = {Module,Name}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">    Name = atom()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Gets all breakpoints, or all breakpoints in <span class="code">Module</span>.
	</p>
      </p></div>

    <p><a name="snapshot-0"><span class="bold_code">snapshot() -&gt; [Snapshot]</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Snapshot = {Pid, Function, Status, Info}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> Pid = pid()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> Function = {Module,Name,Args}</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">  Module = Name = atom()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">  Args = [term()]</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> Status = idle | running | waiting | break | exit
	  | no_conn</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code"> Info = {} | {Module,Line} | ExitReason</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">  Line = int()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">  ExitReason = term()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Gets information about all processes executing interpreted code.
	</p>
	<ul>
	  <li>
<span class="code">Pid</span> - process identifier.</li>
	  <li>
<span class="code">Function</span> - first interpreted function called by
	    the process.</li>
	  <li>
<span class="code">Status</span> - current status of the process.</li>
	  <li>
<span class="code">Info</span> - additional information.</li>
	</ul>
	<p><span class="code">Status</span> is one of:</p>
	<ul>
	  <li>
<span class="code">idle</span> - the process is no longer executing
	    interpreted code. <span class="code">Info={}</span>.</li>
	  <li>
<span class="code">running</span> - the process is running. <span class="code">Info={}</span>.
	  </li>
	  <li>
<span class="code">waiting</span> - the process is waiting at a
	    <span class="code">receive</span>. <span class="code">Info={}</span>.</li>
	  <li>
<span class="code">break</span> - process execution has been stopped,
	    normally at a breakpoint. <span class="code">Info={Module,Line}</span>.</li>
	  <li>
<span class="code">exit</span> - the process has terminated.
	    <span class="code">Info=ExitReason</span>.</li>
	  <li>
<span class="code">no_conn</span> - the connection is down to the node
	    where the process is running. <span class="code">Info={}</span>.</li>
	</ul>
      </p></div>

    <p><a name="clear-0"><span class="bold_code">clear() -&gt; ok</span></a><br></p>
<div class="REFBODY"><p>
	<p>Clears information about processes executing interpreted code
	  by removing all information about terminated processes.</p>
      </p></div>

    <p><a name="continue-1"><span class="bold_code">continue(Pid) -&gt; ok | {error,not_interpreted}</span></a><br><a name="continue-3"><span class="bold_code">continue(X,Y,Z) -&gt; ok | {error,not_interpreted}</span></a><br></p>
<div class="REFBODY">
<p>Types:</p>
	<div class="REFTYPES">
<span class="bold_code">Pid = pid()</span><br>
</div>
	<div class="REFTYPES">
<span class="bold_code">X = Y = Z = int()</span><br>
</div>
      </div>
<div class="REFBODY"><p>
	<p>Resume process execution for <span class="code">Pid</span>, or for
	  <span class="code">c:pid(X,Y,Z)</span>.</p>
      </p></div>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2015 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
