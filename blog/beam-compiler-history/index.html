<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://beta.erlang.org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"A Brief History of the BEAM Compiler - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>A Brief History of the BEAM Compiler - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://beta.erlang.org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://beta.erlang.org/blog.xml" />
    
    <link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/"><img
                    src="/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="get" action="https://duckduckgo.com/">
                    <input type="hidden" name="sites" value="erlang.org">
                    <input class="form-control me-2" id="searchfield" name="q" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-8 offset-lg-2">
            <article class="card mb-4">
    <div class="card-header">
        <h3><a href="/blog/beam-compiler-history/">A Brief History of the BEAM Compiler</a></h3>
        <div class="date">June 18, 2018
             · by Björn Gustavsson
        </div>
    </div>

    <div class="card-body">
        
        
        
        <p>This blog post is a brief history lesson about the Erlang compiler for
the BEAM machine. To provide some context, there will first be a quick
look at the abstract machines for Erlang.</p>
      <h2 id="a-brief-overview-of-the-early-erlang-implementations">
        
        
          A brief overview of the early Erlang implementations <a href="#a-brief-overview-of-the-early-erlang-implementations">#</a>
        
        
      </h2>
    
      <h3 id="the-prolog-interpreter">
        
        
          The Prolog interpreter <a href="#the-prolog-interpreter">#</a>
        
        
      </h3>
    

<p>The first version of Erlang was implemented in
Prolog in 1986. That version of Erlang was used
to find out which features of the languages were
useful and which were not. New languages features
could be added or deleted in a matter of hours
or days.</p>
      <h3 id="jam-joes-abstract-machine">
        
        
          JAM (Joe’s Abstract Machine) <a href="#jam-joes-abstract-machine">#</a>
        
        
      </h3>
    

<p>It soon became clear that Erlang needed to be at
least 40 times faster to be useful in real projects.</p>

<p>In 1989 JAM (Joe’s Abstract Machine) was first
implemented. <a href="http://www.erlang-factory.com/conference/ErlangUserConference2013/speakers/MikeWilliams">Mike Williams</a> wrote the runtime system
in C, <a href="https://github.com/joearms">Joe Armstrong</a> wrote the compiler, and
<a href="https://github.com/rvirding">Robert Virding</a> wrote the libraries.</p>

<p>JAM turned out be 70 times faster than the Prolog
interpreter. Success?</p>
      <h3 id="team-turbo-erlang-abstract-machine">
        
        
          TEAM (Turbo Erlang Abstract Machine) <a href="#team-turbo-erlang-abstract-machine">#</a>
        
        
      </h3>
    

<p>It soon became clear that Erlang still needed
to be faster to be useful in real projects.</p>

<p>Therefore Bogumil (“Bogdan”) Hausman created TEAM (Turbo Erlang
Abstract Machine). It compiled the Erlang code to C code, which was
then compiled to native code using GCC.</p>

<p>It was significantly faster than JAM for small projects.
Unfortunately, compilation was very slow, and the code size of the
compiled code was too big to make it useful for large projects.</p>
      <h3 id="beam-bogdans-erlang-abstract-machine">
        
        
          BEAM (Bogdan’s Erlang Abstract Machine) <a href="#beam-bogdans-erlang-abstract-machine">#</a>
        
        
      </h3>
    

<p>Bogumil Hausman next machine was called BEAM
(Bogdan’s Erlang Abstract Machine). It was a hybrid machine
that could execute both native code and <a href="https://en.wikipedia.org/wiki/Threaded_code">threaded code</a> with
an <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreter</a>. That allowed customers to compile their
time-critial modules to native code and all other modules to
threaded BEAM code. The threaded BEAM in itself was faster
than JAM code.</p>

<p>Bogdan’s original compiler for BEAM shared the compiler front end with
JAM. Essentially, the front end at that time did the same thing as the
front end in the current compiler as described in <a href="http://blog.erlang.org/compiler-lost-in-translation">Lost in Translation
(Exploring the Compiler’s Front End)</a>.</p>

<p>I don’t have the source code for Bodgan’s original compiler,
but as far as I can determine it had three compiler passes that
translated the abstract format to threaded BEAM code.</p>

<ul>
  <li>
    <p><code>beam_compile</code> - Translated the abstract format to BEAM instructions.</p>
  </li>
  <li>
    <p><code>beam_optimize</code> - Optimized the BEAM instructions. This pass was mandatory,
since it did some necessary transformations of the BEAM instructions.</p>
  </li>
  <li>
    <p><code>beam_asm</code> - Converted the symbolic BEAM assembly format to a binary
BEAM module.</p>
  </li>
</ul>
      <h3 id="vee-virdings-erlang-engine">
        
        
          VEE (Virding’s Erlang Engine) <a href="#vee-virdings-erlang-engine">#</a>
        
        
      </h3>
    

<p>Here we must mention VEE (Virding’s Erlang Engine) for reasons that
will soon become clear.</p>

<p>VEE was an experimental implementation with a different memory model
compared to JAM and BEAM. Instead of JAM’s and BEAM’s separate heaps
for each process, VEE used a single shared heap with a real-time
garbage collector.  That made message passing blindlingly fast
compared to JAM and BEAM.</p>

<p>Overall, though, there was no speed gain compared to JAM. The reason
was probably that the single shared heap decreased the cache hit
rate.</p>
      <h2 id="the-maturation-of-beam">
        
        
          The maturation of BEAM <a href="#the-maturation-of-beam">#</a>
        
        
      </h2>
    

<p>The OTP group and Erlang/OTP was created to industrialize Erlang and
make it suitable for huge real-world projects. The first release, OTP
R1B, was released in 1996.</p>

<p>This is the point where the history lesson may become a little bit
more subjective.</p>

<p>I joined the Erlang/OTP team at the end of 1996. My first small
code contributions to Erlang/OTP were included in OTP R1D.</p>

<p>I worked in the ERTS (Erlang Run-Time System) team, which at that time
was lead by Kenneth Lundin. Initially I worked with the Erlang runtime
system for Microsoft Windows. After some time (maybe a year or so),
Kenneth asked me to help stabilizing and improving BEAM. Gradually
BEAM become my main responsibility, and when Bogdan left Ericsson, I
become the main developer responsible for the BEAM <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreter</a> and
compiler.</p>

<p>This blog post desperately tries to cover the history of the BEAM
<em>compiler</em>, but I think that some more historical context is needed
before we can approach the compiler.</p>

<p>The overall goal of the work on BEAM from OTP R1 up to OTP R5
was to make it stable enough and fast enough to be useful in real
projects.</p>

<p>There were two major obstacles to reaching that goal:</p>

<ul>
  <li>BEAM/C, that is, native code via C code.</li>
  <li>The huge number of ever-changing BEAM instructions.</li>
</ul>
      <h3 id="beamc-must-die">
        
        
          BEAM/C must die! <a href="#beamc-must-die">#</a>
        
        
      </h3>
    

<p>It soon became obvious that BEAM/C, the compiler passes that
compiled Erlang code to C code, had to die. At the time that
I started working on BEAM, there were three distinct flavors of
BEAM/C: one for GCC on Sparc, one for GCC on non-sparc CPUs (such
as Intel x86), and one for other C compilers that did not support
GCC’s extension for taking the address of a label. Bugs not only showed
up in the native code, but the mere existence of BEAM/C complicated and
caused bugs in the threaded BEAM interpreter.</p>

<p>Unfortunately, early in my career of improving BEAM, I made some
optimizations of the size of the C code generated by BEAM/C. That came
back to bite me later when I suggested that we should remove
BEAM/C. The size improvements made it possible to fit more Erlang code
compiled to native code into the system, and the native code was
faster than threaded BEAM code. Our customer at the time (<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.9122&amp;rep=rep1&amp;type=pdf">the AXD 301
project</a>) needed the extra speed improvements that BEAM/C gave
them and did not allow us to remove BEAM/C unless we could improve the
performance of threaded BEAM code to similar or better than BEAM/C
performance.</p>
      <h3 id="the-ever-changing-beam-instructions">
        
        
          The ever-changing BEAM instructions <a href="#the-ever-changing-beam-instructions">#</a>
        
        
      </h3>
    

<p>At that time, the BEAM interpreter had over <a href="http://www.cs-lab.org/historical_beam_instruction_set.html">300
instructions</a>.  While JAM had a very simple loader that
essentially only loaded the JAM files into memory, the loader for BEAM
had to translate every instruction from the byte format in the BEAM
files to the threaded code format in memory.  The BEAM had
hand-written code for the loading of every single instruction.</p>

<p>To make it worse, the instruction set was constantly evolving. Bug
fixes and performance improvements needed new instructions, and those
instructions had to be implemented in the compiler, threaded code
interpreter (the <code>process_main()</code> function in <code>beam_emu.c</code>), and
the loader. In every minor and major release of Erlang/OTP, the
users of BEAM had to recompile all of their Erlang code
because the instruction set had changed.</p>

<p>There must be a better way, I thought. I started to write a simple
Perl script to a least automate the mapping from instruction name to
instruction number in the compiler, interpreter, and loader.
<a href="https://github.com/tonyrog">Tony Rogvall</a> suggested that I could be more ambitious and
generate most of the code for for the loader using the Perl script.
He also suggested that operands for many instructions could be packed
into a single word. That would reduce load code size and also improve
the cache hit rate, improving execution speed.</p>

<p>So I started writing the first version of the <a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md">beam_makeops script</a>
and rewriting the loader. I prefer to work incrementally, making minor changes
to a code base that is always working. But I could not rewrite the loader
incrementally, so I hacked away frantically for two or three days until
I had a bare bones version of the new loader working. I could then relax
a little and somewhat more slowly add more features to <code>beam_makeops</code> and
the loader.</p>

<p>The new loader took over some tasks formerly done by the compiler.</p>

<p>For example, the BEAM machine has several specialized <code>move</code>
instructions.  There is one instruction for moving something into an X
register, another for moving an atom into an X register, and so
on. Before the new loader, the compiler knew about all those variants
of <code>move</code> instructions and selected the appropriate one. With the new
loader, there is only one <code>move</code> instruction that the compiler needs
to care about, and the loader will select the appropriate specialized
<code>move</code> instruction to use at load time.</p>

<p>Another minor optimization done by the compiler was combining of
common instructions sequences. For example, a <code>move</code> instruction
followed by a <code>call</code> instruction would be combined to a <code>move_call</code>
instruction. That optimization was also moved to the loader.</p>

<p>All those capabilities made it possible to significantly simplify and
reduce the number of instructions known to the compiler. More
importantly, that made it possible to keep the instruction set stable
(while still allowing minor optimizations and performance tuning by
tweaking only the loader and interpreter), avoiding the need to
recompile all Erlang code every time there was a new release.</p>

<p>If my memory doesn’t fail me, the new loader was introduced in OTP R4.</p>
      <h2 id="otp-r5b-the-new-beam">
        
        
          OTP R5B: The “new” BEAM <a href="#otp-r5b-the-new-beam">#</a>
        
        
      </h2>
    

<p>Moving forward to OTP R5.</p>

<p>OTP R5 was the last release that supported JAM.</p>

<p>OTP R5 can also be said to be first release that featured the “new”
BEAM. In that release, the <a href="http://www.erlang.se/~bjorn/beam_file_format.html">modern BEAM file format</a>
was introduced. The same file format is used today. At that time,
there were 78 BEAM instructions; in OTP 20, there are 159 instructions
(actually, 129 active instructions and 30 obsoleted instructions no
longer used). While new instructions have been introduced when needed
and obsolete instructions have been removed, it has always been
possible to load BEAM files compiled from at least two major releases
back.</p>

<p>Execution of threaded BEAM had become fast enough, so that BEAM/C
could be dropped (already in R4, I think). But strangely enough,
the customers still wanted more speed.</p>

<p>The BEAM compiler in R5 was still Bogdan’s original compiler. While
it did more optimizations than the JAM ever did, we knew that more
optimizations were possible.</p>
      <h2 id="r6b-enter-kernel-erlang">
        
        
          R6B: Enter Kernel Erlang <a href="#r6b-enter-kernel-erlang">#</a>
        
        
      </h2>
    

<p>Meanwhile, on the top floor Robert Virding was busy writing a
new compiler for his VEE machine. In that new compiler, Robert
introduced a new intermediate format that he called <em>Kernel Erlang</em>.
The idea was that more optimizations could be applied to the code
in that format before generating code for the actual machine.</p>

<p>At that time, there was no actual interpreter that could execute the
code emitted by his new compiler (he had not updated the VEE machine
yet). The machine he had in mind was a register machine. It was similar
to BEAM, except that it did stack trimming.</p>

<p>We wanted the better performance that we could get from Robert’s compiler,
but the question was: should we implement a new interpreter (or adapt
BEAM) to execute the code from Robert’s compiler, or should we adapt
Robert’s compiler to generate BEAM code?</p>

<p>Because we now for the first time had a stable implementation of BEAM,
we decided not to rock the boat again; thus, we decided that I should
adapt the code generator part of Robert’s compiler for BEAM.</p>

<p>For the most part, I used Robert’s name for instructions. For example,
the instruction to load a term into a register was called <code>M</code> in the
original BEAM, while Robert’s compiler used the <code>move</code>. The more major
changes was in the handling of the stack.  Robert’s compiler had stack
trimming, which I had to remove and rewrite to handle BEAM’s fixed
stack frame. (I reintroduced a limited form of stack trimming later.)</p>

<p>Since JAM was not supported in OTP R6, all customers that had previously
used JAM had to migrate to BEAM. To minimize the risk of the migration
as much as possible, one of our customers requested that we made the
battle-tested original BEAM compiler available as an option in OTP R6.</p>

<p>Therefore, we added options to choose which version of the compiler
to use. To use the old compiler, one would write:</p>

<pre><code>$ erlc +v1 some_module.erl
</code></pre>

<p>Default was Robert’s new compiler, which was called <code>v2</code>. There
was also an undocumented, unofficial compiler version called <code>v3</code>.</p>

<p>All compilers shared the front end and the <code>beam_asm</code> pass that
created the final BEAM module.</p>
      <h3 id="the-v1_compiler">
        
        
          The v1_compiler <a href="#the-v1_compiler">#</a>
        
        
      </h3>
    

<p>The <code>v1</code> compiler had the following passes:</p>

<ul>
  <li>v1_adapt</li>
  <li>v1_compile</li>
  <li>v1_optimize</li>
  <li>v1_cleanup</li>
</ul>

<p>The <code>v1_compile</code> and <code>v1_optimize</code> passes were essentially
the <code>beam_compile</code> and <code>beam_optimize</code> passes from Bogdan’s
compiler.</p>

<p>There had been some changes to the front end since R5, so
the <code>v1_adapt</code> pass was there to hide those changes for the
<code>v1_compile</code> and <code>v1_optimize</code> passes. The <code>v1_cleanup</code> pass was
an additional minor optimization pass; I think it was present
in OTP R5 as well.</p>
      <h3 id="the-v2_compiler">
        
        
          The v2_compiler <a href="#the-v2_compiler">#</a>
        
        
      </h3>
    

<p>The <code>v2</code> compiler was Robert’s new compiler. It had the following
passes:</p>

<ul>
  <li>v2_kernel</li>
  <li>v2_kernopt</li>
  <li>v2_match</li>
  <li>v2_life</li>
  <li>v2_codegen</li>
</ul>

<p>The <code>v2_kernel</code> pass translated the abstract format to Kernel Erlang.</p>

<p><code>v2_kernopt</code> did very basic optimizations of the Kernel Erlang code,
essentially only <a href="https://en.wikipedia.org/wiki/Constant_folding">constant propagation and constant folding</a>.</p>

<p><code>v2_match</code> did pattern matching compilation. JAM would match clauses
in function heads or <code>case</code> expressions sequentially. The old BEAM
compiler would do only a little bit better in that it could match
multiple integers or atoms in a single instruction. Robert’s compiler
was the first Erlang compiler to properly compile pattern matching using
the algorithm described in
<a href="https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/">The Implementation of Functional Programming Languages</a>
by Simon Peyton Jones.</p>

<p><code>v2_life</code> would calculate life-time information needed by the
<code>v2_codegen</code> pass, and <code>v2_codegen</code> would generate the BEAM
assembly code.</p>
      <h2 id="r7b-enter-core-erlang">
        
        
          R7B: Enter Core Erlang <a href="#r7b-enter-core-erlang">#</a>
        
        
      </h2>
    

<p>Meanwhile, <a href="https://github.com/richcarl">Richard Carlsson</a> and the <a href="https://www.it.uu.se/research/group/hipe/">HiPE group</a>
at Uppsala University come up with the idea for a new intermediate
format useful as an interchange format for different Erlang
implementations and for optimizing Erlang programs.</p>

<p>The new format was called <a href="https://www.it.uu.se/research/group/hipe/cerl/doc/core_erlang-1.0.3.pdf">Core Erlang</a>. Robert liked the idea
and started to implement Core Erlang in the compiler.  The undocumented
implementation of <code>v3</code> compiler in OTP R6 is based on a draft version
of the Core Erlang specification.</p>

<p>In OTP R7B, the v1 and v2 compilers were removed, and the only
remaining compiler was the <code>v3</code> compiler that used Core Erlang.
It had the following passes:</p>

<ul>
  <li>v3_core</li>
  <li>v3_core_opt</li>
  <li>v3_kernel</li>
  <li>v3_life</li>
  <li>v3_codegen</li>
</ul>

<p>The <code>v3_core</code> pass translated the abstract format to Core Erlang.</p>

<p>The <code>v3_core_opt</code> pass essentially only called <code>sys_core_fold</code>, which
did <a href="https://en.wikipedia.org/wiki/Constant_folding">constant propagation and constant folding</a>. <code>sys_core_fold</code>
still do those things, and <a href="http://blog.erlang.org/core-erlang-optimizations">more</a>.</p>

<p>The remaining passes do the same thing as today.</p>

<p>The <code>v3_kernel</code> pass translates from Core Erlang to Kernel Erlang,
and also does pattern matching compilation (in the same way as in
<code>v2_match</code>). The optimizations in <code>v2_kernopt</code> are now done in
<code>sys_core_fold</code>.</p>

<p>The <code>v3_life</code> pass (despite its name) no longer calculates life-time
information. The life-time information is instead calculated by
<code>v3_kernel</code> and passed on as annotations.</p>

<p>The reason that <code>v3_life</code> still exists is that Robert had continued
to work on his own version of <code>codegen</code> that did not have all
my changes in it to work for BEAM. While implementing the Core Erlang
passes, he also did many improvements to <code>codegen</code>.</p>

<p>When it was time to integrate our different versions of the compiler,
Robert looked in horror at all my changes in <code>codegen</code>. To avoid
having to reintroduce all my adapations and optimizations for BEAM
into his new version of <code>codegen</code>, Robert wrote an adapter pass
that translated from the new Kernel Erlang format to the old format
so that my <code>codegen</code> would work. The adapter pass is called
<code>v3_life</code>.</p>

<p>Thus, <code>v3_codegen</code> is essentially <code>v2_codegen</code> with a new name.</p>

<p>In the upcoming OTP 21, <code>v3_life</code> has been combined with <code>v3_codegen</code>.</p>
      <h2 id="learning-erlang-from-robert">
        
        
          Learning Erlang from Robert <a href="#learning-erlang-from-robert">#</a>
        
        
      </h2>
    

<p>In the time period that Robert and I worked together on the compiler,
I usually worked on <code>v3_codegen</code> and the passes below, while Robert
worked on all passes above <code>v3_codegen</code>.</p>

<p>Occasionally, I would add some optimizations to <code>sys_core_fold</code> and
give them to Robert to incorporate into his latest version of
<code>sys_core_fold</code>.</p>

<p>I would then look at what Robert had done with my code, and learn.</p>

<p>Usually Robert had subtly improved my code, made it slightly
cleaner and simpler. But one time I handed Robert an
optimization of <code>case</code> clauses. The code I got back was very different.
Robert had broken apart my optimization into several simpler
optimizations that achieved the same purpose (and more) than my
more complicated optimization.</p>

        
    </div>
</article>
        </div>
    </div>
</div>
<script src="/assets/js/prismjs/prism.js"></script>
<script src="/assets/js/prismjs/components/prism-erlang.js"></script>
<script src="/assets/js/prismjs/components/prism-c.js"></script>
<script src="/assets/js/prismjs/components/prism-bash.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/downloads.html" title="DOWNLOAD"><img src="/assets/img/download.png" alt="Download Erlang/OTP"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/assets/img/GitHub-Mark-32px.png" alt="Erlang/OTP on Github"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/assets/img/twitter.png"
                    width="32" alt="Erlang/OTP twitter"></a>
        </div>
    </footer>
    <script src="/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>