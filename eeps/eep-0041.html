<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://beta.erlang.org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0041 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0041 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://beta.erlang.org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://beta.erlang.org/blog.xml" />
    
    <link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/"><img
                    src="/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="get" action="https://duckduckgo.com/">
                    <input type="hidden" name="sites" value="erlang.org">
                    <input class="form-control me-2" id="searchfield" name="q" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Richard A. O&#39;Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Draft </dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>04-Feb-2013</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>R16A</dd>
                        
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                
                <h2 id="eep-41-pseudo-assignment-for-erlang">
        
        
          EEP 41: Pseudo-assignment for Erlang <a href="#eep-41-pseudo-assignment-for-erlang">#</a>
        
        
      </h2>
    
      <h1 id="abstract">
        
        
          Abstract <a href="#abstract">#</a>
        
        
      </h1>
    

<p>Add the infix token ‘:=’ to Erlang with the purely
functional update semantics of ‘&lt;-‘ in R.</p>
      <h1 id="example">
        
        
          Example <a href="#example">#</a>
        
        
      </h1>
    

<p>Given the declarations</p>

<pre><code class="language-erlang">-record(rect, {top,left,bottom,right}).
-record(whatever, {region, ...}).

centre(#rect{top=T,left=L,bottom=B,right=R}) -&gt;
    {(L+R)/2, (T+B)/2}.

'centre:='(#rect{top=T,left=L,bottom=B,right=R}, {X,Y}) -&gt;
    DX = X - (L+R)/2,
    DY = Y - (T+B)/2,
    #rect{top=T+DY,left=L+DX,bottom=B+DY,right=R+DX}.
</code></pre>

<p>the pseudo-assignment</p>

<pre><code class="language-erlang">centre(W#whatever.region) := P
</code></pre>

<p>expands to</p>

<pre><code class="language-erlang">W' = W#whatever{
       region = 'centre:='(W#whatever.region, P)}
</code></pre>

<p>with W’ automatically replacing downstream mentions of W.</p>
      <h1 id="specification">
        
        
          Specification <a href="#specification">#</a>
        
        
      </h1>
    

<p>A new token ‘:=’ is introduced.  It may only be used in
the form</p>

<pre><code class="language-erlang">Lhs := Rhs
</code></pre>

<p>where Rhs is any Erlang expression, called the source, and
Lhs, called the target, is</p>

<ul>
  <li>a variable (not a wildcard),</li>
  <li>Lhs’ #record.field, or</li>
  <li>~f(Lhs’), or</li>
  <li>f(Lhs’, E2, …, En), or</li>
  <li>m:f(Lhs’, E2, …, En)</li>
</ul>

<p>where E2 … En are any Erlang expressions, Lhs’
is another instance of the same form, f is an atom,
and the module prefix m may only be an atom or a variable.</p>

<p>The “ultimate target”</p>

<ul>
  <li>of a variable is that variable,</li>
  <li>of L#r.f is the ultimate target of L,</li>
  <li>of ~f(L) is the ultimate target of L,</li>
  <li>of f(L,…) is the ultimate target of L,</li>
  <li>of m:f(L,…) is the ultimate target of L.</li>
</ul>

<p>Any pseudo-assignment is basically a (re)binding of its
ultimate target and has as its value the value
given to that variable, <em>not</em> the source right hand side.</p>

<p>A pseudo-assignment is equivalent to a sequence of
simple variable=expression bindings joined by comma,
and may appear anywhere in an expression that such a
sequence of bindings may appear, except that if it
occurs inside a list comprehension, the ultimate
target must not be mentioned outside that comprehension.</p>

<p>The semantics of pseudo-assignment is defined using
three conceptual stages:  protection, expansion, and
renaming.</p>
      <h2 id="protection">
        
        
          Protection <a href="#protection">#</a>
        
        
      </h2>
    

<p>The basic idea is that</p>

<pre><code class="language-erlang">f(T, E2, ..., En) := S
</code></pre>

<p>is syntactic sugar for</p>

<pre><code class="language-erlang">T := 'f:='(T, E2, ..., En, S)
</code></pre>

<p>This form of pseudo-assignment comes from S (<a href="http://en.wikipedia.org/wiki/S_%28programming_language%29" title="The S programming language">S</a> <a href="http://www.r-project.org/" title="The R Project for Statistical Computing">R</a>),
although Pop-2 (<a href="http://en.wikipedia.org/wiki/POP-2" title="Pop-2">P</a>) had an analogous approach much earlier,
and somewhat similar “sinister function calls” were found in
SETL (<a href="http://www.setl.org" title="GNU SETL">M</a>) (which looks imperative but whose values are
semantically immutable).</p>

<p>Where things get slightly complicated is that we want
subexpressions of T1, E2, …, En, S evaluated exactly
once and in order.  This is like the way the Common Lisp
(<a href="http://www.lispworks.com/documentation/common-lisp.html" title="The Common Lisp HyperSpec">L</a>) macros that work with generalised variables “[evaluate]
the subforms of the macro call […] exactly once in
left-to-right order”.  Let’s start with an example:</p>

<pre><code class="language-erlang">f(g(T, E1), E2) := E3

=&gt; V1 = E1,
   g(T, V1) := 'f:='(g(T, V1), E2, E3)

=&gt; V1 = E1,
   T := 'g:='(T, V1, 'f:='(g(T, V1), E2, E3))
</code></pre>

<p>so that E1 is not evaluated twice.</p>

<p>This step is defined using Erlang pseudo-code, in which
&lt;[…]&gt; brackets are “quasi-quotes” enclosing source
syntax representations of abstract syntax trees.
Informally, do a pre-order walk over the AST adding
V=Arg bindings for every non-first argument Arg of each
function but the top-most, for any Arg that needs it.
Which arguments do not need this protection?  Ones whose
evaluation cannot produce any observable effects, which
we can approximate well enough by saying that variables
and constants don’t need protection and everything else does.</p>

<pre><code class="language-erlang">% protect(ast()) -&gt; ast()

protect(&lt;[ Lhs := Rhs ]&gt;) -&gt;
    {Lhs', Bindings} = protect(Lhs, 0, []),
    prepend_bindings(Bindings, &lt;[ Lhs' := Rhs ]&gt;).

% prepend_bindings([ast()], ast()) -&gt; ast().

prepend_bindings([Binding|Bindings], E) -&gt;
    E' = prepend_bindings(Bindings, E),
    &lt;[ Binding, E' ]&gt;;
prepend_bindings([], E) -&gt;
    E.

% protect(Expr::ast(), Depth::int(), [ast()]) -&gt;
%     {ast(), [ast()].

protect(&lt;[ Var ]&gt;, _, B) -&gt;
    {&lt;[ Var ]&gt;, B};
protect(&lt;[ ~F(T) ]&gt;, D, B) -&gt;
    {T', B'} = protect(T, D+1, B),
    {&lt;[ ~F(T') ]&gt;, B'};
protect(&lt;[ T#R.F ]&gt;, D, B) -&gt;
    {T', B'} = protect(T, D+1, B),
    {&lt;[ T'@R.F ]&gt;, B'};
protect(&lt;[ F(T,E2,...,En) ]&gt;, D = 0, B) -&gt;
    {T', B'} = protect(T, D+1, B),
    {&lt;[ F(T',E2,...,En) ]&gt;, B');
protect(&lt;[ F(T,E2,...,En) ]&gt;, D, B) when D &gt; 0 -&gt;
    {[E2',...,En'], B'} = protect_args([E2,...,En], B),
    {T', B''} = protect(T, D+1, B),
    {F(T',E2',...,En'), B''};
protect(&lt;[ M:F(T,E2,...,En) ]&gt;, D = 0, B) -&gt;
    {T', B'} = protect(T, D+1, B),
    {&lt;[ M:F(T',E2,...,En) ]&gt;, B'');
protect(&lt;[ M:F(T,E2,...,En) ]&gt;, D, B) when D &gt; 0 -&gt;
    {[E2',...,En'], B'} = protect_args([E2,...,En], B),
    {T', B''} = protect(T, D+1, B),
    {M:F(T',E2',...,En'), B''};

% protect_args([ast()], [ast()]) -&gt; {[ast()], [ast()]}.

protect_args([], B) -&gt;
    {[], B};
protect_args([&lt;[ Var ]&gt;|Args], B) -&gt;
    {Args', B'} = protect_args(Args, B),
    {[&lt; Var ]&gt;|Args'], B'};
protect_args([&lt;[ Const ]&gt;|Args], B) -&gt;
    {Args', B'} = protect_args(Args, B),
    {[&lt; Const ]&gt;|Args'], B'};
protect_args([&lt;[ E ]&gt;|Args], B) -&gt;
    V = a new variable,
    {Args', B'} = protect_args(Args, [&lt;[ V = E ]&gt;|B]),
    {[&lt;[ V ]&gt;|Args'], B'}.
</code></pre>
      <h2 id="expansion">
        
        
          Expansion <a href="#expansion">#</a>
        
        
      </h2>
    

<p>Expansion recursively rewrites pseudo-assignments until
the target is a simple variable.</p>

<pre><code class="language-erlang">L#r.f := E
=&gt;  L := L#r{f = E}

~f(L) := E
=&gt;  L := &lt;{f ~ E | L}&gt;

f(L, E2, ..., En) := E
=&gt; L := 'f:='(L, E2, ..., En, E)

m:f(L, E2, ..., En) := E
=&gt; L := m:'f:='(L, L2, ..., En, E)
</code></pre>

<p>An assignment function is not a special kind of function but
an ordinary function with a special form of name.  They can
be exported, imported, remote-called, passed around in or as
funs, using existing Erlang means.</p>

<p>In particular, there is no automatic connection between
f/n and ‘f:=/(n+1).  Importing or exporting one does not
automatically import or export the other.</p>
      <h2 id="renaming">
        
        
          Renaming <a href="#renaming">#</a>
        
        
      </h2>
    

<p>After expansion and renaming, there are exactly as many
pseudo-assignments as there were before, but each one now
has a simple variable as its entire target.</p>

<p>This is handled by renaming.  Instead of thinking of a
variable as identified by a name, think of it as identified
by a «name,version» pair.  So the assignment</p>

<pre><code class="language-erlang">V := E
</code></pre>

<p>is to be thought of (and indeed transformed to)</p>

<pre><code class="language-erlang">«V,n+1» = E
</code></pre>

<p>where n is the highest version of V appearing on the
execution path to this rebinding.  If there is no
such version, n = 0.  So</p>

<pre><code class="language-erlang">X := f(...),
X := g(..X..),
X := h(..X..),
</code></pre>

<p>becomes</p>

<pre><code class="language-erlang">«X,1» = f(...),
«X,2» = g(..«X,1»..),
«X,3» = h(..«X,2»..),
</code></pre>

<p>Sequenceas are easy.  The difficulty is control
paths that split and rejoin, like ‘if’ or ‘case’.</p>

<p>If E is a split-join control path, and X is a variable that appears in
in E and is live after it, and the last occurrences of X in each branch
of E do not all have the same version, then let «X,m» be the highest
version of X in E. On each branch of E where a version of X is created,
replace the highest version of X by «X,m».  If a branch does not
create a version of X and X is not live on entry to E, this is already
an error in Erlang, and we don’t change that.  If «X,p» is the version
of X that is live on entry to E, then add</p>

<pre><code class="language-erlang">«X,m» = «X,p»
</code></pre>

<p>just after the -&gt; arrow of each branch that does not update X.
Here’s an example.</p>

<pre><code class="language-erlang">W = 137,
if X &lt; Y  -&gt; Z = X-1, Z := Z*(Y+1)
 ; X &gt;= Y -&gt; Z = 42, W := 3145
end,
f(Z, W)
</code></pre>

<p>becomes</p>

<pre><code class="language-erlang">«W,1» = 137,
if «X,1» &lt; «Y,1» -&gt;
      «W,2» = «W,1»,   % patch
      «Z,1» = «X,1» - 1,
      «Z,2» = «Z,1»*(«Y,1»+1)
 ; «X,1» &gt;= «Y,1» -&gt;
      «Z,2» = 42,     % patch
      «W,2» = 3145
end,
f(«Z,2», «W,2»)
</code></pre>

<p>The first patch line is added because that branch does not
update W, and it is added where it is so as not to interfere
with the result of the rest of the branch.
The second patch line would have bound «Z,1» except that
the version was pushed up to to match the other branch.</p>

<p>In effect, we are working with static single assignment form,
and the patches are pushing the phi-function back into the
branches.</p>

<p>The semantic analyser and code generator of the compiler never
get to hear about pseudo-assignment.  There is no reason why
different versions of a variable should be allocated the same
virtual register or memory cell; it’s up to the register
allocator to do that if it is useful or to do otherwise if
that’s more useful.</p>
      <h1 id="motivation">
        
        
          Motivation <a href="#motivation">#</a>
        
        
      </h1>
    

<p>Several people have complained on the Erlang mailing list
that having to write</p>

<pre><code class="language-erlang">X  = f(...),
X1 = g(..X..),
X2 = h(..X1...)
</code></pre>

<p>is error prone as well as tedious because if they have to
reorder the sequence of transformations, add a transformation,
or remove one, they have to rename the variables.</p>

<p>The fact that “assignment” to whole variables can be modelled
in a pure declarative language using renaming has been known
for a long time.  I knew it when writing “The Craft of Prolog”,
and it was folklore then.  The question was not <em>could</em> we
support</p>

<pre><code class="language-erlang">X := f(...),
X := g(..X..),
X := h(..X..),
</code></pre>

<p>but <em>should</em> we?</p>

<p>Loïc Hoguin has argued strongly that “[he] just want<a href="http://en.wikipedia.org/wiki/S_%28programming_language%29" title="The S programming language">s</a>
primitives to easily update deep data structures” (26 Jan 2013),
saying that Erlang’s handling of records is inadequate because it
makes this difficult.  He wrote (25 Jan 2013):</p>
<blockquote class='blockquote'>
  <p>Assume a variable Character.
This variable contains everything about the character.
How do you best access and modify Character?
The answer must not involve the process dictionary, processes or
message passing.
Today I have to write each access and modification function.
Or I can generate it,
but either way I end up with hundreds of functions in many modules.
Or I could use records, and have one line per sub-record per
modification function I write.
That’s not <em>easy</em> nor <em>practical</em>.
Easy and practical is:</p>

  <p>Character.weapon.ability.cost</p>

  <p>for access, and:</p>

  <p>Character.weapon.ability.cost = 123</p>

  <p>for modification.</p>
</blockquote>

<p>I don’t propose to give him that, but</p>

<pre><code class="language-erlang">C = cost(ability(Character#cinfo.weapon)),
cost(ability(Character#cinfo.weapon)) := C + 123
</code></pre>

<p>he can have, where all functions might be inlined, or</p>

<pre><code class="language-erlang">C = ~cost ~ability ~weapon Character,
~cost ~ability ~weapon Character := C + 123
</code></pre>

<p>in that bright future when we have frames.</p>

<p>The good part, from my point of view, is that this brief
syntax can be had without introducing mutable data structures.
This is <em>pseudo</em>-assignment.  And it is a proven technique
that has been used for over 25 years.</p>

<p>The bad part, for die-hard assignment fans, is that updating
deep paths this way requires allocating modified copies of
records along the way, but we can’t change that without
altering fundamental properties of Erlang.</p>
      <h1 id="rationale">
        
        
          Rationale <a href="#rationale">#</a>
        
        
      </h1>
    

<p>The questions are: what kind of “assignment” should be offered,
what syntax should be used for assignment and what targets should`
be allowed.</p>

<p>Without adding a type system that would permit Haskell-style
monads or Clean/Mercury-style uniqueness tracking,
there are two ways to add assignment to Erlang: the Lisp way
and the S way.  The Lisp way is to offer the real thing in
all its destructive power.  That would have the huge benefit
of making Erlang much more comfortable for C/Java/JavaScript
programmers, and we could look forward to the day when Erlang
syntax is finally reformed to be JavaScript with threads.  It
would also have the huge price of requiring major changes to
the Erlang compiler and runtime system and of voiding one of
the major guarantees (“your data is safe with us”) cherished
by Erlang programmers.  It would make Erlang programs harder
to get right.  Frankly, if we want JavaScript with threads,
we’d do much better to add threads to JavaScript.</p>

<p>The other way is the S way.  S is a programming language
devised by John Chambers at AT&amp;T for programming statistics
algorithms.  The revised language definition was published
in 1988.  The syntax of S looks like slightly deranged
C, but the semantics is astonishingly functional.  In particular,
at least up to S3, S values did not detectably share mutable
parts.  An S assignment like</p>

<pre><code class="language-erlang">a[i,j] &lt;- 0
</code></pre>

<p>is equivalent to</p>

<pre><code class="language-erlang">"["(a, i, j) &lt;- 0
</code></pre>

<p>which is in turn equivalent to</p>

<pre><code class="language-erlang">a &lt;- "[&lt;-"(a, i, j, value = 0)
</code></pre>

<p>and this is not merely a fashion of speaking, there really is a
function named “[&lt;-“ which is really called.   With its C-like
syntax, immutable data structures, and lazily evaluated
function arguments, the S language is is definitely strange.
But it is highly <em>practical</em>.  The R repository has a huge
range of packages doing amazing and useful things; it is used
in Statistics courses around the world; and there is an
abundance of excellent books teaching and using S/R.  So while
the idea of “assignment” being syntactic sugar for computing
a new whole value and rebinding it to a value may seem unfamiliar,
it is demonstrably both <em>workable</em> and <em>usable</em>.</p>

<p>Since there is a battle-tested form of “assignment” that does
not require mutable data structures, that’s clearly the way for
Erlang to go.</p>

<p>As for syntax, I am familiar with</p>

<ul>
  <li>Lhs = Rhs (Fortran, COBOL, BASIC, C)</li>
  <li>Lhs := Rhs (Algol, Pascal, Modula, Ada, ANSI Smalltalk)</li>
  <li>Lhs left-arrow Rhs (APL, classic Smalltalk)</li>
  <li>Lhs &lt;- Rhs (S)</li>
  <li>Rhs -&gt; Lhs (S, Pop-2)</li>
  <li>(set! Lhs Rhs) (Scheme)</li>
  <li>(setf Lhs Rhs) (Lisp)</li>
</ul>

<p>Of these, Erlang already uses =, &lt;-, and -&gt; for other purposes,
and the Unicode left arrow remains difficult to type.  Erlang
syntax is not Lisp syntax, and while LFE has Lispy macros,
plain Erlang does not.  This leaves := as the sole credible contender.</p>

<p>As for the targets of pseudo-assignments, we could simply allow
Erlang variables.  The ability to do renaming-style assignments
has been frequently requested in the Erlang mailing list.  It is
important to understand that the renaming approach to variable
“assignment” does not require the ability to rewrite a memory
cell: different “versions” of a variable may well occupy different
cells, and whether they do or not is up to the register allocator.</p>

<p>We have also seen Erlang criticised for being unable to express
chained record updates clearly.  Instead of</p>

<pre><code class="language-erlang">X1 = X#r{f = X#r.f#s{g = X#r.f#s.g#t{h = 42}}}
</code></pre>

<p>many people would rather write</p>

<pre><code class="language-erlang">X#r.f#s.g#t.h := 42
</code></pre>

<p>and who can blame them?  (Well, <em>me</em>.  I think they should not
be writing code like that whatever the syntax, and found in my
own C code that purging it of pointer chains uncovered a
scary number of present and potential bugs.  The basic nature
of the problem is excessive coupling.)  So we want to allow
field references as targets.</p>

<p>The ~f(L) syntax comes from the frames proposal.  If record
fields are pseudo-assignable, so should frame slots be.</p>

<p>If we want to pseudo-assign to elements of hash tables or
array-like structures, we have to allow function calls.
The example of S shows that we <em>can</em> include function calls on
the left of assignments, meaning that we can do</p>

<pre><code class="language-erlang">at(Dict, Key) -&gt;
    case dict:find(Dict, Key)
      of {ok,V} -&gt; V
       ; error  -&gt; 0
    end.

'at:='(Dict, Key, Value) -&gt;
    dict:store(Key, Value, Dict).

...

    at(D, K) := at(D, K) + 1
...
'element:='(N, Tuple, V) -&gt;
    setelement(N, Tuple, V).
...
   A := {0,0,0},
   element(1, A) := 3,
   element(2, A) := 1,
   element(3, A) := 4
</code></pre>

<p>Some languages let you assign to substrings.
If we can pseudo-assign to function calls, we need no
extra machinery for that:</p>

<pre><code class="language-erlang">'substr:='(String, Start, New) -&gt;
    string:substr(String, 1, Start - 1) ++ New.

'substr:='(String, Start, Length, New) -&gt;
    string:substr(String, 1, Start - 1) ++ New ++
    string:substr(String, Start + Length - 1).
</code></pre>

<p>The next step in generality would be to follow Algol 68 and
allow</p>

<pre><code class="language-erlang">if G1 -&gt; B1, L1
 ; ...
 ; Gn -&gt; Bn, Ln
end := E
</code></pre>

<p>meaning</p>

<pre><code class="language-erlang">if G1 -&gt; B1, L1 := E
 ; ...
 ; Gn -&gt; Bn, Ln := E
end
</code></pre>

<p>with similar definitions for ‘case’ &amp;c.  I can’t see a
straightforward way to implement that without either
duplicating E or doing computations out of order, so it
seemed like a good idea to stop just before this point.</p>

<p>The ‘expansion’ step above says that importing or exporting
f/n does not automatically import or export ‘f:=’/(n+1).
This could be a source of unimportant but annoying errors.
I expect using assignment functions to be more common than
defining them, and you can write a remote call to a function
without explicitly importing it, so <em>writing</em></p>

<pre><code class="language-erlang">string:substr(Line, Comment_Start) := ""
</code></pre>

<p>does not require any special declaration.  The possible
mistake, then, is to define f/n and ‘f:=’/(n+1) in a module
and export the first without exporting the second.  If this
does turn out to be a problem, it will be easy enough to add
a rule that if f/n is exported and ‘f:=’/(n+1) is defined,
the assignment form is exported too.  Let’s wait and see if
it’s really needed.</p>

<p>Should pseudo-assignment syntax be allowed for a variable’s
initial binding?  There does not seem to be any compelling
reason to forbid it.</p>

<p>There <em>is</em> a compelling reason to forbid variables being
pseudo-assigned inside a list comprehension that are used
outside it.  List comprehensions could be compiled inline
instead of generating out-of-line recursive functions, as
they currently do.  And variable assignment by actual
honest-to-goodness smash-that-memory-cell assignment could
be used to implement such assignments.  And the formal
semantics could remain renaming.  But the code generator
would have to know about it.  The renaming semantics
<em>could</em> be implemented with the out-of-line approach, but
the current values of such variables would have to be
passed in and returned, creating overheads that would
surprise me, let alone other programmers.  Simpler by far
just to forbid it.  This is not entirely unlike the
somewhat fiddly scope rules for variables in anonymous
functions.</p>
      <h1 id="backwards-compatibility">
        
        
          Backwards Compatibility <a href="#backwards-compatibility">#</a>
        
        
      </h1>
    

<p>The token ‘:=’ and the token sequence ‘:’ ‘=’ are not currently
legal anywhere in Erlang source code, so no existing code is
directly affected.</p>

<p>Pseudo-assignment is defined as a source to source transformation.
This transformation is local to the function clause affected and
can done entirely within the parser.</p>

<p>This means that anything in the Erlang tool chain downstream from
the parser is unaffected by this change.  In particular, profiling,
monitoring, and debugging tools just see plain old Erlang.</p>
      <h1 id="reference-implementation">
        
        
          Reference Implementation <a href="#reference-implementation">#</a>
        
        
      </h1>
    

<p>None in this draft, though implementation hints are given.</p>
      <h1 id="copyright">
        
        
          Copyright <a href="#copyright">#</a>
        
        
      </h1>
    

<p>This document has been placed in the public domain.</p>

            </div>
        </div>
    </div>
</div>
<script src="/assets/js/prismjs/prism.js"></script>
<script src="/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/downloads.html" title="DOWNLOAD"><img src="/assets/img/download.png" alt="Download Erlang/OTP"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/assets/img/GitHub-Mark-32px.png" alt="Erlang/OTP on Github"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/assets/img/twitter.png"
                    width="32" alt="Erlang/OTP twitter"></a>
        </div>
    </footer>
    <script src="/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>