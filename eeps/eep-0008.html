<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://beta.erlang.org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0008 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0008 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://beta.erlang.org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://beta.erlang.org/blog.xml" />
    
    <link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/"><img
                    src="/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="get" action="https://duckduckgo.com/">
                    <input type="hidden" name="sites" value="erlang.org">
                    <input class="form-control me-2" id="searchfield" name="q" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Tobias Lindahl &lt;tobias(dot)lindahl(at)it(dot)uu(dot)se&gt;
                            
                            , 
                            
                            
                            Kostis Sagonas &lt;kostis(at)it(dot)uu(dot)se&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Draft </dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>2-Dec-2007</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>R12B</dd>
                        
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                
                <h2 id="eep-8-types-and-function-specifications">
        
        
          EEP 8: Types and function specifications <a href="#eep-8-types-and-function-specifications">#</a>
        
        
      </h2>
    
      <h1 id="abstract">
        
        
          Abstract <a href="#abstract">#</a>
        
        
      </h1>
    

<p>This EEP describes an extension to the Erlang language for
declaring sets of Erlang terms to form a particular type, effectively
forming a specific subtype of the set of all Erlang terms.
Subsequently, these types can be used to specify types of record
fields and argument and return values of functions.</p>
      <h1 id="rationale">
        
        
          Rationale <a href="#rationale">#</a>
        
        
      </h1>
    

<p>Type information can be used to document function interfaces, provide
more information for bug detection tools such as Dialyzer, and can be
exploited by documentation tools such as Edoc for generating program
documentation of various forms. It is expected that the type language
described in this document will supersede and eventually replace the
purely comment-based @type and @spec declarations used by Edoc.</p>
      <h1 id="specification">
        
        
          Specification <a href="#specification">#</a>
        
        
      </h1>
    
      <h2 id="types-and-their-syntax">
        
        
          Types and their syntax <a href="#types-and-their-syntax">#</a>
        
        
      </h2>
    

<p>Types describe sets of Erlang terms. Types consist and are built from
a set of predefined types (e.g. <code>integer()</code>, <code>atom()</code>, <code>pid()</code>, …)
described below. Predefined types represent a typically infinite set
of Erlang terms which belong to this type. For example, the type
<code>atom()</code> stands for the set of all Erlang atoms.</p>

<p>For integers and atoms, we allow for singleton types (e.g. the
integers <code>-1</code> and <code>42</code> or the atoms <code>'foo'</code> and <code>'bar'</code>).</p>

<p>All other types are built using unions of either predefined types or
singleton types. In a type union between a type and one of its
subtypes the subtype is absorbed by the supertype and the union is
subsequently treated as if the subtype was not a constituent of the
union. For example, the type union:</p>

<pre><code class="language-erlang">atom() | 'bar' | integer() | 42
</code></pre>

<p>describes the same set of terms as the type union:</p>

<pre><code class="language-erlang">atom() | integer()
</code></pre>

<p>Because of subtype relations that exist between types, types form a
lattice where the topmost element, <code>any()</code>, denotes the set of all Erlang
terms and the bottommost element, <code>none()</code>, denotes the empty set of terms.</p>

<p>The set of predefined types and the syntax for types is given below:</p>

<pre><code class="language-erlang">Type :: any()            %% The top type, the set of all Erlang terms.
      | none()           %% The bottom type, contains no terms.
      | pid()
      | port()
      | ref()
      | []               %% nil
      | Atom
      | Binary
      | float()
      | Fun
      | Integer
      | List
      | Tuple
      | Union
      | UserDefined      %% described in Section 2

Union :: Type1 | Type2

Atom :: atom()
      | Erlang_Atom      %% 'foo', 'bar', ...

Binary :: binary()                        %% &lt;&lt;_:_ * 8&gt;&gt;
        | &lt;&lt;&gt;&gt;
        | &lt;&lt;_:Erlang_Integer&gt;&gt;            %% Base size
        | &lt;&lt;_:_*Erlang_Integer&gt;&gt;          %% Unit size
        | &lt;&lt;_:Erlang_Integer, _:_*Erlang_Integer&gt;&gt;

Fun :: fun()                              %% any function
     | fun((...) -&gt; Type)                 %% any arity, returning Type
     | fun(() -&gt; Type)
     | fun((TList) -&gt; Type)

Integer :: integer()
         | Erlang_Integer                 %% ..., -1, 0, 1, ... 42 ...
         | Erlang_Integer..Erlang_Integer %% specifies an integer range

List :: list(Type)                        %% Proper list ([]-terminated)
      | improper_list(Type1, Type2)       %% Type1=contents, Type2=termination
      | maybe_improper_list(Type1, Type2) %% Type1 and Type2 as above

Tuple :: tuple()                          %% stands for a tuple of any size
       | {}
       | {TList}

TList :: Type
       | Type, TList
</code></pre>

<p>Because lists are commonly used, they have shorthand type notations.
The type <code>list(T)</code> has the shorthand <code>[T]</code>. The shorthand <code>[T,...]</code>
stands for the set of non-empty proper lists whose elements are of type <code>T</code>.
The only difference between the two shorthands is that <code>[T]</code> may be an
empty list but <code>[T,...]</code> may not.</p>

<p>Notice that the shorthand for <code>list()</code>, i.e. the list of elements of
unknown type, is <code>[_]</code> (or <code>[any()]</code>), not <code>[]</code>. The notation <code>[]</code>
specifies the singleton type for the empty list.</p>

<p>For convenience, the following types are also built-in. They can be
thought as predefined aliases for the type unions also shown in the
table. (Some type unions below slightly abuse the syntax of types.)</p>

<pre><code class="language-erlang">==========================  =====================================
      Built-in type                   Stands for
==========================  =====================================
``term()``                  ``any()``
``bool()``                  ``'false' | 'true'``
``byte()``                  ``0..255``
``char()``                  ``0..16#10ffff``
``non_neg_integer()``       ``0..``
``pos_integer()``           ``1..``
``neg_integer()``           ``..-1``
``number()``                ``integer() | float()``
``list()``                  ``[any()]``
``maybe_improper_list()``   ``maybe_improper_list(any(), any())``
``maybe_improper_list(T)``  ``maybe_improper_list(T, any())``
``string()``                ``[char()]``
``nonempty_string()``       ``[char(),...]``
``iolist()``                ``maybe_improper_list(``
                                ``char() | binary() |``
                                ``iolist(), binary() | [])``
``module()``                ``atom()``
``mfa()``                   ``{atom(),atom(),byte()}``
``node()``                  ``atom()``
``timeout()``               ``'infinity' | non_neg_integer()``
``no_return()``             ``none()``
==========================  =====================================
</code></pre>

<p>Users are not allowed to define types with the same names as the
predefined or built-in ones. This is checked by the compiler and its
violation results in a compilation error. (For bootstrapping purposes,
it can also result to just a warning if this involves a built-in type
which has just been introduced.)</p>

<p><strong>NOTE</strong>: The following built-in list types also exist, but they are
expected to be rarely used. Hence, they have long names:</p>

<pre><code class="language-erlang">nonempty_maybe_improper_list(Type) :: nonempty_maybe_improper_list(Type, any())
nonempty_maybe_improper_list() :: nonempty_maybe_improper_list(any())
</code></pre>

<p>where the following two types</p>

<pre><code class="language-erlang">nonempty_improper_list(Type1, Type2)
nonempty_maybe_improper_list(Type1, Type2)
</code></pre>

<p>define the set of Erlang terms one would expect.</p>

<p>Also for convenience, we allow for record notation to be used. Records
are just shorthands for the corresponding tuples:</p>

<pre><code class="language-erlang">Record :: #Erlang_Atom{}
        | #Erlang_Atom{Fields}
</code></pre>

<p>Records have been extended to possibly contain type information. This
is described in Section 3 below.</p>
      <h2 id="type-declarations-of-user-defined-types">
        
        
          Type declarations of user-defined types <a href="#type-declarations-of-user-defined-types">#</a>
        
        
      </h2>
    

<p>As seen, the basic syntax of a type is an atom followed by closed
parentheses. New types are declared using <code>'type'</code> compiler attributes
as in the following:</p>

<pre><code class="language-erlang">-type my_type() :: Type.
</code></pre>

<p>where the type name is an atom (<code>'my_type'</code> in the above) followed by
parenthesis. Type is a type as defined in the previous section. A
current restriction is that Type can contain only predefined types or
user-defined types which have been previously defined. This
restriction is enforced by the compiler and results in a compilation
error. (A similar restriction currently exists for records).</p>

<p>This means that general recursive types cannot be defined. Lifting
this restriction is future work.</p>

<p>Type declarations can also be parametrized by including type variables
between the parentheses. The syntax of type variables is the same as
Erlang variables (starts with an upper case letter). Naturally, these
variables can - and should - appear on the RHS of the definition.
A concrete example appears below:</p>

<pre><code class="language-erlang">-type orddict(Key, Val) :: [{Key, Val}].
</code></pre>
      <h2 id="type-information-in-record-declarations">
        
        
          Type information in record declarations <a href="#type-information-in-record-declarations">#</a>
        
        
      </h2>
    

<p>The types of record fields can be specified in the declaration of the
record. The syntax for this is:</p>

<pre><code class="language-erlang">-record(rec, {field1 :: Type1, field2, field3 :: Type3}).
</code></pre>

<p>For fields without type annotations, their type defaults to <code>any()</code>.
I.e., the above is a shorthand for:</p>

<pre><code class="language-erlang">-record(rec, {field1 :: Type1, field2 :: any(), field3 :: Type3}).
</code></pre>

<p>In the presence of initial values for fields, the type must be
declared after the initialisation as in the following:</p>

<pre><code class="language-erlang">-record(rec, {field1 = [] :: Type1, field2, field3 = 42 :: Type3}).
</code></pre>

<p>Naturally, the initial values for fields should be compatible with
(i.e. a member of) the corresponding types. This is checked by the
compiler and results in a compilation error if a violation is
detected. For fields without initial values, the singleton type
<code>'undefined'</code> is added to all declared types. In other words, the
following two record declarations have identical effects:</p>

<pre><code class="language-erlang">-record(rec, {f1 = 42 :: integer(),
              f2      :: float(),
              f3      :: 'a' | 'b').

-record(rec, {f1 = 42 :: integer(),
              f2      :: 'undefined' | float(),
              f3      :: 'undefined' | 'a' | 'b').
</code></pre>

<p>For this reason, it is recommended that records contain initializers,
whenever possible.</p>

<p>Any record, containing type information or not, once defined, can be
used as a type using the syntax:</p>

<pre><code class="language-erlang">#rec{}
</code></pre>

<p>In addition, the record fields can be further specified when using a
record type by adding type information about the field in the
following manner:</p>

<pre><code class="language-erlang">#rec{some_field :: Type}
</code></pre>

<p>Any unspecified fields are assumed to have the type in the original
record declaration.</p>
      <h2 id="specifications-contracts-for-functions">
        
        
          Specifications (contracts) for functions <a href="#specifications-contracts-for-functions">#</a>
        
        
      </h2>
    

<p>A contract (or specification) for a function is given using the new
compiler attribute <code>'spec'</code>. The basic format is as follows:</p>

<pre><code class="language-erlang">-spec Module:Function(ArgType1, ..., ArgTypeN) -&gt; ReturnType.
</code></pre>

<p>The arity of the function has to match the number of arguments, or
else a compilation error occurs.</p>

<p>This form can also be used in header files (.hrl) to declare type
information for exported functions. Then these header files can be
included in files that (implicitly or explicitly) import these
functions.</p>

<p>For most uses within a given module, the following shorthand is allowed:</p>

<pre><code class="language-erlang">-spec Function(ArgType1, ..., ArgTypeN) -&gt; ReturnType.
</code></pre>

<p>Also, for documentation purposes, argument names can be given:</p>

<pre><code class="language-erlang">-spec Function(ArgName1 :: Type1, ..., ArgNameN :: TypeN) -&gt; RT.
</code></pre>

<p>A function specification can be overloaded. That is, it can have
several types, separated by a semicolon (;):</p>

<pre><code class="language-erlang">-spec foo(T1, T2) -&gt; T3
       ; (T4, T5) -&gt; T6.
</code></pre>

<p>A current restriction, which currently results in a warning (<em>OBS</em>: not
an error) by the compiler, is that the domains of the argument types
cannot be overlapping. For example, the following specification
results in a warning:</p>

<pre><code class="language-erlang">-spec foo(pos_integer()) -&gt; pos_integer()
       ; (integer()) -&gt; integer().
</code></pre>

<p>Type variables can be used in specifications to specify relations for
the input and output arguments of a function. For example, the
following specification defines the type of a polymorphic identity
function:</p>

<pre><code class="language-erlang">-spec id(X) -&gt; X.
</code></pre>

<p>However, note that the above specification does not restrict the input
and output type in any way. We can constrain these types by guard-like
subtype constraints:</p>

<pre><code class="language-erlang">-spec id(X) -&gt; X when is_subtype(X, tuple()).
</code></pre>

<p>and provide bounded quantification. Currently, the <code>is_subtype/2</code> guard
is the only guard which can be used in a <code>'spec'</code> attribute.</p>

<p>The scope of an <code>is_subtype/2</code> constraint is the <code>(...) -&gt; RetType</code>
specification after which it appears. To avoid confusion, we suggest
that different variables are used in different constituents of an
overloaded contract as in the example below:</p>

<pre><code class="language-erlang">-spec foo({X, integer()}) -&gt; X when is_subtype(X, atom())
       ; ([Y]) -&gt; Y when is_subtype(Y, number()).
</code></pre>

<p>Some functions in Erlang are not meant to return; either because they
define servers or because they are used to throw exceptions as the
function below:</p>

<pre><code class="language-erlang">my_error(Err) -&gt; erlang:throw({error, Err}).
</code></pre>

<p>For such functions we recommend the use of the special <code>no_return()</code>
type for their “return”, via a contract of the form:</p>

<pre><code class="language-erlang">-spec my_error(term()) -&gt; no_return().
</code></pre>
      <h2 id="current-limitations">
        
        
          Current limitations <a href="#current-limitations">#</a>
        
        
      </h2>
    

<p>The main limitation is the inability to define recursive types.</p>
      <h1 id="copyright">
        
        
          Copyright <a href="#copyright">#</a>
        
        
      </h1>
    

<p>This document has been placed in the public domain.</p>

            </div>
        </div>
    </div>
</div>
<script src="/assets/js/prismjs/prism.js"></script>
<script src="/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/downloads.html" title="DOWNLOAD"><img src="/assets/img/download.png" alt="Download Erlang/OTP"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/assets/img/GitHub-Mark-32px.png" alt="Erlang/OTP on Github"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/assets/img/twitter.png"
                    width="32" alt="Erlang/OTP twitter"></a>
        </div>
    </footer>
    <script src="/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>