<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://beta.erlang.org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0048 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0048 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://beta.erlang.org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://beta.erlang.org/blog.xml" />
    
    <link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/"><img
                    src="/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="get" action="https://duckduckgo.com/">
                    <input type="hidden" name="sites" value="erlang.org">
                    <input class="form-control me-2" id="searchfield" name="q" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            José Valim &lt;jose(dot)valim(at)gmail(dot)com&gt;
                            
                            , 
                            
                            
                            Eric Bailey
                            
                            , 
                            
                            
                            Radek Szymczyszyn
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Draft </dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>04-Jan-2018</dd>
                        
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                
                <h2 id="eep-48-documentation-storage-and-format">
        
        
          EEP 48: Documentation storage and format <a href="#eep-48-documentation-storage-and-format">#</a>
        
        
      </h2>
    
      <h1 id="abstract">
        
        
          Abstract <a href="#abstract">#</a>
        
        
      </h1>
    

<p>This EEP proposes an official API documentation storage to be used by
by BEAM languages.  By standardizing how API documentation is stored,
it will be possible to write tools that work across languages.</p>
      <h1 id="rationale">
        
        
          Rationale <a href="#rationale">#</a>
        
        
      </h1>
    

<p>Currently, different programming languages and libraries running on
BEAM devise their own schemas for storing and accessing documentation.</p>

<p>For example, Elixir and LFE provide a <code>h</code> helper in their shell that
can print the documentation of any module:</p>

<pre><code class="language-erlang">iex&gt; h String
A String in Elixir is a UTF-8 encoded binary.
</code></pre>

<p>However, Elixir is only able to show docs for Elixir modules.  LFE is
only able to show docs for LFE functions and so on.  If documentation
is standardized, such features can be easily added to other languages
in a way that works consistently across all BEAM languages.</p>

<p>Furthermore, each language ends up building their own tools for
generating, processing and converting documentation.  We hope a unified
approach to documentation will improve the compatibility between tools.
For instance, an Erlang IDE will be able to show inline documentation
for any module and function, regardless if the function is part of OTP,
a library or even written in Elixir, LFE or Alpaca.</p>

<p><strong>Note</strong>: in this document, the word “documentation” refers exclusively
to the API documentation of modules and functions.  Guides, tutorials
and others materials are also essential to projects but not the focus
of this EEP.</p>

<p><strong>Note</strong>: This EEP is not about documentation format.  It is about a
mechanism for storing documentation to make it easier to produce other
formats.  For example, a tool can read the documentation and produce man
pages from it.</p>
      <h1 id="specification">
        
        
          Specification <a href="#specification">#</a>
        
        
      </h1>
    

<p>This EEP is divided in three parts.  The first defines the two
places the documentation can be stored, the second defines the shape of
the documentation and the third discusses integration with OTP.</p>
      <h2 id="part-1-the-docsstorage">
        
        
          Part 1: the “Docs”storage <a href="#part-1-the-docsstorage">#</a>
        
        
      </h2>
    

<p>There are two main mechanisms in which BEAM languages store documentation:
in the filesystem (usually in the <code>/doc</code> directory) and inside <code>.beam</code>
files.</p>

<p>This EEP recognizes both options and aim to support both.  To look for
documentation for a module name <code>example</code>, a tool should:</p>

<ol>
  <li>
    <p>Look for <code>example.beam</code> in the code path, parse the BEAM file and
retrieve the <code>Docs</code> chunk</p>
  </li>
  <li>
    <p>If the chunk is not available, it should look for “example.beam”
in the code path and find the <code>doc/chunks/example.chunk</code> file in
the application that defines the <code>example</code> module</p>
  </li>
  <li>
    <p>If a <code>.chunk</code> file is not available, then documentation is not
available</p>
  </li>
</ol>

<p>The choice of using a chunk or the filesystem is completely up to the
language or library.  In both cases, the documentation can be added or
removed at any moment by stripping the <code>Docs</code> chunk or by removing the
<code>doc/chunks</code> directory.</p>

<p>For example, languages like Elixir and LFE attach the <code>Docs</code> chunk at
compilation time, which can be controlled via a compiler flag.  On the
other hand, projects like OTP itself will likely generate the <code>doc/chunks</code>
entries on a separate command, completely unrelated from code compilation.</p>
      <h2 id="part-2-the-docs-format">
        
        
          Part 2: the “Docs” format <a href="#part-2-the-docs-format">#</a>
        
        
      </h2>
    

<p>In both storages, the documentation is written in the exactly same
format: an Erlang term serialized to binary via <code>term_to_binary/1</code>.
The term may be optionally compressed when serialized and must follow
the type specification below:</p>

<pre><code class="language-erlang">{docs_v1,
 Anno :: erl_anno:anno(),
 BeamLanguage :: atom(),
 Format :: mime_type(),
 ModuleDoc :: #{optional(DocLanguage) := DocValue} | none | hidden,
 Metadata :: map(),
 Docs ::
   [{{Kind, Name, Arity},
     Anno :: erl_anno:anno(),
     Signature :: [binary()],
     Doc :: #{optional(DocLanguage) := DocValue} | none | hidden,
     Metadata :: map()
    }]} when DocLanguage :: binary(),
             DocValue :: binary() | term()
</code></pre>

<p>where in the root tuple we have:</p>

<ul>
  <li>
    <p><code>Anno</code> - annotation (line, column, file) of the definition itself
(see <code>erl_anno</code>)</p>
  </li>
  <li>
    <p><code>BeamLanguage</code> - an atom representing the language, for example:
<code>erlang</code>, <code>elixir</code>, <code>lfe</code>, <code>alpaca</code>, etc</p>
  </li>
  <li>
    <p><code>Format</code> - the mime type of the documentation, such as “text/markdown”
or “application/erlang+html” (see the FAQ for a discussion on this field)</p>
  </li>
  <li>
    <p><code>ModuleDoc</code> - a map with the documentation language as key, such as
<code>&lt;&lt;"en"&gt;&gt;</code> or <code>&lt;&lt;"pt_BR"&gt;&gt;</code>, and the documentation as a binary value.
It may be the atom <code>none</code> in case there is no documentation or the
atom <code>hidden</code> if documentation has been explicitly disabled for this
entry</p>
  </li>
  <li>
    <p><code>Metadata</code> - a map of atom keys with any term as value.  This can be
used to add annotations like the “authors” of a module, “deprecated”,
or anything else a language or documentation tool may find relevant</p>
  </li>
  <li>
    <p><code>Docs</code> - a list of documentation for other entities (such as
functions and types) in the module</p>
  </li>
</ul>

<p>For each entry in <code>Docs</code>, we have:</p>

<ul>
  <li>
    <p><code>{Kind, Name, Arity}</code> - the kind, name and arity identifying the
function, callback, type, etc.  The official entities are: <code>function</code>,
<code>type</code> and <code>callback</code>.  Other languages will add their own. For
instance, Elixir and LFE may add <code>macro</code></p>
  </li>
  <li>
    <p><code>Anno</code> - annotation (line, column, file) of the module documentation
or of the definition itself (see erl_anno)</p>
  </li>
  <li>
    <p><code>Signature</code> - the signature of the entity.  It is is a list of
binaries. Each entry represents a binary in the signature that can
be joined with a whitespace or a newline.  For example,
<code>["binary_to_atom(Binary, Encoding)", "when is_binary(Binary)"]</code>
may be rendered as as a single line or two lines. It exists
exclusively for exhibition purposes</p>
  </li>
  <li>
    <p><code>Doc</code> - a map with the documentation language as key, such as
<code>&lt;&lt;"en"&gt;&gt;</code> or <code>&lt;&lt;"pt_BR"&gt;&gt;</code>, and the documentation as a value.
The documentation may either be a binary or any Erlang term,
both described by <code>Format</code>. If it is an Erlang term, then the
<code>Format</code> must be “application/erlang+SUFFIX”, such as
“application/erlang+html” when the documentation is an Erlang
representation of an HTML document. The <code>Doc</code> may also be the
atom <code>none</code> in case there is no documentation or the atom <code>hidden</code>
if documentation has been explicitly disabled for this entry</p>
  </li>
  <li>
    <p><code>Metadata</code> - a map of atom keys with any term as value</p>
  </li>
</ul>

<blockquote class='blockquote'>
  <p>Note: the documentation map can be empty. In this case, a reference
to said function was added to the documentation index, making it
effectively public, but no documentation was written.</p>
</blockquote>

<p>This shared format is the heart of the EEP as it is what effectively
allows cross-language collaboration.</p>

<p>The <code>Metadata</code> field exists to allow languages, tools and libraries to
add custom information to each entry.  This EEP documents the
following metadata keys:</p>

<ul>
  <li>
    <p><code>authors := [binary()]</code> - a list of authors as binaries</p>
  </li>
  <li>
    <p><code>cross_references := [module() | {module(), {Kind, Name, Arity}}]</code> -
a list of modules or module entries that can be used as cross
references when generating documentation</p>
  </li>
  <li>
    <p><code>deprecated := binary()</code> - when present, it means the current entry
is deprecated with a binary that represents the reason for
deprecation and a recommendation to replace the deprecated code</p>
  </li>
  <li>
    <p><code>since := binary()</code> - a binary representing the version such entry
was added, such as <code>&lt;&lt;"1.3.0"&gt;&gt;</code> or <code>&lt;&lt;"20.0"&gt;&gt;</code></p>
  </li>
  <li>
    <p><code>edit_url := binary()</code> - a binary representing a URL to change to
change the documentation itself</p>
  </li>
</ul>

<p>Any key may be added to Metadata at any time.  Keys that are frequently
used by the community can be standardized in future versions.</p>
      <h2 id="part-3-integration-with-otp">
        
        
          Part 3: Integration with OTP <a href="#part-3-integration-with-otp">#</a>
        
        
      </h2>
    

<p>The last part focuses on integrating the previous parts with OTP docs,
tools and workflows.  The items below are suggestions and are not
necessary for the adoption of this EEP, neither by OTP nor by any other
language or library.</p>

<p>At this point we should consider changes to OTP such as:</p>

<ul>
  <li>
    <p>Distributing the <code>doc/chunks/*.chunk</code> files as part of OTP and
changing the tools that ship with OTP to rely on them. For example,
<code>erl -man lists</code> could be changed to locate the <code>lists.chunk</code> file,
parsing the documentation out and then converting it to a man page
on the fly.  This task may require multiple changes, as OTP stores
documentation on XML files as well as directly in the source code.
<code>edoc</code> itself should likely be augmented with functions that spit
out <code>.chunk</code> files from the source code</p>
  </li>
  <li>
    <p>Adding <code>h(Module)</code>, <code>h(Module, Function, Arity)</code>, and similar to
Erlang’s shell to print the documentation of a module or of a
given function and arity. This should be able to print docs any
other library or language that implements this proposal</p>
  </li>
</ul>
      <h1 id="faq">
        
        
          FAQ <a href="#faq">#</a>
        
        
      </h1>
    

<p><em>Q: Why do we have a Format entry in the documentation?</em></p>

<p>The main trade-off in the proposal is the documentation format.  We have
two options:</p>

<ul>
  <li>Allow each language/library/tool to choose their own documentation
format</li>
  <li>Impose a unified documentation format on all languages</li>
</ul>

<p>A unified format for documentation gives no flexibility to languages and
libraries in choosing how documentation is written.  As the ecosystem
gets more diverse, it will be unlikely to find a format that suits all.
For this reason we introduced a Format field that allows each language
and library to pick their documentation format.  The downside is that,
if the Elixir docs are written in Markdown and a language does not know
how to format Markdown, then the language will have to choose to either
not show the Elixir docs or show them raw (i.e. in Markdown).</p>

<p>Erlang is in a privileged position.  All languages will be able to
support whatever format is chosen for Erlang since all languages run on
Erlang and will have direct access to Erlang’s tooling.</p>

<p><em>Q: If I have an Erlang/Elixir/LFE/Alpaca library that uses a custom
documentation toolkit, will I also be able to leverage this?</em></p>

<p>As long as the documentation ends up up in the <code>Docs</code> chunk or inside
the <code>doc/chunks</code> directory, we absolutely do not care how the
documentation was originally written.  If you use a custom format,
you may need to teach your language of choice how to render it though.
See the previous question.</p>
      <h1 id="copyright">
        
        
          Copyright <a href="#copyright">#</a>
        
        
      </h1>
    

<p>This document has been placed in the public domain.</p>

            </div>
        </div>
    </div>
</div>
<script src="/assets/js/prismjs/prism.js"></script>
<script src="/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/downloads.html" title="DOWNLOAD"><img src="/assets/img/download.png" alt="Download Erlang/OTP"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/assets/img/GitHub-Mark-32px.png" alt="Erlang/OTP on Github"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/assets/img/twitter.png"
                    width="32" alt="Erlang/OTP twitter"></a>
        </div>
    </footer>
    <script src="/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>