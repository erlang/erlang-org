<!DOCTYPE html>
<html lang="en">



<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Allow pinning of website on windows -->
    <meta name="application-name" content="Erlang.org">
    <meta name="msapplication-tooltip" content="The official home of the Erlang Programming Language">
    <meta name="msapplication-starturl" content="/" >

    <!-- Make the site look nicer on facebook -->
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Erlang.org">
    <meta property="og:title" content="Welcome to Erlang.org">
    <meta property="og:description" content="The official home of the Erlang Programming Language">
    <meta property="og:image" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:image:secure_url" content="https://beta.erlang.org/assets/img/erlang-228x200.png">
    <meta property="og:url" content="https://beta.erlang.org/">

    <!-- Twitter metadata -->
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Index" />
    <meta name="twitter:site" content="@erlang_org" />

    <!-- Rich data for google search -->
    <script type="application/ld+json">
{"@type":"WebSite","url":"https://erlang.org/","headline":"Eep 0029 - Erlang/OTP","name":"Erlang.org","sameAs":["https://twitter.com/erlang_org","https://github.com/erlang/otp"],"@context":"https://schema.org"}</script>

    <title>Eep 0029 - Erlang/OTP</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- tells iOS browsers to not show telephone numbers as links -->
    <meta name="format-detection" content="telephone=no">

    <meta name="application-name" content="Erlang.org">
    <meta name="description" content="The official home of the Erlang Programming Language">
    <meta name="keywords" content="Erlang programming language functional parallel distributed documentation download community">
    <!-- https://www.rssboard.org/rss-autodiscovery -->
    <link rel="alternate" type="application/atom+xml" title="News Atom Feed" href="https://beta.erlang.org/news.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Atom Feed" href="https://beta.erlang.org/blog.xml" />
    
    <link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>
    <header class="navbar navbar-expand-lg navbar-light bg-body">
        <nav class="container">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/"><img
                    src="/assets/img/erlang.png" class="img-fluid" width="60" alt="Erlang.org main page"/></a>
            <div class="collapse navbar-collapse fw-bold" id="navbarSupportedContent">
                <ul class="navbar-nav text-uppercase me-auto mb-2 mb-lg-0">
                    <li class="nav-item"><a class="nav-link" href="/downloads">Download</a></li>
                    <li class="nav-item"><a class="nav-link" href="/docs">Documentation</a></li>
                    <li class="nav-item"><a class="nav-link" href="/community">Community</a></li>
                    <li class="nav-item"><a class="nav-link" href="/news">News</a></li>
                    <li class="nav-item"><a class="nav-link" href="/blog">Blog</a></li>
                    <li class="nav-item"><a class="nav-link" href="/eep">EEP</a></li>
                    <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
                </ul>
                <form class="d-flex" role="search" method="get" action="https://duckduckgo.com/">
                    <input type="hidden" name="sites" value="erlang.org">
                    <input class="form-control me-2" id="searchfield" name="q" type="search" placeholder="Search erlang.org"
                        aria-label="Search">
                    <button class="btn btn-outline-primary" type="submit">Search</button>
                </form>
            </div>
        </nav>
    </header>
    <div class="container border-top pt-4">
    <div class="row-lg">
        <div class="col-lg-10 offset-lg-1">
            <div class="card">
                <div class="card-body">
                    <dl class="mb-0 dl-single">
                        <dt>Author:</dt>
                        <dd>
                            Richard A. O&#39;Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
                            
                            
                        </dd>
                        
                        <dt>Status:</dt>
                        <dd>Draft </dd>
                        <dt>Type:</dt>
                        <dd>Standards Track</dd>
                        
                        
                        <dt>Created:</dt>
                        <dd>25-Feb-2009</dd>
                        
                        <dt>Erlang-Version:</dt>
                        <dd>R12B-5</dd>
                        
                        
                        
                        
                    </dl>
                </div>
            </div>
            <div class="border-top mt-4">
                
                <h2 id="eep-29-abstract-patterns-stage-1">
        
        
          EEP 29: Abstract Patterns, Stage 1 <a href="#eep-29-abstract-patterns-stage-1">#</a>
        
        
      </h2>
    
      <h1 id="abstract">
        
        
          Abstract <a href="#abstract">#</a>
        
        
      </h1>
    

<p>Abstract Patterns are named pattern/guard combinations
which can be used</p>

<ul>
  <li>in patterns, to support abstract data types</li>
  <li>as user-defined guards, guaranteed safe-for-guards</li>
  <li>as ordinary functions</li>
  <li>to replace many but not all uses of macros.</li>
</ul>

<p>The full proposal has six stages, of which this is stage 1.
This stage allows only simple abstract patterns which can be
handled by in-line substitution, so requiring no change to the
Erlang Virtual Machine.</p>
      <h1 id="specification">
        
        
          Specification <a href="#specification">#</a>
        
        
      </h1>
    

<p>We introduce abstract pattern declarations and calls.
The syntax is given as an adaptation of that in parse.yrl.</p>

<pre><code class="language-erlang">form -&gt; abstract_pattern dot.

abstract_pattern -&gt; '#' atom clause_args clause_guard
                    '-&gt;' expr.
</code></pre>

<p>For future reference, we’ll use the schematic rule</p>

<pre><code class="language-erlang">#A(H1, ..., Hn) when G -&gt; B.
</code></pre>

<p>where an empty clause_guard is taken to mean that <code>G</code> is ‘true’.
<code>H1, ..., Hn</code> and <code>B</code> must all be patterns.</p>

<p>Abstract patterns may not be directly or indirectly recursive.</p>

<pre><code class="language-erlang">expr_700 -&gt; pattern_call.

pattern_call -&gt; '#' atom argument_list
</code></pre>

<p>The expressions in the argument_list of a pattern_call must be</p>

<ul>
  <li>patterns in a pattern</li>
  <li>guard expressions elsewhere in a guard</li>
  <li>any expression elsewhere in an ordinary expression.</li>
</ul>

<p>There are two ways to understand the semantics of abstract
patterns: as function calls and as inline substitution.</p>

<p>Considered as functions, stage 1 abstract patterns correspond
to two functions.  Given our schematic rule, we get</p>

<pre><code class="language-erlang">'#A-&gt;'(H1, ..., Hn) when G -&gt; B.
</code></pre>

<p>That is, part of the meaning of an abstract pattern is a
function that works just the way it looks as if it works.
(The name ‘#A-&gt;’ is for expository purposes and should not
be taken literally.  In particular, it is NOT part of this
specification that such a function should be directly
accessible at all, still less that it should be accessible
by a name of that form.)  So</p>

<pre><code class="language-erlang">#permute([R,A,T]) when is_atom(A) -&gt; [T,A,R].
</code></pre>

<p>acts in one direction just like</p>

<pre><code class="language-erlang">'#permute-&gt;'([R,A,T]) when is_atom(A) -&gt; [T,A,R].
</code></pre>

<p>would.  Because abstract patterns are not allowed to be
recursive and cannot have any side effects, it is safe
to call them in guards.  As a guard test, <code>#A(E1,...,En)</code>
is equivalent to <code>(true = '#A-&gt;'(E1,...,En))</code>.</p>

<p>In the other direction, we get</p>

<pre><code class="language-erlang">'#A='(B) when G -&gt; {H1, ..., Hn}.
</code></pre>

<p>A pattern match</p>

<pre><code class="language-erlang">#A(P1, ..., Pn) = E
</code></pre>

<p>is equivalent to</p>

<pre><code class="language-erlang">{P1, ..., Pn} = '#A='(E)
</code></pre>

<p>When some of the patterns Hi, B use ‘=’, the definition is
a little trickier.  Suppose, for example, we have</p>

<pre><code class="language-erlang">#foo([H|T] = X) -&gt; {H,T}.
</code></pre>

<p>A naive translation would be</p>

<pre><code class="language-erlang">'#foo='({H,T}) -&gt; [H|T] = X.
</code></pre>

<p>which would not work, because X would be undefined.  The
basic problem here is that ‘=’ in patterns is symmetric,
while ‘=’ in expressions is not.  The real translation
has to be that</p>

<pre><code class="language-erlang">#A(H11=H12=.., ..., Hn1=Hn2=..) when G -&gt; B
</code></pre>

<p>is equivalent to</p>

<pre><code class="language-erlang">'#A='(B)
when G, X1=H11, X1=H12, ..., Xn=Hn1, Xn=Hn2, ...
-&gt; {X1, ..., Xn}
</code></pre>

<p>where the bindings <code>Xi=Hij</code> are both sorted and re-ordered
(that is, switched from <code>Xi=Hij</code> to <code>Hij=Xi</code>) according to
data flow.  In the case of the <code>#foo/1</code> example, we’d get</p>

<pre><code class="language-erlang">'#foo='({H,T}) when X1 = [H|T], X = X1 -&gt; {X1}.
</code></pre>

<p>The sorting and reordering process is easier than it sounds.
While there is an equation <code>Xi=Hij</code> such that either every
variable in <code>Hij</code> is known or <code>Xi</code> is known, add <code>Xi=Hij</code> if
<code>Hij</code> is all known, or <code>Hij = Xi</code> if <code>Xi</code> is known.</p>

<p>This sorting-and-reordering-by-dataflow is also recommended
in the forward direction when B contains ‘=’.</p>

<p>Sometimes one or the other direction of an abstract pattern
cannot be constructed, even with sorting and reordering by
dataflow.  This is typically because one side contains a
variable that doesn’t occur on the other.  For example,</p>

<pre><code class="language-erlang">#first(X) -&gt; {X,_}.
#second(Y) -&gt; {_,Y}.
</code></pre>

<p>are usable as patterns, but not as functions.  The compiler
should issue a warning for such abstract patterns but allow
them.  It should be a run-time error to call such a pattern
as a function as well.  It should be possible to suppress
the warning, perhaps by</p>

<pre><code class="language-erlang">-compile({pattern_only,[{first,1,second,1}]}).
</code></pre>

<p>(That’s within the current syntax.  Ideally that should be
<code>#first/1</code> and <code>#second/1</code>.)</p>

<p>For another example,</p>

<pre><code class="language-erlang">#is_date(#date(_,_,_)) -&gt; true.
</code></pre>

<p>is usable as a function, even/especially in a guard, but is
not usable as a pattern.  The compiler should issue a
warning for such abstract patterns but allow them.  It
should be a run-time error to call such a pattern as well.
It should be possible to suppress the warning, perhaps by</p>

<pre><code class="language-erlang">-compile({function_only,[{is_date,1}]}).
</code></pre>

<p>Definition via in-line substitution is straightforward.
All of the following rewrites assume a standard renaming
of variables.</p>

<pre><code class="language-erlang">f(... #A(P1,...,Pn) ...) when Gf -&gt; Bf
</code></pre>

<p>rewrites to</p>

<pre><code class="language-erlang">f(... B ...)
when G, Xi=Hij..., {P1,...,Pn} = {X1,...,Xn}, Gf -&gt; Bf

case ... of ... #(P1,...,Pn) ... when Gc -&gt; Bc
</code></pre>

<p>rewrites to</p>

<pre><code class="language-erlang">case ... of ... B ...
when G, Xi=Hij..., {P1,...,Pn} = {X1,...,Xn}, Gc -&gt; Bc

P = E
</code></pre>

<p>rewrites to</p>

<pre><code class="language-erlang">case E of P -&gt; ok end
</code></pre>

<p>In a guard expression,</p>

<pre><code class="language-erlang">(... #A(E1, ..., En) ...)
</code></pre>

<p>rewrites to</p>

<pre><code class="language-erlang">{H1,...,Hn} = {E1,...,En}, G, (... B ...)
</code></pre>

<p>As a guard test,</p>

<pre><code class="language-erlang">#A(E1, ..., En)
</code></pre>

<p>rewrites to</p>

<pre><code class="language-erlang">{H1,...,Hn} = {E1,...,En}, G, true = B
</code></pre>

<p>As an ordinary expression,</p>

<pre><code class="language-erlang">#A(E1, ..., En)
</code></pre>

<p>rewrites to</p>

<pre><code class="language-erlang">case {E1,...,En} of {H1,...,Hn} when G -&gt; B end
</code></pre>
      <h1 id="motivation">
        
        
          Motivation <a href="#motivation">#</a>
        
        
      </h1>
    

<p>Even in this restricted form, abstract patterns solve a lot
of problems that keep coming up on the Erlang mailing list.
They were invented to serve two main purposes:  to greatly
reduce the need for the preprocessor, and to support the
use of abstract data types.  It turns out that they can also
reduce the amount of keyboard work a programmer has to do,
and increase the amount of type information available to the
compiler.</p>

<p>Macros are often used to provide named constants.
For example,</p>

<pre><code class="language-erlang">-define(unknown, "UNKNOWN").
f(?unknown, Actors) -&gt; Actors;
f(N, Actors) -&gt; lists:keydelete(N, #actor.name, Actors).
</code></pre>

<p>A function is not used here because function calls may not
appear in patterns.  Abstract patterns are functions that
are sufficiently restricted that they <em>may</em> appear in patterns:</p>

<pre><code class="language-erlang">#unknown() -&gt; "UNKNOWN".
f(#unknown(), Actors) -&gt; Actors;
f(N, Actors) -&gt; lists:keydelete(n, #actor.name, Actors).
</code></pre>

<p>Sometimes these constants must be computed.
For example,</p>

<pre><code class="language-erlang">-define(START_TIMEOUT, 1000 * 30).
</code></pre>

<p>Thanks to variable binding in guards, we can do that too:</p>

<pre><code class="language-erlang">#start_timeout() when N = 1000*30 -&gt; N.
</code></pre>

<p>There are things that macros cannot do, because there needs
to be a guard test as well as a pattern.  Macros can’t bilocate.</p>

<pre><code class="language-erlang">#date(D, M, Y)
when is_integer(Y), Y &gt;= 1600, Y =&lt; 2500,
     is_integer(M), M &gt;= 1,    M =&lt; 12,
     is_integer(D), D &gt;= 1,    D =&lt; 31
-&gt; {Y, M, D}.

#vector3(X, Y, Z)
when is_float(X), is_float(Y), is_float(Z)
-&gt; {X, Y, Z}.

#mod_func(M, F) when is_atom(M), is_atom(F) -&gt; {M, F}.

#mod_func_arity(M, F, A)
when is_atom(M), is_atom(F), is_integer(A), A &gt;= 0
-&gt; {M, F, A}.
</code></pre>

<p>Some macros cannot be replaced by abstract patterns.</p>

<pre><code class="language-erlang">-define(DBG(DbgLvl, Format, Data),
    dbg(DbgLvl, Format, Data)).
</code></pre>

<p>cannot be an abstract pattern because the right hand side
involves a call to an ordinary function.</p>

<p>Some macros define guard tests.  For example,</p>

<pre><code class="language-erlang">-define(tab, 9).
-define(space, 32).
-define(is_tab(X), X == ?tab).
-define(is_space(X), X == ?space).
-define(is_underline(X), X == $_).
-define(is_number(X), X &gt;= $0, X =&lt; $9).
-define(is_upper(X), X &gt;= $A, X =&lt; $Z).
-define(is_lower(X), X &gt;= $a, X =&lt; $z).

token([X|File], L, Result, Gen, BsNl)
  when ?is_upper(X) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
token([X|File], L, Result, Gen, BsNl)
  when ?is_lower(X) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
token([X|File], L, Result, Gen, BsNl)
  when ?is_underline(X) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
</code></pre>

<p>These can be converted to abstract patterns that are usable
as guard tests,</p>

<pre><code class="language-erlang">#tab() -&gt; 9.
#space() -&gt; 32.
#is_tab(#tab()) -&gt; true.
#is_space(#space()) -&gt; true.
#is_underline($_)) -&gt; true.
#is_number(X) when X &gt;= $0, X =&lt; $9 -&gt; true.
#is_upper(X)  when X &gt;= $A, X =&lt; $Z -&gt; true.
#is_lower(X)  when X &gt;= $a, X =&lt; $z -&gt; true.

token([X|File], L, Result, Gen, BsNl)
  when #is_upper(X) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
token([X|File], L, Result, Gen, BsNl)
  when #is_lower(X) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
token([X|File], L, Result, Gen, BsNl)
  when #is_underline(X) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
</code></pre>

<p>or to abstract patterns that can be used as patterns,</p>

<pre><code class="language-erlang">#tab() -&gt; 9.
#space() -&gt; 32.
#underline(X) when X == $_ -&gt; X.
#number(X) when X &gt;= $0, X =&lt; $9 -&gt; X.
#upper(X)  when X &gt;= $A, X =&lt; $Z -&gt; X.
#lower(X)  when X &gt;= $a, X =&lt; $z -&gt; X.

token([#upper(X)|File], L, Result, Gen, BsNl) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
token([#lower(X)|File], L, Result, Gen, BsNl) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
token([#underline(X)|File], L, Result, Gen, BsNl) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
</code></pre>

<p>Of course we can use disjunction in the guard of an
abstract pattern.</p>

<pre><code class="language-erlang">#id_start(X) when X &gt;= $A, X =&lt; $Z
        ; X &gt;= $a, X =&lt; $z
        ; X == $_           -&gt; X.

token([#is_start(X)|File], L, Result, Gen, BsNl) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
</code></pre>

<p>Yes, the original macro-based version could have done the same.
It’s from the OTP sources; don’t blame me.</p>

<p>Aside from replacing a pattern AND a guard, which macros cannot
do, the great advantages over patterns over macros are that</p>

<ul>
  <li>they can be syntax-checked at the point of definition,
while macros can only be syntax-checked at the point of use;</li>
  <li>there is no problem, indeed no possibility, of variable name
capture;</li>
  <li>abstract patterns are value based, not token-list based, so
there are no problems with operators.</li>
</ul>

<p>Consider the following OTP macro:</p>

<pre><code class="language-erlang">-define(IC_FLAG_TEST(_F1, _I1), ((_F1 band _I1) == _I1)).
</code></pre>

<p>First, the author was evidently scared of accidental collisions
with other variable names.  Second, the parentheses look as
though they are there in case of operator precedence bugs.</p>

<p>There’s at least one other like it,</p>

<pre><code class="language-erlang">-define(is_set(F, Bits), ((F) band (Bits)) == (F)).
</code></pre>

<p>which (correctly) suggests that the first macro doesn’t have enough
parentheses.    The abstract pattern equivalent,</p>

<pre><code class="language-erlang">#ic_flag_test(Flags, Mask) when Flags band Mask == Mask -&gt; true.
</code></pre>

<p>has neither problem.</p>

<p>Once again, there are things that abstract patterns cannot do.
For example,</p>

<pre><code class="language-erlang">-define(get_max(_X, _Y), if _X &gt; _Y -&gt; _X; true -&gt; _Y end).
-define(get_min(_X, _Y), if _X &gt; _Y -&gt; _Y; true -&gt; _X end).
</code></pre>

<p>These cannot be abstract patterns because an abstract pattern
cannot contain an ‘if’ or a ‘case’ or any other control structure.
But they can, and should, be ordinary inline functions:</p>

<pre><code class="language-erlang">-compile({inline,[{max,2},{min,2}]}).
max(X, Y) -&gt; if X &gt; Y -&gt; X; true -&gt; Y end.
min(X, Y) -&gt; if X &gt; Y -&gt; Y; true -&gt; X end.
</code></pre>

<p>Abstract patterns don’t need to do what ordinary functions can.
Here’s another example from the OTP sources.</p>

<pre><code class="language-erlang">-define(LOWER(Char),
    if
        Char &gt;= $A, Char =&lt; $Z -&gt;
        Char - ($A - $a);
        true -&gt;
        Char
    end).
tolower(Chars) -&gt;
    [?LOWER(Char) || Char &lt;- Chars].
</code></pre>

<p>This could, and should, have been an ordinary inlined function.
Abstract patterns don’t need to do what ordinary functions can.
Let’s examine it a little closer.  Suppose we had a pattern</p>

<pre><code class="language-erlang">Cl = #lower(Cx)
</code></pre>

<p>which when used as an ordinary function converted both <code>$x</code> and <code>$X</code>
to <code>$x</code>.  Then when used as a pattern <code>#lower(Cx) = $x</code>, there would
be two correct answers for <code>Cx</code>.  There are no other cases where
a pattern may match more than one way.  The fact that abstract
patterns cannot do conditionals is one of the things that makes
them usable as patterns.</p>

<p>Macros are sometimes used for module names.</p>

<pre><code class="language-erlang">-define(SERVER,{rmod_random_impl,
        list_to_atom("babbis@" ++
    hd(tl(string:tokens(atom_to_list(node()),"@"))))}).

-define(CLIENTMOD,'rmod_random').

produce() -&gt; ?CLIENTMOD:produce(?SERVER).
</code></pre>

<p>Abstract patterns can be used for this too, but there is an
error waiting to happen.</p>

<pre><code class="language-erlang">server() -&gt; {rmod_random_impl,
        list_to_atom("babbis@" ++
    hd(tl(string:tokens(atom_to_list(node()),"@"))))}.

#client_mod() -&gt; 'rmod_random'.

produce -&gt; #client_mod():produce(server()).
</code></pre>

<p>The risk is that of writing <code>#client_mod:produce(server())</code>,
which is the syntax we’ll want in stage 2 for calling an
abstract pattern defined in another module.
There is one thing that macros are used for that abstract
patterns can be used for, but you’d probably rather not.</p>

<p>Abstract patterns were also invented with the aim of
replacing at least some uses of records.  Frames (or Joe
Armstrong’s structs, which are essentially the same thing)
are a superior way to do that.   Let’s see a simple case.</p>

<pre><code class="language-erlang">-record(mark_params, {cell_id,
              virtual_col,
              virtual_row
             }).
...
MarkP = mark_params(),
...
NewMarkP = MarkP#mark_params{cell_id     = undefined,
                 virtual_col = undefined,
                 virtual_row = VirtualRow
                },
</code></pre>

<p>This becomes</p>

<pre><code class="language-erlang">% General
#mark_params(Cell, Row, Col) -&gt; {mark_params, Cell, Row, Col}.
% Initial value
#mark_params() -&gt; #mark_params(undefined, undefined, undefined).
% Recogniser
#is_mark_params({mark_params,_,_,_}) -&gt; true.
% Cell extractor
#mark_params__cell(#mark_params(Cell,_,_)) -&gt; Cell.
% Cell updater
#mark_params__cell(Cell, #mark_params(_,R,C)) -&gt;
    #mark_params(Cell, R, C).
% Row extractor
#mark_params__row(#mark_params(_,Row,_)) -&gt; Row.
% Row updater
#mark_params__row(Row, #mark_params(K,_,C)) -&gt;
    #mark_params(K, Row, C).
% Col extractor
#mark_params__col(#mark_params(_,_,Col)) -&gt; Col.
% Col updater
#mark_params__col(Col, #mark_params(K,R,_)) -&gt;
    #mark_params(K, R, Col).
...
MarkP = #mark_params(),
...
NewMarkP = #mark_params__row(VirtualRow,
           #mark_params__col(undefined,
           #mark_params__cell(undefined, MarkP)))
</code></pre>

<p>The extractor and updater patterns can be derived automatically,
which comes in stage 4.  With frames/structs, we may never bother.</p>

<p>There is a feature of Haskell that I have long loved.
That is so-called “n+k patterns”, where a pattern may be N+K
for N a variable and K a positive integer.  This matches V
if V is an integer greater than or equal to K, and binds N
to V - K.  For example,</p>

<pre><code class="language-erlang">fib 0 = 1
fib 1 = 1
fib (n+2) = fib n + fib (n+1)
</code></pre>

<p>Not that that’s a good way to implement the Fibonacci function,
of course.  (It takes O(phi^N) when O(log N) is attainable.)
There’s no such thing in Erlang.  But with abstract patterns,
we could program it:</p>

<pre><code class="language-erlang">#succ(M) when is_integer(N), N &gt;= 1, M = N - 1 -&gt; N.

fib(0) -&gt; 1;
fib(1) -&gt; 1;
fib(#succ(#succ(N)) -&gt; fib(N) + fib(N+1).
</code></pre>

<p>Sometimes we want a three-way split:</p>

<pre><code class="language-erlang">N = 1
N = 2k+0 (k &gt;= 1)
N = 2k+1 (k &gt;= 1)
</code></pre>

<p>We can program that too:</p>

<pre><code class="language-erlang">#one() -&gt; 1.
#even(K)
when is_integer(N), (N band 1) == 0, N &gt;= 2, K = N div 2
-&gt; N.
#odd(K)
when is_integer(N), (N band 1) == 1, N &gt;= 3, K = N div 2
-&gt; N.

ruler(#one())   -&gt; 0 ;
ruler(#even(K)) -&gt; 1 + ruler(K);
ruler(#odd(K))  -&gt; 1.
</code></pre>

<p>Let’s turn to abstract data types.
There are three obvious ways to implement association lists
as single data structures:</p>

<pre><code class="language-erlang">[{K1,V1}, ..., {Kn,Vn}]     % pairs
[K1,V1, ..., Kn,Vn]         % alternating
{K1,V1, ..., {Kn,Vn,[]}}    % triples
</code></pre>

<p>Suppose you cannot make up your mind which is better.</p>

<pre><code class="language-erlang">#empty_alist() -&gt; [].
-ifdef(PAIRS).
#non_empty_alist(K,V,R) -&gt; [{K,V}|R].
-else.
-ifdef(TRIPLES).
#non_empty_alist(K,V,R) -&gt; {K,V,R}.
-else.
#non_empty_alist(K,V,R) -&gt; [K,V|R].
-endif.
-endif.

zip([K|Ks], [V|Vs]) -&gt;
    #non_empty_alist(K, V, zip(Ks, Vs));
zip([], []) -&gt;
    #empty_alist().

lookup(K, #non_empty_alist(K,V,_), _) -&gt;
    V;
lookup(K, #non_empty_alist(_,_,R), D) -&gt;
    lookup(K, R, D);
lookup(K, #empty_alist(), D) -&gt;
    D.
</code></pre>

<p>Now you can switch between the three implementations, for
testing and benchmarking, by flicking a single preprocessor
switch.</p>

<p>Sometimes there is something that would have been an algebraic
data type in Haskell or Clean or SML or CAML, but in Erlang we
just have to use a variety of tuples.  The parsed form of
Erlang source code is a good example.</p>

<pre><code class="language-erlang">lform({attribute,Line,Name,Arg}, Hook) -&gt;
    lattribute({attribute,Line,Name,Arg}, Hook);
lform({function,Line,Name,Arity,Clauses}, Hook) -&gt;
    lfunction({function,Line,Name,Arity,Clauses}, Hook);
lform({rule,Line,Name,Arity,Clauses}, Hook) -&gt;
    lrule({rule,Line,Name,Arity,Clauses}, Hook);
%% These are specials to make it easier for the compiler.
lform({error,E}, _Hook) -&gt;
    leaf(format("~p\n", [{error,E}]));
lform({warning,W}, _Hook) -&gt;
    leaf(format("~p\n", [{warning,W}]));
lform({eof,_Line}, _Hook) -&gt;
    $\n.
</code></pre>

<p>We can define abstract patterns for these.</p>

<pre><code class="language-erlang">#attribute(L, N, A)    -&gt; {attribute, L, N, A}.
#function( L, N, A, C) -&gt; {function,  L, N, A, C}.
#rule(     L, N, A, C) -&gt; {rule,      L, N, A, C}.
#eof(      L)          -&gt; {eof,       L}.
#error(    E_          -&gt; {error,     E}.
#warning(  W)          -&gt; {warning,   W}.

#attribute()       -&gt; #attribute(_,_,_).
#function()        -&gt; #function(_,_,_,_).
#rule()            -&gt; #rule(_,_,_,_).

lform(Form, Hook) -&gt;
    case Form
      of #attribute() -&gt; lattribute(Form, Hook)
       ; #function()  -&gt; lfunction( Form, Hook)
       ; #rule()      -&gt; lrule(     Form, Hook)
       ; #error(E)    -&gt; leaf(format("~p\n", [{error,E}]))
       ; #warning(W)  -&gt; leaf(format("~p\n", [{warning,W}]))
       ; #eof(_)      -&gt; $\n
    end.
</code></pre>

<p>It would almost be worth defining these patterns even if these
were their only occurrences, simply for the clarity they permit.
But these patterns would be used over and over again.  Using
the patterns not only makes the code shorter and clearer, it
gives us two kinds of protection against changes to the data
representation.  For example, suppose we decided to hold
Name/Arity information in ‘function’ and ‘rule’ tuples as
pairs, not as separate fields.  Then we could do</p>

<pre><code class="language-erlang">-ifdef(OLD_DATA).
#function( L, N, A,  C) -&gt; {function,  L, N, A, C}.
#rule(     L, N, A,  C) -&gt; {rule,      L, N, A, C}.
#function( L, {N,A}, C) -&gt; {function,  L, N, A, C}.
#rule(     L, {N,A}, C) -&gt; {rule,      L, N, A, C}.
-else.
#function( L, N, A, C)  -&gt; {function,  L, {N,A}, C}.
#rule(     L, N, A, C)  -&gt; {rule,      L, {N,A}, C}.
#function( L, NA,   C)  -&gt; {function,  L, NA,    C}.
#rule(     L, NA,   C)  -&gt; {rule,      L, NA,    C}.
-endif.
</code></pre>

<p>The rest of the code would remain unchanged.  That’s one kind of
protection.  It doesn’t help us when we need to add new cases.
That’s when the second kind of protection comes up.  Looking
for <code>#function</code> is a much safer guide to finding relevant places
than looking for <code>function</code>.</p>
      <h1 id="rationale">
        
        
          Rationale <a href="#rationale">#</a>
        
        
      </h1>
    

<p>There is more to the idea of abstract patterns than this
specification describes.  Here’s a “road map”.</p>

<ul>
  <li>
    <p>Stage 0:</p>

    <p>Allow pattern matching in guards.
This is the subject of another EEP, as it is
desirable in itself.  This MUST be implemented
first before implementing Stage 1, because that’s
what we want inlinable pattern calls to expand to.</p>
  </li>
  <li>
    <p>Stage 1:</p>

    <p>Simple abstract patterns restricted so that they
can be implemented exclusively by inline expansion.
This requires no change to the VM other than the
changes required for Stage 0.</p>

    <p>Import/export of patterns can be faked using the
preprocessor to -include definitions; this is not
ideal, but it’s an acceptable stopgap.</p>
  </li>
  <li>
    <p>Stage 2:</p>

    <p>Abstract functions are (pairs of) real functions,
they may be -exported and -imported, may be called
with module prefixes, can be replaced by hot loading,
should be traceable, debuggable, profilable, and so
on, just like other functions.  In Stage 2, exported
abstract patterns would need inline declarations if
they are to be inlined; other patterns would continue
to be inlined except when compiled in debugging mode.</p>

    <p>This requires fairly substantial changes to the
run time system.  The big payoff here is that
imported abstract patterns can be replaced by hot
loading, unlike macros.</p>
  </li>
  <li>
    <p>Stage 3:</p>

    <pre><code>  #fun [Module:]Name/Arity and
  #fun (P1, ..., Pn) when G -&gt; B end
</code></pre>

    <p>forms are introduced, and a metacall</p>

    <pre><code>  #Var(E1,...,En) is added.
</code></pre>

    <p>This requires extensions to the Erlang term
representation and the VM.  The gain here is that
the FAQ “how do I pass a pattern as a parameter”
finally gets a safe answer.  For example,</p>

    <pre><code>  collect_messages(P) -&gt;
      lists:reverse(collect_messages_loop(P, [])).

  collect_messages_loop(P, Ms) -&gt;
      receive M = #P() -&gt; collect_messages_loop([M|Ms])
        after 0        -&gt; Ms
      end.
</code></pre>

    <p>gathers all the messages currently in the mailbox
that match a pattern passed as a parameter.</p>
  </li>
  <li>
    <p>Stage 4:</p>

    <p><code>&lt;expression&gt;#&lt;pattern call&gt;</code> field update,
as described in the original proposal.</p>
  </li>
  <li>
    <p>Stage 5:</p>

    <p>Multi-clause abstract patterns,
as described in the original proposal.
Multi-clause abstract patterns CAN handle
examples like <code>?get_max</code> and <code>?LOWER</code>, which makes
them even more useful in guards, but more than
a little dubious as patterns.</p>
  </li>
  <li>
    <p>Stage 6:</p>

    <p>“Hybrid” abstract patterns, where in <code>#A/M+N</code> the
first <code>M</code> arguments are always inputs, and only
the last <code>N</code> are outputs.  This one isn’t actually
my idea.  The example</p>

    <pre><code>  #range(L, U, N)
  when is_integer(N), L =&lt; N, N =&lt; U
  -&gt; N.
</code></pre>

    <p>comes from the mailing list.  I don’t like this very
much, and note that for some purposes,</p>

    <pre><code>  range(L, U) -&gt;
      #fun(N) when is_integer(N), L =&lt; N, N =&lt; U
          -&gt; N end.
</code></pre>

    <p>can do the same job.</p>
  </li>
</ul>

<p>What I’ve done for this proposal is to strip away everything
that isn’t essential.  We get data abstraction, user defined
guard tests and functions, and a replacement for many uses
of macros, without run time overheads and without changes to
anything except the compiler front end, assuming that Stage 0
is done first.</p>
      <h1 id="backwards-compatibility">
        
        
          Backwards Compatibility <a href="#backwards-compatibility">#</a>
        
        
      </h1>
    

<p>Erlang currently uses the sharp sign for record syntax.
Since record syntax uses curly braces, and abstract patterns
use round parentheses, no existing code should be affected.</p>
      <h1 id="reference-implementation">
        
        
          Reference Implementation <a href="#reference-implementation">#</a>
        
        
      </h1>
    

<p>Sketched above.  Given stage 0, this stage 1 is within my
knowledge and abilities, but I don’t understand the Erlang
VM well enough to do stage 0.</p>
      <h1 id="copyright">
        
        
          Copyright <a href="#copyright">#</a>
        
        
      </h1>
    

<p>This document has been placed in the public domain.</p>

            </div>
        </div>
    </div>
</div>
<script src="/assets/js/prismjs/prism.js"></script>
<script src="/assets/js/prismjs/components/prism-erlang.js"></script>
    <footer class="container-fluid footer text-center border-top border-bottom">
        <div>
            <a href="/downloads.html" title="DOWNLOAD"><img src="/assets/img/download.png" alt="Download Erlang/OTP"></a>
        </div>
        <div>
            <a href="http://www.github.com/erlang/otp"><img
                    src="/assets/img/GitHub-Mark-32px.png" alt="Erlang/OTP on Github"></a>
        </div>
        
        <div>
            <a href="http://www.twitter.com/erlang_org"><img src="/assets/img/twitter.png"
                    width="32" alt="Erlang/OTP twitter"></a>
        </div>
    </footer>
    <script src="/assets/js/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>