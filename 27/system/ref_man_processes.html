<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.37.3">
    <meta name="project" content="Erlang System Documentation v27.3.4.1">


<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=27&q=">
<meta name="major-vsn" content="27">
<link rel="canonical" href="https://www.erlang.org/docs/27/system/ref_man_processes.html" />
<meta name="exdoc:autocomplete" content="off">
    <title>Processes — Erlang System Documentation v27.3.4.1</title>

    <link rel="stylesheet" href="dist/html-erlang-FDBURIED.css" />

    <script defer src="dist/sidebar_items-4A143270.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-ALU6OERS.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="Erlang System Documentation" />
        </a>

      <div>
        <a href="../index.html" class="sidebar-projectName" translate="no">
Erlang System Documentation
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v27.3.4.1
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of Erlang System Documentation</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>Processes</h1>


      <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/system/doc/reference_manual/ref_man_processes.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>

<h2 id="processes" class="section-heading">
  <a href="#processes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Processes</span>
</h2>
<p>Erlang is designed for massive concurrency. Erlang processes are lightweight
(grow and shrink dynamically) with small memory footprint, fast to create and
terminate, and the scheduling overhead is low.</p><h2 id="process-creation" class="section-heading">
  <a href="#process-creation" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Process Creation</span>
</h2>
<p>A process is created by calling <a href="../apps/erts/erlang.html#spawn/3"><code class="inline">spawn()</code></a>:</p><pre><code class="makeup erlang" translate="no"><span class="nf">spawn</span><span class="p" data-group-id="4278698942-1">(</span><span class="n">Module</span><span class="p">,</span><span class="w"> </span><span class="n">Name</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p" data-group-id="4278698942-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">pid</span><span class="p" data-group-id="4278698942-2">(</span><span class="p" data-group-id="4278698942-2">)</span><span class="w">
  </span><span class="n">Module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">atom</span><span class="p" data-group-id="4278698942-3">(</span><span class="p" data-group-id="4278698942-3">)</span><span class="w">
  </span><span class="n">Args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4278698942-4">[</span><span class="n">Arg1</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="n">ArgN</span><span class="p" data-group-id="4278698942-4">]</span><span class="w">
    </span><span class="n">ArgI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">term</span><span class="p" data-group-id="4278698942-5">(</span><span class="p" data-group-id="4278698942-5">)</span></code></pre><p><code class="inline">spawn()</code> creates a new process and returns the pid.</p><p>The new process starts executing in <code class="inline">Module:Name(Arg1,...,ArgN)</code> where the
arguments are the elements of the (possible empty) <code class="inline">Args</code> argument list.</p><p>There exist a number of different <code class="inline">spawn</code> BIFs:</p><ul><li><a href="../apps/erts/erlang.html#spawn/4"><code class="inline">spawn/1,2,3,4</code></a></li><li><a href="../apps/erts/erlang.html#spawn_link/4"><code class="inline">spawn_link/1,2,3,4</code></a></li><li><a href="../apps/erts/erlang.html#spawn_monitor/4"><code class="inline">spawn_monitor/1,2,3,4</code></a></li><li><a href="../apps/erts/erlang.html#spawn_opt/5"><code class="inline">spawn_opt/2,3,4,5</code></a></li><li><a href="../apps/erts/erlang.html#spawn_request/5"><code class="inline">spawn_request/1,2,3,4,5</code></a></li></ul><h2 id="registered-processes" class="section-heading">
  <a href="#registered-processes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Registered Processes</span>
</h2>
<p>Besides addressing a process by using its pid, there are also BIFs for
registering a process under a name. The name must be an atom and is
automatically unregistered if the process terminates:</p><table><thead><tr><th style="text-align: left;"><em>BIF</em></th><th style="text-align: left;"><em>Description</em></th></tr></thead><tbody><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#register/2"><code class="inline">register(Name, Pid)</code></a></td><td style="text-align: left;">Associates the name <code class="inline">Name</code>, an atom, with the process <code class="inline">Pid</code>.</td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#registered/0"><code class="inline">registered/0</code></a></td><td style="text-align: left;">Returns a list of names that have been registered using <a href="../apps/erts/erlang.html#register/2"><code class="inline">register/2</code></a>.</td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#whereis/1"><code class="inline">whereis(Name)</code></a></td><td style="text-align: left;">Returns the pid registered under <code class="inline">Name</code>, or <code class="inline">undefined</code>if the name is not registered.</td></tr></tbody></table><p><em>Table: Name Registration BIFs</em></p><h2 id="process-aliases" class="section-heading">
  <a href="#process-aliases" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Process Aliases</span>
</h2>
<p>When sending a message to a process, the receiving process can be identified by
a <a href="data_types.html#pid">Pid</a>, a
<a href="ref_man_processes.html#registered-processes">registered name</a>, or a <em>process
alias</em> which is a term of the type <a href="data_types.html#reference">reference</a>. The
typical use case that process aliases were designed for is a request/reply
scenario. Using a process alias when sending the reply makes it possible for the
receiver of the reply to prevent the reply from reaching its message queue if
the operation times out or if the connection between the processes is lost.</p><p>A process alias can be used as identifier of the receiver when sending a message
using the <a href="expressions.html#send">send operator (<code class="inline">!</code>)</a> or send BIFs such as
<a href="../apps/erts/erlang.html#send/2"><code class="inline">erlang:send/2</code></a>. As long as the process alias is active, messages will be
delivered the same way as if the process identifier of the process that created
the alias had been used. When the alias has been deactivated, messages sent
using the alias will be dropped before entering the message queue of the
receiver. Note that messages that at deactivation time already have entered the
message queue will <em>not</em> be removed.</p><p>A process alias is created either by calling one of the
<a href="../apps/erts/erlang.html#alias/0"><code class="inline">alias/0,1</code></a> BIFs or by creating an alias and a monitor
simultaneously. If the alias is created together with a monitor, the same
reference will be used both as monitor reference and alias. Creating a monitor
and an alias at the same time is done by passing the <code class="inline">{alias, _}</code> option to the
<a href="../apps/erts/erlang.html#monitor/3"><code class="inline">monitor/3</code></a> BIF. The <code class="inline">{alias, _}</code> option can also be
passed when creating a monitor via <a href="../apps/erts/erlang.html#spawn_opt/5"><code class="inline">spawn_opt()</code></a>, or
<a href="../apps/erts/erlang.html#spawn_request/5"><code class="inline">spawn_request()</code></a>.</p><p>A process alias can be deactivated by the process that created it by calling the
<a href="../apps/erts/erlang.html#unalias/1"><code class="inline">unalias/1</code></a> BIF. It is also possible to automatically
deactivate an alias on certain events. See the documentation of the
<a href="../apps/erts/erlang.html#alias/1"><code class="inline">alias/1</code></a> BIF, and the <code class="inline">{alias, _}</code> option of the
<a href="../apps/erts/erlang.html#monitor/3"><code class="inline">monitor/3</code></a> BIF for more information about automatic
deactivation of aliases.</p><p>It is <em>not</em> possible to:</p><ul><li>create an alias identifying another process than the caller.</li><li>deactivate an alias unless it identifies the caller.</li><li>look up an alias.</li><li>look up the process identified by an alias.</li><li>check if an alias is active or not.</li><li>check if a reference is an alias.</li></ul><p>These are all intentional design decisions relating to performance, scalability,
and distribution transparency.</p><h2 id="process-termination" class="section-heading">
  <a href="#process-termination" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Process Termination</span>
</h2>
<p>When a process terminates, it always terminates with an <em>exit reason</em>. The
reason can be any term.</p><p>A process is said to terminate <em>normally</em>, if the exit reason is the atom
<code class="inline">normal</code>. A process with no more code to execute terminates normally.</p><p>A process terminates with an exit reason <code class="inline">{Reason,Stack}</code> when a run-time error
occurs. See <a href="errors.html#exit_reasons">Exit Reasons</a>.</p><p>A process can terminate itself by calling one of the following BIFs:</p><ul><li><a href="../apps/erts/erlang.html#exit/1"><code class="inline">exit(Reason)</code></a></li><li><a href="../apps/erts/erlang.html#error/1"><code class="inline">error(Reason)</code></a></li><li><a href="../apps/erts/erlang.html#error/2"><code class="inline">error(Reason, Args)</code></a></li></ul><p>The process then terminates with reason <code class="inline">Reason</code> for <a href="../apps/erts/erlang.html#exit/1"><code class="inline">exit/1</code></a> or
<code class="inline">{Reason,Stack}</code> for the others.</p><p>A process can also be terminated if it receives an exit signal with another exit
reason than <code class="inline">normal</code>, see <a href="ref_man_processes.html#errors">Error Handling</a>.</p><h2 id="signals" class="section-heading">
  <a href="#signals" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Signals</span>
</h2>
<p><a href="" id="message-sending"></a> All communication between Erlang processes and Erlang
ports is done by sending and receiving asynchronous signals. The most common
signals are Erlang message signals. A message signal can be sent using the
<a href="expressions.html#send">send operator <code class="inline">!</code></a>. A received message can be fetched from
the message queue by the receiving process using the
<a href="expressions.html#receive"><code class="inline">receive</code></a> expression.</p><p><a href="" id="sync-comm"></a></p><p>Synchronous communication can be broken down into multiple asynchronous signals.
An example of such a synchronous communication is a call to the
<a href="../apps/erts/erlang.html#process_info/2"><code class="inline">erlang:process_info/2</code></a> BIF when the first argument does not equal the process
identifier of the calling process. The caller sends an asynchronous signal
requesting information, and then blocks waiting for the reply signal containing
the requested information. When the request signal reaches its destination, the
destination process replies with the requested information.</p><h3 id="sending-signals" class="section-heading">
  <a href="#sending-signals" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Sending Signals</span>
</h3>
<p>There are many signals that processes and ports use to communicate. The list
below contains the most important signals. In all the cases of request/reply
signal pairs, the request signal is sent by the process calling the specific
BIF, and the reply signal is sent back to it when the requested operation has
been performed.</p><ul><li><p><strong><code class="inline">message</code></strong> - Sent when using the <a href="expressions.html#send">send operator <code class="inline">!</code></a>,
or when calling one of the <a href="../apps/erts/erlang.html#send/2"><code class="inline">erlang:send/2,3</code></a> or
<a href="../apps/erts/erlang.html#send_nosuspend/2"><code class="inline">erlang:send_nosuspend/2,3</code></a> BIFs.</p></li><li><p><strong><code class="inline">link</code></strong> - Sent when calling the <a href="../apps/erts/erlang.html#link/1">link/1</a> BIF.</p></li><li><p><strong><code class="inline">unlink</code></strong> - Sent when calling the <a href="../apps/erts/erlang.html#unlink/1">unlink/1</a> BIF.</p></li><li><p><strong><code class="inline">exit</code></strong> - Sent either when explicitly sending an <code class="inline">exit</code> signal by calling
the <a href="../apps/erts/erlang.html#exit/2">exit/2</a> BIF, or when a
<a href="ref_man_processes.html#sending_exit_signals">linked process terminates</a>. If the
signal is sent due to a link, the signal is sent after all
<a href="ref_man_processes.html#visible-resources"><em>directly visible Erlang resources</em></a>
used by the process have been released.</p></li><li><p><strong><code class="inline">monitor</code></strong> - Sent when calling one of the <a href="../apps/erts/erlang.html#monitor/3">monitor/2,3</a>
BIFs.</p></li><li><p><strong><code class="inline">demonitor</code></strong> - Sent when calling one of the
<a href="../apps/erts/erlang.html#demonitor/1">demonitor/1,2</a> BIFs, or when a process monitoring
another process terminates.</p></li><li><p><strong><code class="inline">down</code></strong> - Sent by a
<a href="ref_man_processes.html#monitors">monitored process or port that terminates</a>.
The signal is sent after all
<a href="ref_man_processes.html#visible-resources"><em>directly visible Erlang resources</em></a>
used by the process or the port have been released.</p></li><li><p><strong><code class="inline">change</code></strong> - Sent by the
<a href="ref_man_processes.html#runtime-service">clock service</a> on the local runtime
system, when the <a href="../apps/erts/erlang.html#time_offset/0">time offset</a> changes, to processes
which have <a href="../apps/erts/erlang.html#monitor/2">monitored the <code class="inline">time_offset</code></a>.</p></li><li><p><strong><code class="inline">group_leader</code></strong> - Sent when calling the
<a href="../apps/erts/erlang.html#group_leader/2">group_leader/2</a> BIF.</p></li><li><p><strong><code class="inline">spawn_request</code>/<code class="inline">spawn_reply</code>, <code class="inline">open_port_request</code>/<code class="inline">open_port_reply</code></strong> -
Sent due to a call to one of the <a href="../apps/erts/erlang.html#spawn/4"><code class="inline">spawn/1,2,3,4</code></a>,
<a href="../apps/erts/erlang.html#spawn_link/4"><code class="inline">spawn_link/1,2,3,4</code></a>,
<a href="../apps/erts/erlang.html#spawn_monitor/4"><code class="inline">spawn_monitor/1,2,3,4</code></a>,
<a href="../apps/erts/erlang.html#spawn_opt/5"><code class="inline">spawn_opt/2,3,4,5</code></a>,
<a href="../apps/erts/erlang.html#spawn_request/5"><code class="inline">spawn_request/1,2,3,4,5</code></a>, or <a href="../apps/erts/erlang.html#open_port/2"><code class="inline">erlang:open_port/2</code></a>
BIFs. The request signal is sent to the
<a href="ref_man_processes.html#runtime-service">spawn service</a> which responds with the
reply signal.</p></li><li><p><strong><code class="inline">alive_request</code>/<code class="inline">alive_reply</code></strong> - Sent due to a call to the
<a href="../apps/erts/erlang.html#is_process_alive/1">is_process_alive/1</a> BIF.</p></li><li><p><strong><code class="inline">garbage_collect_request</code>/<code class="inline">garbage_collect_reply</code>,
<code class="inline">check_process_code_request</code>/<code class="inline">check_process_code_reply</code>,
<code class="inline">process_info_request</code>/<code class="inline">process_info_reply</code></strong> - Sent due to a call to one of
the <a href="../apps/erts/erlang.html#garbage_collect/1">garbage_collect/1,2</a>,
<a href="../apps/erts/erlang.html#check_process_code/2">erlang:check_process_code/2,3</a>, or
<a href="../apps/erts/erlang.html#process_info/2">process_info/1,2</a> BIFs. Note that if the request is
directed towards the caller itself and it is a synchronous request, no
signaling will be performed and the caller will instead synchronously perform
the request before returning from the BIF.</p></li><li><p><strong><code class="inline">port_command</code>, <code class="inline">port_connect</code>, <code class="inline">port_close</code></strong> - Sent by a process to a port
on the local node using the <a href="expressions.html#send">send operator (<code class="inline">!</code>)</a>, or by
calling one of the <a href="../apps/erts/erlang.html#send/2"><code class="inline">send()</code></a> BIFs. The signal is sent by
passing a term on the format <code class="inline">{Owner, {command, Data}}</code>,
<code class="inline">{Owner, {connect, Pid}}</code>, or <code class="inline">{Owner, close}</code> as message.</p></li><li><p><strong><code class="inline">port_command_request</code>/<code class="inline">port_command_reply</code>,
<code class="inline">port_connect_request</code>/<code class="inline">port_connect_reply</code>,
<code class="inline">port_close_request</code>/<code class="inline">port_close_reply</code>,
<code class="inline">port_control_request</code>/<code class="inline">port_control_reply</code>,
<code class="inline">port_call_request</code>/<code class="inline">port_call_reply</code>,
<code class="inline">port_info_request</code>/<code class="inline">port_info_reply</code></strong> - Sent due to a call to one of the
<a href="../apps/erts/erlang.html#port_command/2"><code class="inline">erlang:port_command/2,3</code></a>, <a href="../apps/erts/erlang.html#port_connect/2"><code class="inline">erlang:port_connect/2</code></a>,
<a href="../apps/erts/erlang.html#port_close/1"><code class="inline">erlang:port_close/1</code></a>, <a href="../apps/erts/erlang.html#port_control/3"><code class="inline">erlang:port_control/3</code></a>, <a href="../apps/erts/erlang.html#port_call/3"><code class="inline">erlang:port_call/3</code></a>,
<a href="../apps/erts/erlang.html#port_info/1"><code class="inline">erlang:port_info/1,2</code></a> BIFs. The request signal is
sent to a port on the local node which responds with the reply signal.</p></li><li><p><strong><code class="inline">register_name_request</code>/<code class="inline">register_name_reply</code>,
<code class="inline">unregister_name_request</code>/<code class="inline">unregister_name_reply</code>,
<code class="inline">whereis_name_request</code>/<code class="inline">whereis_name_reply</code></strong> - Sent due to a call to one of
the <a href="../apps/erts/erlang.html#register/2"><code class="inline">register/2</code></a>,
<a href="../apps/erts/erlang.html#unregister/1"><code class="inline">unregister/1</code></a>, or <a href="../apps/erts/erlang.html#whereis/1"><code class="inline">whereis/1</code></a>
BIFs. The request signal is sent to the
<a href="ref_man_processes.html#runtime-service">name service</a>, which responds with the
reply signal.</p></li><li><p><strong><code class="inline">timer_start_request</code>/<code class="inline">timer_start_reply</code>,
<code class="inline">timer_cancel_request</code>/<code class="inline">timer_cancel_reply</code></strong> - Sent due to a call to one of
the <a href="../apps/erts/erlang.html#send_after/3"><code class="inline">erlang:send_after/3,4</code></a>,
<a href="../apps/erts/erlang.html#start_timer/3"><code class="inline">erlang:start_timer/3,4</code></a>, or
<a href="../apps/erts/erlang.html#cancel_timer/1"><code class="inline">erlang:cancel_timer/1,2</code></a> BIFs. The request signal
is sent to the <a href="ref_man_processes.html#runtime-service">timer service</a> which
responds with the reply signal.</p></li></ul><p><a href="" id="runtime-service"></a> The clock service, the name service, the timer
service, and the spawn service mentioned previously are services provided by the
runtime system. Each of these services consists of multiple independently
executing entities. Such a service can be viewed as a group of processes, and
could actually be implemented like that. Since each service consists of multiple
independently executing entities, the order between multiple signals sent from
one service to one process is <em>not</em> preserved. Note that this does <em>not</em> violate
the <a href="ref_man_processes.html#signal-delivery">signal ordering guarantee</a> of the
language.</p><p>The realization of the signals described earlier may change both at runtime and
due to changes in implementation. You may be able to detect such changes using
<code class="inline">receive</code> tracing or by inspecting message queues. However, these are internal
implementation details of the runtime system that you should <em>not</em> rely on. As
an example, many of the reply signals are ordinary message signals. When
the operation is synchronous, the reply signals do not have to be message
signals. The current implementation takes advantage of this and, depending on
the state of the system, use alternative ways of delivering the reply signals.
The implementation of these reply signals may also, at any time, be changed to
not use message signals where it previously did.</p><h3 id="receiving-signals" class="section-heading">
  <a href="#receiving-signals" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Receiving Signals</span>
</h3>
<p>Signals are received asynchronously and automatically. There is nothing a
process must do to handle the reception of signals, or can do to prevent it. In
particular, signal reception is <em>not</em> tied to the execution of a
<a href="expressions.html#receive"><code class="inline">receive</code></a> expression, but can happen anywhere in the
execution flow of a process.</p><p>When a signal is received by a process, some kind of action is taken. The
specific action taken depends on the signal type, contents of the signal, and
the state of the receiving process. Actions taken for the most common signals:</p><ul><li><p><strong><code class="inline">message</code></strong> - If the message signal was sent using a
<a href="ref_man_processes.html#process-aliases">process alias</a> that is no longer
active, the message signal will be dropped; otherwise, if the alias is still
active or the message signal was sent by other means, the message is added to
the end of the message queue. When the message has been added to the message
queue, the receiving process can fetch the message from the message queue
using the <a href="expressions.html#receive"><code class="inline">receive</code></a> expression.</p></li><li><p><strong><code class="inline">link</code>, <code class="inline">unlink</code></strong> - Very simplified it can be viewed as updating process
local information about the link. A detailed description of the
<a href="../apps/erts/erl_dist_protocol.html#link_protocol">link protocol</a> can be found in
the <em>Distribution Protocol</em> chapter of the <em>ERTS User's Guide</em>.</p></li><li><p><strong><code class="inline">exit</code></strong> - Set the receiver in an exiting state, drop the signal, or convert
the signal into a message and add it to the end of the message queue. If the
receiver is set in an exiting state, no more Erlang code will be executed and
the process is scheduled for termination. The section
<a href="ref_man_processes.html#receiving_exit_signals"><em>Receiving Exit Signals</em></a> below
gives more details on the action taken when an <code class="inline">exit</code> signal is received.</p></li><li><p><strong><code class="inline">monitor</code>, <code class="inline">demonitor</code></strong> - Update process local information about the
monitor.</p></li><li><p><strong><code class="inline">down</code>, <code class="inline">change</code></strong> - Convert into a message if the corresponding monitor is
still active; otherwise, drop the signal. If the signal is converted into a
message, it is also added to the end of the message queue.</p></li><li><p><strong><code class="inline">group_leader</code></strong> - Change the group leader of the process.</p></li><li><p><strong><code class="inline">spawn_reply</code></strong> - Convert into a message, or drop the signal depending on
the reply and how the <code class="inline">spawn_request</code> signal was configured. If the signal is
converted into a message it is also added to the end of the message queue. For
more information see the <a href="../apps/erts/erlang.html#spawn_request/5"><code class="inline">spawn_request()</code></a> BIF.</p></li><li><p><strong><code class="inline">alive_request</code></strong> - Schedule execution of the <em>is alive</em> test. If the
process is in an exiting state, the <em>is alive</em> test will not be executed until
after all
<a href="ref_man_processes.html#visible-resources"><em>directly visible Erlang resources</em></a>
used by the process have been released. The <code class="inline">alive_reply</code> will be sent after
the <em>is alive</em> test has executed.</p></li><li><p><strong><code class="inline">process_info_request</code>, <code class="inline">garbage_collect_request</code>,
<code class="inline">check_process_code_request</code></strong> - Schedule execution of the requested
operation. The reply signal will be sent when the operation has been executed.</p></li></ul><p>Note that some actions taken when a signal is received involves <em>scheduling</em>
further actions which will result in a reply signal when these scheduled actions
have completed. This implies that the reply signals may be sent in a different
order than the order of the incoming signals that triggered these operations.
This does, however, <em>not</em> violate the
<a href="ref_man_processes.html#signal-delivery">signal ordering guarantee</a> of the
language.</p><p><a href="" id="message-queue-order"></a> The order of messages in the message queue of a
process reflects the order in which the signals corresponding to the messages
has been received since
<a href="ref_man_processes.html#receiving-signals">all signals that add messages to the message queue add them at the end of the message queue</a>.
Messages corresponding to signals from the same sender are also ordered in the
same order as the signals were sent due to the
<a href="ref_man_processes.html#signal-delivery">signal ordering guarantee</a> of the
language.</p><p><a href="" id="visible-resources"></a></p><h3 id="directly-visible-erlang-resources" class="section-heading">
  <a href="#directly-visible-erlang-resources" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Directly Visible Erlang Resources</span>
</h3>
<p>As described earlier, <code class="inline">exit</code> signals due to links, <code class="inline">down</code> signals, and reply
signals from an exiting process due to <code class="inline">alive_request</code>s are not sent until all
<em>directly visible Erlang resources</em> held by the terminating process have been
released. With <em>directly visible Erlang resources</em> we here mean all resources
made available by the language excluding resources held by heap data, dirty
native code execution and the process identifier of the terminating process.
Examples of <em>directly visible Erlang resources</em> are
<a href="ref_man_processes.html#registered-processes">registered name</a> and <a href="../apps/stdlib/ets.html">ETS</a>
tables.</p><h4>The Excluded Resources</h4><p>The process identifier of the process cannot be released for reuse until
everything regarding the process has been released.</p><p>A process executing dirty native code in a NIF when it receives an exit signal
will be set into an exiting state even if it is still executing dirty native
code. <em>Directly visible Erlang resources</em> will be released, but the runtime
system cannot force the native code to stop executing. The runtime system tries
to prevent the execution of the dirty native code from affecting other processes
by, for example, disabling functionality such as
<a href="../apps/erts/erl_nif.html#enif_send"><code class="inline">enif_send()</code></a> when used from a terminated
process, but if the NIF is not well behaved it can still affect other processes.
A well behaved dirty NIF should test if
<a href="../apps/erts/erl_nif.html#enif_is_current_process_alive">the process it is executing in has exited</a>,
and if so stop executing.</p><p>In the general case, the heap of a process cannot be removed before all signals
that it needs to send have been sent. Resources held by heap data are the memory
blocks containing the heap, but also include things referred to from the heap
such as off heap binaries, and resources held via NIF
<a href="../apps/erts/erl_nif.html#resource_objects">resource objects</a> on the heap.</p><p><a href="" id="signal-delivery"></a></p><h3 id="delivery-of-signals" class="section-heading">
  <a href="#delivery-of-signals" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Delivery of Signals</span>
</h3>
<p>The amount of time that passes between the time a signal is sent and the arrival
of the signal at the destination is unspecified but positive. If the receiver
has terminated, the signal does not arrive, but it can trigger another signal.
For example, a <code class="inline">link</code> signal sent to a non-existing process triggers an <code class="inline">exit</code>
signal, which is sent back to where the <code class="inline">link</code> signal originated from. When
communicating over the distribution, signals can be lost if the distribution
channel goes down.</p><p>The only signal ordering guarantee given is the following: if an entity sends
multiple signals to the same destination entity, the order is preserved; that
is, if <code class="inline">A</code> sends a signal <code class="inline">S1</code> to <code class="inline">B</code>, and later sends signal <code class="inline">S2</code> to <code class="inline">B</code>, <code class="inline">S1</code>
is guaranteed not to arrive after <code class="inline">S2</code>. Note that <code class="inline">S1</code> may, or may not have been
lost.</p><p><a href="" id="signal-irregularities"></a></p><h3 id="irregularities" class="section-heading">
  <a href="#irregularities" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Irregularities</span>
</h3>
<ul><li><p><strong>Synchronous Error Checking</strong> - Some functionality that send signals have
synchronous error checking when sending locally on a node and fail if the
receiver is not present at the time when the signal is sent:</p><ul><li>The <a href="expressions.html#send">send operator (<code class="inline">!</code>)</a>,
<a href="../apps/erts/erlang.html#send/2"><code class="inline">erlang:send/2,3</code></a>, BIFs and
<a href="../apps/erts/erlang.html#send_nosuspend/2"><code class="inline">erlang:send_nosuspend/2,3</code></a> BIFs when the
receiver is identified by a name that is expected to be registered locally.</li><li><a href="../apps/erts/erlang.html#link/1"><code class="inline">erlang:link/1</code></a></li><li><a href="../apps/erts/erlang.html#group_leader/2"><code class="inline">erlang:group_leader/2</code></a></li></ul></li><li><p><strong>Unexpected Behaviours of Exit Signals</strong> - When a process sends an exit
signal with exit reason <code class="inline">normal</code> to itself by calling
<a href="../apps/erts/erlang.html#exit/2"><code class="inline">erlang:exit(self(), normal)</code></a> it will be terminated
<a href="ref_man_processes.html#receiving_exit_signals">when the <code class="inline">exit</code> signal is received</a>.
In all other cases when an exit signal with exit reason <code class="inline">normal</code> is received,
it is dropped.</p><p>When an
<a href="ref_man_processes.html#receiving_exit_signals"><code class="inline">exit</code> signal with exit reason <code class="inline">kill</code> is received</a>,
the action taken is different depending on whether the signal was sent due to
a linked process terminating, or the signal was explicitly sent using the
<a href="../apps/erts/erlang.html#exit/2"><code class="inline">exit/2</code></a> BIF. When sent using the <a href="../apps/erts/erlang.html#exit/2"><code class="inline">exit/2</code></a> BIF,
the signal cannot be <a href="../apps/erts/erlang.html#process_flag_trap_exit">trapped</a>, while it
can be trapped if the signal was sent due to a link.</p></li><li><p><strong>Blocking Signaling Over Distribution<a href="" id="blocking-signaling-over-distribution"></a> </strong>
 When sending a signal over a distribution channel, the sending process may be
suspended even though the signal is supposed to be sent asynchronously. This is
due to the built in flow control over the channel that has been present more or
less for ever. When the size of the output buffer for the channel reach the <em>distribution
buffer busy limit</em>, processes sending on the channel will be suspended until the
size of the buffer shrinks below the limit.</p><p>Depending on the reason for why the buffer got full, the time it takes before
suspended processes are resumed can vary <em>very much</em>. A consequence of this
can, for example, be that a timeout in a call to <a href="../apps/kernel/erpc.html#call/5">erpc:call()</a>
is significantly delayed.</p><p>Since this functionality has been present for so long, it is not possible to
remove it, but it is possible to enable <em>fully asynchronous distributed
signaling</em> on a per process level using
<a href="../apps/erts/erlang.html#process_flag_async_dist"><code class="inline">process_flag(async_dist, Bool)</code></a> which
can be used to solve problems occuring due to blocking signaling. However,
note that you need to make sure that flow control for data sent using <em>fully
asynchronous distributed signaling</em> is implemented, or that the amount of such
data is known to always be limited; otherwise, you may get into a situation
with excessive memory usage.</p><p>The size of the <em>distribution buffer busy limit</em> can be inspected by calling
<a href="../apps/erts/erlang.html#system_info_dist_buf_busy_limit"><code class="inline">erlang:system_info(dist_buf_busy_limit)</code></a>.</p></li></ul><p>The irregularities mentioned earlier cannot be fixed as they have been part of
Erlang too long and it would break a lot of existing code.</p><h2 id="links" class="section-heading">
  <a href="#links" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Links</span>
</h2>
<p>Two processes can be <em>linked</em> to each other. Also a process and a port that
reside on the same node can be linked to each other. A link between two
processes can be created if one of them calls the <a href="../apps/erts/erlang.html#link/1"><code class="inline">link/1</code></a>
BIF with the process identifier of the other process as argument. Links can also
be created using one the following spawn BIFs
<a href="../apps/erts/erlang.html#spawn_link/4"><code class="inline">spawn_link()</code></a>, <a href="../apps/erts/erlang.html#spawn_opt/5"><code class="inline">spawn_opt()</code></a>,
or <a href="../apps/erts/erlang.html#spawn_request/5"><code class="inline">spawn_request()</code></a>. The spawn operation and the
link operation will be performed atomically, in these cases.</p><p>If one of the participants of a link terminates, it will
<a href="ref_man_processes.html#sending_exit_signals">send an exit signal</a> to the other
participant. The exit signal will contain the
<a href="ref_man_processes.html#link_exit_signal_reason">exit reason</a> of the terminated
participant.</p><p>A link can be removed by calling the <a href="../apps/erts/erlang.html#unlink/1"><code class="inline">unlink/1</code></a> BIF.</p><p>Links are bidirectional and there can only be one link between two processes.
Repeated calls to <code class="inline">link()</code> have no effect. Either one of the involved processes
may create or remove a link.</p><p>Links are used to monitor the behavior of other processes, see
<a href="ref_man_processes.html#errors">Error Handling</a>.</p><p><a href="" id="errors"></a></p><h2 id="error-handling" class="section-heading">
  <a href="#error-handling" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Error Handling</span>
</h2>
<p>Erlang has a built-in feature for error handling between processes. Terminating
processes emit exit signals to all linked processes, which can terminate as well
or handle the exit in some way. This feature can be used to build hierarchical
program structures where some processes are supervising other processes, for
example, restarting them if they terminate abnormally.</p><p>See
<a href="../system/design_principles.html">OTP Design Principles</a>
for more information about OTP supervision trees, which use this feature.</p><p><a href="" id="sending_exit_signals"></a></p><h3 id="sending-exit-signals" class="section-heading">
  <a href="#sending-exit-signals" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Sending Exit Signals</span>
</h3>
<p>When a process or port <a href="ref_man_processes.html#process-termination">terminates</a> it
will send exit signals to all processes and ports that it is
<a href="ref_man_processes.html#links">linked</a> to. The exit signal will contain the
following information:</p><ul><li><p><strong>Sender identifier</strong> - The process or port identifier of the process or port
that terminated.</p></li><li><p><strong>Receiver identifier</strong> - The process or port identifier of the process or
port which the exit signal is sent to.</p></li><li><p><strong>The <code class="inline">link</code> flag</strong> - This flag will be set indicating that the exit signal
was sent due to a link.</p></li><li><p><strong><a href="" id="link_exit_signal_reason"></a> Exit reason</strong><br/>The exit reason of the process or port that terminated or the atom:</p><ul><li><code class="inline">noproc</code> in case no process or port was found when setting up a link in a
preceding call to the <a href="../apps/erts/erlang.html#link/1"><code class="inline">link(PidOrPort)</code></a> BIF. The process
or port identified as sender of the exit signal will equal the <code class="inline">PidOrPort</code>
argument passed to <a href="../apps/erts/erlang.html#link/1"><code class="inline">link/1</code></a>.</li><li><code class="inline">noconnection</code> in case the linked processes resides on different nodes and
the connection between the nodes was lost or could not be established. The
process or port identified as sender of the exit signal might in this case
still be alive.</li></ul></li></ul><p>Exit signals can also be sent explicitly by calling the
<a href="../apps/erts/erlang.html#exit/2"><code class="inline">exit(PidOrPort, Reason)</code></a> BIF. The exit signal is sent to the
process or port identified by the <code class="inline">PidOrPort</code> argument. The exit signal sent
will contain the following information:</p><ul><li><p><strong>Sender identifier</strong> - The process identifier of the process that called
<a href="../apps/erts/erlang.html#exit/2"><code class="inline">exit/2</code></a>.</p></li><li><p><strong>Receiver identifier</strong> - The process or port identifier of the process or
port which the exit signal is sent to.</p></li><li><p><strong>The <code class="inline">link</code> flag</strong> - This flag will not be set, indicating that this exit
signal was not sent due to a link.</p></li><li><p><strong>Exit reason</strong> - The term passed as <code class="inline">Reason</code> in the call to
<a href="../apps/erts/erlang.html#exit/2"><code class="inline">exit/2</code></a>. If <code class="inline">Reason</code> is the atom <code class="inline">kill</code>, the receiver cannot
<a href="../apps/erts/erlang.html#process_flag_trap_exit">trap the exit</a> signal and will
unconditionally terminate when it receives the signal.</p></li></ul><p><a href="" id="receiving_exit_signals"></a></p><h3 id="receiving-exit-signals" class="section-heading">
  <a href="#receiving-exit-signals" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Receiving Exit Signals</span>
</h3>
<p>What happens when a process receives an exit signal depends on:</p><ul><li>The <a href="../apps/erts/erlang.html#process_flag_trap_exit">trap exit</a> state of the receiver at
the time when the exit signal is received.</li><li>The exit reason of the exit signal.</li><li>The sender of the exit signal.</li><li>The state of the <code class="inline">link</code> flag of the exit signal. If the <code class="inline">link</code> flag is set,
the exit signal was sent due to a link; otherwise, the exit signal was sent by
a call to the <a href="../apps/erts/erlang.html#exit/2"><code class="inline">exit/2</code></a> BIF.</li><li>If the <code class="inline">link</code> flag is set, what happens also depends on whether the
<a href="../apps/erts/erlang.html#unlink/1">link is still active or not</a> when the exit signal is
received.</li></ul><p>Based on the above states, the following will happen when an exit signal is
received by a process:</p><ul><li><p>The exit signal is silently dropped if:</p><ul><li>the <code class="inline">link</code> flag of the exit signal is set and the corresponding link has
been deactivated.</li><li>the exit reason of the exit signal is the atom <code class="inline">normal</code>, the receiver is not
trapping exits, and the receiver and sender are not the same process.</li></ul></li><li><p>The receiving process is terminated if:</p><ul><li>the <code class="inline">link</code> flag of the exit signal is not set, and the exit reason of the
exit signal is the atom <code class="inline">kill</code>. The receiving process will terminate with
the atom <code class="inline">killed</code> as exit reason.</li><li>the receiver is not trapping exits, and the exit reason is something other
than the atom <code class="inline">normal</code>. Also, if the <code class="inline">link</code> flag of the exit signal is set,
the link also needs to be active otherwise the exit signal will be dropped.
The exit reason of the receiving process will equal the exit reason of the
exit signal. Note that if the <code class="inline">link</code> flag is set, an exit reason of <code class="inline">kill</code>
will <em>not</em> be converted to <code class="inline">killed</code>.</li><li>the exit reason of the exit signal is the atom <code class="inline">normal</code> and the sender of
the exit signal is the same process as the receiver. The <code class="inline">link</code> flag cannot
be set in this case. The exit reason of the receiving process will be the
atom <code class="inline">normal</code>.</li></ul></li><li><p>The exit signal is converted to a message signal and added to the end of the
message queue of the receiver, if the receiver is trapping exits, the <code class="inline">link</code>
flag of the exit signal is:</p><ul><li>not set, and the exit reason of the signal is not the atom <code class="inline">kill</code>.</li><li>set, and the corresponding link is active. Note that an exit reason of
<code class="inline">kill</code> will <em>not</em> terminate the process in this case and it will not be
converted to <code class="inline">killed</code>.</li></ul><p>The converted message will be on the form <code class="inline">{'EXIT', SenderID, Reason}</code> where
<code class="inline">Reason</code> equals the exit reason of the exit signal and <code class="inline">SenderID</code> is the
identifier of the process or port that sent the exit signal.</p></li></ul><h2 id="monitors" class="section-heading">
  <a href="#monitors" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Monitors</span>
</h2>
<p>An alternative to links are <em>monitors</em>. A process <code class="inline">Pid1</code> can create a
monitor for <code class="inline">Pid2</code> by calling the BIF <a href="../apps/erts/erlang.html#monitor/2"><code class="inline">erlang:monitor(process, Pid2)</code></a>. The function returns a reference <code class="inline">Ref</code>.</p><p>If <code class="inline">Pid2</code> terminates with exit reason <code class="inline">Reason</code>, a 'DOWN' message is sent to
<code class="inline">Pid1</code>:</p><pre><code class="text">{'DOWN', Ref, process, Pid2, Reason}</code></pre><p>If <code class="inline">Pid2</code> does not exist, the 'DOWN' message is sent immediately with <code class="inline">Reason</code>
set to <code class="inline">noproc</code>.</p><p>Monitors are unidirectional. Repeated calls to <code class="inline">erlang:monitor(process, Pid)</code>
creates several independent monitors, and each one sends a 'DOWN' message when
<code class="inline">Pid</code> terminates.</p><p>A monitor can be removed by calling <a href="../apps/erts/erlang.html#demonitor/1"><code class="inline">erlang:demonitor(Ref)</code></a>.</p><p>Monitors can be created for processes with registered names, also at other
nodes.</p><h2 id="process-dictionary" class="section-heading">
  <a href="#process-dictionary" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Process Dictionary</span>
</h2>
<p>Each process has its own process dictionary, accessed by calling the following
BIFs:</p><ul><li><a href="../apps/erts/erlang.html#put/2"><code class="inline">put(Key, Value)</code></a></li><li><a href="../apps/erts/erlang.html#get/1"><code class="inline">get(Key)</code></a></li><li><a href="../apps/erts/erlang.html#get/0"><code class="inline">get()</code></a></li><li><a href="../apps/erts/erlang.html#get_keys/1"><code class="inline">get_keys(Value)</code></a></li><li><a href="../apps/erts/erlang.html#erase/1"><code class="inline">erase(Key)</code></a></li><li><a href="../apps/erts/erlang.html#erase/0"><code class="inline">erase()</code></a></li></ul>
</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="features.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Features
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="distributed.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Distributed Erlang
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="Erlang System Documentation.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.37.3) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright © 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
