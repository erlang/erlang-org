<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.37.3">
    <meta name="project" content="Erlang System Documentation v27.3.4.6">


<meta name="major-vsn" content="27">
<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=27&q=">
<link rel="canonical" href="https://www.erlang.org/doc/system/maps.html" />
    <title>Maps — Erlang System Documentation v27.3.4.6</title>

    <link rel="stylesheet" href="dist/html-erlang-FDBURIED.css" />

    <script defer src="dist/sidebar_items-4A143270.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-ALU6OERS.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="Erlang System Documentation" />
        </a>

      <div>
        <a href="../index.html" class="sidebar-projectName" translate="no">
Erlang System Documentation
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v27.3.4.6
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of Erlang System Documentation</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>Maps</h1>


      <a href="https://github.com/erlang/otp/blob/OTP-27.3.4.6/system/doc/efficiency_guide/maps.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>

<p>This guide to using maps efficiently starts with a brief section on the choice
between records or maps, followed by three sections giving concrete (but brief)
advice on using maps as an alternative to records, as dictionaries, and as sets.
The remaining sections dig deeper, looking at how maps are implemented, the map
syntax, and finally the functions in the <a href="../apps/stdlib/maps.html"><code class="inline">maps</code></a> module.</p><p><a href="" id="terminology"></a></p><p>Terminology used in this chapter:</p><ul><li>A map with at most 32 elements will informally be called a <em>small map</em>.</li><li>A map with more than 32 elements will informally be called a <em>large map</em>.</li></ul><h2 id="maps-or-records" class="section-heading">
  <a href="#maps-or-records" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Maps or Records?</span>
</h2>
<p>If the advice in this chapter is followed, the performance of records compared
to using small maps instead of records is expected to be similar. Therefore, the
choice between records and maps should be based on the desired properties of the
data structure and not performance.</p><p>The advantages of records compared to maps are:</p><ul><li>If the name of a record field is misspelled, there will be a compilation
error. If a map key is misspelled, the compiler will give no warning and
program will fail in some way when it is run.</li><li>Records will use slightly less memory than maps, and performance is expected
to be <em>slightly</em> better than maps in most circumstances.</li></ul><p>The disadvantage of records compared to maps is that if a new field is added to
a record, all code that uses that record must be recompiled. Because of that, it
is recommended to only use records within a unit of code that can easily be
recompiled all at once, for example within a single application or single
module.</p><h2 id="using-maps-as-an-alternative-to-records" class="section-heading">
  <a href="#using-maps-as-an-alternative-to-records" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Using Maps as an Alternative to Records</span>
</h2>
<ul><li><p>Use the map syntax instead of the functions in the <a href="../apps/stdlib/maps.html"><code class="inline">maps</code></a> module.</p></li><li><p>Avoid having more than 32 elements in the map. As soon as there are more than
32 elements in the map, it will require more memory and keys can no longer be
shared with other instances of the map.</p></li><li><p>When creating a new map, always create it with all keys that will ever be
used. To maximize sharing of keys (thus minimizing memory use), create a
single function that constructs the map using the map syntax and always use
it.</p></li><li><p>Always update the map using the <code class="inline">:=</code> operator (that is, requiring that an
element with that key already exists). The <code class="inline">:=</code> operator is slightly more
efficient, and it helps catching mispellings of keys.</p></li><li><p>Whenever possible, match multiple map elements at once.</p></li><li><p>Whenever possible, update multiple map elements at once.</p></li><li><p>Avoid default values and the <a href="../apps/stdlib/maps.html#get/3"><code class="inline">maps:get/3</code></a> function. If there are default
values, sharing of keys between different instances of the map will be less
effective, and it is not possible to match multiple elements having default
values in one go.</p></li><li><p>To avoid having to deal with a map that may lack some keys, <a href="../apps/stdlib/maps.html#merge/2"><code class="inline">maps:merge/2</code></a> can
efficiently add multiple default values. For example:</p><pre><code class="makeup erlang" translate="no"><span class="n">DefaultMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="0254189349-1">#{</span><span class="ss">shoe_size</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="ss">editor</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">emacs</span><span class="p" data-group-id="0254189349-1">}</span><span class="p">,</span><span class="w">
</span><span class="n">MapWithDefaultsApplied</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">maps</span><span class="p">:</span><span class="nf">merge</span><span class="p" data-group-id="0254189349-2">(</span><span class="n">DefaultMap</span><span class="p">,</span><span class="w"> </span><span class="n">OtherMap</span><span class="p" data-group-id="0254189349-2">)</span></code></pre></li></ul><h2 id="using-maps-as-dictionaries" class="section-heading">
  <a href="#using-maps-as-dictionaries" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Using Maps as Dictionaries</span>
</h2>
<p>Using a map as a dictionary implies the following usage pattern:</p><ul><li>Keys are usually variables not known at compile-time.</li><li>There can be any number of elements in the map.</li><li>Usually, no more than one element is looked up or updated at once.</li></ul><p>Given that usage pattern, the difference in performance between using the map
syntax and the maps module is usually small. Therefore, which one to use is
mostly a matter of taste.</p><p>Maps are usually the most efficient dictionary data structure, with a few
exceptions:</p><ul><li>If it is necessary to frequently convert a dictionary to a sorted list, or
from a sorted list to a dictionary, using <a href="../apps/stdlib/gb_trees.html"><code class="inline">gb_trees</code></a> can be a better choice.</li><li>If all keys are non-negative integers, the <a href="../apps/stdlib/array.html"><code class="inline">array</code></a> module can be a better
choice.</li></ul><h2 id="using-maps-as-sets" class="section-heading">
  <a href="#using-maps-as-sets" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Using Maps as Sets</span>
</h2>
<p>Starting in OTP 24, the <a href="../apps/stdlib/sets.html"><code class="inline">sets</code></a> module has an option to represent sets as maps.
Examples:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="nc">sets</span><span class="p">:</span><span class="nf">new</span><span class="p" data-group-id="1929500004-1">(</span><span class="p" data-group-id="1929500004-2">[</span><span class="p" data-group-id="1929500004-3">{</span><span class="ss">version</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="1929500004-3">}</span><span class="p" data-group-id="1929500004-2">]</span><span class="p" data-group-id="1929500004-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1929500004-4">#{</span><span class="p" data-group-id="1929500004-4">}</span><span class="gp unselectable">
2&gt; </span><span class="nc">sets</span><span class="p">:</span><span class="nf">from_list</span><span class="p" data-group-id="1929500004-5">(</span><span class="p" data-group-id="1929500004-6">[</span><span class="ss">x</span><span class="p">,</span><span class="ss">y</span><span class="p">,</span><span class="ss">z</span><span class="p" data-group-id="1929500004-6">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1929500004-7">[</span><span class="p" data-group-id="1929500004-8">{</span><span class="ss">version</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="1929500004-8">}</span><span class="p" data-group-id="1929500004-7">]</span><span class="p" data-group-id="1929500004-5">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1929500004-9">#{</span><span class="ss">x</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p" data-group-id="1929500004-10">[</span><span class="p" data-group-id="1929500004-10">]</span><span class="p">,</span><span class="ss">y</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p" data-group-id="1929500004-11">[</span><span class="p" data-group-id="1929500004-11">]</span><span class="p">,</span><span class="ss">z</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p" data-group-id="1929500004-12">[</span><span class="p" data-group-id="1929500004-12">]</span><span class="p" data-group-id="1929500004-9">}</span></code></pre><p><code class="inline">sets</code> backed by maps is generally the most efficient set representation, with a
few possible exceptions:</p><ul><li><a href="../apps/stdlib/ordsets.html#intersection/2"><code class="inline">ordsets:intersection/2</code></a> can be more efficient than <a href="../apps/stdlib/sets.html#intersection/2"><code class="inline">sets:intersection/2</code></a>. If
the intersection operation is frequently used and operations that operate on a
single element in a set (such as <code class="inline">is_element/2</code>) are avoided, <a href="../apps/stdlib/ordsets.html"><code class="inline">ordsets</code></a> can
be a better choice than <a href="../apps/stdlib/sets.html"><code class="inline">sets</code></a>.</li><li>If the intersection operation is frequently used and operations that operate
on a single element in a set (such as <code class="inline">is_element/2</code>) must also be efficient,
<a href="../apps/stdlib/gb_sets.html"><code class="inline">gb_sets</code></a> can potentially be a better choice than <a href="../apps/stdlib/sets.html"><code class="inline">sets</code></a>.</li><li>If the elements of the set are integers in a fairly compact range, the set can
be represented as an integer where each bit represents an element in the set.
The union operation is performed by <code class="inline">bor</code> and the intersection operation by
<code class="inline">band</code>.</li></ul><h2 id="how-maps-are-implemented" class="section-heading">
  <a href="#how-maps-are-implemented" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">How Maps are Implemented</span>
</h2>
<p>Internally, maps have two distinct representations depending on the number of
elements in the map. The representation changes when a map grows beyond 32
elements, or when it shrinks to 32 elements or less.</p><ul><li>A map with at most 32 elements has a compact representation, making it
suitable as an alternative to records.</li><li>A map with more than 32 elements is represented as a tree that can be
efficiently searched and updated regardless of how many elements there are.</li></ul><h3 id="how-small-maps-are-implemented" class="section-heading">
  <a href="#how-small-maps-are-implemented" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">How Small Maps are Implemented</span>
</h3>
<p>A small map looks like this inside the runtime system:</p><table><thead><tr><th style="text-align: center;">0</th><th style="text-align: left;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;"></th><th style="text-align: center;">N</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>FLATMAP</strong></td><td style="text-align: left;"><em>N</em></td><td style="text-align: center;"><em>Keys</em></td><td style="text-align: center;"><em>Value1</em></td><td style="text-align: center;"><em>...</em></td><td style="text-align: center;"><em>ValueN</em></td></tr></tbody></table><p><em>Table: The representation of a small map</em></p><ul><li><p><strong><code class="inline">FLATMAP</code></strong> - The tag for a small map (called <em>flat map</em> in the source code
for the runtime system).</p></li><li><p><strong>N</strong> - The number of elements in the map.</p></li><li><p><strong>Keys</strong> - A tuple with keys of the map: <code class="inline">{Key1,...,KeyN}</code>. The keys are
sorted.</p></li><li><p><strong>Value1</strong> - The value corresponding to the first key in the key tuple.</p></li><li><p><strong>ValueN</strong> - The value corresponding to the last key in the key tuple.</p></li></ul><p>As an example, let us look at how the map <code class="inline">#{a =&gt; foo, z =&gt; bar}</code> is
represented:</p><table><thead><tr><th style="text-align: center;">0</th><th style="text-align: left;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: left;">4</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>FLATMAP</strong></td><td style="text-align: left;"><em>2</em></td><td style="text-align: center;"><code class="inline">{a,z}</code></td><td style="text-align: center;"><code class="inline">foo</code></td><td style="text-align: left;"><code class="inline">bar</code></td></tr></tbody></table><p><em>Table: #{a =&gt; foo, z =&gt; bar}</em></p><p>Let us update the map: <code class="inline">M#{q =&gt; baz}</code>. The map now looks like this:</p><table><thead><tr><th style="text-align: center;">0</th><th style="text-align: left;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>FLATMAP</strong></td><td style="text-align: left;"><em>3</em></td><td style="text-align: center;"><code class="inline">{a,q,z}</code></td><td style="text-align: center;"><code class="inline">foo</code></td><td style="text-align: center;"><code class="inline">baz</code></td><td style="text-align: center;"><code class="inline">bar</code></td></tr></tbody></table><p><em>Table: #{a =&gt; foo, q =&gt; baz, z =&gt; bar}</em></p><p>Finally, change the value of one element: <code class="inline">M#{z := bird}</code>. The map now looks
like this:</p><table><thead><tr><th style="text-align: center;">0</th><th style="text-align: left;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>FLATMAP</strong></td><td style="text-align: left;"><em>3</em></td><td style="text-align: center;"><code class="inline">{a,q,z}</code></td><td style="text-align: center;"><code class="inline">foo</code></td><td style="text-align: center;"><code class="inline">baz</code></td><td style="text-align: center;"><code class="inline">bird</code></td></tr></tbody></table><p><em>Table: #{a =&gt; foo, q =&gt; baz, z =&gt; bird}</em></p><p>When the value for an existing key is updated, the key tuple is not updated,
allowing the key tuple to be shared with other instances of the map that have
the same keys. In fact, the key tuple can be shared between all maps with the
same keys with some care. To arrange that, define a function that returns a map.
For example:</p><pre><code class="makeup erlang" translate="no"><span class="nf">new</span><span class="p" data-group-id="9074652551-1">(</span><span class="p" data-group-id="9074652551-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="9074652551-2">#{</span><span class="ss">a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">default</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">default</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">default</span><span class="p" data-group-id="9074652551-2">}</span><span class="p">.</span></code></pre><p>Defined like this, the key tuple <code class="inline">{a,b,c}</code> will be a global literal. To ensure
that the key tuple is shared when creating an instance of the map, always call
<code class="inline">new()</code> and modify the returned map:</p><pre><code class="makeup erlang" translate="no"><span class="w">    </span><span class="p" data-group-id="2720028829-1">(</span><span class="n">SOME_MODULE</span><span class="p">:</span><span class="nf">new</span><span class="p" data-group-id="2720028829-2">(</span><span class="p" data-group-id="2720028829-2">)</span><span class="p" data-group-id="2720028829-1">)</span><span class="p" data-group-id="2720028829-3">#{</span><span class="ss">a</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="mi">42</span><span class="p" data-group-id="2720028829-3">}</span><span class="p">.</span></code></pre><p>Using the map syntax with small maps is particularly efficient. As long as the
keys are known at compile-time, the map is updated in one go, making the time to
update a map essentially constant regardless of the number of keys updated. The
same goes for matching. (When the keys are variables, one or more of the keys
could be identical, so the operations need to be performed sequentially from
left to right.)</p><p>The memory size for a small map is the size of all keys and values plus 5 words.
See <a href="memory.html">Memory</a> for more information about memory sizes.</p><h3 id="how-large-maps-are-implemented" class="section-heading">
  <a href="#how-large-maps-are-implemented" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">How Large Maps are Implemented</span>
</h3>
<p>A map with more than 32 elements is implemented as a
<a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">Hash array mapped trie (HAMT)</a>.
A large map can be efficiently searched and updated regardless of the number of
elements in the map.</p><p>There is less performance to be gained by matching or updating multiple elements
using the map syntax on a large map compared to a small map. The execution time
is roughly proportional to the number of elements matched or updated.</p><p>The storage overhead for a large map is higher than for a small map. For a large
map, the extra number of words besides the keys and values is roughly
proportional to the number of elements. For a map with 33 elements the overhead
is at least 53 heap words according to the formula in
<a href="memory.html">Memory</a> (compared to 5 extra words for a small map
regardless of the number of elements).</p><p>When a large map is updated, the updated map and the original map will share
common parts of the HAMT, but sharing will never be as effective as the best
possible sharing of the key tuple for small maps.</p><p>Therefore, if maps are used instead of records and it is expected that many
instances of the map will be created, it is more efficient from a memory
standpoint to avoid using large maps (for example, by grouping related map
elements into sub maps to reduce the number of elements).</p><h2 id="using-the-map-syntax" class="section-heading">
  <a href="#using-the-map-syntax" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Using the Map Syntax</span>
</h2>
<p>Using the map syntax is usually slightly more efficient than using the
corresponding function in the <a href="../apps/stdlib/maps.html"><code class="inline">maps</code></a> module.</p><p>The gain in efficiency for the map syntax is more noticeable for the following
operations that can only be achieved using the map syntax:</p><ul><li>Matching multiple literal keys</li><li>Updating multiple literal keys</li><li>Adding multiple literal keys to a map</li></ul><p>For example:</p><p><strong>DO</strong></p><pre><code class="makeup erlang" translate="no"><span class="n">Map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Map1</span><span class="p" data-group-id="1180162063-1">#{</span><span class="ss">x</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="ss">z</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Z</span><span class="p" data-group-id="1180162063-1">}</span></code></pre><p><strong>DO NOT</strong></p><pre><code class="makeup erlang" translate="no"><span class="n">Map2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">maps</span><span class="p">:</span><span class="nf">update</span><span class="p" data-group-id="9616890875-1">(</span><span class="ss">x</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Map1</span><span class="p" data-group-id="9616890875-1">)</span><span class="p">,</span><span class="w">
</span><span class="n">Map3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">maps</span><span class="p">:</span><span class="nf">update</span><span class="p" data-group-id="9616890875-2">(</span><span class="ss">y</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="n">Map2</span><span class="p" data-group-id="9616890875-2">)</span><span class="p">,</span><span class="w">
</span><span class="n">Map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">maps</span><span class="p">:</span><span class="nf">update</span><span class="p" data-group-id="9616890875-3">(</span><span class="ss">z</span><span class="p">,</span><span class="w"> </span><span class="n">Z</span><span class="p">,</span><span class="w"> </span><span class="n">Map3</span><span class="p" data-group-id="9616890875-3">)</span></code></pre><p>If the map is a small map, the first example runs roughly three times as fast.</p><p>Note that for variable keys, the elements are updated sequentially from left to
right. For example, given the following update with variable keys:</p><pre><code class="makeup erlang" translate="no"><span class="n">Map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Map1</span><span class="p" data-group-id="8268459414-1">#{</span><span class="n">Key1</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Key2</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="n">Key3</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Z</span><span class="p" data-group-id="8268459414-1">}</span></code></pre><p>the compiler rewrites it like this to ensure that the updates are applied from
left to right:</p><pre><code class="makeup erlang" translate="no"><span class="n">Map2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Map1</span><span class="p" data-group-id="8360536874-1">#{</span><span class="n">Key1</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">X</span><span class="p" data-group-id="8360536874-1">}</span><span class="p">,</span><span class="w">
</span><span class="n">Map3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Map2</span><span class="p" data-group-id="8360536874-2">#{</span><span class="n">Key2</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Y</span><span class="p" data-group-id="8360536874-2">}</span><span class="p">,</span><span class="w">
</span><span class="n">Map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Map3</span><span class="p" data-group-id="8360536874-3">#{</span><span class="n">Key3</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Z</span><span class="p" data-group-id="8360536874-3">}</span></code></pre><p>If a key is known to exist in a map, using the <code class="inline">:=</code> operator is slightly more
efficient than using the <code class="inline">=&gt;</code> operator for a small map.</p><h2 id="using-the-functions-in-the-maps-module" class="section-heading">
  <a href="#using-the-functions-in-the-maps-module" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Using the Functions in the maps Module</span>
</h2>
<p>Here follows some notes about most of the functions in the <code class="inline">maps</code> module. For
each function, the implementation language (C or Erlang) is stated. The reason
we mention the language is that it gives an hint about how efficient the
function is:</p><ul><li><p>If a function is implemented in C, it is pretty much impossible to implement
the same functionality more efficiently in Erlang.</p></li><li><p>However, it might be possible to beat the <code class="inline">maps</code> modules functions implemented
in Erlang, because they are generally implemented in a way that attempts to
make the performance reasonable for all possible inputs.</p><p>For example, <a href="../apps/stdlib/maps.html#map/2"><code class="inline">maps:map/2</code></a> iterates over all elements of the map, calling the
mapping fun, collects the updated map elements in a list, and finally converts
the list back to a map using <a href="../apps/stdlib/maps.html#from_list/1"><code class="inline">maps:from_list/1</code></a>. If it is known that at most
one percent of the values in the map will change, it can be more efficient to
update only the changed values.</p></li></ul><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The implementation details given in this section can change in the future.</p></section><h3 id="maps-filter-2" class="section-heading">
  <a href="#maps-filter-2" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:filter/2</span>
</h3>
<p><a href="../apps/stdlib/maps.html#filter/2"><code class="inline">maps:filter/2</code></a> is implemented in Erlang. It creates a new map using
<a href="../apps/stdlib/maps.html#from_list/1"><code class="inline">maps:from_list/1</code></a>. If it is known that only a minority of the values will be
removed, it can be more efficient to avoid <a href="../apps/stdlib/maps.html#filter/2"><code class="inline">maps:filter/2</code></a> and write a function
that will use <a href="../apps/stdlib/maps.html#remove/2">maps:remove/3</a> to remove the unwanted values.</p><h3 id="maps-filtermap-2" class="section-heading">
  <a href="#maps-filtermap-2" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:filtermap/2</span>
</h3>
<p><a href="../apps/stdlib/maps.html#filtermap/2"><code class="inline">maps:filtermap/2</code></a> is implemented in Erlang. It creates a new map using
<a href="../apps/stdlib/maps.html#from_list/1"><code class="inline">maps:from_list/1</code></a>. See the notes for <a href="../apps/stdlib/maps.html#map/2"><code class="inline">maps:map/2</code></a> and <a href="../apps/stdlib/maps.html#filter/2"><code class="inline">maps:filter/2</code></a> for hints
on how to implement a more efficient version.</p><h3 id="maps-find-2" class="section-heading">
  <a href="#maps-find-2" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:find/2</span>
</h3>
<p><a href="../apps/stdlib/maps.html#find/2"><code class="inline">maps:find/2</code></a> is implemented in C.</p><p>Using the map matching syntax instead of <a href="../apps/stdlib/maps.html#find/2"><code class="inline">maps:find/2</code></a> will be slightly more
efficient since building an <code class="inline">{ok,Value}</code> tuple will be avoided.</p><h3 id="maps-get-2" class="section-heading">
  <a href="#maps-get-2" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:get/2</span>
</h3>
<p>As an optimization, the compiler will rewrite a call to <a href="../apps/stdlib/maps.html#get/2"><code class="inline">maps:get/2</code></a> to a call
to the guard BIF <a href="../apps/erts/erlang.html#map_get/2">map_get/2</a>. A call to a guard BIF is more
efficient than calls to other BIFs, making the performance similar to using the
map matching syntax.</p><p>If the map is small and the keys are constants known at compile-time, using the
map matching syntax will be more efficient than multiple calls to <a href="../apps/stdlib/maps.html#get/2"><code class="inline">maps:get/2</code></a>.</p><p><a href="" id="maps_get_3"></a></p><h3 id="maps-get-3" class="section-heading">
  <a href="#maps-get-3" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:get/3</span>
</h3>
<p>As an optimization, the compiler will rewrite a call to <a href="../apps/stdlib/maps.html#get/3"><code class="inline">maps:get/3</code></a> to Erlang
code similar to the following:</p><pre><code class="makeup erlang" translate="no"><span class="n">Result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="n">Map</span><span class="w"> </span><span class="k">of</span><span class="w">
             </span><span class="p" data-group-id="3402244509-1">#{</span><span class="n">Key</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Value</span><span class="p" data-group-id="3402244509-1">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">Value</span><span class="p">;</span><span class="w">
             </span><span class="p" data-group-id="3402244509-2">#{</span><span class="p" data-group-id="3402244509-2">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">Default</span><span class="w">
         </span><span class="k">end</span></code></pre><p>This is reasonably efficient, but if a small map is used as an alternative to
using a record it is often better not to rely on default values as it prevents
sharing of keys, which may in the end use more memory than what you save from
not storing default values in the map.</p><p>If default values are nevertheless required, instead of calling <a href="../apps/stdlib/maps.html#get/3"><code class="inline">maps:get/3</code></a>
multiple times, consider putting the default values in a map and merging that
map with the other map:</p><pre><code class="makeup erlang" translate="no"><span class="n">DefaultMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="6666315720-1">#{</span><span class="n">Key1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">Value2</span><span class="p">,</span><span class="w"> </span><span class="n">Key2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">Value2</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="n">KeyN</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">ValueN</span><span class="p" data-group-id="6666315720-1">}</span><span class="p">,</span><span class="w">
</span><span class="n">MapWithDefaultsApplied</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">maps</span><span class="p">:</span><span class="nf">merge</span><span class="p" data-group-id="6666315720-2">(</span><span class="n">DefaultMap</span><span class="p">,</span><span class="w"> </span><span class="n">OtherMap</span><span class="p" data-group-id="6666315720-2">)</span></code></pre><p>This helps share keys between the default map and the one you applied defaults
to, as long as the default map contains <em>all</em> the keys that will ever be used
and not just the ones with default values. Whether this is faster than calling
<a href="../apps/stdlib/maps.html#get/3"><code class="inline">maps:get/3</code></a> multiple times depends on the size of the map and the number of
default values.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>Before OTP 26.0 <a href="../apps/stdlib/maps.html#get/3"><code class="inline">maps:get/3</code></a> was implemented by calling the function instead
of rewriting it as an Erlang expression. It is now slightly faster but can no
longer be traced.</p></section><h3 id="maps-intersect-2-maps-intersect_with-3" class="section-heading">
  <a href="#maps-intersect-2-maps-intersect_with-3" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:intersect/2, maps:intersect_with/3</span>
</h3>
<p><a href="../apps/stdlib/maps.html#intersect/2"><code class="inline">maps:intersect/2</code></a> and <a href="../apps/stdlib/maps.html#intersect_with/3"><code class="inline">maps:intersect_with/3</code></a> are implemented in Erlang. They
both create new maps using <a href="../apps/stdlib/maps.html#from_list/1"><code class="inline">maps:from_list/1</code></a>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>A map is usually the most efficient way to implement a set, but an exception
is the intersection operation, where <a href="../apps/stdlib/ordsets.html#intersection/2"><code class="inline">ordsets:intersection/2</code></a> used on
<a href="../apps/stdlib/ordsets.html"><code class="inline">ordsets</code></a> can be more efficient than <a href="../apps/stdlib/maps.html#intersect/2"><code class="inline">maps:intersect/2</code></a> on sets implemented
as maps.</p></section><h3 id="maps-from_list-1" class="section-heading">
  <a href="#maps-from_list-1" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:from_list/1</span>
</h3>
<p><a href="../apps/stdlib/maps.html#from_list/1"><code class="inline">maps:from_list/1</code></a> is implemented in C.</p><h3 id="maps-from_keys-2" class="section-heading">
  <a href="#maps-from_keys-2" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:from_keys/2</span>
</h3>
<p><a href="../apps/stdlib/maps.html#from_keys/2"><code class="inline">maps:from_keys/2</code></a> is implemented in C.</p><h3 id="maps-is_key-2" class="section-heading">
  <a href="#maps-is_key-2" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:is_key/2</span>
</h3>
<p>As an optimization, the compiler rewrites calls to <a href="../apps/stdlib/maps.html#is_key/2"><code class="inline">maps:is_key/2</code></a> to calls to
the guard BIF <a href="../apps/erts/erlang.html#is_map_key/2">is_map_key/2</a>. A call to a guard BIF is
more efficient than calls to other BIFs, making the performance similar to using
the map matching syntax.</p><h3 id="maps-iterator-1" class="section-heading">
  <a href="#maps-iterator-1" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:iterator/1</span>
</h3>
<p><a href="../apps/stdlib/maps.html#iterator/1"><code class="inline">maps:iterator/1</code></a> is efficiently implemented in C and Erlang.</p><h3 id="maps-keys-1" class="section-heading">
  <a href="#maps-keys-1" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:keys/1</span>
</h3>
<p><a href="../apps/stdlib/maps.html#keys/1"><code class="inline">maps:keys/1</code></a> is implemented in C. If the resulting list needs to be ordered,
use <a href="../apps/stdlib/lists.html#sort/1"><code class="inline">lists:sort/1</code></a> to sort the result.</p><h3 id="maps-map-2" class="section-heading">
  <a href="#maps-map-2" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:map/2</span>
</h3>
<p><a href="../apps/stdlib/maps.html#map/2"><code class="inline">maps:map/2</code></a> is implemented in Erlang. It creates a new map using
<a href="../apps/stdlib/maps.html#from_list/1"><code class="inline">maps:from_list/1</code></a>. If it is known that only a minority of the values will be
updated, it can be more efficient to avoid <a href="../apps/stdlib/maps.html#map/2"><code class="inline">maps:map/2</code></a> and write a function
that will call <a href="../apps/stdlib/maps.html#update/3"><code class="inline">maps:update/3</code></a> to update only the values that have changed.</p><h3 id="maps-merge-2" class="section-heading">
  <a href="#maps-merge-2" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:merge/2</span>
</h3>
<p><a href="../apps/stdlib/maps.html#merge/2"><code class="inline">maps:merge/2</code></a> is implemented in C. For <a href="maps.html#terminology">small maps</a>, the
key tuple may be shared with any of the argument maps if that argument map
contains all the keys. Literal key tuples are prefered if possible.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>The sharing of key tuples by <a href="../apps/stdlib/maps.html#merge/2"><code class="inline">maps:merge/2</code></a> was introduced in OTP 26.0. Older
versions always contructed a new key tuple on the callers heap.</p></section><h3 id="maps-merge_with-3" class="section-heading">
  <a href="#maps-merge_with-3" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:merge_with/3</span>
</h3>
<p><a href="../apps/stdlib/maps.html#merge_with/3"><code class="inline">maps:merge_with/3</code></a> is implemented in Erlang. It updates and returns the larger
of the two maps.</p><h3 id="maps-new-0" class="section-heading">
  <a href="#maps-new-0" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:new/0</span>
</h3>
<p>The compiler rewrites a call to <a href="../apps/stdlib/maps.html#new/0"><code class="inline">maps:new/0</code></a> to using the syntax <code class="inline">#{}</code> for
constructing an empty map.</p><h3 id="maps-next-1" class="section-heading">
  <a href="#maps-next-1" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:next/1</span>
</h3>
<p><a href="../apps/stdlib/maps.html#next/1"><code class="inline">maps:next/1</code></a> is efficiently implemented in C and Erlang.</p><h3 id="maps-put-3" class="section-heading">
  <a href="#maps-put-3" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:put/3</span>
</h3>
<p><a href="../apps/stdlib/maps.html#put/3"><code class="inline">maps:put/3</code></a> is implemented in C.</p><p>If the key is known to already exist in the map, <a href="../apps/stdlib/maps.html#update/3"><code class="inline">maps:update/3</code></a> is slightly
more efficient than <a href="../apps/stdlib/maps.html#put/3"><code class="inline">maps:put/3</code></a>.</p><p>If the keys are constants known at compile-time, using the map update syntax
with the <code class="inline">=&gt;</code> operator is more efficient than multiple calls to <a href="../apps/stdlib/maps.html#put/3"><code class="inline">maps:put/3</code></a>,
especially for small maps.</p><h3 id="maps-remove-2" class="section-heading">
  <a href="#maps-remove-2" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:remove/2</span>
</h3>
<p><a href="../apps/stdlib/maps.html#remove/2"><code class="inline">maps:remove/2</code></a> is implemented in C.</p><h3 id="maps-size-1" class="section-heading">
  <a href="#maps-size-1" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:size/1</span>
</h3>
<p>As an optimization, the compiler rewrites calls to <a href="../apps/stdlib/maps.html#size/1"><code class="inline">maps:size/1</code></a> to calls to the
guard BIF <a href="../apps/erts/erlang.html#map_size/1">map_size/1</a>. Calls to guard BIFs are more
efficient than calls to other BIFs.</p><h3 id="maps-take-2" class="section-heading">
  <a href="#maps-take-2" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:take/2</span>
</h3>
<p><a href="../apps/stdlib/maps.html#take/2"><code class="inline">maps:take/2</code></a> is implemented in C.</p><h3 id="maps-to_list-1" class="section-heading">
  <a href="#maps-to_list-1" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:to_list/1</span>
</h3>
<p><a href="../apps/stdlib/maps.html#to_list/1"><code class="inline">maps:to_list/1</code></a> is efficiently implemented in C and Erlang. If the resulting
list needs to be ordered, use <a href="../apps/stdlib/lists.html#sort/1"><code class="inline">lists:sort/1</code></a> to sort the result.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Maps are usually more performant than <a href="../apps/stdlib/gb_trees.html"><code class="inline">gb_trees</code></a>, but if it is necessary to
frequently convert to and from sorted lists, <code class="inline">gb_trees</code> can be a better
choice.</p></section><h3 id="maps-update-3" class="section-heading">
  <a href="#maps-update-3" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:update/3</span>
</h3>
<p><a href="../apps/stdlib/maps.html#update/3"><code class="inline">maps:update/3</code></a> is implemented in C.</p><p>If the keys are constants known at compile-time, using the map update syntax
with the <code class="inline">:=</code> operator is more efficient than multiple calls to <a href="../apps/stdlib/maps.html#update/3"><code class="inline">maps:update/3</code></a>,
especially for <a href="maps.html#terminology">small maps</a>.</p><h3 id="maps-values-1" class="section-heading">
  <a href="#maps-values-1" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:values/1</span>
</h3>
<p><a href="../apps/stdlib/maps.html#values/1"><code class="inline">maps:values/1</code></a> is implemented in C.</p><h3 id="maps-with-2" class="section-heading">
  <a href="#maps-with-2" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:with/2</span>
</h3>
<p><a href="../apps/stdlib/maps.html#with/2"><code class="inline">maps:with/2</code></a> is implemented in Erlang. It creates a new map using
<a href="../apps/stdlib/maps.html#from_list/1"><code class="inline">maps:from_list/1</code></a>.</p><h3 id="maps-without-2" class="section-heading">
  <a href="#maps-without-2" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">maps:without/2</span>
</h3>
<p><a href="../apps/stdlib/maps.html#without/2"><code class="inline">maps:without/2</code></a> is implemented in Erlang. It returns a modified copy of the
input map.</p>
</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="binaryhandling.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Constructing and Matching Binaries
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="listhandling.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
List Handling
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="Erlang System Documentation.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.37.3) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright © 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
