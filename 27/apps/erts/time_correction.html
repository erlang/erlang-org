<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.37.3">
    <meta name="project" content="erts v15.2.7.4">


<meta name="major-vsn" content="27">
<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=27&q=">
<link rel="canonical" href="https://www.erlang.org/doc/apps/erts/time_correction.html" />
    <title>Time and Time Correction in Erlang — erts v15.2.7.4</title>

    <link rel="stylesheet" href="dist/html-erlang-FDBURIED.css" />

    <script defer src="dist/sidebar_items-F22904F5.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-ALU6OERS.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="erts" />
        </a>

      <div>
        <a href="../../index.html" class="sidebar-projectName" translate="no">
erts
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v15.2.7.4
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of erts</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>Time and Time Correction in Erlang</h1>


      <a href="https://github.com/erlang/otp/blob/OTP-27.3.4.6/erts/doc/guides/time_correction.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>

<h2 id="extended-time-functionality" class="section-heading">
  <a href="#extended-time-functionality" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Extended Time Functionality</span>
</h2>
<p>As of Erlang/OTP 18 (ERTS 7.0) the time functionality was extended. This
includes a <a href="time_correction.html#new-time-api">new API</a> for time and
<a href="time_correction.html#time-warp-modes">time warp modes</a> that change the system
behavior when system time changes.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>As of Erlang/OTP 26 (ERTS 14.0) the
<a href="time_correction.html#multi-time-warp-mode">multi time warp mode</a> is enabled by
default. This assumes that all code executing on the system is
<a href="time_correction.html#time-warp-safe-code">time warp safe</a>.</p><p>If you have old code in the system that is not time warp safe, you now
explicitly need to start the system in
<a href="time_correction.html#no-time-warp-mode">no time warp mode</a> (or
<a href="time_correction.html#single-time-warp-mode">singe time warp mode</a> if it is
partially time warp safe) in order to avoid problems. When starting the system
in no time warp mode, the system behaves as it did prior to the introduction
of the extended time functionality introduced in OTP 18.</p><p>If you have code that is not time warp safe, you are strongly encouraged to
change this so that you can use multi time warp mode. Compared to no time warp
mode, multi time warp mode improves scalability and performance as well as
accuracy and precision of time measurements.</p></section><h2 id="terminology" class="section-heading">
  <a href="#terminology" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Terminology</span>
</h2>
<p>To make it easier to understand this section, some terms are defined. This is a
mix of our own terminology (Erlang/OS system time, Erlang/OS monotonic time,
time warp) and globally accepted terminology.</p><h3 id="monotonically-increasing" class="section-heading">
  <a href="#monotonically-increasing" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Monotonically Increasing</span>
</h3>
<p>In a monotonically increasing sequence of values, all values that have a
predecessor are either larger than or equal to its predecessor.</p><h3 id="strictly-monotonically-increasing" class="section-heading">
  <a href="#strictly-monotonically-increasing" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Strictly Monotonically Increasing</span>
</h3>
<p>In a strictly monotonically increasing sequence of values, all values that have
a predecessor are larger than its predecessor.</p><h3 id="ut1" class="section-heading">
  <a href="#ut1" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">UT1</span>
</h3>
<p>Universal Time. UT1 is based on the rotation of the earth and conceptually means
solar time at 0° longitude.</p><h3 id="utc" class="section-heading">
  <a href="#utc" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">UTC</span>
</h3>
<p>Coordinated Universal Time. UTC almost aligns with
<a href="time_correction.html#ut1">UT1</a>. However, UTC uses the SI definition of a second,
which has not exactly the same length as the second used by UT1. This means that
UTC slowly drifts from UT1. To keep UTC relatively in sync with UT1, leap
seconds are inserted, and potentially also deleted. That is, an UTC day can be
86400, 86401, or 86399 seconds long.</p><h3 id="posix-time" class="section-heading">
  <a href="#posix-time" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">POSIX Time</span>
</h3>
<p>Time since
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap03.html#tag_21_03_00_17">Epoch</a>.
Epoch is defined to be 00:00:00 <a href="time_correction.html#utc">UTC</a>, 1970-01-01.
<a href="http://pubs.opengroup.org/onlinepubs/009604499/basedefs/xbd_chap04.html#tag_04_14">A day in POSIX time</a>
is defined to be exactly 86400 seconds long. Strangely enough, Epoch is defined
to be a time in UTC, and UTC has another definition of how long a day is.
Quoting the Open Group
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_15">&quot;POSIX time is therefore not necessarily UTC, despite its appearance&quot;</a>.
The effect of this is that when an UTC leap second is inserted, POSIX time
either stops for a second, or repeats the last second. If an UTC leap second
would be deleted (which has not happened yet), POSIX time would make a one
second leap forward.</p><h3 id="time-resolution" class="section-heading">
  <a href="#time-resolution" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Time Resolution</span>
</h3>
<p>The shortest time interval that can be distinguished when reading time values.</p><h3 id="time-precision" class="section-heading">
  <a href="#time-precision" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Time Precision</span>
</h3>
<p>The shortest time interval that can be distinguished repeatedly and reliably
when reading time values. Precision is limited by the
<a href="time_correction.html#time-resolution">resolution</a>, but resolution and precision
can differ significantly.</p><h3 id="time-accuracy" class="section-heading">
  <a href="#time-accuracy" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Time Accuracy</span>
</h3>
<p>The correctness of time values.</p><h3 id="time-warp" class="section-heading">
  <a href="#time-warp" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Time Warp</span>
</h3>
<p>A time warp is a leap forwards or backwards in time. That is, the difference of
time values taken before and after the time warp does not correspond to the
actual elapsed time.</p><h3 id="os-system-time" class="section-heading">
  <a href="#os-system-time" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">OS System Time</span>
</h3>
<p>The operating systems view of <a href="time_correction.html#posix-time">POSIX time</a>. To
retrieve it, call <a href="../../apps/kernel/os.html#system_time/0"><code class="inline">os:system_time()</code></a>. This may or may not
be an accurate view of POSIX time. This time may typically be adjusted both
backwards and forwards without limitation. That is,
<a href="time_correction.html#time-warp">time warps</a> may be observed.</p><p>To get information about the Erlang runtime system's source of OS system time,
call
<a href="erlang.html#system_info_os_system_time_source"><code class="inline">erlang:system_info(os_system_time_source)</code></a>.</p><h3 id="os-monotonic-time" class="section-heading">
  <a href="#os-monotonic-time" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">OS Monotonic Time</span>
</h3>
<p>A monotonically increasing time provided by the OS. This time does not leap and
has a relatively steady frequency although not completely correct. However, it
is not uncommon that OS monotonic time stops if the system is suspended. This
time typically increases since some unspecified point in time that is not
connected to <a href="time_correction.html#os-system-time">OS system time</a>. This type of
time is not necessarily provided by all OSs.</p><p>To get information about the Erlang runtime system's source of OS monotonic
time, call
<a href="erlang.html#system_info_os_monotonic_time_source"><code class="inline">erlang:system_info(os_monotonic_time_source)</code></a>.</p><h3 id="erlang-system-time" class="section-heading">
  <a href="#erlang-system-time" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Erlang System Time</span>
</h3>
<p>The Erlang runtime systems view of <a href="time_correction.html#posix-time">POSIX time</a>.
To retrieve it, call <a href="erlang.html#system_time/0"><code class="inline">erlang:system_time()</code></a>.</p><p>This time may or may not be an accurate view of POSIX time, and may or may not
align with <a href="time_correction.html#os-system-time">OS system time</a>. The runtime
system works towards aligning the two system times. Depending on the
<a href="time_correction.html#time-warp-modes">time warp mode</a> used, this can be achieved
by letting Erlang system time perform a
<a href="time_correction.html#time-warp">time warp</a>.</p><h3 id="erlang-monotonic-time" class="section-heading">
  <a href="#erlang-monotonic-time" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Erlang Monotonic Time</span>
</h3>
<p>A monotonically increasing time provided by the Erlang runtime system. Erlang
monotonic time increases since some unspecified point in time. To retrieve it,
call <a href="erlang.html#monotonic_time/0"><code class="inline">erlang:monotonic_time()</code></a>.</p><p>The <a href="time_correction.html#time-accuracy">accuracy</a> and
<a href="time_correction.html#time-precision">precision</a> of Erlang monotonic time heavily
depends on the following:</p><ul><li>Accuracy and precision of
<a href="time_correction.html#os-monotonic-time">OS monotonic time</a></li><li>Accuracy and precision of <a href="time_correction.html#os-system-time">OS system time</a></li><li><a href="time_correction.html#time-warp-modes">time warp mode</a> used</li></ul><p>On a system without OS monotonic time, Erlang monotonic time guarantees
monotonicity, but cannot give other guarantees. The frequency adjustments made
to Erlang monotonic time depend on the time warp mode used.</p><p>Internally in the runtime system, Erlang monotonic time is the &quot;time engine&quot;
that is used for more or less everything that has anything to do with time. All
timers, regardless of it is a <code class="inline">receive ... after</code> timer, BIF timer, or a timer
in the <a href="../../apps/stdlib/timer.html"><code class="inline">timer</code></a> module, are triggered relative Erlang monotonic time. Even
<a href="time_correction.html#erlang-system-time">Erlang system time</a> is based on Erlang
monotonic time. By adding current Erlang monotonic time with current time
offset, you get current Erlang system time.</p><p>To retrieve the current time offset, call <a href="erlang.html#time_offset/0"><code class="inline">erlang:time_offset/0</code></a>.</p><h3 id="timers" class="section-heading">
  <a href="#timers" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Timers</span>
</h3>
<p>All timers are triggered relative Erlang monotonic time. All timers currently
have millisecond resolution both in the API and internally in the runtime
system. That is, resolution (as well as precision and accuracy) will not be
higher than millisecond. If <a href="#erlang-monotonic-time">Erlang monotonic time</a> has
a lower resolution than millisecond, the timer resolution will be lower than
millisecond as well.</p><p>Timers can only be triggered on whole milliseconds since <a href="erlang.html#system_info_start_time">the runtime
system start</a>. A timer is not allowed to
trigger before the timeout time given by the user. That is, assuming that the
system is <em>not</em> heavily loaded, a timer will typically be triggered in the range
[<code class="inline">T</code>, <code class="inline">T+1</code>) milliseconds when the user has given the timeout time <code class="inline">T</code>. If the
system is heavily loaded, it may take an even longer time until a timer is
triggered.</p><h2 id="introduction" class="section-heading">
  <a href="#introduction" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Introduction</span>
</h2>
<p>Time is vital to an Erlang program and, more importantly, <em>correct</em> time is
vital to an Erlang program. As Erlang is a language with soft real-time
properties and we can express time in our programs, the Virtual Machine and the
language must be careful about what is considered a correct time and in how time
functions behave.</p><p>When Erlang was designed, it was assumed that the wall clock time in the system
showed a monotonic time moving forward at exactly the same pace as the
definition of time. This more or less meant that an atomic clock (or better time
source) was expected to be attached to your hardware and that the hardware was
then expected to be locked away from any human tinkering forever. While this can
be a compelling thought, it is simply never the case.</p><p>A &quot;normal&quot; modern computer cannot keep time, not on itself and not unless you
have a chip-level atomic clock wired to it. Time, as perceived by your computer,
must normally be corrected. Hence the Network Time Protocol (NTP) protocol,
together with the <code class="inline">ntpd</code> process, does its best to keep your computer time in
sync with the correct time. Between NTP corrections, usually a less potent
time-keeper than an atomic clock is used.</p><p>However, NTP is not fail-safe. The NTP server can be unavailable, <code class="inline">ntp.conf</code> can
be wrongly configured, or your computer can sometimes be disconnected from
Internet. Furthermore, you can have a user (or even system administrator) who
thinks the correct way to handle Daylight Saving Time is to adjust the clock one
hour two times a year (which is the incorrect way to do it). To complicate
things further, this user fetched your software from Internet and has not
considered what the correct time is as perceived by a computer. The user does
not care about keeping the wall clock in sync with the correct time. The user
expects your program to have unlimited knowledge about the time.</p><p>Most programmers also expect time to be reliable, at least until they realize
that the wall clock time on their workstation is off by a minute. Then they set
it to the correct time, but most probably not in a smooth way.</p><p>The number of problems that arise when you always expect the wall clock time on
the system to be correct can be immense. Erlang therefore introduced the
&quot;corrected estimate of time&quot;, or the &quot;time correction&quot;, many years ago. The time
correction relies on the fact that most operating systems have some kind of
monotonic clock, either a real-time extension or some built-in &quot;tick counter&quot;
that is independent of the wall clock settings. This counter can have
microsecond resolution or much less, but it has a drift that cannot be ignored.</p><h2 id="time-correction" class="section-heading">
  <a href="#time-correction" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Time Correction</span>
</h2>
<p>If time correction is enabled, the Erlang runtime system makes use of both
<a href="time_correction.html#os-system-time">OS system time</a> and
<a href="time_correction.html#os-monotonic-time">OS monotonic time</a>, to adjust the
frequency of the Erlang monotonic clock. Time correction ensures that
<a href="time_correction.html#erlang-monotonic-time">Erlang monotonic time</a> does not warp
and that the frequency is relatively accurate. The type of frequency adjustments
depends on the time warp mode used. Section
<a href="time_correction.html#time-warp-modes">Time Warp Modes</a> provides more details.</p><p>By default time correction is enabled if support for it exists on the specific
platform. Support for it includes both OS monotonic time, provided by the OS,
and an implementation in the Erlang runtime system using OS monotonic time. To
check if your system has support for OS monotonic time, call
<a href="erlang.html#system_info_os_monotonic_time_source"><code class="inline">erlang:system_info(os_monotonic_time_source)</code></a>.
To check if time correction is enabled on your system, call
<a href="erlang.html#system_info_time_correction"><code class="inline">erlang:system_info(time_correction)</code></a>.</p><p>To enable or disable time correction, pass command-line argument
<a href="erl_cmd.html#+c"><code class="inline">+c [true|false]</code></a> to <a href="erl_cmd.html"><code class="inline">erl(1)</code></a>.</p><p>If time correction is disabled, Erlang monotonic time can warp forwards or stop,
or even freeze for extended periods of time. There are then no guarantees that
the frequency of the Erlang monotonic clock is accurate or stable.</p><p><em>You typically never want to disable time correction</em>. Previously a performance
penalty was associated with time correction, but nowadays it is usually the
other way around. If time correction is disabled, you probably get bad
scalability, bad performance, and bad time measurements.</p><h2 id="time-warp-safe-code" class="section-heading">
  <a href="#time-warp-safe-code" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Time Warp Safe Code</span>
</h2>
<p>Time warp safe code can handle a <a href="time_correction.html#time-warp">time warp</a> of
<a href="time_correction.html#erlang-system-time">Erlang system time</a>.</p><p><a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> behaves bad when Erlang system time warps. When Erlang system
time does a time warp backwards, the values returned from <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> freeze
(if you disregard the microsecond increments made because of the actual call)
until OS system time reaches the point of the last value returned by
<a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a>. This freeze can continue for a long time. It can take years,
decades, and even longer until the freeze stops.</p><p>All uses of <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> are not necessarily time warp unsafe. If you do not
use it to get time, it is time warp safe. However, <em>all uses of <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a>
are suboptimal</em> from a performance and scalability perspective. So you really
want to replace the use of it with other functionality. For examples of how to
replace the use of <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a>, see section
<a href="time_correction.html#Dos_and_Donts">How to Work with the New API</a>.</p><h2 id="time-warp-modes" class="section-heading">
  <a href="#time-warp-modes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Time Warp Modes</span>
</h2>
<p>Current <a href="time_correction.html#erlang-system-time">Erlang system time</a> is
determined by adding the current
<a href="erlang.html#monotonic_time/0">Erlang monotonic time</a> with current
<a href="erlang.html#time_offset/0">time offset</a>. The time offset is managed differently
depending on which time warp mode you use.</p><p>To set the time warp mode, pass command-line argument
<a href="erl_cmd.html#+C_"><code class="inline">+C [no_time_warp|single_time_warp|multi_time_warp]</code></a> to
<a href="erl_cmd.html"><code class="inline">erl(1)</code></a>.</p><h3 id="no-time-warp-mode" class="section-heading">
  <a href="#no-time-warp-mode" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">No Time Warp Mode</span>
</h3>
<p>The time offset is determined at runtime system start and does not change later.
This is the same behavior as was default prior to OTP 26 (ERTS 14.0), and the
only behavior prior to OTP 18 (ERTS 7.0).</p><p>As the time offset is not allowed to change, time correction must adjust the
frequency of the Erlang monotonic clock to align Erlang system time with OS
system time smoothly. A significant downside of this approach is that we on
purpose will use a faulty frequency on the Erlang monotonic clock if adjustments
are needed. This error can be as large as 1%. This error will show up in all
time measurements in the runtime system.</p><p>If time correction is not enabled, Erlang monotonic time freezes when OS system
time leaps backwards. The freeze of monotonic time continues until OS system
time catches up. The freeze can continue for a long time. When OS system time
leaps forwards, Erlang monotonic time also leaps forward.</p><h3 id="single-time-warp-mode" class="section-heading">
  <a href="#single-time-warp-mode" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Single Time Warp Mode</span>
</h3>
<p>This mode is more or less a backward compatibility mode as from its
introduction.</p><p>On an embedded system it is not uncommon that the system has no power supply,
not even a battery, when it is shut off. The system clock on such a system is
typically way off when the system boots. If
<a href="time_correction.html#no-time-warp-mode">no time warp mode</a> is used, and the
Erlang runtime system is started before OS system time has been corrected,
Erlang system time can be wrong for a long time, centuries or even longer.</p><p>If you need to use Erlang code that is not
<a href="time_correction.html#time-warp-safe-code">time warp safe</a>, and you need to start
the Erlang runtime system before OS system time has been corrected, you may want
to use the single time warp mode.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>There are limitations to when you can execute time warp unsafe code using this
mode. If it is possible to use time warp safe code only, it is <em>much</em> better
to use the <a href="time_correction.html#multi-time-warp-mode">multi-time warp mode</a>
instead.</p></section><p>Using the single time warp mode, the time offset is handled in two phases:</p><ul><li><p><strong>Preliminary Phase</strong> - This phase starts when the runtime system starts. A
preliminary time offset based on current OS system time is determined. This
offset is from now on to be fixed during the whole preliminary phase.</p><p>If time correction is enabled, adjustments to the Erlang monotonic clock are
made to keep its frequency as correct as possible. However, <em>no</em> adjustments
are made trying to align Erlang system time and OS system time. That is,
during the preliminary phase Erlang system time and OS system time can diverge
from each other, and no attempt is made to prevent this.</p><p>If time correction is disabled, changes in OS system time affects the
monotonic clock the same way as when the
<a href="time_correction.html#no-time-warp-mode">no time warp mode</a> is used.</p></li><li><p><strong>Final Phase</strong> - This phase begins when the user finalizes the time offset by
calling
<a href="erlang.html#system_flag_time_offset"><code class="inline">erlang:system_flag(time_offset, finalize)</code></a>.
The finalization can only be performed once.</p><p>During finalization, the time offset is adjusted and fixed so that current
Erlang system time aligns with the current OS system time. As the time offset
can change during the finalization, Erlang system time can do a time warp at
this point. The time offset is from now on fixed until the runtime system
terminates. If time correction has been enabled, the time correction from now
on also makes adjustments to align Erlang system time with OS system time.
When the system is in the final phase, it behaves exactly as in
<a href="time_correction.html#no-time-warp-mode">no time warp mode</a>.</p></li></ul><p>In order for this to work properly, the user must ensure that the following two
requirements are satisfied:</p><ul><li><p><strong>Forward Time Warp</strong> - The time warp made when finalizing the time offset can
only be done forwards without encountering problems. This implies that the
user must ensure that OS system time is set to a time earlier or equal to
actual POSIX time before starting the Erlang runtime system.</p><p>If you are not sure that OS system time is correct, set it to a time that is
guaranteed to be earlier than actual POSIX time before starting the Erlang
runtime system, just to be safe.</p></li><li><p><strong>Finalize Correct OS System Time</strong> - OS system time must be correct when the
user finalizes the time offset.</p></li></ul><p>If these requirements are not fulfilled, the system may behave very bad.</p><p>Assuming that these requirements are fulfilled, time correction is enabled, and
OS system time is adjusted using a time adjustment protocol such as NTP, only
small adjustments of Erlang monotonic time are needed to keep system times
aligned after finalization. As long as the system is not suspended, the largest
adjustments needed are for inserted (or deleted) leap seconds.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>To use this mode, ensure that all Erlang code that will execute in both phases
is <a href="time_correction.html#time-warp-safe-code">time warp safe</a>.</p><p>Code executing only in the final phase does not have to be able to cope with
the time warp.</p></section><h3 id="multi-time-warp-mode" class="section-heading">
  <a href="#multi-time-warp-mode" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Multi-Time Warp Mode</span>
</h3>
<p><em>Multi-time warp mode in combination with time correction is the preferred
configuration</em>. This as the Erlang runtime system have better performance, scale
better, and behave better on almost all platforms. Also, the accuracy and
precision of time measurements are better. Only Erlang runtime systems executing
on ancient platforms benefit from another configuration. As of OTP 26 (ERTS
14.0) this is also the default.</p><p>The time offset can change at any time without limitations. That is, Erlang
system time can perform time warps both forwards and backwards at <em>any</em> time. As
we align Erlang system time with OS system time by changing the time offset, we
can enable a time correction that tries to adjust the frequency of the Erlang
monotonic clock to be as correct as possible. This makes time measurements using
Erlang monotonic time more accurate and precise.</p><p>If time correction is disabled, Erlang monotonic time leaps forward if OS system
time leaps forward. If OS system time leaps backwards, Erlang monotonic time
stops briefly, but it does not freeze for extended periods of time. This as the
time offset is changed to align Erlang system time with OS system time.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>To use this mode, ensure that all Erlang code that will execute on the runtime
system is <a href="time_correction.html#time-warp-safe-code">time warp safe</a>.</p></section><h2 id="new-time-api" class="section-heading">
  <a href="#new-time-api" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">New Time API</span>
</h2>
<p>The old time API is based on <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a>. <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> was intended to be
used for many unrelated things. This tied these unrelated operations together
and caused issues with performance, scalability, accuracy, and precision for
operations that did not need to have such issues. To improve this, the new API
spreads different functionality over multiple functions.</p><p>To be backward compatible, <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> remains &quot;as is&quot;, but <em>you are strongly
discouraged from using it</em>. Many use cases of <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> prevents you from
using the new <a href="time_correction.html#multi-time-warp-mode">multi-time warp mode</a>,
which is an important part of this new time functionality improvement.</p><p>Some of the new BIFs on some systems, perhaps surprisingly, return negative
integer values on a newly started runtime system. This is not a bug, but a
memory use optimization.</p><p>The new API consists of the following new BIFs:</p><ul><li><a href="erlang.html#convert_time_unit/3"><code class="inline">erlang:convert_time_unit/3</code></a></li><li><a href="erlang.html#monotonic_time/0"><code class="inline">erlang:monotonic_time/0</code></a></li><li><a href="erlang.html#monotonic_time/1"><code class="inline">erlang:monotonic_time/1</code></a></li><li><a href="erlang.html#system_time/0"><code class="inline">erlang:system_time/0</code></a></li><li><a href="erlang.html#system_time/1"><code class="inline">erlang:system_time/1</code></a></li><li><a href="erlang.html#time_offset/0"><code class="inline">erlang:time_offset/0</code></a></li><li><a href="erlang.html#time_offset/1"><code class="inline">erlang:time_offset/1</code></a></li><li><a href="erlang.html#timestamp/0"><code class="inline">erlang:timestamp/0</code></a></li><li><a href="erlang.html#unique_integer/0"><code class="inline">erlang:unique_integer/0</code></a></li><li><a href="erlang.html#unique_integer/1"><code class="inline">erlang:unique_integer/1</code></a></li><li><a href="../../apps/kernel/os.html#system_time/0"><code class="inline">os:system_time/0</code></a></li><li><a href="../../apps/kernel/os.html#system_time/1"><code class="inline">os:system_time/1</code></a></li></ul><p>The new API also consists of extensions of the following existing BIFs:</p><ul><li><a href="erlang.html#monitor/2"><code class="inline">erlang:monitor(time_offset, clock_service)</code></a></li><li><a href="erlang.html#system_flag_time_offset"><code class="inline">erlang:system_flag(time_offset, finalize)</code></a></li><li><a href="erlang.html#system_info_os_monotonic_time_source"><code class="inline">erlang:system_info(os_monotonic_time_source)</code></a></li><li><a href="erlang.html#system_info_os_system_time_source"><code class="inline">erlang:system_info(os_system_time_source)</code></a></li><li><a href="erlang.html#system_info_time_offset"><code class="inline">erlang:system_info(time_offset)</code></a></li><li><a href="erlang.html#system_info_time_warp_mode"><code class="inline">erlang:system_info(time_warp_mode)</code></a></li><li><a href="erlang.html#system_info_time_correction"><code class="inline">erlang:system_info(time_correction)</code></a></li><li><a href="erlang.html#system_info_start_time"><code class="inline">erlang:system_info(start_time)</code></a></li><li><a href="erlang.html#system_info_end_time"><code class="inline">erlang:system_info(end_time)</code></a></li></ul><h3 id="new-erlang-monotonic-time" class="section-heading">
  <a href="#new-erlang-monotonic-time" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">New Erlang Monotonic Time</span>
</h3>
<p>Erlang monotonic time as such is new as from ERTS 7.0. It is introduced to
detach time measurements, such as elapsed time from calendar time. In many use
cases there is a need to measure elapsed time or specify a time relative to
another point in time without the need to know the involved times in UTC or any
other globally defined time scale. By introducing a time scale with a local
definition of where it starts, time that do not concern calendar time can be
managed on that time scale. Erlang monotonic time uses such a time scale with a
locally defined start.</p><p>The introduction of Erlang monotonic time allows us to adjust the two Erlang
times (Erlang monotonic time and Erlang system time) separately. By doing this,
the accuracy of elapsed time does not have to suffer just because the system
time happened to be wrong at some point in time. Separate adjustments of the two
times are only performed in the time warp modes, and only fully separated in the
<a href="time_correction.html#multi-time-warp-mode">multi-time warp mode</a>. All other modes
than the multi-time warp mode are for backward compatibility reasons. When using
these modes, the accuracy of Erlang monotonic time suffer, as the adjustments of
Erlang monotonic time in these modes are more or less tied to Erlang system
time.</p><p>The adjustment of system time could have been made smother than using a time
warp approach, but we think that would be a bad choice. As we can express and
measure time that is not connected to calendar time by the use of Erlang
monotonic time, it is better to expose the change in Erlang system time
immediately. This as the Erlang applications executing on the system can react
on the change in system time as soon as possible. This is also more or less
exactly how most operating systems handle this (OS monotonic time and OS system
time). By adjusting system time smoothly, we would just hide the fact that
system time changed and make it harder for the Erlang applications to react to
the change in a sensible way.</p><p>To be able to react to a change in Erlang system time, you must be able to
detect that it happened. The change in Erlang system time occurs when the
current time offset is changed. We have therefore introduced the possibility to
monitor the time offset using
<a href="erlang.html#monitor/2"><code class="inline">erlang:monitor(time_offset, clock_service)</code></a>. A process
monitoring the time offset is sent a message on the following format when the
time offset is changed:</p><pre><code class="text">{'CHANGE', MonitorReference, time_offset, clock_service, NewTimeOffset}</code></pre><h3 id="unique-values" class="section-heading">
  <a href="#unique-values" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Unique Values</span>
</h3>
<p>Besides reporting time, <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> also produces unique and strictly
monotonically increasing values. To detach this functionality from time
measurements, we have introduced
<a href="erlang.html#unique_integer/1"><code class="inline">erlang:unique_integer()</code></a>.</p><p><a href="" id="Dos_and_Donts"></a></p><h3 id="how-to-work-with-the-new-api" class="section-heading">
  <a href="#how-to-work-with-the-new-api" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">How to Work with the New API</span>
</h3>
<p>Previously <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> was the only option for doing many things. This
section deals with some things that <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> can be used for, and how you
use the new API.</p><h4>Retrieve Erlang System Time</h4><section role="note" class="admonition error"><h4 class="admonition-title error">Dont</h4><p>Use <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> to retrieve the current Erlang system time.</p></section><section role="note" class="admonition tip"><h4 class="admonition-title tip">Do</h4><p>Use <a href="erlang.html#system_time/1"><code class="inline">erlang:system_time/1</code></a> to retrieve the current Erlang system time on the
<a href="erlang.html#t:time_unit/0">time unit</a> of your choice.</p><p>If you want the same format as returned by <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a>, use
<a href="erlang.html#timestamp/0"><code class="inline">erlang:timestamp/0</code></a>.</p></section><h4>Measure Elapsed Time</h4><section role="note" class="admonition error"><h4 class="admonition-title error">Dont</h4><p>Take time stamps with <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> and calculate the difference in time with
<a href="../../apps/stdlib/timer.html#now_diff/2"><code class="inline">timer:now_diff/2</code></a>.</p></section><section role="note" class="admonition tip"><h4 class="admonition-title tip">Do</h4><p>Take time stamps with <a href="erlang.html#monotonic_time/0"><code class="inline">erlang:monotonic_time/0</code></a> and calculate the time
difference using ordinary subtraction. The result is in <code class="inline">native</code>
<a href="erlang.html#t:time_unit/0">time unit</a>. If you want to convert the result to
another time unit, you can use <a href="erlang.html#convert_time_unit/3"><code class="inline">erlang:convert_time_unit/3</code></a>.</p><p>An easier way to do this is to use <a href="erlang.html#monotonic_time/1"><code class="inline">erlang:monotonic_time/1</code></a> with the desired
time unit. However, you can then lose accuracy and precision.</p></section><h4>Determine Order of Events</h4><section role="note" class="admonition error"><h4 class="admonition-title error">Dont</h4><p>Determine the order of events by saving a time stamp with <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> when
the event occurs.</p></section><section role="note" class="admonition tip"><h4 class="admonition-title tip">Do</h4><p>Determine the order of events by saving the integer returned by
<a href="erlang.html#unique_integer/1"><code class="inline">erlang:unique_integer([monotonic])</code></a> when the
event occurs. These integers are strictly monotonically ordered on current
runtime system instance corresponding to creation time.</p></section><h4>Determine Order of Events with Time of the Event</h4><section role="note" class="admonition error"><h4 class="admonition-title error">Dont</h4><p>Determine the order of events by saving a time stamp with <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> when
the event occurs.</p></section><section role="note" class="admonition tip"><h4 class="admonition-title tip">Do</h4><p>Determine the order of events by saving a tuple containing
<a href="erlang.html#monotonic_time/0">monotonic time</a> and a
<a href="erlang.html#unique_integer/1">strictly monotonically increasing integer</a> as
follows:</p><pre><code class="makeup erlang" translate="no"><span class="n">Time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">erlang</span><span class="p">:</span><span class="nf">monotonic_time</span><span class="p" data-group-id="2808178652-1">(</span><span class="p" data-group-id="2808178652-1">)</span><span class="p">,</span><span class="w">
</span><span class="n">UMI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">erlang</span><span class="p">:</span><span class="nf">unique_integer</span><span class="p" data-group-id="2808178652-2">(</span><span class="p" data-group-id="2808178652-3">[</span><span class="ss">monotonic</span><span class="p" data-group-id="2808178652-3">]</span><span class="p" data-group-id="2808178652-2">)</span><span class="p">,</span><span class="w">
</span><span class="n">EventTag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="2808178652-4">{</span><span class="n">Time</span><span class="p">,</span><span class="w"> </span><span class="n">UMI</span><span class="p" data-group-id="2808178652-4">}</span></code></pre><p>These tuples are strictly monotonically ordered on the current runtime system
instance according to creation time. It is important that the monotonic time
is in the first element (the most significant element when comparing
two-tuples). Using the monotonic time in the tuples, you can calculate time
between events.</p><p>If you are interested in Erlang system time at the time when the event
occurred, you can also save the time offset before or after saving the events
using <a href="erlang.html#time_offset/0"><code class="inline">erlang:time_offset/0</code></a>. Erlang monotonic time added with the time offset
corresponds to Erlang system time.</p><p>If you are executing in a mode where time offset can change, and you want to
get the actual Erlang system time when the event occurred, you can save the
time offset as a third element in the tuple (the least significant element
when comparing three-tuples).</p></section><h4>Create a Unique Name</h4><section role="note" class="admonition error"><h4 class="admonition-title error">Dont</h4><p>Use the values returned from <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> to create a name unique on the
current runtime system instance.</p></section><section role="note" class="admonition tip"><h4 class="admonition-title tip">Do</h4><p>Use the value returned from <a href="erlang.html#unique_integer/0"><code class="inline">erlang:unique_integer/0</code></a> to create a name unique
on the current runtime system instance. If you only want positive integers,
you can use <a href="erlang.html#unique_integer/1"><code class="inline">erlang:unique_integer([positive])</code></a>.</p></section><h4>Seed Random Number Generation with a Unique Value</h4><section role="note" class="admonition error"><h4 class="admonition-title error">Dont</h4><p>Seed random number generation using <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a>.</p></section><section role="note" class="admonition tip"><h4 class="admonition-title tip">Do</h4><p>Seed random number generation using a combination of
<a href="erlang.html#monotonic_time/0"><code class="inline">erlang:monotonic_time/0</code></a>,
<a href="erlang.html#time_offset/0"><code class="inline">erlang:time_offset/0</code></a>,
<a href="erlang.html#unique_integer/0"><code class="inline">erlang:unique_integer/0</code></a>, and other
functionality.</p></section><p>To sum up this section: <em>Do not use <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a>.</em></p><h2 id="support-of-both-new-and-old-otp-releases" class="section-heading">
  <a href="#support-of-both-new-and-old-otp-releases" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Support of Both New and Old OTP Releases</span>
</h2>
<p>It can be required that your code must run on a variety of OTP installations of
different OTP releases. If so, you cannot use the new API out of the box, as it
will not be available on releases before OTP 18. The solution is <em>not</em> to avoid
using the new API, as your code would then not benefit from the scalability and
accuracy improvements made. Instead, use the new API when available, and fall
back on <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> when the new API is unavailable.</p><p>Fortunately most of the new API can easily be implemented using existing
primitives, except for:</p><ul><li><a href="erlang.html#system_info_start_time"><code class="inline">erlang:system_info(start_time)</code></a></li><li><a href="erlang.html#system_info_end_time"><code class="inline">erlang:system_info(end_time)</code></a></li><li><a href="erlang.html#system_info_os_monotonic_time_source"><code class="inline">erlang:system_info(os_monotonic_time_source)</code></a></li><li><a href="erlang.html#system_info_os_system_time_source"><code class="inline">erlang:system_info(os_system_time_source)</code></a></li></ul><p>By wrapping the API with functions that fall back on <a href="erlang.html#now/0"><code class="inline">erlang:now/0</code></a> when the new
API is unavailable, and using these wrappers instead of using the API directly,
the problem is solved. These wrappers can, for example, be implemented as in
<a href="assets/time_compat.erl">$ERL_TOP/erts/example/time_compat.erl</a>.</p>
</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="communication.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Communication in Erlang
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="match_spec.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Match Specifications in Erlang
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.37.3) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright © 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
