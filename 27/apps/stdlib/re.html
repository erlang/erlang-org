<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.37.3">
    <meta name="project" content="stdlib v6.2.2.1">


<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=27&q=">
<meta name="major-vsn" content="27">
<link rel="canonical" href="https://www.erlang.org/docs/27/apps/stdlib/re.html" />
    <title>re â€” stdlib v6.2.2.1</title>

    <link rel="stylesheet" href="dist/html-erlang-FDBURIED.css" />

    <script defer src="dist/sidebar_items-699D0F77.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-ALU6OERS.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="stdlib" />
        </a>

      <div>
        <a href="../../index.html" class="sidebar-projectName" translate="no">
stdlib
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v6.2.2.1
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-module" id="main" data-type="modules">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of stdlib</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>
      <span translate="no">re</span> 
      <small class="app-vsn" translate="no">(stdlib v6.2.2.1)</small>

    </h1>

      <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L20" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


    <section id="moduledoc">
<p>This module contains regular expression matching functions for strings and
binaries.</p><p>The <a href="re.html#module-perl-like-regular-expression-syntax">regular expression</a> syntax and
semantics resemble that of Perl.</p><p>The matching algorithms of the library are based on the PCRE library, but not
all of the PCRE library is interfaced and some parts of the library go beyond
what PCRE offers. Currently PCRE version 8.40 (release date 2017-01-11) is used.
The sections of the PCRE documentation that are relevant to this module are
included here.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The Erlang literal syntax for strings uses the <code class="inline">\\</code> (backslash) character as
an escape code. You need to escape backslashes in literal strings, both in
your code and in the shell, with an extra backslash, that is, <code class="inline">&quot;\\\\&quot;</code> or
<code class="inline">&lt;&lt;&quot;\\\\&quot;&gt;&gt;</code>.</p><p>Since Erlang/OTP 27 you can use <a href="../../system/data_types.html#sigil">verbatim sigils</a>
to write literal strings. The example above would be written as <code class="inline">~S&quot;\&quot;</code> or <code class="inline">~B&quot;\&quot;</code>.</p></section><h2 id="module-perl-like-regular-expression-syntax" class="section-heading">
  <a href="#module-perl-like-regular-expression-syntax" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Perl-Like Regular Expression Syntax</span>
</h2>
<p>The following sections contain reference material for the regular expressions
used by this module. The information is based on the PCRE documentation, with
changes where this module behaves differently to the PCRE library.</p><h2 id="module-pcre-regular-expression-details" class="section-heading">
  <a href="#module-pcre-regular-expression-details" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">PCRE Regular Expression Details</span>
</h2>
<p>The syntax and semantics of the regular expressions supported by PCRE are
described in detail in the following sections. Perl's regular expressions are
described in its own documentation, and regular expressions in general are
covered in many books, some with copious examples. Jeffrey Friedl's &quot;Mastering
Regular Expressions&quot;, published by O'Reilly, covers regular expressions in great
detail. This description of the PCRE regular expressions is intended as
reference material.</p><p>The reference material is divided into the following sections:</p><ul><li><a href="re.html#sect1">Special Start-of-Pattern Items</a></li><li><a href="re.html#sect2">Characters and Metacharacters</a></li><li><a href="re.html#sect3">Backslash</a></li><li><a href="re.html#sect4">Circumflex and Dollar</a></li><li><a href="re.html#sect5">Full Stop (Period, Dot) and \N</a></li><li><a href="re.html#sect6">Matching a Single Data Unit</a></li><li><a href="re.html#sect7">Square Brackets and Character Classes</a></li><li><a href="re.html#sect8">Posix Character Classes</a></li><li><a href="re.html#sect9">Vertical Bar</a></li><li><a href="re.html#sect10">Internal Option Setting</a></li><li><a href="re.html#sect11">Subpatterns</a></li><li><a href="re.html#sect12">Duplicate Subpattern Numbers</a></li><li><a href="re.html#sect13">Named Subpatterns</a></li><li><a href="re.html#sect14">Repetition</a></li><li><a href="re.html#sect15">Atomic Grouping and Possessive Quantifiers</a></li><li><a href="re.html#sect16">Back References</a></li><li><a href="re.html#sect17">Assertions</a></li><li><a href="re.html#sect18">Conditional Subpatterns</a></li><li><a href="re.html#sect19">Comments</a></li><li><a href="re.html#sect20">Recursive Patterns</a></li><li><a href="re.html#sect21">Subpatterns as Subroutines</a></li><li><a href="re.html#sect22">Oniguruma Subroutine Syntax</a></li><li><a href="re.html#sect23">Backtracking Control</a></li></ul><p><a href="" id="sect1"></a></p><h2 id="module-special-start-of-pattern-items" class="section-heading">
  <a href="#module-special-start-of-pattern-items" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Special Start-of-Pattern Items</span>
</h2>
<p>Some options that can be passed to <a href="#compile/2"><code class="inline">compile/2</code></a> can also be set by special items
at the start of a pattern. These are not Perl-compatible, but are provided to
make these options accessible to pattern writers who are not able to change the
program that processes the pattern. Any number of these items can appear, but
they must all be together right at the start of the pattern string, and the
letters must be in upper case.</p><p><em>UTF Support</em></p><p>Unicode support is basically UTF-8 based. To use Unicode characters, you either
call <a href="#compile/2"><code class="inline">compile/2</code></a> or <a href="#run/3"><code class="inline">run/3</code></a> with option <code class="inline">unicode</code>, or the pattern must start
with one of these special sequences:</p><pre><code class="text">(*UTF8)
(*UTF)</code></pre><p>Both options give the same effect, the input string is interpreted as UTF-8.
Notice that with these instructions, the automatic conversion of lists to UTF-8
is not performed by the <code class="inline">re</code> functions. Therefore, using these sequences is not
recommended. Add option <code class="inline">unicode</code> when running <a href="#compile/2"><code class="inline">compile/2</code></a> instead.</p><p>Some applications that allow their users to supply patterns can wish to restrict
them to non-UTF data for security reasons. If option <code class="inline">never_utf</code> is set at
compile time, (*UTF), and so on, are not allowed, and their appearance causes
an error.</p><p><em>Unicode Property Support</em></p><p>The following is another special sequence that can appear at the start of a
pattern:</p><pre><code class="text">(*UCP)</code></pre><p>This has the same effect as setting option <code class="inline">ucp</code>: it causes sequences such as
<code class="inline">\d</code> and <code class="inline">\w</code> to use Unicode properties to determine character types, instead of
recognizing only characters with codes &lt; 256 through a lookup table.</p><p><em>Disabling Startup Optimizations</em></p><p>If a pattern starts with <code class="inline">(*NO_START_OPT)</code>, it has the same effect as setting
option <code class="inline">no_start_optimize</code> at compile time.</p><p><em>Newline Conventions</em></p><p><a href="" id="newline_conventions"></a></p><p>PCRE supports five conventions for indicating line breaks in strings: a single
CR (carriage return) character, a single LF (line feed) character, the
two-character sequence CRLF, any of the three preceding, and any Unicode newline
sequence.</p><p>A newline convention can also be specified by starting a pattern string with one
of the following five sequences:</p><ul><li><p><strong>(*CR)</strong> - Carriage return</p></li><li><p><strong>(*LF)</strong> - Line feed</p></li><li><p><strong>(*CRLF)</strong> - &gt;Carriage return followed by line feed</p></li><li><p><strong>(*ANYCRLF)</strong> - Any of the three above</p></li><li><p><strong>(*ANY)</strong> - All Unicode newline sequences</p></li></ul><p>These override the default and the options specified to <a href="#compile/2"><code class="inline">compile/2</code></a>. For
example, the following pattern changes the convention to CR:</p><pre><code class="text">(*CR)a.b</code></pre><p>This pattern matches <code class="inline">a\nb</code>, as LF is no longer a newline. If more than one of
them is present, the last one is used.</p><p>The newline convention affects where the circumflex and dollar assertions are
true. It also affects the interpretation of the dot metacharacter when <code class="inline">dotall</code>
is not set, and the behavior of <code class="inline">\N</code>. However, it does not affect what the <code class="inline">\R</code>
escape sequence matches. By default, this is any Unicode newline sequence, for
Perl compatibility. However, this can be changed; see the description of <code class="inline">\R</code> in
section <a href="re.html#newline_sequences">Newline Sequences</a>. A change of the <code class="inline">\R</code>
setting can be combined with a change of the newline convention.</p><p><em>Setting Match and Recursion Limits</em></p><p>The caller of <a href="#run/3"><code class="inline">run/3</code></a> can set a limit on the number of times the internal
match() function is called and on the maximum depth of recursive calls. These
facilities are provided to catch runaway matches that are provoked by patterns
with huge matching trees (a typical example is a pattern with nested unlimited
repeats) and to avoid running out of system stack by too much recursion. When
one of these limits is reached, <code class="inline">pcre_exec()</code> gives an error return. The limits
can also be set by items at the start of the pattern of the following forms:</p><pre><code class="text">(*LIMIT_MATCH=d)
(*LIMIT_RECURSION=d)</code></pre><p>Here d is any number of decimal digits. However, the value of the setting must
be less than the value set by the caller of <a href="#run/3"><code class="inline">run/3</code></a> for it to have
any effect. That is, the pattern writer can lower the limit set by the
programmer, but not raise it. If there is more than one setting of one of these
limits, the lower value is used.</p><p>The default value for both the limits is 10,000,000 in the Erlang VM. Notice
that the recursion limit does not affect the stack depth of the VM, as PCRE for
Erlang is compiled in such a way that the match function never does recursion on
the C stack.</p><p>Note that <code class="inline">LIMIT_MATCH</code> and <code class="inline">LIMIT_RECURSION</code> can only reduce the value of the
limits set by the caller, not increase them.</p><p><a href="" id="sect2"></a></p><h2 id="module-characters-and-metacharacters" class="section-heading">
  <a href="#module-characters-and-metacharacters" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Characters and Metacharacters</span>
</h2>
<p>A regular expression is a pattern that is matched against a subject string from
left to right. Most characters stand for themselves in a pattern and match the
corresponding characters in the subject. As a trivial example, the following
pattern matches a portion of a subject string that is identical to itself:</p><pre><code class="text">The quick brown fox</code></pre><p>When caseless matching is specified (option <code class="inline">caseless</code>), letters are matched
independently of case.</p><p>The power of regular expressions comes from the ability to include alternatives
and repetitions in the pattern. These are encoded in the pattern by the use of
<em>metacharacters</em>, which do not stand for themselves but instead are interpreted
in some special way.</p><p>Two sets of metacharacters exist: those that are recognized anywhere in the
pattern except within square brackets, and those that are recognized within
square brackets. Outside square brackets, the metacharacters are as follows:</p><ul><li><p><strong><code class="inline">\</code></strong> - General escape character with many uses</p></li><li><p><strong><code class="inline">^</code></strong> - Assert start of string (or line, in multiline mode)</p></li><li><p><strong><code class="inline">$</code></strong> - Assert end of string (or line, in multiline mode)</p></li><li><p><strong><code class="inline">.</code></strong> - Match any character except newline (by default)</p></li><li><p><strong><code class="inline">[</code></strong> - Start character class definition</p></li><li><p><strong><code class="inline">|</code></strong> - Start of alternative branch</p></li><li><p><strong><code class="inline">(</code></strong> - Start subpattern</p></li><li><p><strong><code class="inline">)</code></strong> - End subpattern</p></li><li><p><strong><code class="inline">?</code></strong> - Extends the meaning of (, also 0 or 1 quantifier, also quantifier
minimizer</p></li><li><p><strong><code class="inline">*</code></strong> - 0 or more quantifiers</p></li><li><p><strong><code class="inline">+</code></strong> - 1 or more quantifier, also &quot;possessive quantifier&quot;</p></li><li><p><strong><code class="inline">{</code></strong> - Start min/max quantifier</p></li></ul><p>Part of a pattern within square brackets is called a &quot;character class&quot;. The
following are the only metacharacters in a character class:</p><ul><li><p><strong><code class="inline">\</code></strong> - General escape character</p></li><li><p><strong><code class="inline">^</code></strong> - Negate the class, but only if the first character</p></li><li><p><strong><code class="inline">-</code></strong> - Indicates character range</p></li><li><p><strong><code class="inline">[</code></strong> - Posix character class (only if followed by Posix syntax)</p></li><li><p><strong><code class="inline">]</code></strong> - Terminates the character class</p></li></ul><p>The following sections describe the use of each metacharacter.</p><p><a href="" id="sect3"></a></p><h2 id="module-backslash" class="section-heading">
  <a href="#module-backslash" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Backslash</span>
</h2>
<p>The backslash character has many uses. First, if it is followed by a character
that is not a number or a letter, it takes away any special meaning that a
character can have. This use of backslash as an escape character applies both
inside and outside character classes.</p><p>For example, if you want to match a &quot;_&quot; character, you write <code class="inline">\_</code> in the pattern.
This escaping action applies if the following character would otherwise be
interpreted as a metacharacter, so it is always safe to precede a
non-alphanumeric with backslash to specify that it stands for itself. In
particular, if you want to match a backslash, write <code class="inline">\\</code>.</p><p>In <code class="inline">unicode</code> mode, only ASCII numbers and letters have any special meaning after
a backslash. All other characters (in particular, those whose code points
are &gt; 127) are treated as literals.</p><p>If a pattern is compiled with option <code class="inline">extended</code>, whitespace in the pattern
(other than in a character class) and characters between a # outside a character
class and the next newline are ignored. An escaping backslash can be used to
include a whitespace or # character as part of the pattern.</p><p>To remove the special meaning from a sequence of characters, put them between
<code class="inline">\Q</code> and <code class="inline">\E</code>. This is different from Perl in that <code class="inline">$</code> and <code class="inline">@</code> are handled as literals
in <code class="inline">\Q</code>...<code class="inline">\E</code> sequences in PCRE, while <code class="inline">$</code> and <code class="inline">@</code> cause variable interpolation in
Perl. Notice the following examples:</p><pre><code class="text">Pattern            PCRE matches   Perl matches

\Qabc$xyz\E        abc$xyz        abc followed by the contents of $xyz
\Qabc\$xyz\E       abc\$xyz       abc\$xyz
\Qabc\E\$\Qxyz\E   abc$xyz        abc$xyz</code></pre><p>The <code class="inline">\Q</code>...<code class="inline">\E</code> sequence is recognized both inside and outside character classes.
An isolated <code class="inline">\E</code> that is not preceded by <code class="inline">\Q</code> is ignored. If <code class="inline">\Q</code> is not followed
by <code class="inline">\E</code> later in the pattern, the literal interpretation continues to the end of
the pattern (that is, <code class="inline">\E</code> is assumed at the end). If the isolated <code class="inline">\Q</code> is inside
a character class, this causes an error, as the character class is not
terminated.</p><p><em>Non-Printing Characters</em></p><p><a href="" id="non_printing_characters"></a></p><p>A second use of backslash provides a way of encoding non-printing characters in
patterns in a visible manner. There is no restriction on the appearance of
non-printing characters, apart from the binary zero that terminates a pattern.
When a pattern is prepared by text editing, it is often easier to use one of the
following escape sequences than the binary character it represents:</p><ul><li><p><strong><code class="inline">\a</code></strong> - Alarm, that is, the BEL character (hex 07)</p></li><li><p><strong><code class="inline">\cx</code></strong> - &quot;Control-x&quot;, where x is any ASCII character</p></li><li><p><strong><code class="inline">\e</code></strong> - Escape (hex 1B)</p></li><li><p><strong><code class="inline">\f</code></strong> - Form feed (hex 0C)</p></li><li><p><strong><code class="inline">\n</code></strong> - Line feed (hex 0A)</p></li><li><p><strong><code class="inline">\r</code></strong> - Carriage return (hex 0D)</p></li><li><p><strong><code class="inline">\t</code></strong> - Tab (hex 09)</p></li><li><p><strong><code class="inline">\0dd</code></strong> - Character with octal code 0dd</p></li><li><p><strong><code class="inline">\ddd</code></strong> - Character with octal code ddd, or back reference</p></li><li><p><strong><code class="inline">\o{ddd..}</code></strong> - character with octal code ddd..</p></li><li><p><strong><code class="inline">\xhh</code></strong> - Character with hex code hh</p></li><li><p><strong><code class="inline">\x{hhh..}</code></strong> - Character with hex code hhh..</p></li></ul><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Note that <code class="inline">\0dd</code> is always an octal code, and that <code class="inline">\8</code> and <code class="inline">\9</code> are the literal
characters &quot;8&quot; and &quot;9&quot;.</p></section><p>The precise effect of <code class="inline">\cx</code> on ASCII characters is as follows: if x is a
lowercase letter, it is converted to upper case. Then bit 6 of the character
(hex 40) is inverted. Thus <code class="inline">\cA</code> to <code class="inline">\cZ</code> become hex 01 to hex 1A (A is 41, Z is
5A), but <code class="inline">\c{</code> becomes hex 3B (<code class="inline">{</code> is 7B), and <code class="inline">\c</code>; becomes hex 7B (; is 3B). If
the data item (byte or 16-bit value) following <code class="inline">\c</code> has a value &gt; 127, a
compile-time error occurs. This locks out non-ASCII characters in all modes.</p><p>The <code class="inline">\c</code> facility was designed for use with ASCII characters, but with the
extension to Unicode it is even less useful than it once was.</p><p>After <code class="inline">\0</code> up to two further octal digits are read. If there are fewer than two
digits, just those that are present are used. Thus the sequence <code class="inline">\0\x\015</code>
specifies two binary zeros followed by a CR character (code value 13). Make sure
you supply two digits after the initial zero if the pattern character that
follows is itself an octal digit.</p><p>The escape <code class="inline">\o</code> must be followed by a sequence of octal digits, enclosed in
braces. An error occurs if this is not the case. This escape is a recent
addition to Perl; it provides way of specifying character code points as octal
numbers greater than 0777, and it also allows octal numbers and back references
to be unambiguously specified.</p><p>For greater clarity and unambiguity, it is best to avoid following <code class="inline">\</code> by a digit
greater than zero. Instead, use <code class="inline">\o{}</code> or <code class="inline">\x{}</code> to specify character numbers,
and <code class="inline">\g{}</code> to specify back references. The following paragraphs describe the
old, ambiguous syntax.</p><p>The handling of a backslash followed by a digit other than 0 is complicated, and
Perl has changed in recent releases, causing PCRE also to change. Outside a
character class, PCRE reads the digit and any following digits as a decimal
number. If the number is &lt; 8, or if there have been at least that many previous
capturing left parentheses in the expression, the entire sequence is taken as a
<em>back reference</em>. A description of how this works is provided later, following
the discussion of parenthesized subpatterns.</p><p>Inside a character class, or if the decimal number following <code class="inline">\</code> is &gt; 7 and there
have not been that many capturing subpatterns, PCRE handles <code class="inline">\8</code> and <code class="inline">\9</code> as the
literal characters &quot;8&quot; and &quot;9&quot;, and otherwise re-reads up to three octal digits
following the backslash, and using them to generate a data character. Any
subsequent digits stand for themselves. For example:</p><ul><li><p><strong><code class="inline">\040</code></strong> - Another way of writing an ASCII space</p></li><li><p><strong><code class="inline">\40</code></strong> - The same, provided there are &lt; 40 previous capturing subpatterns</p></li><li><p><strong><code class="inline">\7</code></strong> - Always a back reference</p></li><li><p><strong><code class="inline">\11</code></strong> - Can be a back reference, or another way of writing a tab</p></li><li><p><strong><code class="inline">\011</code></strong> - Always a tab</p></li><li><p><strong><code class="inline">\0113</code></strong> - A tab followed by character &quot;3&quot;</p></li><li><p><strong><code class="inline">\113</code></strong> - Can be a back reference, otherwise the character with octal code
113</p></li><li><p><strong><code class="inline">\377</code></strong> - Can be a back reference, otherwise value 255 (decimal)</p></li><li><p><strong><code class="inline">\81</code></strong> - Either a back reference, or the two characters &quot;8&quot; and &quot;1&quot;</p></li></ul><p>Notice that octal values &gt;= 100 that are specified using this syntax must not be
introduced by a leading zero, as no more than three octal digits are ever read.</p><p>By default, after <code class="inline">\x</code> that is not followed by <code class="inline">{</code>, from zero to two hexadecimal
digits are read (letters can be in upper or lower case). Any number of
hexadecimal digits may appear between <code class="inline">\x{</code> and <code class="inline">}</code>. If a character other than a
hexadecimal digit appears between <code class="inline">\x{</code> and <code class="inline">}</code>, or if there is no terminating
<code class="inline">}</code>, an error occurs.</p><p>Characters whose value is less than 256 can be defined by either of the two
syntaxes for <code class="inline">\x</code>. There is no difference in the way they are handled. For
example, <code class="inline">\xdc</code> is exactly the same as <code class="inline">\x{dc}</code>.</p><p><em>Constraints on character values</em></p><p>Characters that are specified using octal or hexadecimal numbers are limited to
certain values, as follows:</p><ul><li><p><strong>8-bit non-UTF mode</strong> - &lt; 0x100</p></li><li><p><strong>8-bit UTF-8 mode</strong> - &lt; 0x10ffff and a valid codepoint</p></li></ul><p>Invalid Unicode codepoints are the range 0xd800 to 0xdfff (the so-called
&quot;surrogate&quot; codepoints), and 0xffef.</p><p><em>Escape sequences in character classes</em></p><p>All the sequences that define a single character value can be used both inside
and outside character classes. Also, inside a character class, <code class="inline">\b</code> is
interpreted as the backspace character (hex 08).</p><p><code class="inline">\N</code> is not allowed in a character class. <code class="inline">\B</code>, <code class="inline">\R</code>, and <code class="inline">\X</code> are not special
inside a character class. Like other unrecognized escape sequences, they are
treated as the literal characters &quot;B&quot;, &quot;R&quot;, and &quot;X&quot;. Outside a character class,
these sequences have different meanings.</p><p><em>Unsupported Escape Sequences</em></p><p>In Perl, the sequences <code class="inline">\l</code>, <code class="inline">\L</code>, <code class="inline">\u</code>, and <code class="inline">\U</code> are recognized by its string
handler and used to modify the case of following characters. PCRE does not
support these escape sequences.</p><p><em>Absolute and Relative Back References</em></p><p>The sequence <code class="inline">\g</code> followed by an unsigned or a negative number, optionally
enclosed in braces, is an absolute or relative back reference. A named back
reference can be coded as <code class="inline">\g{name}</code>. Back references are discussed later,
following the discussion of parenthesized subpatterns.</p><p><em>Absolute and Relative Subroutine Calls</em></p><p>For compatibility with Oniguruma, the non-Perl syntax <code class="inline">\g</code> followed by a name or
a number enclosed either in angle brackets or single quotes, is alternative
syntax for referencing a subpattern as a &quot;subroutine&quot;. Details are discussed
later. Notice that <code class="inline">\g{...}</code> (Perl syntax) and <code class="inline">\g&lt;...&gt;</code> (Oniguruma syntax) are
<em>not</em> synonymous. The former is a back reference and the latter is a subroutine
call.</p><p><em>Generic Character Types</em></p><p><a href="" id="generic_character_types"></a></p><p>Another use of backslash is for specifying generic character types:</p><ul><li><p><strong><code class="inline">\d</code></strong> - Any decimal digit</p></li><li><p><strong><code class="inline">\D</code></strong> - Any character that is not a decimal digit</p></li><li><p><strong><code class="inline">\h</code></strong> - Any horizontal whitespace character</p></li><li><p><strong><code class="inline">\H</code></strong> - Any character that is not a horizontal whitespace character</p></li><li><p><strong><code class="inline">\s</code></strong> - Any whitespace character</p></li><li><p><strong><code class="inline">\S</code></strong> - Any character that is not a whitespace character</p></li><li><p><strong><code class="inline">\v</code></strong> - Any vertical whitespace character</p></li><li><p><strong><code class="inline">\V</code></strong> - Any character that is not a vertical whitespace character</p></li><li><p><strong><code class="inline">\w</code></strong> - Any &quot;word&quot; character</p></li><li><p><strong><code class="inline">\W</code></strong> - Any &quot;non-word&quot; character</p></li></ul><p>There is also the single sequence <code class="inline">\N</code>, which matches a non-newline character.
This is the same as the &quot;.&quot; metacharacter when <code class="inline">dotall</code> is not set. Perl also
uses <code class="inline">\N</code> to match characters by name, but PCRE does not support this.</p><p>Each pair of lowercase and uppercase escape sequences partitions the complete
set of characters into two disjoint sets. Any given character matches one, and
only one, of each pair. The sequences can appear both inside and outside
character classes. They each match one character of the appropriate type. If the
current matching point is at the end of the subject string, all fail, as there
is no character to match.</p><p>For compatibility with Perl, <code class="inline">\s</code> did not used to match the VT character (code
11), which made it different from the the POSIX &quot;space&quot; class. However, Perl
added VT at release 5.18, and PCRE followed suit at release 8.34. The default
<code class="inline">\s</code> characters are now HT (9), LF (10), VT (11), FF (12), CR (13), and space
(32), which are defined as white space in the &quot;C&quot; locale. This list may vary if
locale-specific matching is taking place. For example, in some locales the
&quot;non-breaking space&quot; character (<code class="inline">\xA0</code>) is recognized as white space, and in
others the VT character is not.</p><p>A &quot;word&quot; character is an underscore or any character that is a letter or a
digit. By default, the definition of letters and digits is controlled by the
PCRE low-valued character tables, in Erlang's case (and without option
<code class="inline">unicode</code>), the ISO Latin-1 character set.</p><p>By default, in <code class="inline">unicode</code> mode, characters with values &gt; 255, that is, all
characters outside the ISO Latin-1 character set, never match <code class="inline">\d</code>, <code class="inline">\s</code>, or <code class="inline">\w</code>,
and always match <code class="inline">\D</code>, <code class="inline">\S</code>, and <code class="inline">\W</code>. These sequences retain their original
meanings from before UTF support was available, mainly for efficiency reasons.
However, if option <code class="inline">ucp</code> is set, the behavior is changed so that Unicode
properties are used to determine character types, as follows:</p><ul><li><p><strong><code class="inline">\d</code></strong> - Any character that <code class="inline">\p{Nd}</code> matches (decimal digit)</p></li><li><p><strong><code class="inline">\s</code></strong> - Any character that <code class="inline">\p{Z}</code> or <code class="inline">\h</code> or <code class="inline">\v</code></p></li><li><p><strong><code class="inline">\w</code></strong> - Any character that matches <code class="inline">\p{L}</code> or <code class="inline">\p{N}</code> matches, plus
underscore</p></li></ul><p>The uppercase escapes match the inverse sets of characters. Notice that <code class="inline">\d</code>
matches only decimal digits, while <code class="inline">\w</code> matches any Unicode digit, any Unicode
letter, and underscore. Notice also that <code class="inline">ucp</code> affects <code class="inline">\b</code> and <code class="inline">\B</code>, as they are
defined in terms of <code class="inline">\w</code> and <code class="inline">\W</code>. Matching these sequences is noticeably slower
when <code class="inline">ucp</code> is set.</p><p>The sequences <code class="inline">\h</code>, <code class="inline">\H</code>, <code class="inline">\v</code>, and <code class="inline">\V</code> are features that were added to Perl in
release 5.10. In contrast to the other sequences, which match only ASCII
characters by default, these always match certain high-valued code points,
regardless if <code class="inline">ucp</code> is set.</p><p>The following are the horizontal space characters:</p><ul><li><p><strong>U+0009</strong> - Horizontal tab (HT)</p></li><li><p><strong>U+0020</strong> - Space</p></li><li><p><strong>U+00A0</strong> - Non-break space</p></li><li><p><strong>U+1680</strong> - Ogham space mark</p></li><li><p><strong>U+180E</strong> - Mongolian vowel separator</p></li><li><p><strong>U+2000</strong> - En quad</p></li><li><p><strong>U+2001</strong> - Em quad</p></li><li><p><strong>U+2002</strong> - En space</p></li><li><p><strong>U+2003</strong> - Em space</p></li><li><p><strong>U+2004</strong> - Three-per-em space</p></li><li><p><strong>U+2005</strong> - Four-per-em space</p></li><li><p><strong>U+2006</strong> - Six-per-em space</p></li><li><p><strong>U+2007</strong> - Figure space</p></li><li><p><strong>U+2008</strong> - Punctuation space</p></li><li><p><strong>U+2009</strong> - Thin space</p></li><li><p><strong>U+200A</strong> - Hair space</p></li><li><p><strong>U+202F</strong> - Narrow no-break space</p></li><li><p><strong>U+205F</strong> - Medium mathematical space</p></li><li><p><strong>U+3000</strong> - Ideographic space</p></li></ul><p>The following are the vertical space characters:</p><ul><li><p><strong>U+000A</strong> - Line feed (LF)</p></li><li><p><strong>U+000B</strong> - Vertical tab (VT)</p></li><li><p><strong>U+000C</strong> - Form feed (FF)</p></li><li><p><strong>U+000D</strong> - Carriage return (CR)</p></li><li><p><strong>U+0085</strong> - Next line (NEL)</p></li><li><p><strong>U+2028</strong> - Line separator</p></li><li><p><strong>U+2029</strong> - Paragraph separator</p></li></ul><p>In 8-bit, non-UTF-8 mode, only the characters with code points &lt; 256 are
relevant.</p><p><em>Newline Sequences</em></p><p><a href="" id="newline_sequences"></a></p><p>Outside a character class, by default, the escape sequence <code class="inline">\R</code> matches any
Unicode newline sequence. In non-UTF-8 mode, <code class="inline">\R</code> is equivalent to the following:</p><pre><code class="text">(?&gt;\r\n|\n|\x0b|\f|\r|\x85)</code></pre><p>This is an example of an &quot;atomic group&quot;, details are provided below.</p><p>This particular group matches either the two-character sequence CR followed by
LF, or one of the single characters LF (line feed, U+000A), VT (vertical tab,
U+000B), FF (form feed, U+000C), CR (carriage return, U+000D), or NEL (next
line, U+0085). The two-character sequence is treated as a single unit that
cannot be split.</p><p>In Unicode mode, two more characters whose code points are &gt; 255 are added: LS
(line separator, U+2028) and PS (paragraph separator, U+2029). Unicode character
property support is not needed for these characters to be recognized.</p><p><code class="inline">\R</code> can be restricted to match only CR, LF, or CRLF (instead of the complete set
of Unicode line endings) by setting option <code class="inline">bsr_anycrlf</code> either at compile time
or when the pattern is matched. (BSR is an acronym for &quot;backslash R&quot;.) This can
be made the default when PCRE is built; if so, the other behavior can be
requested through option <code class="inline">bsr_unicode</code>. These settings can also be specified by
starting a pattern string with one of the following sequences:</p><ul><li><p><strong>(*BSR_ANYCRLF)</strong> - CR, LF, or CRLF only</p></li><li><p><strong>(*BSR_UNICODE)</strong> - Any Unicode newline sequence</p></li></ul><p>These override the default and the options specified to the compiling function,
but they can themselves be overridden by options specified to a matching
function. Notice that these special settings, which are not Perl-compatible, are
recognized only at the very start of a pattern, and that they must be in upper
case. If more than one of them is present, the last one is used. They can be
combined with a change of newline convention; for example, a pattern can start
with:</p><pre><code class="text">(*ANY)(*BSR_ANYCRLF)</code></pre><p>They can also be combined with the (<em>UTF8), (</em>UTF), or (*UCP) special
sequences. Inside a character class, <code class="inline">\R</code> is treated as an unrecognized escape
sequence, and so matches the letter &quot;R&quot; by default.</p><p><em>Unicode Character Properties</em></p><p>Three more escape sequences that match characters with specific properties are
available. When in 8-bit non-UTF-8 mode, these sequences are limited to testing
characters whose code points are &lt; 256, but they do work in this mode. The
following are the extra escape sequences:</p><ul><li><p><strong><code class="inline">\p{_xx_}</code></strong> - A character with property <em>xx</em></p></li><li><p><strong><code class="inline">\P{_xx_}</code></strong> - A character without property <em>xx</em></p></li><li><p><strong><code class="inline">\X</code></strong> - A Unicode extended grapheme cluster</p></li></ul><p>The property names represented by <em>xx</em> above are limited to the Unicode script
names, the general category properties, &quot;Any&quot;, which matches any character
(including newline), and some special PCRE properties (described in the next
section). Other Perl properties, such as &quot;InMusicalSymbols&quot;, are currently not
supported by PCRE. Notice that <code class="inline">\P{Any}</code> does not match any characters and
always causes a match failure.</p><p>Sets of Unicode characters are defined as belonging to certain scripts. A
character from one of these sets can be matched using a script name, for
example:</p><pre><code class="text">\p{Greek} \P{Han}</code></pre><p>Those that are not part of an identified script are lumped together as &quot;Common&quot;.
The following is the current list of scripts:</p><ul><li>Arabic</li><li>Armenian</li><li>Avestan</li><li>Balinese</li><li>Bamum</li><li>Bassa_Vah</li><li>Batak</li><li>Bengali</li><li>Bopomofo</li><li>Braille</li><li>Buginese</li><li>Buhid</li><li>Canadian_Aboriginal</li><li>Carian</li><li>Caucasian_Albanian</li><li>Chakma</li><li>Cham</li><li>Cherokee</li><li>Common</li><li>Coptic</li><li>Cuneiform</li><li>Cypriot</li><li>Cyrillic</li><li>Deseret</li><li>Devanagari</li><li>Duployan</li><li>Egyptian_Hieroglyphs</li><li>Elbasan</li><li>Ethiopic</li><li>Georgian</li><li>Glagolitic</li><li>Gothic</li><li>Grantha</li><li>Greek</li><li>Gujarati</li><li>Gurmukhi</li><li>Han</li><li>Hangul</li><li>Hanunoo</li><li>Hebrew</li><li>Hiragana</li><li>Imperial_Aramaic</li><li>Inherited</li><li>Inscriptional_Pahlavi</li><li>Inscriptional_Parthian</li><li>Javanese</li><li>Kaithi</li><li>Kannada</li><li>Katakana</li><li>Kayah_Li</li><li>Kharoshthi</li><li>Khmer</li><li>Khojki</li><li>Khudawadi</li><li>Lao</li><li>Latin</li><li>Lepcha</li><li>Limbu</li><li>Linear_A</li><li>Linear_B</li><li>Lisu</li><li>Lycian</li><li>Lydian</li><li>Mahajani</li><li>Malayalam</li><li>Mandaic</li><li>Manichaean</li><li>Meetei_Mayek</li><li>Mende_Kikakui</li><li>Meroitic_Cursive</li><li>Meroitic_Hieroglyphs</li><li>Miao</li><li>Modi</li><li>Mongolian</li><li>Mro</li><li>Myanmar</li><li>Nabataean</li><li>New_Tai_Lue</li><li>Nko</li><li>Ogham</li><li>Ol_Chiki</li><li>Old_Italic</li><li>Old_North_Arabian</li><li>Old_Permic</li><li>Old_Persian</li><li>Oriya</li><li>Old_South_Arabian</li><li>Old_Turkic</li><li>Osmanya</li><li>Pahawh_Hmong</li><li>Palmyrene</li><li>Pau_Cin_Hau</li><li>Phags_Pa</li><li>Phoenician</li><li>Psalter_Pahlavi</li><li>Rejang</li><li>Runic</li><li>Samaritan</li><li>Saurashtra</li><li>Sharada</li><li>Shavian</li><li>Siddham</li><li>Sinhala</li><li>Sora_Sompeng</li><li>Sundanese</li><li>Syloti_Nagri</li><li>Syriac</li><li>Tagalog</li><li>Tagbanwa</li><li>Tai_Le</li><li>Tai_Tham</li><li>Tai_Viet</li><li>Takri</li><li>Tamil</li><li>Telugu</li><li>Thaana</li><li>Thai</li><li>Tibetan</li><li>Tifinagh</li><li>Tirhuta</li><li>Ugaritic</li><li>Vai</li><li>Warang_Citi</li><li>Yi</li></ul><p>Each character has exactly one Unicode general category property, specified by a
two-letter acronym. For compatibility with Perl, negation can be specified by
including a circumflex between the opening brace and the property name. For
example, <code class="inline">\p{^Lu}</code> is the same as <code class="inline">\P{Lu}</code>.</p><p>If only one letter is specified with <code class="inline">\p</code> or <code class="inline">\P</code>, it includes all the general
category properties that start with that letter. In this case, in the absence of
negation, the curly brackets in the escape sequence are optional. The following
two examples have the same effect:</p><pre><code class="text">\p{L}
\pL</code></pre><p>The following general category property codes are supported:</p><ul><li><p><strong>C</strong> - Other</p></li><li><p><strong>Cc</strong> - Control</p></li><li><p><strong>Cf</strong> - Format</p></li><li><p><strong>Cn</strong> - Unassigned</p></li><li><p><strong>Co</strong> - Private use</p></li><li><p><strong>Cs</strong> - Surrogate</p></li><li><p><strong>L</strong> - Letter</p></li><li><p><strong>Ll</strong> - Lowercase letter</p></li><li><p><strong>Lm</strong> - Modifier letter</p></li><li><p><strong>Lo</strong> - Other letter</p></li><li><p><strong>Lt</strong> - Title case letter</p></li><li><p><strong>Lu</strong> - Uppercase letter</p></li><li><p><strong>M</strong> - Mark</p></li><li><p><strong>Mc</strong> - Spacing mark</p></li><li><p><strong>Me</strong> - Enclosing mark</p></li><li><p><strong>Mn</strong> - Non-spacing mark</p></li><li><p><strong>N</strong> - Number</p></li><li><p><strong>Nd</strong> - Decimal number</p></li><li><p><strong>Nl</strong> - Letter number</p></li><li><p><strong>No</strong> - Other number</p></li><li><p><strong>P</strong> - Punctuation</p></li><li><p><strong>Pc</strong> - Connector punctuation</p></li><li><p><strong>Pd</strong> - Dash punctuation</p></li><li><p><strong>Pe</strong> - Close punctuation</p></li><li><p><strong>Pf</strong> - Final punctuation</p></li><li><p><strong>Pi</strong> - Initial punctuation</p></li><li><p><strong>Po</strong> - Other punctuation</p></li><li><p><strong>Ps</strong> - Open punctuation</p></li><li><p><strong>S</strong> - Symbol</p></li><li><p><strong>Sc</strong> - Currency symbol</p></li><li><p><strong>Sk</strong> - Modifier symbol</p></li><li><p><strong>Sm</strong> - Mathematical symbol</p></li><li><p><strong>So</strong> - Other symbol</p></li><li><p><strong>Z</strong> - Separator</p></li><li><p><strong>Zl</strong> - Line separator</p></li><li><p><strong>Zp</strong> - Paragraph separator</p></li><li><p><strong>Zs</strong> - Space separator</p></li></ul><p>The special property L&amp; is also supported. It matches a character that has the
Lu, Ll, or Lt property, that is, a letter that is not classified as a modifier
or &quot;other&quot;.</p><p>The Cs (Surrogate) property applies only to characters in the range U+D800 to
U+DFFF. Such characters are invalid in Unicode strings and so cannot be tested
by PCRE. Perl does not support the Cs property.</p><p>The long synonyms for property names supported by Perl (such as <code class="inline">\p{Letter}</code>)
are not supported by PCRE. It is not permitted to prefix any of these properties
with &quot;Is&quot;.</p><p>No character in the Unicode table has the Cn (unassigned) property. This
property is instead assumed for any code point that is not in the Unicode table.</p><p>Specifying caseless matching does not affect these escape sequences. For
example, <code class="inline">\p{Lu}</code> always matches only uppercase letters. This is different from
the behavior of current versions of Perl.</p><p>Matching characters by Unicode property is not fast, as PCRE must do a
multistage table lookup to find a character property. That is why the
traditional escape sequences such as <code class="inline">\d</code> and <code class="inline">\w</code> do not use Unicode properties
in PCRE by default. However, you can make them do so by setting option <code class="inline">ucp</code> or
by starting the pattern with <code class="inline">(*UCP)</code>.</p><p><em>Extended Grapheme Clusters</em></p><p>The <code class="inline">\X</code> escape matches any number of Unicode characters that form an &quot;extended
grapheme cluster&quot;, and treats the sequence as an atomic group (see below). Up to
and including release 8.31, PCRE matched an earlier, simpler definition that was
equivalent to <code class="inline">(?&gt;\PM\pM*)</code>. That is, it matched a character without the &quot;mark&quot;
property, followed by zero or more characters with the &quot;mark&quot; property.
Characters with the &quot;mark&quot; property are typically non-spacing accents that
affect the preceding character.</p><p>This simple definition was extended in Unicode to include more complicated kinds
of composite character by giving each character a grapheme breaking property,
and creating rules that use these properties to define the boundaries of
extended grapheme clusters. In PCRE releases later than 8.31, <code class="inline">\X</code> matches one of
these clusters.</p><p><code class="inline">\X</code> always matches at least one character. Then it decides whether to add more
characters according to the following rules for ending a cluster:</p><ol><li>End at the end of the subject string.</li><li>Do not end between CR and LF; otherwise end after any control character.</li><li>Do not break Hangul (a Korean script) syllable sequences. Hangul characters
are of five types: L, V, T, LV, and LVT. An L character can be followed by an
L, V, LV, or LVT character. An LV or V character can be followed by a V or T
character. An LVT or T character can be followed only by a T character.</li><li>Do not end before extending characters or spacing marks. Characters with the
&quot;mark&quot; property always have the &quot;extend&quot; grapheme breaking property.</li><li>Do not end after prepend characters.</li><li>Otherwise, end the cluster.</li></ol><p><em>PCRE Additional Properties</em></p><p>In addition to the standard Unicode properties described earlier, PCRE supports
four more that make it possible to convert traditional escape sequences, such as
<code class="inline">\w</code> and <code class="inline">\s</code> to use Unicode properties. PCRE uses these non-standard, non-Perl
properties internally when the <code class="inline">ucp</code> option is passed. However, they can also be
used explicitly. The properties are as follows:</p><ul><li><p><strong>Xan</strong> - Any alphanumeric character. Matches characters that have either the
L (letter) or the N (number) property.</p></li><li><p><strong>Xps</strong> - Any Posix space character. Matches the characters tab, line feed,
vertical tab, form feed, carriage return, and any other character that has the
Z (separator) property.</p></li><li><p><strong>Xsp</strong> - Any Perl space character. Matches the same as Xps, except that
vertical tab is excluded.</p></li><li><p><strong>Xwd</strong> - Any Perl &quot;word&quot; character. Matches the same characters as Xan, plus
underscore.</p></li></ul><p>Perl and POSIX space are now the same. Perl added VT to its space character set
at release 5.18 and PCRE changed at release 8.34.</p><p>Xan matches characters that have either the L (letter) or the N (number)
property. Xps matches the characters tab, linefeed, vertical tab, form feed, or
carriage return, and any other character that has the Z (separator) property.
Xsp is the same as Xps; it used to exclude vertical tab, for Perl compatibility,
but Perl changed, and so PCRE followed at release 8.34. Xwd matches the same
characters as Xan, plus underscore.</p><p>There is another non-standard property, Xuc, which matches any character that
can be represented by a Universal Character Name in C++ and other programming
languages. These are the characters <code class="inline">$</code>, <code class="inline">@</code>, <code class="inline">`</code> (grave accent), and all characters
with Unicode code points &gt;= U+00A0, except for the surrogates U+D800 to U+DFFF.
Notice that most base (ASCII) characters are excluded. (Universal Character
Names are of the form <code class="inline">\uHHHH</code> or <code class="inline">\UHHHHHHHH</code>, where H is a hexadecimal digit.
Notice that the Xuc property does not match these sequences but the characters
that they represent.)</p><p><em>Resetting the Match Start</em></p><p>The escape sequence <code class="inline">\K</code> causes any previously matched characters not to be
included in the final matched sequence. For example, the following pattern
matches &quot;foobar&quot;, but reports that it has matched &quot;bar&quot;:</p><pre><code class="text">foo\Kbar</code></pre><p>This feature is similar to a lookbehind assertion (described below). However, in
this case, the part of the subject before the real match does not have to be of
fixed length, as lookbehind assertions do. The use of <code class="inline">\K</code> does not interfere
with the setting of captured substrings. For example, when the following pattern
matches &quot;foobar&quot;, the first substring is still set to &quot;foo&quot;:</p><pre><code class="text">(foo)\Kbar</code></pre><p>Perl documents that the use of <code class="inline">\K</code> within assertions is &quot;not well defined&quot;. In
PCRE, <code class="inline">\K</code> is acted upon when it occurs inside positive assertions, but is
ignored in negative assertions. Note that when a pattern such as <code class="inline">(?=ab\K)</code>
matches, the reported start of the match can be greater than the end of the
match.</p><p><em>Simple Assertions</em></p><p>The final use of backslash is for certain simple assertions. An assertion
specifies a condition that must be met at a particular point in a match, without
consuming any characters from the subject string. The use of subpatterns for
more complicated assertions is described below. The following are the
backslashed assertions:</p><ul><li><p><strong><code class="inline">\b</code></strong> - Matches at a word boundary.</p></li><li><p><strong><code class="inline">\B</code></strong> - Matches when not at a word boundary.</p></li><li><p><strong><code class="inline">\A</code></strong> - Matches at the start of the subject.</p></li><li><p><strong><code class="inline">\Z</code></strong> - Matches at the end of the subject, and before a newline at the end
of the subject.</p></li><li><p><strong><code class="inline">\z</code></strong> - Matches only at the end of the subject.</p></li><li><p><strong><code class="inline">\G</code></strong> - Matches at the first matching position in the subject.</p></li></ul><p>Inside a character class, <code class="inline">\b</code> has a different meaning; it matches the backspace
character. If any other of these assertions appears in a character class, by
default it matches the corresponding literal character (for example, <code class="inline">\B</code> matches
the letter B).</p><p>A word boundary is a position in the subject string where the current character
and the previous character do not both match <code class="inline">\w</code> or <code class="inline">\W</code> (that is, one matches
<code class="inline">\w</code> and the other matches <code class="inline">\W</code>), or the start or end of the string if the first
or last character matches <code class="inline">\w</code>, respectively. In UTF mode, the meanings of <code class="inline">\w</code>
and <code class="inline">\W</code> can be changed by setting option <code class="inline">ucp</code>. When this is done, it also
affects <code class="inline">\b</code> and <code class="inline">\B</code>. PCRE and Perl do not have a separate &quot;start of word&quot; or
&quot;end of word&quot; metasequence. However, whatever follows <code class="inline">\b</code> normally determines
which it is. For example, the fragment <code class="inline">\ba</code> matches &quot;a&quot; at the start of a word.</p><p>The <code class="inline">\A</code>, <code class="inline">\Z</code>, and <code class="inline">\z</code> assertions differ from the traditional circumflex and
dollar (described in the next section) in that they only ever match at the very
start and end of the subject string, whatever options are set. Thus, they are
independent of multiline mode. These three assertions are not affected by
options <code class="inline">notbol</code> or <code class="inline">noteol</code>, which affect only the behavior of the circumflex
and dollar metacharacters. However, if argument <code class="inline">startoffset</code> of <a href="#run/3"><code class="inline">run/3</code></a> is
non-zero, indicating that matching is to start at a point other than the
beginning of the subject, <code class="inline">\A</code> can never match. The difference between <code class="inline">\Z</code> and
<code class="inline">\z</code> is that <code class="inline">\Z</code> matches before a newline at the end of the string and at the
very end, while <code class="inline">\z</code> matches only at the end.</p><p>The <code class="inline">\G</code> assertion is true only when the current matching position is at the
start point of the match, as specified by argument <code class="inline">startoffset</code> of
<a href="#run/3"><code class="inline">run/3</code></a>. It differs from <code class="inline">\A</code> when the value of <code class="inline">startoffset</code> is
non-zero. By calling <a href="#run/3"><code class="inline">run/3</code></a> multiple times with appropriate
arguments, you can mimic the Perl option <code class="inline">/g</code>, and it is in this kind of
implementation where <code class="inline">\G</code> can be useful.</p><p>Notice, however, that the PCRE interpretation of <code class="inline">\G</code>, as the start of the
current match, is subtly different from Perl, which defines it as the end of the
previous match. In Perl, these can be different when the previously matched
string was empty. As PCRE does only one match at a time, it cannot reproduce
this behavior.</p><p>If all the alternatives of a pattern begin with <code class="inline">\G</code>, the expression is anchored
to the starting match position, and the &quot;anchored&quot; flag is set in the compiled
regular expression.</p><p><a href="" id="sect4"></a></p><h2 id="module-circumflex-and-dollar" class="section-heading">
  <a href="#module-circumflex-and-dollar" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Circumflex and Dollar</span>
</h2>
<p>The circumflex and dollar metacharacters are zero-width assertions. That is,
they test for a particular condition to be true without consuming any characters
from the subject string.</p><p>Outside a character class, in the default matching mode, the circumflex
character is an assertion that is true only if the current matching point is at
the start of the subject string. If argument <code class="inline">startoffset</code> of <a href="#run/3"><code class="inline">run/3</code></a> is
non-zero, circumflex can never match if option <code class="inline">multiline</code> is unset. Inside a
character class, circumflex has an entirely different meaning (see below).</p><p>Circumflex needs not to be the first character of the pattern if some
alternatives are involved, but it is to be the first thing in each alternative
in which it appears if the pattern is ever to match that branch. If all possible
alternatives start with a circumflex, that is, if the pattern is constrained to
match only at the start of the subject, it is said to be an &quot;anchored&quot; pattern.
(There are also other constructs that can cause a pattern to be anchored.)</p><p>The dollar character is an assertion that is true only if the current matching
point is at the end of the subject string, or immediately before a newline at
the end of the string (by default). Notice however that it does not match the
newline. Dollar needs not to be the last character of the pattern if some
alternatives are involved, but it is to be the last item in any branch in which
it appears. Dollar has no special meaning in a character class.</p><p>The meaning of dollar can be changed so that it matches only at the very end of
the string, by setting option <code class="inline">dollar_endonly</code> at compile time. This does not
affect the <code class="inline">\Z</code> assertion.</p><p>The meanings of the circumflex and dollar characters are changed if option
<code class="inline">multiline</code> is set. When this is the case, a circumflex matches immediately
after internal newlines and at the start of the subject string. It does not
match after a newline that ends the string. A dollar matches before any newlines
in the string, and at the very end, when <code class="inline">multiline</code> is set. When newline is
specified as the two-character sequence CRLF, isolated CR and LF characters do
not indicate newlines.</p><p>For example, the pattern <code class="inline">/^abc$/</code> matches the subject string &quot;def\nabc&quot; (where
\n represents a newline) in multiline mode, but not otherwise. So, patterns
that are anchored in single-line mode because all branches start with ^ are not
anchored in multiline mode, and a match for circumflex is possible when argument
<em>startoffset</em> of <a href="#run/3"><code class="inline">run/3</code></a> is non-zero. Option <code class="inline">dollar_endonly</code> is
ignored if <code class="inline">multiline</code> is set.</p><p>Notice that the sequences <code class="inline">\A</code>, <code class="inline">\Z</code>, and <code class="inline">\z</code> can be used to match the start and
end of the subject in both modes. If all branches of a pattern start with <code class="inline">\A</code>,
it is always anchored, regardless if <code class="inline">multiline</code> is set.</p><p><a href="" id="sect5"></a></p><h2 id="module-full-stop-period-dot-and-n" class="section-heading">
  <a href="#module-full-stop-period-dot-and-n" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Full Stop (Period, Dot) and \N</span>
</h2>
<p>Outside a character class, a dot in the pattern matches any character in the
subject string except (by default) a character that signifies the end of a line.</p><p>When a line ending is defined as a single character, dot never matches that
character. When the two-character sequence CRLF is used, dot does not match CR
if it is immediately followed by LF, otherwise it matches all characters
(including isolated CRs and LFs). When any Unicode line endings are recognized,
dot does not match CR, LF, or any of the other line-ending characters.</p><p>The behavior of dot regarding newlines can be changed. If option <code class="inline">dotall</code> is
set, a dot matches any character, without exception. If the two-character
sequence CRLF is present in the subject string, it takes two dots to match it.</p><p>The handling of dot is entirely independent of the handling of circumflex and
dollar, the only relationship is that both involve newlines. Dot has no special
meaning in a character class.</p><p>The escape sequence <code class="inline">\N</code> behaves like a dot, except that it is not affected by
option <code class="inline">PCRE_DOTALL</code>. That is, it matches any character except one that
signifies the end of a line. Perl also uses <code class="inline">\N</code> to match characters by name but
PCRE does not support this.</p><p><a href="" id="sect6"></a></p><h2 id="module-matching-a-single-data-unit" class="section-heading">
  <a href="#module-matching-a-single-data-unit" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Matching a Single Data Unit</span>
</h2>
<p>Outside a character class, the escape sequence <code class="inline">\C</code> matches any data unit,
regardless if a UTF mode is set. One data unit is one byte. Unlike a dot, <code class="inline">\C</code>
always matches line-ending characters. The feature is provided in Perl to match
individual bytes in UTF-8 mode, but it is unclear how it can usefully be used.
As <code class="inline">\C</code> breaks up characters into individual data units, matching one unit with
<code class="inline">\C</code> in a UTF mode means that the remaining string can start with a malformed UTF
character. This has undefined results, as PCRE assumes that it deals with valid
UTF strings.</p><p>PCRE does not allow <code class="inline">\C</code> to appear in lookbehind assertions (described below) in
a UTF mode, as this would make it impossible to calculate the length of the
lookbehind.</p><p>The <code class="inline">\C</code> escape sequence is best avoided. However, one way of using it that
avoids the problem of malformed UTF characters is to use a lookahead to check
the length of the next character, as in the following pattern, which can be used
with a UTF-8 string (ignore whitespace and line breaks):</p><pre><code class="text">(?| (?=[\x00-\x7f])(\C) |
    (?=[\x80-\x{7ff}])(\C)(\C) |
    (?=[\x{800}-\x{ffff}])(\C)(\C)(\C) |
    (?=[\x{10000}-\x{1fffff}])(\C)(\C)(\C)(\C))</code></pre><p>A group that starts with (?| resets the capturing parentheses numbers in each
alternative (see section <a href="re.html#sect12">Duplicate Subpattern Numbers</a>). The
assertions at the start of each branch check the next UTF-8 character for values
whose encoding uses 1, 2, 3, or 4 bytes, respectively. The individual bytes of
the character are then captured by the appropriate number of groups.</p><p><a href="" id="sect7"></a></p><h2 id="module-square-brackets-and-character-classes" class="section-heading">
  <a href="#module-square-brackets-and-character-classes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Square Brackets and Character Classes</span>
</h2>
<p>An opening square bracket introduces a character class, terminated by a closing
square bracket. A closing square bracket on its own is not special by default.
However, if option <code class="inline">PCRE_JAVASCRIPT_COMPAT</code> is set, a lone closing square
bracket causes a compile-time error. If a closing square bracket is required as
a member of the class, it is to be the first data character in the class (after
an initial circumflex, if present) or escaped with a backslash.</p><p>A character class matches a single character in the subject. In a UTF mode, the
character can be more than one data unit long. A matched character must be in
the set of characters defined by the class, unless the first character in the
class definition is a circumflex, in which case the subject character must not
be in the set defined by the class. If a circumflex is required as a member of
the class, ensure that it is not the first character, or escape it with a
backslash.</p><p>For example, the character class <code class="inline">[aeiou]</code> matches any lowercase vowel, while
<code class="inline">[^aeiou]</code> matches any character that is not a lowercase vowel. Notice that a
circumflex is just a convenient notation for specifying the characters that are
in the class by enumerating those that are not. A class that starts with a
circumflex is not an assertion; it still consumes a character from the subject
string, and therefore it fails if the current pointer is at the end of the
string.</p><p>In UTF-8 mode, characters with values &gt; 255 (0xffff) can be included in a class
as a literal string of data units, or by using the <code class="inline">\x{</code> escaping mechanism.</p><p>When caseless matching is set, any letters in a class represent both their
uppercase and lowercase versions. For example, a caseless <code class="inline">[aeiou]</code> matches &quot;A&quot;
and &quot;a&quot;, and a caseless <code class="inline">[^aeiou]</code> does not match &quot;A&quot;, but a caseful version
would. In a UTF mode, PCRE always understands the concept of case for characters
whose values are &lt; 256, so caseless matching is always possible. For characters
with higher values, the concept of case is supported only if PCRE is compiled
with Unicode property support. If you want to use caseless matching in a UTF
mode for characters &gt;=, ensure that PCRE is compiled with Unicode property
support and with UTF support.</p><p>Characters that can indicate line breaks are never treated in any special way
when matching character classes, whatever line-ending sequence is in use, and
whatever setting of options <code class="inline">PCRE_DOTALL</code> and <code class="inline">PCRE_MULTILINE</code> is used. A class
such as <code class="inline">[^a]</code> always matches one of these characters.</p><p>The minus (hyphen) character can be used to specify a range of characters in a
character class. For example, <code class="inline">[d-m]</code> matches any letter between d and m,
inclusive. If a minus character is required in a class, it must be escaped with
a backslash or appear in a position where it cannot be interpreted as indicating
a range, typically as the first or last character in the class, or immediately
after a range. For example, <code class="inline">[b-d-z]</code> matches letters in the range b to d, a
hyphen character, or z.</p><p>The literal character &quot;]&quot; cannot be the end character of a range. A pattern such
as <code class="inline">[W-]46]</code> is interpreted as a class of two characters (&quot;W&quot; and &quot;-&quot;) followed
by a literal string &quot;46]&quot;, so it would match &quot;W46]&quot; or &quot;-46]&quot;. However, if &quot;]&quot;
is escaped with a backslash, it is interpreted as the end of range, so
<code class="inline">[W-\]46]</code> is interpreted as a class containing a range followed by two other
characters. The octal or hexadecimal representation of &quot;]&quot; can also be used to
end a range.</p><p>An error is generated if a POSIX character class (see below) or an escape
sequence other than one that defines a single character appears at a point where
a range ending character is expected. For example, <code class="inline">[z-\xff]</code> is valid, but
<code class="inline">[A-\d]</code> and <code class="inline">[A-[:digit:]]</code> are not.</p><p>Ranges operate in the collating sequence of character values. They can also be
used for characters specified numerically, for example, <code class="inline">[\000-\037]</code>. Ranges
can include any characters that are valid for the current mode.</p><p>If a range that includes letters is used when caseless matching is set, it
matches the letters in either case. For example, <code class="inline">[W-c]</code> is equivalent to
<code class="inline">[][\\^_`wxyzabc]</code>, matched caselessly. In a non-UTF mode, if character
tables for a French locale are in use, <code class="inline">[\xc8-\xcb]</code> matches accented E
characters in both cases. In UTF modes, PCRE supports the concept of case for
characters with values &gt; 255 only when it is compiled with Unicode property
support.</p><p>The character escape sequences <code class="inline">\d</code>, <code class="inline">\D</code>, <code class="inline">\h</code>, <code class="inline">\H</code>, <code class="inline">\p</code>, <code class="inline">\P</code>, <code class="inline">\s</code>, <code class="inline">\S</code>, <code class="inline">\v</code>, <code class="inline">\V</code>,
<code class="inline">\w</code>, and <code class="inline">\W</code> can appear in a character class, and add the characters that they
match to the class. For example, <code class="inline">[\dABCDEF]</code> matches any hexadecimal digit. In
UTF modes, option <code class="inline">ucp</code> affects the meanings of <code class="inline">\d</code>, <code class="inline">\s</code>, <code class="inline">\w</code> and their
uppercase partners, just as it does when they appear outside a character class,
as described in section
<a href="re.html#generic_character_types">Generic Character Types</a> earlier. The escape
sequence <code class="inline">\b</code> has a different meaning inside a character class; it matches the
backspace character. The sequences <code class="inline">\B</code>, <code class="inline">\N</code>, <code class="inline">\R</code>, and <code class="inline">\X</code> are not special inside
a character class. Like any other unrecognized escape sequences, they are
treated as the literal characters &quot;B&quot;, &quot;N&quot;, &quot;R&quot;, and &quot;X&quot;.</p><p>A circumflex can conveniently be used with the uppercase character types to
specify a more restricted set of characters than the matching lowercase type.
For example, class <code class="inline">[^\W_]</code> matches any letter or digit, but not underscore,
while <code class="inline">[\w]</code> includes underscore. A positive character class is to be read as
&quot;something OR something OR ...&quot; and a negative class as &quot;NOT something AND NOT
something AND NOT ...&quot;.</p><p>Only the following metacharacters are recognized in character classes:</p><ul><li>Backslash</li><li>Hyphen (only where it can be interpreted as specifying a range)</li><li>Circumflex (only at the start)</li><li>Opening square bracket (only when it can be interpreted as introducing a Posix
class name, or for a special compatibility feature; see the next two sections)</li><li>Terminating closing square bracket</li></ul><p>However, escaping other non-alphanumeric characters does no harm.</p><p><a href="" id="sect8"></a></p><h2 id="module-posix-character-classes" class="section-heading">
  <a href="#module-posix-character-classes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Posix Character Classes</span>
</h2>
<p>Perl supports the Posix notation for character classes. This uses names enclosed
by <code class="inline">[:</code> and <code class="inline">:]</code> within the enclosing square brackets. PCRE also supports this
notation. For example, the following matches &quot;0&quot;, &quot;1&quot;, any alphabetic character,
or &quot;%&quot;:</p><pre><code class="text">[01[:alpha:]%]</code></pre><p>The following are the supported class names:</p><ul><li><p><strong>alnum</strong> - Letters and digits</p></li><li><p><strong>alpha</strong> - Letters</p></li><li><p><strong>blank</strong> - Space or tab only</p></li><li><p><strong>cntrl</strong> - Control characters</p></li><li><p><strong>digit</strong> - Decimal digits (same as <code class="inline">\d</code>)</p></li><li><p><strong>graph</strong> - Printing characters, excluding space</p></li><li><p><strong>lower</strong> - Lowercase letters</p></li><li><p><strong>print</strong> - Printing characters, including space</p></li><li><p><strong>punct</strong> - Printing characters, excluding letters, digits, and space</p></li><li><p><strong>space</strong> - Whitespace (the same as <code class="inline">\s</code> from PCRE 8.34)</p></li><li><p><strong>upper</strong> - Uppercase letters</p></li><li><p><strong>word</strong> - &quot;Word&quot; characters (same as <code class="inline">\w</code>)</p></li><li><p><strong>xdigit</strong> - Hexadecimal digits</p></li></ul><p>There is another character class, <code class="inline">ascii</code>, that erroneously matches Latin-1
characters instead of the 0-127 range specified by POSIX. This cannot be fixed
without altering the behaviour of other classes, so we recommend matching the
range with <code class="inline">[\\0-\x7f]</code> instead.</p><p>The default &quot;space&quot; characters are HT (9), LF (10), VT (11), FF (12), CR (13),
and space (32). If locale-specific matching is taking place, the list of space
characters may be different; there may be fewer or more of them. &quot;Space&quot; used to
be different to <code class="inline">\s</code>, which did not include VT, for Perl compatibility. However,
Perl changed at release 5.18, and PCRE followed at release 8.34. &quot;Space&quot; and <code class="inline">\s</code>
now match the same set of characters.</p><p>The name &quot;word&quot; is a Perl extension, and &quot;blank&quot; is a GNU extension from Perl
5.8. Another Perl extension is negation, which is indicated by a ^ character
after the colon. For example, the following matches &quot;1&quot;, &quot;2&quot;, or any non-digit:</p><pre><code class="text">[12[:^digit:]]</code></pre><p>PCRE (and Perl) also recognize the Posix syntax <code class="inline">[.ch.]</code> and <code class="inline">[=ch=]</code> where &quot;ch&quot;
is a &quot;collating element&quot;, but these are not supported, and an error is given if
they are encountered.</p><p>By default, characters with values &gt; 255 do not match any of the Posix character
classes. However, if option <code class="inline">PCRE_UCP</code> is passed to <code class="inline">pcre_compile()</code>, some of
the classes are changed so that Unicode character properties are used. This is
achieved by replacing certain Posix classes by other sequences, as follows:</p><ul><li><p><strong><code class="inline">[:alnum:]</code></strong> - Becomes <em><code class="inline">\p{Xan}</code></em></p></li><li><p><strong><code class="inline">[:alpha:]</code></strong> - Becomes <em><code class="inline">\p{L}</code></em></p></li><li><p><strong><code class="inline">[:blank:]</code></strong> - Becomes <em><code class="inline">\h</code></em></p></li><li><p><strong><code class="inline">[:digit:]</code></strong> - Becomes <em><code class="inline">\p{Nd}</code></em></p></li><li><p><strong><code class="inline">[:lower:]</code></strong> - Becomes <em><code class="inline">\p{Ll}</code></em></p></li><li><p><strong><code class="inline">[:space:]</code></strong> - Becomes <em><code class="inline">\p{Xps}</code></em></p></li><li><p><strong><code class="inline">[:upper:]</code></strong> - Becomes <em><code class="inline">\p{Lu}</code></em></p></li><li><p><strong><code class="inline">[:word:]</code></strong> - Becomes <em><code class="inline">\p{Xwd}</code></em></p></li></ul><p>Negated versions, such as <code class="inline">[:^alpha:]</code>, use <code class="inline">\P</code> instead of <code class="inline">\p</code>. Three other POSIX
classes are handled specially in UCP mode:</p><ul><li><p><strong><code class="inline">[:graph:]</code></strong> - This matches characters that have glyphs that mark the page
when printed. In Unicode property terms, it matches all characters with the L,
M, N, P, S, or Cf properties, except for:</p><ul><li><p><strong>U+061C</strong> - Arabic Letter Mark</p></li><li><p><strong>U+180E</strong> - Mongolian Vowel Separator</p></li><li><p><strong>U+2066 - U+2069</strong> - Various &quot;isolate&quot;s</p></li></ul></li><li><p><strong><code class="inline">[:print:]</code></strong> - This matches the same characters as <code class="inline">[:graph:]</code> plus space
characters that are not controls, that is, characters with the Zs property.</p></li><li><p><strong><code class="inline">[:punct:]</code></strong> - This matches all characters that have the Unicode P
(punctuation) property, plus those characters whose code points are less than
128 that have the S (Symbol) property.</p></li></ul><p>The other POSIX classes are unchanged, and match only characters with code
points less than 128.</p><p><em>Compatibility Feature for Word Boundaries</em></p><p>In the POSIX.2 compliant library that was included in 4.4BSD Unix, the ugly
syntax <code class="inline">[[:&lt;:]]</code> and <code class="inline">[[:&gt;:]]</code> is used for matching &quot;start of word&quot; and &quot;end of
word&quot;. PCRE treats these items as follows:</p><ul><li><p><strong><code class="inline">[[:&lt;:]]</code></strong> - is converted to <code class="inline">\b(?=\w)</code></p></li><li><p><strong><code class="inline">[[:&gt;:]]</code></strong> - is converted to <code class="inline">\b(?&lt;=\w)</code></p></li></ul><p>Only these exact character sequences are recognized. A sequence such as
<code class="inline">[a[:&lt;:]b]</code> provokes error for an unrecognized POSIX class name. This support is
not compatible with Perl. It is provided to help migrations from other
environments, and is best not used in any new patterns. Note that <code class="inline">\b</code> matches at
the start and the end of a word (see &quot;Simple assertions&quot; above), and in a
Perl-style pattern the preceding or following character normally shows which is
wanted, without the need for the assertions that are used above in order to give
exactly the POSIX behaviour.</p><p><a href="" id="sect9"></a></p><h2 id="module-vertical-bar" class="section-heading">
  <a href="#module-vertical-bar" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Vertical Bar</span>
</h2>
<p>Vertical bar characters are used to separate alternative patterns. For example,
the following pattern matches either &quot;gilbert&quot; or &quot;sullivan&quot;:</p><pre><code class="text">gilbert|sullivan</code></pre><p>Any number of alternatives can appear, and an empty alternative is permitted
(matching the empty string). The matching process tries each alternative in
turn, from left to right, and the first that succeeds is used. If the
alternatives are within a subpattern (defined in section
<a href="re.html#sect11">Subpatterns</a>), &quot;succeeds&quot; means matching the remaining main
pattern and the alternative in the subpattern.</p><p><a href="" id="sect10"></a></p><h2 id="module-internal-option-setting" class="section-heading">
  <a href="#module-internal-option-setting" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Internal Option Setting</span>
</h2>
<p>The settings of the Perl-compatible options <code class="inline">caseless</code>, <code class="inline">multiline</code>, <code class="inline">dotall</code>,
and <code class="inline">extended</code> can be changed from within the pattern by a sequence of Perl
option letters enclosed between &quot;(?&quot; and &quot;)&quot;. The option letters are as follows:</p><ul><li><p><strong>i</strong> - For <code class="inline">caseless</code></p></li><li><p><strong>m</strong> - For <code class="inline">multiline</code></p></li><li><p><strong>s</strong> - For <code class="inline">dotall</code></p></li><li><p><strong>x</strong> - For <code class="inline">extended</code></p></li></ul><p>For example, <code class="inline">(?im)</code> sets caseless, multiline matching. These options can also
be unset by preceding the letter with a hyphen. A combined setting and unsetting
such as <code class="inline">(?im-sx)</code>, which sets <code class="inline">caseless</code> and <code class="inline">multiline</code>, while unsetting
<code class="inline">dotall</code> and <code class="inline">extended</code>, is also permitted. If a letter appears both before and
after the hyphen, the option is unset.</p><p>The PCRE-specific options <code class="inline">dupnames</code>, <code class="inline">ungreedy</code>, and <code class="inline">extra</code> can be changed in
the same way as the Perl-compatible options by using the characters J, U, and X
respectively.</p><p>When one of these option changes occurs at top-level (that is, not inside
subpattern parentheses), the change applies to the remainder of the pattern that
follows.</p><p>An option change within a subpattern (see section <a href="re.html#sect11">Subpatterns</a>)
affects only that part of the subpattern that follows it. So, the following
matches abc and aBc and no other strings (assuming <code class="inline">caseless</code> is not used):</p><pre><code class="text">(a(?i)b)c</code></pre><p>By this means, options can be made to have different settings in different parts
of the pattern. Any changes made in one alternative do carry on into subsequent
branches within the same subpattern. For example:</p><pre><code class="text">(a(?i)b|c)</code></pre><p>matches &quot;ab&quot;, &quot;aB&quot;, &quot;c&quot;, and &quot;C&quot;, although when matching &quot;C&quot; the first branch is
abandoned before the option setting. This is because the effects of option
settings occur at compile time. There would be some weird behavior otherwise.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Other PCRE-specific options can be set by the application when the compiling
or matching functions are called. Sometimes the pattern can contain special
leading sequences, such as (*CRLF), to override what the application has set
or what has been defaulted. Details are provided in section
<a href="re.html#newline_sequences">Newline Sequences</a> earlier.</p><p>The (<em>UTF8) and (</em>UCP) leading sequences can be used to set UTF and Unicode
property modes. They are equivalent to setting options <code class="inline">unicode</code> and <code class="inline">ucp</code>,
respectively. The (<em>UTF) sequence is a generic version that can be used with
any of the libraries. However, the application can set option <code class="inline">never_utf</code>,
which locks out the use of the (</em>UTF) sequences.</p></section><p><a href="" id="sect11"></a></p><h2 id="module-subpatterns" class="section-heading">
  <a href="#module-subpatterns" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Subpatterns</span>
</h2>
<p>Subpatterns are delimited by parentheses (round brackets), which can be nested.
Turning part of a pattern into a subpattern does two things:</p><ul><li><p><strong>1.</strong> - It localizes a set of alternatives. For example, the following
pattern matches &quot;cataract&quot;, &quot;caterpillar&quot;, or &quot;cat&quot;:</p><pre><code class="text">cat(aract|erpillar|)</code></pre><p>Without the parentheses, it would match &quot;cataract&quot;, &quot;erpillar&quot;, or an empty
string.</p></li><li><p><strong>2.</strong> - It sets up the subpattern as a capturing subpattern. That is, when
the complete pattern matches, that portion of the subject string that matched
the subpattern is passed back to the caller through the return value of
<a href="#run/3"><code class="inline">run/3</code></a>.</p></li></ul><p>Opening parentheses are counted from left to right (starting from 1) to obtain
numbers for the capturing subpatterns. For example, if the string &quot;the red king&quot;
is matched against the following pattern, the captured substrings are &quot;red
king&quot;, &quot;red&quot;, and &quot;king&quot;, and are numbered 1, 2, and 3, respectively:</p><pre><code class="text">the ((red|white) (king|queen))</code></pre><p>It is not always helpful that plain parentheses fulfill two functions. Often a
grouping subpattern is required without a capturing requirement. If an opening
parenthesis is followed by a question mark and a colon, the subpattern does not
do any capturing, and is not counted when computing the number of any subsequent
capturing subpatterns. For example, if the string &quot;the white queen&quot; is matched
against the following pattern, the captured substrings are &quot;white queen&quot; and
&quot;queen&quot;, and are numbered 1 and 2:</p><pre><code class="text">the ((?:red|white) (king|queen))</code></pre><p>The maximum number of capturing subpatterns is 65535.</p><p>As a convenient shorthand, if any option settings are required at the start of a
non-capturing subpattern, the option letters can appear between &quot;?&quot; and &quot;:&quot;.
Thus, the following two patterns match the same set of strings:</p><pre><code class="text">(?i:saturday|sunday)
(?:(?i)saturday|sunday)</code></pre><p>As alternative branches are tried from left to right, and options are not reset
until the end of the subpattern is reached, an option setting in one branch does
affect subsequent branches, so the above patterns match both &quot;SUNDAY&quot; and
&quot;Saturday&quot;.</p><p><a href="" id="sect12"></a></p><h2 id="module-duplicate-subpattern-numbers" class="section-heading">
  <a href="#module-duplicate-subpattern-numbers" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Duplicate Subpattern Numbers</span>
</h2>
<p>Perl 5.10 introduced a feature where each alternative in a subpattern uses the
same numbers for its capturing parentheses. Such a subpattern starts with <code class="inline">(?|</code>
and is itself a non-capturing subpattern. For example, consider the following
pattern:</p><pre><code class="text">(?|(Sat)ur|(Sun))day</code></pre><p>As the two alternatives are inside a <code class="inline">(?|</code> group, both sets of capturing
parentheses are numbered one. Thus, when the pattern matches, you can look at
captured substring number one, whichever alternative matched. This construct is
useful when you want to capture a part, but not all, of one of many
alternatives. Inside a <code class="inline">(?|</code> group, parentheses are numbered as usual, but the
number is reset at the start of each branch. The numbers of any capturing
parentheses that follow the subpattern start after the highest number used in
any branch. The following example is from the Perl documentation; the numbers
underneath show in which buffer the captured content is stored:</p><pre><code class="text"># before  ---------------branch-reset----------- after
/ ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
# 1            2         2  3        2     3     4</code></pre><p>A back reference to a numbered subpattern uses the most recent value that is set
for that number by any subpattern. The following pattern matches &quot;abcabc&quot; or
&quot;defdef&quot;:</p><pre><code class="text">/(?|(abc)|(def))\1/</code></pre><p>In contrast, a subroutine call to a numbered subpattern always refers to the
first one in the pattern with the given number. The following pattern matches
&quot;abcabc&quot; or &quot;defabc&quot;:</p><pre><code class="text">/(?|(abc)|(def))(?1)/</code></pre><p>If a condition test for a subpattern having matched refers to a non-unique
number, the test is true if any of the subpatterns of that number have matched.</p><p>An alternative approach using this &quot;branch reset&quot; feature is to use duplicate
named subpatterns, as described in the next section.</p><p><a href="" id="sect13"></a></p><h2 id="module-named-subpatterns" class="section-heading">
  <a href="#module-named-subpatterns" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Named Subpatterns</span>
</h2>
<p>Identifying capturing parentheses by number is simple, but it can be hard to
keep track of the numbers in complicated regular expressions. Also, if an
expression is modified, the numbers can change. To help with this difficulty,
PCRE supports the naming of subpatterns. This feature was not added to Perl
until release 5.10. Python had the feature earlier, and PCRE introduced it at
release 4.0, using the Python syntax. PCRE now supports both the Perl and the
Python syntax. Perl allows identically numbered subpatterns to have different
names, but PCRE does not.</p><p>In PCRE, a subpattern can be named in one of three ways: <code class="inline">(?&lt;name&gt;...)</code> or
<code class="inline">(?'name'...)</code> as in Perl, or <code class="inline">(?P&lt;name&gt;...)</code> as in Python. References to
capturing parentheses from other parts of the pattern, such as back references,
recursion, and conditions, can be made by name and by number.</p><p>Names consist of up to 32 alphanumeric characters and underscores, but must
start with a non-digit. Named capturing parentheses are still allocated numbers
as well as names, exactly as if the names were not present. The <code class="inline">capture</code>
specification to <a href="#run/3"><code class="inline">run/3</code></a> can use named values if they are present in the regular
expression.</p><p>By default, a name must be unique within a pattern, but this constraint can be
relaxed by setting option <code class="inline">dupnames</code> at compile time. (Duplicate names are also
always permitted for subpatterns with the same number, set up as described in
the previous section.) Duplicate names can be useful for patterns where only one
instance of the named parentheses can match. Suppose that you want to match the
name of a weekday, either as a 3-letter abbreviation or as the full name, and in
both cases you want to extract the abbreviation. The following pattern (ignoring
the line breaks) does the job:</p><pre><code class="text">(?&lt;DN&gt;Mon|Fri|Sun)(?:day)?|
(?&lt;DN&gt;Tue)(?:sday)?|
(?&lt;DN&gt;Wed)(?:nesday)?|
(?&lt;DN&gt;Thu)(?:rsday)?|
(?&lt;DN&gt;Sat)(?:urday)?</code></pre><p>There are five capturing substrings, but only one is ever set after a match. (An
alternative way of solving this problem is to use a &quot;branch reset&quot; subpattern,
as described in the previous section.)</p><p>For capturing named subpatterns which names are not unique, the first matching
occurrence (counted from left to right in the subject) is returned from <a href="#run/3"><code class="inline">run/3</code></a>,
if the name is specified in the <code class="inline">values</code> part of the <code class="inline">capture</code> statement. The
<code class="inline">all_names</code> capturing value matches all the names in the same way.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>You cannot use different names to distinguish between two subpatterns with the
same number, as PCRE uses only the numbers when matching. For this reason, an
error is given at compile time if different names are specified to subpatterns
with the same number. However, you can specify the same name to subpatterns
with the same number, even when <code class="inline">dupnames</code> is not set.</p></section><p><a href="" id="sect14"></a></p><h2 id="module-repetition" class="section-heading">
  <a href="#module-repetition" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Repetition</span>
</h2>
<p>Repetition is specified by quantifiers, which can follow any of the following
items:</p><ul><li>A literal data character</li><li>The dot metacharacter</li><li>The <code class="inline">\C</code> escape sequence</li><li>The <code class="inline">\X</code> escape sequence</li><li>The <code class="inline">\R</code> escape sequence</li><li>An escape such as <code class="inline">\d</code> or <code class="inline">\pL</code> that matches a single character</li><li>A character class</li><li>A back reference (see the next section)</li><li>A parenthesized subpattern (including assertions)</li><li>A subroutine call to a subpattern (recursive or otherwise)</li></ul><p>The general repetition quantifier specifies a minimum and maximum number of
permitted matches, by giving the two numbers in curly brackets (braces),
separated by a comma. The numbers must be &lt; 65536, and the first must be less
than or equal to the second. For example, the following matches &quot;zz&quot;, &quot;zzz&quot;, or
&quot;zzzz&quot;:</p><pre><code class="text">z{2,4}</code></pre><p>A closing brace on its own is not a special character. If the second number is
omitted, but the comma is present, there is no upper limit. If the second number
and the comma are both omitted, the quantifier specifies an exact number of
required matches. Thus, the following matches at least three successive vowels,
but can match many more:</p><pre><code class="text">[aeiou]{3,}</code></pre><p>The following matches exactly eight digits:</p><pre><code class="text">\d{8}</code></pre><p>An opening curly bracket that appears in a position where a quantifier is not
allowed, or one that does not match the syntax of a quantifier, is taken as a
literal character. For example, {,6} is not a quantifier, but a literal string
of four characters.</p><p>In Unicode mode, quantifiers apply to characters rather than to individual data
units. Thus, for example, <code class="inline">\x{100}{2}</code> matches two characters, each of which
is represented by a 2-byte sequence in a UTF-8 string. Similarly, <code class="inline">\X{3}</code>
matches three Unicode extended grapheme clusters, each of which can be many data
units long (and they can be of different lengths).</p><p>The quantifier {0} is permitted, causing the expression to behave as if the
previous item and the quantifier were not present. This can be useful for
subpatterns that are referenced as subroutines from elsewhere in the pattern
(but see also section
<a href="re.html#defining_subpatterns">Defining Subpatterns for Use by Reference Only</a>).
Items other than subpatterns that have a {0} quantifier are omitted from the
compiled pattern.</p><p>For convenience, the three most common quantifiers have single-character
abbreviations:</p><ul><li><p><strong>*</strong> - Equivalent to {0,}</p></li><li><p><strong>+</strong> - Equivalent to {1,}</p></li><li><p><strong>?</strong> - Equivalent to {0,1}</p></li></ul><p>Infinite loops can be constructed by following a subpattern that can match no
characters with a quantifier that has no upper limit, for example:</p><pre><code class="text">(a?)*</code></pre><p>Earlier versions of Perl and PCRE used to give an error at compile time for such
patterns. However, as there are cases where this can be useful, such patterns
are now accepted. However, if any repetition of the subpattern matches no
characters, the loop is forcibly broken.</p><p>By default, the quantifiers are &quot;greedy&quot;, that is, they match as much as
possible (up to the maximum number of permitted times), without causing the
remaining pattern to fail. The classic example of where this gives problems is
in trying to match comments in C programs. These appear between /<em> and </em>/.
Within the comment, individual * and / characters can appear. An attempt to
match C comments by applying the pattern</p><pre><code class="text">/\*.*\*/</code></pre><p>to the string</p><pre><code class="text">/* first comment */  not comment  /* second comment */</code></pre><p>fails, as it matches the entire string owing to the greediness of the .* item.</p><p>However, if a quantifier is followed by a question mark, it ceases to be greedy,
and instead matches the minimum number of times possible, so the following
pattern does the right thing with the C comments:</p><pre><code class="text">/\*.*?\*/</code></pre><p>The meaning of the various quantifiers is not otherwise changed, only the
preferred number of matches. Do not confuse this use of question mark with its
use as a quantifier in its own right. As it has two uses, it can sometimes
appear doubled, as in</p><pre><code class="text">\d??\d</code></pre><p>which matches one digit by preference, but can match two if that is the only way
the remaining pattern matches.</p><p>If option <code class="inline">ungreedy</code> is set (an option that is not available in Perl), the
quantifiers are not greedy by default, but individual ones can be made greedy by
following them with a question mark. That is, it inverts the default behavior.</p><p>When a parenthesized subpattern is quantified with a minimum repeat count that
is &gt; 1 or with a limited maximum, more memory is required for the compiled
pattern, in proportion to the size of the minimum or maximum.</p><p>If a pattern starts with .* or .{0,} and option <code class="inline">dotall</code> (equivalent to Perl
option <code class="inline">/s</code>) is set, thus allowing the dot to match newlines, the pattern is
implicitly anchored, because whatever follows is tried against every character
position in the subject string. So, there is no point in retrying the overall
match at any position after the first. PCRE normally treats such a pattern as if
it was preceded by <code class="inline">\A</code>.</p><p>In cases where it is known that the subject string contains no newlines, it is
worth setting <code class="inline">dotall</code> to obtain this optimization, or alternatively using ^ to
indicate anchoring explicitly.</p><p>However, there are some cases where the optimization cannot be used. When .* is
inside capturing parentheses that are the subject of a back reference elsewhere
in the pattern, a match at the start can fail where a later one succeeds.
Consider, for example:</p><pre><code class="text">(.*)abc\1</code></pre><p>If the subject is &quot;xyz123abc123&quot;, the match point is the fourth character.
Therefore, such a pattern is not implicitly anchored.</p><p>Another case where implicit anchoring is not applied is when the leading .* is
inside an atomic group. Once again, a match at the start can fail where a later
one succeeds. Consider the following pattern:</p><pre><code class="text">(?&gt;.*?a)b</code></pre><p>It matches &quot;ab&quot; in the subject &quot;aab&quot;. The use of the backtracking control verbs
(<em>PRUNE) and (</em>SKIP) also disable this optimization.</p><p>When a capturing subpattern is repeated, the value captured is the substring
that matched the final iteration. For example, after</p><pre><code class="text">(tweedle[dume]{3}\s*)+</code></pre><p>has matched &quot;tweedledum tweedledee&quot;, the value of the captured substring is
&quot;tweedledee&quot;. However, if there are nested capturing subpatterns, the
corresponding captured values can have been set in previous iterations. For
example, after</p><pre><code class="text">/(a|(b))+/</code></pre><p>matches &quot;aba&quot;, the value of the second captured substring is &quot;b&quot;.</p><p><a href="" id="sect15"></a></p><h2 id="module-atomic-grouping-and-possessive-quantifiers" class="section-heading">
  <a href="#module-atomic-grouping-and-possessive-quantifiers" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Atomic Grouping and Possessive Quantifiers</span>
</h2>
<p>With both maximizing (&quot;greedy&quot;) and minimizing (&quot;ungreedy&quot; or &quot;lazy&quot;)
repetition, failure of what follows normally causes the repeated item to be
re-evaluated to see if a different number of repeats allows the remaining
pattern to match. Sometimes it is useful to prevent this, either to change the
nature of the match, or to cause it to fail earlier than it otherwise might,
when the author of the pattern knows that there is no point in carrying on.</p><p>Consider, for example, the pattern <code class="inline">\d+foo</code> when applied to the following subject
line:</p><pre><code class="text">123456bar</code></pre><p>After matching all six digits and then failing to match &quot;foo&quot;, the normal action
of the matcher is to try again with only five digits matching item <code class="inline">\d+</code>, and
then with four, and so on, before ultimately failing. &quot;Atomic grouping&quot; (a term
taken from Jeffrey Friedl's book) provides the means for specifying that once a
subpattern has matched, it is not to be re-evaluated in this way.</p><p>If atomic grouping is used for the previous example, the matcher gives up
immediately on failing to match &quot;foo&quot; the first time. The notation is a kind of
special parenthesis, starting with <code class="inline">(?&gt;</code> as in the following example:</p><pre><code class="text">(?&gt;\d+)foo</code></pre><p>This kind of parenthesis &quot;locks up&quot; the part of the pattern it contains once it
has matched, and a failure further into the pattern is prevented from
backtracking into it. Backtracking past it to previous items, however, works as
normal.</p><p>An alternative description is that a subpattern of this type matches the string
of characters that an identical standalone pattern would match, if anchored at
the current point in the subject string.</p><p>Atomic grouping subpatterns are not capturing subpatterns. Simple cases such as
the above example can be thought of as a maximizing repeat that must swallow
everything it can. So, while both <code class="inline">\d+</code> and <code class="inline">\d+?</code> are prepared to adjust the
number of digits they match to make the remaining pattern match, <code class="inline">(?&gt;\d+)</code> can
only match an entire sequence of digits.</p><p>Atomic groups in general can contain any complicated subpatterns, and can be
nested. However, when the subpattern for an atomic group is just a single
repeated item, as in the example above, a simpler notation, called a &quot;possessive
quantifier&quot; can be used. This consists of an extra + character following a
quantifier. Using this notation, the previous example can be rewritten as</p><pre><code class="text">\d++foo</code></pre><p>Notice that a possessive quantifier can be used with an entire group, for
example:</p><pre><code class="text">(abc|xyz){2,3}+</code></pre><p>Possessive quantifiers are always greedy; the setting of option <code class="inline">ungreedy</code> is
ignored. They are a convenient notation for the simpler forms of an atomic
group. However, there is no difference in the meaning of a possessive quantifier
and the equivalent atomic group, but there can be a performance difference;
possessive quantifiers are probably slightly faster.</p><p>The possessive quantifier syntax is an extension to the Perl 5.8 syntax. Jeffrey
Friedl originated the idea (and the name) in the first edition of his book. Mike
McCloskey liked it, so implemented it when he built the Sun Java package, and
PCRE copied it from there. It ultimately found its way into Perl at release
5.10.</p><p>PCRE has an optimization that automatically &quot;possessifies&quot; certain simple
pattern constructs. For example, the sequence A+B is treated as A++B, as there
is no point in backtracking into a sequence of A:s when B must follow.</p><p>When a pattern contains an unlimited repeat inside a subpattern that can itself
be repeated an unlimited number of times, the use of an atomic group is the only
way to avoid some failing matches taking a long time. The pattern</p><pre><code class="text">(\D+|&lt;\d+&gt;)*[!?]</code></pre><p>matches an unlimited number of substrings that either consist of non-digits, or
digits enclosed in <code class="inline">&lt;&gt;</code>, followed by <code class="inline">!</code> or <code class="inline">?</code>. When it matches, it runs quickly.
However, if it is applied to</p><pre><code class="text">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre><p>it takes a long time before reporting failure. This is because the string can be
divided between the internal <code class="inline">\D+</code> repeat and the external * repeat in many
ways, and all must be tried. (The example uses <code class="inline">[!?]</code> rather than a single
character at the end, as both PCRE and Perl have an optimization that allows for
fast failure when a single character is used. They remember the last single
character that is required for a match, and fail early if it is not present in
the string.) If the pattern is changed so that it uses an atomic group, like the
following, sequences of non-digits cannot be broken, and failure happens
quickly:</p><pre><code class="text">((?&gt;\D+)|&lt;\d+&gt;)*[!?]</code></pre><p><a href="" id="sect16"></a></p><h2 id="module-back-references" class="section-heading">
  <a href="#module-back-references" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Back References</span>
</h2>
<p>Outside a character class, a backslash followed by a digit &gt; 0 (and possibly
further digits) is a back reference to a capturing subpattern earlier (that is,
to its left) in the pattern, provided there have been that many previous
capturing left parentheses.</p><p>However, if the decimal number following the backslash is &lt; 10, it is always
taken as a back reference, and causes an error only if there are not that many
capturing left parentheses in the entire pattern. That is, the parentheses that
are referenced do need not be to the left of the reference for numbers &lt; 10. A
&quot;forward back reference&quot; of this type can make sense when a repetition is
involved and the subpattern to the right has participated in an earlier
iteration.</p><p>It is not possible to have a numerical &quot;forward back reference&quot; to a subpattern
whose number is 10 or more using this syntax, as a sequence such as <code class="inline">\50</code> is
interpreted as a character defined in octal. For more details of the handling of
digits following a backslash, see section
<a href="re.html#non_printing_characters">Non-Printing Characters</a> earlier. There is no
such problem when named parentheses are used. A back reference to any subpattern
is possible using named parentheses (see below).</p><p>Another way to avoid the ambiguity inherent in the use of digits following a
backslash is to use the <code class="inline">\g</code> escape sequence. This escape must be followed by an
unsigned number or a negative number, optionally enclosed in braces. The
following examples are identical:</p><pre><code class="text">(ring), \1
(ring), \g1
(ring), \g{1}</code></pre><p>An unsigned number specifies an absolute reference without the ambiguity that is
present in the older syntax. It is also useful when literal digits follow the
reference. A negative number is a relative reference. Consider the following
example:</p><pre><code class="text">(abc(def)ghi)\g{-1}</code></pre><p>The sequence <code class="inline">\g{-1}</code> is a reference to the most recently started capturing
subpattern before <code class="inline">\g</code>, that is, it is equivalent to <code class="inline">\2</code> in this example.
Similarly, <code class="inline">\g{-2}</code> would be equivalent to <code class="inline">\1</code>. The use of relative references
can be helpful in long patterns, and also in patterns that are created by
joining fragments containing references within themselves.</p><p>A back reference matches whatever matched the capturing subpattern in the
current subject string, rather than anything matching the subpattern itself
(section <a href="re.html#sect21">Subpattern as Subroutines</a> describes a way of doing
that). So, the following pattern matches &quot;sense and sensibility&quot; and &quot;response
and responsibility&quot;, but not &quot;sense and responsibility&quot;:</p><pre><code class="text">(sens|respons)e and \1ibility</code></pre><p>If caseful matching is in force at the time of the back reference, the case of
letters is relevant. For example, the following matches &quot;rah rah&quot; and &quot;RAH RAH&quot;,
but not &quot;RAH rah&quot;, although the original capturing subpattern is matched
caselessly:</p><pre><code class="text">((?i)rah)\s+\1</code></pre><p>There are many different ways of writing back references to named subpatterns.
The .NET syntax <code class="inline">\k{name}</code> and the Perl syntax <code class="inline">\k&lt;name&gt;</code> or <code class="inline">\k'name'</code> are
supported, as is the Python syntax <code class="inline">(?P=name)</code>. The unified back reference
syntax in Perl 5.10, in which <code class="inline">\g</code> can be used for both numeric and named
references, is also supported. The previous example can be rewritten in the
following ways:</p><pre><code class="text">(?&lt;p1&gt;(?i)rah)\s+\k&lt;p1&gt;
(?'p1'(?i)rah)\s+\k{p1}
(?P&lt;p1&gt;(?i)rah)\s+(?P=p1)
(?&lt;p1&gt;(?i)rah)\s+\g{p1}</code></pre><p>A subpattern that is referenced by name can appear in the pattern before or
after the reference.</p><p>There can be more than one back reference to the same subpattern. If a
subpattern has not been used in a particular match, any back references to it
always fails. For example, the following pattern always fails if it starts to
match &quot;a&quot; rather than &quot;bc&quot;:</p><pre><code class="text">(a|(bc))\2</code></pre><p>As there can be many capturing parentheses in a pattern, all digits following
the backslash are taken as part of a potential back reference number. If the
pattern continues with a digit character, some delimiter must be used to
terminate the back reference. If option <code class="inline">extended</code> is set, this can be
whitespace. Otherwise an empty comment (see section <a href="re.html#sect19">Comments</a>)
can be used.</p><p><em>Recursive Back References</em></p><p>A back reference that occurs inside the parentheses to which it refers fails
when the subpattern is first used, so, for example, (<code class="inline">a\1</code>) never matches.
However, such references can be useful inside repeated subpatterns. For example,
the following pattern matches any number of &quot;a&quot;s and also &quot;aba&quot;, &quot;ababbaa&quot;, and
so on:</p><pre><code class="text">(a|b\1)+</code></pre><p>At each iteration of the subpattern, the back reference matches the character
string corresponding to the previous iteration. In order for this to work, the
pattern must be such that the first iteration does not need to match the back
reference. This can be done using alternation, as in the example above, or by a
quantifier with a minimum of zero.</p><p>Back references of this type cause the group that they reference to be treated
as an atomic group. Once the whole group has been matched, a subsequent matching
failure cannot cause backtracking into the middle of the group.</p><p><a href="" id="sect17"></a></p><h2 id="module-assertions" class="section-heading">
  <a href="#module-assertions" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Assertions</span>
</h2>
<p>An assertion is a test on the characters following or preceding the current
matching point that does not consume any characters. The simple assertions coded
as <code class="inline">\b</code>, <code class="inline">\B</code>, <code class="inline">\A</code>, <code class="inline">\G</code>, <code class="inline">\Z</code>, <code class="inline">\z</code>, <code class="inline">^</code>, and <code class="inline">$</code> are described in the previous
sections.</p><p>More complicated assertions are coded as subpatterns. There are two kinds: those
that look ahead of the current position in the subject string, and those that
look behind it. An assertion subpattern is matched in the normal way, except
that it does not cause the current matching position to be changed.</p><p>Assertion subpatterns are not capturing subpatterns. If such an assertion
contains capturing subpatterns within it, these are counted for the purposes of
numbering the capturing subpatterns in the whole pattern. However, substring
capturing is done only for positive assertions. (Perl sometimes, but not always,
performs capturing in negative assertions.)</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>If a positive assertion containing one or more capturing subpatterns succeeds,
but failure to match later in the pattern causes backtracking over this
assertion, the captures within the assertion are reset only if no higher
numbered captures are already set. This is, unfortunately, a fundamental
limitation of the current implementation, and as PCRE1 is now in
maintenance-only status, it is unlikely ever to change.</p></section><p>For compatibility with Perl, assertion subpatterns can be repeated. However, it
makes no sense to assert the same thing many times, the side effect of capturing
parentheses can occasionally be useful. In practice, there are only three cases:</p><ul><li>If the quantifier is {0}, the assertion is never obeyed during matching.
However, it can contain internal capturing parenthesized groups that are
called from elsewhere through the subroutine mechanism.</li><li>If quantifier is {0,n}, where n &gt; 0, it is treated as if it was {0,1}. At
runtime, the remaining pattern match is tried with and without the assertion,
the order depends on the greediness of the quantifier.</li><li>If the minimum repetition is &gt; 0, the quantifier is ignored. The assertion is
obeyed only once when encountered during matching.</li></ul><p><em>Lookahead Assertions</em></p><p>Lookahead assertions start with (?= for positive assertions and (?! for
negative assertions. For example, the following matches a word followed by a
semicolon, but does not include the semicolon in the match:</p><pre><code class="text">\w+(?=;)</code></pre><p>The following matches any occurrence of &quot;foo&quot; that is not followed by &quot;bar&quot;:</p><pre><code class="text">foo(?!bar)</code></pre><p>Notice that the apparently similar pattern</p><pre><code class="text">(?!foo)bar</code></pre><p>does not find an occurrence of &quot;bar&quot; that is preceded by something other than
&quot;foo&quot;. It finds any occurrence of &quot;bar&quot; whatsoever, as the assertion (?!foo) is
always true when the next three characters are &quot;bar&quot;. A lookbehind assertion is
needed to achieve the other effect.</p><p>If you want to force a matching failure at some point in a pattern, the most
convenient way to do it is with (?!), as an empty string always matches. So, an
assertion that requires there is not to be an empty string must always fail. The
backtracking control verb (<em>FAIL) or (</em>F) is a synonym for (?!).</p><p><em>Lookbehind Assertions</em></p><p>Lookbehind assertions start with (?&lt;= for positive assertions and (?&lt;! for
negative assertions. For example, the following finds an occurrence of &quot;bar&quot;
that is not preceded by &quot;foo&quot;:</p><pre><code class="text">(?&lt;!foo)bar</code></pre><p>The contents of a lookbehind assertion are restricted such that all the strings
it matches must have a fixed length. However, if there are many top-level
alternatives, they do not all have to have the same fixed length. Thus, the
following is permitted:</p><pre><code class="text">(?&lt;=bullock|donkey)</code></pre><p>The following causes an error at compile time:</p><pre><code class="text">(?&lt;!dogs?|cats?)</code></pre><p>Branches that match different length strings are permitted only at the top-level
of a lookbehind assertion. This is an extension compared with Perl, which
requires all branches to match the same length of string. An assertion such as
the following is not permitted, as its single top-level branch can match two
different lengths:</p><pre><code class="text">(?&lt;=ab(c|de))</code></pre><p>However, it is acceptable to PCRE if rewritten to use two top-level branches:</p><pre><code class="text">(?&lt;=abc|abde)</code></pre><p>Sometimes the escape sequence <code class="inline">\K</code> (see above) can be used instead of a
lookbehind assertion to get round the fixed-length restriction.</p><p>The implementation of lookbehind assertions is, for each alternative, to move
the current position back temporarily by the fixed length and then try to match.
If there are insufficient characters before the current position, the assertion
fails.</p><p>In a UTF mode, PCRE does not allow the <code class="inline">\C</code> escape (which matches a single data
unit even in a UTF mode) to appear in lookbehind assertions, as it makes it
impossible to calculate the length of the lookbehind. The <code class="inline">\X</code> and <code class="inline">\R</code> escapes,
which can match different numbers of data units, are not permitted either.</p><p>&quot;Subroutine&quot; calls (see below), such as (?2) or (?&amp;X), are permitted in
lookbehinds, as long as the subpattern matches a fixed-length string. Recursion,
however, is not supported.</p><p>Possessive quantifiers can be used with lookbehind assertions to specify
efficient matching of fixed-length strings at the end of subject strings.
Consider the following simple pattern when applied to a long string that does
not match:</p><pre><code class="text">abcd$</code></pre><p>As matching proceeds from left to right, PCRE looks for each &quot;a&quot; in the subject
and then sees if what follows matches the remaining pattern. If the pattern is
specified as</p><pre><code class="text">^.*abcd$</code></pre><p>the initial .* matches the entire string at first. However, when this fails (as
there is no following &quot;a&quot;), it backtracks to match all but the last character,
then all but the last two characters, and so on. Once again the search for &quot;a&quot;
covers the entire string, from right to left, so we are no better off. However,
if the pattern is written as</p><pre><code class="text">^.*+(?&lt;=abcd)</code></pre><p>there can be no backtracking for the .*+ item; it can match only the entire
string. The subsequent lookbehind assertion does a single test on the last four
characters. If it fails, the match fails immediately. For long strings, this
approach makes a significant difference to the processing time.</p><p><em>Using Multiple Assertions</em></p><p>Many assertions (of any sort) can occur in succession. For example, the
following matches &quot;foo&quot; preceded by three digits that are not &quot;999&quot;:</p><pre><code class="text">(?&lt;=\d{3})(?&lt;!999)foo</code></pre><p>Notice that each of the assertions is applied independently at the same point in
the subject string. First there is a check that the previous three characters
are all digits, and then there is a check that the same three characters are not
&quot;999&quot;. This pattern does <em>not</em> match &quot;foo&quot; preceded by six characters, the first
of which are digits and the last three of which are not &quot;999&quot;. For example, it
does not match &quot;123abcfoo&quot;. A pattern to do that is the following:</p><pre><code class="text">(?&lt;=\d{3}...)(?&lt;!999)foo</code></pre><p>This time the first assertion looks at the preceding six characters, checks that
the first three are digits, and then the second assertion checks that the
preceding three characters are not &quot;999&quot;.</p><p>Assertions can be nested in any combination. For example, the following matches
an occurrence of &quot;baz&quot; that is preceded by &quot;bar&quot;, which in turn is not preceded
by &quot;foo&quot;:</p><pre><code class="text">(?&lt;=(?&lt;!foo)bar)baz</code></pre><p>The following pattern matches &quot;foo&quot; preceded by three digits and any three
characters that are not &quot;999&quot;:</p><pre><code class="text">(?&lt;=\d{3}(?!999)...)foo</code></pre><p><a href="" id="sect18"></a></p><h2 id="module-conditional-subpatterns" class="section-heading">
  <a href="#module-conditional-subpatterns" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Conditional Subpatterns</span>
</h2>
<p>It is possible to cause the matching process to obey a subpattern conditionally
or to choose between two alternative subpatterns, depending on the result of an
assertion, or whether a specific capturing subpattern has already been matched.
The following are the two possible forms of conditional subpattern:</p><pre><code class="text">(?(condition)yes-pattern)
(?(condition)yes-pattern|no-pattern)</code></pre><p>If the condition is satisfied, the yes-pattern is used, otherwise the no-pattern
(if present). If more than two alternatives exist in the subpattern, a
compile-time error occurs. Each of the two alternatives can itself contain
nested subpatterns of any form, including conditional subpatterns; the
restriction to two alternatives applies only at the level of the condition. The
following pattern fragment is an example where the alternatives are complex:</p><pre><code class="text">(?(1) (A|B|C) | (D | (?(2)E|F) | E) )</code></pre><p>There are four kinds of condition: references to subpatterns, references to
recursion, a pseudo-condition called DEFINE, and assertions.</p><p><em>Checking for a Used Subpattern By Number</em></p><p>If the text between the parentheses consists of a sequence of digits, the
condition is true if a capturing subpattern of that number has previously
matched. If more than one capturing subpattern with the same number exists (see
section <a href="re.html#sect12">Duplicate Subpattern Numbers</a> earlier), the condition is
true if any of them have matched. An alternative notation is to precede the
digits with a plus or minus sign. In this case, the subpattern number is
relative rather than absolute. The most recently opened parentheses can be
referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops,
it can also make sense to refer to subsequent groups. The next parentheses to be
opened can be referenced as (?(+1), and so on. (The value zero in any of these
forms is not used; it provokes a compile-time error.)</p><p>Consider the following pattern, which contains non-significant whitespace to
make it more readable (assume option <code class="inline">extended</code>) and to divide it into three
parts for ease of discussion:</p><pre><code class="text">( \( )?    [^()]+    (?(1) \) )</code></pre><p>The first part matches an optional opening parenthesis, and if that character is
present, sets it as the first captured substring. The second part matches one or
more characters that are not parentheses. The third part is a conditional
subpattern that tests whether the first set of parentheses matched or not. If
they did, that is, if subject started with an opening parenthesis, the condition
is true, and so the yes-pattern is executed and a closing parenthesis is
required. Otherwise, as no-pattern is not present, the subpattern matches
nothing. That is, this pattern matches a sequence of non-parentheses, optionally
enclosed in parentheses.</p><p>If this pattern is embedded in a larger one, a relative reference can be used:</p><pre><code class="text">...other stuff... ( \( )?    [^()]+    (?(-1) \) ) ...</code></pre><p>This makes the fragment independent of the parentheses in the larger pattern.</p><p><em>Checking for a Used Subpattern By Name</em></p><p>Perl uses the syntax (?(&lt;name&gt;)...) or (?('name')...) to test for a used
subpattern by name. For compatibility with earlier versions of PCRE, which had
this facility before Perl, the syntax (?(name)...) is also recognized.</p><p>Rewriting the previous example to use a named subpattern gives:</p><pre><code class="text">(?&lt;OPEN&gt; \( )?    [^()]+    (?(&lt;OPEN&gt;) \) )</code></pre><p>If the name used in a condition of this kind is a duplicate, the test is applied
to all subpatterns of the same name, and is true if any one of them has matched.</p><p><em>Checking for Pattern Recursion</em></p><p>If the condition is the string (R), and there is no subpattern with the name R,
the condition is true if a recursive call to the whole pattern or any subpattern
has been made. If digits or a name preceded by ampersand follow the letter R,
for example:</p><pre><code class="text">(?(R3)...) or (?(R&amp;name)...)</code></pre><p>the condition is true if the most recent recursion is into a subpattern whose
number or name is given. This condition does not check the entire recursion
stack. If the name used in a condition of this kind is a duplicate, the test is
applied to all subpatterns of the same name, and is true if any one of them is
the most recent recursion.</p><p>At &quot;top-level&quot;, all these recursion test conditions are false. The syntax for
recursive patterns is described below.</p><p><em>Defining Subpatterns for Use By Reference Only</em></p><p><a href="" id="defining_subpatterns"></a></p><p>If the condition is the string (DEFINE), and there is no subpattern with the
name DEFINE, the condition is always false. In this case, there can be only one
alternative in the subpattern. It is always skipped if control reaches this
point in the pattern. The idea of DEFINE is that it can be used to define
&quot;subroutines&quot; that can be referenced from elsewhere. (The use of subroutines is
described below.) For example, a pattern to match an IPv4 address, such as
&quot;192.168.23.245&quot;, can be written like this (ignore whitespace and line breaks):</p><pre><code class="text">(?(DEFINE) (?&lt;byte&gt; 2[0-4]\d | 25[0-5] | 1\d\d | [1-9]?\d) ) \b (?&amp;byte) (\.(?&amp;byte)){3} \b</code></pre><p>The first part of the pattern is a DEFINE group inside which is a another group
named &quot;byte&quot; is defined. This matches an individual component of an IPv4 address
(a number &lt; 256). When matching takes place, this part of the pattern is
skipped, as DEFINE acts like a false condition. The remaining pattern uses
references to the named group to match the four dot-separated components of an
IPv4 address, insisting on a word boundary at each end.</p><p><em>Assertion Conditions</em></p><p>If the condition is not in any of the above formats, it must be an assertion.
This can be a positive or negative lookahead or lookbehind assertion. Consider
the following pattern, containing non-significant whitespace, and with the two
alternatives on the second line:</p><pre><code class="text">(?(?=[^a-z]*[a-z])
\d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )</code></pre><p>The condition is a positive lookahead assertion that matches an optional
sequence of non-letters followed by a letter. That is, it tests for the presence
of at least one letter in the subject. If a letter is found, the subject is
matched against the first alternative, otherwise it is matched against the
second. This pattern matches strings in one of the two forms dd-aaa-dd or
dd-dd-dd, where aaa are letters and dd are digits.</p><p><a href="" id="sect19"></a></p><h2 id="module-comments" class="section-heading">
  <a href="#module-comments" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Comments</span>
</h2>
<p>There are two ways to include comments in patterns that are processed by PCRE.
In both cases, the start of the comment must not be in a character class, or in
the middle of any other sequence of related characters such as (?: or a
subpattern name or number. The characters that make up a comment play no part in
the pattern matching.</p><p>The sequence (?# marks the start of a comment that continues up to the next
closing parenthesis. Nested parentheses are not permitted. If option
PCRE_EXTENDED is set, an unescaped # character also introduces a comment, which
in this case continues to immediately after the next newline character or
character sequence in the pattern. Which characters are interpreted as newlines
is controlled by the options passed to a compiling function or by a special
sequence at the start of the pattern, as described in section
<a href="re.html#newline_conventions">Newline Conventions</a> earlier.</p><p>Notice that the end of this type of comment is a literal newline sequence in the
pattern; escape sequences that happen to represent a newline do not count. For
example, consider the following pattern when <code class="inline">extended</code> is set, and the default
newline convention is in force:</p><pre><code class="text">abc #comment \n still comment</code></pre><p>On encountering character #, <code class="inline">pcre_compile()</code> skips along, looking for a newline
in the pattern. The sequence <code class="inline">\n</code> is still literal at this stage, so it does not
terminate the comment. Only a character with code value 0x0a (the default
newline) does so.</p><p><a href="" id="sect20"></a></p><h2 id="module-recursive-patterns" class="section-heading">
  <a href="#module-recursive-patterns" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Recursive Patterns</span>
</h2>
<p>Consider the problem of matching a string in parentheses, allowing for unlimited
nested parentheses. Without the use of recursion, the best that can be done is
to use a pattern that matches up to some fixed depth of nesting. It is not
possible to handle an arbitrary nesting depth.</p><p>For some time, Perl has provided a facility that allows regular expressions to
recurse (among other things). It does this by interpolating Perl code in the
expression at runtime, and the code can refer to the expression itself. A Perl
pattern using code interpolation to solve the parentheses problem can be created
like this:</p><pre><code class="text">$re = qr{\( (?: (?&gt;[^()]+) | (?p{$re}) )* \)}x;</code></pre><p>Item (?p{...}) interpolates Perl code at runtime, and in this case refers
recursively to the pattern in which it appears.</p><p>Obviously, PCRE cannot support the interpolation of Perl code. Instead, it
supports special syntax for recursion of the entire pattern, and for individual
subpattern recursion. After its introduction in PCRE and Python, this kind of
recursion was later introduced into Perl at release 5.10.</p><p>A special item that consists of (? followed by a number &gt; 0 and a closing
parenthesis is a recursive subroutine call of the subpattern of the given
number, if it occurs inside that subpattern. (If not, it is a non-recursive
subroutine call, which is described in the next section.) The special item (?R)
or (?0) is a recursive call of the entire regular expression.</p><p>This PCRE pattern solves the nested parentheses problem (assume that option
<code class="inline">extended</code> is set so that whitespace is ignored):</p><pre><code class="text">\( ( [^()]++ | (?R) )* \)</code></pre><p>First it matches an opening parenthesis. Then it matches any number of
substrings, which can either be a sequence of non-parentheses or a recursive
match of the pattern itself (that is, a correctly parenthesized substring).
Finally there is a closing parenthesis. Notice the use of a possessive
quantifier to avoid backtracking into sequences of non-parentheses.</p><p>If this was part of a larger pattern, you would not want to recurse the entire
pattern, so instead you can use:</p><pre><code class="text">( \( ( [^()]++ | (?1) )* \) )</code></pre><p>The pattern is here within parentheses so that the recursion refers to them
instead of the whole pattern.</p><p>In a larger pattern, keeping track of parenthesis numbers can be tricky. This is
made easier by the use of relative references. Instead of (?1) in the pattern
above, you can write (?-2) to refer to the second most recently opened
parentheses preceding the recursion. That is, a negative number counts capturing
parentheses leftwards from the point at which it is encountered.</p><p>It is also possible to refer to later opened parentheses, by writing references
such as (?+2). However, these cannot be recursive, as the reference is not
inside the parentheses that are referenced. They are always non-recursive
subroutine calls, as described in the next section.</p><p>An alternative approach is to use named parentheses instead. The Perl syntax for
this is (?&amp;name). The earlier PCRE syntax (?P&gt;name) is also supported. We can
rewrite the above example as follows:</p><pre><code class="text">(?&lt;pn&gt; \( ( [^()]++ | (?&amp;pn) )* \) )</code></pre><p>If there is more than one subpattern with the same name, the earliest one is
used.</p><p>This particular example pattern that we have studied contains nested unlimited
repeats, and so the use of a possessive quantifier for matching strings of
non-parentheses is important when applying the pattern to strings that do not
match. For example, when this pattern is applied to</p><pre><code class="text">(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</code></pre><p>it gives &quot;no match&quot; quickly. However, if a possessive quantifier is not used,
the match runs for a long time, as there are so many different ways the + and *
repeats can carve up the subject, and all must be tested before failure can be
reported.</p><p>At the end of a match, the values of capturing parentheses are those from the
outermost level. If the pattern above is matched against</p><pre><code class="text">(ab(cd)ef)</code></pre><p>the value for the inner capturing parentheses (numbered 2) is &quot;ef&quot;, which is the
last value taken on at the top-level. If a capturing subpattern is not matched
at the top level, its final captured value is unset, even if it was
(temporarily) set at a deeper level during the matching process.</p><p>Do not confuse item (?R) with condition (R), which tests for recursion. Consider
the following pattern, which matches text in angle brackets, allowing for
arbitrary nesting. Only digits are allowed in nested brackets (that is, when
recursing), while any characters are permitted at the outer level.</p><pre><code class="text">&lt; (?: (?(R) \d++  | [^&lt;&gt;]*+) | (?R)) * &gt;</code></pre><p>Here (?(R) is the start of a conditional subpattern, with two different
alternatives for the recursive and non-recursive cases. Item (?R) is the actual
recursive call.</p><p><em>Differences in Recursion Processing between PCRE and Perl</em></p><p>Recursion processing in PCRE differs from Perl in two important ways. In PCRE
(like Python, but unlike Perl), a recursive subpattern call is always treated as
an atomic group. That is, once it has matched some of the subject string, it is
never re-entered, even if it contains untried alternatives and there is a
subsequent matching failure. This can be illustrated by the following pattern,
which means to match a palindromic string containing an odd number of characters
(for example, &quot;a&quot;, &quot;aba&quot;, &quot;abcba&quot;, &quot;abcdcba&quot;):</p><pre><code class="text">^(.|(.)(?1)\2)$</code></pre><p>The idea is that it either matches a single character, or two identical
characters surrounding a subpalindrome. In Perl, this pattern works; in PCRE it
does not work if the pattern is longer than three characters. Consider the
subject string &quot;abcba&quot;.</p><p>At the top level, the first character is matched, but as it is not at the end of
the string, the first alternative fails, the second alternative is taken, and
the recursion kicks in. The recursive call to subpattern 1 successfully matches
the next character (&quot;b&quot;). (Notice that the beginning and end of line tests are
not part of the recursion.)</p><p>Back at the top level, the next character (&quot;c&quot;) is compared with what subpattern
2 matched, which was &quot;a&quot;. This fails. As the recursion is treated as an atomic
group, there are now no backtracking points, and so the entire match fails.
(Perl can now re-enter the recursion and try the second alternative.) However,
if the pattern is written with the alternatives in the other order, things are
different:</p><pre><code class="text">^((.)(?1)\2|.)$</code></pre><p>This time, the recursing alternative is tried first, and continues to recurse
until it runs out of characters, at which point the recursion fails. But this
time we have another alternative to try at the higher level. That is the
significant difference: in the previous case the remaining alternative is at a
deeper recursion level, which PCRE cannot use.</p><p>To change the pattern so that it matches all palindromic strings, not only those
with an odd number of characters, it is tempting to change the pattern to this:</p><pre><code class="text">^((.)(?1)\2|.?)$</code></pre><p>Again, this works in Perl, but not in PCRE, and for the same reason. When a
deeper recursion has matched a single character, it cannot be entered again to
match an empty string. The solution is to separate the two cases, and write out
the odd and even cases as alternatives at the higher level:</p><pre><code class="text">^(?:((.)(?1)\2|)|((.)(?3)\4|.))</code></pre><p>If you want to match typical palindromic phrases, the pattern must ignore all
non-word characters, which can be done as follows:</p><pre><code class="text">^\W*+(?:((.)\W*+(?1)\W*+\2|)|((.)\W*+(?3)\W*+\4|\W*+.\W*+))\W*+$</code></pre><p>If run with option <code class="inline">caseless</code>, this pattern matches phrases such as &quot;A man, a
plan, a canal: Panama!&quot; and it works well in both PCRE and Perl. Notice the use
of the possessive quantifier *+ to avoid backtracking into sequences of
non-word characters. Without this, PCRE takes much longer (10 times or more) to
match typical phrases, and Perl takes so long that you think it has gone into a
loop.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The palindrome-matching patterns above work only if the subject string does
not start with a palindrome that is shorter than the entire string. For
example, although &quot;abcba&quot; is correctly matched, if the subject is &quot;ababa&quot;,
PCRE finds palindrome &quot;aba&quot; at the start, and then fails at top level, as the
end of the string does not follow. Once again, it cannot jump back into the
recursion to try other alternatives, so the entire match fails.</p></section><p>The second way in which PCRE and Perl differ in their recursion processing is in
the handling of captured values. In Perl, when a subpattern is called
recursively or as a subpattern (see the next section), it has no access to any
values that were captured outside the recursion. In PCRE these values can be
referenced. Consider the following pattern:</p><pre><code class="text">^(.)(\1|a(?2))</code></pre><p>In PCRE, it matches &quot;bab&quot;. The first capturing parentheses match &quot;b&quot;, then in
the second group, when the back reference <code class="inline">\1</code> fails to match &quot;b&quot;, the second
alternative matches &quot;a&quot;, and then recurses. In the recursion, <code class="inline">\1</code> does now match
&quot;b&quot; and so the whole match succeeds. In Perl, the pattern fails to match because
inside the recursive call <code class="inline">\1</code> cannot access the externally set value.</p><p><a href="" id="sect21"></a></p><h2 id="module-subpatterns-as-subroutines" class="section-heading">
  <a href="#module-subpatterns-as-subroutines" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Subpatterns as Subroutines</span>
</h2>
<p>If the syntax for a recursive subpattern call (either by number or by name) is
used outside the parentheses to which it refers, it operates like a subroutine
in a programming language. The called subpattern can be defined before or after
the reference. A numbered reference can be absolute or relative, as in the
following examples:</p><pre><code class="text">(...(absolute)...)...(?2)...
(...(relative)...)...(?-1)...
(...(?+1)...(relative)...</code></pre><p>An earlier example pointed out that the following pattern matches &quot;sense and
sensibility&quot; and &quot;response and responsibility&quot;, but not &quot;sense and
responsibility&quot;:</p><pre><code class="text">(sens|respons)e and \1ibility</code></pre><p>If instead the following pattern is used, it matches &quot;sense and responsibility&quot;
and the other two strings:</p><pre><code class="text">(sens|respons)e and (?1)ibility</code></pre><p>Another example is provided in the discussion of DEFINE earlier.</p><p>All subroutine calls, recursive or not, are always treated as atomic groups.
That is, once a subroutine has matched some of the subject string, it is never
re-entered, even if it contains untried alternatives and there is a subsequent
matching failure. Any capturing parentheses that are set during the subroutine
call revert to their previous values afterwards.</p><p>Processing options such as case-independence are fixed when a subpattern is
defined, so if it is used as a subroutine, such options cannot be changed for
different calls. For example, the following pattern matches &quot;abcabc&quot; but not
&quot;abcABC&quot;, as the change of processing option does not affect the called
subpattern:</p><pre><code class="text">(abc)(?i:(?-1))</code></pre><p><a href="" id="sect22"></a></p><h2 id="module-oniguruma-subroutine-syntax" class="section-heading">
  <a href="#module-oniguruma-subroutine-syntax" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Oniguruma Subroutine Syntax</span>
</h2>
<p>For compatibility with Oniguruma, the non-Perl syntax <code class="inline">\g</code> followed by a name or
a number enclosed either in angle brackets or single quotes, is alternative
syntax for referencing a subpattern as a subroutine, possibly recursively. Here
follows two of the examples used above, rewritten using this syntax:</p><pre><code class="text">(?&lt;pn&gt; \( ( (?&gt;[^()]+) | \g&lt;pn&gt; )* \) )
(sens|respons)e and \g'1'ibility</code></pre><p>PCRE supports an extension to Oniguruma: if a number is preceded by a plus or
minus sign, it is taken as a relative reference, for example:</p><pre><code class="text">(abc)(?i:\g&lt;-1&gt;)</code></pre><p>Notice that <code class="inline">\g{...}</code> (Perl syntax) and <code class="inline">\g&lt;...&gt;</code> (Oniguruma syntax) are <em>not</em>
synonymous. The former is a back reference; the latter is a subroutine call.</p><p><a href="" id="sect23"></a></p><h2 id="module-backtracking-control" class="section-heading">
  <a href="#module-backtracking-control" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Backtracking Control</span>
</h2>
<p>Perl 5.10 introduced some &quot;Special Backtracking Control Verbs&quot;, which are still
described in the Perl documentation as &quot;experimental and subject to change or
removal in a future version of Perl&quot;. It goes on to say: &quot;Their usage in
production code should be noted to avoid problems during upgrades.&quot; The same
remarks apply to the PCRE features described in this section.</p><p>The new verbs make use of what was previously invalid syntax: an opening
parenthesis followed by an asterisk. They are generally of the form (<em>VERB) or
(</em>VERB:NAME). Some can take either form, possibly behaving differently depending
on whether a name is present. A name is any sequence of characters that does not
include a closing parenthesis. The maximum name length is 255 in the 8-bit
library and 65535 in the 16-bit and 32-bit libraries. If the name is empty, that
is, if the closing parenthesis immediately follows the colon, the effect is as
if the colon was not there. Any number of these verbs can occur in a pattern.</p><p>The behavior of these verbs in repeated groups, assertions, and in subpatterns
called as subroutines (whether or not recursively) is described below.</p><p><em>Optimizations That Affect Backtracking Verbs</em></p><p>PCRE contains some optimizations that are used to speed up matching by running
some checks at the start of each match attempt. For example, it can know the
minimum length of matching subject, or that a particular character must be
present. When one of these optimizations bypasses the running of a match, any
included backtracking verbs are not processed. processed. You can suppress the
start-of-match optimizations by setting option <code class="inline">no_start_optimize</code> when calling
<a href="#compile/2"><code class="inline">compile/2</code></a> or <a href="#run/3"><code class="inline">run/3</code></a>, or by starting the pattern with (*NO_START_OPT).</p><p>Experiments with Perl suggest that it too has similar optimizations, sometimes
leading to anomalous results.</p><p><em>Verbs That Act Immediately</em></p><p>The following verbs act as soon as they are encountered. They must not be
followed by a name.</p><pre><code class="text">(*ACCEPT)</code></pre><p>This verb causes the match to end successfully, skipping the remainder of the
pattern. However, when it is inside a subpattern that is called as a subroutine,
only that subpattern is ended successfully. Matching then continues at the outer
level. If (*ACCEPT) is triggered in a positive assertion, the assertion
succeeds; in a negative assertion, the assertion fails.</p><p>If (*ACCEPT) is inside capturing parentheses, the data so far is captured. For
example, the following matches &quot;AB&quot;, &quot;AAD&quot;, or &quot;ACD&quot;. When it matches &quot;AB&quot;, &quot;B&quot;
is captured by the outer parentheses.</p><pre><code class="text">A((?:A|B(*ACCEPT)|C)D)</code></pre><p>The following verb causes a matching failure, forcing backtracking to occur. It
is equivalent to (?!) but easier to read.</p><pre><code class="text">(*FAIL) or (*F)</code></pre><p>The Perl documentation states that it is probably useful only when combined with
(?{}) or (??{}). Those are Perl features that are not present in PCRE.</p><p>A match with the string &quot;aaaa&quot; always fails, but the callout is taken before
each backtrack occurs (in this example, 10 times).</p><p><em>Recording Which Path Was Taken</em></p><p>The main purpose of this verb is to track how a match was arrived at, although
it also has a secondary use in with advancing the match starting point (see
(*SKIP) below).</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>In Erlang, there is no interface to retrieve a mark with <a href="#run/2"><code class="inline">run/2,3</code></a>,
so only the secondary purpose is relevant to the Erlang programmer.</p><p>The rest of this section is therefore deliberately not adapted for reading by
the Erlang programmer, but the examples can help in understanding NAMES as
they can be used by (*SKIP).</p></section><pre><code class="text">(*MARK:NAME) or (*:NAME)</code></pre><p>A name is always required with this verb. There can be as many instances of
(*MARK) as you like in a pattern, and their names do not have to be unique.</p><p>When a match succeeds, the name of the last encountered (<em>MARK:NAME),
(</em>PRUNE:NAME), or (<em>THEN:NAME) on the matching path is passed back to the caller
as described in section &quot;Extra data for <code class="inline">pcre_exec()</code>&quot; in the <code class="inline">pcreapi</code>
documentation. In the following example of <code class="inline">pcretest</code> output, the /K modifier
requests the retrieval and outputting of (</em>MARK) data:</p><pre><code class="text">re&gt; /X(*MARK:A)Y|X(*MARK:B)Z/K
data&gt; XY
 0: XY
MK: A
XZ
 0: XZ
MK: B</code></pre><p>The (*MARK) name is tagged with &quot;MK:&quot; in this output, and in this example it
indicates which of the two alternatives matched. This is a more efficient way of
obtaining this information than putting each alternative in its own capturing
parentheses.</p><p>If a verb with a name is encountered in a positive assertion that is true, the
name is recorded and passed back if it is the last encountered. This does not
occur for negative assertions or failing positive assertions.</p><p>After a partial match or a failed match, the last encountered name in the entire
match process is returned, for example:</p><pre><code class="text">re&gt; /X(*MARK:A)Y|X(*MARK:B)Z/K
data&gt; XP
No match, mark = B</code></pre><p>Notice that in this unanchored example, the mark is retained from the match
attempt that started at letter &quot;X&quot; in the subject. Subsequent match attempts
starting at &quot;P&quot; and then with an empty string do not get as far as the (*MARK)
item, nevertheless do not reset it.</p><p><em>Verbs That Act after Backtracking</em></p><p>The following verbs do nothing when they are encountered. Matching continues
with what follows, but if there is no subsequent match, causing a backtrack to
the verb, a failure is forced. That is, backtracking cannot pass to the left of
the verb. However, when one of these verbs appears inside an atomic group or an
assertion that is true, its effect is confined to that group, as once the group
has been matched, there is never any backtracking into it. In this situation,
backtracking can &quot;jump back&quot; to the left of the entire atomic group or
assertion. (Remember also, as stated above, that this localization also applies
in subroutine calls.)</p><p>These verbs differ in exactly what kind of failure occurs when backtracking
reaches them. The behavior described below is what occurs when the verb is not
in a subroutine or an assertion. Subsequent sections cover these special cases.</p><p>The following verb, which must not be followed by a name, causes the whole match
to fail outright if there is a later matching failure that causes backtracking
to reach it. Even if the pattern is unanchored, no further attempts to find a
match by advancing the starting point take place.</p><pre><code class="text">(*COMMIT)</code></pre><p>If (*COMMIT) is the only backtracking verb that is encountered, once it has
been passed, <a href="#run/2"><code class="inline">run/2,3</code></a> is committed to find a match at the current
starting point, or not at all, for example:</p><pre><code class="text">a+(*COMMIT)b</code></pre><p>This matches &quot;xxaab&quot; but not &quot;aacaab&quot;. It can be thought of as a kind of dynamic
anchor, or &quot;I've started, so I must finish&quot;. The name of the most recently
passed (<em>MARK) in the path is passed back when (</em>COMMIT) forces a match failure.</p><p>If more than one backtracking verb exists in a pattern, a different one that
follows (<em>COMMIT) can be triggered first, so merely passing (</em>COMMIT) during a
match does not always guarantee that a match must be at this starting point.</p><p>Notice that (*COMMIT) at the start of a pattern is not the same as an anchor,
unless the PCRE start-of-match optimizations are turned off, as shown in the
following example:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="6311523037-1">(</span><span class="s">&quot;xyzabc&quot;</span><span class="p">,</span><span class="s">&quot;(*COMMIT)abc&quot;</span><span class="p">,</span><span class="p" data-group-id="6311523037-2">[</span><span class="p" data-group-id="6311523037-3">{</span><span class="ss">capture</span><span class="p">,</span><span class="ss">all</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="6311523037-3">}</span><span class="p" data-group-id="6311523037-2">]</span><span class="p" data-group-id="6311523037-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="6311523037-4">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="6311523037-5">[</span><span class="s">&quot;abc&quot;</span><span class="p" data-group-id="6311523037-5">]</span><span class="p" data-group-id="6311523037-4">}</span><span class="gp unselectable">
2&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="6311523037-6">(</span><span class="s">&quot;xyzabc&quot;</span><span class="p">,</span><span class="s">&quot;(*COMMIT)abc&quot;</span><span class="p">,</span><span class="p" data-group-id="6311523037-7">[</span><span class="p" data-group-id="6311523037-8">{</span><span class="ss">capture</span><span class="p">,</span><span class="ss">all</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="6311523037-8">}</span><span class="p">,</span><span class="ss">no_start_optimize</span><span class="p" data-group-id="6311523037-7">]</span><span class="p" data-group-id="6311523037-6">)</span><span class="p">.</span><span class="w">
</span><span class="ss">nomatch</span></code></pre><p>For this pattern, PCRE knows that any match must start with &quot;a&quot;, so the
optimization skips along the subject to &quot;a&quot; before applying the pattern to the
first set of data. The match attempt then succeeds. In the second call the
<code class="inline">no_start_optimize</code> disables the optimization that skips along to the first
character. The pattern is now applied starting at &quot;x&quot;, and so the (*COMMIT)
causes the match to fail without trying any other starting points.</p><p>The following verb causes the match to fail at the current starting position in
the subject if there is a later matching failure that causes backtracking to
reach it:</p><pre><code class="text">(*PRUNE) or (*PRUNE:NAME)</code></pre><p>If the pattern is unanchored, the normal &quot;bumpalong&quot; advance to the next
starting character then occurs. Backtracking can occur as usual to the left of
(<em>PRUNE), before it is reached, or when matching to the right of (</em>PRUNE), but
if there is no match to the right, backtracking cannot cross (<em>PRUNE). In simple
cases, the use of (</em>PRUNE) is just an alternative to an atomic group or
possessive quantifier, but there are some uses of (<em>PRUNE) that cannot be
expressed in any other way. In an anchored pattern, (</em>PRUNE) has the same effect
as (*COMMIT).</p><p>The behavior of (<em>PRUNE:NAME) is the not the same as (</em>MARK:NAME)(<em>PRUNE). It is
like (</em>MARK:NAME) in that the name is remembered for passing back to the caller.
However, (<em>SKIP:NAME) searches only for names set with (</em>MARK).</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The fact that (*PRUNE:NAME) remembers the name is useless to the Erlang
programmer, as names cannot be retrieved.</p></section><p>The following verb, when specified without a name, is like (<em>PRUNE), except that
if the pattern is unanchored, the &quot;bumpalong&quot; advance is not to the next
character, but to the position in the subject where (</em>SKIP) was encountered.</p><pre><code class="text">(*SKIP)</code></pre><p>(*SKIP) signifies that whatever text was matched leading up to it cannot be
part of a successful match. Consider:</p><pre><code class="text">a+(*SKIP)b</code></pre><p>If the subject is &quot;aaaac...&quot;, after the first match attempt fails (starting at
the first character in the string), the starting point skips on to start the
next attempt at &quot;c&quot;. Notice that a possessive quantifier does not have the same
effect as this example; although it would suppress backtracking during the first
match attempt, the second attempt would start at the second character instead of
skipping on to &quot;c&quot;.</p><p>When (*SKIP) has an associated name, its behavior is modified:</p><pre><code class="text">(*SKIP:NAME)</code></pre><p>When this is triggered, the previous path through the pattern is searched for
the most recent (<em>MARK) that has the same name. If one is found, the &quot;bumpalong&quot;
advance is to the subject position that corresponds to that (</em>MARK) instead of
to where (<em>SKIP) was encountered. If no (</em>MARK) with a matching name is found,
(*SKIP) is ignored.</p><p>Notice that (<em>SKIP:NAME) searches only for names set by (</em>MARK:NAME). It ignores
names that are set by (<em>PRUNE:NAME) or (</em>THEN:NAME).</p><p>The following verb causes a skip to the next innermost alternative when
backtracking reaches it. That is, it cancels any further backtracking within the
current alternative.</p><pre><code class="text">(*THEN) or (*THEN:NAME)</code></pre><p>The verb name comes from the observation that it can be used for a pattern-based
if-then-else block:</p><pre><code class="text">( COND1 (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ ) ...</code></pre><p>If the COND1 pattern matches, FOO is tried (and possibly further items after the
end of the group if FOO succeeds). On failure, the matcher skips to the second
alternative and tries COND2, without backtracking into COND1. If that succeeds
and BAR fails, COND3 is tried. If BAZ then fails, there are no more
alternatives, so there is a backtrack to whatever came before the entire group.
If (<em>THEN) is not inside an alternation, it acts like (</em>PRUNE).</p><p>The behavior of (<em>THEN:NAME) is the not the same as (</em>MARK:NAME)(<em>THEN). It is
like (</em>MARK:NAME) in that the name is remembered for passing back to the caller.
However, (<em>SKIP:NAME) searches only for names set with (</em>MARK).</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The fact that (*THEN:NAME) remembers the name is useless to the Erlang
programmer, as names cannot be retrieved.</p></section><p>A subpattern that does not contain a | character is just a part of the enclosing
alternative; it is not a nested alternation with only one alternative. The
effect of (*THEN) extends beyond such a subpattern to the enclosing
alternative. Consider the following pattern, where A, B, and so on, are complex
pattern fragments that do not contain any | characters at this level:</p><pre><code class="text">A (B(*THEN)C) | D</code></pre><p>If A and B are matched, but there is a failure in C, matching does not backtrack
into A; instead it moves to the next alternative, that is, D. However, if the
subpattern containing (*THEN) is given an alternative, it behaves differently:</p><pre><code class="text">A (B(*THEN)C | (*FAIL)) | D</code></pre><p>The effect of (<em>THEN) is now confined to the inner subpattern. After a failure
in C, matching moves to (</em>FAIL), which causes the whole subpattern to fail, as
there are no more alternatives to try. In this case, matching does now backtrack
into A.</p><p>Notice that a conditional subpattern is not considered as having two
alternatives, as only one is ever used. That is, the | character in a
conditional subpattern has a different meaning. Ignoring whitespace, consider:</p><pre><code class="text">^.*? (?(?=a) a | b(*THEN)c )</code></pre><p>If the subject is &quot;ba&quot;, this pattern does not match. As .<em>? is ungreedy, it
initially matches zero characters. The condition (?=a) then fails, the character
&quot;b&quot; is matched, but &quot;c&quot; is not. At this point, matching does not backtrack to
.</em>? as can perhaps be expected from the presence of the | character. The
conditional subpattern is part of the single alternative that comprises the
whole pattern, and so the match fails. (If there was a backtrack into .*?,
allowing it to match &quot;b&quot;, the match would succeed.)</p><p>The verbs described above provide four different &quot;strengths&quot; of control when
subsequent matching fails:</p><ul><li>(*THEN) is the weakest, carrying on the match at the next alternative.</li><li>(*PRUNE) comes next, fails the match at the current starting position, but
allows an advance to the next character (for an unanchored pattern).</li><li>(*SKIP) is similar, except that the advance can be more than one character.</li><li>(*COMMIT) is the strongest, causing the entire match to fail.</li></ul><p><em>More than One Backtracking Verb</em></p><p>If more than one backtracking verb is present in a pattern, the one that is
backtracked onto first acts. For example, consider the following pattern, where
A, B, and so on, are complex pattern fragments:</p><pre><code class="text">(A(*COMMIT)B(*THEN)C|ABD)</code></pre><p>If A matches but B fails, the backtrack to (<em>COMMIT) causes the entire match to
fail. However, if A and B match, but C fails, the backtrack to (</em>THEN) causes
the next alternative (ABD) to be tried. This behavior is consistent, but is not
always the same as in Perl. It means that if two or more backtracking verbs
appear in succession, the last of them has no effect. Consider the following
example:</p><pre><code class="text">...(*COMMIT)(*PRUNE)...</code></pre><p>If there is a matching failure to the right, backtracking onto (<em>PRUNE) causes
it to be triggered, and its action is taken. There can never be a backtrack onto
(</em>COMMIT).</p><p><em>Backtracking Verbs in Repeated Groups</em></p><p>PCRE differs from Perl in its handling of backtracking verbs in repeated groups.
For example, consider:</p><pre><code class="text">/(a(*COMMIT)b)+ac/</code></pre><p>If the subject is &quot;abac&quot;, Perl matches, but PCRE fails because the (*COMMIT) in
the second repeat of the group acts.</p><p><em>Backtracking Verbs in Assertions</em></p><p>(*FAIL) in an assertion has its normal effect: it forces an immediate
backtrack.</p><p>(<em>ACCEPT) in a positive assertion causes the assertion to succeed without any
further processing. In a negative assertion, (</em>ACCEPT) causes the assertion to
fail without any further processing.</p><p>The other backtracking verbs are not treated specially if they appear in a
positive assertion. In particular, (*THEN) skips to the next alternative in the
innermost enclosing group that has alternations, regardless if this is within
the assertion.</p><p>Negative assertions are, however, different, to ensure that changing a positive
assertion into a negative assertion changes its result. Backtracking into
(<em>COMMIT), (</em>SKIP), or (<em>PRUNE) causes a negative assertion to be true, without
considering any further alternative branches in the assertion. Backtracking into
(</em>THEN) causes it to skip to the next enclosing alternative within the assertion
(the normal behavior), but if the assertion does not have such an alternative,
(<em>THEN) behaves like (</em>PRUNE).</p><p><em>Backtracking Verbs in Subroutines</em></p><p>These behaviors occur regardless if the subpattern is called recursively. The
treatment of subroutines in Perl is different in some cases.</p><ul><li>(*FAIL) in a subpattern called as a subroutine has its normal effect: it
forces an immediate backtrack.</li><li>(*ACCEPT) in a subpattern called as a subroutine causes the subroutine match
to succeed without any further processing. Matching then continues after the
subroutine call.</li><li>(<em>COMMIT), (</em>SKIP), and (*PRUNE) in a subpattern called as a subroutine cause
the subroutine match to fail.</li><li>(<em>THEN) skips to the next alternative in the innermost enclosing group within
the subpattern that has alternatives. If there is no such group within the
subpattern, (</em>THEN) causes the subroutine match to fail.</li></ul>
    </section>

</div>

  <section id="summary" class="details-list">
    <h1 class="section-heading">
      <a class="hover-link" href="#summary">
        <i class="ri-link-m" aria-hidden="true"></i>
      </a>
      <span class="text">Summary</span>
    </h1>
<div class="summary-types summary">
  <h2>
    <a href="#types">Types</a>
  </h2>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:capture/0" data-no-tooltip="" translate="no">capture()</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:compile_option/0" data-no-tooltip="" translate="no">compile_option()</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:compile_options/0" data-no-tooltip="" translate="no">compile_options()</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:mp/0" data-no-tooltip="" translate="no">mp()</a>

      </div>

        <div class="summary-synopsis"><p>Opaque data type containing a compiled regular expression.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:nl_spec/0" data-no-tooltip="" translate="no">nl_spec()</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:option/0" data-no-tooltip="" translate="no">option()</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:options/0" data-no-tooltip="" translate="no">options()</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:replace_fun/0" data-no-tooltip="" translate="no">replace_fun()</a>

      </div>

    </div>

</div>
<div class="summary-functions summary">
  <h2>
    <a href="#functions">Functions</a>
  </h2>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#compile/1" data-no-tooltip="" translate="no">compile(Regexp)</a>

      </div>

        <div class="summary-synopsis"><p>The same as <a href="#compile/2"><code class="inline">compile(Regexp,[])</code></a></p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#compile/2" data-no-tooltip="" translate="no">compile(Regexp, Options)</a>

      </div>

        <div class="summary-synopsis"><p>Compiles a regular expression, with the syntax described below, into an internal
format to be used later as a parameter to <a href="#run/2"><code class="inline">run/2</code></a> and <a href="#run/3"><code class="inline">run/3</code></a>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#inspect/2" data-no-tooltip="" translate="no">inspect(MP, Item)</a>

      </div>

        <div class="summary-synopsis"><p>Takes a compiled regular expression and an item, and returns the relevant data
from the regular expression.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#replace/3" data-no-tooltip="" translate="no">replace(Subject, RE, Replacement)</a>

      </div>

        <div class="summary-synopsis"><p>Equivalent to <a href="#replace/4"><code class="inline">replace(Subject, RE, Replacement, [])</code></a>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#replace/4" data-no-tooltip="" translate="no">replace(Subject, RE, Replacement, Options)</a>

      </div>

        <div class="summary-synopsis"><p>Replaces the matched part of the <code class="inline">Subject</code> string with <code class="inline">Replacement</code>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#run/2" data-no-tooltip="" translate="no">run(Subject, RE)</a>

      </div>

        <div class="summary-synopsis"><p>Equivalent to <a href="#run/3"><code class="inline">run(Subject, RE, [])</code></a>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#run/3" data-no-tooltip="" translate="no">run(Subject, RE, Options)</a>

      </div>

        <div class="summary-synopsis"><p>Executes a regular expression matching, and returns <code class="inline">match/{match, Captured}</code> or
<code class="inline">nomatch</code>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#split/2" data-no-tooltip="" translate="no">split(Subject, RE)</a>

      </div>

        <div class="summary-synopsis"><p>Equivalent to <a href="#split/3"><code class="inline">split(Subject, RE, [])</code></a>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#split/3" data-no-tooltip="" translate="no">split(Subject, RE, Options)</a>

      </div>

        <div class="summary-synopsis"><p>Splits the input into parts by finding tokens according to the regular
expression supplied.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#version/0" data-no-tooltip="" translate="no">version()</a>

      </div>

        <div class="summary-synopsis"><p>The return of this function is a string with the PCRE version of the system that
was used in the Erlang/OTP compilation.</p></div>

    </div>

</div>

  </section>


  <section id="types" class="details-list">
    <h1 class="section-heading">
      <a class="hover-link" href="#types">
        <i class="ri-link-m" aria-hidden="true"></i>
      </a>
      <span class="text">Types</span>
    </h1>
    <div class="types-list">
<section class="detail" id="t:capture/0">

  <div class="detail-header">
    <a href="#t:capture/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">capture()</h1>

        <span class="note">(not exported)</span>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L55" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> capture() ::
          all | all_but_first | all_names | first | none |
          (ValueList :: [<a href="../../apps/erts/erlang.html#t:integer/0">integer</a>() | <a href="../../apps/erts/erlang.html#t:string/0">string</a>() | <a href="../../apps/erts/erlang.html#t:atom/0">atom</a>()]).</pre>

      </div>


  </section>
</section>
<section class="detail" id="t:compile_option/0">

  <div class="detail-header">
    <a href="#t:compile_option/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">compile_option()</h1>

        <span class="note">(not exported)</span>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L38" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> compile_option() ::
          unicode | anchored | caseless | dollar_endonly | dotall | extended | firstline | multiline |
          no_auto_capture | dupnames | ungreedy |
          {newline, <a href="#t:nl_spec/0">nl_spec</a>()} |
          bsr_anycrlf | bsr_unicode | no_start_optimize | ucp | never_utf.</pre>

      </div>


  </section>
</section>
<section class="detail" id="t:compile_options/0">

  <div class="detail-header">
    <a href="#t:compile_options/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">compile_options()</h1>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L37" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> compile_options() :: [<a href="#t:compile_option/0">compile_option</a>()].</pre>

      </div>


  </section>
</section>
<section class="detail" id="t:mp/0">

  <div class="detail-header">
    <a href="#t:mp/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">mp()</h1>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L33" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> mp() :: {re_pattern, _, _, _, _}.</pre>

      </div>

<p>Opaque data type containing a compiled regular expression.</p><p><a href="#t:mp/0"><code class="inline">mp/0</code></a> is guaranteed to be a tuple() having the atom <code class="inline">re_pattern</code> as its first element, to
allow for matching in guards. The arity of the tuple or the content of the other
fields can change in future Erlang/OTP releases.</p>
  </section>
</section>
<section class="detail" id="t:nl_spec/0">

  <div class="detail-header">
    <a href="#t:nl_spec/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">nl_spec()</h1>

        <span class="note">(not exported)</span>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L35" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> nl_spec() :: cr | crlf | lf | anycrlf | any.</pre>

      </div>


  </section>
</section>
<section class="detail" id="t:option/0">

  <div class="detail-header">
    <a href="#t:option/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">option()</h1>

        <span class="note">(not exported)</span>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L46" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> option() ::
          anchored | global | notbol | noteol | notempty | notempty_atstart | report_errors |
          {offset, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
          {match_limit, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
          {match_limit_recursion, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
          {newline, NLSpec :: <a href="#t:nl_spec/0">nl_spec</a>()} |
          bsr_anycrlf | bsr_unicode |
          {capture, ValueSpec :: <a href="#t:capture/0">capture</a>()} |
          {capture, ValueSpec :: <a href="#t:capture/0">capture</a>(), Type :: index | list | binary} |
          <a href="#t:compile_option/0">compile_option</a>().</pre>

      </div>


  </section>
</section>
<section class="detail" id="t:options/0">

  <div class="detail-header">
    <a href="#t:options/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">options()</h1>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L45" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> options() :: [<a href="#t:option/0">option</a>()].</pre>

      </div>


  </section>
</section>
<section class="detail" id="t:replace_fun/0">

  <div class="detail-header">
    <a href="#t:replace_fun/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">replace_fun()</h1>

        <span class="note">(not exported)</span>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L58" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-type</span> replace_fun() :: fun((<a href="../../apps/erts/erlang.html#t:binary/0">binary</a>(), [<a href="../../apps/erts/erlang.html#t:binary/0">binary</a>()]) -> <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>()).</pre>

      </div>


  </section>
</section>

    </div>
  </section>

  <section id="functions" class="details-list">
    <h1 class="section-heading">
      <a class="hover-link" href="#functions">
        <i class="ri-link-m" aria-hidden="true"></i>
      </a>
      <span class="text">Functions</span>
    </h1>
    <div class="functions-list">
<section class="detail" id="compile/1">

  <div class="detail-header">
    <a href="#compile/1" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">compile(Regexp)</h1>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L86" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> compile(Regexp) -> {ok, MP} | {error, ErrSpec}
                 when
                     Regexp :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>(),
                     MP :: <a href="#t:mp/0">mp</a>(),
                     ErrSpec :: {ErrString :: <a href="../../apps/erts/erlang.html#t:string/0">string</a>(), Position :: <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()}.</pre>

      </div>

<p>The same as <a href="#compile/2"><code class="inline">compile(Regexp,[])</code></a></p>
  </section>
</section>
<section class="detail" id="compile/2">

  <div class="detail-header">
    <a href="#compile/2" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">compile(Regexp, Options)</h1>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L236" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> compile(Regexp, Options) -> {ok, MP} | {error, ErrSpec}
                 when
                     Regexp :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                     Options :: [Option],
                     Option :: <a href="#t:compile_option/0">compile_option</a>(),
                     MP :: <a href="#t:mp/0">mp</a>(),
                     ErrSpec :: {ErrString :: <a href="../../apps/erts/erlang.html#t:string/0">string</a>(), Position :: <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()}.</pre>

      </div>

<p>Compiles a regular expression, with the syntax described below, into an internal
format to be used later as a parameter to <a href="#run/2"><code class="inline">run/2</code></a> and <a href="#run/3"><code class="inline">run/3</code></a>.</p><p>Compiling the regular expression before matching is useful if the same
expression is to be used in matching against multiple subjects during the
lifetime of the program. Compiling once and executing many times is far more
efficient than compiling each time one wants to match.</p><p>When option <code class="inline">unicode</code> is specified, the regular expression is to be specified as
a valid Unicode <code class="inline">charlist()</code>, otherwise as any valid <a href="../../apps/erts/erlang.html#t:iodata/0"><code class="inline">iodata/0</code></a>.</p><p><a href="" id="compile_options"></a></p><p>Options:</p><ul><li><p><strong><code class="inline">unicode</code></strong> - The regular expression is specified as a Unicode <code class="inline">charlist()</code>
and the resulting regular expression code is to be run against a valid Unicode
<code class="inline">charlist()</code> subject. Also consider option <code class="inline">ucp</code> when using Unicode
characters.</p></li><li><p><strong><code class="inline">anchored</code></strong> - The pattern is forced to be &quot;anchored&quot;, that is, it is
constrained to match only at the first matching point in the string that is
searched (the &quot;subject string&quot;). This effect can also be achieved by
appropriate constructs in the pattern itself.</p></li><li><p><strong><code class="inline">caseless</code></strong> - Letters in the pattern match both uppercase and lowercase
letters. It is equivalent to Perl option <code class="inline">/i</code> and can be changed within a
pattern by a <code class="inline">(?i)</code> option setting. Uppercase and lowercase letters are
defined as in the ISO 8859-1 character set.</p></li><li><p><strong><code class="inline">dollar_endonly</code></strong> - A dollar metacharacter in the pattern matches only at
the end of the subject string. Without this option, a dollar also matches
immediately before a newline at the end of the string (but not before any
other newlines). This option is ignored if option <code class="inline">multiline</code> is specified.
There is no equivalent option in Perl, and it cannot be set within a pattern.</p></li><li><p><strong><code class="inline">dotall</code></strong> - A dot in the pattern matches all characters, including those
indicating newline. Without it, a dot does not match when the current position
is at a newline. This option is equivalent to Perl option <code class="inline">/s</code> and it can be
changed within a pattern by a <code class="inline">(?s)</code> option setting. A negative class, such as
<code class="inline">[^a]</code>, always matches newline characters, independent of the setting of this
option.</p></li><li><p><strong><code class="inline">extended</code></strong> - If this option is set, most white space characters in the
pattern are totally ignored except when escaped or inside a character class.
However, white space is not allowed within sequences such as <code class="inline">(?&gt;</code> that
introduce various parenthesized subpatterns, nor within a numerical quantifier
such as <code class="inline">{1,3}</code>. However, ignorable white space is permitted between an item
and a following quantifier and between a quantifier and a following + that
indicates possessiveness.</p><p>White space did not used to include the VT character (code 11), because Perl
did not treat this character as white space. However, Perl changed at release
5.18, so PCRE followed at release 8.34, and VT is now treated as white space.</p><p>This also causes characters between an unescaped # outside a character class
and the next newline, inclusive, to be ignored. This is equivalent to Perl's
<code class="inline">/x</code> option, and it can be changed within a pattern by a <code class="inline">(?x)</code> option
setting.</p><p>With this option, comments inside complicated patterns can be included.
However, notice that this applies only to data characters. Whitespace
characters can never appear within special character sequences in a pattern,
for example within sequence <code class="inline">(?(</code> that introduces a conditional subpattern.</p></li><li><p><strong><code class="inline">firstline</code></strong> - An unanchored pattern is required to match before or at the
first newline in the subject string, although the matched text can continue
over the newline.</p></li><li><p><strong><code class="inline">multiline</code></strong> - By default, PCRE treats the subject string as consisting of
a single line of characters (even if it contains newlines). The &quot;start of
line&quot; metacharacter (<code class="inline">^</code>) matches only at the start of the string, while the
&quot;end of line&quot; metacharacter (<code class="inline">$</code>) matches only at the end of the string, or
before a terminating newline (unless option <code class="inline">dollar_endonly</code> is specified).
This is the same as in Perl.</p><p>When this option is specified, the &quot;start of line&quot; and &quot;end of line&quot;
constructs match immediately following or immediately before internal newlines
in the subject string, respectively, as well as at the very start and end.
This is equivalent to Perl option <code class="inline">/m</code> and can be changed within a pattern by
a <code class="inline">(?m)</code> option setting. If there are no newlines in a subject string, or no
occurrences of <code class="inline">^</code> or <code class="inline">$</code> in a pattern, setting <code class="inline">multiline</code> has no effect.</p></li><li><p><strong><code class="inline">no_auto_capture</code></strong> - Disables the use of numbered capturing parentheses in
the pattern. Any opening parenthesis that is not followed by <code class="inline">?</code> behaves as if
it is followed by <code class="inline">?:</code>. Named parentheses can still be used for capturing (and
they acquire numbers in the usual way). There is no equivalent option in Perl.</p></li><li><p><strong><code class="inline">dupnames</code></strong> - Names used to identify capturing subpatterns need not be
unique. This can be helpful for certain types of pattern when it is known that
only one instance of the named subpattern can ever be matched. More details of
named subpatterns are provided below.</p></li><li><p><strong><code class="inline">ungreedy</code></strong> - Inverts the &quot;greediness&quot; of the quantifiers so that they are
not greedy by default, but become greedy if followed by &quot;?&quot;. It is not
compatible with Perl. It can also be set by a <code class="inline">(?U)</code> option setting within the
pattern.</p></li><li><p><strong><code class="inline">{newline, NLSpec}</code></strong> - Overrides the default definition of a newline in the
subject string, which is LF (ASCII 10) in Erlang.</p><ul><li><p><strong><code class="inline">cr</code></strong> - Newline is indicated by a single character <code class="inline">cr</code> (ASCII 13).</p></li><li><p><strong><code class="inline">lf</code></strong> - Newline is indicated by a single character LF (ASCII 10), the
default.</p></li><li><p><strong><code class="inline">crlf</code></strong> - Newline is indicated by the two-character CRLF (ASCII 13
followed by ASCII 10) sequence.</p></li><li><p><strong><code class="inline">anycrlf</code></strong> - Any of the three preceding sequences is to be recognized.</p></li><li><p><strong><code class="inline">any</code></strong> - Any of the newline sequences above, and the Unicode sequences VT
(vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS
(line separator, U+2028), and PS (paragraph separator, U+2029).</p></li></ul></li><li><p><strong><code class="inline">bsr_anycrlf</code></strong> - Specifies specifically that \R is to match only the CR,
LF, or CRLF sequences, not the Unicode-specific newline characters.</p></li><li><p><strong><code class="inline">bsr_unicode</code></strong> - Specifies specifically that \R is to match all the
Unicode newline characters (including CRLF, and so on, the default).</p></li><li><p><strong><code class="inline">no_start_optimize</code></strong> - Disables optimization that can malfunction if
&quot;Special start-of-pattern items&quot; are present in the regular expression. A
typical example would be when matching &quot;DEFABC&quot; against &quot;(<em>COMMIT)ABC&quot;, where
the start optimization of PCRE would skip the subject up to &quot;A&quot; and never
realize that the (</em>COMMIT) instruction is to have made the matching fail. This
option is only relevant if you use &quot;start-of-pattern items&quot;, as discussed in
section <a href="re.html#module-pcre-regular-expression-details">PCRE Regular Expression Details</a>.</p></li><li><p><strong><code class="inline">ucp</code></strong> - Specifies that Unicode character properties are to be used when
resolving \B, \b, \D, \d, \S, \s, \W and \w. Without this flag, only
ISO Latin-1 properties are used. Using Unicode properties hurts performance,
but is semantically correct when working with Unicode characters beyond the
ISO Latin-1 range.</p></li><li><p><strong><code class="inline">never_utf</code></strong> - Specifies that the (<em>UTF) and/or (</em>UTF8) &quot;start-of-pattern
items&quot; are forbidden. This flag cannot be combined with option <code class="inline">unicode</code>.
Useful if ISO Latin-1 patterns from an external source are to be compiled.</p></li></ul>
  </section>
</section>
<section class="detail" id="inspect/2">

  <div class="detail-header">
    <a href="#inspect/2" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">inspect(MP, Item)</h1>

        <span class="note">(since OTP 17.0)</span>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L869" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> inspect(MP, Item) -> {namelist, [<a href="../../apps/erts/erlang.html#t:binary/0">binary</a>()]} when MP :: <a href="#t:mp/0">mp</a>(), Item :: namelist.</pre>

      </div>

<p>Takes a compiled regular expression and an item, and returns the relevant data
from the regular expression.</p><p>The only supported item is <code class="inline">namelist</code>, which returns the tuple <code class="inline">{namelist, [binary()]}</code>,
containing the names of all (unique) named subpatterns in the regular expression.</p><p>For example:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="6431882534-1">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">MP</span><span class="p" data-group-id="6431882534-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">re</span><span class="p">:</span><span class="nf">compile</span><span class="p" data-group-id="6431882534-2">(</span><span class="s">&quot;(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;</span><span class="p" data-group-id="6431882534-2">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="6431882534-3">{</span><span class="ss">ok</span><span class="p">,</span><span class="p" data-group-id="6431882534-4">{</span><span class="ss">re_pattern</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w">
                </span><span class="p" data-group-id="6431882534-5">&lt;&lt;</span><span class="mi">69</span><span class="p">,</span><span class="mi">82</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">119</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="w">
                  </span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="6431882534-5">&gt;&gt;</span><span class="p" data-group-id="6431882534-4">}</span><span class="p" data-group-id="6431882534-3">}</span><span class="gp unselectable">
2&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">inspect</span><span class="p" data-group-id="6431882534-6">(</span><span class="n">MP</span><span class="p">,</span><span class="ss">namelist</span><span class="p" data-group-id="6431882534-6">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="6431882534-7">{</span><span class="ss">namelist</span><span class="p">,</span><span class="p" data-group-id="6431882534-8">[</span><span class="p" data-group-id="6431882534-9">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="6431882534-9">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="6431882534-10">&lt;&lt;</span><span class="s">&quot;B&quot;</span><span class="p" data-group-id="6431882534-10">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="6431882534-11">&lt;&lt;</span><span class="s">&quot;C&quot;</span><span class="p" data-group-id="6431882534-11">&gt;&gt;</span><span class="p" data-group-id="6431882534-8">]</span><span class="p" data-group-id="6431882534-7">}</span><span class="gp unselectable">
3&gt; </span><span class="p" data-group-id="6431882534-12">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">MPD</span><span class="p" data-group-id="6431882534-12">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">re</span><span class="p">:</span><span class="nf">compile</span><span class="p" data-group-id="6431882534-13">(</span><span class="s">&quot;(?&lt;C&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;</span><span class="p">,</span><span class="p" data-group-id="6431882534-14">[</span><span class="ss">dupnames</span><span class="p" data-group-id="6431882534-14">]</span><span class="p" data-group-id="6431882534-13">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="6431882534-15">{</span><span class="ss">ok</span><span class="p">,</span><span class="p" data-group-id="6431882534-16">{</span><span class="ss">re_pattern</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w">
                </span><span class="p" data-group-id="6431882534-17">&lt;&lt;</span><span class="mi">69</span><span class="p">,</span><span class="mi">82</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">119</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="w">
                  </span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="6431882534-17">&gt;&gt;</span><span class="p" data-group-id="6431882534-16">}</span><span class="p" data-group-id="6431882534-15">}</span><span class="gp unselectable">
4&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">inspect</span><span class="p" data-group-id="6431882534-18">(</span><span class="n">MPD</span><span class="p">,</span><span class="ss">namelist</span><span class="p" data-group-id="6431882534-18">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="6431882534-19">{</span><span class="ss">namelist</span><span class="p">,</span><span class="p" data-group-id="6431882534-20">[</span><span class="p" data-group-id="6431882534-21">&lt;&lt;</span><span class="s">&quot;B&quot;</span><span class="p" data-group-id="6431882534-21">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="6431882534-22">&lt;&lt;</span><span class="s">&quot;C&quot;</span><span class="p" data-group-id="6431882534-22">&gt;&gt;</span><span class="p" data-group-id="6431882534-20">]</span><span class="p" data-group-id="6431882534-19">}</span></code></pre><p>Notice in the second example that the duplicate name only occurs once in the
returned list, and that the list is in alphabetical order regardless of where
the names are positioned in the regular expression. The order of the names is
the same as the order of captured subexpressions if <code class="inline">{capture, all_names}</code> is
specified as an option to <a href="#run/3"><code class="inline">run/3</code></a>. You can therefore create a name-to-value
mapping from the result of <a href="#run/3"><code class="inline">run/3</code></a> like this:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="2604929518-1">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">MP</span><span class="p" data-group-id="2604929518-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">re</span><span class="p">:</span><span class="nf">compile</span><span class="p" data-group-id="2604929518-2">(</span><span class="s">&quot;(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;</span><span class="p" data-group-id="2604929518-2">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2604929518-3">{</span><span class="ss">ok</span><span class="p">,</span><span class="p" data-group-id="2604929518-4">{</span><span class="ss">re_pattern</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w">
                </span><span class="p" data-group-id="2604929518-5">&lt;&lt;</span><span class="mi">69</span><span class="p">,</span><span class="mi">82</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">119</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="w">
                  </span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="2604929518-5">&gt;&gt;</span><span class="p" data-group-id="2604929518-4">}</span><span class="p" data-group-id="2604929518-3">}</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="2604929518-6">{</span><span class="ss">namelist</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p" data-group-id="2604929518-6">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">re</span><span class="p">:</span><span class="nf">inspect</span><span class="p" data-group-id="2604929518-7">(</span><span class="n">MP</span><span class="p">,</span><span class="ss">namelist</span><span class="p" data-group-id="2604929518-7">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2604929518-8">{</span><span class="ss">namelist</span><span class="p">,</span><span class="p" data-group-id="2604929518-9">[</span><span class="p" data-group-id="2604929518-10">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="2604929518-10">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="2604929518-11">&lt;&lt;</span><span class="s">&quot;B&quot;</span><span class="p" data-group-id="2604929518-11">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="2604929518-12">&lt;&lt;</span><span class="s">&quot;C&quot;</span><span class="p" data-group-id="2604929518-12">&gt;&gt;</span><span class="p" data-group-id="2604929518-9">]</span><span class="p" data-group-id="2604929518-8">}</span><span class="gp unselectable">
3&gt; </span><span class="p" data-group-id="2604929518-13">{</span><span class="ss">match</span><span class="p">,</span><span class="n">L</span><span class="p" data-group-id="2604929518-13">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="2604929518-14">(</span><span class="s">&quot;AA&quot;</span><span class="p">,</span><span class="n">MP</span><span class="p">,</span><span class="p" data-group-id="2604929518-15">[</span><span class="p" data-group-id="2604929518-16">{</span><span class="ss">capture</span><span class="p">,</span><span class="ss">all_names</span><span class="p">,</span><span class="ss">binary</span><span class="p" data-group-id="2604929518-16">}</span><span class="p" data-group-id="2604929518-15">]</span><span class="p" data-group-id="2604929518-14">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2604929518-17">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="2604929518-18">[</span><span class="p" data-group-id="2604929518-19">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="2604929518-19">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="2604929518-20">&lt;&lt;</span><span class="p" data-group-id="2604929518-20">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="2604929518-21">&lt;&lt;</span><span class="p" data-group-id="2604929518-21">&gt;&gt;</span><span class="p" data-group-id="2604929518-18">]</span><span class="p" data-group-id="2604929518-17">}</span><span class="gp unselectable">
4&gt; </span><span class="n">NameMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">lists</span><span class="p">:</span><span class="nf">zip</span><span class="p" data-group-id="2604929518-22">(</span><span class="n">N</span><span class="p">,</span><span class="n">L</span><span class="p" data-group-id="2604929518-22">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2604929518-23">[</span><span class="p" data-group-id="2604929518-24">{</span><span class="p" data-group-id="2604929518-25">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="2604929518-25">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="2604929518-26">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="2604929518-26">&gt;&gt;</span><span class="p" data-group-id="2604929518-24">}</span><span class="p">,</span><span class="p" data-group-id="2604929518-27">{</span><span class="p" data-group-id="2604929518-28">&lt;&lt;</span><span class="s">&quot;B&quot;</span><span class="p" data-group-id="2604929518-28">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="2604929518-29">&lt;&lt;</span><span class="p" data-group-id="2604929518-29">&gt;&gt;</span><span class="p" data-group-id="2604929518-27">}</span><span class="p">,</span><span class="p" data-group-id="2604929518-30">{</span><span class="p" data-group-id="2604929518-31">&lt;&lt;</span><span class="s">&quot;C&quot;</span><span class="p" data-group-id="2604929518-31">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="2604929518-32">&lt;&lt;</span><span class="p" data-group-id="2604929518-32">&gt;&gt;</span><span class="p" data-group-id="2604929518-30">}</span><span class="p" data-group-id="2604929518-23">]</span></code></pre>
  </section>
</section>
<section class="detail" id="replace/3">

  <div class="detail-header">
    <a href="#replace/3" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">replace(Subject, RE, Replacement)</h1>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L1251" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> replace(Subject, RE, Replacement) -> <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>()
                 when
                     Subject :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                     RE :: <a href="#t:mp/0">mp</a>() | <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>(),
                     Replacement :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>() | <a href="#t:replace_fun/0">replace_fun</a>().</pre>

      </div>

<p>Equivalent to <a href="#replace/4"><code class="inline">replace(Subject, RE, Replacement, [])</code></a>.</p>
  </section>
</section>
<section class="detail" id="replace/4">

  <div class="detail-header">
    <a href="#replace/4" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">replace(Subject, RE, Replacement, Options)</h1>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L1349" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> replace(Subject, RE, Replacement, Options) -> <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>()
                 when
                     Subject :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                     RE :: <a href="#t:mp/0">mp</a>() | <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                     Replacement :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>() | <a href="#t:replace_fun/0">replace_fun</a>(),
                     Options :: [Option],
                     Option ::
                         anchored | global | notbol | noteol | notempty | notempty_atstart |
                         {offset, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
                         {newline, NLSpec} |
                         bsr_anycrlf |
                         {match_limit, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
                         {match_limit_recursion, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
                         bsr_unicode |
                         {return, ReturnType} |
                         CompileOpt,
                     ReturnType :: iodata | list | binary,
                     CompileOpt :: <a href="#t:compile_option/0">compile_option</a>(),
                     NLSpec :: cr | crlf | lf | anycrlf | any.</pre>

      </div>

<p>Replaces the matched part of the <code class="inline">Subject</code> string with <code class="inline">Replacement</code>.</p><p>The permissible options are the same as for <a href="#run/3"><code class="inline">run/3</code></a>, except that
option<code class="inline">capture</code> is not allowed. Instead a <code class="inline">{return, ReturnType}</code> is present.
The default return type is <code class="inline">iodata</code>, constructed in a way to minimize copying.
The <code class="inline">iodata</code> result can be used directly in many I/O operations. If a flat
<a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a> is desired, specify <code class="inline">{return, list}</code>. If a binary is desired, specify
<code class="inline">{return, binary}</code>.</p><p>As in function <a href="#run/3"><code class="inline">run/3</code></a>, an <a href="#t:mp/0"><code class="inline">mp/0</code></a> compiled with option <code class="inline">unicode</code>
requires <code class="inline">Subject</code> to be a Unicode <code class="inline">charlist()</code>. If compilation is done
implicitly and the <code class="inline">unicode</code> compilation option is specified to this function,
both the regular expression and <code class="inline">Subject</code> are to specified as valid Unicode
<code class="inline">charlist()</code>s.</p><p>If the replacement is given as a string, it can contain the special character
<code class="inline">&amp;</code>, which inserts the whole matching expression in the result, and the special
sequence <code class="inline">\</code>N (where N is an integer &gt; 0), <code class="inline">\g</code>N, or <code class="inline">\g{</code>N<code class="inline">}</code>, resulting in the
subexpression number N, is inserted in the result. If no subexpression with that
number is generated by the regular expression, nothing is inserted.</p><p>To insert an &amp; or a \ in the result, precede it with a \. Notice that Erlang
already gives a special meaning to \ in literal strings, so a single \ must be
written as <code class="inline">&quot;\\&quot;</code> and therefore a double \ as <code class="inline">&quot;\\\\&quot;</code>.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">replace</span><span class="p" data-group-id="1174445825-1">(</span><span class="s">&quot;abcd&quot;</span><span class="p">,</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="s">&quot;[&amp;]&quot;</span><span class="p">,</span><span class="p" data-group-id="1174445825-2">[</span><span class="p" data-group-id="1174445825-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="1174445825-3">}</span><span class="p" data-group-id="1174445825-2">]</span><span class="p" data-group-id="1174445825-1">)</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;ab[c]d&quot;</span></code></pre><p>while</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">2&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">replace</span><span class="p" data-group-id="7266458301-1">(</span><span class="s">&quot;abcd&quot;</span><span class="p">,</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="s">&quot;[\\&amp;]&quot;</span><span class="p">,</span><span class="p" data-group-id="7266458301-2">[</span><span class="p" data-group-id="7266458301-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="7266458301-3">}</span><span class="p" data-group-id="7266458301-2">]</span><span class="p" data-group-id="7266458301-1">)</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;ab[&amp;]d&quot;</span></code></pre><p>If the replacement is given as a fun, it will be called with the whole matching
expression as the first argument and a list of subexpression matches in the
order in which they appear in the regular expression. The returned value will be
inserted in the result.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">3&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">replace</span><span class="p" data-group-id="7473080981-1">(</span><span class="s">&quot;abcd&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;.(.)&quot;</span><span class="p">,</span><span class="w">
    </span><span class="nf">fun</span><span class="p" data-group-id="7473080981-2">(</span><span class="n">Whole</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7473080981-3">[</span><span class="p" data-group-id="7473080981-4">&lt;&lt;</span><span class="n">C</span><span class="p" data-group-id="7473080981-4">&gt;&gt;</span><span class="p" data-group-id="7473080981-3">]</span><span class="p" data-group-id="7473080981-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
         </span><span class="p" data-group-id="7473080981-5">&lt;&lt;</span><span class="sc">$#</span><span class="p">,</span><span class="w"> </span><span class="n">Whole</span><span class="o">/</span><span class="ss">binary</span><span class="p">,</span><span class="w"> </span><span class="sc">$-</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7473080981-6">(</span><span class="n">C</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="sc">$a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="sc">$A</span><span class="p" data-group-id="7473080981-6">)</span><span class="p">,</span><span class="w"> </span><span class="sc">$#</span><span class="p" data-group-id="7473080981-5">&gt;&gt;</span><span class="w">
    </span><span class="k">end</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="7473080981-7">[</span><span class="p" data-group-id="7473080981-8">{</span><span class="ss">return</span><span class="p">,</span><span class="w"> </span><span class="ss">list</span><span class="p" data-group-id="7473080981-8">}</span><span class="p" data-group-id="7473080981-7">]</span><span class="p" data-group-id="7473080981-1">)</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;#ab-B#cd&quot;</span></code></pre><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Non-matching optional subexpressions will not be included in the list of
subexpression matches if they are the last subexpressions in the regular
expression.</p><p><em>Example:</em></p><p>The regular expression <code class="inline">&quot;(a)(b)?(c)?&quot;</code> (&quot;a&quot;, optionally followed by &quot;b&quot;,
optionally followed by &quot;c&quot;) will create the following subexpression lists:</p><ul><li><code class="inline">[&lt;&lt;&quot;a&quot;&gt;&gt;, &lt;&lt;&quot;b&quot;&gt;&gt;, &lt;&lt;&quot;c&quot;&gt;&gt;]</code> when applied to the string <code class="inline">&quot;abc&quot;</code></li><li><code class="inline">[&lt;&lt;&quot;a&quot;&gt;&gt;, &lt;&lt;&gt;&gt;, &lt;&lt;&quot;c&quot;&gt;&gt;]</code> when applied to the string <code class="inline">&quot;acx&quot;</code></li><li><code class="inline">[&lt;&lt;&quot;a&quot;&gt;&gt;, &lt;&lt;&quot;b&quot;&gt;&gt;]</code> when applied to the string <code class="inline">&quot;abx&quot;</code></li><li><code class="inline">[&lt;&lt;&quot;a&quot;&gt;&gt;]</code> when applied to the string <code class="inline">&quot;axx&quot;</code></li></ul></section><p>As with <a href="#run/3"><code class="inline">run/3</code></a>, compilation errors raise the <code class="inline">badarg</code> exception.
<a href="#compile/2"><code class="inline">compile/2</code></a> can be used to get more information about the error.</p>
  </section>
</section>
<section class="detail" id="run/2">

  <div class="detail-header">
    <a href="#run/2" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">run(Subject, RE)</h1>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L246" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> run(Subject, RE) -> {match, Captured} | nomatch
             when
                 Subject :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                 RE :: <a href="#t:mp/0">mp</a>() | <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>(),
                 Captured :: [CaptureData],
                 CaptureData :: {<a href="../../apps/erts/erlang.html#t:integer/0">integer</a>(), <a href="../../apps/erts/erlang.html#t:integer/0">integer</a>()}.</pre>

      </div>

<p>Equivalent to <a href="#run/3"><code class="inline">run(Subject, RE, [])</code></a>.</p>
  </section>
</section>
<section class="detail" id="run/3">

  <div class="detail-header">
    <a href="#run/3" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">run(Subject, RE, Options)</h1>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L782" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> run(Subject, RE, Options) -> {match, Captured} | match | nomatch | {error, ErrType}
             when
                 Subject :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                 RE :: <a href="#t:mp/0">mp</a>() | <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                 Options :: <a href="#t:options/0">options</a>(),
                 Captured :: [CaptureData] | [[CaptureData]],
                 CaptureData :: {<a href="../../apps/erts/erlang.html#t:integer/0">integer</a>(), <a href="../../apps/erts/erlang.html#t:integer/0">integer</a>()} | ListConversionData | <a href="../../apps/erts/erlang.html#t:binary/0">binary</a>(),
                 ListConversionData ::
                     <a href="../../apps/erts/erlang.html#t:string/0">string</a>() | {error, <a href="../../apps/erts/erlang.html#t:string/0">string</a>(), <a href="../../apps/erts/erlang.html#t:binary/0">binary</a>()} | {incomplete, <a href="../../apps/erts/erlang.html#t:string/0">string</a>(), <a href="../../apps/erts/erlang.html#t:binary/0">binary</a>()},
                 ErrType :: match_limit | match_limit_recursion | {compile, CompileErr},
                 CompileErr :: {ErrString :: <a href="../../apps/erts/erlang.html#t:string/0">string</a>(), Position :: <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()}.</pre>

      </div>

<p>Executes a regular expression matching, and returns <code class="inline">match/{match, Captured}</code> or
<code class="inline">nomatch</code>.</p><p>The regular expression can be specified either as <a href="../../apps/erts/erlang.html#t:iodata/0"><code class="inline">iodata/0</code></a> in
which case it is automatically compiled (as by <a href="#compile/2"><code class="inline">compile/2</code></a>) and
executed, or as a precompiled <a href="#t:mp/0"><code class="inline">mp/0</code></a> in which case it is executed against the
subject directly.</p><p>When compilation is involved, exception <code class="inline">badarg</code> is thrown if a compilation
error occurs. Call <a href="#compile/2"><code class="inline">compile/2</code></a> to get information about the
location of the error in the regular expression.</p><p>If the regular expression is previously compiled, the option list can only
contain the following options:</p><ul><li><code class="inline">anchored</code></li><li><code class="inline">{capture, ValueSpec}/{capture, ValueSpec, Type}</code></li><li><code class="inline">global</code></li><li><code class="inline">{match_limit, integer() &gt;= 0}</code></li><li><code class="inline">{match_limit_recursion, integer() &gt;= 0}</code></li><li><code class="inline">{newline, NLSpec}</code></li><li><code class="inline">notbol</code></li><li><code class="inline">notempty</code></li><li><code class="inline">notempty_atstart</code></li><li><code class="inline">noteol</code></li><li><code class="inline">{offset, integer() &gt;= 0}</code></li><li><code class="inline">report_errors</code></li></ul><p>Otherwise all options valid for function <a href="#compile/2"><code class="inline">compile/2</code></a> are also
allowed. Options allowed both for compilation and execution of a match, namely
<code class="inline">anchored</code> and <code class="inline">{newline, NLSpec}</code>, affect both the compilation and execution if
present together with a non-precompiled regular expression.</p><p>If the regular expression was previously compiled with option <code class="inline">unicode</code>,
<code class="inline">Subject</code> is to be provided as a valid Unicode <code class="inline">charlist()</code>, otherwise any
<a href="../../apps/erts/erlang.html#t:iodata/0"><code class="inline">iodata/0</code></a> will do. If compilation is involved and option <code class="inline">unicode</code> is
specified, both <code class="inline">Subject</code> and the regular expression are to be specified as
valid Unicode <code class="inline">charlists()</code>.</p><p><code class="inline">{capture, ValueSpec}/{capture, ValueSpec, Type}</code> defines what to return from
the function upon successful matching. The <code class="inline">capture</code> tuple can contain both a
value specification, telling which of the captured substrings are to be
returned, and a type specification, telling how captured substrings are to be
returned (as index tuples, lists, or binaries). The options are described in
detail below.</p><p>If the capture options describe that no substring capturing is to be done
(<code class="inline">{capture, none}</code>), the function returns the single atom <code class="inline">match</code> upon
successful matching, otherwise the tuple <code class="inline">{match, ValueList}</code>. Disabling
capturing can be done either by specifying <code class="inline">none</code> or an empty list as
<code class="inline">ValueSpec</code>.</p><p>Option <code class="inline">report_errors</code> adds the possibility that an error tuple is returned. The
tuple either indicates a matching error (<code class="inline">match_limit</code> or
<code class="inline">match_limit_recursion</code>), or a compilation error, where the error tuple has the
format <code class="inline">{error, {compile, CompileErr}}</code>. Notice that if option <code class="inline">report_errors</code>
is not specified, the function never returns error tuples, but reports
compilation errors as a <code class="inline">badarg</code> exception and failed matches because of
exceeded match limits simply as <code class="inline">nomatch</code>.</p><p>The following options are relevant for execution:</p><ul><li><p><strong><code class="inline">anchored</code></strong> - Limits <a href="#run/3"><code class="inline">run/3</code></a> to matching at the first matching
position. If a pattern was compiled with <code class="inline">anchored</code>, or turned out to be
anchored by virtue of its contents, it cannot be made unanchored at matching
time, hence there is no <code class="inline">unanchored</code> option.</p></li><li><p><strong><code class="inline">global</code></strong> - Implements global (repetitive) search (flag <code class="inline">g</code> in Perl). Each
match is returned as a separate <a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a> containing the specific match and
any matching subexpressions (or as specified by option <code class="inline">capture</code>. The
<code class="inline">Captured</code> part of the return value is hence a <a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a> of <a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a>s when
this option is specified.</p><p>The interaction of option <code class="inline">global</code> with a regular expression that matches an
empty string surprises some users. When option <code class="inline">global</code> is specified,
<a href="#run/3"><code class="inline">run/3</code></a> handles empty matches in the same way as Perl: a
zero-length match at any point is also retried with options
<code class="inline">[anchored, notempty_atstart]</code>. If that search gives a result of length &gt; 0,
the result is included. Example:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="9706400716-1">(</span><span class="s">&quot;cat&quot;</span><span class="p">,</span><span class="s">&quot;(|at)&quot;</span><span class="p">,</span><span class="p" data-group-id="9706400716-2">[</span><span class="ss">global</span><span class="p" data-group-id="9706400716-2">]</span><span class="p" data-group-id="9706400716-1">)</span><span class="p">.</span></code></pre><p>The following matchings are performed:</p><ul><li><p><strong>At offset <code class="inline">0</code></strong> - The regular expression <code class="inline">(|at)</code> first match at the
initial position of string <code class="inline">cat</code>, giving the result set <code class="inline">[{0,0},{0,0}]</code> (the
second <code class="inline">{0,0}</code> is because of the subexpression marked by the parentheses).
As the length of the match is 0, we do not advance to the next position yet.</p></li><li><p><strong>At offset <code class="inline">0</code> with <code class="inline">[anchored, notempty_atstart]</code></strong> - The search is
retried with options <code class="inline">[anchored, notempty_atstart]</code> at the same position,
which does not give any interesting result of longer length, so the search
position is advanced to the next character (<code class="inline">a</code>).</p></li><li><p><strong>At offset <code class="inline">1</code></strong> - The search results in <code class="inline">[{1,0},{1,0}]</code>, so this search is
also repeated with the extra options.</p></li><li><p><strong>At offset <code class="inline">1</code> with <code class="inline">[anchored, notempty_atstart]</code></strong> - Alternative <code class="inline">ab</code> is
found and the result is [{1,2},{1,2}]. The result is added to the list
of results and the position in the search string is advanced two steps.</p></li><li><p><strong>At offset <code class="inline">3</code></strong> - The search once again matches the empty string, giving
<code class="inline">[{3,0},{3,0}]</code>.</p></li><li><p><strong>At offset <code class="inline">1</code> with <code class="inline">[anchored, notempty_atstart]</code></strong> - This gives no result
of length &gt; 0 and we are at the last position, so the global search is
complete.</p></li></ul><p>The result of the call is:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="0604834477-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="0604834477-2">[</span><span class="p" data-group-id="0604834477-3">[</span><span class="p" data-group-id="0604834477-4">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="0604834477-4">}</span><span class="p">,</span><span class="p" data-group-id="0604834477-5">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="0604834477-5">}</span><span class="p" data-group-id="0604834477-3">]</span><span class="p">,</span><span class="p" data-group-id="0604834477-6">[</span><span class="p" data-group-id="0604834477-7">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="0604834477-7">}</span><span class="p">,</span><span class="p" data-group-id="0604834477-8">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="0604834477-8">}</span><span class="p" data-group-id="0604834477-6">]</span><span class="p">,</span><span class="p" data-group-id="0604834477-9">[</span><span class="p" data-group-id="0604834477-10">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="0604834477-10">}</span><span class="p">,</span><span class="p" data-group-id="0604834477-11">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="0604834477-11">}</span><span class="p" data-group-id="0604834477-9">]</span><span class="p">,</span><span class="p" data-group-id="0604834477-12">[</span><span class="p" data-group-id="0604834477-13">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="0604834477-13">}</span><span class="p">,</span><span class="p" data-group-id="0604834477-14">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="0604834477-14">}</span><span class="p" data-group-id="0604834477-12">]</span><span class="p" data-group-id="0604834477-2">]</span><span class="p" data-group-id="0604834477-1">}</span></code></pre></li><li><p><strong><code class="inline">notempty</code></strong> - An empty string is not considered to be a valid match if this
option is specified. If alternatives in the pattern exist, they are tried. If
all the alternatives match the empty string, the entire match fails.</p><p><em>Example:</em></p><p>If the following pattern is applied to a string not beginning with &quot;a&quot; or &quot;b&quot;,
it would normally match the empty string at the start of the subject:</p><pre><code class="text">a?b?</code></pre><p>With option <code class="inline">notempty</code>, this match is invalid, so <a href="#run/3"><code class="inline">run/3</code></a> searches
further into the string for occurrences of &quot;a&quot; or &quot;b&quot;.</p></li><li><p><strong><code class="inline">notempty_atstart</code></strong> - Like <code class="inline">notempty</code>, except that an empty string match
that is not at the start of the subject is permitted. If the pattern is
anchored, such a match can occur only if the pattern contains \K.</p><p>Perl has no direct equivalent of <code class="inline">notempty</code> or <code class="inline">notempty_atstart</code>, but it does
make a special case of a pattern match of the empty string within its split()
function, and when using modifier <code class="inline">/g</code>. The Perl behavior can be emulated
after matching a null string by first trying the match again at the same
offset with <code class="inline">notempty_atstart</code> and <code class="inline">anchored</code>, and then, if that fails, by
advancing the starting offset (see below) and trying an ordinary match again.</p></li><li><p><strong><code class="inline">notbol</code></strong> - Specifies that the first character of the subject string is not
the beginning of a line, so the circumflex metacharacter is not to match
before it. Setting this without <code class="inline">multiline</code> (at compile time) causes
circumflex never to match. This option only affects the behavior of the
circumflex metacharacter. It does not affect \A.</p></li><li><p><strong><code class="inline">noteol</code></strong> - Specifies that the end of the subject string is not the end of
a line, so the dollar metacharacter is not to match it nor (except in
multiline mode) a newline immediately before it. Setting this without
<code class="inline">multiline</code> (at compile time) causes dollar never to match. This option
affects only the behavior of the dollar metacharacter. It does not affect \Z
or \z.</p></li><li><p><strong><code class="inline">report_errors</code></strong> - Gives better control of the error handling in
<a href="#run/3"><code class="inline">run/3</code></a>. When specified, compilation errors (if the regular
expression is not already compiled) and runtime errors are explicitly returned
as an error tuple.</p><p>The following are the possible runtime errors:</p><ul><li><p><strong><code class="inline">match_limit</code></strong> - The PCRE library sets a limit on how many times the
internal match function can be called. Defaults to 10,000,000 in the library
compiled for Erlang. If <code class="inline">{error, match_limit}</code> is returned, the execution of
the regular expression has reached this limit. This is normally to be
regarded as a <code class="inline">nomatch</code>, which is the default return value when this occurs,
but by specifying <code class="inline">report_errors</code>, you are informed when the match fails
because of too many internal calls.</p></li><li><p><strong><code class="inline">match_limit_recursion</code></strong> - This error is very similar to <code class="inline">match_limit</code>,
but occurs when the internal match function of PCRE is &quot;recursively&quot; called
more times than the <code class="inline">match_limit_recursion</code> limit, which defaults to
10,000,000 as well. Notice that as long as the <code class="inline">match_limit</code> and
<code class="inline">match_limit_default</code> values are kept at the default values, the
<code class="inline">match_limit_recursion</code> error cannot occur, as the <code class="inline">match_limit</code> error
occurs before that (each recursive call is also a call, but not conversely).
Both limits can however be changed, either by setting limits directly in the
regular expression string (see section
<a href="re.html#module-pcre-regular-expression-details">PCRE Regular Eexpression Details</a>) or by
specifying options to <a href="#run/3"><code class="inline">run/3</code></a>.</p></li></ul><p>It is important to understand that what is referred to as &quot;recursion&quot; when
limiting matches is not recursion on the C stack of the Erlang machine or on
the Erlang process stack. The PCRE version compiled into the Erlang VM uses
machine &quot;heap&quot; memory to store values that must be kept over recursion in
regular expression matches.</p></li><li><p><strong><code class="inline">{match_limit, integer() &gt;= 0}</code></strong> - Limits the execution time of a match in
an implementation-specific way. It is described as follows by the PCRE
documentation:</p><blockquote><p>The match_limit field provides a means of preventing PCRE from using
up a vast amount of resources when running patterns that are not going
to match, but which have a very large number of possibilities in their
search trees. The classic example is a pattern that uses nested
unlimited repeats.</p><p>Internally, pcre_exec() uses a function called match(), which it calls
repeatedly (sometimes recursively). The limit set by match_limit is
imposed on the number of times this function is called during a match,
which has the effect of limiting the amount of backtracking that can
take place. For patterns that are not anchored, the count restarts
from zero for each position in the subject string.</p></blockquote><p>This means that runaway regular expression matches can fail faster if the
limit is lowered using this option. The default value 10,000,000 is compiled
into the Erlang VM.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>This option does in no way affect the execution of the Erlang VM in terms of
&quot;long running BIFs&quot;. <a href="#run/3"><code class="inline">run/3</code></a> always gives control back to the
scheduler of Erlang processes at intervals that ensures the real-time
properties of the Erlang system.</p></section></li><li><p><strong><code class="inline">{match_limit_recursion, integer() &gt;= 0}</code></strong> - Limits the execution time and
memory consumption of a match in an implementation-specific way, very similar
to <code class="inline">match_limit</code>. It is described as follows by the PCRE documentation:</p><blockquote><p>The match_limit_recursion field is similar to match_limit, but instead
of limiting the total number of times that match() is called, it
limits the depth of recursion. The recursion depth is a smaller number
than the total number of calls, because not all calls to match() are
recursive. This limit is of use only if it is set smaller than
match_limit.</p><p>Limiting the recursion depth limits the amount of machine stack that
can be used, or, when PCRE has been compiled to use memory on the heap
instead of the stack, the amount of heap memory that can be used.</p></blockquote><p>The Erlang VM uses a PCRE library where heap memory is used when regular
expression match recursion occurs. This therefore limits the use of machine
heap, not C stack.</p><p>Specifying a lower value can result in matches with deep recursion failing,
when they should have matched:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="0178752688-1">(</span><span class="s">&quot;aaaaaaaaaaaaaz&quot;</span><span class="p">,</span><span class="s">&quot;(a+)*z&quot;</span><span class="p" data-group-id="0178752688-1">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="0178752688-2">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="0178752688-3">[</span><span class="p" data-group-id="0178752688-4">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">14</span><span class="p" data-group-id="0178752688-4">}</span><span class="p">,</span><span class="p" data-group-id="0178752688-5">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">13</span><span class="p" data-group-id="0178752688-5">}</span><span class="p" data-group-id="0178752688-3">]</span><span class="p" data-group-id="0178752688-2">}</span><span class="gp unselectable">
2&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="0178752688-6">(</span><span class="s">&quot;aaaaaaaaaaaaaz&quot;</span><span class="p">,</span><span class="s">&quot;(a+)*z&quot;</span><span class="p">,</span><span class="p" data-group-id="0178752688-7">[</span><span class="p" data-group-id="0178752688-8">{</span><span class="ss">match_limit_recursion</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="0178752688-8">}</span><span class="p" data-group-id="0178752688-7">]</span><span class="p" data-group-id="0178752688-6">)</span><span class="p">.</span><span class="w">
</span><span class="ss">nomatch</span><span class="gp unselectable">
3&gt; </span><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="0178752688-9">(</span><span class="s">&quot;aaaaaaaaaaaaaz&quot;</span><span class="p">,</span><span class="s">&quot;(a+)*z&quot;</span><span class="p">,</span><span class="p" data-group-id="0178752688-10">[</span><span class="p" data-group-id="0178752688-11">{</span><span class="ss">match_limit_recursion</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="0178752688-11">}</span><span class="p">,</span><span class="ss">report_errors</span><span class="p" data-group-id="0178752688-10">]</span><span class="p" data-group-id="0178752688-9">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="0178752688-12">{</span><span class="ss">error</span><span class="p">,</span><span class="ss">match_limit_recursion</span><span class="p" data-group-id="0178752688-12">}</span></code></pre><p>This option and option <code class="inline">match_limit</code> are only to be used in rare cases.
Understanding of the PCRE library internals is recommended before tampering
with these limits.</p></li><li><p><strong><code class="inline">{offset, integer() &gt;= 0}</code></strong> - Start matching at the offset (position)
specified in the subject string. The offset is zero-based, so that the default
is <code class="inline">{offset,0}</code> (all of the subject string).</p></li><li><p><strong><code class="inline">{newline, NLSpec}</code></strong> - Overrides the default definition of a newline in the
subject string, which is LF (ASCII 10) in Erlang.</p><ul><li><p><strong><code class="inline">cr</code></strong> - Newline is indicated by a single character CR (ASCII 13).</p></li><li><p><strong><code class="inline">lf</code></strong> - Newline is indicated by a single character LF (ASCII 10), the
default.</p></li><li><p><strong><code class="inline">crlf</code></strong> - Newline is indicated by the two-character CRLF (ASCII 13
followed by ASCII 10) sequence.</p></li><li><p><strong><code class="inline">anycrlf</code></strong> - Any of the three preceding sequences is be recognized.</p></li><li><p><strong><code class="inline">any</code></strong> - Any of the newline sequences above, and the Unicode sequences VT
(vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS
(line separator, U+2028), and PS (paragraph separator, U+2029).</p></li></ul></li><li><p><strong><code class="inline">bsr_anycrlf</code></strong> - Specifies specifically that \R is to match only the CR
LF, or CRLF sequences, not the Unicode-specific newline characters. (Overrides
the compilation option.)</p></li><li><p><strong><code class="inline">bsr_unicode</code></strong> - Specifies specifically that \R is to match all the
Unicode newline characters (including CRLF, and so on, the default).
(Overrides the compilation option.)</p></li><li><p><strong><code class="inline">{capture, ValueSpec}</code>/<code class="inline">{capture, ValueSpec, Type}</code></strong> - Specifies which
captured substrings are returned and in what format. By default,
<a href="#run/3"><code class="inline">run/3</code></a> captures all of the matching part of the substring and all
capturing subpatterns (all of the pattern is automatically captured). The
default return type is (zero-based) indexes of the captured parts of the
string, specified as <code class="inline">{Offset,Length}</code> pairs (the <code class="inline">index</code> <code class="inline">Type</code> of
capturing).</p><p>As an example of the default behavior, the following call returns, as first
and only captured string, the matching part of the subject (&quot;abcd&quot; in the
middle) as an index pair <code class="inline">{3,4}</code>, where character positions are zero-based,
just as in offsets:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="4601012573-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;abcd&quot;</span><span class="p">,</span><span class="p" data-group-id="4601012573-2">[</span><span class="p" data-group-id="4601012573-2">]</span><span class="p" data-group-id="4601012573-1">)</span><span class="p">.</span></code></pre><p>The return value of this call is:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="8176671565-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="8176671565-2">[</span><span class="p" data-group-id="8176671565-3">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="8176671565-3">}</span><span class="p" data-group-id="8176671565-2">]</span><span class="p" data-group-id="8176671565-1">}</span></code></pre><p>Another (and quite common) case is where the regular expression matches all of
the subject:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="1414422529-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*abcd.*&quot;</span><span class="p">,</span><span class="p" data-group-id="1414422529-2">[</span><span class="p" data-group-id="1414422529-2">]</span><span class="p" data-group-id="1414422529-1">)</span><span class="p">.</span></code></pre><p>Here the return value correspondingly points out all of the string, beginning
at index 0, and it is 10 characters long:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="5612091328-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="5612091328-2">[</span><span class="p" data-group-id="5612091328-3">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="5612091328-3">}</span><span class="p" data-group-id="5612091328-2">]</span><span class="p" data-group-id="5612091328-1">}</span></code></pre><p>If the regular expression contains capturing subpatterns, like in:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="8083487883-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*(abcd).*&quot;</span><span class="p">,</span><span class="p" data-group-id="8083487883-2">[</span><span class="p" data-group-id="8083487883-2">]</span><span class="p" data-group-id="8083487883-1">)</span><span class="p">.</span></code></pre><p>all of the matched subject is captured, as well as the captured substrings:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="3920551198-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="3920551198-2">[</span><span class="p" data-group-id="3920551198-3">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="3920551198-3">}</span><span class="p">,</span><span class="p" data-group-id="3920551198-4">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="3920551198-4">}</span><span class="p" data-group-id="3920551198-2">]</span><span class="p" data-group-id="3920551198-1">}</span></code></pre><p>The complete matching pattern always gives the first return value in the list
and the remaining subpatterns are added in the order they occurred in the
regular expression.</p><p>The capture tuple is built up as follows:</p><ul><li><p><strong><code class="inline">ValueSpec</code></strong> - Specifies which captured (sub)patterns are to be returned.
<code class="inline">ValueSpec</code> can either be an atom describing a predefined set of return
values, or a list containing the indexes or the names of specific
subpatterns to return.</p><p>The following are the predefined sets of subpatterns:</p><ul><li><p><strong><code class="inline">all</code></strong> - All captured subpatterns including the complete matching
string. This is the default.</p></li><li><p><strong><code class="inline">all_names</code></strong> - All <em>named</em> subpatterns in the regular expression, as if
a <a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a> of all the names <em>in alphabetical order</em> was specified. The
list of all names can also be retrieved with <a href="#inspect/2"><code class="inline">inspect/2</code></a>.</p></li><li><p><strong><code class="inline">first</code></strong> - Only the first captured subpattern, which is always the
complete matching part of the subject. All explicitly captured subpatterns
are discarded.</p></li><li><p><strong><code class="inline">all_but_first</code></strong> - All but the first matching subpattern, that is, all
explicitly captured subpatterns, but not the complete matching part of the
subject string. This is useful if the regular expression as a whole
matches a large part of the subject, but the part you are interested in is
in an explicitly captured subpattern. If the return type is <code class="inline">list</code> or
<code class="inline">binary</code>, not returning subpatterns you are not interested in is a good
way to optimize.</p></li><li><p><strong><code class="inline">none</code></strong> - Returns no matching subpatterns, gives the single atom
<code class="inline">match</code> as the return value of the function when matching successfully
instead of the <code class="inline">{match, list()}</code> return. Specifying an empty list gives
the same behavior.</p></li></ul><p>The value list is a list of indexes for the subpatterns to return, where
index 0 is for all of the pattern, and 1 is for the first explicit capturing
subpattern in the regular expression, and so on. When using named captured
subpatterns (see below) in the regular expression, one can use <a href="../../apps/erts/erlang.html#t:atom/0"><code class="inline">atom/0</code></a>s
or <a href="../../apps/erts/erlang.html#t:string/0"><code class="inline">string/0</code></a>s to specify the subpatterns to be returned. For example,
consider the regular expression:</p><pre><code class="text">&quot;.*(abcd).*&quot;</code></pre><p>matched against string &quot;ABCabcdABC&quot;, capturing only the &quot;abcd&quot; part (the
first explicit subpattern):</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="8871214817-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*(abcd).*&quot;</span><span class="p">,</span><span class="p" data-group-id="8871214817-2">[</span><span class="p" data-group-id="8871214817-3">{</span><span class="ss">capture</span><span class="p">,</span><span class="p" data-group-id="8871214817-4">[</span><span class="mi">1</span><span class="p" data-group-id="8871214817-4">]</span><span class="p" data-group-id="8871214817-3">}</span><span class="p" data-group-id="8871214817-2">]</span><span class="p" data-group-id="8871214817-1">)</span><span class="p">.</span></code></pre><p>The call gives the following result, as the first explicitly captured
subpattern is &quot;(abcd)&quot;, matching &quot;abcd&quot; in the subject, at (zero-based)
position 3, of length 4:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="0912354337-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="0912354337-2">[</span><span class="p" data-group-id="0912354337-3">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="0912354337-3">}</span><span class="p" data-group-id="0912354337-2">]</span><span class="p" data-group-id="0912354337-1">}</span></code></pre><p>Consider the same regular expression, but with the subpattern explicitly
named 'FOO':</p><pre><code class="text">&quot;.*(?&lt;FOO&gt;abcd).*&quot;</code></pre><p>With this expression, we could still give the index of the subpattern with
the following call:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="3802776534-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*(?&lt;FOO&gt;abcd).*&quot;</span><span class="p">,</span><span class="p" data-group-id="3802776534-2">[</span><span class="p" data-group-id="3802776534-3">{</span><span class="ss">capture</span><span class="p">,</span><span class="p" data-group-id="3802776534-4">[</span><span class="mi">1</span><span class="p" data-group-id="3802776534-4">]</span><span class="p" data-group-id="3802776534-3">}</span><span class="p" data-group-id="3802776534-2">]</span><span class="p" data-group-id="3802776534-1">)</span><span class="p">.</span></code></pre><p>giving the same result as before. But, as the subpattern is named, we can
also specify its name in the value list:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="2782241364-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*(?&lt;FOO&gt;abcd).*&quot;</span><span class="p">,</span><span class="p" data-group-id="2782241364-2">[</span><span class="p" data-group-id="2782241364-3">{</span><span class="ss">capture</span><span class="p">,</span><span class="p" data-group-id="2782241364-4">[</span><span class="ss">&#39;FOO&#39;</span><span class="p" data-group-id="2782241364-4">]</span><span class="p" data-group-id="2782241364-3">}</span><span class="p" data-group-id="2782241364-2">]</span><span class="p" data-group-id="2782241364-1">)</span><span class="p">.</span></code></pre><p>This would give the same result as the earlier examples, namely:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="4660064491-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="4660064491-2">[</span><span class="p" data-group-id="4660064491-3">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="4660064491-3">}</span><span class="p" data-group-id="4660064491-2">]</span><span class="p" data-group-id="4660064491-1">}</span></code></pre><p>The values list can specify indexes or names not present in the regular
expression, in which case the return values vary depending on the type. If
the type is <code class="inline">index</code>, the tuple <code class="inline">{-1,0}</code> is returned for values with no
corresponding subpattern in the regular expression, but for the other types
(<code class="inline">binary</code> and <code class="inline">list</code>), the values are the empty binary or list,
respectively.</p></li><li><p><strong><code class="inline">Type</code></strong> - Optionally specifies how captured substrings are to be
returned. If omitted, the default of <code class="inline">index</code> is used.</p><p><code class="inline">Type</code> can be one of the following:</p><ul><li><p><strong><code class="inline">index</code></strong> - Returns captured substrings as pairs of byte indexes into
the subject string and length of the matching string in the subject (as if
the subject string was flattened with <a href="../../apps/erts/erlang.html#iolist_to_binary/1"><code class="inline">erlang:iolist_to_binary/1</code></a> or
<a href="unicode.html#characters_to_binary/2"><code class="inline">unicode:characters_to_binary/2</code></a> before matching). Notice that option
<code class="inline">unicode</code> results in <em>byte-oriented</em> indexes in a (possibly virtual)
<em>UTF-8 encoded</em> binary. A byte index tuple <code class="inline">{0,2}</code> can therefore represent
one or two characters when <code class="inline">unicode</code> is in effect. This can seem
counter-intuitive, but has been deemed the most effective and useful way
to do it. To return lists instead can result in simpler code if that is
desired. This return type is the default.</p></li><li><p><strong><code class="inline">list</code></strong> - Returns matching substrings as lists of characters (Erlang
<a href="../../apps/erts/erlang.html#t:string/0"><code class="inline">string/0</code></a>s). It option <code class="inline">unicode</code> is used in combination with the \C
sequence in the regular expression, a captured subpattern can contain
bytes that are not valid UTF-8 (\C matches bytes regardless of character
encoding). In that case the <code class="inline">list</code> capturing can result in the same types
of tuples that <a href="unicode.html#characters_to_list/2"><code class="inline">unicode:characters_to_list/2</code></a> can return, namely
three-tuples with tag <code class="inline">incomplete</code> or <code class="inline">error</code>, the successfully converted
characters and the invalid UTF-8 tail of the conversion as a binary. The
best strategy is to avoid using the \C sequence when capturing lists.</p></li><li><p><strong><code class="inline">binary</code></strong> - Returns matching substrings as binaries. If option
<code class="inline">unicode</code> is used, these binaries are in UTF-8. If the \C sequence is
used together with <code class="inline">unicode</code>, the binaries can be invalid UTF-8.</p></li></ul></li></ul><p>In general, subpatterns that were not assigned a value in the match are
returned as the tuple <code class="inline">{-1,0}</code> when <code class="inline">type</code> is <code class="inline">index</code>. Unassigned subpatterns
are returned as the empty binary or list, respectively, for other return
types. Consider the following regular expression:</p><pre><code class="text">&quot;.*((?&lt;FOO&gt;abdd)|a(..d)).*&quot;</code></pre><p>There are three explicitly capturing subpatterns, where the opening
parenthesis position determines the order in the result, hence
<code class="inline">((?&lt;FOO&gt;abdd)|a(..d))</code> is subpattern index 1, <code class="inline">(?&lt;FOO&gt;abdd)</code> is subpattern
index 2, and <code class="inline">(..d)</code> is subpattern index 3. When matched against the following
string:</p><pre><code class="text">&quot;ABCabcdABC&quot;</code></pre><p>the subpattern at index 2 does not match, as &quot;abdd&quot; is not present in the
string, but the complete pattern matches (because of the alternative
<code class="inline">a(..d)</code>). The subpattern at index 2 is therefore unassigned and the default
return value is:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="7398530287-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="7398530287-2">[</span><span class="p" data-group-id="7398530287-3">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="7398530287-3">}</span><span class="p">,</span><span class="p" data-group-id="7398530287-4">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="7398530287-4">}</span><span class="p">,</span><span class="p" data-group-id="7398530287-5">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="7398530287-5">}</span><span class="p">,</span><span class="p" data-group-id="7398530287-6">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="7398530287-6">}</span><span class="p" data-group-id="7398530287-2">]</span><span class="p" data-group-id="7398530287-1">}</span></code></pre><p>Setting the capture <code class="inline">Type</code> to <code class="inline">binary</code> gives:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="5700332750-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="5700332750-2">[</span><span class="p" data-group-id="5700332750-3">&lt;&lt;</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p" data-group-id="5700332750-3">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="5700332750-4">&lt;&lt;</span><span class="s">&quot;abcd&quot;</span><span class="p" data-group-id="5700332750-4">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="5700332750-5">&lt;&lt;</span><span class="p" data-group-id="5700332750-5">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="5700332750-6">&lt;&lt;</span><span class="s">&quot;bcd&quot;</span><span class="p" data-group-id="5700332750-6">&gt;&gt;</span><span class="p" data-group-id="5700332750-2">]</span><span class="p" data-group-id="5700332750-1">}</span></code></pre><p>Here the empty binary (<code class="inline">&lt;&lt;&gt;&gt;</code>) represents the unassigned subpattern. In the
<code class="inline">binary</code> case, some information about the matching is therefore lost, as
<code class="inline">&lt;&lt;&gt;&gt;</code> can also be an empty string captured.</p><p>If differentiation between empty matches and non-existing subpatterns is
necessary, use the <code class="inline">type</code> <code class="inline">index</code> and do the conversion to the final type in
Erlang code.</p><p>When option <code class="inline">global</code> is speciified, the <code class="inline">capture</code> specification affects each
match separately, so that:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">run</span><span class="p" data-group-id="2300604112-1">(</span><span class="s">&quot;cacb&quot;</span><span class="p">,</span><span class="s">&quot;c(a|b)&quot;</span><span class="p">,</span><span class="p" data-group-id="2300604112-2">[</span><span class="ss">global</span><span class="p">,</span><span class="p" data-group-id="2300604112-3">{</span><span class="ss">capture</span><span class="p">,</span><span class="p" data-group-id="2300604112-4">[</span><span class="mi">1</span><span class="p" data-group-id="2300604112-4">]</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="2300604112-3">}</span><span class="p" data-group-id="2300604112-2">]</span><span class="p" data-group-id="2300604112-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="0849420896-1">{</span><span class="ss">match</span><span class="p">,</span><span class="p" data-group-id="0849420896-2">[</span><span class="p" data-group-id="0849420896-3">[</span><span class="s">&quot;a&quot;</span><span class="p" data-group-id="0849420896-3">]</span><span class="p">,</span><span class="p" data-group-id="0849420896-4">[</span><span class="s">&quot;b&quot;</span><span class="p" data-group-id="0849420896-4">]</span><span class="p" data-group-id="0849420896-2">]</span><span class="p" data-group-id="0849420896-1">}</span></code></pre></li></ul><p>For a descriptions of options only affecting the compilation step, see
<a href="#compile/2"><code class="inline">compile/2</code></a>.</p>
  </section>
</section>
<section class="detail" id="split/2">

  <div class="detail-header">
    <a href="#split/2" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">split(Subject, RE)</h1>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L881" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> split(Subject, RE) -> SplitList
               when
                   Subject :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                   RE :: <a href="#t:mp/0">mp</a>() | <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>(),
                   SplitList :: [<a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>()].</pre>

      </div>

<p>Equivalent to <a href="#split/3"><code class="inline">split(Subject, RE, [])</code></a>.</p>
  </section>
</section>
<section class="detail" id="split/3">

  <div class="detail-header">
    <a href="#split/3" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">split(Subject, RE, Options)</h1>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L1075" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> split(Subject, RE, Options) -> SplitList
               when
                   Subject :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                   RE :: <a href="#t:mp/0">mp</a>() | <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>(),
                   Options :: [Option],
                   Option ::
                       anchored | notbol | noteol | notempty | notempty_atstart |
                       {offset, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
                       {newline, <a href="#t:nl_spec/0">nl_spec</a>()} |
                       {match_limit, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
                       {match_limit_recursion, <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>()} |
                       bsr_anycrlf | bsr_unicode |
                       {return, ReturnType} |
                       {parts, NumParts} |
                       group | trim | CompileOpt,
                   NumParts :: <a href="../../apps/erts/erlang.html#t:non_neg_integer/0">non_neg_integer</a>() | infinity,
                   ReturnType :: iodata | list | binary,
                   CompileOpt :: <a href="#t:compile_option/0">compile_option</a>(),
                   SplitList :: [RetData] | [GroupedRetData],
                   GroupedRetData :: [RetData],
                   RetData :: <a href="../../apps/erts/erlang.html#t:iodata/0">iodata</a>() | <a href="unicode.html#t:charlist/0">unicode:charlist</a>() | <a href="../../apps/erts/erlang.html#t:binary/0">binary</a>() | <a href="../../apps/erts/erlang.html#t:list/0">list</a>().</pre>

      </div>

<p>Splits the input into parts by finding tokens according to the regular
expression supplied.</p><p>The splitting is basically done by running a global regular
expression match and dividing the initial string wherever a match occurs. The
matching part of the string is removed from the output.</p><p>As in <a href="#run/3"><code class="inline">run/3</code></a>, an <a href="#t:mp/0"><code class="inline">mp/0</code></a> compiled with option <code class="inline">unicode</code> requires <code class="inline">Subject</code> to
be a Unicode <code class="inline">charlist()</code>. If compilation is done implicitly and the <code class="inline">unicode</code>
compilation option is specified to this function, both the regular expression
and <code class="inline">Subject</code> are to be specified as valid Unicode <code class="inline">charlist()</code>s.</p><p>The result is given as a list of &quot;strings&quot;, the preferred data type specified in
option <code class="inline">return</code> (default <code class="inline">iodata</code>).</p><p>If subexpressions are specified in the regular expression, the matching
subexpressions are returned in the resulting list as well. For example:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="6522691268-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[ln]&quot;</span><span class="p">,</span><span class="p" data-group-id="6522691268-2">[</span><span class="p" data-group-id="6522691268-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="6522691268-3">}</span><span class="p" data-group-id="6522691268-2">]</span><span class="p" data-group-id="6522691268-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="4371035153-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;g&quot;</span><span class="p" data-group-id="4371035153-1">]</span></code></pre><p>while</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="5372122697-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;([ln])&quot;</span><span class="p">,</span><span class="p" data-group-id="5372122697-2">[</span><span class="p" data-group-id="5372122697-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="5372122697-3">}</span><span class="p" data-group-id="5372122697-2">]</span><span class="p" data-group-id="5372122697-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="3270144055-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;l&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;n&quot;</span><span class="p">,</span><span class="s">&quot;g&quot;</span><span class="p" data-group-id="3270144055-1">]</span></code></pre><p>The text matching the subexpression (marked by the parentheses in the regular
expression) is inserted in the result list where it was found. This means that
concatenating the result of a split where the whole regular expression is a
single subexpression (as in the last example) always results in the original
string.</p><p>As there is no matching subexpression for the last part in the example (the
&quot;g&quot;), nothing is inserted after that. To make the group of strings and the parts
matching the subexpressions more obvious, one can use option <code class="inline">group</code>, which
groups together the part of the subject string with the parts matching the
subexpressions when the string was split:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="8322359419-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;([ln])&quot;</span><span class="p">,</span><span class="p" data-group-id="8322359419-2">[</span><span class="p" data-group-id="8322359419-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="8322359419-3">}</span><span class="p">,</span><span class="ss">group</span><span class="p" data-group-id="8322359419-2">]</span><span class="p" data-group-id="8322359419-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="5820911210-1">[</span><span class="p" data-group-id="5820911210-2">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;l&quot;</span><span class="p" data-group-id="5820911210-2">]</span><span class="p">,</span><span class="p" data-group-id="5820911210-3">[</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;n&quot;</span><span class="p" data-group-id="5820911210-3">]</span><span class="p">,</span><span class="p" data-group-id="5820911210-4">[</span><span class="s">&quot;g&quot;</span><span class="p" data-group-id="5820911210-4">]</span><span class="p" data-group-id="5820911210-1">]</span></code></pre><p>Here the regular expression first matched the &quot;l&quot;, causing &quot;Er&quot; to be the first
part in the result. When the regular expression matched, the (only)
subexpression was bound to the &quot;l&quot;, so the &quot;l&quot; is inserted in the group together
with &quot;Er&quot;. The next match is of the &quot;n&quot;, making &quot;a&quot; the next part to be
returned. As the subexpression is bound to substring &quot;n&quot; in this case, the &quot;n&quot;
is inserted into this group. The last group consists of the remaining string, as
no more matches are found.</p><p>By default, all parts of the string, including the empty strings, are returned
from the function, for example:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="1185712057-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[lg]&quot;</span><span class="p">,</span><span class="p" data-group-id="1185712057-2">[</span><span class="p" data-group-id="1185712057-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="1185712057-3">}</span><span class="p" data-group-id="1185712057-2">]</span><span class="p" data-group-id="1185712057-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="1348760721-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;an&quot;</span><span class="p">,</span><span class="p" data-group-id="1348760721-2">[</span><span class="p" data-group-id="1348760721-2">]</span><span class="p" data-group-id="1348760721-1">]</span></code></pre><p>as the matching of the &quot;g&quot; in the end of the string leaves an empty rest, which
is also returned. This behavior differs from the default behavior of the split
function in Perl, where empty strings at the end are by default removed. To get
the &quot;trimming&quot; default behavior of Perl, specify <code class="inline">trim</code> as an option:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="9118935655-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[lg]&quot;</span><span class="p">,</span><span class="p" data-group-id="9118935655-2">[</span><span class="p" data-group-id="9118935655-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="9118935655-3">}</span><span class="p">,</span><span class="ss">trim</span><span class="p" data-group-id="9118935655-2">]</span><span class="p" data-group-id="9118935655-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="2206886433-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;an&quot;</span><span class="p" data-group-id="2206886433-1">]</span></code></pre><p>The &quot;trim&quot; option says; &quot;give me as many parts as possible except the empty
ones&quot;, which sometimes can be useful. You can also specify how many parts you
want, by specifying <code class="inline">{parts,</code>N<code class="inline">}</code>:</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="8494606631-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[lg]&quot;</span><span class="p">,</span><span class="p" data-group-id="8494606631-2">[</span><span class="p" data-group-id="8494606631-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="8494606631-3">}</span><span class="p">,</span><span class="p" data-group-id="8494606631-4">{</span><span class="ss">parts</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="8494606631-4">}</span><span class="p" data-group-id="8494606631-2">]</span><span class="p" data-group-id="8494606631-1">)</span><span class="p">.</span></code></pre><p>gives</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="7703752246-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;ang&quot;</span><span class="p" data-group-id="7703752246-1">]</span></code></pre><p>Notice that the last part is &quot;ang&quot;, not &quot;an&quot;, as splitting was specified into
two parts, and the splitting stops when enough parts are given, which is why the
result differs from that of <code class="inline">trim</code>.</p><p>More than three parts are not possible with this indata, so</p><pre><code class="makeup erlang" translate="no"><span class="nc">re</span><span class="p">:</span><span class="nf">split</span><span class="p" data-group-id="2642029550-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[lg]&quot;</span><span class="p">,</span><span class="p" data-group-id="2642029550-2">[</span><span class="p" data-group-id="2642029550-3">{</span><span class="ss">return</span><span class="p">,</span><span class="ss">list</span><span class="p" data-group-id="2642029550-3">}</span><span class="p">,</span><span class="p" data-group-id="2642029550-4">{</span><span class="ss">parts</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="2642029550-4">}</span><span class="p" data-group-id="2642029550-2">]</span><span class="p" data-group-id="2642029550-1">)</span><span class="p">.</span></code></pre><p>gives the same result as the default, which is to be viewed as &quot;an infinite
number of parts&quot;.</p><p>Specifying <code class="inline">0</code> as the number of parts gives the same effect as option <code class="inline">trim</code>. If
subexpressions are captured, empty subexpressions matched at the end are also
stripped from the result if <code class="inline">trim</code> or <code class="inline">{parts,0}</code> is specified.</p><p>The <code class="inline">trim</code> behavior corresponds exactly to the Perl default. <code class="inline">{parts,N}</code>, where
N is a positive integer, corresponds exactly to the Perl behavior with a
positive numerical third parameter. The default behavior of
<a href="#split/3"><code class="inline">split/3</code></a> corresponds to the Perl behavior when a negative integer
is specified as the third parameter for the Perl routine.</p><p>Summary of options not previously described for function <a href="#run/3"><code class="inline">run/3</code></a>:</p><ul><li><p><strong><code class="inline">{return,ReturnType}</code></strong> - Specifies how the parts of the original string are
presented in the result list. Valid types:</p><ul><li><p><strong><code class="inline">iodata</code></strong> - The variant of <a href="../../apps/erts/erlang.html#t:iodata/0"><code class="inline">iodata/0</code></a> that gives the least copying of
data with the current implementation (often a binary, but do not depend on
it).</p></li><li><p><strong><code class="inline">binary</code></strong> - All parts returned as binaries.</p></li><li><p><strong><code class="inline">list</code></strong> - All parts returned as lists of characters (&quot;strings&quot;).</p></li></ul></li><li><p><strong><code class="inline">group</code></strong> - Groups together the part of the string with the parts of the
string matching the subexpressions of the regular expression.</p><p>The return value from the function is in this case a <a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a> of
<a href="../../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a>s. Each sublist begins with the string picked out of the subject
string, followed by the parts matching each of the subexpressions in order of
occurrence in the regular expression.</p></li><li><p><strong><code class="inline">{parts,N}</code></strong> - Specifies the number of parts the subject string is to be
split into.</p><p>The number of parts is to be a positive integer for a specific maximum number
of parts, and <code class="inline">infinity</code> for the maximum number of parts possible (the
default). Specifying <code class="inline">{parts,0}</code> gives as many parts as possible disregarding
empty parts at the end, the same as specifying <code class="inline">trim</code>.</p></li><li><p><strong><code class="inline">trim</code></strong> - Specifies that empty parts at the end of the result list are to
be disregarded. The same as specifying <code class="inline">{parts,0}</code>. This corresponds to the
default behavior of the <code class="inline">split</code> built-in function in Perl.</p></li></ul>
  </section>
</section>
<section class="detail" id="version/0">

  <div class="detail-header">
    <a href="#version/0" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">version()</h1>

        <span class="note">(since OTP 20.0)</span>


        <a href="https://github.com/garazdawi/otp/blob/OTP-27.3.4.1/lib/stdlib/src/re.erl#L77" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">-spec</span> version() -> <a href="../../apps/erts/erlang.html#t:binary/0">binary</a>().</pre>

      </div>

<p>The return of this function is a string with the PCRE version of the system that
was used in the Erlang/OTP compilation.</p>
  </section>
</section>

    </div>
  </section>

    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="stdlib.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.37.3) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright Â© 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
