<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.38.1">
    <meta name="project" content="stdlib v7.0">


<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=1&q=">
<meta name="major-vsn" content="1">
<link rel="canonical" href="https://www.erlang.org/docs/1/apps/stdlib/unicode_usage.html" />
    <title>Using Unicode in Erlang — stdlib v7.0</title>

    <link rel="stylesheet" href="dist/html-erlang-ZK43ZOAC.css" />

    <script defer src="dist/sidebar_items-AA1EE98A.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-DPJLHKSM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="stdlib" />
        </a>

      <div>
        <a href="../../index.html" class="sidebar-projectName" translate="no">
stdlib
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v7.0
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of stdlib</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>Using Unicode in Erlang</h1>


      <a href="https://github.com/erlang/otp/blob/master/lib/stdlib/doc/guides/unicode_usage.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<h2 id="unicode-implementation" class="section-heading"><a href="#unicode-implementation" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Unicode Implementation</span></h2><p>Implementing support for Unicode character sets is an ongoing process. The
Erlang Enhancement Proposal (EEP) 10 outlined the basics of Unicode support and
specified a default encoding in binaries that all Unicode-aware modules are to
handle in the future.</p><p>Here is an overview what has been done so far:</p><ul><li><p>The functionality described in EEP10 was implemented in Erlang/OTP R13A.</p></li><li><p>Erlang/OTP R14B01 added support for Unicode filenames, but it was not complete
and was by default disabled on platforms where no guarantee was given for the
filename encoding.</p></li><li><p>With Erlang/OTP R16A came support for UTF-8 encoded source code, with
enhancements to many of the applications to support both Unicode encoded
filenames and support for UTF-8 encoded files in many circumstances. Most
notable is the support for UTF-8 in files read by <a href="../../apps/kernel/file.html#consult/1"><code class="inline">file:consult/1</code></a>, release
handler support for UTF-8, and more support for Unicode character sets in the
I/O system.</p></li><li><p>In Erlang/OTP 17.0, the encoding default for Erlang source files was switched
to UTF-8.</p></li><li><p>In Erlang/OTP 20.0, atoms and function can contain Unicode characters. Module
names, application names, and node names are still restricted to the ISO
Latin-1 range.</p><p>Support was added for normalizations forms in <code class="inline">unicode</code> and the <code class="inline">string</code>
module now handles utf8-encoded binaries.</p></li></ul><p>This section outlines the current Unicode support and gives some recipes for
working with Unicode data.</p><h2 id="understanding-unicode" class="section-heading"><a href="#understanding-unicode" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Understanding Unicode</span></h2><p>Experience with the Unicode support in Erlang has made it clear that
understanding Unicode characters and encodings is not as easy as one would
expect. The complexity of the field and the implications of the standard require
thorough understanding of concepts rarely before thought of.</p><p>Also, the Erlang implementation requires understanding of concepts that were
never an issue for many (Erlang) programmers. To understand and use Unicode
characters requires that you study the subject thoroughly, even if you are an
experienced programmer.</p><p>As an example, contemplate the issue of converting between upper and lower case
letters. Reading the standard makes you realize that there is not a simple one
to one mapping in all scripts, for example:</p><ul><li>In German, the letter &quot;ß&quot; (sharp s) is in lower case, but the uppercase
equivalent is &quot;SS&quot;.</li><li>In Greek, the letter &quot;Σ&quot; has two different lowercase forms, &quot;ς&quot; in word-final
position and &quot;σ&quot; elsewhere.</li><li>In Turkish, both dotted and dotless &quot;i&quot; exist in lower case and upper case
forms.</li><li>Cyrillic &quot;I&quot; has usually no lowercase form.</li><li>Languages with no concept of upper case (or lower case).</li></ul><p>So, a conversion function must know not only one character at a time, but
possibly the whole sentence, the natural language to translate to, the
differences in input and output string length, and so on. Erlang/OTP has
currently no Unicode <code class="inline">uppercase</code>/<code class="inline">lowercase</code> functionality with language
specific handling, but publicly available libraries address these issues.</p><p>Another example is the accented characters, where the same glyph has two
different representations. The Swedish letter &quot;ö&quot; is one example. The Unicode
standard has a code point for it, but you can also write it as &quot;o&quot; followed by
&quot;U+0308&quot; (Combining Diaeresis, with the simplified meaning that the last letter
is to have &quot;¨&quot; above). They have the same glyph, user perceived character. They
are for most purposes the same, but have different representations. For example,
MacOS X converts all filenames to use Combining Diaeresis, while most other
programs (including Erlang) try to hide that by doing the opposite when, for
example, listing directories. However it is done, it is usually important to
normalize such characters to avoid confusion.</p><p>The list of examples can be made long. One need a kind of knowledge that was not
needed when programs only considered one or two languages. The complexity of
human languages and scripts has certainly made this a challenge when
constructing a universal standard. Supporting Unicode properly in your program
will require effort.</p><h2 id="what-unicode-is" class="section-heading"><a href="#what-unicode-is" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">What Unicode Is</span></h2><p>Unicode is a standard defining code points (numbers) for all known, living or
dead, scripts. In principle, every symbol used in any language has a Unicode
code point. Unicode code points are defined and published by the Unicode
Consortium, which is a non-profit organization.</p><p>Support for Unicode is increasing throughout the world of computing, as the
benefits of one common character set are overwhelming when programs are used in
a global environment. Along with the base of the standard, the code points for
all the scripts, some <em>encoding standards</em> are available.</p><p>It is vital to understand the difference between encodings and Unicode
characters. Unicode characters are code points according to the Unicode
standard, while the encodings are ways to represent such code points. An
encoding is only a standard for representation. UTF-8 can, for example, be used
to represent a very limited part of the Unicode character set (for example
ISO-Latin-1) or the full Unicode range. It is only an encoding format.</p><p>As long as all character sets were limited to 256 characters, each character
could be stored in one single byte, so there was more or less only one practical
encoding for the characters. Encoding each character in one byte was so common
that the encoding was not even named. With the Unicode system there are much
more than 256 characters, so a common way is needed to represent these. The
common ways of representing the code points are the encodings. This means a
whole new concept to the programmer, the concept of character representation,
which was a non-issue earlier.</p><p>Different operating systems and tools support different encodings. For example,
Linux and MacOS X have chosen the UTF-8 encoding, which is backward compatible
with 7-bit ASCII and therefore affects programs written in plain English the
least. Windows supports a limited version of UTF-16, namely all the code planes
where the characters can be stored in one single 16-bit entity, which includes
most living languages.</p><p>The following are the most widely spread encodings:</p><ul><li><p><strong>Bytewise representation</strong> - This is not a proper Unicode representation, but
the representation used for characters before the Unicode standard. It can
still be used to represent character code points in the Unicode standard with
numbers &lt; 256, which exactly corresponds to the ISO Latin-1 character set. In
Erlang, this is commonly denoted <code class="inline">latin1</code> encoding, which is slightly
misleading as ISO Latin-1 is a character code range, not an encoding.</p></li><li><p><strong>UTF-8</strong> - Each character is stored in one to four bytes depending on code
point. The encoding is backward compatible with bytewise representation of
7-bit ASCII, as all 7-bit characters are stored in one single byte in UTF-8.
The characters beyond code point 127 are stored in more bytes, letting the
most significant bit in the first character indicate a multi-byte character.
For details on the encoding, the RFC is publicly available.</p><p>Notice that UTF-8 is <em>not</em> compatible with bytewise representation for code
points from 128 through 255, so an ISO Latin-1 bytewise representation is
generally incompatible with UTF-8.</p></li><li><p><strong>UTF-16</strong> - This encoding has many similarities to UTF-8, but the basic unit
is a 16-bit number. This means that all characters occupy at least two bytes,
and some high numbers four bytes. Some programs, libraries, and operating
systems claiming to use UTF-16 only allow for characters that can be stored in
one 16-bit entity, which is usually sufficient to handle living languages. As
the basic unit is more than one byte, byte-order issues occur, which is why
UTF-16 exists in both a big-endian and a little-endian variant.</p><p>In Erlang, the full UTF-16 range is supported when applicable, like in the
<a href="unicode.html"><code class="inline">unicode</code></a> module and in the bit syntax.</p></li><li><p><strong>UTF-32</strong> - The most straightforward representation. Each character is stored
in one single 32-bit number. There is no need for escapes or any variable
number of entities for one character. All Unicode code points can be stored in
one single 32-bit entity. As with UTF-16, there are byte-order issues. UTF-32
can be both big-endian and little-endian.</p></li><li><p><strong>UCS-4</strong> - Basically the same as UTF-32, but without some Unicode semantics,
defined by IEEE, and has little use as a separate encoding standard. For all
normal (and possibly abnormal) use, UTF-32 and UCS-4 are interchangeable.</p></li></ul><p>Certain number ranges are unused in the Unicode standard and certain ranges are
even deemed invalid. The most notable invalid range is 16#D800-16#DFFF, as the
UTF-16 encoding does not allow for encoding of these numbers. This is possibly
because the UTF-16 encoding standard, from the beginning, was expected to be
able to hold all Unicode characters in one 16-bit entity, but was then extended,
leaving a hole in the Unicode range to handle backward compatibility.</p><p>Code point 16#FEFF is used for Byte Order Marks (BOMs) and use of that character
is not encouraged in other contexts. It is valid though, as the character
&quot;ZWNBS&quot; (Zero Width Non Breaking Space). BOMs are used to identify encodings and
byte order for programs where such parameters are not known in advance. BOMs are
more seldom used than expected, but can become more widely spread as they
provide the means for programs to make educated guesses about the Unicode format
of a certain file.</p><h2 id="areas-of-unicode-support" class="section-heading"><a href="#areas-of-unicode-support" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Areas of Unicode Support</span></h2><p>To support Unicode in Erlang, problems in various areas have been addressed.
This section describes each area briefly and more thoroughly later in this
User's Guide.</p><ul><li><p><strong>Representation</strong> - To handle Unicode characters in Erlang, a common
representation in both lists and binaries is needed. EEP (10) and the
subsequent initial implementation in Erlang/OTP R13A settled a standard
representation of Unicode characters in Erlang.</p></li><li><p><strong>Manipulation</strong> - The Unicode characters need to be processed by the Erlang
program, which is why library functions must be able to handle them. In some
cases functionality has been added to already existing interfaces (as the
<a href="string.html"><code class="inline">string</code></a> module now can handle strings with any code points). In some cases
new functionality or options have been added (as in the <a href="io.html"><code class="inline">io</code></a> module, the
file handling, the <a href="unicode.html"><code class="inline">unicode</code></a> module, and the bit syntax). Today most modules
in Kernel and STDLIB, as well as the VM are Unicode-aware.</p></li><li><p><strong>File I/O</strong> - I/O is by far the most problematic area for Unicode. A file is
an entity where bytes are stored, and the lore of programming has been to
treat characters and bytes as interchangeable. With Unicode characters, you
must decide on an encoding when you want to store the data in a file. In
Erlang, you can open a text file with an encoding option, so that you can read
characters from it rather than bytes, but you can also open a file for
bytewise I/O.</p><p>The Erlang I/O-system has been designed (or at least used) in a way where you
expect any I/O server to handle any string data. That is, however, no longer
the case when working with Unicode characters. The Erlang programmer must now
know the capabilities of the device where the data ends up. Also, ports in
Erlang are byte-oriented, so an arbitrary string of (Unicode) characters
cannot be sent to a port without first converting it to an encoding of choice.</p></li><li><p><strong>Terminal I/O</strong> - Terminal I/O is slightly easier than file I/O. The output
is meant for human reading and is usually Erlang syntax (for example, in the
shell). There exists syntactic representation of any Unicode character without
displaying the glyph (instead written as <code class="inline">\x</code>{<code class="inline">HHH</code>}). Unicode data can
therefore usually be displayed even if the terminal as such does not support
the whole Unicode range.</p></li><li><p><strong>Filenames</strong> - Filenames can be stored as Unicode strings in different ways
depending on the underlying operating system and file system. This can be
handled fairly easy by a program. The problems arise when the file system is
inconsistent in its encodings. For example, Linux allows files to be named
with any sequence of bytes, leaving to each program to interpret those bytes.
On systems where these &quot;transparent&quot; filenames are used, Erlang must be
informed about the filename encoding by a startup flag. The default is
bytewise interpretation, which is usually wrong, but allows for interpretation
of <em>all</em> filenames.</p><p>The concept of &quot;raw filenames&quot; can be used to handle wrongly encoded filenames
if one enables Unicode filename translation (<code class="inline">+fnu</code>) on platforms where this
is not the default.</p></li><li><p><strong>Source code encoding</strong> - The Erlang source code has support for the UTF-8
encoding and bytewise encoding. The default in Erlang/OTP R16B was bytewise
(<code class="inline">latin1</code>) encoding. It was changed to UTF-8 in Erlang/OTP 17.0. You can
control the encoding by a comment like the following in the beginning of the
file:</p><pre><code class="makeup erlang" translate="no"><span class="c1">%% -*- coding: utf-8 -*-</span></code></pre><p>This of course requires your editor to support UTF-8 as well. The same comment
is also interpreted by functions like <a href="../../apps/kernel/file.html#consult/1"><code class="inline">file:consult/1</code></a>, the release handler,
and so on, so that you can have all text files in your source directories in
UTF-8 encoding.</p></li><li><p><strong>The language</strong> - Having the source code in UTF-8 also allows you to write
string literals, function names, and atoms containing Unicode characters with
code points &gt; 255. Module names, application names, and node names are still
restricted to the ISO Latin-1 range. Binary literals, where you use type
<code class="inline">/utf8</code>, can also be expressed using Unicode characters &gt; 255. Having module
names or application names using characters other than 7-bit ASCII can cause
trouble on operating systems with inconsistent file naming schemes, and can
hurt portability, so it is not recommended.</p><p>EEP 40 suggests that the language is also to allow for Unicode characters &gt;
255 in variable names. Whether to implement that EEP is yet to be decided.</p></li></ul><h2 id="standard-unicode-representation" class="section-heading"><a href="#standard-unicode-representation" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Standard Unicode Representation</span></h2><p>In Erlang, strings are lists of integers. A string was until Erlang/OTP R13
defined to be encoded in the ISO Latin-1 (ISO 8859-1) character set, which is,
code point by code point, a subrange of the Unicode character set.</p><p>The standard list encoding for strings was therefore easily extended to handle
the whole Unicode range. A Unicode string in Erlang is a list containing
integers, where each integer is a valid Unicode code point and represents one
character in the Unicode character set.</p><p>Erlang strings in ISO Latin-1 are a subset of Unicode strings.</p><p>Only if a string contains code points &lt; 256, can it be directly converted to a
binary by using, for example, <a href="../../apps/erts/erlang.html#iolist_to_binary/1"><code class="inline">erlang:iolist_to_binary/1</code></a> or can be sent
directly to a port. If the string contains Unicode characters &gt; 255, an encoding
must be decided upon and the string is to be converted to a binary in the
preferred encoding using
<a href="unicode.html#characters_to_binary/1"><code class="inline">unicode:characters_to_binary/1,2,3</code></a>.
Strings are not generally lists of bytes, as they were before Erlang/OTP R13,
they are lists of characters. Characters are not generally bytes, they are
Unicode code points.</p><p>Binaries are more troublesome. For performance reasons, programs often store
textual data in binaries instead of lists, mainly because they are more compact
(one byte per character instead of two words per character, as is the case with
lists). Using <a href="../../apps/erts/erlang.html#list_to_binary/1"><code class="inline">erlang:list_to_binary/1</code></a>, an ISO Latin-1 Erlang string can be
converted into a binary, effectively using bytewise encoding: one byte per
character. This was convenient for those limited Erlang strings, but cannot be
done for arbitrary Unicode lists.</p><p>As the UTF-8 encoding is widely spread and provides some backward compatibility
in the 7-bit ASCII range, it is selected as the standard encoding for Unicode
characters in binaries for Erlang.</p><p>The standard binary encoding is used whenever a library function in Erlang is to
handle Unicode data in binaries, but is of course not enforced when
communicating externally. Functions and bit syntax exist to encode and decode
both UTF-8, UTF-16, and UTF-32 in binaries. However, library functions dealing
with binaries and Unicode in general only deal with the default encoding.</p><p>Character data can be combined from many sources, sometimes available in a mix
of strings and binaries. Erlang has for long had the concept of <code class="inline">iodata</code> or
<code class="inline">iolist</code>s, where binaries and lists can be combined to represent a sequence of
bytes. In the same way, the Unicode-aware modules often allow for combinations
of binaries and lists, where the binaries have characters encoded in UTF-8 and
the lists contain such binaries or numbers representing Unicode code points:</p><pre><code class="makeup erlang" translate="no"><span class="nf">unicode_binary</span><span class="p" data-group-id="1164682817-1">(</span><span class="p" data-group-id="1164682817-1">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">binary</span><span class="p" data-group-id="1164682817-2">(</span><span class="p" data-group-id="1164682817-2">)</span><span class="w"> </span><span class="ss">with</span><span class="w"> </span><span class="ss">characters</span><span class="w"> </span><span class="ss">encoded</span><span class="w"> </span><span class="ss">in</span><span class="w"> </span><span class="n">UTF</span><span class="o">-</span><span class="mi">8</span><span class="w"> </span><span class="ss">coding</span><span class="w"> </span><span class="ss">standard</span><span class="w">

</span><span class="nf">chardata</span><span class="p" data-group-id="1164682817-3">(</span><span class="p" data-group-id="1164682817-3">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">charlist</span><span class="p" data-group-id="1164682817-4">(</span><span class="p" data-group-id="1164682817-4">)</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">unicode_binary</span><span class="p" data-group-id="1164682817-5">(</span><span class="p" data-group-id="1164682817-5">)</span><span class="w">

</span><span class="nf">charlist</span><span class="p" data-group-id="1164682817-6">(</span><span class="p" data-group-id="1164682817-6">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">maybe_improper_list</span><span class="p" data-group-id="1164682817-7">(</span><span class="nf">char</span><span class="p" data-group-id="1164682817-8">(</span><span class="p" data-group-id="1164682817-8">)</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">unicode_binary</span><span class="p" data-group-id="1164682817-9">(</span><span class="p" data-group-id="1164682817-9">)</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">charlist</span><span class="p" data-group-id="1164682817-10">(</span><span class="p" data-group-id="1164682817-10">)</span><span class="p">,</span><span class="w">
  </span><span class="nf">unicode_binary</span><span class="p" data-group-id="1164682817-11">(</span><span class="p" data-group-id="1164682817-11">)</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">nil</span><span class="p" data-group-id="1164682817-12">(</span><span class="p" data-group-id="1164682817-12">)</span><span class="p" data-group-id="1164682817-7">)</span></code></pre><p>The module <a href="unicode.html"><code class="inline">unicode</code></a> even supports similar mixes with binaries containing
other encodings than UTF-8, but that is a special case to allow for conversions
to and from external data:</p><pre><code class="makeup erlang" translate="no"><span class="nf">external_unicode_binary</span><span class="p" data-group-id="0127036951-1">(</span><span class="p" data-group-id="0127036951-1">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">binary</span><span class="p" data-group-id="0127036951-2">(</span><span class="p" data-group-id="0127036951-2">)</span><span class="w"> </span><span class="ss">with</span><span class="w"> </span><span class="ss">characters</span><span class="w"> </span><span class="ss">coded</span><span class="w"> </span><span class="ss">in</span><span class="w"> </span><span class="ss">a</span><span class="w"> </span><span class="ss">user</span><span class="o">-</span><span class="ss">specified</span><span class="w">
  </span><span class="n">Unicode</span><span class="w"> </span><span class="ss">encoding</span><span class="w"> </span><span class="ss">other</span><span class="w"> </span><span class="ss">than</span><span class="w"> </span><span class="n">UTF</span><span class="o">-</span><span class="mi">8</span><span class="w"> </span><span class="p" data-group-id="0127036951-3">(</span><span class="n">UTF</span><span class="o">-</span><span class="mi">16</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">UTF</span><span class="o">-</span><span class="mi">32</span><span class="p" data-group-id="0127036951-3">)</span><span class="w">

</span><span class="nf">external_chardata</span><span class="p" data-group-id="0127036951-4">(</span><span class="p" data-group-id="0127036951-4">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">external_charlist</span><span class="p" data-group-id="0127036951-5">(</span><span class="p" data-group-id="0127036951-5">)</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">external_unicode_binary</span><span class="p" data-group-id="0127036951-6">(</span><span class="p" data-group-id="0127036951-6">)</span><span class="w">

</span><span class="nf">external_charlist</span><span class="p" data-group-id="0127036951-7">(</span><span class="p" data-group-id="0127036951-7">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">maybe_improper_list</span><span class="p" data-group-id="0127036951-8">(</span><span class="nf">char</span><span class="p" data-group-id="0127036951-9">(</span><span class="p" data-group-id="0127036951-9">)</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">external_unicode_binary</span><span class="p" data-group-id="0127036951-10">(</span><span class="p" data-group-id="0127036951-10">)</span><span class="w"> </span><span class="p">|</span><span class="w">
  </span><span class="nf">external_charlist</span><span class="p" data-group-id="0127036951-11">(</span><span class="p" data-group-id="0127036951-11">)</span><span class="p">,</span><span class="w"> </span><span class="nf">external_unicode_binary</span><span class="p" data-group-id="0127036951-12">(</span><span class="p" data-group-id="0127036951-12">)</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">nil</span><span class="p" data-group-id="0127036951-13">(</span><span class="p" data-group-id="0127036951-13">)</span><span class="p" data-group-id="0127036951-8">)</span></code></pre><h2 id="basic-language-support" class="section-heading"><a href="#basic-language-support" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Basic Language Support</span></h2><p><a href="" id="unicode_in_erlang"></a> As from Erlang/OTP R16, Erlang source files can be
written in UTF-8 or bytewise (<code class="inline">latin1</code>) encoding. For information about how to
state the encoding of an Erlang source file, see the <a href="epp.html#encoding"><code class="inline">epp</code></a>
module. As from Erlang/OTP R16, strings and comments can be written using
Unicode. As from Erlang/OTP 20, also atoms and functions can be written using
Unicode. Modules, applications, and nodes must still be named using characters
from the ISO Latin-1 character set. (These restrictions in the language are
independent of the encoding of the source file.)</p><h3 id="bit-syntax" class="section-heading"><a href="#bit-syntax" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Bit Syntax</span></h3><p>The bit syntax contains types for handling binary data in the three main
encodings. The types are named <code class="inline">utf8</code>, <code class="inline">utf16</code>, and <code class="inline">utf32</code>. The <code class="inline">utf16</code> and
<code class="inline">utf32</code> types can be in a big-endian or a little-endian variant:</p><pre><code class="text">&lt;&lt;Ch/utf8,_/binary&gt;&gt; = Bin1,
&lt;&lt;Ch/utf16-little,_/binary&gt;&gt; = Bin2,
Bin3 = &lt;&lt;$H/utf32-little, $e/utf32-little, $l/utf32-little, $l/utf32-little,
$o/utf32-little&gt;&gt;,</code></pre><p>For convenience, literal strings can be encoded with a Unicode encoding in
binaries using the following (or similar) syntax:</p><pre><code class="text">Bin4 = &lt;&lt;&quot;Hello&quot;/utf16&gt;&gt;,</code></pre><h3 id="string-and-character-literals" class="section-heading"><a href="#string-and-character-literals" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">String and Character Literals</span></h3><p>For source code, there is an extension to syntax <code class="inline">\</code>OOO (backslash followed by
three octal numbers) and <code class="inline">\x</code>HH (backslash followed by <code class="inline">x</code>, followed by two
hexadecimal characters), namely <code class="inline">\x{</code>H ...<code class="inline">}</code> (backslash followed by <code class="inline">x</code>,
followed by left curly bracket, any number of hexadecimal digits, and a
terminating right curly bracket). This allows for entering characters of any
code point literally in a string even when the encoding of the source file is
bytewise (<code class="inline">latin1</code>).</p><p>In the shell, if using a Unicode input device, or in source code stored in
UTF-8, <code class="inline">$</code> can be followed directly by a Unicode character producing an integer.
In the following example, the code point of a Cyrillic <code class="inline">с</code> is output:</p><pre><code class="text">7&gt; $с.
1089</code></pre><h3 id="heuristic-string-detection" class="section-heading"><a href="#heuristic-string-detection" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Heuristic String Detection</span></h3><p>In certain output functions and in the output of return values in the shell,
Erlang tries to detect string data in lists and binaries heuristically.
Typically you will see heuristic detection in a situation like this:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="1043935667-1">[</span><span class="mi">97</span><span class="p">,</span><span class="mi">98</span><span class="p">,</span><span class="mi">99</span><span class="p" data-group-id="1043935667-1">]</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;abc&quot;</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="1043935667-2">&lt;&lt;</span><span class="mi">97</span><span class="p">,</span><span class="mi">98</span><span class="p">,</span><span class="mi">99</span><span class="p" data-group-id="1043935667-2">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1043935667-3">&lt;&lt;</span><span class="s">&quot;abc&quot;</span><span class="p" data-group-id="1043935667-3">&gt;&gt;</span><span class="gp unselectable">
3&gt; </span><span class="p" data-group-id="1043935667-4">&lt;&lt;</span><span class="mi">195</span><span class="p">,</span><span class="mi">165</span><span class="p">,</span><span class="mi">195</span><span class="p">,</span><span class="mi">164</span><span class="p">,</span><span class="mi">195</span><span class="p">,</span><span class="mi">182</span><span class="p" data-group-id="1043935667-4">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1043935667-5">&lt;&lt;</span><span class="s">&quot;åäö&quot;</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="1043935667-5">&gt;&gt;</span></code></pre><p>Here the shell detects lists containing printable characters or binaries
containing printable characters in bytewise or UTF-8 encoding. But what is a
printable character? One view is that anything the Unicode standard thinks is
printable, is also printable according to the heuristic detection. The result is
then that almost any list of integers are deemed a string, and all sorts of
characters are printed, maybe also characters that your terminal lacks in its
font set (resulting in some unappreciated generic output). Another way is to
keep it backward compatible so that only the ISO Latin-1 character set is used
to detect a string. A third way is to let the user decide exactly what Unicode
ranges that are to be viewed as characters.</p><p>As from Erlang/OTP R16B you can select the ISO Latin-1 range or the whole
Unicode range by supplying startup flag <code class="inline">+pc latin1</code> or <code class="inline">+pc unicode</code>,
respectively. For backward compatibility, <code class="inline">latin1</code> is default. This only
controls how heuristic string detection is done. More ranges are expected to be
added in the future, enabling tailoring of the heuristics to the language and
region relevant to the user.</p><p>The following examples show the two startup options:</p><pre><code class="makeup erlang" translate="no"><span class="sc">$ </span><span class="ss">erl</span><span class="w"> </span><span class="o">+</span><span class="ss">pc</span><span class="w"> </span><span class="ss">latin1</span><span class="w">
</span><span class="n">Erlang</span><span class="w"> </span><span class="n">R16B</span><span class="w"> </span><span class="p" data-group-id="1475789325-1">(</span><span class="ss">erts</span><span class="o">-</span><span class="mf">5.10</span><span class="p">.</span><span class="mi">1</span><span class="p" data-group-id="1475789325-1">)</span><span class="w"> </span><span class="p" data-group-id="1475789325-2">[</span><span class="ss">source</span><span class="p" data-group-id="1475789325-2">]</span><span class="w"> </span><span class="p" data-group-id="1475789325-3">[</span><span class="ss">async</span><span class="o">-</span><span class="nc">threads</span><span class="p">:</span><span class="mi">0</span><span class="p" data-group-id="1475789325-3">]</span><span class="w"> </span><span class="p" data-group-id="1475789325-4">[</span><span class="ss">hipe</span><span class="p" data-group-id="1475789325-4">]</span><span class="w"> </span><span class="p" data-group-id="1475789325-5">[</span><span class="ss">kernel</span><span class="o">-</span><span class="nc">poll</span><span class="p">:</span><span class="ss">false</span><span class="p" data-group-id="1475789325-5">]</span><span class="w">

</span><span class="n">Eshell</span><span class="w"> </span><span class="n">V5</span><span class="p">.</span><span class="mf">10.1</span><span class="w">  </span><span class="p" data-group-id="1475789325-6">(</span><span class="ss">abort</span><span class="w"> </span><span class="ss">with</span><span class="w"> </span><span class="err">^</span><span class="n">G</span><span class="p" data-group-id="1475789325-6">)</span><span class="gp unselectable">
1&gt; </span><span class="p" data-group-id="1475789325-7">[</span><span class="mi">1024</span><span class="p" data-group-id="1475789325-7">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1475789325-8">[</span><span class="mi">1024</span><span class="p" data-group-id="1475789325-8">]</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="1475789325-9">[</span><span class="mi">1070</span><span class="p">,</span><span class="mi">1085</span><span class="p">,</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1082</span><span class="p">,</span><span class="mi">1086</span><span class="p">,</span><span class="mi">1076</span><span class="p" data-group-id="1475789325-9">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1475789325-10">[</span><span class="mi">1070</span><span class="p">,</span><span class="mi">1085</span><span class="p">,</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1082</span><span class="p">,</span><span class="mi">1086</span><span class="p">,</span><span class="mi">1076</span><span class="p" data-group-id="1475789325-10">]</span><span class="gp unselectable">
3&gt; </span><span class="p" data-group-id="1475789325-11">[</span><span class="mi">229</span><span class="p">,</span><span class="mi">228</span><span class="p">,</span><span class="mi">246</span><span class="p" data-group-id="1475789325-11">]</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;åäö&quot;</span><span class="gp unselectable">
4&gt; </span><span class="p" data-group-id="1475789325-12">&lt;&lt;</span><span class="mi">208</span><span class="p">,</span><span class="mi">174</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">189</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">184</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">186</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">190</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">180</span><span class="p" data-group-id="1475789325-12">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1475789325-13">&lt;&lt;</span><span class="mi">208</span><span class="p">,</span><span class="mi">174</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">189</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">184</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">186</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">190</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">180</span><span class="p" data-group-id="1475789325-13">&gt;&gt;</span><span class="gp unselectable">
5&gt; </span><span class="p" data-group-id="1475789325-14">&lt;&lt;</span><span class="mi">229</span><span class="o">/</span><span class="ss">utf8</span><span class="p">,</span><span class="mi">228</span><span class="o">/</span><span class="ss">utf8</span><span class="p">,</span><span class="mi">246</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="1475789325-14">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1475789325-15">&lt;&lt;</span><span class="s">&quot;åäö&quot;</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="1475789325-15">&gt;&gt;</span></code></pre><pre><code class="makeup erlang" translate="no"><span class="sc">$ </span><span class="ss">erl</span><span class="w"> </span><span class="o">+</span><span class="ss">pc</span><span class="w"> </span><span class="ss">unicode</span><span class="w">
</span><span class="n">Erlang</span><span class="w"> </span><span class="n">R16B</span><span class="w"> </span><span class="p" data-group-id="6522598543-1">(</span><span class="ss">erts</span><span class="o">-</span><span class="mf">5.10</span><span class="p">.</span><span class="mi">1</span><span class="p" data-group-id="6522598543-1">)</span><span class="w"> </span><span class="p" data-group-id="6522598543-2">[</span><span class="ss">source</span><span class="p" data-group-id="6522598543-2">]</span><span class="w"> </span><span class="p" data-group-id="6522598543-3">[</span><span class="ss">async</span><span class="o">-</span><span class="nc">threads</span><span class="p">:</span><span class="mi">0</span><span class="p" data-group-id="6522598543-3">]</span><span class="w"> </span><span class="p" data-group-id="6522598543-4">[</span><span class="ss">hipe</span><span class="p" data-group-id="6522598543-4">]</span><span class="w"> </span><span class="p" data-group-id="6522598543-5">[</span><span class="ss">kernel</span><span class="o">-</span><span class="nc">poll</span><span class="p">:</span><span class="ss">false</span><span class="p" data-group-id="6522598543-5">]</span><span class="w">

</span><span class="n">Eshell</span><span class="w"> </span><span class="n">V5</span><span class="p">.</span><span class="mf">10.1</span><span class="w">  </span><span class="p" data-group-id="6522598543-6">(</span><span class="ss">abort</span><span class="w"> </span><span class="ss">with</span><span class="w"> </span><span class="err">^</span><span class="n">G</span><span class="p" data-group-id="6522598543-6">)</span><span class="gp unselectable">
1&gt; </span><span class="p" data-group-id="6522598543-7">[</span><span class="mi">1024</span><span class="p" data-group-id="6522598543-7">]</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;Ѐ&quot;</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="6522598543-8">[</span><span class="mi">1070</span><span class="p">,</span><span class="mi">1085</span><span class="p">,</span><span class="mi">1080</span><span class="p">,</span><span class="mi">1082</span><span class="p">,</span><span class="mi">1086</span><span class="p">,</span><span class="mi">1076</span><span class="p" data-group-id="6522598543-8">]</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;Юникод&quot;</span><span class="gp unselectable">
3&gt; </span><span class="p" data-group-id="6522598543-9">[</span><span class="mi">229</span><span class="p">,</span><span class="mi">228</span><span class="p">,</span><span class="mi">246</span><span class="p" data-group-id="6522598543-9">]</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;åäö&quot;</span><span class="gp unselectable">
4&gt; </span><span class="p" data-group-id="6522598543-10">&lt;&lt;</span><span class="mi">208</span><span class="p">,</span><span class="mi">174</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">189</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">184</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">186</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">190</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">180</span><span class="p" data-group-id="6522598543-10">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="6522598543-11">&lt;&lt;</span><span class="s">&quot;Юникод&quot;</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="6522598543-11">&gt;&gt;</span><span class="gp unselectable">
5&gt; </span><span class="p" data-group-id="6522598543-12">&lt;&lt;</span><span class="mi">229</span><span class="o">/</span><span class="ss">utf8</span><span class="p">,</span><span class="mi">228</span><span class="o">/</span><span class="ss">utf8</span><span class="p">,</span><span class="mi">246</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="6522598543-12">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="6522598543-13">&lt;&lt;</span><span class="s">&quot;åäö&quot;</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="6522598543-13">&gt;&gt;</span></code></pre><p>In the examples, you can see that the default Erlang shell interprets only
characters from the ISO Latin1 range as printable and only detects lists or
binaries with those &quot;printable&quot; characters as containing string data. The valid
UTF-8 binary containing the Russian word &quot;Юникод&quot;, is not printed as a string.
When started with all Unicode characters printable (<code class="inline">+pc unicode</code>), the shell
outputs anything containing printable Unicode data (in binaries, either UTF-8 or
bytewise encoded) as string data.</p><p>These heuristics are also used by <a href="io.html#format/2"><code class="inline">io:format/2</code></a>, <a href="io_lib.html#format/2"><code class="inline">io_lib:format/2</code></a>, and friends
when modifier <code class="inline">t</code> is used with <code class="inline">~p</code> or <code class="inline">~P</code>:</p><pre><code class="makeup erlang" translate="no"><span class="sc">$ </span><span class="ss">erl</span><span class="w"> </span><span class="o">+</span><span class="ss">pc</span><span class="w"> </span><span class="ss">latin1</span><span class="w">
</span><span class="n">Erlang</span><span class="w"> </span><span class="n">R16B</span><span class="w"> </span><span class="p" data-group-id="5654589239-1">(</span><span class="ss">erts</span><span class="o">-</span><span class="mf">5.10</span><span class="p">.</span><span class="mi">1</span><span class="p" data-group-id="5654589239-1">)</span><span class="w"> </span><span class="p" data-group-id="5654589239-2">[</span><span class="ss">source</span><span class="p" data-group-id="5654589239-2">]</span><span class="w"> </span><span class="p" data-group-id="5654589239-3">[</span><span class="ss">async</span><span class="o">-</span><span class="nc">threads</span><span class="p">:</span><span class="mi">0</span><span class="p" data-group-id="5654589239-3">]</span><span class="w"> </span><span class="p" data-group-id="5654589239-4">[</span><span class="ss">hipe</span><span class="p" data-group-id="5654589239-4">]</span><span class="w"> </span><span class="p" data-group-id="5654589239-5">[</span><span class="ss">kernel</span><span class="o">-</span><span class="nc">poll</span><span class="p">:</span><span class="ss">false</span><span class="p" data-group-id="5654589239-5">]</span><span class="w">

</span><span class="n">Eshell</span><span class="w"> </span><span class="n">V5</span><span class="p">.</span><span class="mf">10.1</span><span class="w">  </span><span class="p" data-group-id="5654589239-6">(</span><span class="ss">abort</span><span class="w"> </span><span class="ss">with</span><span class="w"> </span><span class="err">^</span><span class="n">G</span><span class="p" data-group-id="5654589239-6">)</span><span class="gp unselectable">
1&gt; </span><span class="nc">io</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="5654589239-7">(</span><span class="s">&quot;~tp</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="p" data-group-id="5654589239-8">[</span><span class="p" data-group-id="5654589239-9">{</span><span class="p" data-group-id="5654589239-10">&lt;&lt;</span><span class="s">&quot;åäö&quot;</span><span class="p" data-group-id="5654589239-10">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5654589239-11">&lt;&lt;</span><span class="s">&quot;åäö&quot;</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="5654589239-11">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5654589239-12">&lt;&lt;</span><span class="mi">208</span><span class="p">,</span><span class="mi">174</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">189</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">184</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">186</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">190</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">180</span><span class="p" data-group-id="5654589239-12">&gt;&gt;</span><span class="p" data-group-id="5654589239-9">}</span><span class="p" data-group-id="5654589239-8">]</span><span class="p" data-group-id="5654589239-7">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="5654589239-13">{</span><span class="p" data-group-id="5654589239-14">&lt;&lt;</span><span class="s">&quot;åäö&quot;</span><span class="p" data-group-id="5654589239-14">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="5654589239-15">&lt;&lt;</span><span class="s">&quot;åäö&quot;</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="5654589239-15">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="5654589239-16">&lt;&lt;</span><span class="mi">208</span><span class="p">,</span><span class="mi">174</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">189</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">184</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">186</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">190</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">180</span><span class="p" data-group-id="5654589239-16">&gt;&gt;</span><span class="p" data-group-id="5654589239-13">}</span><span class="w">
</span><span class="ss">ok</span></code></pre><pre><code class="makeup erlang" translate="no"><span class="sc">$ </span><span class="ss">erl</span><span class="w"> </span><span class="o">+</span><span class="ss">pc</span><span class="w"> </span><span class="ss">unicode</span><span class="w">
</span><span class="n">Erlang</span><span class="w"> </span><span class="n">R16B</span><span class="w"> </span><span class="p" data-group-id="7930044739-1">(</span><span class="ss">erts</span><span class="o">-</span><span class="mf">5.10</span><span class="p">.</span><span class="mi">1</span><span class="p" data-group-id="7930044739-1">)</span><span class="w"> </span><span class="p" data-group-id="7930044739-2">[</span><span class="ss">source</span><span class="p" data-group-id="7930044739-2">]</span><span class="w"> </span><span class="p" data-group-id="7930044739-3">[</span><span class="ss">async</span><span class="o">-</span><span class="nc">threads</span><span class="p">:</span><span class="mi">0</span><span class="p" data-group-id="7930044739-3">]</span><span class="w"> </span><span class="p" data-group-id="7930044739-4">[</span><span class="ss">hipe</span><span class="p" data-group-id="7930044739-4">]</span><span class="w"> </span><span class="p" data-group-id="7930044739-5">[</span><span class="ss">kernel</span><span class="o">-</span><span class="nc">poll</span><span class="p">:</span><span class="ss">false</span><span class="p" data-group-id="7930044739-5">]</span><span class="w">

</span><span class="n">Eshell</span><span class="w"> </span><span class="n">V5</span><span class="p">.</span><span class="mf">10.1</span><span class="w">  </span><span class="p" data-group-id="7930044739-6">(</span><span class="ss">abort</span><span class="w"> </span><span class="ss">with</span><span class="w"> </span><span class="err">^</span><span class="n">G</span><span class="p" data-group-id="7930044739-6">)</span><span class="gp unselectable">
1&gt; </span><span class="nc">io</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="7930044739-7">(</span><span class="s">&quot;~tp</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="p" data-group-id="7930044739-8">[</span><span class="p" data-group-id="7930044739-9">{</span><span class="p" data-group-id="7930044739-10">&lt;&lt;</span><span class="s">&quot;åäö&quot;</span><span class="p" data-group-id="7930044739-10">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7930044739-11">&lt;&lt;</span><span class="s">&quot;åäö&quot;</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="7930044739-11">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7930044739-12">&lt;&lt;</span><span class="mi">208</span><span class="p">,</span><span class="mi">174</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">189</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">184</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">186</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">190</span><span class="p">,</span><span class="mi">208</span><span class="p">,</span><span class="mi">180</span><span class="p" data-group-id="7930044739-12">&gt;&gt;</span><span class="p" data-group-id="7930044739-9">}</span><span class="p" data-group-id="7930044739-8">]</span><span class="p" data-group-id="7930044739-7">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="7930044739-13">{</span><span class="p" data-group-id="7930044739-14">&lt;&lt;</span><span class="s">&quot;åäö&quot;</span><span class="p" data-group-id="7930044739-14">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="7930044739-15">&lt;&lt;</span><span class="s">&quot;åäö&quot;</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="7930044739-15">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="7930044739-16">&lt;&lt;</span><span class="s">&quot;Юникод&quot;</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="7930044739-16">&gt;&gt;</span><span class="p" data-group-id="7930044739-13">}</span><span class="w">
</span><span class="ss">ok</span></code></pre><p>Notice that this only affects <em>heuristic</em> interpretation of lists and binaries
on output. For example, the <code class="inline">~ts</code> format sequence always outputs a valid list of
characters, regardless of the <code class="inline">+pc</code> setting, as the programmer has explicitly
requested string output.</p><h2 id="the-interactive-shell" class="section-heading"><a href="#the-interactive-shell" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">The Interactive Shell</span></h2><p>The interactive Erlang shell can support Unicode input and output.</p><p>On Windows, proper operation requires that a suitable font is installed and
selected for the Erlang application to use. If no suitable font is available on
your system, try installing the <a href="http://dejavu-fonts.org">DejaVu fonts</a>, which
are freely available, and then select that font in the Erlang shell application.</p><p>On Unix-like operating systems, the terminal is to be able to handle UTF-8 on
input and output (this is done by, for example, modern versions of XTerm, KDE
Konsole, and the Gnome terminal) and your locale settings must be proper. As an
example, a <code class="inline">LANG</code> environment variable can be set as follows:</p><pre><code class="text">$ echo $LANG
en_US.UTF-8</code></pre><p>Most systems handle variable <code class="inline">LC_CTYPE</code> before <code class="inline">LANG</code>, so if that is set, it
must be set to <code class="inline">UTF-8</code>:</p><pre><code class="text">$ echo $LC_CTYPE
en_US.UTF-8</code></pre><p>The <code class="inline">LANG</code> or <code class="inline">LC_CTYPE</code> setting are to be consistent with what the terminal is
capable of. There is no portable way for Erlang to ask the terminal about its
UTF-8 capacity, we have to rely on the language and character type settings.</p><p>To investigate what Erlang thinks about the terminal, the call
<a href="io.html#getopts/1"><code class="inline">io:getopts()</code></a> can be used when the shell is started:</p><pre><code class="makeup erlang" translate="no"><span class="sc">$ </span><span class="n">LC_CTYPE</span><span class="o">=</span><span class="ss">en_US</span><span class="p">.</span><span class="n">ISO</span><span class="o">-</span><span class="mi">8859</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="ss">erl</span><span class="w">
</span><span class="n">Erlang</span><span class="w"> </span><span class="n">R16B</span><span class="w"> </span><span class="p" data-group-id="6175221516-1">(</span><span class="ss">erts</span><span class="o">-</span><span class="mf">5.10</span><span class="p">.</span><span class="mi">1</span><span class="p" data-group-id="6175221516-1">)</span><span class="w"> </span><span class="p" data-group-id="6175221516-2">[</span><span class="ss">source</span><span class="p" data-group-id="6175221516-2">]</span><span class="w"> </span><span class="p" data-group-id="6175221516-3">[</span><span class="ss">async</span><span class="o">-</span><span class="nc">threads</span><span class="p">:</span><span class="mi">0</span><span class="p" data-group-id="6175221516-3">]</span><span class="w"> </span><span class="p" data-group-id="6175221516-4">[</span><span class="ss">hipe</span><span class="p" data-group-id="6175221516-4">]</span><span class="w"> </span><span class="p" data-group-id="6175221516-5">[</span><span class="ss">kernel</span><span class="o">-</span><span class="nc">poll</span><span class="p">:</span><span class="ss">false</span><span class="p" data-group-id="6175221516-5">]</span><span class="w">

</span><span class="n">Eshell</span><span class="w"> </span><span class="n">V5</span><span class="p">.</span><span class="mf">10.1</span><span class="w">  </span><span class="p" data-group-id="6175221516-6">(</span><span class="ss">abort</span><span class="w"> </span><span class="ss">with</span><span class="w"> </span><span class="err">^</span><span class="n">G</span><span class="p" data-group-id="6175221516-6">)</span><span class="gp unselectable">
1&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">keyfind</span><span class="p" data-group-id="6175221516-7">(</span><span class="ss">encoding</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nc">io</span><span class="p">:</span><span class="nf">getopts</span><span class="p" data-group-id="6175221516-8">(</span><span class="p" data-group-id="6175221516-8">)</span><span class="p" data-group-id="6175221516-7">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="6175221516-9">{</span><span class="ss">encoding</span><span class="p">,</span><span class="ss">latin1</span><span class="p" data-group-id="6175221516-9">}</span><span class="gp unselectable">
2&gt; </span><span class="nf">q</span><span class="p" data-group-id="6175221516-10">(</span><span class="p" data-group-id="6175221516-10">)</span><span class="p">.</span><span class="w">
</span><span class="ss">ok</span><span class="w">
</span><span class="sc">$ </span><span class="n">LC_CTYPE</span><span class="o">=</span><span class="ss">en_US</span><span class="p">.</span><span class="n">UTF</span><span class="o">-</span><span class="mi">8</span><span class="w"> </span><span class="ss">erl</span><span class="w">
</span><span class="n">Erlang</span><span class="w"> </span><span class="n">R16B</span><span class="w"> </span><span class="p" data-group-id="6175221516-11">(</span><span class="ss">erts</span><span class="o">-</span><span class="mf">5.10</span><span class="p">.</span><span class="mi">1</span><span class="p" data-group-id="6175221516-11">)</span><span class="w"> </span><span class="p" data-group-id="6175221516-12">[</span><span class="ss">source</span><span class="p" data-group-id="6175221516-12">]</span><span class="w"> </span><span class="p" data-group-id="6175221516-13">[</span><span class="ss">async</span><span class="o">-</span><span class="nc">threads</span><span class="p">:</span><span class="mi">0</span><span class="p" data-group-id="6175221516-13">]</span><span class="w"> </span><span class="p" data-group-id="6175221516-14">[</span><span class="ss">hipe</span><span class="p" data-group-id="6175221516-14">]</span><span class="w"> </span><span class="p" data-group-id="6175221516-15">[</span><span class="ss">kernel</span><span class="o">-</span><span class="nc">poll</span><span class="p">:</span><span class="ss">false</span><span class="p" data-group-id="6175221516-15">]</span><span class="w">

</span><span class="n">Eshell</span><span class="w"> </span><span class="n">V5</span><span class="p">.</span><span class="mf">10.1</span><span class="w">  </span><span class="p" data-group-id="6175221516-16">(</span><span class="ss">abort</span><span class="w"> </span><span class="ss">with</span><span class="w"> </span><span class="err">^</span><span class="n">G</span><span class="p" data-group-id="6175221516-16">)</span><span class="gp unselectable">
1&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">keyfind</span><span class="p" data-group-id="6175221516-17">(</span><span class="ss">encoding</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nc">io</span><span class="p">:</span><span class="nf">getopts</span><span class="p" data-group-id="6175221516-18">(</span><span class="p" data-group-id="6175221516-18">)</span><span class="p" data-group-id="6175221516-17">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="6175221516-19">{</span><span class="ss">encoding</span><span class="p">,</span><span class="ss">unicode</span><span class="p" data-group-id="6175221516-19">}</span><span class="w">
</span><span class="mi">2</span><span class="o">&gt;</span></code></pre><p>When (finally?) everything is in order with the locale settings, fonts. and the
terminal emulator, you have probably found a way to input characters in the
script you desire. For testing, the simplest way is to add some keyboard
mappings for other languages, usually done with some applet in your desktop
environment.</p><p>In a KDE environment, select <em>KDE Control Center (Personal Settings)</em> &gt;
<em>Regional and Accessibility</em> &gt; <em>Keyboard Layout</em>.</p><p>On Windows XP, select <em>Control Panel</em> &gt; <em>Regional and Language Options</em>, select
tab <em>Language</em>, and click button <em>Details...</em> in the square named <em>Text Services
and Input Languages</em>.</p><p>Your environment probably provides similar means of changing the keyboard
layout. Ensure that you have a way to switch back and forth between keyboards
easily if you are not used to this. For example, entering commands using a
Cyrillic character set is not easily done in the Erlang shell.</p><p>Now you are set up for some Unicode input and output. The simplest thing to do
is to enter a string in the shell:</p><pre><code class="makeup erlang" translate="no"><span class="sc">$ </span><span class="ss">erl</span><span class="w">
</span><span class="n">Erlang</span><span class="w"> </span><span class="n">R16B</span><span class="w"> </span><span class="p" data-group-id="5126217197-1">(</span><span class="ss">erts</span><span class="o">-</span><span class="mf">5.10</span><span class="p">.</span><span class="mi">1</span><span class="p" data-group-id="5126217197-1">)</span><span class="w"> </span><span class="p" data-group-id="5126217197-2">[</span><span class="ss">source</span><span class="p" data-group-id="5126217197-2">]</span><span class="w"> </span><span class="p" data-group-id="5126217197-3">[</span><span class="ss">async</span><span class="o">-</span><span class="nc">threads</span><span class="p">:</span><span class="mi">0</span><span class="p" data-group-id="5126217197-3">]</span><span class="w"> </span><span class="p" data-group-id="5126217197-4">[</span><span class="ss">hipe</span><span class="p" data-group-id="5126217197-4">]</span><span class="w"> </span><span class="p" data-group-id="5126217197-5">[</span><span class="ss">kernel</span><span class="o">-</span><span class="nc">poll</span><span class="p">:</span><span class="ss">false</span><span class="p" data-group-id="5126217197-5">]</span><span class="w">

</span><span class="n">Eshell</span><span class="w"> </span><span class="n">V5</span><span class="p">.</span><span class="mf">10.1</span><span class="w">  </span><span class="p" data-group-id="5126217197-6">(</span><span class="ss">abort</span><span class="w"> </span><span class="ss">with</span><span class="w"> </span><span class="err">^</span><span class="n">G</span><span class="p" data-group-id="5126217197-6">)</span><span class="gp unselectable">
1&gt; </span><span class="nc">lists</span><span class="p">:</span><span class="nf">keyfind</span><span class="p" data-group-id="5126217197-7">(</span><span class="ss">encoding</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nc">io</span><span class="p">:</span><span class="nf">getopts</span><span class="p" data-group-id="5126217197-8">(</span><span class="p" data-group-id="5126217197-8">)</span><span class="p" data-group-id="5126217197-7">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="5126217197-9">{</span><span class="ss">encoding</span><span class="p">,</span><span class="ss">unicode</span><span class="p" data-group-id="5126217197-9">}</span><span class="gp unselectable">
2&gt; </span><span class="s">&quot;Юникод&quot;</span><span class="p">.</span><span class="w">
</span><span class="s">&quot;Юникод&quot;</span><span class="gp unselectable">
3&gt; </span><span class="nc">io</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="5126217197-10">(</span><span class="s">&quot;~ts</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5126217197-11">[</span><span class="nf">v</span><span class="p" data-group-id="5126217197-12">(</span><span class="mi">2</span><span class="p" data-group-id="5126217197-12">)</span><span class="p" data-group-id="5126217197-11">]</span><span class="p" data-group-id="5126217197-10">)</span><span class="p">.</span><span class="w">
</span><span class="err">Ю</span><span class="err">н</span><span class="err">и</span><span class="err">к</span><span class="err">о</span><span class="err">д</span><span class="w">
</span><span class="ss">ok</span><span class="w">
</span><span class="mi">4</span><span class="o">&gt;</span></code></pre><p>While strings can be input as Unicode characters, the language elements are
still limited to the ISO Latin-1 character set. Only character constants and
strings are allowed to be beyond that range:</p><pre><code class="text">$ erl
Erlang R16B (erts-5.10.1) [source] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.10.1  (abort with ^G)
1&gt; $ξ.
958
2&gt; Юникод.
* 1: illegal character
2&gt;</code></pre><h2 id="escripts-and-non-interactive-i-o" class="section-heading"><a href="#escripts-and-non-interactive-i-o" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Escripts and non-interactive I/O</span></h2><p>When Erlang is started without an interactive shell (<code class="inline">-noshell</code>, <code class="inline">-noinput</code> or
as an escript) the unicode support is identified using environment variables
just as for <a href="unicode_usage.html#the-interactive-shell">interactive shells</a>.
Working with unicode in non-interactive sessions works just the same as for
interactive sessions.</p><p>In some situations you may need to be able to read and write raw bytes from
<a href="io.html#t:standard_io/0"><code class="inline">standard_io</code></a>. If that is the case, then you want to set
the <a href="../../apps/kernel/kernel_app.html#standard_io_encoding">standard_io_encoding</a>
configuration parameter to <code class="inline">latin1</code> and use the <a href="../../apps/kernel/file.html"><code class="inline">file</code></a> API to read and write
data (as explained in
<a href="unicode_usage.html#unicode-data-in-files">Unicode Data in Files</a>).</p><p>In the example below we first read the character <code class="inline">ξ</code> from
<a href="io.html#t:standard_io/0"><code class="inline">standard_io</code></a> and then print the
<a href="unicode.html#t:charlist/0">charlist()</a> represented by it.</p><pre><code class="makeup erlang" translate="no"><span class="ch">#!/usr/bin/env escript
</span><span class="c1">%%! -kernel standard_io_encoding latin1</span><span class="w">

</span><span class="nf">main</span><span class="p" data-group-id="3306824776-1">(</span><span class="p">_</span><span class="p" data-group-id="3306824776-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
  </span><span class="p" data-group-id="3306824776-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">Char</span><span class="p" data-group-id="3306824776-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">read_line</span><span class="p" data-group-id="3306824776-3">(</span><span class="ss">standard_io</span><span class="p" data-group-id="3306824776-3">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">write</span><span class="p" data-group-id="3306824776-4">(</span><span class="ss">standard_io</span><span class="p">,</span><span class="w"> </span><span class="nc">string</span><span class="p">:</span><span class="nf">trim</span><span class="p" data-group-id="3306824776-5">(</span><span class="n">Char</span><span class="p" data-group-id="3306824776-5">)</span><span class="p" data-group-id="3306824776-4">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">write</span><span class="p" data-group-id="3306824776-6">(</span><span class="ss">standard_io</span><span class="p">,</span><span class="w"> </span><span class="nc">io_lib</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="3306824776-7">(</span><span class="s">&quot;: </span><span class="si">~w</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="p" data-group-id="3306824776-8">[</span><span class="nc">string</span><span class="p">:</span><span class="nf">trim</span><span class="p" data-group-id="3306824776-9">(</span><span class="n">Char</span><span class="p" data-group-id="3306824776-9">)</span><span class="p" data-group-id="3306824776-8">]</span><span class="p" data-group-id="3306824776-7">)</span><span class="p" data-group-id="3306824776-6">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">ok</span><span class="p">.</span></code></pre><pre><code class="text">$ escript test.es
ξ
ξ: [206,190]</code></pre><p><code class="inline">ξ</code> would normally be represented as the integer 958, but since we are using
bytewise encoding (<code class="inline">latin1</code>), it is represented by 206 and 190, which is the
utf-8 bytes representing <code class="inline">ξ</code>. When we echo those bytes back to
<a href="io.html#t:standard_io/0"><code class="inline">standard_io</code></a>, the terminal will see the bytes as utf-8
and show the correct value even though in Erlang we never knew that it was
indeed a unicode string.</p><p><a href="" id="unicode_file_names"></a></p><h2 id="unicode-filenames" class="section-heading"><a href="#unicode-filenames" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Unicode Filenames</span></h2><p>Most modern operating systems support Unicode filenames in some way. There are
many different ways to do this and Erlang by default treats the different
approaches differently:</p><ul><li><p><strong>Mandatory Unicode file naming</strong> - Windows, Android and, for most cases,
MacOS X enforce Unicode support for filenames. All files created in the file
system have names that can consistently be interpreted. In MacOS X and
Android, all filenames are retrieved in UTF-8 encoding. In Windows, each
system call handling filenames has a special Unicode-aware variant, giving
much the same effect. There are no filenames on these systems that are not
Unicode filenames. So, the default behavior of the Erlang VM is to work in
&quot;Unicode filename translation mode&quot;. This means that a filename can be
specified as a Unicode list, which is automatically translated to the proper
name encoding for the underlying operating system and file system.</p><p>Doing, for example, a <a href="../../apps/kernel/file.html#list_dir/1"><code class="inline">file:list_dir/1</code></a> on one of these systems can return
Unicode lists with code points &gt; 255, depending on the content of the file
system.</p></li><li><p><strong>Transparent file naming</strong> - Most Unix operating systems have adopted a
simpler approach, namely that Unicode file naming is not enforced, but by
convention. Those systems usually use UTF-8 encoding for Unicode filenames,
but do not enforce it. On such a system, a filename containing characters with
code points from 128 through 255 can be named as plain ISO Latin-1 or use
UTF-8 encoding. As no consistency is enforced, the Erlang VM cannot do
consistent translation of all filenames.</p><p>By default on such systems, Erlang starts in <code class="inline">utf8</code> filename mode if the
terminal supports UTF-8, otherwise in <code class="inline">latin1</code> mode.</p><p>In <code class="inline">latin1</code> mode, filenames are bytewise encoded. This allows for list
representation of all filenames in the system. However, a a file named
&quot;Östersund.txt&quot;, appears in <a href="../../apps/kernel/file.html#list_dir/1"><code class="inline">file:list_dir/1</code></a> either as &quot;Östersund.txt&quot; (if
the filename was encoded in bytewise ISO Latin-1 by the program creating the
file) or more probably as <code class="inline">[195,150,115,116,101,114,115,117,110,100]</code>, which
is a list containing UTF-8 bytes (not what you want). If you use Unicode
filename translation on such a system, non-UTF-8 filenames are ignored by
functions like <a href="../../apps/kernel/file.html#list_dir/1"><code class="inline">file:list_dir/1</code></a>. They can be retrieved with function
<a href="../../apps/kernel/file.html#list_dir_all/1"><code class="inline">file:list_dir_all/1</code></a>, but wrongly encoded filenames appear as &quot;raw
filenames&quot;.</p></li></ul><p>The Unicode file naming support was introduced in Erlang/OTP R14B01. A VM
operating in Unicode filename translation mode can work with files having names
in any language or character set (as long as it is supported by the underlying
operating system and file system). The Unicode character list is used to denote
filenames or directory names. If the file system content is listed, you also get
Unicode lists as return value. The support lies in the Kernel and STDLIB
modules, which is why most applications (that do not explicitly require the
filenames to be in the ISO Latin-1 range) benefit from the Unicode support
without change.</p><p>On operating systems with mandatory Unicode filenames, this means that you more
easily conform to the filenames of other (non-Erlang) applications. You can also
process filenames that, at least on Windows, were inaccessible (because of
having names that could not be represented in ISO Latin-1). Also, you avoid
creating incomprehensible filenames on MacOS X, as the <code class="inline">vfs</code> layer of the
operating system accepts all your filenames as UTF-8 does not rewrite them.</p><p>For most systems, turning on Unicode filename translation is no problem even if
it uses transparent file naming. Very few systems have mixed filename encodings.
A consistent UTF-8 named system works perfectly in Unicode filename mode. It was
still, however, considered experimental in Erlang/OTP R14B01 and is still not
the default on such systems.</p><p>Unicode filename translation is turned on with switch <code class="inline">+fnu</code>. On Linux, a VM
started without explicitly stating the filename translation mode defaults to
<code class="inline">latin1</code> as the native filename encoding. On Windows, MacOS X and Android, the
default behavior is that of Unicode filename translation. Therefore
<a href="../../apps/kernel/file.html#native_name_encoding/0"><code class="inline">file:native_name_encoding/0</code></a> by default returns <code class="inline">utf8</code> on those systems
(Windows does not use UTF-8 on the file system level, but this can safely be
ignored by the Erlang programmer). The default behavior can, as stated earlier,
be changed using option <code class="inline">+fnu</code> or <code class="inline">+fnl</code> to the VM, see the
<a href="../../apps/erts/erl_cmd.html"><code class="inline">erl</code></a> program. If the VM is started in Unicode filename
translation mode, <a href="../../apps/kernel/file.html#native_name_encoding/0"><code class="inline">file:native_name_encoding/0</code></a> returns atom <code class="inline">utf8</code>. Switch
<code class="inline">+fnu</code> can be followed by <code class="inline">w</code>, <code class="inline">i</code>, or <code class="inline">e</code> to control how wrongly encoded
filenames are to be reported.</p><ul><li><code class="inline">w</code> means that a warning is sent to the <code class="inline">error_logger</code> whenever a wrongly
encoded filename is &quot;skipped&quot; in directory listings. <code class="inline">w</code> is the default.</li><li><code class="inline">i</code> means that wrongly encoded filenames are silently ignored.</li><li><code class="inline">e</code> means that the API function returns an error whenever a wrongly encoded
filename (or directory name) is encountered.</li></ul><p>Notice that <a href="../../apps/kernel/file.html#read_link/1"><code class="inline">file:read_link/1</code></a> always returns an error if the link points to an
invalid filename.</p><p>In Unicode filename mode, filenames given to BIF <a href="../../apps/erts/erlang.html#open_port/2"><code class="inline">open_port/2</code></a>
with option <code class="inline">{spawn_executable,...}</code> are also interpreted as Unicode. So is the
parameter list specified in option <code class="inline">args</code> available when using
<code class="inline">spawn_executable</code>. The UTF-8 translation of arguments can be avoided using
binaries, see section
<a href="unicode_usage.html#notes-about-raw-filenames">Notes About Raw Filenames</a>.</p><p>Notice that the file encoding options specified when opening a file has nothing
to do with the filename encoding convention. You can very well open files
containing data encoded in UTF-8, but having filenames in bytewise (<code class="inline">latin1</code>)
encoding or conversely.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Erlang drivers and NIF-shared objects still cannot be named with names
containing code points &gt; 127. This limitation will be removed in a future
release. However, Erlang modules can, but it is definitely not a good idea and
is still considered experimental.</p></section><h3 id="notes-about-raw-filenames" class="section-heading"><a href="#notes-about-raw-filenames" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Notes About Raw Filenames</span></h3><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Note that raw filenames <em>not</em> necessarily are encoded the same way as on the
OS level.</p></section><p>Raw filenames were introduced together with Unicode filename support in ERTS
5.8.2 (Erlang/OTP R14B01). The reason &quot;raw filenames&quot; were introduced in the
system was to be able to represent filenames, specified in different encodings
on the same system, consistently. It can seem practical to have the VM
automatically translate a filename that is not in UTF-8 to a list of Unicode
characters, but this would open up for both duplicate filenames and other
inconsistent behavior.</p><p>Consider a directory containing a file named &quot;björn&quot; in ISO Latin-1, while the
Erlang VM is operating in Unicode filename mode (and therefore expects UTF-8
file naming). The ISO Latin-1 name is not valid UTF-8 and one can be tempted to
think that automatic conversion in, for example, <a href="../../apps/kernel/file.html#list_dir/1"><code class="inline">file:list_dir/1</code></a> is a good
idea. But what would happen if we later tried to open the file and have the name
as a Unicode list (magically converted from the ISO Latin-1 filename)? The VM
converts the filename to UTF-8, as this is the encoding expected. Effectively
this means trying to open the file named &lt;&lt;&quot;björn&quot;/utf8&gt;&gt;. This file does not
exist, and even if it existed it would not be the same file as the one that was
listed. We could even create two files named &quot;björn&quot;, one named in UTF-8
encoding and one not. If <a href="../../apps/kernel/file.html#list_dir/1"><code class="inline">file:list_dir/1</code></a> would automatically convert the ISO
Latin-1 filename to a list, we would get two identical filenames as the result.
To avoid this, we must differentiate between filenames that are properly encoded
according to the Unicode file naming convention (that is, UTF-8) and filenames
that are invalid under the encoding. By the common function <a href="../../apps/kernel/file.html#list_dir/1"><code class="inline">file:list_dir/1</code></a>,
the wrongly encoded filenames are ignored in Unicode filename translation mode,
but by function <a href="../../apps/kernel/file.html#list_dir_all/1"><code class="inline">file:list_dir_all/1</code></a> the filenames with invalid encoding are
returned as &quot;raw&quot; filenames, that is, as binaries.</p><p>The <code class="inline">file</code> module accepts raw filenames as input.
<code class="inline">open_port({spawn_executable, ...} ...)</code> also accepts them. As mentioned
earlier, the arguments specified in the option list to
<code class="inline">open_port({spawn_executable, ...} ...)</code> undergo the same conversion as the
filenames, meaning that the executable is provided with arguments in UTF-8 as
well. This translation is avoided consistently with how the filenames are
treated, by giving the argument as a binary.</p><p>To force Unicode filename translation mode on systems where this is not the
default was considered experimental in Erlang/OTP R14B01. This was because the
initial implementation did not ignore wrongly encoded filenames, so that raw
filenames could spread unexpectedly throughout the system. As from Erlang/OTP
R16B, the wrongly encoded filenames are only retrieved by special functions
(such as <a href="../../apps/kernel/file.html#list_dir_all/1"><code class="inline">file:list_dir_all/1</code></a>). Since the impact on existing code is therefore
much lower it is now supported. Unicode filename translation is expected to be
default in future releases.</p><p>Even if you are operating without Unicode file naming translation automatically
done by the VM, you can access and create files with names in UTF-8 encoding by
using raw filenames encoded as UTF-8. Enforcing the UTF-8 encoding regardless of
the mode the Erlang VM is started in can in some circumstances be a good idea,
as the convention of using UTF-8 filenames is spreading.</p><h3 id="notes-about-macos-x" class="section-heading"><a href="#notes-about-macos-x" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Notes About MacOS X</span></h3><p>The <code class="inline">vfs</code> layer of MacOS X enforces UTF-8 filenames in an aggressive way. Older
versions did this by refusing to create non-UTF-8 conforming filenames, while
newer versions replace offending bytes with the sequence &quot;%HH&quot;, where HH is the
original character in hexadecimal notation. As Unicode translation is enabled by
default on MacOS X, the only way to come up against this is to either start the
VM with flag <code class="inline">+fnl</code> or to use a raw filename in bytewise (<code class="inline">latin1</code>) encoding. If
using a raw filename, with a bytewise encoding containing characters from 127
through 255, to create a file, the file cannot be opened using the same name as
the one used to create it. There is no remedy for this behavior, except keeping
the filenames in the correct encoding.</p><p>MacOS X reorganizes the filenames so that the representation of accents, and so
on, uses the &quot;combining characters&quot;. For example, character <code class="inline">ö</code> is represented
as code points <code class="inline">[111,776]</code>, where <code class="inline">111</code> is character <code class="inline">o</code> and <code class="inline">776</code> is the
special accent character &quot;Combining Diaeresis&quot;. This way of normalizing Unicode
is otherwise very seldom used. Erlang normalizes those filenames in the opposite
way upon retrieval, so that filenames using combining accents are not passed up
to the Erlang application. In Erlang, filename &quot;björn&quot; is retrieved as
<code class="inline">[98,106,246,114,110]</code>, not as <code class="inline">[98,106,117,776,114,110]</code>, although the file
system can think differently. The normalization into combining accents is redone
when accessing files, so this can usually be ignored by the Erlang programmer.</p><h2 id="unicode-in-environment-and-parameters" class="section-heading"><a href="#unicode-in-environment-and-parameters" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Unicode in Environment and Parameters</span></h2><p><a href="" id="unicode_in_environment_and_parameters"></a></p><p>Environment variables and their interpretation are handled much in the same way
as filenames. If Unicode filenames are enabled, environment variables as well as
parameters to the Erlang VM are expected to be in Unicode.</p><p>If Unicode filenames are enabled, the calls to <a href="../../apps/kernel/os.html#getenv/0"><code class="inline">os:getenv/0,1</code></a>,
<a href="../../apps/kernel/os.html#putenv/2"><code class="inline">os:putenv/2</code></a>, and <a href="../../apps/kernel/os.html#unsetenv/1"><code class="inline">os:unsetenv/1</code></a> handle Unicode strings. On Unix-like
platforms, the built-in functions translate environment variables in UTF-8
to/from Unicode strings, possibly with code points &gt; 255. On Windows, the
Unicode versions of the environment system API are used, and code points &gt; 255
are allowed.</p><p>On Unix-like operating systems, parameters are expected to be UTF-8 without
translation if Unicode filenames are enabled.</p><h2 id="unicode-aware-modules" class="section-heading"><a href="#unicode-aware-modules" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Unicode-Aware Modules</span></h2><p>Most of the modules in Erlang/OTP are Unicode-unaware in the sense that they
have no notion of Unicode and should not have. Typically they handle non-textual
or byte-oriented data (such as <code class="inline">gen_tcp</code>).</p><p>Modules handling textual data (such as <a href="io_lib.html"><code class="inline">io_lib</code></a> and <a href="string.html"><code class="inline">string</code></a> are sometimes
subject to conversion or extension to be able to handle Unicode characters.</p><p>Fortunately, most textual data has been stored in lists and range checking has
been sparse, so modules like <code class="inline">string</code> work well for Unicode strings with little
need for conversion or extension.</p><p>Some modules are, however, changed to be explicitly Unicode-aware. These modules
include:</p><ul><li><p><strong><code class="inline">unicode</code></strong> - The <a href="unicode.html"><code class="inline">unicode</code></a> module is clearly Unicode-aware. It contains
functions for conversion between different Unicode formats and some utilities
for identifying byte order marks. Few programs handling Unicode data survive
without this module.</p></li><li><p><strong><code class="inline">io</code></strong> - The <a href="io.html"><code class="inline">io</code></a> module has been extended along with the actual I/O
protocol to handle Unicode data. This means that many functions require
binaries to be in UTF-8, and there are modifiers to format control sequences
to allow for output of Unicode strings.</p></li><li><p><strong><code class="inline">file</code>, <code class="inline">group</code>, <code class="inline">user</code></strong> - I/O-servers throughout the system can handle
Unicode data and have options for converting data upon output or input to/from
the device. As shown earlier, the <a href="shell.html"><code class="inline">shell</code></a> module has support for Unicode
terminals and the <a href="../../apps/kernel/file.html"><code class="inline">file</code></a> module allows for translation to and from various
Unicode formats on disk.</p><p>Reading and writing of files with Unicode data is, however, not best done with
the <code class="inline">file</code> module, as its interface is byte-oriented. A file opened with a
Unicode encoding (like UTF-8) is best read or written using the <a href="io.html"><code class="inline">io</code></a> module.</p></li><li><p><strong><code class="inline">re</code></strong> - The <a href="re.html"><code class="inline">re</code></a> module allows for matching Unicode strings as a special
option. As the library is centered on matching in binaries, the Unicode
support is UTF-8-centered.</p></li><li><p><strong><code class="inline">wx</code></strong> - The graphical library <a href="../../apps/wx/wx.html"><code class="inline">wx</code></a> has extensive support for Unicode
text.</p></li></ul><p>The <a href="string.html"><code class="inline">string</code></a> module works perfectly for Unicode strings and ISO Latin-1
strings, except the language-dependent functions <a href="string.html#uppercase/1"><code class="inline">string:uppercase/1</code></a> and
<a href="string.html#lowercase/1"><code class="inline">string:lowercase/1</code></a>. These two functions can never function correctly for
Unicode characters in their current form, as there are language and locale
issues to consider when converting text between cases. Converting case in an
international environment is a large subject not yet addressed in OTP.</p><h2 id="unicode-data-in-files" class="section-heading"><a href="#unicode-data-in-files" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Unicode Data in Files</span></h2><p>Although Erlang can handle Unicode data in many forms does not automatically
mean that the content of any file can be Unicode text. The external entities,
such as ports and I/O servers, are not generally Unicode capable.</p><p>Ports are always byte-oriented, so before sending data that you are not sure is
bytewise-encoded to a port, ensure to encode it in a proper Unicode encoding.
Sometimes this means that only part of the data must be encoded as, for example,
UTF-8. Some parts can be binary data (like a length indicator) or something else
that must not undergo character encoding, so no automatic translation is
present.</p><p>I/O servers behave a little differently. The I/O servers connected to terminals
(or <code class="inline">stdout</code>) can usually cope with Unicode data regardless of the encoding
option. This is convenient when one expects a modern environment but do not want
to crash when writing to an archaic terminal or pipe.</p><p>A file can have an encoding option that makes it generally usable by the <a href="io.html"><code class="inline">io</code></a>
module (for example <code class="inline">{encoding,utf8}</code>), but is by default opened as a
byte-oriented file. The <a href="../../apps/kernel/file.html"><code class="inline">file</code></a> module is byte-oriented, so only ISO Latin-1
characters can be written using that module. Use the <code class="inline">io</code> module if Unicode data
is to be output to a file with other <code class="inline">encoding</code> than <code class="inline">latin1</code> (bytewise
encoding). It is slightly confusing that a file opened with, for example,
<code class="inline">file:open(Name,[read,{encoding,utf8}])</code> cannot be properly read using
<code class="inline">file:read(File,N)</code>, but using the <code class="inline">io</code> module to retrieve the Unicode data from
it. The reason is that <code class="inline">file:read</code> and <code class="inline">file:write</code> (and friends) are purely
byte-oriented, and should be, as that is the way to access files other than text
files, byte by byte. As with ports, you can write encoded data into a file by
&quot;manually&quot; converting the data to the encoding of choice (using the <a href="unicode.html"><code class="inline">unicode</code></a>
module or the bit syntax) and then output it on a bytewise (<code class="inline">latin1</code>) encoded
file.</p><p>Recommendations:</p><ul><li>Use the <a href="../../apps/kernel/file.html"><code class="inline">file</code></a> module for files opened for bytewise access
(<code class="inline">{encoding,latin1}</code>).</li><li>Use the <a href="io.html"><code class="inline">io</code></a> module when accessing files with any other encoding (for
example <code class="inline">{encoding,utf8}</code>).</li></ul><p>Functions reading Erlang syntax from files recognize the <code class="inline">coding:</code> comment and
can therefore handle Unicode data on input. When writing Erlang terms to a file,
you are advised to insert such comments when applicable:</p><pre><code class="makeup erlang" translate="no"><span class="sc">$ </span><span class="ss">erl</span><span class="w"> </span><span class="o">+</span><span class="ss">fna</span><span class="w"> </span><span class="o">+</span><span class="ss">pc</span><span class="w"> </span><span class="ss">unicode</span><span class="w">
</span><span class="n">Erlang</span><span class="w"> </span><span class="n">R16B</span><span class="w"> </span><span class="p" data-group-id="2525401117-1">(</span><span class="ss">erts</span><span class="o">-</span><span class="mf">5.10</span><span class="p">.</span><span class="mi">1</span><span class="p" data-group-id="2525401117-1">)</span><span class="w"> </span><span class="p" data-group-id="2525401117-2">[</span><span class="ss">source</span><span class="p" data-group-id="2525401117-2">]</span><span class="w">  </span><span class="p" data-group-id="2525401117-3">[</span><span class="ss">async</span><span class="o">-</span><span class="nc">threads</span><span class="p">:</span><span class="mi">0</span><span class="p" data-group-id="2525401117-3">]</span><span class="w"> </span><span class="p" data-group-id="2525401117-4">[</span><span class="ss">hipe</span><span class="p" data-group-id="2525401117-4">]</span><span class="w"> </span><span class="p" data-group-id="2525401117-5">[</span><span class="ss">kernel</span><span class="o">-</span><span class="nc">poll</span><span class="p">:</span><span class="ss">false</span><span class="p" data-group-id="2525401117-5">]</span><span class="w">

</span><span class="n">Eshell</span><span class="w"> </span><span class="n">V5</span><span class="p">.</span><span class="mf">10.1</span><span class="w">  </span><span class="p" data-group-id="2525401117-6">(</span><span class="ss">abort</span><span class="w"> </span><span class="ss">with</span><span class="w"> </span><span class="err">^</span><span class="n">G</span><span class="p" data-group-id="2525401117-6">)</span><span class="gp unselectable">
1&gt; </span><span class="nc">file</span><span class="p">:</span><span class="nf">write_file</span><span class="p" data-group-id="2525401117-7">(</span><span class="s">&quot;test.term&quot;</span><span class="p">,</span><span class="p" data-group-id="2525401117-8">&lt;&lt;</span><span class="s">&quot;%% coding: utf-8\n[{\&quot;Юникод\&quot;,4711}].\n&quot;</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="2525401117-8">&gt;&gt;</span><span class="p" data-group-id="2525401117-7">)</span><span class="p">.</span><span class="w">
</span><span class="ss">ok</span><span class="gp unselectable">
2&gt; </span><span class="nc">file</span><span class="p">:</span><span class="nf">consult</span><span class="p" data-group-id="2525401117-9">(</span><span class="s">&quot;test.term&quot;</span><span class="p" data-group-id="2525401117-9">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2525401117-10">{</span><span class="ss">ok</span><span class="p">,</span><span class="p" data-group-id="2525401117-11">[</span><span class="p" data-group-id="2525401117-12">[</span><span class="p" data-group-id="2525401117-13">{</span><span class="s">&quot;Юникод&quot;</span><span class="p">,</span><span class="mi">4711</span><span class="p" data-group-id="2525401117-13">}</span><span class="p" data-group-id="2525401117-12">]</span><span class="p" data-group-id="2525401117-11">]</span><span class="p" data-group-id="2525401117-10">}</span></code></pre><h2 id="summary-of-options" class="section-heading"><a href="#summary-of-options" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Summary of Options</span></h2><p><a href="" id="unicode_options_summary"></a></p><p>The Unicode support is controlled by both command-line switches, some standard
environment variables, and the OTP version you are using. Most options affect
mainly how Unicode data is displayed, not the functionality of the APIs in the
standard libraries. This means that Erlang programs usually do not need to
concern themselves with these options, they are more for the development
environment. An Erlang program can be written so that it works well regardless
of the type of system or the Unicode options that are in effect.</p><p>Here follows a summary of the settings affecting Unicode:</p><ul><li><p><strong>The <code class="inline">LANG</code> and <code class="inline">LC_CTYPE</code> environment variables</strong> - The language setting in
the operating system mainly affects the shell. The terminal (that is, the
group leader) operates with <code class="inline">{encoding, unicode}</code> only if the environment
tells it that UTF-8 is allowed. This setting is to correspond to the terminal
you are using.</p><p>The environment can also affect filename interpretation, if Erlang is started
with flag <code class="inline">+fna</code> (which is default from Erlang/OTP 17.0).</p><p>You can check the setting of this by calling <a href="io.html#getopts/1"><code class="inline">io:getopts()</code></a>,
which gives you an option list containing <code class="inline">{encoding,unicode}</code> or
<code class="inline">{encoding,latin1}</code>.</p></li><li><p><strong>The <code class="inline">+pc</code> {<code class="inline">unicode</code>|<code class="inline">latin1</code>} flag to <a href="../../apps/erts/erl_cmd.html"><code class="inline">erl(1)</code></a></strong> -
This flag affects what is interpreted as string data when doing heuristic
string detection in the shell and in <a href="io.html"><code class="inline">io</code></a>/
<a href="io_lib.html#format/2"><code class="inline">io_lib:format</code></a> with the <code class="inline">&quot;~tp&quot;</code> and <code class="inline">~tP</code> formatting
instructions, as described earlier.</p><p>You can check this option by calling <a href="io.html#printable_range/0"><code class="inline">io:printable_range/0</code></a>, which returns
<code class="inline">unicode</code> or <code class="inline">latin1</code>. To be compatible with future (expected) extensions to
the settings, rather use <a href="io_lib.html#printable_list/1"><code class="inline">io_lib:printable_list/1</code></a> to check if a list is
printable according to the setting. That function takes into account new
possible settings returned from <a href="io.html#printable_range/0"><code class="inline">io:printable_range/0</code></a>.</p></li><li><p><strong>The <code class="inline">+fn</code>{<code class="inline">l</code>|<code class="inline">u</code>|<code class="inline">a</code>} [{<code class="inline">w</code>|<code class="inline">i</code>|<code class="inline">e</code>}] flag to
<a href="../../apps/erts/erl_cmd.html"><code class="inline">erl(1)</code></a></strong> - This flag affects how the filenames are to
be interpreted. On operating systems with transparent file naming, this must
be specified to allow for file naming in Unicode characters (and for correct
interpretation of filenames containing characters &gt; 255).</p><ul><li><code class="inline">+fnl</code> means bytewise interpretation of filenames, which was the usual way
to represent ISO Latin-1 filenames before UTF-8 file naming got widespread.</li><li><code class="inline">+fnu</code> means that filenames are encoded in UTF-8, which is nowadays the
common scheme (although not enforced).</li><li><code class="inline">+fna</code> means that you automatically select between <code class="inline">+fnl</code> and <code class="inline">+fnu</code>, based
on environment variables <code class="inline">LANG</code> and <code class="inline">LC_CTYPE</code>. This is optimistic
heuristics indeed, nothing enforces a user to have a terminal with the same
encoding as the file system, but this is usually the case. This is the
default on all Unix-like operating systems, except MacOS X.</li></ul><p>The filename translation mode can be read with function
<a href="../../apps/kernel/file.html#native_name_encoding/0"><code class="inline">file:native_name_encoding/0</code></a>, which returns <code class="inline">latin1</code> (bytewise encoding) or
<code class="inline">utf8</code>.</p></li><li><p><strong><a href="epp.html#default_encoding/0"><code class="inline">epp:default_encoding/0</code></a></strong> - This function returns the default encoding for
Erlang source files (if no encoding comment is present) in the currently
running release. In Erlang/OTP R16B, <code class="inline">latin1</code> (bytewise encoding) was
returned. As from Erlang/OTP 17.0, <code class="inline">utf8</code> is returned.</p><p>The encoding of each file can be specified using comments as described in the
<a href="epp.html#encoding"><code class="inline">epp</code></a> module.</p></li><li><p><strong><a href="io.html#setopts/1"><code class="inline">io:setopts/1,2</code></a> and
<a href="../../apps/kernel/kernel_app.html#standard_io_encoding"><code class="inline">standard_io_encoding</code></a></strong> -
When Erlang is started the encoding for <a href="io.html#t:standard_io/0"><code class="inline">standard_io</code></a>
is by default set to what the
<a href="unicode_usage.html#the-interactive-shell">locale settings indicate</a>. You can
override the default by setting the kernel configuration parameter
<a href="../../apps/kernel/kernel_app.html#standard_io_encoding"><code class="inline">standard_io_encoding</code></a> to the
desired encoding.</p><p>You can set the encoding of a file or other I/O server with function
<a href="io.html#setopts/1"><code class="inline">io:setopts/2</code></a>. This can also be set when opening a file.
Setting the terminal (or other <a href="io.html#t:standard_io/0"><code class="inline">standard_io</code></a> server)
unconditionally to option <code class="inline">{encoding,utf8}</code> implies that UTF-8 encoded
characters are written to the device, regardless of how Erlang was started or
the user's environment.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>If you use <a href="io.html#setopts/1"><code class="inline">io:setopts/2</code></a> to change the encoding of
<a href="io.html#t:standard_io/0"><code class="inline">standard_io</code></a> the I/O server may already have read
some data using the default encoding. To avoid this you should set the
encoding using
<a href="../../apps/kernel/kernel_app.html#standard_io_encoding"><code class="inline">standard_io_encoding</code></a>.</p></section><p>Opening files with option <code class="inline">encoding</code> is convenient when writing or reading
text files in a known encoding.</p><p>You can retrieve the <code class="inline">encoding</code> setting for an I/O server with function
<a href="io.html#getopts/1"><code class="inline">io:getopts()</code></a>.</p></li></ul><h2 id="recipes" class="section-heading"><a href="#recipes" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Recipes</span></h2><p>When starting with Unicode, one often stumbles over some common issues. This
section describes some methods of dealing with Unicode data.</p><h3 id="byte-order-marks" class="section-heading"><a href="#byte-order-marks" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Byte Order Marks</span></h3><p>A common method of identifying encoding in text files is to put a Byte Order
Mark (BOM) first in the file. The BOM is the code point 16#FEFF encoded in the
same way as the remaining file. If such a file is to be read, the first few
bytes (depending on encoding) are not part of the text. This code outlines how
to open a file that is believed to have a BOM, and sets the files encoding and
position for further sequential reading (preferably using the <a href="io.html"><code class="inline">io</code></a> module).</p><p>Notice that error handling is omitted from the code:</p><pre><code class="makeup erlang" translate="no"><span class="nf">open_bom_file_for_reading</span><span class="p" data-group-id="2183547224-1">(</span><span class="n">File</span><span class="p" data-group-id="2183547224-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="2183547224-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">F</span><span class="p" data-group-id="2183547224-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">open</span><span class="p" data-group-id="2183547224-3">(</span><span class="n">File</span><span class="p">,</span><span class="p" data-group-id="2183547224-4">[</span><span class="ss">read</span><span class="p">,</span><span class="ss">binary</span><span class="p" data-group-id="2183547224-4">]</span><span class="p" data-group-id="2183547224-3">)</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="2183547224-5">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">Bin</span><span class="p" data-group-id="2183547224-5">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">read</span><span class="p" data-group-id="2183547224-6">(</span><span class="n">F</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="2183547224-6">)</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="2183547224-7">{</span><span class="n">Type</span><span class="p">,</span><span class="n">Bytes</span><span class="p" data-group-id="2183547224-7">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">unicode</span><span class="p">:</span><span class="nf">bom_to_encoding</span><span class="p" data-group-id="2183547224-8">(</span><span class="n">Bin</span><span class="p" data-group-id="2183547224-8">)</span><span class="p">,</span><span class="w">
    </span><span class="nc">file</span><span class="p">:</span><span class="nf">position</span><span class="p" data-group-id="2183547224-9">(</span><span class="n">F</span><span class="p">,</span><span class="n">Bytes</span><span class="p" data-group-id="2183547224-9">)</span><span class="p">,</span><span class="w">
    </span><span class="nc">io</span><span class="p">:</span><span class="nf">setopts</span><span class="p" data-group-id="2183547224-10">(</span><span class="n">F</span><span class="p">,</span><span class="p" data-group-id="2183547224-11">[</span><span class="p" data-group-id="2183547224-12">{</span><span class="ss">encoding</span><span class="p">,</span><span class="n">Type</span><span class="p" data-group-id="2183547224-12">}</span><span class="p" data-group-id="2183547224-11">]</span><span class="p" data-group-id="2183547224-10">)</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="2183547224-13">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">F</span><span class="p" data-group-id="2183547224-13">}</span><span class="p">.</span></code></pre><p>Function <a href="unicode.html#bom_to_encoding/1"><code class="inline">unicode:bom_to_encoding/1</code></a> identifies the encoding from a binary of at
least four bytes. It returns, along with a term suitable for setting the
encoding of the file, the byte length of the BOM, so that the file position can
be set accordingly. Notice that function <a href="../../apps/kernel/file.html#position/2"><code class="inline">file:position/2</code></a> always works on
byte-offsets, so that the byte length of the BOM is needed.</p><p>To open a file for writing and place the BOM first is even simpler:</p><pre><code class="makeup erlang" translate="no"><span class="nf">open_bom_file_for_writing</span><span class="p" data-group-id="8782733749-1">(</span><span class="n">File</span><span class="p">,</span><span class="n">Encoding</span><span class="p" data-group-id="8782733749-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="8782733749-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">F</span><span class="p" data-group-id="8782733749-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">open</span><span class="p" data-group-id="8782733749-3">(</span><span class="n">File</span><span class="p">,</span><span class="p" data-group-id="8782733749-4">[</span><span class="ss">write</span><span class="p">,</span><span class="ss">binary</span><span class="p" data-group-id="8782733749-4">]</span><span class="p" data-group-id="8782733749-3">)</span><span class="p">,</span><span class="w">
    </span><span class="ss">ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">write</span><span class="p" data-group-id="8782733749-5">(</span><span class="n">File</span><span class="p">,</span><span class="nc">unicode</span><span class="p">:</span><span class="nf">encoding_to_bom</span><span class="p" data-group-id="8782733749-6">(</span><span class="n">Encoding</span><span class="p" data-group-id="8782733749-6">)</span><span class="p" data-group-id="8782733749-5">)</span><span class="p">,</span><span class="w">
    </span><span class="nc">io</span><span class="p">:</span><span class="nf">setopts</span><span class="p" data-group-id="8782733749-7">(</span><span class="n">F</span><span class="p">,</span><span class="p" data-group-id="8782733749-8">[</span><span class="p" data-group-id="8782733749-9">{</span><span class="ss">encoding</span><span class="p">,</span><span class="n">Encoding</span><span class="p" data-group-id="8782733749-9">}</span><span class="p" data-group-id="8782733749-8">]</span><span class="p" data-group-id="8782733749-7">)</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="8782733749-10">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">F</span><span class="p" data-group-id="8782733749-10">}</span><span class="p">.</span></code></pre><p>The file is in both these cases then best processed using the <a href="io.html"><code class="inline">io</code></a> module, as
the functions in that module can handle code points beyond the ISO Latin-1
range.</p><h3 id="formatted-i-o" class="section-heading"><a href="#formatted-i-o" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Formatted I/O</span></h3><p>When reading and writing to Unicode-aware entities, like a file opened for
Unicode translation, you probably want to format text strings using the
functions in the <a href="io.html"><code class="inline">io</code></a> module or the <a href="io_lib.html"><code class="inline">io_lib</code></a> module. For backward
compatibility reasons, these functions do not accept any list as a string, but
require a special <em>translation modifier</em> when working with Unicode texts. The
modifier is <code class="inline">t</code>. When applied to control character <code class="inline">s</code> in a formatting string,
it accepts all Unicode code points and expects binaries to be in UTF-8:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="nc">io</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="8834055921-1">(</span><span class="s">&quot;~ts</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="p" data-group-id="8834055921-2">[</span><span class="p" data-group-id="8834055921-3">&lt;&lt;</span><span class="s">&quot;åäö&quot;</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="8834055921-3">&gt;&gt;</span><span class="p" data-group-id="8834055921-2">]</span><span class="p" data-group-id="8834055921-1">)</span><span class="p">.</span><span class="w">
</span><span class="err">å</span><span class="err">ä</span><span class="err">ö</span><span class="w">
</span><span class="ss">ok</span><span class="gp unselectable">
2&gt; </span><span class="nc">io</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="8834055921-4">(</span><span class="s">&quot;</span><span class="si">~s</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="p" data-group-id="8834055921-5">[</span><span class="p" data-group-id="8834055921-6">&lt;&lt;</span><span class="s">&quot;åäö&quot;</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="8834055921-6">&gt;&gt;</span><span class="p" data-group-id="8834055921-5">]</span><span class="p" data-group-id="8834055921-4">)</span><span class="p">.</span><span class="w">
</span><span class="err">Ã</span><span class="err">¥</span><span class="err">Ã</span><span class="err">¤</span><span class="err">Ã</span><span class="err">¶</span><span class="w">
</span><span class="ss">ok</span></code></pre><p>Clearly, the second <a href="io.html#format/2"><code class="inline">io:format/2</code></a> gives undesired output, as the UTF-8 binary is
not in <code class="inline">latin1</code>. For backward compatibility, the non-prefixed control character
<code class="inline">s</code> expects bytewise-encoded ISO Latin-1 characters in binaries and lists
containing only code points &lt; 256.</p><p>As long as the data is always lists, modifier <code class="inline">t</code> can be used for any string,
but when binary data is involved, care must be taken to make the correct choice
of formatting characters. A bytewise-encoded binary is also interpreted as a
string, and printed even when using <code class="inline">~ts</code>, but it can be mistaken for a valid
UTF-8 string. Avoid therefore using the <code class="inline">~ts</code> control if the binary contains
bytewise-encoded characters and not UTF-8.</p><p>Function <a href="io_lib.html#format/2"><code class="inline">io_lib:format/2</code></a> behaves similarly. It is defined to return a deep
list of characters and the output can easily be converted to binary data for
outputting on any device by a simple <a href="../../apps/erts/erlang.html#list_to_binary/1"><code class="inline">erlang:list_to_binary/1</code></a>. When the
translation modifier is used, the list can, however, contain characters that
cannot be stored in one byte. The call to <a href="../../apps/erts/erlang.html#list_to_binary/1"><code class="inline">erlang:list_to_binary/1</code></a> then fails.
However, if the I/O server you want to communicate with is Unicode-aware, the
returned list can still be used directly:</p><pre><code class="makeup erlang" translate="no"><span class="sc">$ </span><span class="ss">erl</span><span class="w"> </span><span class="o">+</span><span class="ss">pc</span><span class="w"> </span><span class="ss">unicode</span><span class="w">
</span><span class="n">Erlang</span><span class="w"> </span><span class="n">R16B</span><span class="w"> </span><span class="p" data-group-id="2148109453-1">(</span><span class="ss">erts</span><span class="o">-</span><span class="mf">5.10</span><span class="p">.</span><span class="mi">1</span><span class="p" data-group-id="2148109453-1">)</span><span class="w"> </span><span class="p" data-group-id="2148109453-2">[</span><span class="ss">source</span><span class="p" data-group-id="2148109453-2">]</span><span class="w"> </span><span class="p" data-group-id="2148109453-3">[</span><span class="ss">async</span><span class="o">-</span><span class="nc">threads</span><span class="p">:</span><span class="mi">0</span><span class="p" data-group-id="2148109453-3">]</span><span class="w"> </span><span class="p" data-group-id="2148109453-4">[</span><span class="ss">hipe</span><span class="p" data-group-id="2148109453-4">]</span><span class="w"> </span><span class="p" data-group-id="2148109453-5">[</span><span class="ss">kernel</span><span class="o">-</span><span class="nc">poll</span><span class="p">:</span><span class="ss">false</span><span class="p" data-group-id="2148109453-5">]</span><span class="w">

</span><span class="n">Eshell</span><span class="w"> </span><span class="n">V5</span><span class="p">.</span><span class="mf">10.1</span><span class="w"> </span><span class="p" data-group-id="2148109453-6">(</span><span class="ss">abort</span><span class="w"> </span><span class="ss">with</span><span class="w"> </span><span class="err">^</span><span class="n">G</span><span class="p" data-group-id="2148109453-6">)</span><span class="gp unselectable">
1&gt; </span><span class="nc">io_lib</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="2148109453-7">(</span><span class="s">&quot;~ts</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2148109453-8">[</span><span class="s">&quot;Γιούνικοντ&quot;</span><span class="p" data-group-id="2148109453-8">]</span><span class="p" data-group-id="2148109453-7">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2148109453-9">[</span><span class="s">&quot;Γιούνικοντ&quot;</span><span class="p">,</span><span class="s">&quot;\n&quot;</span><span class="p" data-group-id="2148109453-9">]</span><span class="gp unselectable">
2&gt; </span><span class="nc">io</span><span class="p">:</span><span class="nf">put_chars</span><span class="p" data-group-id="2148109453-10">(</span><span class="nc">io_lib</span><span class="p">:</span><span class="nf">format</span><span class="p" data-group-id="2148109453-11">(</span><span class="s">&quot;~ts</span><span class="si">~n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2148109453-12">[</span><span class="s">&quot;Γιούνικοντ&quot;</span><span class="p" data-group-id="2148109453-12">]</span><span class="p" data-group-id="2148109453-11">)</span><span class="p" data-group-id="2148109453-10">)</span><span class="p">.</span><span class="w">
</span><span class="err">Γ</span><span class="err">ι</span><span class="err">ο</span><span class="err">ύ</span><span class="err">ν</span><span class="err">ι</span><span class="err">κ</span><span class="err">ο</span><span class="err">ν</span><span class="err">τ</span><span class="w">
</span><span class="ss">ok</span></code></pre><p>The Unicode string is returned as a Unicode list, which is recognized as such,
as the Erlang shell uses the Unicode encoding (and is started with all Unicode
characters considered printable). The Unicode list is valid input to function
<a href="io.html#put_chars/2"><code class="inline">io:put_chars/2</code></a>, so data can be output on any Unicode-capable device. If the
device is a terminal, characters are output in format <code class="inline">\x{</code>H...<code class="inline">}</code> if encoding
is <code class="inline">latin1</code>. Otherwise in UTF-8 (for the non-interactive terminal: &quot;oldshell&quot; or
&quot;noshell&quot;) or whatever is suitable to show the character properly (for an
interactive terminal: the regular shell).</p><p>So, you can always send Unicode data to the
<a href="io.html#t:standard_io/0"><code class="inline">standard_io</code></a> device. Files, however, accept only
Unicode code points beyond ISO Latin-1 if <code class="inline">encoding</code> is set to something else
than <code class="inline">latin1</code>.</p><h3 id="heuristic-identification-of-utf-8" class="section-heading"><a href="#heuristic-identification-of-utf-8" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Heuristic Identification of UTF-8</span></h3><p>While it is strongly encouraged that the encoding of characters in binary data
is known before processing, that is not always possible. On a typical Linux
system, there is a mix of UTF-8 and ISO Latin-1 text files, and there are seldom
any BOMs in the files to identify them.</p><p>UTF-8 is designed so that ISO Latin-1 characters with numbers beyond the 7-bit
ASCII range are seldom considered valid when decoded as UTF-8. Therefore one can
usually use heuristics to determine if a file is in UTF-8 or if it is encoded in
ISO Latin-1 (one byte per character). The <a href="unicode.html"><code class="inline">unicode</code></a> module can be used to
determine if data can be interpreted as UTF-8:</p><pre><code class="makeup erlang" translate="no"><span class="nf">heuristic_encoding_bin</span><span class="p" data-group-id="9520211002-1">(</span><span class="n">Bin</span><span class="p" data-group-id="9520211002-1">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nf">is_binary</span><span class="p" data-group-id="9520211002-2">(</span><span class="n">Bin</span><span class="p" data-group-id="9520211002-2">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="nc">unicode</span><span class="p">:</span><span class="nf">characters_to_binary</span><span class="p" data-group-id="9520211002-3">(</span><span class="n">Bin</span><span class="p">,</span><span class="ss">utf8</span><span class="p">,</span><span class="ss">utf8</span><span class="p" data-group-id="9520211002-3">)</span><span class="w"> </span><span class="k">of</span><span class="w">
	</span><span class="n">Bin</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
	    </span><span class="ss">utf8</span><span class="p">;</span><span class="w">
	</span><span class="p">_</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
	    </span><span class="ss">latin1</span><span class="w">
    </span><span class="k">end</span><span class="p">.</span></code></pre><p>If you do not have a complete binary of the file content, you can instead chunk
through the file and check part by part. The return-tuple
<code class="inline">{incomplete,Decoded,Rest}</code> from function
<a href="unicode.html#characters_to_binary/1"><code class="inline">unicode:characters_to_binary/1,2,3</code></a> comes
in handy. The incomplete rest from one chunk of data read from the file is
prepended to the next chunk and we therefore avoid the problem of character
boundaries when reading chunks of bytes in UTF-8 encoding:</p><pre><code class="makeup erlang" translate="no"><span class="nf">heuristic_encoding_file</span><span class="p" data-group-id="0311220161-1">(</span><span class="n">FileName</span><span class="p" data-group-id="0311220161-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="0311220161-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">F</span><span class="p" data-group-id="0311220161-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">open</span><span class="p" data-group-id="0311220161-3">(</span><span class="n">FileName</span><span class="p">,</span><span class="p" data-group-id="0311220161-4">[</span><span class="ss">read</span><span class="p">,</span><span class="ss">binary</span><span class="p" data-group-id="0311220161-4">]</span><span class="p" data-group-id="0311220161-3">)</span><span class="p">,</span><span class="w">
    </span><span class="nf">loop_through_file</span><span class="p" data-group-id="0311220161-5">(</span><span class="n">F</span><span class="p">,</span><span class="p" data-group-id="0311220161-6">&lt;&lt;</span><span class="p" data-group-id="0311220161-6">&gt;&gt;</span><span class="p">,</span><span class="nc">file</span><span class="p">:</span><span class="nf">read</span><span class="p" data-group-id="0311220161-7">(</span><span class="n">F</span><span class="p">,</span><span class="mi">1024</span><span class="p" data-group-id="0311220161-7">)</span><span class="p" data-group-id="0311220161-5">)</span><span class="p">.</span><span class="w">

</span><span class="nf">loop_through_file</span><span class="p" data-group-id="0311220161-8">(</span><span class="p">_</span><span class="p">,</span><span class="p" data-group-id="0311220161-9">&lt;&lt;</span><span class="p" data-group-id="0311220161-9">&gt;&gt;</span><span class="p">,</span><span class="ss">eof</span><span class="p" data-group-id="0311220161-8">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="ss">utf8</span><span class="p">;</span><span class="w">
</span><span class="nf">loop_through_file</span><span class="p" data-group-id="0311220161-10">(</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="ss">eof</span><span class="p" data-group-id="0311220161-10">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="ss">latin1</span><span class="p">;</span><span class="w">
</span><span class="nf">loop_through_file</span><span class="p" data-group-id="0311220161-11">(</span><span class="n">F</span><span class="p">,</span><span class="n">Acc</span><span class="p">,</span><span class="p" data-group-id="0311220161-12">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">Bin</span><span class="p" data-group-id="0311220161-12">}</span><span class="p" data-group-id="0311220161-11">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nf">is_binary</span><span class="p" data-group-id="0311220161-13">(</span><span class="n">Bin</span><span class="p" data-group-id="0311220161-13">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="nc">unicode</span><span class="p">:</span><span class="nf">characters_to_binary</span><span class="p" data-group-id="0311220161-14">(</span><span class="p" data-group-id="0311220161-15">[</span><span class="n">Acc</span><span class="p">,</span><span class="n">Bin</span><span class="p" data-group-id="0311220161-15">]</span><span class="p" data-group-id="0311220161-14">)</span><span class="w"> </span><span class="k">of</span><span class="w">
	</span><span class="p" data-group-id="0311220161-16">{</span><span class="ss">error</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p" data-group-id="0311220161-16">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
	    </span><span class="ss">latin1</span><span class="p">;</span><span class="w">
	</span><span class="p" data-group-id="0311220161-17">{</span><span class="ss">incomplete</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="n">Rest</span><span class="p" data-group-id="0311220161-17">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
	    </span><span class="nf">loop_through_file</span><span class="p" data-group-id="0311220161-18">(</span><span class="n">F</span><span class="p">,</span><span class="n">Rest</span><span class="p">,</span><span class="nc">file</span><span class="p">:</span><span class="nf">read</span><span class="p" data-group-id="0311220161-19">(</span><span class="n">F</span><span class="p">,</span><span class="mi">1024</span><span class="p" data-group-id="0311220161-19">)</span><span class="p" data-group-id="0311220161-18">)</span><span class="p">;</span><span class="w">
	</span><span class="n">Res</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nf">is_binary</span><span class="p" data-group-id="0311220161-20">(</span><span class="n">Res</span><span class="p" data-group-id="0311220161-20">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
	    </span><span class="nf">loop_through_file</span><span class="p" data-group-id="0311220161-21">(</span><span class="n">F</span><span class="p">,</span><span class="p" data-group-id="0311220161-22">&lt;&lt;</span><span class="p" data-group-id="0311220161-22">&gt;&gt;</span><span class="p">,</span><span class="nc">file</span><span class="p">:</span><span class="nf">read</span><span class="p" data-group-id="0311220161-23">(</span><span class="n">F</span><span class="p">,</span><span class="mi">1024</span><span class="p" data-group-id="0311220161-23">)</span><span class="p" data-group-id="0311220161-21">)</span><span class="w">
    </span><span class="k">end</span><span class="p">.</span></code></pre><p>Another option is to try to read the whole file in UTF-8 encoding and see if it
fails. Here we need to read the file using function <a href="io.html#get_chars/3"><code class="inline">io:get_chars/3</code></a>, as we have
to read characters with a code point &gt; 255:</p><pre><code class="makeup erlang" translate="no"><span class="nf">heuristic_encoding_file2</span><span class="p" data-group-id="7484296556-1">(</span><span class="n">FileName</span><span class="p" data-group-id="7484296556-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="7484296556-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">F</span><span class="p" data-group-id="7484296556-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">open</span><span class="p" data-group-id="7484296556-3">(</span><span class="n">FileName</span><span class="p">,</span><span class="p" data-group-id="7484296556-4">[</span><span class="ss">read</span><span class="p">,</span><span class="ss">binary</span><span class="p">,</span><span class="p" data-group-id="7484296556-5">{</span><span class="ss">encoding</span><span class="p">,</span><span class="ss">utf8</span><span class="p" data-group-id="7484296556-5">}</span><span class="p" data-group-id="7484296556-4">]</span><span class="p" data-group-id="7484296556-3">)</span><span class="p">,</span><span class="w">
    </span><span class="nf">loop_through_file2</span><span class="p" data-group-id="7484296556-6">(</span><span class="n">F</span><span class="p">,</span><span class="nc">io</span><span class="p">:</span><span class="nf">get_chars</span><span class="p" data-group-id="7484296556-7">(</span><span class="n">F</span><span class="p">,</span><span class="ss">&#39;&#39;</span><span class="p">,</span><span class="mi">1024</span><span class="p" data-group-id="7484296556-7">)</span><span class="p" data-group-id="7484296556-6">)</span><span class="p">.</span><span class="w">

</span><span class="nf">loop_through_file2</span><span class="p" data-group-id="7484296556-8">(</span><span class="p">_</span><span class="p">,</span><span class="ss">eof</span><span class="p" data-group-id="7484296556-8">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="ss">utf8</span><span class="p">;</span><span class="w">
</span><span class="nf">loop_through_file2</span><span class="p" data-group-id="7484296556-9">(</span><span class="p">_</span><span class="p">,</span><span class="p" data-group-id="7484296556-10">{</span><span class="ss">error</span><span class="p">,</span><span class="p">_</span><span class="n">Err</span><span class="p" data-group-id="7484296556-10">}</span><span class="p" data-group-id="7484296556-9">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="ss">latin1</span><span class="p">;</span><span class="w">
</span><span class="nf">loop_through_file2</span><span class="p" data-group-id="7484296556-11">(</span><span class="n">F</span><span class="p">,</span><span class="n">Bin</span><span class="p" data-group-id="7484296556-11">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nf">is_binary</span><span class="p" data-group-id="7484296556-12">(</span><span class="n">Bin</span><span class="p" data-group-id="7484296556-12">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nf">loop_through_file2</span><span class="p" data-group-id="7484296556-13">(</span><span class="n">F</span><span class="p">,</span><span class="nc">io</span><span class="p">:</span><span class="nf">get_chars</span><span class="p" data-group-id="7484296556-14">(</span><span class="n">F</span><span class="p">,</span><span class="ss">&#39;&#39;</span><span class="p">,</span><span class="mi">1024</span><span class="p" data-group-id="7484296556-14">)</span><span class="p" data-group-id="7484296556-13">)</span><span class="p">.</span></code></pre><h3 id="lists-of-utf-8-bytes" class="section-heading"><a href="#lists-of-utf-8-bytes" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Lists of UTF-8 Bytes</span></h3><p>For various reasons, you can sometimes have a list of UTF-8 bytes. This is not a
regular string of Unicode characters, as each list element does not contain one
character. Instead you get the &quot;raw&quot; UTF-8 encoding that you have in binaries.
This is easily converted to a proper Unicode string by first converting byte per
byte into a binary, and then converting the binary of UTF-8 encoded characters
back to a Unicode string:</p><pre><code class="makeup erlang" translate="no"><span class="nf">utf8_list_to_string</span><span class="p" data-group-id="0644828430-1">(</span><span class="n">StrangeList</span><span class="p" data-group-id="0644828430-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
  </span><span class="nc">unicode</span><span class="p">:</span><span class="nf">characters_to_list</span><span class="p" data-group-id="0644828430-2">(</span><span class="nf">list_to_binary</span><span class="p" data-group-id="0644828430-3">(</span><span class="n">StrangeList</span><span class="p" data-group-id="0644828430-3">)</span><span class="p" data-group-id="0644828430-2">)</span><span class="p">.</span></code></pre><h3 id="double-utf-8-encoding" class="section-heading"><a href="#double-utf-8-encoding" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Double UTF-8 Encoding</span></h3><p>When working with binaries, you can get the horrible &quot;double UTF-8 encoding&quot;,
where strange characters are encoded in your binaries or files. In other words,
you can get a UTF-8 encoded binary that for the second time is encoded as UTF-8.
A common situation is where you read a file, byte by byte, but the content is
already UTF-8. If you then convert the bytes to UTF-8, using, for example, the
<a href="unicode.html"><code class="inline">unicode</code></a> module, or by writing to a file opened with option
<code class="inline">{encoding,utf8}</code>, you have each <em>byte</em> in the input file encoded as UTF-8, not
each character of the original text (one character can have been encoded in many
bytes). There is no real remedy for this other than to be sure of which data is
encoded in which format, and never convert UTF-8 data (possibly read byte by
byte from a file) into UTF-8 again.</p><p>By far the most common situation where this occurs, is when you get lists of
UTF-8 instead of proper Unicode strings, and then convert them to UTF-8 in a
binary or on a file:</p><pre><code class="makeup erlang" translate="no"><span class="nf">wrong_thing_to_do</span><span class="p" data-group-id="2238020548-1">(</span><span class="p" data-group-id="2238020548-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
  </span><span class="p" data-group-id="2238020548-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">Bin</span><span class="p" data-group-id="2238020548-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">read_file</span><span class="p" data-group-id="2238020548-3">(</span><span class="s">&quot;an_utf8_encoded_file.txt&quot;</span><span class="p" data-group-id="2238020548-3">)</span><span class="p">,</span><span class="w">
  </span><span class="n">MyList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">binary_to_list</span><span class="p" data-group-id="2238020548-4">(</span><span class="n">Bin</span><span class="p" data-group-id="2238020548-4">)</span><span class="p">,</span><span class="w"> </span><span class="c1">%% Wrong! It is an utf8 binary!</span><span class="w">
  </span><span class="p" data-group-id="2238020548-5">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">C</span><span class="p" data-group-id="2238020548-5">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">open</span><span class="p" data-group-id="2238020548-6">(</span><span class="s">&quot;catastrophe.txt&quot;</span><span class="p">,</span><span class="p" data-group-id="2238020548-7">[</span><span class="ss">write</span><span class="p">,</span><span class="p" data-group-id="2238020548-8">{</span><span class="ss">encoding</span><span class="p">,</span><span class="ss">utf8</span><span class="p" data-group-id="2238020548-8">}</span><span class="p" data-group-id="2238020548-7">]</span><span class="p" data-group-id="2238020548-6">)</span><span class="p">,</span><span class="w">
  </span><span class="nc">io</span><span class="p">:</span><span class="nf">put_chars</span><span class="p" data-group-id="2238020548-9">(</span><span class="n">C</span><span class="p">,</span><span class="n">MyList</span><span class="p" data-group-id="2238020548-9">)</span><span class="p">,</span><span class="w"> </span><span class="c1">%% Expects a Unicode string, but get UTF-8</span><span class="w">
                          </span><span class="c1">%% bytes in a list!</span><span class="w">
  </span><span class="nc">file</span><span class="p">:</span><span class="nf">close</span><span class="p" data-group-id="2238020548-10">(</span><span class="n">C</span><span class="p" data-group-id="2238020548-10">)</span><span class="p">.</span><span class="w"> </span><span class="c1">%% The file catastrophe.txt contains more or less unreadable</span><span class="w">
                 </span><span class="c1">%% garbage!</span></code></pre><p>Ensure you know what a binary contains before converting it to a string. If no
other option exists, try heuristics:</p><pre><code class="makeup erlang" translate="no"><span class="nf">if_you_can_not_know</span><span class="p" data-group-id="0110853453-1">(</span><span class="p" data-group-id="0110853453-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
  </span><span class="p" data-group-id="0110853453-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">Bin</span><span class="p" data-group-id="0110853453-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">read_file</span><span class="p" data-group-id="0110853453-3">(</span><span class="s">&quot;maybe_utf8_encoded_file.txt&quot;</span><span class="p" data-group-id="0110853453-3">)</span><span class="p">,</span><span class="w">
  </span><span class="n">MyList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="nc">unicode</span><span class="p">:</span><span class="nf">characters_to_list</span><span class="p" data-group-id="0110853453-4">(</span><span class="n">Bin</span><span class="p" data-group-id="0110853453-4">)</span><span class="w"> </span><span class="k">of</span><span class="w">
    </span><span class="n">L</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nf">is_list</span><span class="p" data-group-id="0110853453-5">(</span><span class="n">L</span><span class="p" data-group-id="0110853453-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
      </span><span class="n">L</span><span class="p">;</span><span class="w">
    </span><span class="p">_</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
      </span><span class="nf">binary_to_list</span><span class="p" data-group-id="0110853453-6">(</span><span class="n">Bin</span><span class="p" data-group-id="0110853453-6">)</span><span class="w"> </span><span class="c1">%% The file was bytewise encoded</span><span class="w">
  </span><span class="k">end</span><span class="p">,</span><span class="w">
  </span><span class="c1">%% Now we know that the list is a Unicode string, not a list of UTF-8 bytes</span><span class="w">
  </span><span class="p" data-group-id="0110853453-7">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">G</span><span class="p" data-group-id="0110853453-7">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">open</span><span class="p" data-group-id="0110853453-8">(</span><span class="s">&quot;greatness.txt&quot;</span><span class="p">,</span><span class="p" data-group-id="0110853453-9">[</span><span class="ss">write</span><span class="p">,</span><span class="p" data-group-id="0110853453-10">{</span><span class="ss">encoding</span><span class="p">,</span><span class="ss">utf8</span><span class="p" data-group-id="0110853453-10">}</span><span class="p" data-group-id="0110853453-9">]</span><span class="p" data-group-id="0110853453-8">)</span><span class="p">,</span><span class="w">
  </span><span class="nc">io</span><span class="p">:</span><span class="nf">put_chars</span><span class="p" data-group-id="0110853453-11">(</span><span class="n">G</span><span class="p">,</span><span class="n">MyList</span><span class="p" data-group-id="0110853453-11">)</span><span class="p">,</span><span class="w"> </span><span class="c1">%% Expects a Unicode string, which is what it gets!</span><span class="w">
  </span><span class="nc">file</span><span class="p">:</span><span class="nf">close</span><span class="p" data-group-id="0110853453-12">(</span><span class="n">G</span><span class="p" data-group-id="0110853453-12">)</span><span class="p">.</span><span class="w"> </span><span class="c1">%% The file contains valid UTF-8 encoded Unicode characters!</span></code></pre>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="terminal_interface.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Creating a terminal application
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="uri_string_usage.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Uniform Resource Identifiers
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="stdlib.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.38.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright © 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
