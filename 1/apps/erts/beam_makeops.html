<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.38.1">
    <meta name="project" content="erts v16.0">


<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=1&q=">
<meta name="major-vsn" content="1">
<link rel="canonical" href="https://www.erlang.org/docs/1/apps/erts/beam_makeops.html" />
    <title>The beam_makeops script — erts v16.0</title>

    <link rel="stylesheet" href="dist/html-erlang-ZK43ZOAC.css" />

    <script defer src="dist/sidebar_items-40F65B05.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-DPJLHKSM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="erts" />
        </a>

      <div>
        <a href="../../index.html" class="sidebar-projectName" translate="no">
erts
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v16.0
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of erts</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>The beam_makeops script</h1>


      <a href="https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/beam_makeops.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<p>This document describes the <strong>beam_makeops</strong> script.</p><h2 id="introduction" class="section-heading"><a href="#introduction" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Introduction</span></h2><p>The <strong>beam_makeops</strong> Perl script is used at build-time by both the
compiler and runtime system.  Given a number of input files (all with
the extension <code class="inline">.tab</code>), it will generate source files used by the
Erlang compiler and by the runtime system to load and execute BEAM
instructions.</p><p>Essentially those <code class="inline">.tab</code> files define:</p><ul><li><p>External generic BEAM instructions.  They are the instructions that
are known to both the compiler and the runtime system.  Generic
instructions are stable between releases.  New generic instructions
with high numbers than previous instructions can be added in major
releases.  The OTP 20 release has 159 external generic instructions.</p></li><li><p>Internal generic instructions.  They are known only to the runtime
system and can be changed at any time without compatibility issues.
They are created by transformation rules (described next).</p></li><li><p>Rules for transforming one or more generic instructions to other
generic instructions.  The transformation rules allow combining,
splitting, and removal of instructions, as well as shuffling operands.
Because of the transformation rules, the runtime can have many
internal generic instructions that are only known to runtime system.</p></li><li><p>Specific BEAM instructions.  The specific instructions are the
instructions that are actually executed by the runtime system.  They
can be changed at any time without causing compatibility issues.
The loader translates generic instructions to specific instructions.
In general, for each generic instruction, there exists a family of
specific instructions.  The OTP 20 release has 389 specific
instructions.</p></li><li><p>The implementation of specific instructions for the traditional
BEAM interpreter. For the <a href="beamasm.html">BeamAsm JIT</a> introduced
in OTP 24, the implementation of instructions are defined in emitter
functions written in C++.</p></li></ul><p>Generic instructions have typed operands. Here are a few examples of
operands for <code class="inline">move/2</code>:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="1688979824-1">{</span><span class="ss">move</span><span class="p">,</span><span class="p" data-group-id="1688979824-2">{</span><span class="ss">atom</span><span class="p">,</span><span class="ss">id</span><span class="p" data-group-id="1688979824-2">}</span><span class="p">,</span><span class="p" data-group-id="1688979824-3">{</span><span class="ss">x</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="1688979824-3">}</span><span class="p" data-group-id="1688979824-1">}</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1688979824-4">{</span><span class="ss">move</span><span class="p">,</span><span class="p" data-group-id="1688979824-5">{</span><span class="ss">x</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="1688979824-5">}</span><span class="p">,</span><span class="p" data-group-id="1688979824-6">{</span><span class="ss">x</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="1688979824-6">}</span><span class="p" data-group-id="1688979824-4">}</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1688979824-7">{</span><span class="ss">move</span><span class="p">,</span><span class="p" data-group-id="1688979824-8">{</span><span class="ss">x</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="1688979824-8">}</span><span class="p">,</span><span class="p" data-group-id="1688979824-9">{</span><span class="ss">y</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="1688979824-9">}</span><span class="p" data-group-id="1688979824-7">}</span><span class="p">.</span></code></pre><p>When those instructions are loaded, the loader rewrites them
to specific instructions:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move_cx</span><span class="w"> </span><span class="ss">id</span><span class="w"> </span><span class="mi">5</span><span class="w">
</span><span class="ss">move_xx</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="ss">move_xy</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span></code></pre><p>Corresponding to each generic instruction, there is a family of
specific instructions.  The types that an instance of a specific
instruction can handle are encoded in the instruction names.  For
example, <code class="inline">move_xy</code> takes an X register number as the first operand and
a Y register number as the second operand.  <code class="inline">move_cx</code> takes a tagged
Erlang term as the first operand and an X register number as the
second operand.</p><h2 id="an-example-the-move-instruction" class="section-heading"><a href="#an-example-the-move-instruction" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">An example: the move instruction</span></h2><p>Using the <code class="inline">move</code> instruction as an example, we will give a quick
tour to show the main features of <strong>beam_makeops</strong>.</p><p>In the <code class="inline">compiler</code> application, in the file <code class="inline">genop.tab</code>, there is the
following line:</p><pre><code class="makeup erlang" translate="no"><span class="mi">64</span><span class="p">:</span><span class="w"> </span><span class="ss">move</span><span class="p">/</span><span class="mi">2</span></code></pre><p>This is a definition of an external generic BEAM instruction. Most
importantly it specifies that the opcode is 64.  It also defines that
it has two operands.  The BEAM assembler will use the opcode when
creating <code class="inline">.beam</code> files.  The compiler does not really need the arity,
but it will use it as an internal sanity check when assembling the
BEAM code.</p><p>Let's have a look at <code class="inline">ops.tab</code> in <code class="inline">erts/emulator/beam/emu</code>, where the
specific <code class="inline">move</code> instructions are defined.  Here are a few of them:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">x</span><span class="w">
</span><span class="ss">move</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">y</span><span class="w">
</span><span class="ss">move</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">x</span></code></pre><p>Each specific instructions is defined by following the name of the
instruction with the types for each operand.  An operand type is a
single letter.  For example, <code class="inline">x</code> means an X register, <code class="inline">y</code>
means a Y register, and <code class="inline">c</code> is a &quot;constant&quot; (a tagged term such as
an integer, an atom, or a literal).</p><p>Now let's look at the implementation of the <code class="inline">move</code> instruction.  There
are multiple files containing implementations of instructions in the
<code class="inline">erts/emulator/beam/emu</code> directory.  The <code class="inline">move</code> instruction is defined
in <code class="inline">instrs.tab</code>.  It looks like this:</p><pre><code class="makeup erlang" translate="no"><span class="nf">move</span><span class="p" data-group-id="7378677619-1">(</span><span class="n">Src</span><span class="p">,</span><span class="w"> </span><span class="n">Dst</span><span class="p" data-group-id="7378677619-1">)</span><span class="w"> </span><span class="p" data-group-id="7378677619-2">{</span><span class="w">
    </span><span class="sc">$D</span><span class="ss">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$S</span><span class="ss">rc</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="7378677619-2">}</span></code></pre><p>The implementation for an instruction largely follows the C syntax,
except that the variables in the function head don't have any types.
The <code class="inline">$</code> before an identifier denotes a macro expansion.  Thus,
<code class="inline">$Src</code> will expand to the code to pick up the source operand for
the instruction and <code class="inline">$Dst</code> to the code for the destination register.</p><p>We will look at the code for each specific instruction in turn.  To
make the code easier to understand, let's first look at the memory
layout for the instruction <code class="inline">{move,{atom,id},{x,5}}</code>:</p><pre><code class="makeup erlang" translate="no"><span class="w">     </span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="w">
</span><span class="n">I</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">|</span><span class="w">                 </span><span class="mi">40</span><span class="w"> </span><span class="p">|</span><span class="w">       </span><span class="p">&amp;&amp;</span><span class="ss">lb_move_cx</span><span class="w"> </span><span class="p">|</span><span class="w">
     </span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="w">
     </span><span class="p">|</span><span class="w">                        </span><span class="n">Tagged</span><span class="w"> </span><span class="ss">atom</span><span class="w"> </span><span class="ss">&#39;id&#39;</span><span class="w"> </span><span class="p">|</span><span class="w">
     </span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span></code></pre><p>This example and all other examples in the document assumes a 64-bit
architecture, and furthermore that pointers to C code fit in 32 bits.</p><p><code class="inline">I</code> in the BEAM virtual machine is the instruction pointer.  When BEAM
executes an instruction, <code class="inline">I</code> points to the first word of the
instruction.</p><p><code class="inline">&amp;&amp;lb_move_cx</code> is the address to C code that implements <code class="inline">move_cx</code>.  It
is stored in the lower 32 bits of the word.  In the upper 32 bits is
the byte offset to the X register; the register number 5 has been
multiplied by the word size size 8.</p><p>In the next word the tagged atom <code class="inline">id</code> is stored.</p><p>With that background, we can look at the generated code for <code class="inline">move_cx</code>
in <code class="inline">beam_hot.h</code>:</p><pre><code class="makeup erlang" translate="no"><span class="n">OpCase</span><span class="p" data-group-id="3444797406-1">(</span><span class="ss">move_cx</span><span class="p" data-group-id="3444797406-1">)</span><span class="p">:</span><span class="w">
</span><span class="p" data-group-id="3444797406-2">{</span><span class="w">
  </span><span class="n">BeamInstr</span><span class="w"> </span><span class="ss">next_pf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BeamCodeAddr</span><span class="p" data-group-id="3444797406-3">(</span><span class="n">I</span><span class="p" data-group-id="3444797406-4">[</span><span class="mi">2</span><span class="p" data-group-id="3444797406-4">]</span><span class="p" data-group-id="3444797406-3">)</span><span class="p">;</span><span class="w">
  </span><span class="nf">xb</span><span class="p" data-group-id="3444797406-5">(</span><span class="n">BeamExtraData</span><span class="p" data-group-id="3444797406-6">(</span><span class="n">I</span><span class="p" data-group-id="3444797406-7">[</span><span class="mi">0</span><span class="p" data-group-id="3444797406-7">]</span><span class="p" data-group-id="3444797406-6">)</span><span class="p" data-group-id="3444797406-5">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I</span><span class="p" data-group-id="3444797406-8">[</span><span class="mi">1</span><span class="p" data-group-id="3444797406-8">]</span><span class="p">;</span><span class="w">
  </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
  </span><span class="n">ASSERT</span><span class="p" data-group-id="3444797406-9">(</span><span class="n">VALID_INSTR</span><span class="p" data-group-id="3444797406-10">(</span><span class="ss">next_pf</span><span class="p" data-group-id="3444797406-10">)</span><span class="p" data-group-id="3444797406-9">)</span><span class="p">;</span><span class="w">
  </span><span class="n">GotoPF</span><span class="p" data-group-id="3444797406-11">(</span><span class="ss">next_pf</span><span class="p" data-group-id="3444797406-11">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="3444797406-2">}</span></code></pre><p>We will go through each line in turn.</p><ul><li><p><code class="inline">OpCase(move_cx):</code> defines a label for the instruction.  The
<code class="inline">OpCase()</code> macro is defined in <code class="inline">beam_emu.c</code>.  It will expand this line
to <code class="inline">lb_move_cx:</code>.</p></li><li><p><code class="inline">BeamInstr next_pf = BeamCodeAddr(I[2]);</code> fetches the pointer to
code for the next instruction to be executed.  The <code class="inline">BeamCodeAddr()</code>
macro extracts the pointer from the lower 32 bits of the instruction
word.</p></li><li><p><code class="inline">xb(BeamExtraData(I[0])) = I[1];</code> is the expansion of <code class="inline">$Dst = $Src</code>.
<code class="inline">BeamExtraData()</code> is a macro that will extract the upper 32 bits from
the instruction word.  In this example, it will return 40 which is the
byte offset for X register 5.  The <code class="inline">xb()</code> macro will cast a byte
pointer to an <code class="inline">Eterm</code> pointer and dereference it.  The <code class="inline">I[1]</code> on
the right-hand side of the <code class="inline">=</code> fetches an Erlang term (the atom <code class="inline">id</code> in
this case).</p></li><li><p><code class="inline">I += 2</code> advances the instruction pointer to the next
instruction.</p></li><li><p>In a debug-compiled emulator, <code class="inline">ASSERT(VALID_INSTR(next_pf));</code> makes
sure that <code class="inline">next_pf</code> is a valid instruction (that is, that it points
within the <code class="inline">process_main()</code> function in <code class="inline">beam_emu.c</code>).</p></li><li><p><code class="inline">GotoPF(next_pf);</code> transfers control to the next instruction.</p></li></ul><p>Now let's look at the implementation of <code class="inline">move_xx</code>:</p><pre><code class="makeup erlang" translate="no"><span class="n">OpCase</span><span class="p" data-group-id="1849663936-1">(</span><span class="ss">move_xx</span><span class="p" data-group-id="1849663936-1">)</span><span class="p">:</span><span class="w">
</span><span class="p" data-group-id="1849663936-2">{</span><span class="w">
  </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">tmp_packed1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BeamExtraData</span><span class="p" data-group-id="1849663936-3">(</span><span class="n">I</span><span class="p" data-group-id="1849663936-4">[</span><span class="mi">0</span><span class="p" data-group-id="1849663936-4">]</span><span class="p" data-group-id="1849663936-3">)</span><span class="p">;</span><span class="w">
  </span><span class="n">BeamInstr</span><span class="w"> </span><span class="ss">next_pf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BeamCodeAddr</span><span class="p" data-group-id="1849663936-5">(</span><span class="n">I</span><span class="p" data-group-id="1849663936-6">[</span><span class="mi">1</span><span class="p" data-group-id="1849663936-6">]</span><span class="p" data-group-id="1849663936-5">)</span><span class="p">;</span><span class="w">
  </span><span class="nf">xb</span><span class="p" data-group-id="1849663936-7">(</span><span class="p" data-group-id="1849663936-8">(</span><span class="ss">tmp_packed1</span><span class="p">&gt;&gt;</span><span class="n">BEAM_TIGHT_SHIFT</span><span class="p" data-group-id="1849663936-8">)</span><span class="p" data-group-id="1849663936-7">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">xb</span><span class="p" data-group-id="1849663936-9">(</span><span class="ss">tmp_packed1</span><span class="err">&amp;</span><span class="n">BEAM_TIGHT_MASK</span><span class="p" data-group-id="1849663936-9">)</span><span class="p">;</span><span class="w">
  </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
  </span><span class="n">ASSERT</span><span class="p" data-group-id="1849663936-10">(</span><span class="n">VALID_INSTR</span><span class="p" data-group-id="1849663936-11">(</span><span class="ss">next_pf</span><span class="p" data-group-id="1849663936-11">)</span><span class="p" data-group-id="1849663936-10">)</span><span class="p">;</span><span class="w">
  </span><span class="n">GotoPF</span><span class="p" data-group-id="1849663936-12">(</span><span class="ss">next_pf</span><span class="p" data-group-id="1849663936-12">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="1849663936-2">}</span></code></pre><p>We will go through the lines that are new or have changed compared to
<code class="inline">move_cx</code>.</p><ul><li><p><code class="inline">Eterm tmp_packed1 = BeamExtraData(I[0]);</code> picks up both X register
numbers packed into the upper 32 bits of the instruction word.</p></li><li><p><code class="inline">BeamInstr next_pf = BeamCodeAddr(I[1]);</code> pre-fetches the address of
the next instruction. Note that because both X registers operands fits
into the instruction word, the next instruction is in the very next
word.</p></li><li><p><code class="inline">xb((tmp_packed1&gt;&gt;BEAM_TIGHT_SHIFT)) = xb(tmp_packed1&amp;BEAM_TIGHT_MASK);</code>
copies the source to the destination.  (For a 64-bit architecture,
<code class="inline">BEAM_TIGHT_SHIFT</code> is 16 and <code class="inline">BEAM_TIGHT_MASK</code> is <code class="inline">0xFFFF</code>.)</p></li><li><p><code class="inline">I += 1;</code> advances the instruction pointer to the next instruction.</p></li></ul><p><code class="inline">move_xy</code> is almost identical to <code class="inline">move_xx</code>.  The only difference is
the use of the <code class="inline">yb()</code> macro instead of <code class="inline">xb()</code> to reference the
destination register:</p><pre><code class="makeup erlang" translate="no"><span class="n">OpCase</span><span class="p" data-group-id="9187700444-1">(</span><span class="ss">move_xy</span><span class="p" data-group-id="9187700444-1">)</span><span class="p">:</span><span class="w">
</span><span class="p" data-group-id="9187700444-2">{</span><span class="w">
  </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">tmp_packed1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BeamExtraData</span><span class="p" data-group-id="9187700444-3">(</span><span class="n">I</span><span class="p" data-group-id="9187700444-4">[</span><span class="mi">0</span><span class="p" data-group-id="9187700444-4">]</span><span class="p" data-group-id="9187700444-3">)</span><span class="p">;</span><span class="w">
  </span><span class="n">BeamInstr</span><span class="w"> </span><span class="ss">next_pf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BeamCodeAddr</span><span class="p" data-group-id="9187700444-5">(</span><span class="n">I</span><span class="p" data-group-id="9187700444-6">[</span><span class="mi">1</span><span class="p" data-group-id="9187700444-6">]</span><span class="p" data-group-id="9187700444-5">)</span><span class="p">;</span><span class="w">
  </span><span class="nf">yb</span><span class="p" data-group-id="9187700444-7">(</span><span class="p" data-group-id="9187700444-8">(</span><span class="ss">tmp_packed1</span><span class="p">&gt;&gt;</span><span class="n">BEAM_TIGHT_SHIFT</span><span class="p" data-group-id="9187700444-8">)</span><span class="p" data-group-id="9187700444-7">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">xb</span><span class="p" data-group-id="9187700444-9">(</span><span class="ss">tmp_packed1</span><span class="err">&amp;</span><span class="n">BEAM_TIGHT_MASK</span><span class="p" data-group-id="9187700444-9">)</span><span class="p">;</span><span class="w">
  </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
  </span><span class="n">ASSERT</span><span class="p" data-group-id="9187700444-10">(</span><span class="n">VALID_INSTR</span><span class="p" data-group-id="9187700444-11">(</span><span class="ss">next_pf</span><span class="p" data-group-id="9187700444-11">)</span><span class="p" data-group-id="9187700444-10">)</span><span class="p">;</span><span class="w">
  </span><span class="n">GotoPF</span><span class="p" data-group-id="9187700444-12">(</span><span class="ss">next_pf</span><span class="p" data-group-id="9187700444-12">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="9187700444-2">}</span></code></pre><h3 id="transformation-rules" class="section-heading"><a href="#transformation-rules" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Transformation rules</span></h3><p>Next let's look at how we can do some optimizations using transformation
rules.  For simple instructions such as <code class="inline">move/2</code>, the instruction dispatch
overhead can be substantial.  A simple optimization is to combine common
instructions sequences to a single instruction.  One such common sequence
is multiple <code class="inline">move</code> instructions moving X registers to Y registers.</p><p>Using the following rule we can combine two <code class="inline">move</code> instructions
to a <code class="inline">move2</code> instruction:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="n">X1</span><span class="o">=</span><span class="ss">x</span><span class="w"> </span><span class="n">Y1</span><span class="o">=</span><span class="ss">y</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="ss">move</span><span class="w"> </span><span class="n">X2</span><span class="o">=</span><span class="ss">x</span><span class="w"> </span><span class="n">Y2</span><span class="o">=</span><span class="ss">y</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">move2</span><span class="w"> </span><span class="n">X1</span><span class="w"> </span><span class="n">Y1</span><span class="w"> </span><span class="n">X2</span><span class="w"> </span><span class="n">Y2</span></code></pre><p>The left-hand side of the arrow (<code class="inline">=&gt;</code>) is a pattern.  If the pattern
matches, the matching instructions will be replaced by the
instructions on the right-hand side.  Variables in a pattern must start
with an uppercase letter just as in Erlang.  A pattern variable may be
followed <code class="inline">=</code> and one or more type letters to constrain the match to
one of those types.  The variables that are bound on the left-hand side can
be used on the right-hand side.</p><p>We will also need to define a specific instruction and an implementation:</p><pre><code class="makeup erlang" translate="no"><span class="p">#</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="ss">ops</span><span class="p">.</span><span class="ss">tab</span><span class="w">
</span><span class="ss">move2</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">y</span><span class="w">

</span><span class="o">/</span><span class="o">/</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="ss">instrs</span><span class="p">.</span><span class="ss">tab</span><span class="w">
</span><span class="nf">move2</span><span class="p" data-group-id="0541010566-1">(</span><span class="n">S1</span><span class="p">,</span><span class="w"> </span><span class="n">D1</span><span class="p">,</span><span class="w"> </span><span class="n">S2</span><span class="p">,</span><span class="w"> </span><span class="n">D2</span><span class="p" data-group-id="0541010566-1">)</span><span class="w"> </span><span class="p" data-group-id="0541010566-2">{</span><span class="w">
    </span><span class="n">Eterm</span><span class="w"> </span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="n">V2</span><span class="p">;</span><span class="w">
    </span><span class="n">V1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$S</span><span class="mi">1</span><span class="p">;</span><span class="w">
    </span><span class="n">V2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$S</span><span class="mi">2</span><span class="p">;</span><span class="w">
    </span><span class="sc">$D</span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V1</span><span class="p">;</span><span class="w">
    </span><span class="sc">$D</span><span class="mi">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V2</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="0541010566-2">}</span></code></pre><p>When the loader has found a match and replaced the matched instructions,
it will match the new instructions against the transformation rules.
Because of that, we can define the rule for a <code class="inline">move3/6</code> instruction
as follows:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move2</span><span class="w"> </span><span class="n">X1</span><span class="o">=</span><span class="ss">x</span><span class="w"> </span><span class="n">Y1</span><span class="o">=</span><span class="ss">y</span><span class="w"> </span><span class="n">X2</span><span class="o">=</span><span class="ss">x</span><span class="w"> </span><span class="n">Y2</span><span class="o">=</span><span class="ss">y</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="ss">move</span><span class="w"> </span><span class="n">X3</span><span class="o">=</span><span class="ss">x</span><span class="w"> </span><span class="n">Y3</span><span class="o">=</span><span class="ss">y</span><span class="w"> </span><span class="p">=&gt;</span><span class="w">
      </span><span class="ss">move3</span><span class="w"> </span><span class="n">X1</span><span class="w"> </span><span class="n">Y1</span><span class="w"> </span><span class="n">X2</span><span class="w"> </span><span class="n">Y2</span><span class="w"> </span><span class="n">X3</span><span class="w"> </span><span class="n">Y3</span></code></pre><p>(For readability, a long transformation line can be broken after <code class="inline">|</code>
and <code class="inline">=&gt;</code> operators.)</p><p>It would also be possible to define it like this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="n">X1</span><span class="o">=</span><span class="ss">x</span><span class="w"> </span><span class="n">Y1</span><span class="o">=</span><span class="ss">y</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="ss">move</span><span class="w"> </span><span class="n">X2</span><span class="o">=</span><span class="ss">x</span><span class="w"> </span><span class="n">Y2</span><span class="o">=</span><span class="ss">y</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="ss">move</span><span class="w"> </span><span class="n">X3</span><span class="o">=</span><span class="ss">x</span><span class="w"> </span><span class="n">Y3</span><span class="o">=</span><span class="ss">y</span><span class="w"> </span><span class="p">=&gt;</span><span class="w">
     </span><span class="ss">move3</span><span class="w"> </span><span class="n">X1</span><span class="w"> </span><span class="n">Y1</span><span class="w"> </span><span class="n">X2</span><span class="w"> </span><span class="n">Y2</span><span class="w"> </span><span class="n">X3</span><span class="w"> </span><span class="n">Y3</span></code></pre><p>but in that case it must be defined before the rule for <code class="inline">move2/4</code>
because the first matching rule will be applied.</p><p>One must be careful not to create infinite loops.  For example, if we
for some reason would want to reverse the operand order for the <code class="inline">move</code>
instruction, we must not do like this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="n">Src</span><span class="w"> </span><span class="n">Dst</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">move</span><span class="w"> </span><span class="n">Dst</span><span class="w"> </span><span class="n">Src</span></code></pre><p>The loader would swap the operands forever.  To avoid the loop, we must
rename the instruction.  For example:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="n">Src</span><span class="w"> </span><span class="n">Dst</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">assign</span><span class="w"> </span><span class="n">Dst</span><span class="w"> </span><span class="n">Src</span></code></pre><p>This concludes the quick tour of the features of <strong>beam_makeops</strong>.</p><h2 id="short-overview-of-instruction-loading-for-the-interpreter" class="section-heading"><a href="#short-overview-of-instruction-loading-for-the-interpreter" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Short overview of instruction loading for the interpreter</span></h2><p>To give some background to the rest of this document, here follows a
quick overview of how instructions are loaded.</p><ul><li><p>The loader reads and decodes one instruction at a time from the BEAM
code and creates a generic instruction.  Many transformation rules
must look at multiple instructions, so the loader will
keep multiple generic instructions in a linked list.</p></li><li><p>The loader tries to apply transformation rules against the
generic instructions in the linked list.  If a rule matches, the
matched instructions will be removed and replaced with new
generic instructions constructed from the right-hand side of the
transformation.</p></li><li><p>If a transformation rule matched, the loader applies the
transformation rules again.</p></li><li><p>If no transformation rule match, the loader will begin rewriting
the first of generic instructions to a specific instruction.</p></li><li><p>First the loader will search for a specific operation where the
types for all operands match the type for the generic instruction.
The first matching instruction will be selected.  <strong>beam_makeops</strong>
has ordered the specific instructions so that instructions with more
specific operands comes before instructions with less specific
operands.  For example, <code class="inline">move_nx</code> is more specific than <code class="inline">move_cx</code>.  If
the first operand is <code class="inline">[]</code> (NIL), <code class="inline">move_nx</code> will be selected.</p></li><li><p>Given the opcode for the selected specific instruction, the loader
looks up the pointer to the C code for the instruction and stores
in the code area for the module being loaded.</p></li><li><p>The loader translates each operand to a machine word and stores it
in the code area.  The operand type for the selected specific
instruction guides the translation.  For example, if the type is <code class="inline">e</code>,
the value of the operand is an index into an array of external
functions and will be translated to a pointer to the export entry for
the function to call.  If the type is <code class="inline">x</code>, the number of the X
register will be multiplied by the word size to produce a byte offset.</p></li><li><p>The loader runs the packing engine to pack multiple operands into a
single word.  The packing engine is controlled by a small program,
which is a string where each character is an instruction.  For
example, the code to pack the operands for <code class="inline">move_xy</code> is <code class="inline">&quot;22#&quot;</code> (on a
64-bit machine).  That program will pack the byte offsets for both
registers into the same word as the pointer to C code.</p></li></ul><h2 id="short-overview-of-instruction-loading-for-beamasm" class="section-heading"><a href="#short-overview-of-instruction-loading-for-beamasm" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Short overview of instruction loading for BeamAsm</span></h2><ul><li><p>The first steps up to selection of a specific instruction is done
as described for the interpreter.  The selection of a specific instruction
is simpler, because in BeamAsm most generic instructions only have
a single corresponding specific instruction.</p></li><li><p>The loader calls the <em>emitter function</em> for the selected specific
instruction.  The emitter function translates the instruction to
machine code.</p></li></ul><h2 id="running-beam_makeops" class="section-heading"><a href="#running-beam_makeops" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Running beam_makeops</span></h2><p><strong>beam_makeops</strong> is found in <code class="inline">$ERL_TOP/erts/emulator/utils</code>.  Options
start with a hyphen (<code class="inline">-</code>).  The options are followed by the name of
the input files.  By convention, all input files have the extension
<code class="inline">.tab</code>, but is not enforced by <strong>beam_makeops</strong>.</p><h3 id="the-outdir-option" class="section-heading"><a href="#the-outdir-option" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">The -outdir option</span></h3><p>The option <code class="inline">-outdir Directory</code> specifies the output directory for
the generated files.  Default is the current working directory.</p><h3 id="running-beam_makeops-for-the-compiler" class="section-heading"><a href="#running-beam_makeops-for-the-compiler" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Running beam_makeops for the compiler</span></h3><p>Give the option <code class="inline">-compiler</code> to produce output files for the compiler.
The following files will be written to the output directory:</p><ul><li><p><code class="inline">beam_opcodes.erl</code> - Used primarily by <code class="inline">beam_asm</code> and <code class="inline">beam_diasm</code>.</p></li><li><p><code class="inline">beam_opcode.hrl</code> - Used by <code class="inline">beam_asm</code>.  It contains tag definitions
used for encoding instruction operands.</p></li></ul><p>The input file should only contain the definition of BEAM_FORMAT_NUMBER
and external generic instructions.  (Everything else would be ignored.)</p><h3 id="running-beam_makeops-for-the-emulator" class="section-heading"><a href="#running-beam_makeops-for-the-emulator" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Running beam_makeops for the emulator</span></h3><p>Give the option <code class="inline">-emulator</code> to produce output files for the emulator.
The following output files will be generated in the output directory.</p><ul><li><p><code class="inline">beam_opcodes.c</code> - Defines static data used by the loader
(<code class="inline">beam_load.c</code>), providing information about generic and specific
instructions, as well as all C code for the transformation rules.</p></li><li><p><code class="inline">beam_opcodes.h</code> - Miscellaneous preprocessor definitions, mainly
used by <code class="inline">beam_load.c</code> but also by <code class="inline">beam_{hot,warm,cold}.h</code>.</p></li></ul><p>For the traditional BEAM interpreter, the following files are also
generated:</p><ul><li><code class="inline">beam_hot.h</code>, <code class="inline">beam_warm.h</code>, <code class="inline">beam_cold.h</code> - Implementation of
instructions.  Included inside the <code class="inline">process_main()</code> function in
<code class="inline">beam_emu.c</code>.</li></ul><p>For BeamAsm, the following files are also generated:</p><ul><li><p><code class="inline">beamasm_emit.h</code> - Glue code to call emitter functions.</p></li><li><p><code class="inline">beamasm_protos.h</code> - Prototypes for all emitter functions.</p></li></ul><p>The following options can be given:</p><ul><li><p><code class="inline">wordsize 32|64</code> - Defines the word size.  Default is 32.</p></li><li><p><code class="inline">code-model Model</code> - The code model as given to <code class="inline">-mcmodel</code> option
for GCC.  Default is <code class="inline">unknown</code>.  If the code model is <code class="inline">small</code> (and
the word size is 64 bits), <strong>beam_makeops</strong> will pack operands
into the upper 32 bits of the instruction word.</p></li><li><p><code class="inline">DSymbol=0|1</code> - Defines the value for a symbol.  The symbol can be
used in <code class="inline">%if</code> and <code class="inline">%unless</code> directives.</p></li></ul><h2 id="syntax-of-tab-files" class="section-heading"><a href="#syntax-of-tab-files" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Syntax of .tab files</span></h2><h3 id="comments" class="section-heading"><a href="#comments" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Comments</span></h3><p>Any line starting with <code class="inline">#</code> is a comment and is ignored.</p><p>A line with <code class="inline">//</code> is also a comment.  It is recommended to only
use this style of comments in files that define implementations of
instructions.</p><p>A long transformation line can be broken after the <code class="inline">=&gt;</code> operator and
after <code class="inline">|</code> operators. Since OTP 25, this is the only way to break transformation
lines. When reading older source you may see that <code class="inline">\</code> was used for this
purpose, but we removed it since it was only seen together with <code class="inline">=&gt;</code> and <code class="inline">|</code>.</p><h3 id="variable-definitions" class="section-heading"><a href="#variable-definitions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Variable definitions</span></h3><p>A variable definition binds a variable to a Perl variable.  It is only
meaningful to add a new definition if <strong>beam_makeops</strong> is updated
at the same time to use the variable.  A variable definition looks this:</p><p><em>name</em>=<em>value</em>[;]</p><p>where <em>name</em> is the name of a Perl variable in <strong>beam_makeops</strong>,
and <em>value</em> is the value to be given to the variable.  The line
can optionally end with a <code class="inline">;</code> (to avoid messing up the
C indentation mode in Emacs).</p><p>Here follows a description of the variables that are defined.</p><h4>BEAM_FORMAT_NUMBER</h4><p><code class="inline">genop.tab</code> has the following definition:</p><pre><code class="makeup erlang" translate="no"><span class="n">BEAM_FORMAT_NUMBER</span><span class="o">=</span><span class="mi">0</span></code></pre><p>It defines the version of the instruction set (which will be
included in the code header in the BEAM code).  Theoretically,
the version could be bumped, and all instructions changed.
In practice, we would have two support two instruction sets
in the runtime system for at least two releases, so it will
probably never happen in practice.</p><h4>GC_REGEXP</h4><p>In <code class="inline">macros.tab</code>, there is a definition of <code class="inline">GC_REGEXP</code>.
It will be described in <a href="#the-GC_REGEXP-definition">a later section</a>.</p><h4>FORBIDDEN_TYPES</h4><p>In <code class="inline">asm/ops.tab</code>, there is a directive to forbid certain types
in specific instructions:</p><pre><code class="makeup erlang" translate="no"><span class="n">FORBIDDEN_TYPES</span><span class="o">=</span><span class="ss">hQ</span></code></pre><p>Especially for BeamAsm, all built-in types may not make sense, so <code class="inline">FORBIDDEN_TYPES</code>
makes it possible to enforce that some types should not be used.</p><p>Specific instructions will be described in <a href="#defining-specific-instructions">a later section</a>.</p><h3 id="directives" class="section-heading"><a href="#directives" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Directives</span></h3><p>There are directives to classify specific instructions depending
on how frequently used they are:</p><ul><li><p><code class="inline">%hot</code> - Implementation will be placed in <code class="inline">beam_hot.h</code>. Frequently
executed instructions.</p></li><li><p><code class="inline">%warm</code> - Implementation will be placed in <code class="inline">beam_warm.h</code>.  Binary
syntax instructions.</p></li><li><p><code class="inline">%cold</code> - Implementation will be placed in <code class="inline">beam_cold.h</code>. Trace
instructions and infrequently used instructions.</p></li></ul><p>Default is <code class="inline">%hot</code>.  The directives will be applied to declarations
of the specific instruction that follow.  Here is an example:</p><pre><code class="makeup erlang" translate="no"><span class="c1">%cold</span><span class="w">
</span><span class="nb">is_number</span><span class="w"> </span><span class="ss">f</span><span class="o">?</span><span class="w"> </span><span class="ss">xy</span><span class="w">
</span><span class="c1">%hot</span></code></pre><h4>Conditional compilation directives</h4><p>The <code class="inline">%if</code> directive includes a range of lines if a condition is
true.  For example:</p><pre><code class="makeup erlang" translate="no"><span class="c1">%if ARCH_64</span><span class="w">
</span><span class="ss">i_bs_get_integer_32</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">f</span><span class="o">?</span><span class="w"> </span><span class="ss">x</span><span class="w">
</span><span class="c1">%endif</span></code></pre><p>The specific instruction <code class="inline">i_bs_get_integer_32</code> will only be defined
on a 64-bit machine.</p><p>The condition can be inverted by using <code class="inline">%unless</code> instead of <code class="inline">%if</code>:</p><pre><code class="makeup erlang" translate="no"><span class="c1">%unless NO_FPE_SIGNALS</span><span class="w">
</span><span class="ss">fcheckerror</span><span class="w"> </span><span class="ss">p</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">i_fcheckerror</span><span class="w">
</span><span class="ss">i_fcheckerror</span><span class="w">
</span><span class="ss">fclearerror</span><span class="w">
</span><span class="c1">%endif</span></code></pre><p>It is also possible to add an <code class="inline">%else</code> clause:</p><pre><code class="makeup erlang" translate="no"><span class="c1">%if ARCH_64</span><span class="w">
</span><span class="n">BS_SAFE_MUL</span><span class="p" data-group-id="7432359909-1">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Fail</span><span class="p">,</span><span class="w"> </span><span class="n">Dst</span><span class="p" data-group-id="7432359909-1">)</span><span class="w"> </span><span class="p" data-group-id="7432359909-2">{</span><span class="w">
    </span><span class="n">Uint64</span><span class="w"> </span><span class="ss">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7432359909-3">(</span><span class="sc">$A</span><span class="p" data-group-id="7432359909-3">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p" data-group-id="7432359909-4">(</span><span class="sc">$B</span><span class="p" data-group-id="7432359909-4">)</span><span class="p">;</span><span class="w">
    </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="7432359909-5">(</span><span class="ss">res</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="sc">$B</span><span class="w"> </span><span class="o">!</span><span class="o">=</span><span class="w"> </span><span class="sc">$A</span><span class="p" data-group-id="7432359909-5">)</span><span class="w"> </span><span class="p" data-group-id="7432359909-6">{</span><span class="w">
        </span><span class="sc">$F</span><span class="ss">ail</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="7432359909-6">}</span><span class="w">
    </span><span class="sc">$D</span><span class="ss">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">res</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="7432359909-2">}</span><span class="w">
</span><span class="c1">%else</span><span class="w">
</span><span class="n">BS_SAFE_MUL</span><span class="p" data-group-id="7432359909-7">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Fail</span><span class="p">,</span><span class="w"> </span><span class="n">Dst</span><span class="p" data-group-id="7432359909-7">)</span><span class="w"> </span><span class="p" data-group-id="7432359909-8">{</span><span class="w">
    </span><span class="n">Uint64</span><span class="w"> </span><span class="ss">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7432359909-9">(</span><span class="n">Uint64</span><span class="p" data-group-id="7432359909-9">)</span><span class="p" data-group-id="7432359909-10">(</span><span class="sc">$A</span><span class="p" data-group-id="7432359909-10">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p" data-group-id="7432359909-11">(</span><span class="n">Uint64</span><span class="p" data-group-id="7432359909-11">)</span><span class="p" data-group-id="7432359909-12">(</span><span class="sc">$B</span><span class="p" data-group-id="7432359909-12">)</span><span class="p">;</span><span class="w">
    </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="7432359909-13">(</span><span class="p" data-group-id="7432359909-14">(</span><span class="ss">res</span><span class="w"> </span><span class="p">&gt;&gt;</span><span class="w"> </span><span class="p" data-group-id="7432359909-15">(</span><span class="mi">8</span><span class="o">*</span><span class="nf">sizeof</span><span class="p" data-group-id="7432359909-16">(</span><span class="n">Uint</span><span class="p" data-group-id="7432359909-16">)</span><span class="p" data-group-id="7432359909-15">)</span><span class="p" data-group-id="7432359909-14">)</span><span class="w"> </span><span class="o">!</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="7432359909-13">)</span><span class="w"> </span><span class="p" data-group-id="7432359909-17">{</span><span class="w">
        </span><span class="sc">$F</span><span class="ss">ail</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="7432359909-17">}</span><span class="w">
    </span><span class="sc">$D</span><span class="ss">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">res</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="7432359909-8">}</span><span class="w">
</span><span class="c1">%endif</span></code></pre><h4>Symbols that are defined in directives</h4><p>The following symbols are always defined.</p><ul><li><code class="inline">ARCH_64</code> - is 1 for a 64-bit machine, and 0 otherwise.</li><li><code class="inline">ARCH_32</code> - is 1 for 32-bit machine, and 0 otherwise.</li></ul><p>The <code class="inline">Makefile</code> for building the emulator currently defines the
following symbols by using the <code class="inline">-D</code> option on the command line for
<strong>beam_makeops</strong>.</p><ul><li><code class="inline">USE_VM_PROBES</code> - 1 if the runtime system is compiled to use VM
probes (support for dtrace or systemtap), 0 otherwise.</li></ul><h3 id="defining-external-generic-instructions" class="section-heading"><a href="#defining-external-generic-instructions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Defining external generic instructions</span></h3><p>External generic BEAM instructions are known to both the compiler and
the runtime system.  They remain stable between releases.  A new major
release may add more external generic instructions, but must not change
the semantics for a previously defined instruction.</p><p>The syntax for an external generic instruction is as follows:</p><p><em>opcode</em>: [-]<em>name</em>/<em>arity</em></p><p><em>opcode</em> is an integer greater than or equal to 1.</p><p><em>name</em> is an identifier starting with a lowercase letter.  <em>arity</em> is
an integer denoting the number of operands.</p><p><em>name</em> can optionally be preceded by <code class="inline">-</code> to indicate that it has been
obsoleted.  The compiler is not allowed to generate BEAM files that
use obsolete instructions and the loader will refuse to load BEAM
files that use obsolete instructions.</p><p>It only makes sense to define external generic instructions in the
file <code class="inline">genop.tab</code> in <code class="inline">lib/compiler/src</code>, because the compiler must
know about them in order to use them.</p><p>New instructions must be added at the end of the file, with higher
numbers than the previous instructions.</p><h3 id="defining-internal-generic-instructions" class="section-heading"><a href="#defining-internal-generic-instructions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Defining internal generic instructions</span></h3><p>Internal generic instructions are known only to the runtime
system and can be changed at any time without compatibility issues.</p><p>There are two ways to define internal generic instructions:</p><ul><li><p>Implicitly when a specific instruction is defined.  This is by far
the most common way.  Whenever a specific instruction is created,
<strong>beam_makeops</strong> automatically creates an internal generic instruction
if it does not previously exist.</p></li><li><p>Explicitly.  This is necessary only when a generic instruction is
used in transformations, but does not have any corresponding specific
instruction.</p></li></ul><p>The syntax for an internal generic instruction is as follows:</p><p><em>name</em>/<em>arity</em></p><p><em>name</em> is an identifier starting with a lowercase letter.  <em>arity</em> is
an integer denoting the number of operands.</p><h3 id="about-generic-instructions-in-general" class="section-heading"><a href="#about-generic-instructions-in-general" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">About generic instructions in general</span></h3><p>Each generic instruction has an opcode.  The opcode is an integer,
greater than or equal to 1. For an external generic instruction, it
must be explicitly given <code class="inline">genop.tab</code>, while internal generic
instructions are automatically numbered by <strong>beam_makeops</strong>.</p><p>The identity of a generic instruction is its name combined with its
arity.  That means that it is allowed to define two distinct generic
instructions having the same name but with different arities.  For
example:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move_window</span><span class="p">/</span><span class="mi">5</span><span class="w">
</span><span class="ss">move_window</span><span class="p">/</span><span class="mi">6</span></code></pre><p>Each operand of a generic instruction is tagged with its type.  A generic
instruction can have one of the following types:</p><ul><li><p><code class="inline">x</code> - X register.</p></li><li><p><code class="inline">y</code> - Y register.</p></li><li><p><code class="inline">l</code> - Floating point register number.</p></li><li><p><code class="inline">i</code> - Tagged literal integer.</p></li><li><p><code class="inline">a</code> - Tagged literal atom.</p></li><li><p><code class="inline">n</code> - NIL (<code class="inline">[]</code>, the empty list).</p></li><li><p><code class="inline">q</code> - Literal that don't fit in a word, that is an object stored on
the heap such as a list or tuple.  Any heap object type is supported,
even types that don't have real literals such as external references.</p></li><li><p><code class="inline">f</code> - Non-zero failure label.</p></li><li><p><code class="inline">p</code> - Zero failure label.</p></li><li><p><code class="inline">u</code> - Untagged integer that fits in a machine word.  It is used for many
different purposes, such as the number of live registers in <code class="inline">test_heap/2</code>,
as a reference to the export for <code class="inline">call_ext/2</code>, and as the flags operand for
binary syntax instructions.  When the generic instruction is translated to a
specific instruction, the type for the operand in the specific operation will
tell the loader how to treat the operand.</p></li><li><p><code class="inline">o</code> - Overflow.  If the value for an <code class="inline">u</code> operand does not fit in a machine
word, the type of the operand will be changed to <code class="inline">o</code> (with no associated
value).  Currently only used internally in the loader in the guard constraint
function <code class="inline">binary_too_big()</code>.</p></li><li><p><code class="inline">v</code> - Arity value.  Only used internally in the loader.</p></li></ul><h3 id="defining-specific-instructions" class="section-heading"><a href="#defining-specific-instructions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Defining specific instructions</span></h3><p>The specific instructions are known only to the runtime system and
are the instructions that are actually executed.  They can be changed
at any time without causing compatibility issues.</p><p>A specific instruction can have at most 6 operands if the family of
instructions it belongs to has more than one member.  The number of
operands is unlimited if there is only a single specific instruction
in a family.</p><p>A specific instruction is defined by first giving its name followed by
the types for each operand.  For example:</p><pre><code class="makeup erlang" translate="no"><span class="w"> </span><span class="ss">move</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">y</span></code></pre><p>Internally, for example in the generated code and in the output from
the BEAM disassembler, the instruction <code class="inline">move x y</code> will be called <code class="inline">move_xy</code>.</p><p>The name for a specific instruction is an identifier starting with a
lowercase letter.  A type is a lowercase or uppercase letter.</p><p>All specific instructions with a given name must have the same number
of operands. That is, the following is <strong>not</strong> allowed:</p><pre><code class="makeup erlang" translate="no"><span class="w"> </span><span class="ss">move</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">x</span><span class="w">
 </span><span class="ss">move</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">y</span></code></pre><p>Here follows the type letters that more or less directly corresponds
to the types for generic instructions.</p><ul><li><p><code class="inline">x</code> - X register.  Will be loaded as a byte offset to the X register
relative to the base of X register array.  (Can be packed with other
operands.)</p></li><li><p><code class="inline">y</code> - Y register.  Will be loaded as a byte offset to the Y register
relative to the stack frame. (Can be packed with other operands.)</p></li><li><p><code class="inline">r</code> - X register 0.  An implicit operand that will not be stored in
the loaded code.  (Not used in BeamAsm.)</p></li><li><p><code class="inline">l</code> - Floating point register number.  (Can be packed with other
operands.)</p></li><li><p><code class="inline">a</code> - Tagged atom.</p></li><li><p><code class="inline">n</code> - NIL or the empty list.  (Will not be stored in the loaded code.)</p></li><li><p><code class="inline">q</code> - Tagged CONS or BOXED pointer.  That is, a term such as a list
or tuple.  Any heap object type is supported, even types that don't
have real literals such as external references.</p></li><li><p><code class="inline">f</code> - Failure label (non-zero).  The target for a branch
or call instruction.</p></li><li><p><code class="inline">p</code> - The 0 failure label, meaning that an exception should be raised
if the instruction fails.  (Will not be stored in the loaded code.)</p></li><li><p><code class="inline">c</code> - Any literal term; that is, immediate literals such as SMALL,
and CONS or BOXED pointers to literals.  (Can be used where the
operand in the generic instruction has one of the types <code class="inline">i</code>, <code class="inline">a</code>, <code class="inline">n</code>,
or <code class="inline">q</code>.)</p></li></ul><p>The types that follow do a type test of the operand at runtime; thus,
they are generally more expensive in terms of runtime than the types
described earlier.  However, those operand types are needed to avoid a
combinatorial explosion in the number of specific instructions and
overall code size of <code class="inline">process_main()</code>.</p><ul><li><p><code class="inline">s</code> - Tagged source: X register, Y register, or a literal term.  The
tag will be tested at runtime to retrieve the value from an X
register, a Y register, or simply use the value as a tagged Erlang
term.  (Implementation note: An X register is tagged as a pid, and a Y
register as a port.  Therefore the literal term must not contain a
port or pid.)</p></li><li><p><code class="inline">S</code> - Tagged source register (X or Y).  The tag will be tested at
runtime to retrieve the value from an X register or a Y register.  Slightly
cheaper than <code class="inline">s</code>.</p></li><li><p><code class="inline">d</code> - Tagged destination register (X or Y).  The tag will be tested
at runtime to set up a pointer to the destination register.  If the
instruction performs a garbage collection, it must use the
<code class="inline">$REFRESH_GEN_DEST()</code> macro to refresh the pointer before storing to
it (there are more details about that in a later section).</p></li><li><p><code class="inline">j</code> - A failure label (combination of <code class="inline">f</code> and <code class="inline">p</code>).  If the branch target 0,
an exception will be raised if instruction fails, otherwise control will be
transferred to the target address.</p></li></ul><p>The types that follows are all applied to an operand that has the <code class="inline">u</code>
type.</p><ul><li><p><code class="inline">t</code> - An untagged integer that will fit in 12 bits (0-4096).  It can be
packed with other operands in a word.  Most often used as the number
of live registers in instructions such as <code class="inline">test_heap</code>.</p></li><li><p><code class="inline">I</code> - An untagged integer that will fit in 32 bits.  It can be
packed with other operands in a word on a 64-bit system.</p></li><li><p><code class="inline">W</code> - Untagged integer or pointer.  Not possible to pack with other
operands.</p></li><li><p><code class="inline">e</code> - Pointer to an export entry.  Use by call instructions that call
other modules, such as <code class="inline">call_ext</code>.</p></li><li><p><code class="inline">L</code> - A label.  Only used by the <code class="inline">label/1</code> instruction.</p></li><li><p><code class="inline">b</code> - Pointer to BIF.  Used in BIF instructions such as <code class="inline">call_bif</code>.</p></li><li><p><code class="inline">F</code> - Pointer to a fun entry. Used in <code class="inline">make_fun2</code> and friends.</p></li><li><p><code class="inline">A</code> - A tagged arityvalue.  Used in instructions that test the arity
of a tuple.</p></li><li><p><code class="inline">P</code> - A byte offset into a tuple.</p></li><li><p><code class="inline">Q</code> - A byte offset into the stack.  Used for updating the frame
pointer register.  Can be packed with other operands.</p></li><li><p><code class="inline">*</code> - This operand must be the last operand.  It indicates that a
variable number of operands follow.  Its use is mandatory for BeamAsm
when an instruction has a variable number of operands; see <a href="#handling-a-variable-number-of-operands">handling a
variable number of operands</a>.
It can be used for the interpreter as documentation, but it will have
no effect on the code generation.</p></li></ul><p>When the loader translates a generic instruction a specific
instruction, it will choose the most specific instruction that will
fit the types.  Consider the following two instructions:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">x</span><span class="w">
</span><span class="ss">move</span><span class="w"> </span><span class="ss">n</span><span class="w"> </span><span class="ss">x</span></code></pre><p>The <code class="inline">c</code> operand can encode any literal value, including NIL.  The
<code class="inline">n</code> operand only works for NIL.  If we have the generic instruction
<code class="inline">{move,nil,{x,1}}</code>, the loader will translate it to <code class="inline">move_nx 1</code>
because <code class="inline">move n x</code> is more specific.  <code class="inline">move_nx</code> could be slightly
faster or smaller (depending on the architecture), because the <code class="inline">[]</code>
is not stored explicitly as an operand.</p><h4>Syntactic sugar for specific instructions</h4><p>It is possible to specify more than one type letter for each operand.
Here is an example:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="ss">cxy</span><span class="w"> </span><span class="ss">xy</span></code></pre><p>This is syntactic sugar for:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">x</span><span class="w">
</span><span class="ss">move</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">y</span><span class="w">
</span><span class="ss">move</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">x</span><span class="w">
</span><span class="ss">move</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">y</span><span class="w">
</span><span class="ss">move</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="ss">x</span><span class="w">
</span><span class="ss">move</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="ss">y</span></code></pre><p>Note the difference between <code class="inline">move c xy</code> and <code class="inline">move c d</code>.  Note that <code class="inline">move c xy</code>
is equivalent to the following two definitions:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">x</span><span class="w">
</span><span class="ss">move</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="ss">y</span></code></pre><p>On the other hand, <code class="inline">move c d</code> is a single instruction.  At runtime,
the <code class="inline">d</code> operand will be tested to see whether it refers to an X
register or a Y register, and a pointer to the register will be set
up.</p><h4>The '?' type modifier</h4><p>The character <code class="inline">?</code> can be added to the end of an operand to indicate
that the operand will not be used every time the instruction is executed.
For example:</p><pre><code class="makeup erlang" translate="no"><span class="ss">allocate_heap</span><span class="w"> </span><span class="ss">t</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="ss">t</span><span class="o">?</span><span class="w">
</span><span class="ss">is_eq_exact</span><span class="w"> </span><span class="ss">f</span><span class="o">?</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">xy</span></code></pre><p>In <code class="inline">allocate_heap</code>, the last operand is the number of live registers.
It will only be used if there is not enough heap space and a garbage
collection must be performed.</p><p>In <code class="inline">is_eq_exact</code>, the failure address (the first operand) will only be
used if the two register operands are not equal.</p><p>Knowing that an operand is not always used can improve how packing
is done for some instructions.</p><p>For the <code class="inline">allocate_heap</code> instruction, without the <code class="inline">?</code> the packing would
be done like this:</p><pre><code class="makeup erlang" translate="no"><span class="w">     </span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="w">
</span><span class="n">I</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">|</span><span class="w">       </span><span class="n">Stack</span><span class="w"> </span><span class="ss">needed</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="p">&amp;&amp;</span><span class="ss">lb_allocate_heap</span><span class="w"> </span><span class="o">+</span><span class="w">
     </span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="w">
     </span><span class="p">|</span><span class="w">        </span><span class="n">Heap</span><span class="w"> </span><span class="ss">needed</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="n">Live</span><span class="w"> </span><span class="ss">registers</span><span class="w">     </span><span class="o">+</span><span class="w">
     </span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span></code></pre><p>&quot;Stack needed&quot; and &quot;Heap needed&quot; are always used, but they are in
different words.  Thus, at runtime the <code class="inline">allocate_heap</code> instruction
must read both words from memory even though it will not always use
&quot;Live registers&quot;.</p><p>With the <code class="inline">?</code>, the operands will be packed like this:</p><pre><code class="makeup erlang" translate="no"><span class="w">     </span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="w">
</span><span class="n">I</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">|</span><span class="w">     </span><span class="n">Live</span><span class="w"> </span><span class="ss">registers</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="p">&amp;&amp;</span><span class="ss">lb_allocate_heap</span><span class="w"> </span><span class="o">+</span><span class="w">
     </span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="w">
     </span><span class="p">|</span><span class="w">        </span><span class="n">Heap</span><span class="w"> </span><span class="ss">needed</span><span class="w"> </span><span class="p">|</span><span class="w">       </span><span class="n">Stack</span><span class="w"> </span><span class="ss">needed</span><span class="w"> </span><span class="o">+</span><span class="w">
     </span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">+</span></code></pre><p>Now &quot;Stack needed&quot; and &quot;Heap needed&quot; are in the same word.</p><h3 id="defining-transformation-rules" class="section-heading"><a href="#defining-transformation-rules" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Defining transformation rules</span></h3><p>Transformation rules are used to rewrite generic instructions to other
generic instructions.  The transformations rules are applied
repeatedly until no rule match.  At that point, the first instruction
in the resulting instruction sequence will be converted to a specific
instruction and added to the code for the module being loaded.  Then
the transformation rules for the remaining instructions are run in the
same way.</p><p>A rule is recognized by its right-pointer arrow: <code class="inline">=&gt;</code>.  To the left of
the arrow is one or more instruction patterns, separated by <code class="inline">|</code>.  To
the right of the arrow is zero or more instructions, separated by <code class="inline">|</code>.
If the instructions from the BEAM code matches the instruction
patterns on the left-hand side, they will be replaced with
instructions on the right-hand side (or removed if there are no
instructions on the right).</p><h4>Defining instruction patterns</h4><p>We will start looking at the patterns on the left-hand side of the arrow.</p><p>A pattern for an instruction consists of its name, followed by a pattern
for each of its operands.  The operand patterns are separated by spaces.</p><p>The simplest possible pattern is a variable.  Just like in Erlang,
a variable must begin with an uppercase letter.  In constrast to Erlang,
variables must <strong>not</strong> be repeated.</p><p>Variables that have been bound on the left-hand side can be used on
the right-hand side or in predicates.  For example, this rule will rewrite all
<code class="inline">move</code> instructions to <code class="inline">assign</code> instructions with the operands swapped:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="n">Src</span><span class="w"> </span><span class="n">Dst</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">assign</span><span class="w"> </span><span class="n">Dst</span><span class="w"> </span><span class="n">Src</span></code></pre><p>To help catch issues caused by unused variables (such as GH-8875), they are
considered errors. If you wish to give an operand a name for documentation
purposes, prefix it with an underscore (<code class="inline">_Foobar</code>) to mark the variable as
intentionally unused. Conversely, using a variable marked in this manner is
also an error.</p><p>If we only want to match operands of a certain type, we can
use a type constraint.  A type constraint consists of one or more
lowercase letters, each specifying a type.  For example:</p><pre><code class="makeup erlang" translate="no"><span class="nb">is_integer</span><span class="w"> </span><span class="n">Fail</span><span class="w"> </span><span class="ss">an</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">jump</span><span class="w"> </span><span class="n">Fail</span></code></pre><p>The second operand pattern, <code class="inline">an</code>, will match if the second operand is
either an atom or NIL (the empty list).  In case of a match, the
<code class="inline">is_integer/2</code> instruction will be replaced with a <code class="inline">jump/1</code>
instruction.</p><p>An operand pattern can bind a variable and constrain the type at the
same time by following the variable with a <code class="inline">=</code> and the constraint.
For example:</p><pre><code class="makeup erlang" translate="no"><span class="ss">is_eq_exact</span><span class="w"> </span><span class="n">Fail</span><span class="o">=</span><span class="ss">f</span><span class="w"> </span><span class="n">R</span><span class="o">=</span><span class="ss">xy</span><span class="w"> </span><span class="n">C</span><span class="o">=</span><span class="ss">q</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">i_is_eq_exact_literal</span><span class="w"> </span><span class="n">Fail</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="n">C</span></code></pre><p>Here the <code class="inline">is_eq_exact</code> instruction is replaced with a specialized instruction
that only compares literals, but only if the first operand is a register and
the second operand is a literal.</p><h4>Removing instructions</h4><p>The instructions of the left-hand side of the pattern can be removed
by using the <code class="inline">_</code> symbol on the right-hand side of the
transformation. For example, a <code class="inline">line</code> instruction without any actual
line-number information can be removed like this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">line</span><span class="w"> </span><span class="ss">n</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">_</span></code></pre><p>(Before OTP 25, this was instead achieved by leaving the right-hand side
blank.)</p><h4>Further constraining patterns</h4><p>In addition to specifying a type letter, the actual value for the type can
be specified.  For example:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="n">C</span><span class="o">=</span><span class="ss">c</span><span class="w"> </span><span class="ss">x</span><span class="o">==</span><span class="mi">1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">move_x1</span><span class="w"> </span><span class="n">C</span></code></pre><p>Here the second operand of <code class="inline">move</code> is constrained to be X register 1.</p><p>When specifying an atom constraint, the atom is written as it would be
in the C source code.  That is, it needs an <code class="inline">am_</code> prefix, and it must
be listed in <code class="inline">atom.names</code>.  For example, redundant <code class="inline">is_boolean</code> instructions
can be removed like this:</p><pre><code class="makeup erlang" translate="no"><span class="nb">is_boolean</span><span class="w"> </span><span class="n">Fail</span><span class="o">=</span><span class="ss">f</span><span class="w"> </span><span class="ss">a</span><span class="o">==</span><span class="ss">am_true</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">_</span><span class="w">
</span><span class="nb">is_boolean</span><span class="w"> </span><span class="n">Fail</span><span class="o">=</span><span class="ss">f</span><span class="w"> </span><span class="ss">a</span><span class="o">==</span><span class="ss">am_false</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">_</span></code></pre><p>There are several constraints available for testing whether a call is to a BIF
or a function.</p><p>The constraint <code class="inline">u$is_bif</code> will test whether the given operand refers to a BIF.
For example:</p><pre><code class="makeup erlang" translate="no"><span class="ss">call_ext</span><span class="w"> </span><span class="ss">u</span><span class="w"> </span><span class="n">Bif</span><span class="o">=</span><span class="ss">u</span><span class="sc">$i</span><span class="ss">s_bif</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">call_bif</span><span class="w"> </span><span class="n">Bif</span><span class="w">
</span><span class="ss">call_ext</span><span class="w"> </span><span class="ss">u</span><span class="w"> </span><span class="n">Func</span><span class="w">         </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">i_call_ext</span><span class="w"> </span><span class="n">Func</span></code></pre><p>The <code class="inline">call_ext</code> instruction can be used to call functions written in
Erlang as well as BIFs (or more properly called SNIFs).  The
<code class="inline">u$is_bif</code> constraint will match if the operand refers to a BIF (that
is, if it is listed in the file <code class="inline">bif.tab</code>).  Note that <code class="inline">u$is_bif</code>
should only be applied to operands that are known to contain an index
to the import table chunk in the BEAM file (such operands have the
type <code class="inline">b</code> or <code class="inline">e</code> in the corresponding specific instruction).  If
applied to other <code class="inline">u</code> operands, it will at best return a nonsense
result.</p><p>The <code class="inline">u$is_not_bif</code> constraint matches if the operand does not refer to
a BIF (not listed in <code class="inline">bif.tab</code>).  For example:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="n">X0</span><span class="o">=</span><span class="ss">x</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="ss">line</span><span class="w"> </span><span class="n">Loc</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="ss">call_ext_last</span><span class="w"> </span><span class="n">Ar</span><span class="w"> </span><span class="n">Func</span><span class="o">=</span><span class="ss">u</span><span class="sc">$i</span><span class="ss">s_not_bif</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="p">=&gt;</span><span class="w">
     </span><span class="ss">move</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="n">X0</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="ss">call_ext_last</span><span class="w"> </span><span class="n">Ar</span><span class="w"> </span><span class="n">Func</span><span class="w"> </span><span class="n">D</span></code></pre><p>The <code class="inline">u$bif:Module:Name/Arity</code> constraint tests whether the given
operand refers to a specific BIF.  Note that <code class="inline">Module:Name/Arity</code>
<strong>must</strong> be an existing BIF defined in <code class="inline">bif.tab</code>, or there will
be a compilation error.  It is useful when a call to a specific BIF
should be replaced with an instruction as in this example:</p><pre><code class="makeup erlang" translate="no"><span class="ss">gc_bif2</span><span class="w"> </span><span class="n">Fail</span><span class="w"> </span><span class="n">Live</span><span class="w"> </span><span class="ss">u</span><span class="sc">$b</span><span class="nc">if</span><span class="p">:</span><span class="nc">erlang</span><span class="p">:</span><span class="ss">splus</span><span class="p">/</span><span class="mi">2</span><span class="w"> </span><span class="n">S1</span><span class="w"> </span><span class="n">S2</span><span class="w"> </span><span class="n">Dst</span><span class="w"> </span><span class="p">=&gt;</span><span class="w">
     </span><span class="ss">gen_plus</span><span class="w"> </span><span class="n">Fail</span><span class="w"> </span><span class="n">Live</span><span class="w"> </span><span class="n">S1</span><span class="w"> </span><span class="n">S2</span><span class="w"> </span><span class="n">Dst</span></code></pre><p>Here the call to the GC BIF <code class="inline">'+'/2</code> will be replaced with the instruction
<code class="inline">gen_plus/5</code>.  Note that the same name as used in the C source code must be
used for the BIF, which in this case is <code class="inline">splus</code>.  It is defined like this
in <code class="inline">bit.tab</code>:</p><pre><code class="makeup erlang" translate="no"><span class="ss">ubif</span><span class="w"> </span><span class="nc">erlang</span><span class="p">:</span><span class="ss">&#39;+&#39;</span><span class="p">/</span><span class="mi">2</span><span class="w"> </span><span class="ss">splus_2</span></code></pre><p>The <code class="inline">u$func:Module:Name/Arity</code> will test whether the given operand is a
a specific function.  Here is an example:</p><pre><code class="makeup erlang" translate="no"><span class="ss">bif1</span><span class="w"> </span><span class="n">Fail</span><span class="w"> </span><span class="ss">u</span><span class="sc">$f</span><span class="nc">unc</span><span class="p">:</span><span class="nc">erlang</span><span class="p">:</span><span class="ss">is_constant</span><span class="p">/</span><span class="mi">1</span><span class="w"> </span><span class="n">Src</span><span class="w"> </span><span class="n">Dst</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">too_old_compiler</span></code></pre><p><code class="inline">is_constant/1</code> used to be a BIF a long time ago.  The transformation
replaces the call with the <code class="inline">too_old_compiler</code> instruction, which is
specially handled in the loader to produce a nicer error message than
the default error would be for a missing guard BIF.</p><h4>Type constraints allowed in patterns</h4><p>Here are all type letters that are allowed on the left-hand side of a
transformation rule.</p><ul><li><p><code class="inline">u</code> - An untagged integer that fits in a machine word.</p></li><li><p><code class="inline">x</code> - X register.</p></li><li><p><code class="inline">y</code> - Y register.</p></li><li><p><code class="inline">l</code> - Floating point register number.</p></li><li><p><code class="inline">i</code> - Tagged literal integer.</p></li><li><p><code class="inline">a</code> - Tagged literal atom.</p></li><li><p><code class="inline">n</code> - NIL (<code class="inline">[]</code>, the empty list).</p></li><li><p><code class="inline">q</code> - Literals that don't fit in a word, such as list or tuples.</p></li><li><p><code class="inline">f</code> - Non-zero failure label.</p></li><li><p><code class="inline">p</code> - The zero failure label.</p></li><li><p><code class="inline">j</code> - Any label.  Equivalent to <code class="inline">fp</code>.</p></li><li><p><code class="inline">c</code> - Any literal term.  Equivalent to <code class="inline">ainq</code>.</p></li><li><p><code class="inline">s</code> - X register, Y register, or any literal term.  Equivalent to <code class="inline">xyc</code>.</p></li><li><p><code class="inline">d</code> - X or Y register.  Equivalent to <code class="inline">xy</code>.  (In a pattern <code class="inline">d</code> will
match both source and destination registers.  As an operand in a specific
instruction, it must only be used for a destination register.)</p></li><li><p><code class="inline">o</code> - Overflow.  An untagged integer that does not fit in a machine word.</p></li></ul><h4>Predicates</h4><p>If the constraints described so far is not enough, additional
constraints can be implemented in C and be called as a guard function
on the left-hand side of the transformation.  If the guard function returns
a non-zero value, the matching of the rule will continue, otherwise
the match will fail.  Such guard functions are hereafter called
<em>predicates</em>.</p><p>The most commonly used guard constraints is <code class="inline">equal()</code>. It can be used
to remove a redundant <code class="inline">move</code> instructio like this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="n">R1</span><span class="w"> </span><span class="n">R2</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">equal</span><span class="p" data-group-id="2764988107-1">(</span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">R2</span><span class="p" data-group-id="2764988107-1">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">_</span></code></pre><p>or remove a redundant <code class="inline">is_eq_exact</code> instruction like this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">is_eq_exact</span><span class="w"> </span><span class="n">Lbl</span><span class="w"> </span><span class="n">Src1</span><span class="w"> </span><span class="n">Src2</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">equal</span><span class="p" data-group-id="7608993518-1">(</span><span class="n">Src1</span><span class="p">,</span><span class="w"> </span><span class="n">Src2</span><span class="p" data-group-id="7608993518-1">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">_</span></code></pre><p>At the time of writing, all predicates are defined in files named
<code class="inline">predicates.tab</code> in several directories.  In <code class="inline">predicates.tab</code> directly
in <code class="inline">$ERL_TOP/erts/emulator/beam</code>, predicates that are used by both the
traditinal emulator and the JIT implementations are contained.
Predicates only used by the emulator can be found in
<code class="inline">emu/predicates.tab</code>.</p><h3 id="a-very-brief-note-on-implementation-of-predicates" class="section-heading"><a href="#a-very-brief-note-on-implementation-of-predicates" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">A very brief note on implementation of predicates</span></h3><p>It is outside the scope for this document to describe in detail how
predicates are implemented because it requires knowledge of the
internal loader data structures, but here is quick look at the
implementation of a simple predicate called <code class="inline">literal_is_map()</code>.</p><p>Here is first an example how it is used:</p><p>   is<em>map Fail Lit=q | literal_is_map(Lit) =&gt; </em></p><p>If the <code class="inline">Lit</code> operand is a literal, then the <code class="inline">literal_is_map()</code>
predicate is called to determine whether it is a map literal.
If it is, the instruction is not needed and can be removed.</p><p><code class="inline">literal_is_map()</code> is implemented like this (in <code class="inline">emu/predicates.tab</code>):</p><pre><code class="makeup erlang" translate="no"><span class="ss">pred</span><span class="p">.</span><span class="nf">literal_is_map</span><span class="p" data-group-id="8678203294-1">(</span><span class="n">Lit</span><span class="p" data-group-id="8678203294-1">)</span><span class="w"> </span><span class="p" data-group-id="8678203294-2">{</span><span class="w">
    </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">term</span><span class="p">;</span><span class="w">

    </span><span class="n">ASSERT</span><span class="p" data-group-id="8678203294-3">(</span><span class="n">Lit</span><span class="p">.</span><span class="ss">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TAG_q</span><span class="p" data-group-id="8678203294-3">)</span><span class="p">;</span><span class="w">
    </span><span class="ss">term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">beamfile_get_literal</span><span class="p" data-group-id="8678203294-4">(</span><span class="err">&amp;</span><span class="n">S</span><span class="p">-&gt;</span><span class="ss">beam</span><span class="p">,</span><span class="w"> </span><span class="n">Lit</span><span class="p">.</span><span class="ss">val</span><span class="p" data-group-id="8678203294-4">)</span><span class="p">;</span><span class="w">
    </span><span class="ss">return</span><span class="w"> </span><span class="nf">is_map</span><span class="p" data-group-id="8678203294-5">(</span><span class="ss">term</span><span class="p" data-group-id="8678203294-5">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="8678203294-2">}</span></code></pre><p>The <code class="inline">pred.</code> prefix tells <strong>beam_makeops</strong> that this function is a
predicate.  Without the prefix, it would have been interpreted as the
implementation of an instruction (described in <strong>Defining the
implementation</strong>).</p><p>Predicate functions have a magic variabled called <code class="inline">S</code>, which is a
pointer to a state struct. In the example,
<code class="inline">beamfile_get_literal(&amp;S-&gt;beam, Lit.val);</code> is used to retrieve the actual term
for the literal.</p><p>At the time of writing, the expanded C code generated by
<strong>beam_makeops</strong> looks like this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">static</span><span class="w"> </span><span class="ss">int</span><span class="w"> </span><span class="nf">literal_is_map</span><span class="p" data-group-id="0723012150-1">(</span><span class="n">LoaderState</span><span class="o">*</span><span class="w"> </span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">BeamOpArg</span><span class="w"> </span><span class="n">Lit</span><span class="p" data-group-id="0723012150-1">)</span><span class="w"> </span><span class="p" data-group-id="0723012150-2">{</span><span class="w">
  </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">term</span><span class="p">;</span><span class="w">

  </span><span class="n">ASSERT</span><span class="p" data-group-id="0723012150-3">(</span><span class="n">Lit</span><span class="p">.</span><span class="ss">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TAG_q</span><span class="p" data-group-id="0723012150-3">)</span><span class="p">;</span><span class="w">
  </span><span class="ss">term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p">-&gt;</span><span class="ss">literals</span><span class="p" data-group-id="0723012150-4">[</span><span class="n">Lit</span><span class="p">.</span><span class="ss">val</span><span class="p" data-group-id="0723012150-4">]</span><span class="p">.</span><span class="ss">term</span><span class="p">;</span><span class="w">
  </span><span class="ss">return</span><span class="w"> </span><span class="nf">is_map</span><span class="p" data-group-id="0723012150-5">(</span><span class="ss">term</span><span class="p" data-group-id="0723012150-5">)</span><span class="p">;</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="0723012150-2">}</span></code></pre><h4>Handling instructions with variable number of operands</h4><p>Some instructions, such as <code class="inline">select_val/3</code>, essentially has a variable
number of operands.  Such instructions have a <code class="inline">{list,[...]}</code> operand
as their last operand in the BEAM assembly code.  For example:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="9628163751-1">{</span><span class="ss">select_val</span><span class="p">,</span><span class="p" data-group-id="9628163751-2">{</span><span class="ss">x</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="9628163751-2">}</span><span class="p">,</span><span class="w">
            </span><span class="p" data-group-id="9628163751-3">{</span><span class="ss">f</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="9628163751-3">}</span><span class="p">,</span><span class="w">
            </span><span class="p" data-group-id="9628163751-4">{</span><span class="ss">list</span><span class="p">,</span><span class="p" data-group-id="9628163751-5">[</span><span class="p" data-group-id="9628163751-6">{</span><span class="ss">atom</span><span class="p">,</span><span class="ss">b</span><span class="p" data-group-id="9628163751-6">}</span><span class="p">,</span><span class="p" data-group-id="9628163751-7">{</span><span class="ss">f</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="9628163751-7">}</span><span class="p">,</span><span class="p" data-group-id="9628163751-8">{</span><span class="ss">atom</span><span class="p">,</span><span class="ss">a</span><span class="p" data-group-id="9628163751-8">}</span><span class="p">,</span><span class="p" data-group-id="9628163751-9">{</span><span class="ss">f</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="9628163751-9">}</span><span class="p" data-group-id="9628163751-5">]</span><span class="p" data-group-id="9628163751-4">}</span><span class="p" data-group-id="9628163751-1">}</span><span class="p">.</span></code></pre><p>The loader will convert a <code class="inline">{list,[...]}</code> operand to an <code class="inline">u</code> operand whose
value is the number of elements in the list, followed by each element in
the list.  The instruction above would be translated to the following
generic instruction:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="2900311217-1">{</span><span class="ss">select_val</span><span class="p">,</span><span class="p" data-group-id="2900311217-2">{</span><span class="ss">x</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="2900311217-2">}</span><span class="p">,</span><span class="p" data-group-id="2900311217-3">{</span><span class="ss">f</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="2900311217-3">}</span><span class="p">,</span><span class="p" data-group-id="2900311217-4">{</span><span class="ss">u</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="2900311217-4">}</span><span class="p">,</span><span class="p" data-group-id="2900311217-5">{</span><span class="ss">atom</span><span class="p">,</span><span class="ss">b</span><span class="p" data-group-id="2900311217-5">}</span><span class="p">,</span><span class="p" data-group-id="2900311217-6">{</span><span class="ss">f</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="2900311217-6">}</span><span class="p">,</span><span class="p" data-group-id="2900311217-7">{</span><span class="ss">atom</span><span class="p">,</span><span class="ss">a</span><span class="p" data-group-id="2900311217-7">}</span><span class="p">,</span><span class="p" data-group-id="2900311217-8">{</span><span class="ss">f</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="2900311217-8">}</span><span class="p" data-group-id="2900311217-1">}</span></code></pre><p>To match a variable number of arguments we need to use the special
operand type <code class="inline">*</code> like this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">select_val</span><span class="w"> </span><span class="n">Src</span><span class="o">=</span><span class="ss">aiq</span><span class="w"> </span><span class="n">Fail</span><span class="o">=</span><span class="ss">f</span><span class="w"> </span><span class="n">Size</span><span class="o">=</span><span class="ss">u</span><span class="w"> </span><span class="n">List</span><span class="o">=</span><span class="o">*</span><span class="w"> </span><span class="p">=&gt;</span><span class="w">
    </span><span class="ss">i_const_select_val</span><span class="w"> </span><span class="n">Src</span><span class="w"> </span><span class="n">Fail</span><span class="w"> </span><span class="n">Size</span><span class="w"> </span><span class="n">List</span></code></pre><p>This transformation renames a <code class="inline">select_val/3</code> instruction
with a constant source operand to <code class="inline">i_const_select_val/3</code>.</p><h4>Constructing new instructions on the right-hand side</h4><p>The most common operand on the right-hand side is a variable that was
bound while matching the pattern on the left-hand side.  For example:</p><pre><code class="makeup erlang" translate="no"><span class="ss">trim</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="n">Remaining</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">i_trim</span><span class="w"> </span><span class="n">N</span></code></pre><p>An operand can also be a type letter to construct an operand of that
type.  Each type has a default value.  For example, the type <code class="inline">x</code> has
the default value 1023, which is the highest X register.  That makes
<code class="inline">x</code> on the right-hand side a convenient shortcut for a temporary X
register.  For example:</p><pre><code class="makeup erlang" translate="no"><span class="nb">is_number</span><span class="w"> </span><span class="n">Fail</span><span class="w"> </span><span class="n">Literal</span><span class="o">=</span><span class="ss">q</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">move</span><span class="w"> </span><span class="n">Literal</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nb">is_number</span><span class="w"> </span><span class="n">Fail</span><span class="w"> </span><span class="ss">x</span></code></pre><p>If the second operand for <code class="inline">is_number/2</code> is a literal, it will be moved to
X register 1023.  Then <code class="inline">is_number/2</code> will test whether the value stored in
X register 1023 is a number.</p><p>This kind of transformation is useful when it is rare that an operand can
be anything else but a register.  In the case of <code class="inline">is_number/2</code>, the second
operand is always a register unless the compiler optimizations have been
disabled.</p><p>If the default value is not suitable, the type letter can be followed
by <code class="inline">=</code> and a value.  Most types take an integer value.  The value for
an atom is written the same way as in the C source code.  For example,
the atom <code class="inline">false</code> is written as <code class="inline">am_false</code>.  The atom must be listed in
<code class="inline">atom.names</code>.</p><p>Here is an example showing how values can be specified:</p><pre><code class="makeup erlang" translate="no"><span class="ss">bs_put_utf32</span><span class="w"> </span><span class="n">Fail</span><span class="o">=</span><span class="ss">j</span><span class="w"> </span><span class="n">Flags</span><span class="o">=</span><span class="ss">u</span><span class="w"> </span><span class="n">Src</span><span class="o">=</span><span class="ss">s</span><span class="w"> </span><span class="p">=&gt;</span><span class="w">
    </span><span class="ss">i_bs_validate_unicode</span><span class="w"> </span><span class="n">Fail</span><span class="w"> </span><span class="n">Src</span><span class="w"> </span><span class="p">|</span><span class="w">
    </span><span class="ss">bs_put_integer</span><span class="w"> </span><span class="n">Fail</span><span class="w"> </span><span class="ss">i</span><span class="o">=</span><span class="mi">32</span><span class="w"> </span><span class="ss">u</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">Flags</span><span class="w"> </span><span class="n">Src</span></code></pre><h4>Type letters on the right-hand side</h4><p>Here follows all types that are allowed to be used in operands for
instructions being constructed on the right-hand side of a
transformation rule.</p><ul><li><p><code class="inline">u</code> - Construct an untagged integer.  The default value is 0.</p></li><li><p><code class="inline">x</code> - X register.  The default value is 1023.  That makes <code class="inline">x</code> convenient to
use as a temporary X register.</p></li><li><p><code class="inline">y</code> - Y register.  The default value is 0.</p></li><li><p><code class="inline">l</code> - Floating point register number.  The default value is 0.</p></li><li><p><code class="inline">i</code> - Tagged literal integer.  The default value is 0.</p></li><li><p><code class="inline">a</code> - Tagged atom.  The default value is the empty atom (<code class="inline">am_Empty</code>).</p></li><li><p><code class="inline">p</code> - Zero failure label.</p></li><li><p><code class="inline">n</code> - NIL (<code class="inline">[]</code>, the empty list).</p></li></ul><h4>Function call on the right-hand side</h4><p>Transformations that are not possible to describe with the rule
language as described here can be implemented as a generator function
in C and called from the right-hand side of a transformation.  The left-hand
side of the transformation will perform the match and bind operands to
variables.  The variables can then be passed to a generator function
on the right-hand side.  For example:</p><pre><code class="makeup erlang" translate="no"><span class="ss">bif2</span><span class="w"> </span><span class="n">Fail</span><span class="o">=</span><span class="ss">j</span><span class="w"> </span><span class="ss">u</span><span class="sc">$b</span><span class="nc">if</span><span class="p">:</span><span class="nc">erlang</span><span class="p">:</span><span class="nb">element</span><span class="p">/</span><span class="mi">2</span><span class="w"> </span><span class="n">Index</span><span class="o">=</span><span class="ss">s</span><span class="w"> </span><span class="n">Tuple</span><span class="o">=</span><span class="ss">xy</span><span class="w"> </span><span class="n">Dst</span><span class="o">=</span><span class="ss">d</span><span class="w"> </span><span class="p">=&gt;</span><span class="w">
    </span><span class="nf">element</span><span class="p" data-group-id="4511974985-1">(</span><span class="n">Jump</span><span class="p">,</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">Tuple</span><span class="p">,</span><span class="w"> </span><span class="n">Dst</span><span class="p" data-group-id="4511974985-1">)</span></code></pre><p>This transformation rule matches a call to the BIF <a href="erlang.html#element/2"><code class="inline">element/2</code></a>.
The operands will be captured and the generator function <code class="inline">element()</code> will
be called.</p><p>The <code class="inline">element()</code> generator will produce one of two instructions
depending on <code class="inline">Index</code>.  If <code class="inline">Index</code> is an integer in the range from 1 up
to the maximum tuple size, the instruction <code class="inline">i_fast_element/2</code> will be
produced, otherwise the instruction <code class="inline">i_element/4</code> will be produced.
The corresponding specific instructions are:</p><pre><code class="makeup erlang" translate="no"><span class="ss">i_fast_element</span><span class="w"> </span><span class="ss">xy</span><span class="w"> </span><span class="ss">j</span><span class="o">?</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="ss">d</span><span class="w">
</span><span class="ss">i_element</span><span class="w"> </span><span class="ss">xy</span><span class="w"> </span><span class="ss">j</span><span class="o">?</span><span class="w"> </span><span class="ss">s</span><span class="w"> </span><span class="ss">d</span></code></pre><p>The <code class="inline">i_fast_element/2</code> instruction is faster because the tuple is
already an untagged integer.  It also knows that the index is at least
1, so it does not have to test for that.  The <code class="inline">i_element/4</code>
instruction will have to fetch the index from a register, test that it
is an integer, and untag the integer.</p><p>At the time of writing, all generators functions were defined in files
named <code class="inline">generators.tab</code> in several directories (in the same directories
as the <code class="inline">predicates.tab</code> files).</p><p>It is outside the scope of this document to describe in detail how
generator functions are written, but here is the implementation of
<code class="inline">element()</code>:</p><pre><code class="makeup erlang" translate="no"><span class="ss">gen</span><span class="p">.</span><span class="nf">element</span><span class="p" data-group-id="5063918034-1">(</span><span class="n">Fail</span><span class="p">,</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">Tuple</span><span class="p">,</span><span class="w"> </span><span class="n">Dst</span><span class="p" data-group-id="5063918034-1">)</span><span class="w"> </span><span class="p" data-group-id="5063918034-2">{</span><span class="w">
    </span><span class="n">BeamOp</span><span class="o">*</span><span class="w"> </span><span class="ss">op</span><span class="p">;</span><span class="w">

    </span><span class="sc">$N</span><span class="nf">ewBeamOp</span><span class="p" data-group-id="5063918034-3">(</span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="ss">op</span><span class="p" data-group-id="5063918034-3">)</span><span class="p">;</span><span class="w">

    </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="5063918034-4">(</span><span class="n">Index</span><span class="p">.</span><span class="ss">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TAG_i</span><span class="w"> </span><span class="p">&amp;&amp;</span><span class="w"> </span><span class="n">Index</span><span class="p">.</span><span class="ss">val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">&amp;&amp;</span><span class="w">
        </span><span class="n">Index</span><span class="p">.</span><span class="ss">val</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">ERTS_MAX_TUPLE_SIZE</span><span class="w"> </span><span class="p">&amp;&amp;</span><span class="w">
        </span><span class="p" data-group-id="5063918034-5">(</span><span class="n">Tuple</span><span class="p">.</span><span class="ss">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TAG_x</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">Tuple</span><span class="p">.</span><span class="ss">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TAG_y</span><span class="p" data-group-id="5063918034-5">)</span><span class="p" data-group-id="5063918034-4">)</span><span class="w"> </span><span class="p" data-group-id="5063918034-6">{</span><span class="w">
        </span><span class="sc">$B</span><span class="nf">eamOpNameArity</span><span class="p" data-group-id="5063918034-7">(</span><span class="ss">op</span><span class="p">,</span><span class="w"> </span><span class="ss">i_fast_element</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="5063918034-7">)</span><span class="p">;</span><span class="w">
        </span><span class="ss">op</span><span class="p">-&gt;</span><span class="ss">a</span><span class="p" data-group-id="5063918034-8">[</span><span class="mi">0</span><span class="p" data-group-id="5063918034-8">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Tuple</span><span class="p">;</span><span class="w">
        </span><span class="ss">op</span><span class="p">-&gt;</span><span class="ss">a</span><span class="p" data-group-id="5063918034-9">[</span><span class="mi">1</span><span class="p" data-group-id="5063918034-9">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Fail</span><span class="p">;</span><span class="w">
        </span><span class="ss">op</span><span class="p">-&gt;</span><span class="ss">a</span><span class="p" data-group-id="5063918034-10">[</span><span class="mi">2</span><span class="p" data-group-id="5063918034-10">]</span><span class="p">.</span><span class="ss">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TAG_u</span><span class="p">;</span><span class="w">
        </span><span class="ss">op</span><span class="p">-&gt;</span><span class="ss">a</span><span class="p" data-group-id="5063918034-11">[</span><span class="mi">2</span><span class="p" data-group-id="5063918034-11">]</span><span class="p">.</span><span class="ss">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Index</span><span class="p">.</span><span class="ss">val</span><span class="p">;</span><span class="w">
        </span><span class="ss">op</span><span class="p">-&gt;</span><span class="ss">a</span><span class="p" data-group-id="5063918034-12">[</span><span class="mi">3</span><span class="p" data-group-id="5063918034-12">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dst</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="5063918034-6">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p" data-group-id="5063918034-13">{</span><span class="w">
        </span><span class="sc">$B</span><span class="nf">eamOpNameArity</span><span class="p" data-group-id="5063918034-14">(</span><span class="ss">op</span><span class="p">,</span><span class="w"> </span><span class="ss">i_element</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="5063918034-14">)</span><span class="p">;</span><span class="w">
        </span><span class="ss">op</span><span class="p">-&gt;</span><span class="ss">a</span><span class="p" data-group-id="5063918034-15">[</span><span class="mi">0</span><span class="p" data-group-id="5063918034-15">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Tuple</span><span class="p">;</span><span class="w">
        </span><span class="ss">op</span><span class="p">-&gt;</span><span class="ss">a</span><span class="p" data-group-id="5063918034-16">[</span><span class="mi">1</span><span class="p" data-group-id="5063918034-16">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Fail</span><span class="p">;</span><span class="w">
        </span><span class="ss">op</span><span class="p">-&gt;</span><span class="ss">a</span><span class="p" data-group-id="5063918034-17">[</span><span class="mi">2</span><span class="p" data-group-id="5063918034-17">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Index</span><span class="p">;</span><span class="w">
        </span><span class="ss">op</span><span class="p">-&gt;</span><span class="ss">a</span><span class="p" data-group-id="5063918034-18">[</span><span class="mi">3</span><span class="p" data-group-id="5063918034-18">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dst</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="5063918034-13">}</span><span class="w">

    </span><span class="ss">return</span><span class="w"> </span><span class="ss">op</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="5063918034-2">}</span></code></pre><p>The <code class="inline">gen.</code> prefix tells <strong>beam_makeops</strong> that this function is a
generator.  Without the prefix, it would have been interpreted as the
implementation of an instruction (described in <strong>Defining the
implementation</strong>).</p><p>Generator functions have a magic variabled called <code class="inline">S</code>, which is a
pointer to a state struct.  In the example, <code class="inline">S</code> is used in the invocation
of the <code class="inline">NewBeamOp</code> macro.</p><h3 id="defining-the-implementation" class="section-heading"><a href="#defining-the-implementation" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Defining the implementation</span></h3><p>For the traditional BEAM interpreter, the actual implementation of
instructions are also defined in <code class="inline">.tab</code> files processed by
<strong>beam_makeops</strong>.  See <a href="#code-generation-for-beamasm">Code generation for
BeamAsm</a> for a brief introduction to
how code generation is done for BeamAsm.</p><p>For practical reasons, instruction definitions are stored in several
files, at the time of writing in the following files (in the
<code class="inline">beam/emu</code> directory):</p><pre><code class="makeup erlang" translate="no"><span class="ss">bif_instrs</span><span class="p">.</span><span class="ss">tab</span><span class="w">
</span><span class="ss">arith_instrs</span><span class="p">.</span><span class="ss">tab</span><span class="w">
</span><span class="ss">bs_instrs</span><span class="p">.</span><span class="ss">tab</span><span class="w">
</span><span class="ss">float_instrs</span><span class="p">.</span><span class="ss">tab</span><span class="w">
</span><span class="ss">instrs</span><span class="p">.</span><span class="ss">tab</span><span class="w">
</span><span class="ss">map_instrs</span><span class="p">.</span><span class="ss">tab</span><span class="w">
</span><span class="ss">msg_instrs</span><span class="p">.</span><span class="ss">tab</span><span class="w">
</span><span class="ss">select_instrs</span><span class="p">.</span><span class="ss">tab</span><span class="w">
</span><span class="ss">trace_instrs</span><span class="p">.</span><span class="ss">tab</span></code></pre><p>There is also a file that only contains macro definitions:</p><pre><code class="makeup erlang" translate="no"><span class="ss">macros</span><span class="p">.</span><span class="ss">tab</span></code></pre><p>The syntax of each file is similar to C code.  In fact, most of
the contents <em>is</em> C code, interspersed with macro invocations.</p><p>To allow Emacs to auto-indent the code, each file starts with the
following line:</p><pre><code class="makeup erlang" translate="no"><span class="o">/</span><span class="o">/</span><span class="w"> </span><span class="o">-</span><span class="o">*</span><span class="o">-</span><span class="w"> </span><span class="ss">c</span><span class="w"> </span><span class="o">-</span><span class="o">*</span><span class="o">-</span></code></pre><p>To avoid messing up the indentation, all comments are written
as C++ style comments (<code class="inline">//</code>) instead of <code class="inline">#</code>.  Note that a comment
must start at the beginning of a line.</p><p>The meat of an instruction definition file are macro definitions.
We have seen this macro definition before:</p><pre><code class="makeup erlang" translate="no"><span class="nf">move</span><span class="p" data-group-id="3837424124-1">(</span><span class="n">Src</span><span class="p">,</span><span class="w"> </span><span class="n">Dst</span><span class="p" data-group-id="3837424124-1">)</span><span class="w"> </span><span class="p" data-group-id="3837424124-2">{</span><span class="w">
    </span><span class="sc">$D</span><span class="ss">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$S</span><span class="ss">rc</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="3837424124-2">}</span></code></pre><p>A macro definitions must start at the beginning of the line (no spaces
allowed), the opening curly bracket must be on the same line, and the
finishing curly bracket must be at the beginning of a line.  It is
recommended that the macro body is properly indented.</p><p>As a convention, the macro arguments in the head all start with an
uppercase letter.  In the body, the macro arguments can be expanded
by preceding them with <code class="inline">$</code>.</p><p>A macro definition whose name and arity matches a family of
specific instructions is assumed to be the implementation of that
instruction.</p><p>A macro can also be invoked from within another macro.  For example,
<code class="inline">move_deallocate_return/2</code> avoids repeating code by invoking
<code class="inline">$deallocate_return()</code> as a macro:</p><pre><code class="makeup erlang" translate="no"><span class="nf">move_deallocate_return</span><span class="p" data-group-id="9835324203-1">(</span><span class="n">Src</span><span class="p">,</span><span class="w"> </span><span class="n">Deallocate</span><span class="p" data-group-id="9835324203-1">)</span><span class="w"> </span><span class="p" data-group-id="9835324203-2">{</span><span class="w">
    </span><span class="nf">x</span><span class="p" data-group-id="9835324203-3">(</span><span class="mi">0</span><span class="p" data-group-id="9835324203-3">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$S</span><span class="ss">rc</span><span class="p">;</span><span class="w">
    </span><span class="sc">$d</span><span class="nf">eallocate_return</span><span class="p" data-group-id="9835324203-4">(</span><span class="sc">$D</span><span class="ss">eallocate</span><span class="p" data-group-id="9835324203-4">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="9835324203-2">}</span></code></pre><p>Here is the definition of <code class="inline">deallocate_return/1</code>:</p><pre><code class="makeup erlang" translate="no"><span class="nf">deallocate_return</span><span class="p" data-group-id="5796038003-1">(</span><span class="n">Deallocate</span><span class="p" data-group-id="5796038003-1">)</span><span class="w"> </span><span class="p" data-group-id="5796038003-2">{</span><span class="w">
    </span><span class="o">/</span><span class="o">/</span><span class="p">|</span><span class="w"> </span><span class="o">-</span><span class="ss">no_next</span><span class="w">
    </span><span class="ss">int</span><span class="w"> </span><span class="ss">words_to_pop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$D</span><span class="ss">eallocate</span><span class="p">;</span><span class="w">
    </span><span class="n">SET_I</span><span class="p" data-group-id="5796038003-3">(</span><span class="p" data-group-id="5796038003-4">(</span><span class="n">BeamInstr</span><span class="w"> </span><span class="o">*</span><span class="p" data-group-id="5796038003-4">)</span><span class="w"> </span><span class="nf">cp_val</span><span class="p" data-group-id="5796038003-5">(</span><span class="o">*</span><span class="n">E</span><span class="p" data-group-id="5796038003-5">)</span><span class="p" data-group-id="5796038003-3">)</span><span class="p">;</span><span class="w">
    </span><span class="n">E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ADD_BYTE_OFFSET</span><span class="p" data-group-id="5796038003-6">(</span><span class="n">E</span><span class="p">,</span><span class="w"> </span><span class="ss">words_to_pop</span><span class="p" data-group-id="5796038003-6">)</span><span class="p">;</span><span class="w">
    </span><span class="n">CHECK_TERM</span><span class="p" data-group-id="5796038003-7">(</span><span class="nf">x</span><span class="p" data-group-id="5796038003-8">(</span><span class="mi">0</span><span class="p" data-group-id="5796038003-8">)</span><span class="p" data-group-id="5796038003-7">)</span><span class="p">;</span><span class="w">
    </span><span class="n">DispatchReturn</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="5796038003-2">}</span></code></pre><p>The expanded code for <code class="inline">move_deallocate_return</code> will look this:</p><pre><code class="makeup erlang" translate="no"><span class="n">OpCase</span><span class="p" data-group-id="2651181305-1">(</span><span class="ss">move_deallocate_return_cQ</span><span class="p" data-group-id="2651181305-1">)</span><span class="p">:</span><span class="w">
</span><span class="p" data-group-id="2651181305-2">{</span><span class="w">
  </span><span class="nf">x</span><span class="p" data-group-id="2651181305-3">(</span><span class="mi">0</span><span class="p" data-group-id="2651181305-3">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I</span><span class="p" data-group-id="2651181305-4">[</span><span class="mi">1</span><span class="p" data-group-id="2651181305-4">]</span><span class="p">;</span><span class="w">
  </span><span class="ss">do</span><span class="w"> </span><span class="p" data-group-id="2651181305-5">{</span><span class="w">
    </span><span class="ss">int</span><span class="w"> </span><span class="ss">words_to_pop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Qb</span><span class="p" data-group-id="2651181305-6">(</span><span class="n">BeamExtraData</span><span class="p" data-group-id="2651181305-7">(</span><span class="n">I</span><span class="p" data-group-id="2651181305-8">[</span><span class="mi">0</span><span class="p" data-group-id="2651181305-8">]</span><span class="p" data-group-id="2651181305-7">)</span><span class="p" data-group-id="2651181305-6">)</span><span class="p">;</span><span class="w">
    </span><span class="n">SET_I</span><span class="p" data-group-id="2651181305-9">(</span><span class="p" data-group-id="2651181305-10">(</span><span class="n">BeamInstr</span><span class="w"> </span><span class="o">*</span><span class="p" data-group-id="2651181305-10">)</span><span class="w"> </span><span class="nf">cp_val</span><span class="p" data-group-id="2651181305-11">(</span><span class="o">*</span><span class="n">E</span><span class="p" data-group-id="2651181305-11">)</span><span class="p" data-group-id="2651181305-9">)</span><span class="p">;</span><span class="w">
    </span><span class="n">E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ADD_BYTE_OFFSET</span><span class="p" data-group-id="2651181305-12">(</span><span class="n">E</span><span class="p">,</span><span class="w"> </span><span class="ss">words_to_pop</span><span class="p" data-group-id="2651181305-12">)</span><span class="p">;</span><span class="w">
    </span><span class="n">CHECK_TERM</span><span class="p" data-group-id="2651181305-13">(</span><span class="nf">x</span><span class="p" data-group-id="2651181305-14">(</span><span class="mi">0</span><span class="p" data-group-id="2651181305-14">)</span><span class="p" data-group-id="2651181305-13">)</span><span class="p">;</span><span class="w">
    </span><span class="n">DispatchReturn</span><span class="p">;</span><span class="w">
  </span><span class="p" data-group-id="2651181305-5">}</span><span class="w"> </span><span class="nf">while</span><span class="w"> </span><span class="p" data-group-id="2651181305-15">(</span><span class="mi">0</span><span class="p" data-group-id="2651181305-15">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="2651181305-2">}</span></code></pre><p>When expanding macros, <strong>beam_makeops</strong> wraps the expansion in a
<code class="inline">do</code>/<code class="inline">while</code> wrapper unless <strong>beam_makeops</strong> can clearly see that no
wrapper is needed.  In this case, the wrapper is needed.</p><p>Note that arguments for macros cannot be complex expressions, because
the arguments are split on <code class="inline">,</code>.  For example, the following would
not work because <strong>beam_makeops</strong> would split the expression into
two arguments:</p><pre><code class="makeup erlang" translate="no"><span class="sc">$d</span><span class="nf">eallocate_return</span><span class="p" data-group-id="6203444430-1">(</span><span class="nf">get_deallocation</span><span class="p" data-group-id="6203444430-2">(</span><span class="ss">y</span><span class="p">,</span><span class="w"> </span><span class="sc">$D</span><span class="ss">eallocate</span><span class="p" data-group-id="6203444430-2">)</span><span class="p" data-group-id="6203444430-1">)</span><span class="p">;</span></code></pre><h4>Code generation directives</h4><p>Within macro definitions, <code class="inline">//</code> comments are in general not treated
specially.  They will be copied to the file with the generated code
along with the rest of code in the body.</p><p>However, there is an exception. Within a macro definition, a line that
starts with whitespace followed by <code class="inline">//|</code> is treated specially.  The
rest of the line is assumed to contain directives to control code
generation.</p><p>Currently, two code generation directives are recognized:</p><ul><li><code class="inline">-no_prefetch</code></li><li><code class="inline">-no_next</code></li></ul><h5>The -no_prefetch directive</h5><p>To see what <code class="inline">-no_prefetch</code> does, let's first look at the default code
generation.  Here is the code generated for <code class="inline">move_cx</code>:</p><pre><code class="makeup erlang" translate="no"><span class="n">OpCase</span><span class="p" data-group-id="2894640047-1">(</span><span class="ss">move_cx</span><span class="p" data-group-id="2894640047-1">)</span><span class="p">:</span><span class="w">
</span><span class="p" data-group-id="2894640047-2">{</span><span class="w">
  </span><span class="n">BeamInstr</span><span class="w"> </span><span class="ss">next_pf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BeamCodeAddr</span><span class="p" data-group-id="2894640047-3">(</span><span class="n">I</span><span class="p" data-group-id="2894640047-4">[</span><span class="mi">2</span><span class="p" data-group-id="2894640047-4">]</span><span class="p" data-group-id="2894640047-3">)</span><span class="p">;</span><span class="w">
  </span><span class="nf">xb</span><span class="p" data-group-id="2894640047-5">(</span><span class="n">BeamExtraData</span><span class="p" data-group-id="2894640047-6">(</span><span class="n">I</span><span class="p" data-group-id="2894640047-7">[</span><span class="mi">0</span><span class="p" data-group-id="2894640047-7">]</span><span class="p" data-group-id="2894640047-6">)</span><span class="p" data-group-id="2894640047-5">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I</span><span class="p" data-group-id="2894640047-8">[</span><span class="mi">1</span><span class="p" data-group-id="2894640047-8">]</span><span class="p">;</span><span class="w">
  </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
  </span><span class="n">ASSERT</span><span class="p" data-group-id="2894640047-9">(</span><span class="n">VALID_INSTR</span><span class="p" data-group-id="2894640047-10">(</span><span class="ss">next_pf</span><span class="p" data-group-id="2894640047-10">)</span><span class="p" data-group-id="2894640047-9">)</span><span class="p">;</span><span class="w">
  </span><span class="n">GotoPF</span><span class="p" data-group-id="2894640047-11">(</span><span class="ss">next_pf</span><span class="p" data-group-id="2894640047-11">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="2894640047-2">}</span></code></pre><p>Note that the very first thing done is to fetch the address to the
next instruction.  The reason is that it usually improves performance.</p><p>Just as a demonstration, we can add a <code class="inline">-no_prefetch</code> directive to
the <code class="inline">move/2</code> instruction:</p><pre><code class="makeup erlang" translate="no"><span class="nf">move</span><span class="p" data-group-id="2628461529-1">(</span><span class="n">Src</span><span class="p">,</span><span class="w"> </span><span class="n">Dst</span><span class="p" data-group-id="2628461529-1">)</span><span class="w"> </span><span class="p" data-group-id="2628461529-2">{</span><span class="w">
    </span><span class="o">/</span><span class="o">/</span><span class="p">|</span><span class="w"> </span><span class="o">-</span><span class="ss">no_prefetch</span><span class="w">
    </span><span class="sc">$D</span><span class="ss">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$S</span><span class="ss">rc</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="2628461529-2">}</span></code></pre><p>We can see that the prefetch is no longer done:</p><pre><code class="makeup erlang" translate="no"><span class="n">OpCase</span><span class="p" data-group-id="0204453810-1">(</span><span class="ss">move_cx</span><span class="p" data-group-id="0204453810-1">)</span><span class="p">:</span><span class="w">
</span><span class="p" data-group-id="0204453810-2">{</span><span class="w">
  </span><span class="nf">xb</span><span class="p" data-group-id="0204453810-3">(</span><span class="n">BeamExtraData</span><span class="p" data-group-id="0204453810-4">(</span><span class="n">I</span><span class="p" data-group-id="0204453810-5">[</span><span class="mi">0</span><span class="p" data-group-id="0204453810-5">]</span><span class="p" data-group-id="0204453810-4">)</span><span class="p" data-group-id="0204453810-3">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I</span><span class="p" data-group-id="0204453810-6">[</span><span class="mi">1</span><span class="p" data-group-id="0204453810-6">]</span><span class="p">;</span><span class="w">
  </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
  </span><span class="n">ASSERT</span><span class="p" data-group-id="0204453810-7">(</span><span class="n">VALID_INSTR</span><span class="p" data-group-id="0204453810-8">(</span><span class="o">*</span><span class="n">I</span><span class="p" data-group-id="0204453810-8">)</span><span class="p" data-group-id="0204453810-7">)</span><span class="p">;</span><span class="w">
  </span><span class="n">Goto</span><span class="p" data-group-id="0204453810-9">(</span><span class="o">*</span><span class="n">I</span><span class="p" data-group-id="0204453810-9">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="0204453810-2">}</span></code></pre><p>When would we want to turn off the prefetch in practice?</p><p>In instructions that will not always execute the next instruction.
For example:</p><pre><code class="makeup erlang" translate="no"><span class="nf">is_atom</span><span class="p" data-group-id="1919218246-1">(</span><span class="n">Fail</span><span class="p">,</span><span class="w"> </span><span class="n">Src</span><span class="p" data-group-id="1919218246-1">)</span><span class="w"> </span><span class="p" data-group-id="1919218246-2">{</span><span class="w">
    </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="1919218246-3">(</span><span class="nf">is_not_atom</span><span class="p" data-group-id="1919218246-4">(</span><span class="sc">$S</span><span class="ss">rc</span><span class="p" data-group-id="1919218246-4">)</span><span class="p" data-group-id="1919218246-3">)</span><span class="w"> </span><span class="p" data-group-id="1919218246-5">{</span><span class="w">
        </span><span class="sc">$F</span><span class="n">AIL</span><span class="p" data-group-id="1919218246-6">(</span><span class="sc">$F</span><span class="ss">ail</span><span class="p" data-group-id="1919218246-6">)</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="1919218246-5">}</span><span class="w">
</span><span class="p" data-group-id="1919218246-2">}</span><span class="w">

</span><span class="o">/</span><span class="o">/</span><span class="w"> </span><span class="n">From</span><span class="w"> </span><span class="ss">macros</span><span class="p">.</span><span class="ss">tab</span><span class="w">
</span><span class="n">FAIL</span><span class="p" data-group-id="1919218246-7">(</span><span class="n">Fail</span><span class="p" data-group-id="1919218246-7">)</span><span class="w"> </span><span class="p" data-group-id="1919218246-8">{</span><span class="w">
    </span><span class="o">/</span><span class="o">/</span><span class="p">|</span><span class="w"> </span><span class="o">-</span><span class="ss">no_prefetch</span><span class="w">
    </span><span class="sc">$S</span><span class="n">ET_I_REL</span><span class="p" data-group-id="1919218246-9">(</span><span class="sc">$F</span><span class="ss">ail</span><span class="p" data-group-id="1919218246-9">)</span><span class="p">;</span><span class="w">
    </span><span class="n">Goto</span><span class="p" data-group-id="1919218246-10">(</span><span class="o">*</span><span class="n">I</span><span class="p" data-group-id="1919218246-10">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="1919218246-8">}</span></code></pre><p><code class="inline">is_atom/2</code> may either execute the next instruction (if the second
operand is an atom) or branch to the failure label.</p><p>The generated code looks like this:</p><pre><code class="makeup erlang" translate="no"><span class="n">OpCase</span><span class="p" data-group-id="0100230927-1">(</span><span class="ss">is_atom_fx</span><span class="p" data-group-id="0100230927-1">)</span><span class="p">:</span><span class="w">
</span><span class="p" data-group-id="0100230927-2">{</span><span class="w">
  </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="0100230927-3">(</span><span class="nf">is_not_atom</span><span class="p" data-group-id="0100230927-4">(</span><span class="nf">xb</span><span class="p" data-group-id="0100230927-5">(</span><span class="n">I</span><span class="p" data-group-id="0100230927-6">[</span><span class="mi">1</span><span class="p" data-group-id="0100230927-6">]</span><span class="p" data-group-id="0100230927-5">)</span><span class="p" data-group-id="0100230927-4">)</span><span class="p" data-group-id="0100230927-3">)</span><span class="w"> </span><span class="p" data-group-id="0100230927-7">{</span><span class="w">
    </span><span class="n">ASSERT</span><span class="p" data-group-id="0100230927-8">(</span><span class="n">VALID_INSTR</span><span class="p" data-group-id="0100230927-9">(</span><span class="o">*</span><span class="p" data-group-id="0100230927-10">(</span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p" data-group-id="0100230927-11">(</span><span class="nf">fb</span><span class="p" data-group-id="0100230927-12">(</span><span class="n">BeamExtraData</span><span class="p" data-group-id="0100230927-13">(</span><span class="n">I</span><span class="p" data-group-id="0100230927-14">[</span><span class="mi">0</span><span class="p" data-group-id="0100230927-14">]</span><span class="p" data-group-id="0100230927-13">)</span><span class="p" data-group-id="0100230927-12">)</span><span class="p" data-group-id="0100230927-11">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="0100230927-10">)</span><span class="p" data-group-id="0100230927-9">)</span><span class="p" data-group-id="0100230927-8">)</span><span class="p">;</span><span class="w">
    </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="nf">fb</span><span class="p" data-group-id="0100230927-15">(</span><span class="n">BeamExtraData</span><span class="p" data-group-id="0100230927-16">(</span><span class="n">I</span><span class="p" data-group-id="0100230927-17">[</span><span class="mi">0</span><span class="p" data-group-id="0100230927-17">]</span><span class="p" data-group-id="0100230927-16">)</span><span class="p" data-group-id="0100230927-15">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="p">;</span><span class="w">
    </span><span class="n">Goto</span><span class="p" data-group-id="0100230927-18">(</span><span class="o">*</span><span class="n">I</span><span class="p" data-group-id="0100230927-18">)</span><span class="p">;</span><span class="p">;</span><span class="w">
  </span><span class="p" data-group-id="0100230927-7">}</span><span class="w">
  </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
  </span><span class="n">ASSERT</span><span class="p" data-group-id="0100230927-19">(</span><span class="n">VALID_INSTR</span><span class="p" data-group-id="0100230927-20">(</span><span class="o">*</span><span class="n">I</span><span class="p" data-group-id="0100230927-20">)</span><span class="p" data-group-id="0100230927-19">)</span><span class="p">;</span><span class="w">
  </span><span class="n">Goto</span><span class="p" data-group-id="0100230927-21">(</span><span class="o">*</span><span class="n">I</span><span class="p" data-group-id="0100230927-21">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="0100230927-2">}</span></code></pre><h5>The -no_next directive</h5><p>Next we will look at when the <code class="inline">-no_next</code> directive can be used.  Here
is the <code class="inline">jump/1</code> instruction:</p><pre><code class="makeup erlang" translate="no"><span class="nf">jump</span><span class="p" data-group-id="7089870439-1">(</span><span class="n">Fail</span><span class="p" data-group-id="7089870439-1">)</span><span class="w"> </span><span class="p" data-group-id="7089870439-2">{</span><span class="w">
    </span><span class="sc">$J</span><span class="n">UMP</span><span class="p" data-group-id="7089870439-3">(</span><span class="sc">$F</span><span class="ss">ail</span><span class="p" data-group-id="7089870439-3">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="7089870439-2">}</span><span class="w">

</span><span class="o">/</span><span class="o">/</span><span class="w"> </span><span class="n">From</span><span class="w"> </span><span class="ss">macros</span><span class="p">.</span><span class="ss">tab</span><span class="w">
</span><span class="n">JUMP</span><span class="p" data-group-id="7089870439-4">(</span><span class="n">Fail</span><span class="p" data-group-id="7089870439-4">)</span><span class="w"> </span><span class="p" data-group-id="7089870439-5">{</span><span class="w">
    </span><span class="o">/</span><span class="o">/</span><span class="p">|</span><span class="w"> </span><span class="o">-</span><span class="ss">no_next</span><span class="w">
    </span><span class="sc">$S</span><span class="n">ET_I_REL</span><span class="p" data-group-id="7089870439-6">(</span><span class="sc">$F</span><span class="ss">ail</span><span class="p" data-group-id="7089870439-6">)</span><span class="p">;</span><span class="w">
    </span><span class="n">Goto</span><span class="p" data-group-id="7089870439-7">(</span><span class="o">*</span><span class="n">I</span><span class="p" data-group-id="7089870439-7">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="7089870439-5">}</span></code></pre><p>The generated code looks like this:</p><pre><code class="makeup erlang" translate="no"><span class="n">OpCase</span><span class="p" data-group-id="5694007829-1">(</span><span class="ss">jump_f</span><span class="p" data-group-id="5694007829-1">)</span><span class="p">:</span><span class="w">
</span><span class="p" data-group-id="5694007829-2">{</span><span class="w">
  </span><span class="n">ASSERT</span><span class="p" data-group-id="5694007829-3">(</span><span class="n">VALID_INSTR</span><span class="p" data-group-id="5694007829-4">(</span><span class="o">*</span><span class="p" data-group-id="5694007829-5">(</span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p" data-group-id="5694007829-6">(</span><span class="nf">fb</span><span class="p" data-group-id="5694007829-7">(</span><span class="n">BeamExtraData</span><span class="p" data-group-id="5694007829-8">(</span><span class="n">I</span><span class="p" data-group-id="5694007829-9">[</span><span class="mi">0</span><span class="p" data-group-id="5694007829-9">]</span><span class="p" data-group-id="5694007829-8">)</span><span class="p" data-group-id="5694007829-7">)</span><span class="p" data-group-id="5694007829-6">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="5694007829-5">)</span><span class="p" data-group-id="5694007829-4">)</span><span class="p" data-group-id="5694007829-3">)</span><span class="p">;</span><span class="w">
  </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="nf">fb</span><span class="p" data-group-id="5694007829-10">(</span><span class="n">BeamExtraData</span><span class="p" data-group-id="5694007829-11">(</span><span class="n">I</span><span class="p" data-group-id="5694007829-12">[</span><span class="mi">0</span><span class="p" data-group-id="5694007829-12">]</span><span class="p" data-group-id="5694007829-11">)</span><span class="p" data-group-id="5694007829-10">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="p">;</span><span class="w">
  </span><span class="n">Goto</span><span class="p" data-group-id="5694007829-13">(</span><span class="o">*</span><span class="n">I</span><span class="p" data-group-id="5694007829-13">)</span><span class="p">;</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="5694007829-2">}</span></code></pre><p>If we remove the <code class="inline">-no_next</code> directive, the code would look like this:</p><pre><code class="makeup erlang" translate="no"><span class="n">OpCase</span><span class="p" data-group-id="3492328876-1">(</span><span class="ss">jump_f</span><span class="p" data-group-id="3492328876-1">)</span><span class="p">:</span><span class="w">
</span><span class="p" data-group-id="3492328876-2">{</span><span class="w">
  </span><span class="n">BeamInstr</span><span class="w"> </span><span class="ss">next_pf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BeamCodeAddr</span><span class="p" data-group-id="3492328876-3">(</span><span class="n">I</span><span class="p" data-group-id="3492328876-4">[</span><span class="mi">1</span><span class="p" data-group-id="3492328876-4">]</span><span class="p" data-group-id="3492328876-3">)</span><span class="p">;</span><span class="w">
  </span><span class="n">ASSERT</span><span class="p" data-group-id="3492328876-5">(</span><span class="n">VALID_INSTR</span><span class="p" data-group-id="3492328876-6">(</span><span class="o">*</span><span class="p" data-group-id="3492328876-7">(</span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p" data-group-id="3492328876-8">(</span><span class="nf">fb</span><span class="p" data-group-id="3492328876-9">(</span><span class="n">BeamExtraData</span><span class="p" data-group-id="3492328876-10">(</span><span class="n">I</span><span class="p" data-group-id="3492328876-11">[</span><span class="mi">0</span><span class="p" data-group-id="3492328876-11">]</span><span class="p" data-group-id="3492328876-10">)</span><span class="p" data-group-id="3492328876-9">)</span><span class="p" data-group-id="3492328876-8">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="3492328876-7">)</span><span class="p" data-group-id="3492328876-6">)</span><span class="p" data-group-id="3492328876-5">)</span><span class="p">;</span><span class="w">
  </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="nf">fb</span><span class="p" data-group-id="3492328876-12">(</span><span class="n">BeamExtraData</span><span class="p" data-group-id="3492328876-13">(</span><span class="n">I</span><span class="p" data-group-id="3492328876-14">[</span><span class="mi">0</span><span class="p" data-group-id="3492328876-14">]</span><span class="p" data-group-id="3492328876-13">)</span><span class="p" data-group-id="3492328876-12">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="p">;</span><span class="w">
  </span><span class="n">Goto</span><span class="p" data-group-id="3492328876-15">(</span><span class="o">*</span><span class="n">I</span><span class="p" data-group-id="3492328876-15">)</span><span class="p">;</span><span class="p">;</span><span class="w">
  </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
  </span><span class="n">ASSERT</span><span class="p" data-group-id="3492328876-16">(</span><span class="n">VALID_INSTR</span><span class="p" data-group-id="3492328876-17">(</span><span class="ss">next_pf</span><span class="p" data-group-id="3492328876-17">)</span><span class="p" data-group-id="3492328876-16">)</span><span class="p">;</span><span class="w">
  </span><span class="n">GotoPF</span><span class="p" data-group-id="3492328876-18">(</span><span class="ss">next_pf</span><span class="p" data-group-id="3492328876-18">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="3492328876-2">}</span></code></pre><p>In the end, the C compiler will probably optimize this code to the
same native code as the first version, but the first version is certainly
much easier to read for human readers.</p><h4>Macros in the macros.tab file</h4><p>The file <code class="inline">macros.tab</code> contains many useful macros.  When implementing
new instructions it is good practice to look through <code class="inline">macros.tab</code> to
see if any of existing macros can be used rather than re-inventing
the wheel.</p><p>We will describe a few of the most useful macros here.</p><p><a href="" id="the-GC_REGEXP-definition"></a></p><h5>The GC_REGEXP definition</h5><p>The following line defines a regular expression that will recognize
a call to a function that does a garbage collection:</p><pre><code class="makeup erlang" translate="no"><span class="w"> </span><span class="n">GC_REGEXP</span><span class="o">=</span><span class="ss">erts_garbage_collect</span><span class="p">|</span><span class="ss">erts_gc</span><span class="p">|</span><span class="n">GcBifFunction</span><span class="p">;</span></code></pre><p>The purpose is that <strong>beam_makeops</strong> can verify that an instruction
that does a garbage collection and has an <code class="inline">d</code> operand uses the
<code class="inline">$REFRESH_GEN_DEST()</code> macro.</p><p>If you need to define a new function that does garbage collection,
you should give it the prefix <code class="inline">erts_gc_</code>.  If that is not possible
you should update the regular expression so that it will match your
new function.</p><h5>FAIL(Fail)</h5><p>Branch to <code class="inline">$Fail</code>.  Will suppress prefetch (<code class="inline">-no_prefetch</code>).  Typical use:</p><pre><code class="makeup erlang" translate="no"><span class="nf">is_nonempty_list</span><span class="p" data-group-id="7459412395-1">(</span><span class="n">Fail</span><span class="p">,</span><span class="w"> </span><span class="n">Src</span><span class="p" data-group-id="7459412395-1">)</span><span class="w"> </span><span class="p" data-group-id="7459412395-2">{</span><span class="w">
    </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="7459412395-3">(</span><span class="nf">is_not_list</span><span class="p" data-group-id="7459412395-4">(</span><span class="sc">$S</span><span class="ss">rc</span><span class="p" data-group-id="7459412395-4">)</span><span class="p" data-group-id="7459412395-3">)</span><span class="w"> </span><span class="p" data-group-id="7459412395-5">{</span><span class="w">
        </span><span class="sc">$F</span><span class="n">AIL</span><span class="p" data-group-id="7459412395-6">(</span><span class="sc">$F</span><span class="ss">ail</span><span class="p" data-group-id="7459412395-6">)</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="7459412395-5">}</span><span class="w">
</span><span class="p" data-group-id="7459412395-2">}</span></code></pre><h5>JUMP(Fail)</h5><p>Branch to <code class="inline">$Fail</code>.  Suppresses generation of dispatch of the next
instruction (<code class="inline">-no_next</code>).  Typical use:</p><pre><code class="makeup erlang" translate="no"><span class="nf">jump</span><span class="p" data-group-id="2376369728-1">(</span><span class="n">Fail</span><span class="p" data-group-id="2376369728-1">)</span><span class="w"> </span><span class="p" data-group-id="2376369728-2">{</span><span class="w">
    </span><span class="sc">$J</span><span class="n">UMP</span><span class="p" data-group-id="2376369728-3">(</span><span class="sc">$F</span><span class="ss">ail</span><span class="p" data-group-id="2376369728-3">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="2376369728-2">}</span></code></pre><h5>GC_TEST(NeedStack, NeedHeap, Live)</h5><p><code class="inline">$GC_TEST(NeedStack, NeedHeap, Live)</code> tests that given amount of
stack space and heap space is available.  If not it will do a
garbage collection.  Typical use:</p><pre><code class="makeup erlang" translate="no"><span class="nf">test_heap</span><span class="p" data-group-id="8856142516-1">(</span><span class="n">Nh</span><span class="p">,</span><span class="w"> </span><span class="n">Live</span><span class="p" data-group-id="8856142516-1">)</span><span class="w"> </span><span class="p" data-group-id="8856142516-2">{</span><span class="w">
    </span><span class="sc">$G</span><span class="n">C_TEST</span><span class="p" data-group-id="8856142516-3">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="sc">$N</span><span class="ss">h</span><span class="p">,</span><span class="w"> </span><span class="sc">$L</span><span class="ss">ive</span><span class="p" data-group-id="8856142516-3">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="8856142516-2">}</span></code></pre><h5>AH(NeedStack, NeedHeap, Live)</h5><p><code class="inline">AH(NeedStack, NeedHeap, Live)</code> allocates a stack frame and
optionally additional heap space.</p><h4>Pre-defined macros and variables</h4><p><strong>beam_makeops</strong> defines several built-in macros and pre-bound variables.</p><h5>The NEXT_INSTRUCTION pre-bound variable</h5><p>The NEXT_INSTRUCTION is a pre-bound variable that is available in
all instructions.  It expands to the address of the next instruction.</p><p>Here is an example:</p><pre><code class="makeup erlang" translate="no"><span class="nf">i_call</span><span class="p" data-group-id="8260994118-1">(</span><span class="n">CallDest</span><span class="p" data-group-id="8260994118-1">)</span><span class="w"> </span><span class="p" data-group-id="8260994118-2">{</span><span class="w">
    </span><span class="o">/</span><span class="o">/</span><span class="p">|</span><span class="w"> </span><span class="o">-</span><span class="ss">no_next</span><span class="w">
    </span><span class="sc">$S</span><span class="n">AVE_CONTINUATION_POINTER</span><span class="p" data-group-id="8260994118-3">(</span><span class="sc">$N</span><span class="n">EXT_INSTRUCTION</span><span class="p" data-group-id="8260994118-3">)</span><span class="p">;</span><span class="w">
    </span><span class="sc">$D</span><span class="n">ISPATCH_REL</span><span class="p" data-group-id="8260994118-4">(</span><span class="sc">$C</span><span class="ss">allDest</span><span class="p" data-group-id="8260994118-4">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="8260994118-2">}</span></code></pre><p>When calling a function, the return address is first stored in <code class="inline">E[0]</code>
(using the <code class="inline">$SAVE_CONTINUATION_POINTER()</code> macro), and then control is
transferred to the callee.  Here is the generated code:</p><pre><code class="makeup erlang" translate="no"><span class="n">OpCase</span><span class="p" data-group-id="5094567530-1">(</span><span class="ss">i_call_f</span><span class="p" data-group-id="5094567530-1">)</span><span class="p">:</span><span class="w">
</span><span class="p" data-group-id="5094567530-2">{</span><span class="w">
    </span><span class="n">ASSERT</span><span class="p" data-group-id="5094567530-3">(</span><span class="n">VALID_INSTR</span><span class="p" data-group-id="5094567530-4">(</span><span class="o">*</span><span class="p" data-group-id="5094567530-5">(</span><span class="n">I</span><span class="o">+</span><span class="mi">2</span><span class="p" data-group-id="5094567530-5">)</span><span class="p" data-group-id="5094567530-4">)</span><span class="p" data-group-id="5094567530-3">)</span><span class="p">;</span><span class="w">
    </span><span class="o">*</span><span class="n">E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5094567530-6">(</span><span class="n">BeamInstr</span><span class="p" data-group-id="5094567530-6">)</span><span class="w"> </span><span class="p" data-group-id="5094567530-7">(</span><span class="n">I</span><span class="o">+</span><span class="mi">2</span><span class="p" data-group-id="5094567530-7">)</span><span class="p">;</span><span class="p">;</span><span class="w">

    </span><span class="o">/</span><span class="o">*</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="ss">dispatch</span><span class="w"> </span><span class="ss">code</span><span class="w"> </span><span class="ss">intentionally</span><span class="w"> </span><span class="ss">left</span><span class="w"> </span><span class="ss">out</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="o">*</span><span class="o">/</span><span class="w">
</span><span class="p" data-group-id="5094567530-2">}</span></code></pre><p>We can see that that <code class="inline">$NEXT_INSTRUCTION</code> has been expanded to <code class="inline">I+2</code>.
That makes sense since the size of the <code class="inline">i_call_f/1</code> instruction is
two words.</p><h5>The IP_ADJUSTMENT pre-bound variable</h5><p><code class="inline">$IP_ADJUSTMENT</code> is usually 0.  In a few combined instructions
(described below) it can be non-zero.  It is used like this
in <code class="inline">macros.tab</code>:</p><pre><code class="makeup erlang" translate="no"><span class="n">SET_I_REL</span><span class="p" data-group-id="1666720130-1">(</span><span class="n">Offset</span><span class="p" data-group-id="1666720130-1">)</span><span class="w"> </span><span class="p" data-group-id="1666720130-2">{</span><span class="w">
    </span><span class="n">ASSERT</span><span class="p" data-group-id="1666720130-3">(</span><span class="n">VALID_INSTR</span><span class="p" data-group-id="1666720130-4">(</span><span class="o">*</span><span class="p" data-group-id="1666720130-5">(</span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p" data-group-id="1666720130-6">(</span><span class="sc">$O</span><span class="ss">ffset</span><span class="p" data-group-id="1666720130-6">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="sc">$I</span><span class="n">P_ADJUSTMENT</span><span class="p" data-group-id="1666720130-5">)</span><span class="p" data-group-id="1666720130-4">)</span><span class="p" data-group-id="1666720130-3">)</span><span class="p">;</span><span class="w">
    </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="sc">$O</span><span class="ss">ffset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="sc">$I</span><span class="n">P_ADJUSTMENT</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="1666720130-2">}</span></code></pre><p>Avoid using <code class="inline">IP_ADJUSTMENT</code> directly.  Use <code class="inline">SET_I_REL()</code> or
one of the macros that invoke such as <code class="inline">FAIL()</code> or <code class="inline">JUMP()</code>
defined in <code class="inline">macros.tab</code>.</p><h4>Pre-defined macro functions</h4><h5>The IF() macro</h5><p><code class="inline">$IF(Expr, IfTrue, IfFalse)</code> evaluates <code class="inline">Expr</code>, which must be a valid
Perl expression (which for simple numeric expressions have the same
syntax as C).  If <code class="inline">Expr</code> evaluates to 0, the entire <code class="inline">IF()</code> expression will be
replaced with <code class="inline">IfFalse</code>, otherwise it will be replaced with <code class="inline">IfTrue</code>.</p><p>See the description of <code class="inline">OPERAND_POSITION()</code> for an example.</p><h5>The OPERAND_POSITION() macro</h5><p><code class="inline">$OPERAND_POSITION(Expr)</code> returns the position for <code class="inline">Expr</code>, if
<code class="inline">Expr</code> is an operand that is not packed.  The first operand is
at position 1.</p><p>Returns 0 otherwise.</p><p>This macro could be used like this in order to share code:</p><pre><code class="makeup erlang" translate="no"><span class="n">FAIL</span><span class="p" data-group-id="2998143970-1">(</span><span class="n">Fail</span><span class="p" data-group-id="2998143970-1">)</span><span class="w"> </span><span class="p" data-group-id="2998143970-2">{</span><span class="w">
    </span><span class="o">/</span><span class="o">/</span><span class="p">|</span><span class="w"> </span><span class="o">-</span><span class="ss">no_prefetch</span><span class="w">
    </span><span class="sc">$I</span><span class="n">F</span><span class="p" data-group-id="2998143970-3">(</span><span class="sc">$O</span><span class="n">PERAND_POSITION</span><span class="p" data-group-id="2998143970-4">(</span><span class="sc">$F</span><span class="ss">ail</span><span class="p" data-group-id="2998143970-4">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">&amp;&amp;</span><span class="w"> </span><span class="sc">$I</span><span class="n">P_ADJUSTMENT</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
        </span><span class="ss">goto</span><span class="w"> </span><span class="ss">common_jump</span><span class="p">,</span><span class="w">
        </span><span class="sc">$D</span><span class="n">O_JUMP</span><span class="p" data-group-id="2998143970-5">(</span><span class="sc">$F</span><span class="ss">ail</span><span class="p" data-group-id="2998143970-5">)</span><span class="p" data-group-id="2998143970-3">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="2998143970-2">}</span><span class="w">

</span><span class="n">DO_JUMP</span><span class="p" data-group-id="2998143970-6">(</span><span class="n">Fail</span><span class="p" data-group-id="2998143970-6">)</span><span class="w"> </span><span class="p" data-group-id="2998143970-7">{</span><span class="w">
    </span><span class="sc">$S</span><span class="n">ET_I_REL</span><span class="p" data-group-id="2998143970-8">(</span><span class="sc">$F</span><span class="ss">ail</span><span class="p" data-group-id="2998143970-8">)</span><span class="p">;</span><span class="w">
    </span><span class="n">Goto</span><span class="p" data-group-id="2998143970-9">(</span><span class="o">*</span><span class="n">I</span><span class="p" data-group-id="2998143970-9">)</span><span class="p">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="2998143970-7">}</span><span class="w">

</span><span class="o">/</span><span class="o">/</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="ss">beam_emu</span><span class="p">.</span><span class="nc">c</span><span class="p">:</span><span class="w">
</span><span class="nc">common_jump</span><span class="p">:</span><span class="w">
   </span><span class="n">I</span><span class="w"> </span><span class="o">+</span><span class="o">=</span><span class="w"> </span><span class="n">I</span><span class="p" data-group-id="2998143970-10">[</span><span class="mi">1</span><span class="p" data-group-id="2998143970-10">]</span><span class="p">;</span><span class="w">
   </span><span class="n">Goto</span><span class="p" data-group-id="2998143970-11">(</span><span class="o">*</span><span class="n">I</span><span class="p" data-group-id="2998143970-11">)</span><span class="p">)</span><span class="p">;</span></code></pre><h4>The $REFRESH_GEN_DEST() macro</h4><p>When a specific instruction has a <code class="inline">d</code> operand, early during execution
of the instruction, a pointer will be initialized to point to the X or
Y register in question.</p><p>If there is a garbage collection before the result is stored,
the stack will move and if the <code class="inline">d</code> operand referred to a Y
register, the pointer will no longer be valid.  (Y registers are
stored on the stack.)</p><p>In those circumstances, <code class="inline">$REFRESH_GEN_DEST()</code> must be invoked
to set up the pointer again. <strong>beam_makeops</strong> will notice
if there is a call to a function that does a garbage collection and
<code class="inline">$REFRESH_GEN_DEST()</code> is not called.</p><p>Here is a complete example.  The <code class="inline">new_map</code> instruction is defined
like this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">new_map</span><span class="w"> </span><span class="ss">d</span><span class="w"> </span><span class="ss">t</span><span class="w"> </span><span class="n">I</span></code></pre><p>It is implemented like this:</p><pre><code class="makeup erlang" translate="no"><span class="nf">new_map</span><span class="p" data-group-id="1051432202-1">(</span><span class="n">Dst</span><span class="p">,</span><span class="w"> </span><span class="n">Live</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p" data-group-id="1051432202-1">)</span><span class="w"> </span><span class="p" data-group-id="1051432202-2">{</span><span class="w">
    </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">res</span><span class="p">;</span><span class="w">

    </span><span class="n">HEAVY_SWAPOUT</span><span class="p">;</span><span class="w">
    </span><span class="ss">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">erts_gc_new_map</span><span class="p" data-group-id="1051432202-3">(</span><span class="ss">c_p</span><span class="p">,</span><span class="w"> </span><span class="ss">reg</span><span class="p">,</span><span class="w"> </span><span class="sc">$L</span><span class="ss">ive</span><span class="p">,</span><span class="w"> </span><span class="sc">$N</span><span class="p">,</span><span class="w"> </span><span class="sc">$N</span><span class="n">EXT_INSTRUCTION</span><span class="p" data-group-id="1051432202-3">)</span><span class="p">;</span><span class="w">
    </span><span class="n">HEAVY_SWAPIN</span><span class="p">;</span><span class="w">
    </span><span class="sc">$R</span><span class="n">EFRESH_GEN_DEST</span><span class="p" data-group-id="1051432202-4">(</span><span class="p" data-group-id="1051432202-4">)</span><span class="p">;</span><span class="w">
    </span><span class="sc">$D</span><span class="ss">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">res</span><span class="p">;</span><span class="w">
    </span><span class="sc">$N</span><span class="n">EXT</span><span class="p" data-group-id="1051432202-5">(</span><span class="sc">$N</span><span class="n">EXT_INSTRUCTION</span><span class="o">+</span><span class="sc">$N</span><span class="p" data-group-id="1051432202-5">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="1051432202-2">}</span></code></pre><p>If we have forgotten the <code class="inline">$REFRESH_GEN_DEST()</code> there would be a message
similar to this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">pointer</span><span class="w"> </span><span class="ss">to</span><span class="w"> </span><span class="ss">destination</span><span class="w"> </span><span class="nb">register</span><span class="w"> </span><span class="ss">is</span><span class="w"> </span><span class="ss">invalid</span><span class="w"> </span><span class="k">after</span><span class="w"> </span><span class="n">GC</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="ss">use</span><span class="w"> </span><span class="sc">$R</span><span class="n">EFRESH_GEN_DEST</span><span class="p" data-group-id="5038659967-1">(</span><span class="p" data-group-id="5038659967-1">)</span><span class="w">
</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="ss">from</span><span class="w"> </span><span class="ss">the</span><span class="w"> </span><span class="ss">body</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="ss">new_map</span><span class="w"> </span><span class="ss">at</span><span class="w"> </span><span class="ss">beam</span><span class="o">/</span><span class="ss">map_instrs</span><span class="p">.</span><span class="nf">tab</span><span class="p" data-group-id="5038659967-2">(</span><span class="mi">30</span><span class="p" data-group-id="5038659967-2">)</span></code></pre><h4>Variable number of operands</h4><p>Here follows an example of how to handle an instruction with a variable number
of operands for the interpreter.  Here is the instruction definition in <code class="inline">emu/ops.tab</code>:</p><pre><code class="makeup erlang" translate="no"><span class="ss">put_tuple2</span><span class="w"> </span><span class="ss">xy</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">*</span></code></pre><p>For the interpreter, the <code class="inline">*</code> is optional, because it does not effect code generation
in any way. However, it is recommended to include it to make it clear for human readers
that there is a variable number of operands.</p><p>Use the <code class="inline">$NEXT_INSTRUCTION</code> macro to obtain a pointer to the first of the variable
operands.</p><p>Here is the implementation:</p><pre><code class="makeup erlang" translate="no"><span class="nf">put_tuple2</span><span class="p" data-group-id="9453546850-1">(</span><span class="n">Dst</span><span class="p">,</span><span class="w"> </span><span class="n">Arity</span><span class="p" data-group-id="9453546850-1">)</span><span class="w"> </span><span class="p" data-group-id="9453546850-2">{</span><span class="w">
</span><span class="n">Eterm</span><span class="o">*</span><span class="w"> </span><span class="ss">hp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HTOP</span><span class="p">;</span><span class="w">
</span><span class="n">Eterm</span><span class="w"> </span><span class="ss">arity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$A</span><span class="ss">rity</span><span class="p">;</span><span class="w">
</span><span class="n">Eterm</span><span class="o">*</span><span class="w"> </span><span class="ss">dst_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">&amp;</span><span class="p" data-group-id="9453546850-3">(</span><span class="sc">$D</span><span class="ss">st</span><span class="p" data-group-id="9453546850-3">)</span><span class="p">;</span><span class="w">

</span><span class="o">/</span><span class="o">/</span><span class="p">|</span><span class="w"> </span><span class="o">-</span><span class="ss">no_next</span><span class="w">
</span><span class="n">ASSERT</span><span class="p" data-group-id="9453546850-4">(</span><span class="ss">arity</span><span class="w"> </span><span class="o">!</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="9453546850-4">)</span><span class="p">;</span><span class="w">
</span><span class="o">*</span><span class="ss">hp</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">make_arityval</span><span class="p" data-group-id="9453546850-5">(</span><span class="ss">arity</span><span class="p" data-group-id="9453546850-5">)</span><span class="p">;</span><span class="w">

</span><span class="o">/</span><span class="o">*</span><span class="w">
 </span><span class="o">*</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="sc">$N</span><span class="n">EXT_INSTRUCTION</span><span class="w"> </span><span class="ss">macro</span><span class="w"> </span><span class="ss">points</span><span class="w"> </span><span class="ss">just</span><span class="w"> </span><span class="ss">beyond</span><span class="w"> </span><span class="ss">the</span><span class="w"> </span><span class="ss">fixed</span><span class="w">
 </span><span class="o">*</span><span class="w"> </span><span class="ss">operands</span><span class="p">.</span><span class="w"> </span><span class="n">In</span><span class="w"> </span><span class="ss">this</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="ss">it</span><span class="w"> </span><span class="ss">points</span><span class="w"> </span><span class="ss">to</span><span class="w"> </span><span class="ss">the</span><span class="w"> </span><span class="ss">descriptor</span><span class="w"> </span><span class="k">of</span><span class="w">
 </span><span class="o">*</span><span class="w"> </span><span class="ss">the</span><span class="w"> </span><span class="ss">first</span><span class="w"> </span><span class="nb">element</span><span class="w"> </span><span class="ss">to</span><span class="w"> </span><span class="ss">be</span><span class="w"> </span><span class="nb">put</span><span class="w"> </span><span class="ss">into</span><span class="w"> </span><span class="ss">the</span><span class="w"> </span><span class="ss">tuple</span><span class="p">.</span><span class="w">
 </span><span class="o">*</span><span class="o">/</span><span class="w">
</span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$N</span><span class="n">EXT_INSTRUCTION</span><span class="p">;</span><span class="w">
</span><span class="ss">do</span><span class="w"> </span><span class="p" data-group-id="9453546850-6">{</span><span class="w">
    </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">I</span><span class="o">++</span><span class="p">;</span><span class="w">
    </span><span class="nf">switch</span><span class="w"> </span><span class="p" data-group-id="9453546850-7">(</span><span class="nf">loader_tag</span><span class="p" data-group-id="9453546850-8">(</span><span class="ss">term</span><span class="p" data-group-id="9453546850-8">)</span><span class="p" data-group-id="9453546850-7">)</span><span class="w"> </span><span class="p" data-group-id="9453546850-9">{</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="n">LOADER_X_REG</span><span class="p">:</span><span class="w">
    </span><span class="o">*</span><span class="ss">hp</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">x</span><span class="p" data-group-id="9453546850-10">(</span><span class="nf">loader_x_reg_index</span><span class="p" data-group-id="9453546850-11">(</span><span class="ss">term</span><span class="p" data-group-id="9453546850-11">)</span><span class="p" data-group-id="9453546850-10">)</span><span class="p">;</span><span class="w">
    </span><span class="ss">break</span><span class="p">;</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="n">LOADER_Y_REG</span><span class="p">:</span><span class="w">
    </span><span class="o">*</span><span class="ss">hp</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">y</span><span class="p" data-group-id="9453546850-12">(</span><span class="nf">loader_y_reg_index</span><span class="p" data-group-id="9453546850-13">(</span><span class="ss">term</span><span class="p" data-group-id="9453546850-13">)</span><span class="p" data-group-id="9453546850-12">)</span><span class="p">;</span><span class="w">
    </span><span class="ss">break</span><span class="p">;</span><span class="w">
    </span><span class="nc">default</span><span class="p">:</span><span class="w">
    </span><span class="o">*</span><span class="ss">hp</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">term</span><span class="p">;</span><span class="w">
    </span><span class="ss">break</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="9453546850-9">}</span><span class="w">
</span><span class="p" data-group-id="9453546850-6">}</span><span class="w"> </span><span class="nf">while</span><span class="w"> </span><span class="p" data-group-id="9453546850-14">(</span><span class="o">--</span><span class="ss">arity</span><span class="w"> </span><span class="o">!</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="9453546850-14">)</span><span class="p">;</span><span class="w">
</span><span class="o">*</span><span class="ss">dst_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">make_tuple</span><span class="p" data-group-id="9453546850-15">(</span><span class="n">HTOP</span><span class="p" data-group-id="9453546850-15">)</span><span class="p">;</span><span class="w">
</span><span class="n">HTOP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">hp</span><span class="p">;</span><span class="w">
</span><span class="n">ASSERT</span><span class="p" data-group-id="9453546850-16">(</span><span class="n">VALID_INSTR</span><span class="p" data-group-id="9453546850-17">(</span><span class="o">*</span><span class="w"> </span><span class="p" data-group-id="9453546850-18">(</span><span class="n">Eterm</span><span class="w"> </span><span class="o">*</span><span class="p" data-group-id="9453546850-18">)</span><span class="n">I</span><span class="p" data-group-id="9453546850-17">)</span><span class="p" data-group-id="9453546850-16">)</span><span class="p">;</span><span class="w">
</span><span class="n">Goto</span><span class="p" data-group-id="9453546850-19">(</span><span class="o">*</span><span class="n">I</span><span class="p" data-group-id="9453546850-19">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="9453546850-2">}</span></code></pre><h4>Combined instructions</h4><p><strong>Problem</strong>: For frequently executed instructions we want to use
&quot;fast&quot; operands types such as <code class="inline">x</code> and <code class="inline">y</code>, as opposed to <code class="inline">s</code> or <code class="inline">S</code>.
To avoid an explosion in code size, we want to share most of the
implementation between the instructions.  Here are the specific
instructions for <code class="inline">i_increment/5</code>:</p><pre><code class="makeup erlang" translate="no"><span class="ss">i_increment</span><span class="w"> </span><span class="ss">r</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="ss">t</span><span class="w"> </span><span class="ss">d</span><span class="w">
</span><span class="ss">i_increment</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="ss">t</span><span class="w"> </span><span class="ss">d</span><span class="w">
</span><span class="ss">i_increment</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="ss">t</span><span class="w"> </span><span class="ss">d</span></code></pre><p>The <code class="inline">i_increment</code> instruction is implemented like this:</p><pre><code class="makeup erlang" translate="no"><span class="nf">i_increment</span><span class="p" data-group-id="8246145946-1">(</span><span class="n">Source</span><span class="p">,</span><span class="w"> </span><span class="n">IncrementVal</span><span class="p">,</span><span class="w"> </span><span class="n">Live</span><span class="p">,</span><span class="w"> </span><span class="n">Dst</span><span class="p" data-group-id="8246145946-1">)</span><span class="w"> </span><span class="p" data-group-id="8246145946-2">{</span><span class="w">
    </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">increment_reg_source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$S</span><span class="ss">ource</span><span class="p">;</span><span class="w">
    </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">increment_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$I</span><span class="ss">ncrementVal</span><span class="p">;</span><span class="w">
    </span><span class="n">Uint</span><span class="w"> </span><span class="ss">live</span><span class="p">;</span><span class="w">
    </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">result</span><span class="p">;</span><span class="w">

    </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="8246145946-3">(</span><span class="n">ERTS_LIKELY</span><span class="p" data-group-id="8246145946-4">(</span><span class="nf">is_small</span><span class="p" data-group-id="8246145946-5">(</span><span class="ss">increment_reg_val</span><span class="p" data-group-id="8246145946-5">)</span><span class="p" data-group-id="8246145946-4">)</span><span class="p" data-group-id="8246145946-3">)</span><span class="w"> </span><span class="p" data-group-id="8246145946-6">{</span><span class="w">
        </span><span class="n">Sint</span><span class="w"> </span><span class="ss">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">signed_val</span><span class="p" data-group-id="8246145946-7">(</span><span class="ss">increment_reg_val</span><span class="p" data-group-id="8246145946-7">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ss">increment_val</span><span class="p">;</span><span class="w">
        </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="8246145946-8">(</span><span class="n">ERTS_LIKELY</span><span class="p" data-group-id="8246145946-9">(</span><span class="n">IS_SSMALL</span><span class="p" data-group-id="8246145946-10">(</span><span class="ss">i</span><span class="p" data-group-id="8246145946-10">)</span><span class="p" data-group-id="8246145946-9">)</span><span class="p" data-group-id="8246145946-8">)</span><span class="w"> </span><span class="p" data-group-id="8246145946-11">{</span><span class="w">
            </span><span class="sc">$D</span><span class="ss">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">make_small</span><span class="p" data-group-id="8246145946-12">(</span><span class="ss">i</span><span class="p" data-group-id="8246145946-12">)</span><span class="p">;</span><span class="w">
            </span><span class="sc">$N</span><span class="n">EXT0</span><span class="p" data-group-id="8246145946-13">(</span><span class="p" data-group-id="8246145946-13">)</span><span class="p">;</span><span class="w">
        </span><span class="p" data-group-id="8246145946-11">}</span><span class="w">
    </span><span class="p" data-group-id="8246145946-6">}</span><span class="w">
    </span><span class="ss">live</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$L</span><span class="ss">ive</span><span class="p">;</span><span class="w">
    </span><span class="n">HEAVY_SWAPOUT</span><span class="p">;</span><span class="w">
    </span><span class="ss">reg</span><span class="p" data-group-id="8246145946-14">[</span><span class="ss">live</span><span class="p" data-group-id="8246145946-14">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">increment_reg_val</span><span class="p">;</span><span class="w">
    </span><span class="ss">reg</span><span class="p" data-group-id="8246145946-15">[</span><span class="ss">live</span><span class="o">+</span><span class="mi">1</span><span class="p" data-group-id="8246145946-15">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">make_small</span><span class="p" data-group-id="8246145946-16">(</span><span class="ss">increment_val</span><span class="p" data-group-id="8246145946-16">)</span><span class="p">;</span><span class="w">
    </span><span class="ss">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">erts_gc_mixed_plus</span><span class="p" data-group-id="8246145946-17">(</span><span class="ss">c_p</span><span class="p">,</span><span class="w"> </span><span class="ss">reg</span><span class="p">,</span><span class="w"> </span><span class="ss">live</span><span class="p" data-group-id="8246145946-17">)</span><span class="p">;</span><span class="w">
    </span><span class="n">HEAVY_SWAPIN</span><span class="p">;</span><span class="w">
    </span><span class="n">ERTS_HOLE_CHECK</span><span class="p" data-group-id="8246145946-18">(</span><span class="ss">c_p</span><span class="p" data-group-id="8246145946-18">)</span><span class="p">;</span><span class="w">
    </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="8246145946-19">(</span><span class="n">ERTS_LIKELY</span><span class="p" data-group-id="8246145946-20">(</span><span class="nf">is_value</span><span class="p" data-group-id="8246145946-21">(</span><span class="ss">result</span><span class="p" data-group-id="8246145946-21">)</span><span class="p" data-group-id="8246145946-20">)</span><span class="p" data-group-id="8246145946-19">)</span><span class="w"> </span><span class="p" data-group-id="8246145946-22">{</span><span class="w">
        </span><span class="sc">$R</span><span class="n">EFRESH_GEN_DEST</span><span class="p" data-group-id="8246145946-23">(</span><span class="p" data-group-id="8246145946-23">)</span><span class="p">;</span><span class="w">
        </span><span class="sc">$D</span><span class="ss">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">result</span><span class="p">;</span><span class="w">
        </span><span class="sc">$N</span><span class="n">EXT0</span><span class="p" data-group-id="8246145946-24">(</span><span class="p" data-group-id="8246145946-24">)</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="8246145946-22">}</span><span class="w">
    </span><span class="n">ASSERT</span><span class="p" data-group-id="8246145946-25">(</span><span class="ss">c_p</span><span class="p">-&gt;</span><span class="ss">freason</span><span class="w"> </span><span class="o">!</span><span class="o">=</span><span class="w"> </span><span class="n">BADMATCH</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="nf">is_value</span><span class="p" data-group-id="8246145946-26">(</span><span class="ss">c_p</span><span class="p">-&gt;</span><span class="ss">fvalue</span><span class="p" data-group-id="8246145946-26">)</span><span class="p" data-group-id="8246145946-25">)</span><span class="p">;</span><span class="w">
    </span><span class="ss">goto</span><span class="w"> </span><span class="ss">find_func_info</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="8246145946-2">}</span></code></pre><p>There will be three almost identical copies of the code.  Given the
size of the code, that could be too high cost to pay.</p><p>To avoid the three copies of the code, we could use only one specific
instruction:</p><pre><code class="makeup erlang" translate="no"><span class="ss">i_increment</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="ss">t</span><span class="w"> </span><span class="ss">d</span></code></pre><p>(The same implementation as above will work.)</p><p>That reduces the code size, but is slower because <code class="inline">S</code> means that
there will be extra code to test whether the operand refers to an X
register or a Y register.</p><p><strong>Solution</strong>: We can use &quot;combined instructions&quot;.  Combined
instructions are combined from instruction fragments.  The
bulk of the code can be shared.</p><p>Here we will show how <code class="inline">i_increment</code> can be implemented as a combined
instruction.  We will show each individual fragment first, and then
show how to connect them together.  First we will need a variable that
we can store the value fetched from the register in:</p><pre><code class="makeup erlang" translate="no"><span class="ss">increment</span><span class="p">.</span><span class="nf">head</span><span class="p" data-group-id="2953454776-1">(</span><span class="p" data-group-id="2953454776-1">)</span><span class="w"> </span><span class="p" data-group-id="2953454776-2">{</span><span class="w">
    </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">increment_reg_val</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="2953454776-2">}</span></code></pre><p>The name <code class="inline">increment</code> is the name of the group that the fragment
belongs to.  Note that it does not need to have the same
name as the instruction.  The group name is followed by <code class="inline">.</code> and
the name of the fragment.  The name <code class="inline">head</code> is pre-defined.
The code in it will be placed at the beginning of a block, so
that all fragments in the group can access it.</p><p>Next we define the fragment that will pick up the value from the
register from the first operand:</p><pre><code class="makeup erlang" translate="no"><span class="ss">increment</span><span class="p">.</span><span class="nf">fetch</span><span class="p" data-group-id="8753594357-1">(</span><span class="n">Src</span><span class="p" data-group-id="8753594357-1">)</span><span class="w"> </span><span class="p" data-group-id="8753594357-2">{</span><span class="w">
    </span><span class="ss">increment_reg_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$S</span><span class="ss">rc</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="8753594357-2">}</span></code></pre><p>We call this fragment <code class="inline">fetch</code>.  This fragment will be duplicated three
times, one for each value of the first operand (<code class="inline">r</code>, <code class="inline">x</code>, and <code class="inline">y</code>).</p><p>Next we define the main part of the code that do the actual incrementing.</p><pre><code class="makeup erlang" translate="no"><span class="ss">increment</span><span class="p">.</span><span class="nf">execute</span><span class="p" data-group-id="1180824792-1">(</span><span class="n">IncrementVal</span><span class="p">,</span><span class="w"> </span><span class="n">Live</span><span class="p">,</span><span class="w"> </span><span class="n">Dst</span><span class="p" data-group-id="1180824792-1">)</span><span class="w"> </span><span class="p" data-group-id="1180824792-2">{</span><span class="w">
    </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">increment_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$I</span><span class="ss">ncrementVal</span><span class="p">;</span><span class="w">
    </span><span class="n">Uint</span><span class="w"> </span><span class="ss">live</span><span class="p">;</span><span class="w">
    </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">result</span><span class="p">;</span><span class="w">

    </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="1180824792-3">(</span><span class="n">ERTS_LIKELY</span><span class="p" data-group-id="1180824792-4">(</span><span class="nf">is_small</span><span class="p" data-group-id="1180824792-5">(</span><span class="ss">increment_reg_val</span><span class="p" data-group-id="1180824792-5">)</span><span class="p" data-group-id="1180824792-4">)</span><span class="p" data-group-id="1180824792-3">)</span><span class="w"> </span><span class="p" data-group-id="1180824792-6">{</span><span class="w">
        </span><span class="n">Sint</span><span class="w"> </span><span class="ss">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">signed_val</span><span class="p" data-group-id="1180824792-7">(</span><span class="ss">increment_reg_val</span><span class="p" data-group-id="1180824792-7">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ss">increment_val</span><span class="p">;</span><span class="w">
        </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="1180824792-8">(</span><span class="n">ERTS_LIKELY</span><span class="p" data-group-id="1180824792-9">(</span><span class="n">IS_SSMALL</span><span class="p" data-group-id="1180824792-10">(</span><span class="ss">i</span><span class="p" data-group-id="1180824792-10">)</span><span class="p" data-group-id="1180824792-9">)</span><span class="p" data-group-id="1180824792-8">)</span><span class="w"> </span><span class="p" data-group-id="1180824792-11">{</span><span class="w">
            </span><span class="sc">$D</span><span class="ss">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">make_small</span><span class="p" data-group-id="1180824792-12">(</span><span class="ss">i</span><span class="p" data-group-id="1180824792-12">)</span><span class="p">;</span><span class="w">
            </span><span class="sc">$N</span><span class="n">EXT0</span><span class="p" data-group-id="1180824792-13">(</span><span class="p" data-group-id="1180824792-13">)</span><span class="p">;</span><span class="w">
        </span><span class="p" data-group-id="1180824792-11">}</span><span class="w">
    </span><span class="p" data-group-id="1180824792-6">}</span><span class="w">
    </span><span class="ss">live</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$L</span><span class="ss">ive</span><span class="p">;</span><span class="w">
    </span><span class="n">HEAVY_SWAPOUT</span><span class="p">;</span><span class="w">
    </span><span class="ss">reg</span><span class="p" data-group-id="1180824792-14">[</span><span class="ss">live</span><span class="p" data-group-id="1180824792-14">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">increment_reg_val</span><span class="p">;</span><span class="w">
    </span><span class="ss">reg</span><span class="p" data-group-id="1180824792-15">[</span><span class="ss">live</span><span class="o">+</span><span class="mi">1</span><span class="p" data-group-id="1180824792-15">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">make_small</span><span class="p" data-group-id="1180824792-16">(</span><span class="ss">increment_val</span><span class="p" data-group-id="1180824792-16">)</span><span class="p">;</span><span class="w">
    </span><span class="ss">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">erts_gc_mixed_plus</span><span class="p" data-group-id="1180824792-17">(</span><span class="ss">c_p</span><span class="p">,</span><span class="w"> </span><span class="ss">reg</span><span class="p">,</span><span class="w"> </span><span class="ss">live</span><span class="p" data-group-id="1180824792-17">)</span><span class="p">;</span><span class="w">
    </span><span class="n">HEAVY_SWAPIN</span><span class="p">;</span><span class="w">
    </span><span class="n">ERTS_HOLE_CHECK</span><span class="p" data-group-id="1180824792-18">(</span><span class="ss">c_p</span><span class="p" data-group-id="1180824792-18">)</span><span class="p">;</span><span class="w">
    </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="1180824792-19">(</span><span class="n">ERTS_LIKELY</span><span class="p" data-group-id="1180824792-20">(</span><span class="nf">is_value</span><span class="p" data-group-id="1180824792-21">(</span><span class="ss">result</span><span class="p" data-group-id="1180824792-21">)</span><span class="p" data-group-id="1180824792-20">)</span><span class="p" data-group-id="1180824792-19">)</span><span class="w"> </span><span class="p" data-group-id="1180824792-22">{</span><span class="w">
        </span><span class="sc">$R</span><span class="n">EFRESH_GEN_DEST</span><span class="p" data-group-id="1180824792-23">(</span><span class="p" data-group-id="1180824792-23">)</span><span class="p">;</span><span class="w">
        </span><span class="sc">$D</span><span class="ss">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">result</span><span class="p">;</span><span class="w">
        </span><span class="sc">$N</span><span class="n">EXT0</span><span class="p" data-group-id="1180824792-24">(</span><span class="p" data-group-id="1180824792-24">)</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="1180824792-22">}</span><span class="w">
    </span><span class="n">ASSERT</span><span class="p" data-group-id="1180824792-25">(</span><span class="ss">c_p</span><span class="p">-&gt;</span><span class="ss">freason</span><span class="w"> </span><span class="o">!</span><span class="o">=</span><span class="w"> </span><span class="n">BADMATCH</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="nf">is_value</span><span class="p" data-group-id="1180824792-26">(</span><span class="ss">c_p</span><span class="p">-&gt;</span><span class="ss">fvalue</span><span class="p" data-group-id="1180824792-26">)</span><span class="p" data-group-id="1180824792-25">)</span><span class="p">;</span><span class="w">
    </span><span class="ss">goto</span><span class="w"> </span><span class="ss">find_func_info</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="1180824792-2">}</span></code></pre><p>We call this fragment <code class="inline">execute</code>.  It will handle the three remaining
operands (<code class="inline">W t d</code>).  There will only be one copy of this fragment.</p><p>Now that we have defined the fragments, we need to inform
<strong>beam_makeops</strong> how they should be connected:</p><pre><code class="makeup erlang" translate="no"><span class="ss">i_increment</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">increment</span><span class="p">.</span><span class="ss">fetch</span><span class="p">.</span><span class="ss">execute</span><span class="p">;</span></code></pre><p>To the left of the <code class="inline">:=</code> is the name of the specific instruction that
should be implemented by the fragments, in this case <code class="inline">i_increment</code>.
To the right of <code class="inline">:=</code> is the name of the group with the fragments,
followed by a <code class="inline">.</code>.  Then the name of the fragments in the group are
listed in the order they should be executed.  Note that the <code class="inline">head</code>
fragment is not listed.</p><p>The line ends in <code class="inline">;</code> (to avoid messing up the indentation in Emacs).</p><p>(Note that in practice the <code class="inline">:=</code> line is usually placed before the
fragments.)</p><p>The generated code looks like this:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="9686883159-1">{</span><span class="w">
  </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">increment_reg_val</span><span class="p">;</span><span class="w">
  </span><span class="n">OpCase</span><span class="p" data-group-id="9686883159-2">(</span><span class="ss">i_increment_rWtd</span><span class="p" data-group-id="9686883159-2">)</span><span class="p">:</span><span class="w">
  </span><span class="p" data-group-id="9686883159-3">{</span><span class="w">
    </span><span class="ss">increment_reg_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">r</span><span class="p" data-group-id="9686883159-4">(</span><span class="mi">0</span><span class="p" data-group-id="9686883159-4">)</span><span class="p">;</span><span class="w">
  </span><span class="p" data-group-id="9686883159-3">}</span><span class="w">
  </span><span class="ss">goto</span><span class="w"> </span><span class="ss">increment__execute</span><span class="p">;</span><span class="w">

  </span><span class="n">OpCase</span><span class="p" data-group-id="9686883159-5">(</span><span class="ss">i_increment_xWtd</span><span class="p" data-group-id="9686883159-5">)</span><span class="p">:</span><span class="w">
  </span><span class="p" data-group-id="9686883159-6">{</span><span class="w">
    </span><span class="ss">increment_reg_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">xb</span><span class="p" data-group-id="9686883159-7">(</span><span class="n">BeamExtraData</span><span class="p" data-group-id="9686883159-8">(</span><span class="n">I</span><span class="p" data-group-id="9686883159-9">[</span><span class="mi">0</span><span class="p" data-group-id="9686883159-9">]</span><span class="p" data-group-id="9686883159-8">)</span><span class="p" data-group-id="9686883159-7">)</span><span class="p">;</span><span class="w">
  </span><span class="p" data-group-id="9686883159-6">}</span><span class="w">
  </span><span class="ss">goto</span><span class="w"> </span><span class="ss">increment__execute</span><span class="p">;</span><span class="w">

  </span><span class="n">OpCase</span><span class="p" data-group-id="9686883159-10">(</span><span class="ss">i_increment_yWtd</span><span class="p" data-group-id="9686883159-10">)</span><span class="p">:</span><span class="w">
  </span><span class="p" data-group-id="9686883159-11">{</span><span class="w">
    </span><span class="ss">increment_reg_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">yb</span><span class="p" data-group-id="9686883159-12">(</span><span class="n">BeamExtraData</span><span class="p" data-group-id="9686883159-13">(</span><span class="n">I</span><span class="p" data-group-id="9686883159-14">[</span><span class="mi">0</span><span class="p" data-group-id="9686883159-14">]</span><span class="p" data-group-id="9686883159-13">)</span><span class="p" data-group-id="9686883159-12">)</span><span class="p">;</span><span class="w">
  </span><span class="p" data-group-id="9686883159-11">}</span><span class="w">
  </span><span class="ss">goto</span><span class="w"> </span><span class="ss">increment__execute</span><span class="p">;</span><span class="w">

  </span><span class="nc">increment__execute</span><span class="p">:</span><span class="w">
  </span><span class="p" data-group-id="9686883159-15">{</span><span class="w">
    </span><span class="o">/</span><span class="o">/</span><span class="w"> </span><span class="n">Here</span><span class="w"> </span><span class="ss">follows</span><span class="w"> </span><span class="ss">the</span><span class="w"> </span><span class="ss">code</span><span class="w"> </span><span class="ss">from</span><span class="w"> </span><span class="ss">increment</span><span class="p">.</span><span class="nf">execute</span><span class="p" data-group-id="9686883159-16">(</span><span class="p" data-group-id="9686883159-16">)</span><span class="w">
    </span><span class="p">.</span><span class="w">
    </span><span class="p">.</span><span class="w">
    </span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9686883159-15">}</span></code></pre><h5>Some notes about combined instructions</h5><p>The operands that are different must be at
the beginning of the instruction.  All operands in the last
fragment must have the same operands in all variants of
the specific instruction.</p><p>As an example, the following specific instructions cannot be
implemented as a combined instruction:</p><pre><code class="makeup erlang" translate="no"><span class="ss">i_times</span><span class="w"> </span><span class="ss">j</span><span class="o">?</span><span class="w"> </span><span class="ss">t</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">d</span><span class="w">
</span><span class="ss">i_times</span><span class="w"> </span><span class="ss">j</span><span class="o">?</span><span class="w"> </span><span class="ss">t</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="ss">d</span><span class="w">
</span><span class="ss">i_times</span><span class="w"> </span><span class="ss">j</span><span class="o">?</span><span class="w"> </span><span class="ss">t</span><span class="w"> </span><span class="ss">s</span><span class="w"> </span><span class="ss">s</span><span class="w"> </span><span class="ss">d</span></code></pre><p>We would have to change the order of the operands so that the
two operands that are different are placed first:</p><pre><code class="makeup erlang" translate="no"><span class="ss">i_times</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">j</span><span class="o">?</span><span class="w"> </span><span class="ss">t</span><span class="w"> </span><span class="ss">d</span><span class="w">
</span><span class="ss">i_times</span><span class="w"> </span><span class="ss">x</span><span class="w"> </span><span class="ss">y</span><span class="w"> </span><span class="ss">j</span><span class="o">?</span><span class="w"> </span><span class="ss">t</span><span class="w"> </span><span class="ss">d</span><span class="w">
</span><span class="ss">i_times</span><span class="w"> </span><span class="ss">s</span><span class="w"> </span><span class="ss">s</span><span class="w"> </span><span class="ss">j</span><span class="o">?</span><span class="w"> </span><span class="ss">t</span><span class="w"> </span><span class="ss">d</span></code></pre><p>We can then define:</p><pre><code class="makeup erlang" translate="no"><span class="ss">i_times</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">times</span><span class="p">.</span><span class="ss">fetch</span><span class="p">.</span><span class="ss">execute</span><span class="p">;</span><span class="w">

</span><span class="ss">times</span><span class="p">.</span><span class="ss">head</span><span class="w"> </span><span class="p" data-group-id="3758427729-1">{</span><span class="w">
    </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">op1</span><span class="p">,</span><span class="w"> </span><span class="ss">op2</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="3758427729-1">}</span><span class="w">

</span><span class="ss">times</span><span class="p">.</span><span class="nf">fetch</span><span class="p" data-group-id="3758427729-2">(</span><span class="n">Src1</span><span class="p">,</span><span class="w"> </span><span class="n">Src2</span><span class="p" data-group-id="3758427729-2">)</span><span class="w"> </span><span class="p" data-group-id="3758427729-3">{</span><span class="w">
    </span><span class="ss">op1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$S</span><span class="ss">rc1</span><span class="p">;</span><span class="w">
    </span><span class="ss">op2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$S</span><span class="ss">rc2</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="3758427729-3">}</span><span class="w">

</span><span class="ss">times</span><span class="p">.</span><span class="nf">execute</span><span class="p" data-group-id="3758427729-4">(</span><span class="n">Fail</span><span class="p">,</span><span class="w"> </span><span class="n">Live</span><span class="p">,</span><span class="w"> </span><span class="n">Dst</span><span class="p" data-group-id="3758427729-4">)</span><span class="w"> </span><span class="p" data-group-id="3758427729-5">{</span><span class="w">
    </span><span class="o">/</span><span class="o">/</span><span class="w"> </span><span class="n">Multiply</span><span class="w"> </span><span class="ss">op1</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="ss">op2</span><span class="p">.</span><span class="w">
    </span><span class="p">.</span><span class="w">
    </span><span class="p">.</span><span class="w">
    </span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="3758427729-5">}</span></code></pre><p>Several instructions can share a group.  As an example, the following
instructions have different names, but in the end they all create a
binary.  The last two operands are common for all of them:</p><pre><code class="makeup erlang" translate="no"><span class="ss">i_bs_init_fail</span><span class="w">       </span><span class="ss">xy</span><span class="w"> </span><span class="ss">j</span><span class="o">?</span><span class="w"> </span><span class="ss">t</span><span class="o">?</span><span class="w"> </span><span class="ss">x</span><span class="w">
</span><span class="ss">i_bs_init_fail_heap</span><span class="w"> </span><span class="ss">s</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="ss">j</span><span class="o">?</span><span class="w"> </span><span class="ss">t</span><span class="o">?</span><span class="w"> </span><span class="ss">x</span><span class="w">
</span><span class="ss">i_bs_init</span><span class="w">                </span><span class="n">W</span><span class="w"> </span><span class="ss">t</span><span class="o">?</span><span class="w"> </span><span class="ss">x</span><span class="w">
</span><span class="ss">i_bs_init_heap</span><span class="w">         </span><span class="n">W</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="ss">t</span><span class="o">?</span><span class="w"> </span><span class="ss">x</span></code></pre><p>The instructions are defined like this (formatted with extra
spaces for clarity):</p><pre><code class="makeup erlang" translate="no"><span class="ss">i_bs_init_fail_heap</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">bs_init</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="ss">fail_heap</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="ss">verify</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="ss">execute</span><span class="p">;</span><span class="w">
</span><span class="ss">i_bs_init_fail</span><span class="w">      </span><span class="p">:=</span><span class="w"> </span><span class="ss">bs_init</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="ss">fail</span><span class="w">      </span><span class="p">.</span><span class="w"> </span><span class="ss">verify</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="ss">execute</span><span class="p">;</span><span class="w">
</span><span class="ss">i_bs_init</span><span class="w">           </span><span class="p">:=</span><span class="w"> </span><span class="ss">bs_init</span><span class="w"> </span><span class="p">.</span><span class="w">           </span><span class="p">.</span><span class="w">  </span><span class="ss">plain</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="ss">execute</span><span class="p">;</span><span class="w">
</span><span class="ss">i_bs_init_heap</span><span class="w">      </span><span class="p">:=</span><span class="w"> </span><span class="ss">bs_init</span><span class="w"> </span><span class="p">.</span><span class="w">               </span><span class="ss">heap</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="ss">execute</span><span class="p">;</span></code></pre><p>Note that the first two instruction have three fragments, while the
other two only have two fragments.  Here are the fragments:</p><pre><code class="makeup erlang" translate="no"><span class="ss">bs_init_bits</span><span class="p">.</span><span class="nf">head</span><span class="p" data-group-id="9234119249-1">(</span><span class="p" data-group-id="9234119249-1">)</span><span class="w"> </span><span class="p" data-group-id="9234119249-2">{</span><span class="w">
    </span><span class="n">Eterm</span><span class="w"> </span><span class="ss">num_bits_term</span><span class="p">;</span><span class="w">
    </span><span class="n">Uint</span><span class="w"> </span><span class="ss">num_bits</span><span class="p">;</span><span class="w">
    </span><span class="n">Uint</span><span class="w"> </span><span class="ss">alloc</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="9234119249-2">}</span><span class="w">

</span><span class="ss">bs_init_bits</span><span class="p">.</span><span class="nf">plain</span><span class="p" data-group-id="9234119249-3">(</span><span class="n">NumBits</span><span class="p" data-group-id="9234119249-3">)</span><span class="w"> </span><span class="p" data-group-id="9234119249-4">{</span><span class="w">
    </span><span class="ss">num_bits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$N</span><span class="ss">umBits</span><span class="p">;</span><span class="w">
    </span><span class="ss">alloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="9234119249-4">}</span><span class="w">

</span><span class="ss">bs_init_bits</span><span class="p">.</span><span class="nf">heap</span><span class="p" data-group-id="9234119249-5">(</span><span class="n">NumBits</span><span class="p">,</span><span class="w"> </span><span class="n">Alloc</span><span class="p" data-group-id="9234119249-5">)</span><span class="w"> </span><span class="p" data-group-id="9234119249-6">{</span><span class="w">
    </span><span class="ss">num_bits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$N</span><span class="ss">umBits</span><span class="p">;</span><span class="w">
    </span><span class="ss">alloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$A</span><span class="ss">lloc</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="9234119249-6">}</span><span class="w">

</span><span class="ss">bs_init_bits</span><span class="p">.</span><span class="nf">fail</span><span class="p" data-group-id="9234119249-7">(</span><span class="n">NumBitsTerm</span><span class="p" data-group-id="9234119249-7">)</span><span class="w"> </span><span class="p" data-group-id="9234119249-8">{</span><span class="w">
    </span><span class="ss">num_bits_term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$N</span><span class="ss">umBitsTerm</span><span class="p">;</span><span class="w">
    </span><span class="ss">alloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="9234119249-8">}</span><span class="w">

</span><span class="ss">bs_init_bits</span><span class="p">.</span><span class="nf">fail_heap</span><span class="p" data-group-id="9234119249-9">(</span><span class="n">NumBitsTerm</span><span class="p">,</span><span class="w"> </span><span class="n">Alloc</span><span class="p" data-group-id="9234119249-9">)</span><span class="w"> </span><span class="p" data-group-id="9234119249-10">{</span><span class="w">
    </span><span class="ss">num_bits_term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$N</span><span class="ss">umBitsTerm</span><span class="p">;</span><span class="w">
    </span><span class="ss">alloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">$A</span><span class="ss">lloc</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="9234119249-10">}</span><span class="w">

</span><span class="ss">bs_init_bits</span><span class="p">.</span><span class="nf">verify</span><span class="p" data-group-id="9234119249-11">(</span><span class="n">Fail</span><span class="p" data-group-id="9234119249-11">)</span><span class="w"> </span><span class="p" data-group-id="9234119249-12">{</span><span class="w">
    </span><span class="o">/</span><span class="o">/</span><span class="w"> </span><span class="n">Verify</span><span class="w"> </span><span class="ss">the</span><span class="w"> </span><span class="ss">num_bits_term</span><span class="p">,</span><span class="w"> </span><span class="ss">fail</span><span class="w"> </span><span class="ss">using</span><span class="w"> </span><span class="sc">$F</span><span class="n">AIL</span><span class="w">
    </span><span class="o">/</span><span class="o">/</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="ss">there</span><span class="w"> </span><span class="ss">is</span><span class="w"> </span><span class="ss">a</span><span class="w"> </span><span class="ss">problem</span><span class="p">.</span><span class="w">
</span><span class="p">.</span><span class="w">
</span><span class="p">.</span><span class="w">
</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9234119249-12">}</span><span class="w">

</span><span class="ss">bs_init_bits</span><span class="p">.</span><span class="nf">execute</span><span class="p" data-group-id="9234119249-13">(</span><span class="n">Live</span><span class="p">,</span><span class="w"> </span><span class="n">Dst</span><span class="p" data-group-id="9234119249-13">)</span><span class="w"> </span><span class="p" data-group-id="9234119249-14">{</span><span class="w">
   </span><span class="o">/</span><span class="o">/</span><span class="w"> </span><span class="n">Long</span><span class="w"> </span><span class="ss">complicated</span><span class="w"> </span><span class="ss">code</span><span class="w"> </span><span class="ss">to</span><span class="w"> </span><span class="ss">a</span><span class="w"> </span><span class="ss">create</span><span class="w"> </span><span class="ss">a</span><span class="w"> </span><span class="ss">binary</span><span class="p">.</span><span class="w">
   </span><span class="p">.</span><span class="w">
   </span><span class="p">.</span><span class="w">
   </span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9234119249-14">}</span></code></pre><p>The full definitions of those instructions can be found in <code class="inline">bs_instrs.tab</code>.
The generated code can be found in <code class="inline">beam_warm.h</code>.</p><h3 id="code-generation-for-beamasm" class="section-heading"><a href="#code-generation-for-beamasm" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Code generation for BeamAsm</span></h3><p>For the BeamAsm runtime system, the implementation of each instruction is defined
by emitter functions written in C++ that emit the assembly code for each instruction.
There is one emitter function for each family of specific instructions.</p><p>Take for example the <code class="inline">move</code> instruction. In <code class="inline">beam/asm/ops.tab</code> there is a
single specific instruction for <code class="inline">move</code> defined like this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">move</span><span class="w"> </span><span class="ss">s</span><span class="w"> </span><span class="ss">d</span></code></pre><p>The implementation is found in <code class="inline">beam/asm/instr_common.cpp</code>:</p><pre><code class="makeup erlang" translate="no"><span class="ss">void</span><span class="w"> </span><span class="n">BeamModuleAssembler</span><span class="p">:</span><span class="p">:</span><span class="nf">emit_move</span><span class="p" data-group-id="4602599623-1">(</span><span class="ss">const</span><span class="w"> </span><span class="n">ArgVal</span><span class="w"> </span><span class="err">&amp;</span><span class="n">Src</span><span class="p">,</span><span class="w"> </span><span class="ss">const</span><span class="w"> </span><span class="n">ArgVal</span><span class="w"> </span><span class="err">&amp;</span><span class="n">Dst</span><span class="p" data-group-id="4602599623-1">)</span><span class="w"> </span><span class="p" data-group-id="4602599623-2">{</span><span class="w">
    </span><span class="nf">mov_arg</span><span class="p" data-group-id="4602599623-3">(</span><span class="n">Dst</span><span class="p">,</span><span class="w"> </span><span class="n">Src</span><span class="p" data-group-id="4602599623-3">)</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="4602599623-2">}</span></code></pre><p>The <code class="inline">mov_arg()</code> helper function will handle all combinations of source and destination
operands.  For example, the instruction <code class="inline">{move,{x,1},{y,1}}</code> will be translated like this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">mov</span><span class="w"> </span><span class="ss">rdi</span><span class="p">,</span><span class="w"> </span><span class="ss">qword</span><span class="w"> </span><span class="p" data-group-id="7990582534-1">[</span><span class="ss">rbx</span><span class="o">+</span><span class="mi">8</span><span class="p" data-group-id="7990582534-1">]</span><span class="w">
</span><span class="ss">mov</span><span class="w"> </span><span class="ss">qword</span><span class="w"> </span><span class="p" data-group-id="7990582534-2">[</span><span class="ss">rsp</span><span class="o">+</span><span class="mi">8</span><span class="p" data-group-id="7990582534-2">]</span><span class="p">,</span><span class="w"> </span><span class="ss">rdi</span></code></pre><p>while <code class="inline">{move,{integer,42},{x,0}}</code> will be translated like this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">mov</span><span class="w"> </span><span class="ss">qword</span><span class="w"> </span><span class="p" data-group-id="1576094272-1">[</span><span class="ss">rbx</span><span class="p" data-group-id="1576094272-1">]</span><span class="p">,</span><span class="w"> </span><span class="mi">687</span></code></pre><p>It is possible to define more than one specific instruction, but there will still be
only one emitter function. For example:</p><pre><code class="makeup erlang" translate="no"><span class="ss">fload</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="ss">l</span><span class="w">
</span><span class="ss">fload</span><span class="w"> </span><span class="ss">q</span><span class="w"> </span><span class="ss">l</span></code></pre><p>By defining <code class="inline">fload</code> like this, the source operand must be a X register, Y register, or
a literal.  If not, the loading will be aborted.  If the instruction instead had been
defined like this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">fload</span><span class="w"> </span><span class="ss">s</span><span class="w"> </span><span class="ss">l</span></code></pre><p>attempting to load an invalid instruction such as <code class="inline">{fload,{atom,clearly_bad},{fr,0}}</code>
would cause a crash (either at load time or when the instruction was executed).</p><p>Regardless on how many specific instructions there are in the family,
only a single <code class="inline">emit_fload()</code> function is allowed:</p><pre><code class="makeup erlang" translate="no"><span class="ss">void</span><span class="w"> </span><span class="n">BeamModuleAssembler</span><span class="p">:</span><span class="p">:</span><span class="nf">emit_fload</span><span class="p" data-group-id="9369419789-1">(</span><span class="ss">const</span><span class="w"> </span><span class="n">ArgVal</span><span class="w"> </span><span class="err">&amp;</span><span class="n">Src</span><span class="p">,</span><span class="w"> </span><span class="ss">const</span><span class="w"> </span><span class="n">ArgVal</span><span class="w"> </span><span class="err">&amp;</span><span class="n">Dst</span><span class="p" data-group-id="9369419789-1">)</span><span class="w"> </span><span class="p" data-group-id="9369419789-2">{</span><span class="w">
    </span><span class="p">.</span><span class="w">
    </span><span class="p">.</span><span class="w">
    </span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9369419789-2">}</span></code></pre><p><a href="" id="handling-a-variable-number-of-operands"></a></p><h4>Handling a variable number of operands</h4><p>Here follows an example of how an instruction with a variable number
of operands could be handled.  One such instructions is
<code class="inline">select_val/3</code>. Here is an example how it can look like in BEAM code:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="7146123830-1">{</span><span class="ss">select_val</span><span class="p">,</span><span class="p" data-group-id="7146123830-2">{</span><span class="ss">x</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="7146123830-2">}</span><span class="p">,</span><span class="w">
            </span><span class="p" data-group-id="7146123830-3">{</span><span class="ss">f</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="7146123830-3">}</span><span class="p">,</span><span class="w">
            </span><span class="p" data-group-id="7146123830-4">{</span><span class="ss">list</span><span class="p">,</span><span class="p" data-group-id="7146123830-5">[</span><span class="p" data-group-id="7146123830-6">{</span><span class="ss">atom</span><span class="p">,</span><span class="ss">b</span><span class="p" data-group-id="7146123830-6">}</span><span class="p">,</span><span class="p" data-group-id="7146123830-7">{</span><span class="ss">f</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="7146123830-7">}</span><span class="p">,</span><span class="p" data-group-id="7146123830-8">{</span><span class="ss">atom</span><span class="p">,</span><span class="ss">a</span><span class="p" data-group-id="7146123830-8">}</span><span class="p">,</span><span class="p" data-group-id="7146123830-9">{</span><span class="ss">f</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="7146123830-9">}</span><span class="p" data-group-id="7146123830-5">]</span><span class="p" data-group-id="7146123830-4">}</span><span class="p" data-group-id="7146123830-1">}</span><span class="p">.</span></code></pre><p>The loader will convert a <code class="inline">{list,[...]}</code> operand to an <code class="inline">u</code> operand whose
value is the number of elements in the list, followed by each element in
the list.  The instruction above would be translated to the following
instruction:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="8544195106-1">{</span><span class="ss">select_val</span><span class="p">,</span><span class="p" data-group-id="8544195106-2">{</span><span class="ss">x</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="8544195106-2">}</span><span class="p">,</span><span class="p" data-group-id="8544195106-3">{</span><span class="ss">f</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="8544195106-3">}</span><span class="p">,</span><span class="p" data-group-id="8544195106-4">{</span><span class="ss">u</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="8544195106-4">}</span><span class="p">,</span><span class="p" data-group-id="8544195106-5">{</span><span class="ss">atom</span><span class="p">,</span><span class="ss">b</span><span class="p" data-group-id="8544195106-5">}</span><span class="p">,</span><span class="p" data-group-id="8544195106-6">{</span><span class="ss">f</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="8544195106-6">}</span><span class="p">,</span><span class="p" data-group-id="8544195106-7">{</span><span class="ss">atom</span><span class="p">,</span><span class="ss">a</span><span class="p" data-group-id="8544195106-7">}</span><span class="p">,</span><span class="p" data-group-id="8544195106-8">{</span><span class="ss">f</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="8544195106-8">}</span><span class="p" data-group-id="8544195106-1">}</span></code></pre><p>A definition of a specific instruction for that instruction would look
like this:</p><pre><code class="makeup erlang" translate="no"><span class="ss">select_val</span><span class="w"> </span><span class="ss">s</span><span class="w"> </span><span class="ss">f</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">*</span></code></pre><p>The <code class="inline">*</code> as the last operand will make sure that the variable operands
are passed in as a <code class="inline">Span</code> of <code class="inline">ArgVal</code> (will be <code class="inline">std::span</code> in C++20 onwards).
Here is the emitter function:</p><pre><code class="makeup erlang" translate="no"><span class="ss">void</span><span class="w"> </span><span class="n">BeamModuleAssembler</span><span class="p">:</span><span class="p">:</span><span class="nf">emit_select_val</span><span class="p" data-group-id="8614901117-1">(</span><span class="ss">const</span><span class="w"> </span><span class="n">ArgVal</span><span class="w"> </span><span class="err">&amp;</span><span class="n">Src</span><span class="p">,</span><span class="w">
                                          </span><span class="ss">const</span><span class="w"> </span><span class="n">ArgVal</span><span class="w"> </span><span class="err">&amp;</span><span class="n">Fail</span><span class="p">,</span><span class="w">
                                          </span><span class="ss">const</span><span class="w"> </span><span class="n">ArgVal</span><span class="w"> </span><span class="err">&amp;</span><span class="n">Size</span><span class="p">,</span><span class="w">
                                          </span><span class="ss">const</span><span class="w"> </span><span class="n">Span</span><span class="o">&lt;</span><span class="n">ArgVal</span><span class="o">&gt;</span><span class="w"> </span><span class="err">&amp;</span><span class="ss">args</span><span class="p" data-group-id="8614901117-1">)</span><span class="w"> </span><span class="p" data-group-id="8614901117-2">{</span><span class="w">
    </span><span class="n">ASSERT</span><span class="p" data-group-id="8614901117-3">(</span><span class="n">Size</span><span class="p">.</span><span class="nf">getValue</span><span class="p" data-group-id="8614901117-4">(</span><span class="p" data-group-id="8614901117-4">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">args</span><span class="p">.</span><span class="nf">size</span><span class="p" data-group-id="8614901117-5">(</span><span class="p" data-group-id="8614901117-5">)</span><span class="p" data-group-id="8614901117-3">)</span><span class="p">;</span><span class="w">
       </span><span class="p">.</span><span class="w">
       </span><span class="p">.</span><span class="w">
       </span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8614901117-2">}</span></code></pre>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="tracing.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Tracing
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.38.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright © 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
