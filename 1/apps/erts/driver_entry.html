<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.38.1">
    <meta name="project" content="erts v16.0">


<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=1&q=">
<meta name="major-vsn" content="1">
<link rel="canonical" href="https://www.erlang.org/doc/apps/erts/driver_entry.html" />
    <title>driver_entry — erts v16.0</title>

    <link rel="stylesheet" href="dist/html-erlang-ZK43ZOAC.css" />

    <script defer src="dist/sidebar_items-40F65B05.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-DPJLHKSM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="erts" />
        </a>

      <div>
        <a href="../../index.html" class="sidebar-projectName" translate="no">
erts
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v16.0
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of erts</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>driver_entry</h1>


      <a href="https://github.com/erlang/otp/blob/master/erts/doc/references/driver_entry.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<p>The driver-entry structure used by Erlang drivers.</p><h2 id="description" class="section-heading"><a href="#description" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Description</span></h2><section role="note" class="admonition warning"><h4 class="admonition-title warning" id="WARNING">Warning</h4><p><em>Use this functionality with extreme care.</em></p><p>A driver callback is executed as a direct extension of the native code of the
VM. Execution is not made in a safe environment. The VM <em>cannot</em> provide the
same services as provided when executing Erlang code, such as pre-emptive
scheduling or memory protection. If the driver callback function does not
behave well, the whole VM will misbehave.</p><ul><li>A driver callback that crash will crash the whole VM.</li><li>An erroneously implemented driver callback can cause a VM internal state
inconsistency, which can cause a crash of the VM, or miscellaneous
misbehaviors of the VM at any point after the call to the driver callback.</li><li>A driver callback doing <a href="erl_driver.html#lengthy_work">lengthy work</a> before
returning degrades responsiveness of the VM, and can cause miscellaneous
strange behaviors. Such strange behaviors include, but are not limited to,
extreme memory usage, and bad load balancing between schedulers. Strange
behaviors that can occur because of lengthy work can also vary between
Erlang/OTP releases.</li></ul></section><p>As from ERTS 5.9 (Erlang/OTP R15B) the driver interface has been changed with
larger types for the callbacks <a href="driver_entry.html#output"><code class="inline">output</code></a>,
<a href="driver_entry.html#control"><code class="inline">control</code></a>, and <a href="driver_entry.html#call"><code class="inline">call</code></a>. See
driver <a href="erl_driver.html#version_management">version management</a> in
<a href="erl_driver.html"><code class="inline">erl_driver</code></a>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Old drivers (compiled with an <code class="inline">erl_driver.h</code> from an ERTS version earlier than
5.9) must be updated and have to use the extended interface (with
<a href="erl_driver.html#version_management">version management </a>).</p></section><p>The <code class="inline">driver_entry</code> structure is a C struct that all Erlang drivers define. It
contains entry points for the Erlang driver, which are called by the Erlang
emulator when Erlang code accesses the driver.</p><p><a href="" id="emulator"></a> The <a href="erl_driver.html"><code class="inline">erl_driver</code></a> driver API functions need a
port handle that identifies the driver instance (and the port in the emulator).
This is only passed to the <code class="inline">start</code> function, but not to the other functions. The
<code class="inline">start</code> function returns a driver-defined handle that is passed to the other
functions. A common practice is to have the <code class="inline">start</code> function allocate some
application-defined structure and stash the <code class="inline">port</code> handle in it, to use it later
with the driver API functions.</p><p>The driver callback functions are called synchronously from the Erlang emulator.
If they take too long before completing, they can cause time-outs in the
emulator. Use the queue or asynchronous calls if necessary, as the emulator must
be responsive.</p><p>The driver structure contains the driver name and some 15 function pointers,
which are called at different times by the emulator.</p><p id="DRIVER_INIT">The only exported function from the driver is <code class="inline">driver_init</code>. This function
returns the <code class="inline">driver_entry</code> structure that points to the other functions in the
driver. The <code class="inline">driver_init</code> function is declared with a macro,
<code class="inline">DRIVER_INIT(drivername)</code>. (This is because different operating systems have
different names for it.)</p><p>When writing a driver in C++, the driver entry is to be of <code class="inline">&quot;C&quot;</code> linkage. One
way to do this is to put the following line somewhere before the driver entry:</p><pre><code class="text">extern &quot;C&quot; DRIVER_INIT(drivername);</code></pre><p>When the driver has passed the <code class="inline">driver_entry</code> over to the emulator, the driver
is <em>not</em> allowed to modify the <code class="inline">driver_entry</code>.</p><p>If compiling a driver for static inclusion through <code class="inline">--enable-static-drivers</code>,
you must define <code class="inline">STATIC_ERLANG_DRIVER</code> before the <code class="inline">DRIVER_INIT</code> declaration.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Do <em>not</em> declare the <code class="inline">driver_entry</code> <code class="inline">const</code>. This because the emulator must
modify the <code class="inline">handle</code> and the <code class="inline">handle2</code> fields. A statically allocated, and
<code class="inline">const</code>-declared <code class="inline">driver_entry</code> can be located in read-only memory, which
causes the emulator to crash.</p></section><h2 id="data-types" class="section-heading"><a href="#data-types" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Data Types</span></h2><p><code class="inline">ErlDrvEntry</code></p><pre><code class="makeup c" translate="no"><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">erl_drv_entry</span><span class="w"> </span><span class="p" data-group-id="5850911926-1">{</span><span class="w">
    </span><span class="kt">int</span><span class="w"> </span><span class="p" data-group-id="5850911926-2">(</span><span class="o">*</span><span class="n">init</span><span class="p" data-group-id="5850911926-2">)</span><span class="p" data-group-id="5850911926-3">(</span><span class="kc">void</span><span class="p" data-group-id="5850911926-3">)</span><span class="p">;</span><span class="w">          </span><span class="cm">/* Called at system startup for statically
                                   linked drivers, and after loading for
                                   dynamically loaded drivers */</span><span class="w">
</span><span class="kp">#ifndef</span><span class="w"> </span><span class="no">ERL_SYS_DRV</span><span class="w">
    </span><span class="no">ErlDrvData</span><span class="w"> </span><span class="p" data-group-id="5850911926-4">(</span><span class="o">*</span><span class="n">start</span><span class="p" data-group-id="5850911926-4">)</span><span class="p" data-group-id="5850911926-5">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">command</span><span class="p" data-group-id="5850911926-5">)</span><span class="p">;</span><span class="w">
                                </span><span class="cm">/* Called when open_port/2 is invoked,
                                   return value -1 means failure */</span><span class="w">
</span><span class="kp">#else</span><span class="w">
    </span><span class="no">ErlDrvData</span><span class="w"> </span><span class="p" data-group-id="5850911926-6">(</span><span class="o">*</span><span class="n">start</span><span class="p" data-group-id="5850911926-6">)</span><span class="p" data-group-id="5850911926-7">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="no">SysDriverOpts</span><span class="o">*</span><span class="w"> </span><span class="n">opts</span><span class="p" data-group-id="5850911926-7">)</span><span class="p">;</span><span class="w">
                                </span><span class="cm">/* Special options, only for system driver */</span><span class="w">
</span><span class="kp">#endif</span><span class="w">
    </span><span class="kc">void</span><span class="w"> </span><span class="p" data-group-id="5850911926-8">(</span><span class="o">*</span><span class="n">stop</span><span class="p" data-group-id="5850911926-8">)</span><span class="p" data-group-id="5850911926-9">(</span><span class="no">ErlDrvData</span><span class="w"> </span><span class="n">drv_data</span><span class="p" data-group-id="5850911926-9">)</span><span class="p">;</span><span class="w">
                                </span><span class="cm">/* Called when port is closed, and when the
                                   emulator is halted */</span><span class="w">
    </span><span class="kc">void</span><span class="w"> </span><span class="p" data-group-id="5850911926-10">(</span><span class="o">*</span><span class="n">output</span><span class="p" data-group-id="5850911926-10">)</span><span class="p" data-group-id="5850911926-11">(</span><span class="no">ErlDrvData</span><span class="w"> </span><span class="n">drv_data</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="5850911926-11">)</span><span class="p">;</span><span class="w">
                                </span><span class="cm">/* Called when we have output from Erlang to
                                   the port */</span><span class="w">
    </span><span class="kc">void</span><span class="w"> </span><span class="p" data-group-id="5850911926-12">(</span><span class="o">*</span><span class="n">ready_input</span><span class="p" data-group-id="5850911926-12">)</span><span class="p" data-group-id="5850911926-13">(</span><span class="no">ErlDrvData</span><span class="w"> </span><span class="n">drv_data</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvEvent</span><span class="w"> </span><span class="n">event</span><span class="p" data-group-id="5850911926-13">)</span><span class="p">;</span><span class="w">
                                </span><span class="cm">/* Called when we have input from one of
                                   the driver&#39;s handles */</span><span class="w">
    </span><span class="kc">void</span><span class="w"> </span><span class="p" data-group-id="5850911926-14">(</span><span class="o">*</span><span class="n">ready_output</span><span class="p" data-group-id="5850911926-14">)</span><span class="p" data-group-id="5850911926-15">(</span><span class="no">ErlDrvData</span><span class="w"> </span><span class="n">drv_data</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvEvent</span><span class="w"> </span><span class="n">event</span><span class="p" data-group-id="5850911926-15">)</span><span class="p">;</span><span class="w">
                                </span><span class="cm">/* Called when output is possible to one of
                                   the driver&#39;s handles */</span><span class="w">
    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">driver_name</span><span class="p">;</span><span class="w">          </span><span class="cm">/* Name supplied as command in
                                   erlang:open_port/2 */</span><span class="w">
    </span><span class="kc">void</span><span class="w"> </span><span class="p" data-group-id="5850911926-16">(</span><span class="o">*</span><span class="n">finish</span><span class="p" data-group-id="5850911926-16">)</span><span class="p" data-group-id="5850911926-17">(</span><span class="kc">void</span><span class="p" data-group-id="5850911926-17">)</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Called before unloading the driver -
                                   dynamic drivers only */</span><span class="w">
    </span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="n">handle</span><span class="p">;</span><span class="w">               </span><span class="cm">/* Reserved, used by emulator internally */</span><span class="w">
    </span><span class="no">ErlDrvSSizeT</span><span class="w"> </span><span class="p" data-group-id="5850911926-18">(</span><span class="o">*</span><span class="n">control</span><span class="p" data-group-id="5850911926-18">)</span><span class="p" data-group-id="5850911926-19">(</span><span class="no">ErlDrvData</span><span class="w"> </span><span class="n">drv_data</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">command</span><span class="p">,</span><span class="w">
                            </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w">
</span><span class="err">	</span><span class="err">	</span><span class="err">	</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="o">*</span><span class="n">rbuf</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">rlen</span><span class="p" data-group-id="5850911926-19">)</span><span class="p">;</span><span class="w">
                                </span><span class="cm">/* &quot;ioctl&quot; for drivers - invoked by
                                   port_control/3 */</span><span class="w">
    </span><span class="kc">void</span><span class="w"> </span><span class="p" data-group-id="5850911926-20">(</span><span class="o">*</span><span class="n">timeout</span><span class="p" data-group-id="5850911926-20">)</span><span class="p" data-group-id="5850911926-21">(</span><span class="no">ErlDrvData</span><span class="w"> </span><span class="n">drv_data</span><span class="p" data-group-id="5850911926-21">)</span><span class="p">;</span><span class="w">
                                </span><span class="cm">/* Handling of time-out in driver */</span><span class="w">
    </span><span class="kc">void</span><span class="w"> </span><span class="p" data-group-id="5850911926-22">(</span><span class="o">*</span><span class="n">outputv</span><span class="p" data-group-id="5850911926-22">)</span><span class="p" data-group-id="5850911926-23">(</span><span class="no">ErlDrvData</span><span class="w"> </span><span class="n">drv_data</span><span class="p">,</span><span class="w"> </span><span class="no">ErlIOVec</span><span class="w"> </span><span class="o">*</span><span class="n">ev</span><span class="p" data-group-id="5850911926-23">)</span><span class="p">;</span><span class="w">
                                </span><span class="cm">/* Called when we have output from Erlang
                                   to the port */</span><span class="w">
    </span><span class="kc">void</span><span class="w"> </span><span class="p" data-group-id="5850911926-24">(</span><span class="o">*</span><span class="n">ready_async</span><span class="p" data-group-id="5850911926-24">)</span><span class="p" data-group-id="5850911926-25">(</span><span class="no">ErlDrvData</span><span class="w"> </span><span class="n">drv_data</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvThreadData</span><span class="w"> </span><span class="n">thread_data</span><span class="p" data-group-id="5850911926-25">)</span><span class="p">;</span><span class="w">
    </span><span class="kc">void</span><span class="w"> </span><span class="p" data-group-id="5850911926-26">(</span><span class="o">*</span><span class="n">flush</span><span class="p" data-group-id="5850911926-26">)</span><span class="p" data-group-id="5850911926-27">(</span><span class="no">ErlDrvData</span><span class="w"> </span><span class="n">drv_data</span><span class="p" data-group-id="5850911926-27">)</span><span class="p">;</span><span class="w">
                                </span><span class="cm">/* Called when the port is about to be
                                   closed, and there is data in the
                                   driver queue that must be flushed
                                   before &#39;stop&#39; can be called */</span><span class="w">
    </span><span class="no">ErlDrvSSizeT</span><span class="w"> </span><span class="p" data-group-id="5850911926-28">(</span><span class="o">*</span><span class="n">call</span><span class="p" data-group-id="5850911926-28">)</span><span class="p" data-group-id="5850911926-29">(</span><span class="no">ErlDrvData</span><span class="w"> </span><span class="n">drv_data</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">command</span><span class="p">,</span><span class="w">
                         </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w">
</span><span class="err">	</span><span class="err">	</span><span class="err">	</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="o">*</span><span class="n">rbuf</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">rlen</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">flags</span><span class="p" data-group-id="5850911926-29">)</span><span class="p">;</span><span class="w">
                                </span><span class="cm">/* Works mostly like &#39;control&#39;, a synchronous
                                   call into the driver */</span><span class="w">
    </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">unused_event_callback</span><span class="p">;</span><span class="w">
    </span><span class="kt">int</span><span class="w"> </span><span class="n">extended_marker</span><span class="p">;</span><span class="w">        </span><span class="cm">/* ERL_DRV_EXTENDED_MARKER */</span><span class="w">
    </span><span class="kt">int</span><span class="w"> </span><span class="n">major_version</span><span class="p">;</span><span class="w">          </span><span class="cm">/* ERL_DRV_EXTENDED_MAJOR_VERSION */</span><span class="w">
    </span><span class="kt">int</span><span class="w"> </span><span class="n">minor_version</span><span class="p">;</span><span class="w">          </span><span class="cm">/* ERL_DRV_EXTENDED_MINOR_VERSION */</span><span class="w">
    </span><span class="kt">int</span><span class="w"> </span><span class="n">driver_flags</span><span class="p">;</span><span class="w">           </span><span class="cm">/* ERL_DRV_FLAGs */</span><span class="w">
    </span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="n">handle2</span><span class="p">;</span><span class="w">              </span><span class="cm">/* Reserved, used by emulator internally */</span><span class="w">
    </span><span class="kc">void</span><span class="w"> </span><span class="p" data-group-id="5850911926-30">(</span><span class="o">*</span><span class="n">process_exit</span><span class="p" data-group-id="5850911926-30">)</span><span class="p" data-group-id="5850911926-31">(</span><span class="no">ErlDrvData</span><span class="w"> </span><span class="n">drv_data</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvMonitor</span><span class="w"> </span><span class="o">*</span><span class="n">monitor</span><span class="p" data-group-id="5850911926-31">)</span><span class="p">;</span><span class="w">
                                </span><span class="cm">/* Called when a process monitor fires */</span><span class="w">
    </span><span class="kc">void</span><span class="w"> </span><span class="p" data-group-id="5850911926-32">(</span><span class="o">*</span><span class="n">stop_select</span><span class="p" data-group-id="5850911926-32">)</span><span class="p" data-group-id="5850911926-33">(</span><span class="no">ErlDrvEvent</span><span class="w"> </span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">reserved</span><span class="p" data-group-id="5850911926-33">)</span><span class="p">;</span><span class="w">
                                </span><span class="cm">/* Called to close an event object */</span><span class="w">
 </span><span class="p" data-group-id="5850911926-1">}</span><span class="w"> </span><span class="no">ErlDrvEntry</span><span class="p">;</span></code></pre><ul><li><p><strong><code class="inline" id="init">int (*init)(void)</code></strong> - Called directly after the driver has been
loaded by <a href="../../apps/kernel/erl_ddll.html#load_driver/2"><code class="inline">erl_ddll:load_driver/2</code></a> (actually when the driver is added to the
driver list). The driver is to return <code class="inline">0</code>, or, if the driver cannot
initialize, <code class="inline">-1</code>.</p></li><li><p><strong><code class="inline" id="start">ErlDrvData (*start)(ErlDrvPort port, char* command)</code></strong> - Called
when the driver is instantiated, when <a href="erlang.html#open_port/2"><code class="inline">erlang:open_port/2</code></a> is called. The
driver is to return a number &gt;= 0 or a pointer, or, if the driver cannot be
started, one of three error codes:</p><ul><li><p><strong><code class="inline">ERL_DRV_ERROR_GENERAL</code></strong> - General error, no error code</p></li><li><p><strong><code class="inline">ERL_DRV_ERROR_ERRNO</code></strong> - Error with error code in <code class="inline">errno</code></p></li><li><p><strong><code class="inline">ERL_DRV_ERROR_BADARG</code></strong> - Error, <code class="inline">badarg</code></p></li></ul><p>If an error code is returned, the port is not started.</p></li><li><p><strong><code class="inline" id="stop">void (*stop)(ErlDrvData drv_data)</code></strong> - Called when the port is
closed, with <a href="erlang.html#port_close/1"><code class="inline">erlang:port_close/1</code></a> or <code class="inline">Port ! {self(), close}</code>. Notice that
terminating the port owner process also closes the port. If <code class="inline">drv_data</code> is a
pointer to memory allocated in <code class="inline">start</code>, then <code class="inline">stop</code> is the place to deallocate
that memory.</p></li><li><p><strong><code class="inline" id="output">void (*output)(ErlDrvData drv_data, char *buf, ErlDrvSizeT len)</code></strong> -
Called when an Erlang process has sent data to the port. The data is
pointed to by <code class="inline">buf</code>, and is <code class="inline">len</code> bytes. Data is sent to the port with
<code class="inline">Port ! {self(), {command, Data}}</code> or with <a href="erlang.html#port_command/2"><code class="inline">erlang:port_command/2</code></a>. Depending
on how the port was opened, it is to be either a list of integers <code class="inline">0...255</code> or
a binary. See <a href="erlang.html#open_port/2"><code class="inline">erlang:open_port/2</code></a> and <a href="erlang.html#port_command/2"><code class="inline">erlang:port_command/2</code></a>.</p></li><li><p><strong><code class="inline" id="ready_input">void (*ready_input)(ErlDrvData drv_data, ErlDrvEvent event)</code></strong></p></li><li><p><strong><code class="inline" id="ready_output">void (*ready_output)(ErlDrvData drv_data, ErlDrvEvent event)</code></strong> -
Called when a driver event (specified in parameter <code class="inline">event</code>) is signaled. This is used
to help asynchronous drivers &quot;wake up&quot; when something occurs.</p><p>On Unix the <code class="inline">event</code> is a pipe or socket handle (or something that the <code class="inline">select</code>
system call understands).</p><p>On Windows the <code class="inline">event</code> is an <code class="inline">Event</code> or <code class="inline">Semaphore</code> (or something that the
<code class="inline">WaitForMultipleObjects</code> API function understands). (Some trickery in the
emulator allows more than the built-in limit of 64 <code class="inline">Events</code> to be used.)</p><p>To use this with threads and asynchronous routines, create a pipe on Unix and
an <code class="inline">Event</code> on Windows. When the routine completes, write to the pipe (use
<code class="inline">SetEvent</code> on Windows), this makes the emulator call <code class="inline">ready_input</code> or
<code class="inline">ready_output</code>.</p><p>False events can occur. That is, calls to <code class="inline">ready_input</code> or <code class="inline">ready_output</code>
although no real events are signaled. In reality, it is rare (and
OS-dependant), but a robust driver must nevertheless be able to handle such
cases.</p></li><li><p><strong><code class="inline" id="driver_name">char *driver_name</code></strong> - The driver name. It must correspond
to the atom used in <a href="erlang.html#open_port/2"><code class="inline">erlang:open_port/2</code></a>, and the name of the driver library
file (without the extension).</p></li><li><p><strong><code class="inline" id="finish">void (*finish)(void)</code></strong> - Called by the <code class="inline">erl_ddll</code> driver when
the driver is unloaded. (It is only called in dynamic drivers.)</p><p>The driver is only unloaded as a result of calling <a href="../../apps/kernel/erl_ddll.html#unload_driver/1"><code class="inline">erl_ddll:unload_driver/1</code></a>,
or when the emulator halts.</p></li><li><p><strong><code class="inline">void *handle</code></strong> - This field is reserved for the emulator's internal use.
The emulator will modify this field, so it is important that the
<code class="inline">driver_entry</code> is not declared <code class="inline">const</code>.</p></li><li><p><strong id="control"><code class="inline">ErlDrvSSizeT (*control)(ErlDrvData drv_data, unsigned int command, char *buf, ErlDrvSizeT len, char **rbuf, ErlDrvSizeT rlen)</code></strong> -
A special routine invoked with <a href="erlang.html#port_control/3"><code class="inline">erlang:port_control/3</code></a>. It
works a little like an &quot;ioctl&quot; for Erlang drivers. The data specified to
<a href="erlang.html#port_control/3"><code class="inline">port_control/3</code></a> arrives in <code class="inline">buf</code> and <code class="inline">len</code>. The driver
can send data back, using <code class="inline">*rbuf</code> and <code class="inline">rlen</code>.</p><p>This is the fastest way of calling a driver and get a response. It makes no
context switch in the Erlang emulator and requires no message passing. It is
suitable for calling C function to get faster execution, when Erlang is too
slow.</p><p>If the driver wants to return data, it is to return it in <code class="inline">rbuf</code>. When
<code class="inline">control</code> is called, <code class="inline">*rbuf</code> points to a default buffer of <code class="inline">rlen</code> bytes, which
can be used to return data. Data is returned differently depending on the port
control flags (those that are set with
<a href="erl_driver.html#set_port_control_flags"><code class="inline">erl_driver:set_port_control_flags</code></a>).</p><p>If the flag is set to <code class="inline">PORT_CONTROL_FLAG_BINARY</code>, a binary is returned. Small
binaries can be returned by writing the raw data into the default buffer. A
binary can also be returned by setting <code class="inline">*rbuf</code> to point to a binary allocated
with <a href="erl_driver.html#driver_alloc_binary"><code class="inline">erl_driver:driver_alloc_binary</code></a>.
This binary is freed automatically after <code class="inline">control</code> has returned. The driver
can retain the binary for <em>read only</em> access with
<a href="erl_driver.html#driver_binary_inc_refc"><code class="inline">erl_driver:driver_binary_inc_refc</code></a> to
be freed later with
<a href="erl_driver.html#driver_free_binary"><code class="inline">erl_driver:driver_free_binary</code></a>. It is
never allowed to change the binary after <code class="inline">control</code> has returned. If <code class="inline">*rbuf</code> is
set to <code class="inline">NULL</code>, an empty list is returned.</p><p>If the flag is set to <code class="inline">0</code>, data is returned as a list of integers. Either use
the default buffer or set <code class="inline">*rbuf</code> to point to a larger buffer allocated with
<a href="erl_driver.html#driver_alloc"><code class="inline">erl_driver:driver_alloc</code></a>. The buffer is freed
automatically after <code class="inline">control</code> has returned.</p><p>Using binaries is faster if more than a few bytes are returned.</p><p>The return value is the number of bytes returned in <code class="inline">*rbuf</code>.</p></li><li><p><strong><code class="inline" id="timeout">void (*timeout)(ErlDrvData drv_data)</code></strong> - Called any time
after the driver's timer reaches <code class="inline">0</code>. The timer is activated with
<a href="erl_driver.html#driver_set_timer"><code class="inline">erl_driver:driver_set_timer</code></a>. No priorities
or ordering exist among drivers, so if several drivers time out at the same
time, anyone of them is called first.</p></li><li><p><strong><code class="inline" id="outputv">void (*outputv)(ErlDrvData drv_data, ErlIOVec *ev)</code></strong> - Called
whenever the port is written to. If it is <code class="inline">NULL</code>, the <code class="inline">output</code> function is
called instead. This function is faster than <code class="inline">output</code>, as it takes an
<code class="inline">ErlIOVec</code> directly, which requires no copying of the data. The port is to be
in binary mode, see <a href="erlang.html#open_port/2"><code class="inline">erlang:open_port/2</code></a>.</p><p><code class="inline">ErlIOVec</code> contains both a <code class="inline">SysIOVec</code>, suitable for <code class="inline">writev</code>, and one or more
binaries. If these binaries are to be retained when the driver returns from
<code class="inline">outputv</code>, they can be queued (using, for example,
<a href="erl_driver.html#driver_enq_bin"><code class="inline">erl_driver:driver_enq_bin</code></a>) or, if they are
kept in a static or global variable, the reference counter can be incremented.</p></li><li><p><strong><code class="inline" id="ready_async">void (*ready_async)(ErlDrvData drv_data, ErlDrvThreadData thread_data)</code></strong> -
Called after an asynchronous call has completed. The asynchronous call is started with
<a href="erl_driver.html#driver_async"><code class="inline">erl_driver:driver_async</code></a>. This function is
called from the Erlang emulator thread, as opposed to the asynchronous
function, which is called in some thread (if multi-threading is enabled).</p></li><li><p><strong><code class="inline">void (*flush)(ErlDrvData drv_data)</code></strong> - Called when the port is about to be
closed, and there is data in the driver queue that must be flushed before
'stop' can be called.</p></li><li><p><strong id="call"><code class="inline">ErlDrvSSizeT (*call)(ErlDrvData drv_data, unsigned int command, char *buf, ErlDrvSizeT len, char **rbuf, ErlDrvSizeT rlen, unsigned int *flags)</code></strong> -
Called from <a href="erlang.html#port_call/3"><code class="inline">erlang:port_call/3</code></a>. It works a lot like the
<code class="inline">control</code> callback, but uses the external term format for input and output.</p><p><code class="inline">command</code> is an integer, obtained from the call from Erlang (the second
argument to <a href="erlang.html#port_call/3"><code class="inline">erlang:port_call/3</code></a>).</p><p><code class="inline">buf</code> and <code class="inline">len</code> provide the arguments to the call (the third argument to
<a href="erlang.html#port_call/3"><code class="inline">erlang:port_call/3</code></a>). They can be decoded using <code class="inline">ei</code> functions.</p><p><code class="inline">rbuf</code> points to a return buffer, <code class="inline">rlen</code> bytes long. The return data is to be
a valid Erlang term in the external (binary) format. This is converted to an
Erlang term and returned by <a href="erlang.html#port_call/3"><code class="inline">erlang:port_call/3</code></a> to the caller. If more space
than <code class="inline">rlen</code> bytes is needed to return data, <code class="inline">*rbuf</code> can be set to memory
allocated with <a href="erl_driver.html#driver_alloc"><code class="inline">erl_driver:driver_alloc</code></a>. This
memory is freed automatically after <code class="inline">call</code> has returned.</p><p>The return value is the number of bytes returned in <code class="inline">*rbuf</code>. If
<code class="inline">ERL_DRV_ERROR_GENERAL</code> is returned (or in fact, anything &lt; 0),
<a href="erlang.html#port_call/3"><code class="inline">erlang:port_call/3</code></a> throws a <code class="inline">BAD_ARG</code>.</p></li><li><p><strong><code class="inline">void (*event)(ErlDrvData drv_data, ErlDrvEvent event, ErlDrvEventData event_data)</code></strong> -
Intentionally left undocumented.</p></li><li><p><strong><code class="inline" id="extended_marker">int extended_marker</code></strong> - This field is either to be
equal to <code class="inline">ERL_DRV_EXTENDED_MARKER</code> or <code class="inline">0</code>. An old driver (not aware of the
extended driver interface) is to set this field to <code class="inline">0</code>. If this field is <code class="inline">0</code>,
all the following fields <em>must</em> also be <code class="inline">0</code>, or <code class="inline">NULL</code> if it is a pointer
field.</p></li><li><p><strong><code class="inline">int major_version</code></strong> - This field is to equal
<code class="inline">ERL_DRV_EXTENDED_MAJOR_VERSION</code> if field <code class="inline">extended_marker</code> equals
<code class="inline">ERL_DRV_EXTENDED_MARKER</code>.</p></li><li><p><strong><code class="inline">int minor_version</code></strong> - This field is to equal
<code class="inline">ERL_DRV_EXTENDED_MINOR_VERSION</code> if field <code class="inline">extended_marker</code> equals
<code class="inline">ERL_DRV_EXTENDED_MARKER</code>.</p></li><li><p><strong><code class="inline" id="driver_flags">int driver_flags</code></strong> - This field is used to pass driver
capability and other information to the runtime system. If field
<code class="inline">extended_marker</code> equals <code class="inline">ERL_DRV_EXTENDED_MARKER</code>, it is to contain <code class="inline">0</code> or
driver flags (<code class="inline">ERL_DRV_FLAG_*</code>) OR'ed bitwise. The following driver flags
exist:</p><ul><li><p><strong><code class="inline">ERL_DRV_FLAG_USE_PORT_LOCKING</code></strong> - The runtime system uses port-level
locking on all ports executing this driver instead of driver-level locking.
For more information, see <a href="erl_driver.html#smp_support"><code class="inline">erl_driver</code></a>.</p></li><li><p><strong><code class="inline">ERL_DRV_FLAG_SOFT_BUSY</code></strong> - Marks that driver instances can handle being
called in the <a href="driver_entry.html#output"><code class="inline">output</code></a> and/or
<a href="driver_entry.html#outputv"><code class="inline">outputv</code></a> callbacks although a driver instance
has marked itself as busy (see
<a href="erl_driver.html#set_busy_port"><code class="inline">erl_driver:set_busy_port</code></a>). As from ERTS
5.7.4 this flag is required for drivers used by the Erlang distribution (the
behavior has always been required by drivers used by the distribution).</p></li><li><p><strong><code class="inline">ERL_DRV_FLAG_NO_BUSY_MSGQ</code></strong> - Disables busy port message queue
functionality. For more information, see
<a href="erl_driver.html#erl_drv_busy_msgq_limits"><code class="inline">erl_driver:erl_drv_busy_msgq_limits</code></a>.</p></li><li><p><strong><code class="inline">ERL_DRV_FLAG_USE_INIT_ACK</code></strong> - When this flag is specified, the linked-in
driver must manually acknowledge that the port has been successfully started
using <a href="erl_driver.html#erl_drv_init_ack"><code class="inline">erl_driver:erl_drv_init_ack()</code></a>.
This allows the implementor to make the <code class="inline">erlang:open_port</code> exit with
<code class="inline">badarg</code> after some initial asynchronous initialization has been done.</p></li></ul></li><li><p><strong><code class="inline">void *handle2</code></strong> - This field is reserved for the emulator's internal use.
The emulator modifies this field, so it is important that the <code class="inline">driver_entry</code>
is not declared <code class="inline">const</code>.</p></li><li><p><strong><code class="inline" id="process_exit">void (*process_exit)(ErlDrvData drv_data, ErlDrvMonitor *monitor)</code></strong> -
Called when a monitored process exits. The <code class="inline">drv_data</code> is
the data associated with the port for which the process is monitored (using
<a href="erl_driver.html#driver_monitor_process"><code class="inline">erl_driver:driver_monitor_process</code></a>)
and the <code class="inline">monitor</code> corresponds to the <code class="inline">ErlDrvMonitor</code> structure filled in when
creating the monitor. The driver interface function
<a href="erl_driver.html#driver_get_monitored_process"><code class="inline">erl_driver:driver_get_monitored_process</code></a>
can be used to retrieve the process ID of the exiting process as an
<code class="inline">ErlDrvTermData</code>.</p></li><li><p><strong><code class="inline" id="stop_select">void (*stop_select)(ErlDrvEvent event, void* reserved)</code></strong> -
Called on behalf of
<a href="erl_driver.html#driver_select"><code class="inline">erl_driver:driver_select</code></a> when it is safe to
close an event object.</p><p>A typical implementation on Unix is to do <code class="inline">close((int)event)</code>.</p><p>Argument <code class="inline">reserved</code> is intended for future use and is to be ignored.</p><p>In contrast to most of the other callback functions, <code class="inline">stop_select</code> is called
independent of any port. No <code class="inline">ErlDrvData</code> argument is passed to the function.
No driver lock or port lock is guaranteed to be held. The port that called
<code class="inline">driver_select</code> can even be closed at the time <code class="inline">stop_select</code> is called. But it
can also be the case that <code class="inline">stop_select</code> is called directly by
<code class="inline">erl_driver:driver_select</code>.</p><p>It is not allowed to call any functions in the <a href="erl_driver.html">driver API</a>
from <code class="inline">stop_select</code>. This strict limitation is because the volatile context
that <code class="inline">stop_select</code> can be called.</p></li></ul><h2 id="see-also" class="section-heading"><a href="#see-also" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">See Also</span></h2><p><a href="erl_driver.html"><code class="inline">erl_driver(3)</code></a>, <a href="erlang.html"><code class="inline">erlang</code></a>, <a href="../../apps/kernel/erl_ddll.html"><code class="inline">erl_ddll</code></a></p>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="werl_cmd.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
werl
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="erl_driver.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
erl_driver
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.38.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright © 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
