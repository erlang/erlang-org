<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Erlang Garbage Collector</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="leftnav-tube">
<div class="erlang-logo-wrapper"><a href="../../index.html"><img alt="Erlang Logo" src="../../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Erlang Run-Time System Application (ERTS)</p>
<p class="section-subtitle">Internal Documentation</p>
<p class="section-version">Version 11.2.2.18</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="index.html">Reference Manual</a></li>
<li><a href="internal_docs.html">Internal Documentation</a></li>
<li><a href="release_notes.html">Release Notes</a></li>
<li><a href="erts.pdf">PDF</a></li>
<li><a href="../../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Carrier Migration" expanded="false">Carrier Migration<ul>
<li><a href="CarrierMigration.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="CarrierMigration.html#introduction">Introduction</a></li>
<li title="Problem"><a href="CarrierMigration.html#problem">Problem</a></li>
<li title="Solution"><a href="CarrierMigration.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Thread Progress" expanded="false">Thread Progress<ul>
<li><a href="ThreadProgress.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="ThreadProgress.html#problems">Problems</a></li>
<li title="Functionality Used to Address These Problems"><a href="ThreadProgress.html#functionality-used-to-address-these-problems">Functionality Used to Address These Problems</a></li>
<li title="Implementation of the Thread Progress Functionality"><a href="ThreadProgress.html#implementation-of-the-thread-progress-functionality">Implementation of the Thread Progress Functionality</a></li>
</ul>
</li>
<li id="no" title="Non-Blocking Code Loading" expanded="false">Non-Blocking Code Loading<ul>
<li><a href="CodeLoading.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="CodeLoading.html#introduction">Introduction</a></li>
<li title="The Load Phases"><a href="CodeLoading.html#the-load-phases">The Load Phases</a></li>
<li title="The Finishing Sequence"><a href="CodeLoading.html#the-finishing-sequence">The Finishing Sequence</a></li>
</ul>
</li>
<li id="no" title="Non-blocking trace setting" expanded="false">Non-blocking trace setting<ul>
<li><a href="Tracing.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="Tracing.html#introduction">Introduction</a></li>
<li title="Redesign of Breakpoint Wheel"><a href="Tracing.html#redesign-of-breakpoint-wheel">Redesign of Breakpoint Wheel</a></li>
<li title="Same Same but Different"><a href="Tracing.html#same-same-but-different">Same Same but Different</a></li>
<li title="Adding a new Breakpoint"><a href="Tracing.html#adding-a-new-breakpoint">Adding a new Breakpoint</a></li>
<li title="To Updating and Remove Breakpoints"><a href="Tracing.html#to-updating-and-remove-breakpoints">To Updating and Remove Breakpoints</a></li>
<li title="Global Tracing"><a href="Tracing.html#global-tracing">Global Tracing</a></li>
<li title="Future work"><a href="Tracing.html#future-work">Future work</a></li>
</ul>
</li>
<li id="no" title="Delayed Dealloc" expanded="false">Delayed Dealloc<ul>
<li><a href="DelayedDealloc.html">
              Top of chapter
            </a></li>
<li title="Problem"><a href="DelayedDealloc.html#problem">Problem</a></li>
<li title="Functionality Used to Address This problem"><a href="DelayedDealloc.html#functionality-used-to-address-this-problem">Functionality Used to Address This problem</a></li>
</ul>
</li>
<li id="no" title="The beam_makeops script" expanded="false">The beam_makeops script<ul>
<li><a href="beam_makeops.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="beam_makeops.html#introduction">Introduction</a></li>
<li title="An example: the move instruction"><a href="beam_makeops.html#an-example--the-move-instruction">An example: the move instruction</a></li>
<li title="Short overview of instruction loading"><a href="beam_makeops.html#short-overview-of-instruction-loading">Short overview of instruction loading</a></li>
<li title="Running beam_makeops"><a href="beam_makeops.html#running-beam_makeops">Running beam_makeops</a></li>
<li title="Syntax of .tab files"><a href="beam_makeops.html#syntax-of-.tab-files">Syntax of .tab files</a></li>
</ul>
</li>
<li id="no" title="Counting Instructions" expanded="false">Counting Instructions<ul><li><a href="CountingInstructions.html">
              Top of chapter
            </a></li></ul>
</li>
<li id="loadscrollpos" title="Erlang Garbage Collector" expanded="true">Erlang Garbage Collector<ul>
<li><a href="GarbageCollection.html">
              Top of chapter
            </a></li>
<li title="Overview"><a href="GarbageCollection.html#overview">Overview</a></li>
<li title="Generational Garbage Collection"><a href="GarbageCollection.html#generational-garbage-collection">Generational Garbage Collection</a></li>
<li title="The young heap"><a href="GarbageCollection.html#the-young-heap">The young heap</a></li>
<li title="Sizing the heap"><a href="GarbageCollection.html#sizing-the-heap">Sizing the heap</a></li>
<li title="Literals"><a href="GarbageCollection.html#literals">Literals</a></li>
<li title="Binary heap"><a href="GarbageCollection.html#binary-heap">Binary heap</a></li>
<li title="Messages"><a href="GarbageCollection.html#messages">Messages</a></li>
<li title="References"><a href="GarbageCollection.html#references">References</a></li>
</ul>
</li>
<li id="no" title="Process and Port Tables" expanded="false">Process and Port Tables<ul>
<li><a href="PTables.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="PTables.html#problems">Problems</a></li>
<li title="Solution"><a href="PTables.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Port Signals" expanded="false">Port Signals<ul>
<li><a href="PortSignals.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="PortSignals.html#problems">Problems</a></li>
<li title="Solution"><a href="PortSignals.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Process Management Optimizations" expanded="false">Process Management Optimizations<ul>
<li><a href="ProcessManagementOptimizations.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="ProcessManagementOptimizations.html#problems">Problems</a></li>
<li title="Solution"><a href="ProcessManagementOptimizations.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Super Carrier" expanded="false">Super Carrier<ul>
<li><a href="SuperCarrier.html">
              Top of chapter
            </a></li>
<li title="Problem"><a href="SuperCarrier.html#problem">Problem</a></li>
<li title="Solution"><a href="SuperCarrier.html#solution">Solution</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>8Â Erlang Garbage Collector</h1>


<p>
Erlang manages dynamic memory with a <span class="bold_code bc-20"><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">tracing garbage collector</a></span>. More precisely a per process generational semi-space copying collector using Cheney's copy collection algorithm together with a global large object space. (See C. J. Cheney in <span class="bold_code bc-17"><a href="#References">References</a></span>.)
</p>

<h3>
<a name="Overview"></a><span onMouseOver="document.getElementById('ghlink-overview-idm31333').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-overview-idm31333').style.visibility = 'hidden';"><a class="title_link" name="overview">8.1Â 
          Overview</a><span id="ghlink-overview-idm31333" class="ghlink-after"><a href="#overview" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
Each Erlang process has its own stack and heap which are allocated in the same memory block and grow towards each other. When the stack and the heap <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/beam_emu.c#L387">meet</a></span>, the garbage collector is triggered and memory is reclaimed. If not enough memory was reclaimed, the heap will grow.
</p>

<h4>
<a name="Overview_Creating-Data"></a><span onMouseOver="document.getElementById('ghlink-creating-data-idm31338').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-creating-data-idm31338').style.visibility = 'hidden';"><a class="title_link" name="creating-data">Creating Data</a><span id="ghlink-creating-data-idm31338" class="ghlink-after"><a href="#creating-data" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
Terms are created on the heap by evaluating expressions. There are two major types of terms: <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_term.h#L88-L97">immediate terms</a></span> which require no heap space (small integers, atoms, pids, port ids etc) and cons or <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_term.h#L106-L120">boxed terms</a></span> (tuple, big num, binaries etc) that do require heap space. Immediate terms do not need any heap space because they are embedded into the containing structure.
</p>

<p>
Let's look at an example that returns a tuple with the newly created data.
</p>

<div class="example example-none"><pre>data(Foo) -&gt;
   Cons = [42|Foo],
   Literal = {text, "hello world!"},
   {tag, Cons, Literal}.</pre></div>
<p>
In this example we first create a new cons cell with an integer and a tuple with some text. Then a tuple of size three wrapping the other values with an atom tag is created and returned.
</p>

<p>
On the heap tuples require a word size for each of its elements as well as for the header. Cons cells always require two words. Adding these things together, we get seven words for the tuples and 26 words for the cons cells. The string <span class="code">"hello world!"</span> is a list of cons cells and thus requires 24 words. The atom <span class="code">tag</span> and the integer <span class="code">42</span> do not require any additional heap memory since it is an <strong>immediate</strong>. Adding all the terms together, the heap space required in this example should be 33 words.
</p>

<p>
Compiling this code to beam assembly (<span class="code">erlc -S</span>) shows exactly what is happening.
</p>

<div class="example example-none"><pre>...
{test_heap,6,1}.
{put_list,{integer,42},{x,0},{x,1}}.
{put_tuple,3,{x,0}}.
{put,{atom,tag}}.
{put,{x,1}}.
{put,{literal,{text,"hello world!"}}}.
return.</pre></div>
<p>
Looking at the assembler code we can see three things: The heap requirement in this function turns out to be only six words, as seen by the <span class="code">{test_heap,6,1}</span> instruction. All the allocations are combined to a single instruction. The bulk of the data <span class="code">{text, "hello world!"}</span> is a <strong>literal</strong>. Literals, sometimes referred to as constants, are not allocated in the function since they are a part of the module and allocated at load time.
</p>

<p>
If there is not enough space available on the heap to satisfy the <span class="code">test_heap</span> instructions request for memory, then a garbage collection is initiated. It may happen immediately in the <span class="code">test_heap</span> instruction, or it can be delayed until a later time depending on what state the process is in. If the garbage collection is delayed, any memory needed will be allocated in heap fragments. Heap fragments are extra memory blocks that are a part of the young heap, but are not allocated in the contigious area where terms normally reside. See <span class="bold_code bc-17"><a href="#The-young-heap">The young heap</a></span> for more details.
</p>



<h4>
<a name="Overview_The-collector"></a><span onMouseOver="document.getElementById('ghlink-the-collector-idm31363').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-the-collector-idm31363').style.visibility = 'hidden';"><a class="title_link" name="the-collector">The collector</a><span id="ghlink-the-collector-idm31363" class="ghlink-after"><a href="#the-collector" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
Erlang has a copying semi-space garbage collector. This means that when doing a garbage collection, the terms are copied from one distinct area, called the <strong>from space</strong>, to a new clean area, called the <strong>to space</strong>. The collector starts by <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1980">scanning the root-set</a></span> (stack, registers, etc).
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/gc-start.png" class="doc-image"><p class="doc-image-caption">Figure
        8.1:
        Â 
        </p>
</div>

<p>
It follows all the pointers from the root-set to the heap and copies each term word by word to the <strong>to space</strong>.
</p>

<p>
After the header word has been copied a <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.h#L45-L46">move marker</a></span> is destructively placed in it pointing to the term in the <strong>to space</strong>. Any other term that points to the already moved term will <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1125">see this move marker</a></span> and copy the referring pointer instead. For example, if the have the following Erlang code:
</p>

<div class="example example-none"><pre>foo(Arg) -&gt;
    T = {test, Arg},
    {wrapper, T, T, T}.</pre></div>
<p>
Only one copy of T exists on the heap and during the garbage collection only the first time T is encountered will it be copied.
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/gc-rootset-scan.png" class="doc-image"><p class="doc-image-caption">Figure
        8.2:
        Â 
        </p>
</div>

<p>
After <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1089">all terms</a></span> referenced by the root-set have been copied, the collector scans the <strong>to space</strong> and copies all terms that these terms reference. When scanning, the collector steps through each term on the <strong>to space</strong> and any term still referencing the <strong>from space</strong> is copied over to the <strong>to space</strong>. Some terms contain non-term data (the payload of a on heap binary for instance). When encountered by the collector, these values are simply skipped.
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/gc-heap-scan1.png" class="doc-image"><p class="doc-image-caption">Figure
        8.3:
        Â 
        </p>
</div>

<p>
Every term object we can reach is copied to the <strong>to space</strong> and stored on top off the <strong>scan stop</strong> line, and then the scan stop is moved to the end of the last object.
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/gc-heap-stop.png" class="doc-image"><p class="doc-image-caption">Figure
        8.4:
        Â 
        </p>
</div>

<p>
When <strong>scan stop</strong> marker <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1103">catches up</a></span> to the <strong>scan start</strong> marker, the garbage collection is done. At this point we can <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1206">deallocate</a></span> the entire <strong>from space</strong> and therefore reclaim the entire young heap.
</p>





<h3>
<a name="Generational-Garbage-Collection"></a><span onMouseOver="document.getElementById('ghlink-generational-garbage-collection-idm31401').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-generational-garbage-collection-idm31401').style.visibility = 'hidden';"><a class="title_link" name="generational-garbage-collection">8.2Â 
          Generational Garbage Collection</a><span id="ghlink-generational-garbage-collection-idm31401" class="ghlink-after"><a href="#generational-garbage-collection" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
In addition to the collection algorithm described above, the Erlang garbage collector also provides generational garbage collection. An additional heap, called the old heap, is used where the long lived data is stored. The original heap is called the young heap, or sometimes the allocation heap.
</p>

<p>
With this in mind we can look at the Erlang's garbage collection again. During the copy stage anything that should be copied to the young <strong>to space</strong> is instead copied to the old <strong>to space</strong> <strong>if</strong> it is <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1127">below the *high-watermark*</a></span>.
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/gc-watermark.png" class="doc-image"><p class="doc-image-caption">Figure
        8.5:
        Â 
        </p>
</div>

<p>
The <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_process.h#L1021">high-watermark</a></span> is placed where the previous garbage collection (described in <span class="bold_code bc-17"><a href="#Overview">Overview</a></span>) ended and we have introduced a new area called the old heap. When doing the normal garbage collection pass, any term that is located below the high-watermark is copied to the old <strong>to space</strong> instead of the young.
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/gc-watermark-2.png" class="doc-image"><p class="doc-image-caption">Figure
        8.6:
        Â 
        </p>
</div>

<p>
In the next garbage collection, any pointers to the old heap will be ignored and not scanned. This way the garbage collector does not have to scan the long-lived terms.
</p>

<p>
Generational garbage collection aims to increase performance at the expense of memory. This is achieved because only the young, smaller, heap is considered in most garbage collections.
</p>

<p>
The generational hypothesis predicts that most terms tend to die young (see D. Ungar in <span class="bold_code bc-17"><a href="#References">References</a></span>), and for an immutable language such as Erlang, young terms die even faster than in other languages. So for most usage patterns the data in the new heap will die very soon after it is allocated. This is good because it limits the amount of data copied to the old heap and also because the garbage collection algorithm used is proportional to the amount of live data on the heap.
</p>

<p>
One critical issue to note here is that any term on the young heap can reference terms on the old heap but <strong>no</strong> term on the old heap may refer to a term on the young heap. This is due to the nature of the copy algorithm. Anything referenced by an old heap term is not included in the reference tree, root-set and its followers, and hence is not copied. If it was, the data would be lost, fire and brimstone would rise to cover the earth. Fortunately, this comes naturally for Erlang because the terms are immutable and thus there can be no pointers modified on the old heap to point to the young heap.
</p>

<p>
To reclaim data from the old heap, both young and old heaps are included during the collection and copied to a common <strong>to space</strong>. Both the <strong>from space</strong> of the young and old heap are then deallocated and the procedure will start over from the beginning. This type of garbage collection is called a full sweep and is triggered when the size of the area under the high-watermark is larger than the size of the free area of the old heap. It can also be triggered by doing a manual call to <span class="bold_code bc-20"><a href="http://erlang.org/doc/man/erlang.html#garbage_collect-0">erlang:garbage_collect()</a></span>, or by running into the young garbage collection limit set by <span class="bold_code bc-20"><a href="http://erlang.org/doc/man/erlang.html#spawn_opt-4">spawn_opt(fun(),[{fullsweep_after, N}])</a></span> where N is the number of young garbage collections to do before forcing a garbage collection of both young and old heap.
</p>



<h3>
<a name="The-young-heap"></a><span onMouseOver="document.getElementById('ghlink-the-young-heap-idm31429').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-the-young-heap-idm31429').style.visibility = 'hidden';"><a class="title_link" name="the-young-heap">8.3Â 
          The young heap</a><span id="ghlink-the-young-heap-idm31429" class="ghlink-after"><a href="#the-young-heap" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
The young heap, or the allocation heap, consists of the stack and heap as described in the Overview. However, it also includes any heap fragments that are attached to the heap. All of the heap fragments are considered to be above the high-watermark and part of the young generation. Heap fragments contain terms that either did not fit on the heap, or were created by another process and then attached to the heap. For instance if the bif <span class="code">binary_to_term/1</span> created a term which does not fit on the current heap without doing a garbage collection, it will create a heap-fragment for the term and then schedule a garbage collection for later. Also if a message is sent to the process, the payload may be placed in a heap-fragment and that fragment is added to young heap when the message is matched in a receive clause.
</p>

<p>
This procedure differs from how it worked prior to Erlang/OTP 19.0. Before 19.0, only a contiguous memory block where the young heap and stack resided was considered to be part of the young heap. Heap fragments and messages were immediately copied into the young heap before they could be inspected by the Erlang program. The behaviour introduced in 19.0 is superior in many ways - most significantly it reduces the number of necessary copy operations and the root set for garbage collection.
</p>



<h3>
<a name="Sizing-the-heap"></a><span onMouseOver="document.getElementById('ghlink-sizing-the-heap-idm31435').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-sizing-the-heap-idm31435').style.visibility = 'hidden';"><a class="title_link" name="sizing-the-heap">8.4Â 
          Sizing the heap</a><span id="ghlink-sizing-the-heap-idm31435" class="ghlink-after"><a href="#sizing-the-heap" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
As mentioned in the Overview the size of the heap <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L247">grows</a></span> to accommodate more data. Heaps grow in two stages, first a <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L199-L208">variation of the Fibonacci sequence</a></span> is used starting at 233 words. Then at about 1 mega words the heap only <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L215-L227">grows in 20% increments</a></span>.
</p>

<p>
There are two occasions when the young heap grows:
</p>

<ul>
<li>
if the total size of the heap + message and heap fragments exceeds the current heap size.

</li>
<li>
if after a fullsweep, the total amount of live objects is greater than 75%.

</li>
</ul>
<p>
There are two occasions when the young heap is shrunk:
</p>

<ul>
<li>
if after a young collection, the total amount of live objects is less than 25% of the heap and the young heap is "big"

</li>
<li>
if after a fullsweep, the total amount of live objects is less than 25% of the heap.

</li>
</ul>
<p>
The old heap is always one step ahead in the heap growth stages than the young heap.
</p>



<h3>
<a name="Literals"></a><span onMouseOver="document.getElementById('ghlink-literals-idm31451').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-literals-idm31451').style.visibility = 'hidden';"><a class="title_link" name="literals">8.5Â 
          Literals</a><span id="ghlink-literals-idm31451" class="ghlink-after"><a href="#literals" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
When garbage collecting a heap (young or old) all literals are left in place and not copied. To figure out if a term should be copied or not when doing a garbage collection the following pseudo code is used:
</p>

<div class="example example-none"><pre>if (erts_is_literal(ptr) || (on_old_heap(ptr) &amp;&amp; !fullsweep)) {
  /* literal or non fullsweep - do not copy */
} else {
  copy(ptr);
}</pre></div>
<p>
The <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/global.h#L1452-L1465">`erts_is_literal`</a></span> check works differently on different architectures and operating systems.
</p>

<p>
On 64 bit systems that allow mapping of unreserved virtual memory areas (most operating systems except Windows), an area of size 1 GB (by default) is mapped and then all literals are placed within that area. Then all that has to be done to determine if something is a literal or not is <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L322-L324">two quick pointer checks</a></span>. This system relies on the fact that a memory page that has not been touched yet does not take any actual space. So even if 1 GB of virtual memory is mapped, only the memory which is actually needed for literals is allocated in ram. The size of the literal area is configurable through the +MIscs erts_alloc option.
</p>

<p>
On 32 bit systems, there is not enough virtual memory space to allocate 1 GB for just literals, so instead small 256 KB sized literal regions are created on demand and a card mark bit-array of the entire 32 bit memory space is then used to determine if a term is a literal or not. Since the total memory space is only 32 bits, the card mark bit-array is only 256 words large. On a 64 bit system the same bit-array would have to be 1 tera words large, so this technique is only viable on 32 bit systems. Doing <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L316-L319">lookups in the array</a></span> is a little more expensive then just doing the pointer checks that can be done in 64 bit systems, but not extremely so.
</p>

<p>
On 64 bit windows, on which erts_alloc cannot do unreserved virtual memory mappings, a <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L59">special tag</a></span> within the Erlang term object is used to determine if something <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L248-L252">is a literal or not</a></span>. This is very cheap, however, the tag is only available on 64 bit machines, and it is possible to do a great deal of other nice optimizations with this tag in the future (like for instance a more compact list implementation) so it is not used on operating systems where it is not needed.
</p>

<p>
This behaviour is different from how it worked prior to Erlang/OTP 19.0. Before 19.0 the literal check was done by checking if the pointer pointed to the young or old heap block. If it did not, then it was considered a literal. This lead to considerable overhead and strange memory usage scenarios, so it was removed in 19.0.
</p>



<h3>
<a name="Binary-heap"></a><span onMouseOver="document.getElementById('ghlink-binary-heap-idm31466').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-binary-heap-idm31466').style.visibility = 'hidden';"><a class="title_link" name="binary-heap">8.6Â 
          Binary heap</a><span id="ghlink-binary-heap-idm31466" class="ghlink-after"><a href="#binary-heap" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
The binary heap works as a large object space for binary terms that are greater than 64 bytes (from now on called off-heap binaries). The binary heap is <span class="bold_code bc-20"><a href="https://en.wikipedia.org/wiki/Reference_counting">reference counted</a></span> and a pointer to the off-heap binary is stored on the process heap. To keep track of when to decrement the reference counter of the off-heap binary, a linked list (the MSO - mark and sweep object list) containing funs and externals as well as off-heap binaries is woven through the heap. After a garbage collection is done, the <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2299">MSO list is swept</a></span> and any off-heap binary that does not have a <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2325">move marker</a></span> written into the header words has its reference <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2344-L2367">decremented and is potentially freed</a></span>.
</p>

<p>
All items in the MSO list are ordered by the time they were added to the process heap, so when doing a minor garbage collection, the MSO sweeper only has to sweep until it <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L2369">encounters an off-heap binary that is on the old heap</a></span>.
</p>

<h4>
<a name="Binary-heap_Virtual-Binary-heap"></a><span onMouseOver="document.getElementById('ghlink-virtual-binary-heap-idm31476').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-virtual-binary-heap-idm31476').style.visibility = 'hidden';"><a class="title_link" name="virtual-binary-heap">Virtual Binary heap</a><span id="ghlink-virtual-binary-heap-idm31476" class="ghlink-after"><a href="#virtual-binary-heap" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
Each process has a virtual binary heap associated with it that has the size of all the current off-heap binaries that the process has references to. The virtual binary heap also has a limit and grows and shrinks depending on how off-heap binaries are used by the process. The same growth and shrink mechanisms are used for the binary heap and for the term heap, so first a Fibonacci like series and then 20% growth.
</p>

<p>
The virtual binary heap exists in order to <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/beam_emu.c#L364">trigger</a></span> garbage collections earlier when potentially there is a very large amount of off-heap binary data that could be reclaimed. This approach does not catch all problems with binary memory not being released soon enough, but it does catch a lot of them.
</p>





<h3>
<a name="Messages"></a><span onMouseOver="document.getElementById('ghlink-messages-idm31482').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-messages-idm31482').style.visibility = 'hidden';"><a class="title_link" name="messages">8.7Â 
          Messages</a><span id="ghlink-messages-idm31482" class="ghlink-after"><a href="#messages" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
Messages can become a part of the process heap at different times. This depends on how the process is configured.
We can configure the behaviour of each process using <span class="code">process_flag(message_queue_data, off_heap | on_heap)</span> or we can set a default for all processes at start using the option <span class="code">+hmqd</span>.
</p>

<p>
What do these different configurations do and when should we use them?
Let's start by going through what happens when one Erlang process sends a message to another.
The sending process needs to do a couple of things:
</p>

<ul>
<li>
calculate <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_message.c#L1031">how large</a></span> the message to be sent is

</li>
<li>
<span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_message.c#L1033">allocate enough space</a></span> to fit the entire message

</li>
<li>
<span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_message.c#L1040">copy</a></span> the message payload

</li>
<li>
allocate a message container with some meta data

</li>
<li>
<span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_message.c#L502">insert</a></span> the message container in the receiver process' <span class="bold_code bc-20"><a href="https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_process.h#L1042">message queue</a></span>

</li>
</ul>
<p>
The process flag <span class="code">message_queue_data</span>, of the receiver process, controls the message allocating strategy of the sender process in step 2 and also how the message data is treated by the garbage collector.
</p>

<p>
The procedure above is different from how it worked prior to 19.0. Before 19.0 there was no configuration option, the behaviour was always very similar to how the <span class="code">on_heap</span> option is in 19.0.
</p>

<h4>
<a name="Messages_Message-allocating-strategies"></a><span onMouseOver="document.getElementById('ghlink-message-allocating-strategies-idm31504').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-message-allocating-strategies-idm31504').style.visibility = 'hidden';"><a class="title_link" name="message-allocating-strategies">Message allocating strategies</a><span id="ghlink-message-allocating-strategies-idm31504" class="ghlink-after"><a href="#message-allocating-strategies" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h4>



<p>
If set to <span class="code">on_heap</span>, the sending process will first attempt to allocate the space for the message directly on the young heap block of the receiving process.
This is not always possible as it requires taking the <strong>main lock</strong> of the receiving process. The main lock is also held when the process is executing. The possibility for a lock conflict is thus likely in an intensely collaborating system.
If the sending process cannot acquire the main lock, a heap fragment is instead created for the message and the message payload is copied onto that.
With the <span class="code">off_heap</span> option the sender process always creates heap fragments for messages sent to that process.
</p>

<p>
There are a bunch of different tradeoffs that come into play when trying to figure out which of the strategies you want to use.
</p>

<p>
Using <span class="code">off_heap</span> may seem like a nice way to get a more scalable system as you get very little contention on the main locks, however, allocating a heap fragment is more expensive than allocating on the heap of the receiving process. So if it is very unlikely that contention will occur, it is more efficient to try to allocate the message directly on the receiving process' heap.
</p>

<p>
Using <span class="code">on_heap</span> will force all messages to be part of on the young heap which will increase the amount of data that the garbage collector has to move. So if a garbage collection is triggered while processing a large amount of messages, they will be copied to the young heap. This in turn will lead to that the messages will quickly be promoted to the old heap and thus increase its size. This may be good or bad depending on exactly what the process does. A large old heap means that the young heap will also be larger, which in turn means that less garbage collections will be triggered while processing the message queue. This will temporarly increase the throughput of the process at the cost of more memory usage. However, if after all the messages have been consumed the process enters a state where a lot less messages are being received. Then it may be a long time before the next fullsweep garbage collection happens and the messages that are on the old heap will be there until that happens. So while <span class="code">on_heap</span> is potentially faster than the other modes, it uses more memory for a longer time. This mode is the legacy mode which is almost how the message queue was handled before Erlang/OTP 19.0.
</p>

<p>
Which one of these strategies is best depends a lot on what the process is doing and how it interacts with other processes. So, as always, profile the application and see how it behaves with the different options.
</p>





<h3>
<a name="References"></a><span onMouseOver="document.getElementById('ghlink-references-idm31518').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-references-idm31518').style.visibility = 'hidden';"><a class="title_link" name="references">8.8Â 
          References</a><span id="ghlink-references-idm31518" class="ghlink-after"><a href="#references" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
C. J. Cheney. A nonrecursive list compacting algorithm. Commun. ACM, 13(11):677â678, Nov. 1970.
</p>

<p>
D. Ungar. Generation scavenging: A non-disruptive high performance storage reclamation algorithm. SIGSOFT Softw. Eng. Notes, 9(3):157â167, Apr. 1984.
</p>


</div>
<div class="footer">
<hr>
<p>Copyright Â© 1997-2024 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../../js/';</script><script type="text/javascript" src="../../js/highlight.js"></script>
</body>
</html>
