<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<title>Erlang -- Using SSL application API</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="leftnav-tube">
<div class="erlang-logo-wrapper"><a href="../../index.html"><img alt="Erlang Logo" src="../../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Secure Socket Layer </p>
<p class="section-subtitle">User's Guide</p>
<p class="section-version">Version 10.3.1.5</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="index.html">Reference Manual</a></li>
<li><a href="release_notes.html">Release Notes</a></li>
<li><a href="ssl.pdf">PDF</a></li>
<li><a href="../../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="ssl_introduction.html">
              Top of chapter
            </a></li>
<li title="Purpose"><a href="ssl_introduction.html#purpose">Purpose</a></li>
<li title="Prerequisites"><a href="ssl_introduction.html#prerequisites">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="TLS/DTLS and TLS Predecessor, SSL" expanded="false">TLS/DTLS and TLS Predecessor, SSL<ul>
<li><a href="ssl_protocol.html">
              Top of chapter
            </a></li>
<li title="Security Overview"><a href="ssl_protocol.html#security-overview">Security Overview</a></li>
<li title="Data Privacy and Integrity"><a href="ssl_protocol.html#data-privacy-and-integrity">Data Privacy and Integrity</a></li>
<li title="Digital Certificates"><a href="ssl_protocol.html#digital-certificates">Digital Certificates</a></li>
<li title="Peer Authentication"><a href="ssl_protocol.html#peer-authentication">Peer Authentication</a></li>
<li title="TLS Sessions - PRE TLS-1.3"><a href="ssl_protocol.html#tls-sessions---pre-tls-1.3">TLS Sessions - PRE TLS-1.3</a></li>
<li title="TLS-1.3 session tickets"><a href="ssl_protocol.html#tls-1.3-session-tickets">TLS-1.3 session tickets</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Using SSL application API" expanded="true">Using SSL application API<ul>
<li><a href="using_ssl.html">
              Top of chapter
            </a></li>
<li title="Setting up Connections"><a href="using_ssl.html#setting-up-connections">Setting up Connections</a></li>
<li title="Customizing cipher suites"><a href="using_ssl.html#customizing-cipher-suites">Customizing cipher suites</a></li>
<li title="Using an Engine Stored Key"><a href="using_ssl.html#using-an-engine-stored-key">Using an Engine Stored Key</a></li>
<li title="Session Reuse pre TLS 1.3"><a href="using_ssl.html#session-reuse-pre-tls-1.3">Session Reuse pre TLS 1.3</a></li>
<li title="Session Tickets and Session Resumption in TLS 1.3"><a href="using_ssl.html#session-tickets-and-session-resumption-in-tls-1.3">Session Tickets and Session Resumption in TLS 1.3</a></li>
<li title="Early Data in TLS 1.3"><a href="using_ssl.html#early-data-in-tls-1.3">Early Data in TLS 1.3</a></li>
<li title="Anti-Replay Protection in TLS 1.3"><a href="using_ssl.html#anti-replay-protection-in-tls-1.3">Anti-Replay Protection in TLS 1.3</a></li>
</ul>
</li>
<li id="no" title="Using TLS for Erlang Distribution" expanded="false">Using TLS for Erlang Distribution<ul>
<li><a href="ssl_distribution.html">
              Top of chapter
            </a></li>
<li title="Building Boot Scripts Including the SSL Application"><a href="ssl_distribution.html#building-boot-scripts-including-the-ssl-application">Building Boot Scripts Including the SSL Application</a></li>
<li title="Specifying Distribution Module for net_kernel"><a href="ssl_distribution.html#specifying-distribution-module-for-net_kernel">Specifying Distribution Module for net_kernel</a></li>
<li title="Specifying TLS Options"><a href="ssl_distribution.html#specifying-tls-options">Specifying TLS Options</a></li>
<li title="Specifying TLS Options (Legacy)"><a href="ssl_distribution.html#specifying-tls-options--legacy-">Specifying TLS Options (Legacy)</a></li>
<li title="Setting up Environment to Always Use TLS (Legacy)"><a href="ssl_distribution.html#setting-up-environment-to-always-use-tls--legacy-">Setting up Environment to Always Use TLS (Legacy)</a></li>
<li title="Using TLS distribution over IPv6"><a href="ssl_distribution.html#using-tls-distribution-over-ipv6">Using TLS distribution over IPv6</a></li>
</ul>
</li>
<li id="no" title="Standards Compliance" expanded="false">Standards Compliance<ul>
<li><a href="standards_compliance.html">
              Top of chapter
            </a></li>
<li title="Purpose"><a href="standards_compliance.html#purpose">Purpose</a></li>
<li title="Common (pre TLS 1.3)"><a href="standards_compliance.html#common--pre-tls-1.3-">Common (pre TLS 1.3)</a></li>
<li title="Common"><a href="standards_compliance.html#common">Common</a></li>
<li title="SSL 2.0"><a href="standards_compliance.html#ssl-2.0">SSL 2.0</a></li>
<li title="SSL 3.0"><a href="standards_compliance.html#ssl-3.0">SSL 3.0</a></li>
<li title="TLS 1.0"><a href="standards_compliance.html#tls-1.0">TLS 1.0</a></li>
<li title="TLS 1.1"><a href="standards_compliance.html#tls-1.1">TLS 1.1</a></li>
<li title="TLS 1.2"><a href="standards_compliance.html#tls-1.2">TLS 1.2</a></li>
<li title="DTLS 1.0"><a href="standards_compliance.html#dtls-1.0">DTLS 1.0</a></li>
<li title="DTLS 1.2"><a href="standards_compliance.html#dtls-1.2">DTLS 1.2</a></li>
<li title="DTLS 1.3"><a href="standards_compliance.html#dtls-1.3">DTLS 1.3</a></li>
<li title="TLS 1.3"><a href="standards_compliance.html#tls-1.3">TLS 1.3</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>3 Using SSL application API</h1>
  
  <p>To see relevant version information for ssl, call
  <span class="bold_code bc-13"><a href="../../man/ssl.html#versions-0"><span class="code">ssl:versions/0</span></a></span>
  .</p>
    
  <p>To see all supported cipher suites, call  <span class="bold_code bc-13"><a href="../../man/ssl.html#cipher_suites-1"><span class="code">ssl:cipher_suites(all)</span> </a></span>. 
  The available cipher suites for a connection depend on your certificate. 
  Specific cipher suites that you want your connection to use can also be 
  specified. Default is to use the strongest available.</p>
  
  <h3><span onMouseOver="document.getElementById('ghlink-setting-up-connections-idm128').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-setting-up-connections-idm128').style.visibility = 'hidden';"><a class="title_link" name="setting-up-connections">3.1 
          Setting up Connections</a><span id="ghlink-setting-up-connections-idm128" class="ghlink-after"><a href="#setting-up-connections" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/ssl/doc/src/using_ssl.xml#L44" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></span></h3>
    
    
    <p>This section shows a small example of how to set up client/server connections
    using the Erlang shell. The returned value of the <span class="code">sslsocket</span> is abbreviated
    with <span class="code">[...]</span> as it can be fairly large and is opaque.</p>
    
    <h4><span onMouseOver="document.getElementById('ghlink-minimal-example-idm133').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-minimal-example-idm133').style.visibility = 'hidden';"><a class="title_link" name="minimal-example">Minimal Example</a><span id="ghlink-minimal-example-idm133" class="ghlink-after"><a href="#minimal-example" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/ssl/doc/src/using_ssl.xml#L51" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></span></h4>
      
      
      <div class="note">
<div class="label">Note</div>
<div class="content"><p><p> The minimal setup is not the most secure setup of TLS/DTLS.</p>    
      </p></div>
</div>

      <p>To set up client/server connections:</p>

      <p><strong>Step 1:</strong> Start the server side:</p>
      <div class="example example-erl"><pre>1 server&gt; ssl:start().
ok</pre></div>
      
      <p><strong>Step 2:</strong> Create a TLS listen socket: (To run DTLS add the option {protocol, dtls})</p>
      <div class="example example-erl"><pre>2 server&gt; {ok, ListenSocket} =
ssl:listen(9999, [{certfile, "cert.pem"}, {keyfile, "key.pem"},{reuseaddr, true}]).
{ok,{sslsocket, [...]}}</pre></div>
      
      <p><strong>Step 3:</strong> Do a transport accept on the TLS listen socket:</p>
      <div class="example example-erl"><pre>3 server&gt; {ok, TLSTransportSocket} = ssl:transport_accept(ListenSocket).
{ok,{sslsocket, [...]}}</pre></div>

      <p><strong>Step 4:</strong> Start the client side: </p>
      <div class="example example-erl"><pre>1 client&gt; ssl:start().
ok</pre></div>
      <p> To run DTLS add the option {protocol, dtls} to third argument.</p>
      <div class="example example-erl"><pre>2 client&gt; {ok, Socket} = ssl:connect("localhost", 9999,  [], infinity).
{ok,{sslsocket, [...]}}</pre></div>
      
      <p><strong>Step 5:</strong> Do the TLS handshake:</p>
      <div class="example example-erl"><pre>4 server&gt; {ok, Socket} = ssl:handshake(TLSTransportSocket).
{ok,{sslsocket, [...]}}</pre></div>
      
      <p><strong>Step 6:</strong> Send a message over TLS:</p>
      <div class="example example-erl"><pre>5 server&gt; ssl:send(Socket, "foo").
ok</pre></div>
      
      <p><strong>Step 7:</strong> Flush the shell message queue to see that the message
      was sent on the server side:</p>
      <div class="example example-erl"><pre>3 client&gt; flush().
Shell got {ssl,{sslsocket,[...]},"foo"}
ok</pre></div>
    
    
    <h4><span onMouseOver="document.getElementById('ghlink-upgrade-example---tls-only--idm161').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-upgrade-example---tls-only--idm161').style.visibility = 'hidden';"><a class="title_link" name="upgrade-example---tls-only-">Upgrade Example - TLS only </a><span id="ghlink-upgrade-example---tls-only--idm161" class="ghlink-after"><a href="#upgrade-example---tls-only-" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/ssl/doc/src/using_ssl.xml#L94" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></span></h4>
      
      
      <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>To upgrade a TCP/IP connection to a TLS connection, the
      client and server must agree to do so. The agreement
      can be accomplished by using a protocol, for example, the one used by HTTP
      specified in RFC 2817.</p></p></div>
</div>

      <p>To upgrade to a TLS connection:</p>
      
      <p><strong>Step 1:</strong> Start the server side:</p>
      <div class="example example-erl"><pre>1 server&gt; ssl:start().
ok</pre></div>
      
      <p><strong>Step 2:</strong> Create a normal TCP listen socket:</p>
      <div class="example example-erl"><pre>2 server&gt; {ok, ListenSocket} = gen_tcp:listen(9999, [{reuseaddr, true}]).
{ok, #Port&lt;0.475&gt;}</pre></div>
      
      <p><strong>Step 3:</strong> Accept client connection:</p>
      <div class="example example-erl"><pre>3 server&gt; {ok, Socket} = gen_tcp:accept(ListenSocket).
{ok, #Port&lt;0.476&gt;}</pre></div>
      
      <p><strong>Step 4:</strong> Start the client side:</p>
      <div class="example example-erl"><pre>1 client&gt; ssl:start().
ok</pre></div>
      
      <div class="example example-erl"><pre>2 client&gt; {ok, Socket} = gen_tcp:connect("localhost", 9999,  [], infinity).</pre></div>
      
      <p><strong>Step 5:</strong> Ensure <span class="code">active</span> is set to <span class="code">false</span> before trying
      to upgrade a connection to a TLS connection, otherwise
      TLS handshake messages can be delivered to the wrong process:</p>
      <div class="example example-erl"><pre>4 server&gt; inet:setopts(Socket, [{active, false}]).
ok</pre></div>
      
      <p><strong>Step 6:</strong> Do the TLS handshake:</p>
      <div class="example example-erl"><pre>5 server&gt; {ok, TLSSocket} = ssl:handshake(Socket, [{cacertfile, "cacerts.pem"},
{certfile, "cert.pem"}, {keyfile, "key.pem"}]).
{ok,{sslsocket,[...]}}</pre></div>
      
      <p><strong>Step 7:</strong> Upgrade to a TLS connection. The client and server
      must agree upon the upgrade. The server must call
      <span class="code">ssl:handshake/2</span> before the client calls <span class="code">ssl:connect/3.</span></p>
      <div class="example example-erl"><pre>3 client&gt;{ok, TLSSocket} = ssl:connect(Socket, [{cacertfile, "cacerts.pem"},
{certfile, "cert.pem"}, {keyfile, "key.pem"}], infinity).
{ok,{sslsocket,[...]}}</pre></div>
      
      <p><strong>Step 8:</strong> Send a message over TLS:</p>
      <div class="example example-erl"><pre>4 client&gt; ssl:send(TLSSocket, "foo").
ok</pre></div>
      
      <p><strong>Step 9:</strong> Set <span class="code">active true</span> on the TLS socket:</p>
      <div class="example example-erl"><pre>4 server&gt; ssl:setopts(TLSSocket, [{active, true}]).
ok</pre></div>
      
      <p><strong>Step 10:</strong> Flush the shell message queue to see that the message
      was sent on the client side:</p>
      <div class="example example-erl"><pre>5 server&gt; flush().
Shell got {ssl,{sslsocket,[...]},"foo"}
ok</pre></div>
    
  

  <h3><span onMouseOver="document.getElementById('ghlink-customizing-cipher-suites-idm202').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-customizing-cipher-suites-idm202').style.visibility = 'hidden';"><a class="title_link" name="customizing-cipher-suites">3.2 
          Customizing cipher suites</a><span id="ghlink-customizing-cipher-suites-idm202" class="ghlink-after"><a href="#customizing-cipher-suites" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/ssl/doc/src/using_ssl.xml#L156" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></span></h3>
    

    <p>Fetch default cipher suite list for a TLS/DTLS version. Change default
    to all to get all possible cipher suites.</p>
    <div class="example example-erl"><pre>1&gt;  Default = ssl:cipher_suites(default, 'tlsv1.2').
    [#{cipher =&gt; aes_256_gcm,key_exchange =&gt; ecdhe_ecdsa,
    mac =&gt; aead,prf =&gt; sha384}, ....]</pre></div>

    <p>In OTP 20 it is desirable to remove all cipher suites
    that uses rsa kexchange (removed from default in 21) </p>
    <div class="example example-erl"><pre>2&gt; NoRSA =
    ssl:filter_cipher_suites(Default,
                            [{key_exchange, fun(rsa) -&gt; false;
			                       (_) -&gt; true end}]).
    [...]</pre></div>

    <p> Pick just a few suites </p>
    <div class="example example-erl"><pre> 3&gt; Suites =
    ssl:filter_cipher_suites(Default,
                            [{key_exchange, fun(ecdh_ecdsa) -&gt; true;
			                       (_) -&gt; false end},
                             {cipher, fun(aes_128_cbc) -&gt;true;
			                  (_) -&gt;false end}]).
    [#{cipher =&gt; aes_128_cbc,key_exchange =&gt; ecdh_ecdsa,
     mac =&gt; sha256,prf =&gt; sha256},
     #{cipher =&gt; aes_128_cbc,key_exchange =&gt; ecdh_ecdsa,mac =&gt; sha,
     prf =&gt; default_prf}]</pre></div>
    
    <p> Make some particular suites the most preferred, or least
    preferred by changing prepend to append.</p>
    <div class="example example-erl"><pre> 4&gt;ssl:prepend_cipher_suites(Suites, Default).
  [#{cipher =&gt; aes_128_cbc,key_exchange =&gt; ecdh_ecdsa,
     mac =&gt; sha256,prf =&gt; sha256},
   #{cipher =&gt; aes_128_cbc,key_exchange =&gt; ecdh_ecdsa,mac =&gt; sha,
     prf =&gt; default_prf},
   #{cipher =&gt; aes_256_cbc,key_exchange =&gt; ecdhe_ecdsa,
     mac =&gt; sha384,prf =&gt; sha384}, ...]</pre></div>
        

  <h3><span onMouseOver="document.getElementById('ghlink-using-an-engine-stored-key-idm212').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-using-an-engine-stored-key-idm212').style.visibility = 'hidden';"><a class="title_link" name="using-an-engine-stored-key">3.3 
          Using an Engine Stored Key</a><span id="ghlink-using-an-engine-stored-key-idm212" class="ghlink-after"><a href="#using-an-engine-stored-key" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/ssl/doc/src/using_ssl.xml#L200" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></span></h3>
    
    
    <p>Erlang ssl application is able to use private keys provided
    by OpenSSL engines using the following mechanism:</p>
    
    <div class="example example-erl"><pre>1&gt; ssl:start().
ok</pre></div>

    <p>Load a crypto engine, should be done once per engine used. For example
    dynamically load the engine called <span class="code">MyEngine</span>:
    </p>
    <div class="example example-erl"><pre>2&gt; {ok, EngineRef} =
crypto:engine_load(&lt;&lt;"dynamic"&gt;&gt;,
                   [{&lt;&lt;"SO_PATH"&gt;&gt;, "/tmp/user/engines/MyEngine"},&lt;&lt;"LOAD"&gt;&gt;],[]).
{ok,#Ref&lt;0.2399045421.3028942852.173962&gt;}</pre></div>
    
    <p>Create a map with the engine information and the algorithm used by the engine:</p>
    <div class="example example-erl"><pre>3&gt; PrivKey =
 #{algorithm =&gt; rsa,
   engine =&gt; EngineRef,
   key_id =&gt; "id of the private key in Engine"}.</pre></div>
    <p>Use the map in the ssl key option:</p>
    <div class="example example-erl"><pre>4&gt; {ok, SSLSocket} =
ssl:connect("localhost", 9999,
            [{cacertfile, "cacerts.pem"},
             {certfile, "cert.pem"},
             {key, PrivKey}], infinity).</pre></div>

    <p>See also <span class="bold_code bc-13"><a href="../../apps/crypto/engine_load.html#engine_load"> crypto documentation</a></span> </p>
    
  


  <h3><span onMouseOver="document.getElementById('ghlink-session-reuse-pre-tls-1.3-idm225').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-session-reuse-pre-tls-1.3-idm225').style.visibility = 'hidden';"><a class="title_link" name="session-reuse-pre-tls-1.3">3.4 
          Session Reuse pre TLS 1.3</a><span id="ghlink-session-reuse-pre-tls-1.3-idm225" class="ghlink-after"><a href="#session-reuse-pre-tls-1.3" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/ssl/doc/src/using_ssl.xml#L237" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></span></h3>
    
    <p>Clients can request to reuse a session established
    by a previous full handshake between that client and server by
    sending the id of the session in the initial handshake
    message. The server may or may not agree to reuse it. If agreed
    the server will send back the id and if not it will send a new
    id. The ssl application has several options for handling session
    reuse.</p>

    <p>On the client side the ssl application will save session data
    to try to automate session reuse on behalf of the client processes
    on the Erlang node. Note that only verified sessions will be
    saved for security reasons, that is session resumption relies on
    the certificate validation to have been run in the original
    handshake. To minimize memory consumption only unique sessions
    will be saved unless the special <span class="code">save</span> value is specified
    for the following option <span class="code"> {reuse_sessions, boolean() |
    save}</span> in which case a full handhake will be performed and that
    specific session will have been saved before the handshake
    returns. The session id and even an opaque binary containing the
    session data can be retrieved using
    <span class="code">ssl:connection_information/1</span> function. A saved session
    (guaranteed by the save option) can be explicitly reused using
    <span class="code">{reuse_session, SessionId}</span>. Also it is possible for the
    client to reuse a session that is not saved by the ssl application
    using <span class="code">{reuse_session, {SessionId, SessionData}}</span>.</p>

    <div class="note">
<div class="label">Note</div>
<div class="content"><p><p>When using explicit session reuse, it is up to the client
    to make sure that the session being reused is for the correct
    server and has been verified.</p></p></div>
</div>

    <p>Here follows a client side example,
    divide into several steps for readability.
    </p>

    <p>Step 1 - Automated Session Reuse</p>

    <div class="example example-erl"><pre>1&gt; ssl:start().
ok

2&gt; {ok, C1} = ssl:connect("localhost", 9999, [{verify, verify_peer},
					      {versions, ['tlsv1.2']},
					      {cacertfile, "cacerts.pem"}]).
{ok,{sslsocket,{gen_tcp,#Port&lt;0.7&gt;,tls_connection,undefined}, ...}}

3&gt; ssl:connection_information(C1, [session_id]).
{ok,[{session_id,&lt;&lt;95,32,43,22,35,63,249,22,26,36,106,
                   152,49,52,124,56,130,192,137,161,
                   146,145,164,232,...&gt;&gt;}]}

%% Reuse session if possible, note that if C2 is really fast the session
%% data might not be available for reuse.
4&gt; {ok, C2} = ssl:connect("localhost", 9999, [{verify, verify_peer},
					      {versions, ['tlsv1.2']},
					      {cacertfile, "cacerts.pem"},
					      {reuse_sessions, true}]).
{ok,{sslsocket,{gen_tcp,#Port&lt;0.8&gt;,tls_connection,undefined}, ...]}}

%% C2 got same session ID as client one, session was automatically reused.
5&gt; ssl:connection_information(C2, [session_id]).
{ok,[{session_id,&lt;&lt;95,32,43,22,35,63,249,22,26,36,106,
                   152,49,52,124,56,130,192,137,161,
                   146,145,164,232,...&gt;&gt;}]}</pre></div>

<p>Step 2- Using <span class="code">save</span> Option </p>

<div class="example example-erl"><pre>%% We want save this particular session for reuse although it has the same basis as C1
6&gt; {ok, C3} = ssl:connect("localhost", 9999, [{verify, verify_peer},
					      {versions, ['tlsv1.2']},
					      {cacertfile, "cacerts.pem"},
					      {reuse_sessions, save}]).
{ok,{sslsocket,{gen_tcp,#Port&lt;0.9&gt;,tls_connection,undefined}, ...]}}

%% A full handshake is performed and we get a new session ID
7&gt; {ok, [{session_id, ID}]} = ssl:connection_information(C3, [session_id]).
{ok,[{session_id,&lt;&lt;91,84,27,151,183,39,84,90,143,141,
                   121,190,66,192,10,1,27,192,33,95,78,
                   8,34,180,...&gt;&gt;}]}

%% Use automatic session reuse
8&gt; {ok, C4} = ssl:connect("localhost", 9999, [{verify, verify_peer},
					      {versions, ['tlsv1.2']},
					      {cacertfile, "cacerts.pem"},
					      {reuse_sessions, true}]).
{ok,{sslsocket,{gen_tcp,#Port&lt;0.10&gt;,tls_connection,
                        undefined}, ...]}}

%% The "saved" one happened to be selected, but this is not a guarantee
9&gt; ssl:connection_information(C4, [session_id]).
{ok,[{session_id,&lt;&lt;91,84,27,151,183,39,84,90,143,141,
                   121,190,66,192,10,1,27,192,33,95,78,
                   8,34,180,...&gt;&gt;}]}

%% Make sure to reuse the "saved" session
10&gt; {ok, C5} = ssl:connect("localhost", 9999, [{verify, verify_peer},
					       {versions, ['tlsv1.2']},
					       {cacertfile, "cacerts.pem"},
					       {reuse_session, ID}]).
{ok,{sslsocket,{gen_tcp,#Port&lt;0.11&gt;,tls_connection,
                        undefined}, ...]}}

11&gt; ssl:connection_information(C5, [session_id]).
{ok,[{session_id,&lt;&lt;91,84,27,151,183,39,84,90,143,141,
                   121,190,66,192,10,1,27,192,33,95,78,
                   8,34,180,...&gt;&gt;}]}</pre></div>

<p>Step 3 - Explicit Session Reuse </p>

<div class="example example-erl"><pre>%% Preform a full handshake and the session will not be saved for reuse
12&gt; {ok, C9} = ssl:connect("localhost", 9999, [{verify, verify_peer},
				               {versions, ['tlsv1.2']},
		                               {cacertfile, "cacerts.pem"},
					       {reuse_sessions, false},
					       {server_name_indication, disable}]).
{ok,{sslsocket,{gen_tcp,#Port&lt;0.14&gt;,tls_connection, ...}}

%% Fetch session ID and data for C9 connection
12&gt; {ok, [{session_id, ID1}, {session_data, SessData}]} =
	ssl:connection_information(C9, [session_id, session_data]).
{ok,[{session_id,&lt;&lt;9,233,4,54,170,88,170,180,17,96,202,
                   85,85,99,119,47,9,68,195,50,120,52,
                   130,239,...&gt;&gt;},
     {session_data,&lt;&lt;131,104,13,100,0,7,115,101,115,115,105,
                     111,110,109,0,0,0,32,9,233,4,54,170,...&gt;&gt;}]}

%% Explicitly reuse the session from C9
13&gt; {ok, C10} = ssl:connect("localhost", 9999, [{verify, verify_peer},
						{versions, ['tlsv1.2']},
						{cacertfile, "cacerts.pem"},
						{reuse_session, {ID1, SessData}}]).
{ok,{sslsocket,{gen_tcp,#Port&lt;0.15&gt;,tls_connection,
                        undefined}, ...}}

14&gt; ssl:connection_information(C10, [session_id]).
{ok,[{session_id,&lt;&lt;9,233,4,54,170,88,170,180,17,96,202,
                   85,85,99,119,47,9,68,195,50,120,52,
                   130,239,...&gt;&gt;}]}</pre></div>

<p>Step 4 - Not Possible to Reuse Explicit Session by ID Only</p>

<div class="example example-erl"><pre>%% Try to reuse the session from C9 using only the id
15&gt; {ok, E} = ssl:connect("localhost", 9999, [{verify, verify_peer},
				              {versions, ['tlsv1.2']},
				              {cacertfile, "cacerts.pem"},
					      {reuse_session, ID1}]).
{ok,{sslsocket,{gen_tcp,#Port&lt;0.18&gt;,tls_connection,
                        undefined}, ...}}

%% This will fail (as it is not saved for reuse)
%% and a full handshake will be performed, we get a new id.
16&gt;  ssl:connection_information(E, [session_id]).
{ok,[{session_id,&lt;&lt;87,46,43,126,175,68,160,153,37,29,
                   196,240,65,160,254,88,65,224,18,63,
                   18,17,174,39,...&gt;&gt;}]}</pre></div>

    <p>On the server side the the <span class="code">{reuse_sessions, boolean()}</span> option
      determines if the server will save session data and allow session
      reuse or not. This can be further customized by the option
      <span class="code">{reuse_session, fun()}</span> that may introduce a local policy for
      session reuse.
    </p>

  

  <h3><span onMouseOver="document.getElementById('ghlink-session-tickets-and-session-resumption-in-tls-1.3-idm249').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-session-tickets-and-session-resumption-in-tls-1.3-idm249').style.visibility = 'hidden';"><a class="title_link" name="session-tickets-and-session-resumption-in-tls-1.3">3.5 
          Session Tickets and Session Resumption in TLS 1.3</a><span id="ghlink-session-tickets-and-session-resumption-in-tls-1.3-idm249" class="ghlink-after"><a href="#session-tickets-and-session-resumption-in-tls-1.3" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/ssl/doc/src/using_ssl.xml#L412" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></span></h3>
    

    <p>
    TLS 1.3 introduces a new secure way of resuming sessions by using session tickets.
    A session ticket is an opaque data structure that is sent in the pre_shared_key extension of
    a ClientHello, when a client attempts to resume a session with keying material from a
    previous successful handshake.</p>
    <p>Session tickets can be stateful or stateless. A stateful session ticket is a database reference
    (session ticket store) and used with stateful servers, while a stateless ticket
    is a self-encrypted and self-authenticated data structure with cryptographic keying material and
    state data, enabling session resumption with stateless servers.</p>
    <p>The choice between stateful or stateless depends on the server requirements as the session tickets
    are opaque for the clients. Generally, stateful tickets are smaller and the server can guarantee
    that tickets are only used once. Stateless tickets contain additional data, require less storage
    on the server side, but they offer different guarantees against anti-replay. See also
    <span class="bold_code bc-13"><a href="using_ssl.html#anti-replay-protection-in-tls-1.3">
    Anti-Replay Protection in TLS 1.3</a></span>
    </p>
    <p>Session tickets are sent by servers on newly estalished TLS connections.
    The number of tickets sent and their lifetime are configurable by application variables. See also
    <span class="bold_code bc-13"><a href="../../man/ssl_app.html#configuration"> SSL's configuration</a></span>.</p>
    <p>Session tickets are protected by application traffic keys, and in stateless
    tickets, the opaque data structure itself is self-encrypted.</p>

    <p>An example with automatic and manual session resumption:</p>

    <p><strong>Step 1 (server):</strong> Start the server:</p>
    <div class="example example-erl"><pre>      {ok, _} = application:ensure_all_started(ssl).
      LOpts = [{certfile, "cert.pem"},
               {keyfile, "key.pem"},
               {versions, ['tlsv1.2','tlsv1.3']},
               {session_tickets, stateless}].
      {ok, LSock} = ssl:listen(8001, LOpts).
      {ok, CSock} = ssl:transport_accept(LSock).</pre></div>

    <p><strong>Step 2 (client):</strong> Start the client and connect to server:</p>
    <div class="example example-erl"><pre>      {ok, _} = application:ensure_all_started(ssl).
      COpts = [{cacertfile, "cert.pem"},
               {versions, ['tlsv1.2','tlsv1.3']},
               {log_level, debug},
               {session_tickets, auto}].
      ssl:connect("localhost", 8001, COpts).</pre></div>

    <p><strong>Step 3 (server):</strong> Start the TLS handshake:</p>
    <div class="example example-erl"><pre>      ssl:handshake(CSock).</pre></div>

    <p>A connection is established using a full handshake.
    Below is a summary of the exchanged messages:</p>
    <div class="example example-erl"><pre>      &gt;&gt;&gt; TLS 1.3 Handshake, ClientHello ...
      &lt;&lt;&lt; TLS 1.3 Handshake, ServerHello ...
      &lt;&lt;&lt; Handshake, EncryptedExtensions ...
      &lt;&lt;&lt; Handshake, Certificate ...
      &lt;&lt;&lt; Handshake, CertificateVerify ...
      &lt;&lt;&lt; Handshake, Finished ...
      &gt;&gt;&gt; Handshake, Finished ...
      &lt;&lt;&lt; Post-Handshake, NewSessionTicket ...</pre></div>

    <p>At this point the client has stored the received session tickets and ready to use them when
    establishing new connections to the same server.</p>

    <p><strong>Step 4 (server):</strong> Accept a new connection on the server:</p>
    <div class="example example-erl"><pre>      {ok, CSock2} = ssl:transport_accept(LSock).</pre></div>

    <p><strong>Step 5 (client):</strong> Make a new connection:</p>
    <div class="example example-erl"><pre>      ssl:connect("localhost", 8001, COpts).</pre></div>

    <p><strong>Step 6 (server):</strong> Start the handshake:</p>
    <div class="example example-erl"><pre>      ssl:handshake(CSock2).</pre></div>

    <p>The second connection is a session resumption using keying material
    from the previous handshake:</p>
    <div class="example example-erl"><pre>      &gt;&gt;&gt; TLS 1.3 Handshake, ClientHello ...
      &lt;&lt;&lt; TLS 1.3 Handshake, ServerHello ...
      &lt;&lt;&lt; Handshake, EncryptedExtensions ...
      &lt;&lt;&lt; Handshake, Finished ...
      &gt;&gt;&gt; Handshake, Finished ...
      &lt;&lt;&lt; Post-Handshake, NewSessionTicket ...</pre></div>

    <p>Manual handling of session tickets is also supported. In manual mode, it is the
    responsibility of the client to handle received session tickets.</p>

    <p><strong>Step 7 (server):</strong> Accept a new connection on the server:</p>
    <div class="example example-erl"><pre>      {ok, CSock3} = ssl:transport_accept(LSock).</pre></div>

    <p><strong>Step 8 (client):</strong> Make a new connection to server:</p>
    <div class="example example-erl"><pre>      {ok, _} = application:ensure_all_started(ssl).
      COpts2 = [{cacertfile, "cert.pem"},
                {versions, ['tlsv1.2','tlsv1.3']},
                {log_level, debug},
                {session_tickets, manual}].
      ssl:connect("localhost", 8001, COpts).</pre></div>

    <p><strong>Step 9 (server):</strong> Start the handshake:</p>
    <div class="example example-erl"><pre>      ssl:handshake(CSock3).</pre></div>

    <p>After the handshake is performed, the user process receives messages with the tickets
    sent by the server.</p>

    <p><strong>Step 10 (client):</strong> Receive a new session ticket:</p>
    <div class="example example-erl"><pre>      Ticket = receive {ssl, session_ticket, {_, TicketData}} -&gt; TicketData end.</pre></div>

    <p><strong>Step 11 (server):</strong> Accept a new connection on the server:</p>
    <div class="example example-erl"><pre>      {ok, CSock4} = ssl:transport_accept(LSock).</pre></div>

    <p><strong>Step 12 (client):</strong> Initiate a new connection to the server with the session ticket
    received in Step 10:</p>
    <div class="example example-erl"><pre>      {ok, _} = application:ensure_all_started(ssl).
      COpts2 = [{cacertfile, "cert.pem"},
                {versions, ['tlsv1.2','tlsv1.3']},
                {log_level, debug},
                {session_tickets, manual},
                {use_ticket, [Ticket]}].
      ssl:connect("localhost", 8001, COpts).</pre></div>

    <p><strong>Step 13 (server):</strong> Start the handshake:</p>
    <div class="example example-erl"><pre>      ssl:handshake(CSock3).</pre></div>
  

  <h3><span onMouseOver="document.getElementById('ghlink-early-data-in-tls-1.3-idm305').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-early-data-in-tls-1.3-idm305').style.visibility = 'hidden';"><a class="title_link" name="early-data-in-tls-1.3">3.6 
          Early Data in TLS 1.3</a><span id="ghlink-early-data-in-tls-1.3-idm305" class="ghlink-after"><a href="#early-data-in-tls-1.3" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/ssl/doc/src/using_ssl.xml#L561" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></span></h3>
    
    <p>TLS 1.3 allows clients to send data on the first flight if the endpoints have
    a shared crypographic secret (pre-shared key). This means that clients can send
    early data if they have a valid session ticket received in a previous
    successful handshake. For more information about session resumption see
    <span class="bold_code bc-13"><a href="using_ssl.html#session-tickets-and-session-resumption-in-tls-1.3">
    Session Tickets and Session Resumption in TLS 1.3</a></span>.
    </p>
    <p>The security properties of Early Data are weaker than other kinds of TLS data.
    This data is not forward secret, and it is vulnerable to replay attacks. For available
    mitigation strategies see
    <span class="bold_code bc-13"><a href="using_ssl.html#anti-replay-protection-in-tls-1.3">
    Anti-Replay Protection in TLS 1.3</a></span>.</p>
    <p>In normal operation, clients will not know which, if any, of the available mitigation
    strategies servers actually implement, and hence must only send early data which
    they deem safe to be replayed. For example, idempotent HTTP operations, such as HEAD and
    GET, can usually be regarded as safe but even they can be exploited by a large number of
    replays causing resource limit exhaustion and other similar problems.</p>
    <p>An example of sending early data with automatic and manual session ticket handling:</p>
    <div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
    <p>The Early Data feature is experimental in this version of OTP.
    </p>
    </p></div>
</div>

    <p><strong>Server (with NSS key logging)</strong></p>
    <div class="example example-none"><pre>    early_data_server() -&gt;
        application:load(ssl),
        {ok, _} = application:ensure_all_started(ssl),
        Port = 11029,
        LOpts = [{certfile, ?SERVER_CERT},
             {keyfile, ?SERVER_KEY},
             {reuseaddr, true},
             {versions, ['tlsv1.2','tlsv1.3']},
             {session_tickets, stateless},
             {early_data, enabled},
             {keep_secrets, true} %% Enable NSS key log (debug option)
            ],
        {ok, LSock} = ssl:listen(Port, LOpts),
        %% Accept first connection
        {ok, CSock0} = ssl:transport_accept(LSock),
        {ok, _} = ssl:handshake(CSock0),
        %% Accept second connection
        {ok, CSock1} = ssl:transport_accept(LSock),
        {ok, Sock} = ssl:handshake(CSock1),
        Sock.</pre></div>
    <p><strong>Exporting the secrets (optional)</strong></p>
    <div class="example example-none"><pre>    {ok, [{keylog, KeylogItems}]} = ssl:connection_information(Sock, [keylog]).
    file:write_file("key.log", [[KeylogItem,$\n] || KeylogItem &lt;- KeylogItems]).</pre></div>
    <p><strong>Client (automatic ticket handling):</strong></p>
    <div class="example example-erl"><pre>    early_data_auto() -&gt;
        %% First handshake 1-RTT - get session tickets
	application:load(ssl),
	{ok, _} = application:ensure_all_started(ssl),
	Port = 11029,
	Data = &lt;&lt;"HEAD / HTTP/1.1\r\nHost: \r\nConnection: close\r\n"&gt;&gt;,
	COpts0 = [{cacertfile, ?CA_CERT},
	          {versions, ['tlsv1.2', 'tlsv1.3']},
	          {session_tickets, auto}],
        {ok, Sock0} = ssl:connect("localhost", Port, COpts0),

        %% Wait for session tickets
	timer:sleep(500),
	%% Close socket if server cannot handle multiple connections e.g. openssl s_server
	ssl:close(Sock0),

        %% Second handshake 0-RTT
	COpts1 = [{cacertfile, ?CA_CERT},
	          {versions, ['tlsv1.2', 'tlsv1.3']},
		  {session_tickets, auto},
		  {early_data, Data}],
        {ok, Sock} = ssl:connect("localhost", Port, COpts1),
	Sock.</pre></div>
    <p><strong>Client (manual ticket handling):</strong></p>
    <div class="example example-erl"><pre>    early_data_manual() -&gt;
        %% First handshake 1-RTT - get session tickets
	application:load(ssl),
	{ok, _} = application:ensure_all_started(ssl),
	Port = 11029,
	Data = &lt;&lt;"HEAD / HTTP/1.1\r\nHost: \r\nConnection: close\r\n"&gt;&gt;,
	COpts0 = [{cacertfile, ?CA_CERT},
	          {versions, ['tlsv1.2', 'tlsv1.3']},
	          {session_tickets, manual}],
        {ok, Sock0} = ssl:connect("localhost", Port, COpts0),

        %% Wait for session tickets
	Ticket =
	    receive
	        {ssl, session_ticket, Ticket0} -&gt;
		    Ticket0
            end,

       %% Close socket if server cannot handle multiple connections
       %% e.g. openssl s_server
       ssl:close(Sock0),

       %% Second handshake 0-RTT
       COpts1 = [{cacertfile, ?CA_CERT},
                 {versions, ['tlsv1.2', 'tlsv1.3']},
		 {session_tickets, manual},
		 {use_ticket, [Ticket]},
		 {early_data, Data}],
       {ok, Sock} = ssl:connect("localhost", Port, COpts1),
       Sock.</pre></div>
  

  <h3><span onMouseOver="document.getElementById('ghlink-anti-replay-protection-in-tls-1.3-idm327').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-anti-replay-protection-in-tls-1.3-idm327').style.visibility = 'hidden';"><a class="title_link" name="anti-replay-protection-in-tls-1.3">3.7 
          Anti-Replay Protection in TLS 1.3</a><span id="ghlink-anti-replay-protection-in-tls-1.3-idm327" class="ghlink-after"><a href="#anti-replay-protection-in-tls-1.3" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/ssl/doc/src/using_ssl.xml#L675" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></span></h3>
    

    <p>The TLS 1.3 protocol does not provide inherent protection for replay of 0-RTT data but
    describes mechanisms that SHOULD be implemented by compliant server implementations.
    The implementation of TLS 1.3 in the SSL application employs all standard methods
    to prevent potential threats.
    </p>
    <p><strong>Single-use tickets</strong></p>
    <p>This mechanism is available with stateful session tickets. Session tickets can
    only be used once, subsequent use of the same ticket results in a full handshake.
    Stateful servers enforce this rule by maintaining a database of outstanding valid
    tickets.</p>

    <p><strong>Client Hello Recording</strong></p>
    <p>This mechanism is available with stateless session tickets. The server records
    a unique value derived from the ClientHello (PSK binder) in a given time window. The
    ticket's age is verified by using both the "obsfuscated_ticket_age" and an additional
    timestamp encrypted in the ticket data. As the used datastore allows false positives,
    apparent replays will be answered by doing a full 1-RTT handshake.</p>

    <p><strong>Freshness Checks</strong></p>
    <p>This mechanism is available with the stateless session tickets. As the ticket data
    has an embedded timestamp, the server can determine if a ClientHello was sent reasonably
    recently and accept the 0-RTT handshake, otherwise if falls back to a full 1-RTT
    handshake. This mechanism is tightly coupled with the previous one, it prevents storing an
    unlimited number of ClientHellos.</p>

    <p>The current implementation uses a pair of Bloom filters to implement the last two mechanisms.
    Bloom filters are fast, memory-efficient, probabilistic data structures that can tell
    if an element may be in a set or if it is definitely not in the set.</p>

    <p>If the option <span class="bold_code bc-13"><a href="../../man/ssl.html#type-anti_replay">anti_replay</a></span>
    is defined in the server, a pair of Bloom filters (<strong>current</strong> and
    <strong>old</strong>) are used to record incoming ClientHello messages (it is the unique
    binder value that is actually stored).
    The <strong>current</strong> Bloom filter is used for <span class="code">WindowSize</span> seconds to store new
    elements. At the end of the time window the Bloom filters are rotated
    (the <strong>current</strong> Bloom filter becomes the <strong>old</strong> and an empty Bloom filter
    is set as <strong>current</strong>.
    </p>

    <p>The Anti-Replay protection feature in stateless servers executes in the following steps
    when a new ClientHello is received:</p>
    <ul>
      <li><p>Reported ticket age (obfuscated ticket age) shall be
      less than ticket lifetime.</p></li>
      <li><p>Actual ticket age shall be less than the ticket lifetime (stateless session
      tickets contain the servers timestamp when the ticket was issued).</p></li>
      <li><p>Ticket shall be used within specified time window (freshness checks).</p></li>
      <li><p>If all above checks passed both <strong>current</strong> and <strong>old</strong> Bloom filters
      are checked to detect if binder was already seen. Being a probabilistic data structure,
      false positives can occur and they trigger a full handshake.</p></li>
      <li><p>If the binder is not seen, the binder is validated. If the binder is valid,
      the server proceeds with the 0-RTT handshake.</p></li>
    </ul>

  
 </div>
<div class="footer">
<hr>
<p>Copyright © 1999-2024 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../../js/';</script><script type="text/javascript" src="../../js/highlight.js"></script>
</body>
</html>
