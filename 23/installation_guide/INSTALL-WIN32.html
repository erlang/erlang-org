<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- How to Build Erlang/OTP on Windows</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="leftnav-tube">
<div class="erlang-logo-wrapper"><a href="../index.html"><img alt="Erlang Logo" src="../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Installation Guide</p>
<p class="section-subtitle">User's Guide</p>
<p class="section-version">Version 11.2.2.18</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="../pdf/otp-system-documentation.pdf">PDF</a></li>
<li><a href="../index.html">Top</a></li>
</ul>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3>Chapters</h3>
<ul class="flipMenu" imagePath="../js/flipmenu">
<li id="no" title="Installing the Binary Release" expanded="false">Installing the Binary Release<ul>
<li><a href="install-binary.html">
              Top of chapter
            </a></li>
<li title="Windows"><a href="install-binary.html#windows">Windows</a></li>
</ul>
</li>
<li id="no" title="Building and Installing Erlang/OTP" expanded="false">Building and Installing Erlang/OTP<ul>
<li><a href="INSTALL.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="INSTALL.html#introduction">Introduction</a></li>
<li title="Required Utilities"><a href="INSTALL.html#required-utilities">Required Utilities</a></li>
<li title="Optional Utilities"><a href="INSTALL.html#optional-utilities">Optional Utilities</a></li>
<li title="How to Build and Install Erlang/OTP"><a href="INSTALL.html#how-to-build-and-install-erlang-otp">How to Build and Install Erlang/OTP</a></li>
<li title="Advanced configuration and build of Erlang/OTP"><a href="INSTALL.html#advanced-configuration-and-build-of-erlang-otp">Advanced configuration and build of Erlang/OTP</a></li>
</ul>
</li>
<li id="no" title="Cross Compiling Erlang/OTP" expanded="false">Cross Compiling Erlang/OTP<ul>
<li><a href="INSTALL-CROSS.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="INSTALL-CROSS.html#introduction">Introduction</a></li>
<li title="Build and Install Procedure"><a href="INSTALL-CROSS.html#build-and-install-procedure">Build and Install Procedure</a></li>
<li title="Building and Installing the Documentation"><a href="INSTALL-CROSS.html#building-and-installing-the-documentation">Building and Installing the Documentation</a></li>
<li title="Testing the cross compiled system"><a href="INSTALL-CROSS.html#testing-the-cross-compiled-system">Testing the cross compiled system</a></li>
<li title="Currently Used Configuration Variables"><a href="INSTALL-CROSS.html#currently-used-configuration-variables">Currently Used Configuration Variables</a></li>
</ul>
</li>
<li id="loadscrollpos" title="How to Build Erlang/OTP on Windows" expanded="true">How to Build Erlang/OTP on Windows<ul>
<li><a href="INSTALL-WIN32.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="INSTALL-WIN32.html#introduction">Introduction</a></li>
<li title="Short Version"><a href="INSTALL-WIN32.html#short-version">Short Version</a></li>
<li title="Tools you Need and Their Environment"><a href="INSTALL-WIN32.html#tools-you-need-and-their-environment">Tools you Need and Their Environment</a></li>
<li title="The Shell Environment"><a href="INSTALL-WIN32.html#the-shell-environment">The Shell Environment</a></li>
<li title="Building and Installing"><a href="INSTALL-WIN32.html#building-and-installing">Building and Installing</a></li>
<li title="Development"><a href="INSTALL-WIN32.html#development">Development</a></li>
<li title="Frequently Asked Questions"><a href="INSTALL-WIN32.html#frequently-asked-questions">Frequently Asked Questions</a></li>
</ul>
</li>
<li id="no" title="Patching OTP Applications" expanded="false">Patching OTP Applications<ul>
<li><a href="OTP-PATCH-APPLY.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="OTP-PATCH-APPLY.html#introduction">Introduction</a></li>
<li title="Prerequisites"><a href="OTP-PATCH-APPLY.html#prerequisites">Prerequisites</a></li>
<li title="Using otp_patch_apply"><a href="OTP-PATCH-APPLY.html#using-otp_patch_apply">Using otp_patch_apply</a></li>
<li title="Sanity check"><a href="OTP-PATCH-APPLY.html#sanity-check">Sanity check</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>4 How to Build Erlang/OTP on Windows</h1>

<p><strong>Table of Contents</strong></p>
  <ul>
<li>
      <span class="bold_code bc-17"><a href="#Introduction">Introduction</a></span>
    </li>
<li>
      <span class="bold_code bc-17"><a href="#Short-Version">Short Version</a></span>
    </li>
<li>
      <span class="bold_code bc-17"><a href="#Tools-you-Need-and-Their-Environment">Tools you Need and Their Environment</a></span>
    </li>
<li>
      <span class="bold_code bc-17"><a href="#The-Shell-Environment">The Shell Environment</a></span>
    </li>
<li>
      <span class="bold_code bc-17"><a href="#Building-and-Installing">Building and Installing</a></span>
    </li>
<li>
      <span class="bold_code bc-17"><a href="#Development">Development</a></span>
    </li>
<li>
      <span class="bold_code bc-17"><a href="#Frequently-Asked-Questions">Frequently Asked Questions</a></span>
  </li>
</ul>

<h3>
<a name="Introduction"></a><span onMouseOver="document.getElementById('ghlink-introduction-idm1452').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-introduction-idm1452').style.visibility = 'hidden';"><a class="title_link" name="introduction">4.1 
          Introduction</a><span id="ghlink-introduction-idm1452" class="ghlink-after"><a href="#introduction" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
This section describes how to build the Erlang emulator and the OTP
libraries on Windows. Note that the Windows binary releases are still
a preferred alternative if one does not have Microsoft’s development
tools and/or don’t want to install WSL.
</p>

<p>
The instructions apply to Windows 10 (v.1809 and later) supporting the
WSL.1 (Windows Subsystem for Linux v.1) and using Ubuntu 18.04 release.
</p>

<p>
The procedure described uses WSL as a build environment.  You run the
bash shell in WSL and use the gnu configure/make etc to do
the build. The emulator C-source code is, however, mostly compiled
with Microsoft Visual C++™, producing a native Windows binary. This is
the same procedure as we use to build the pre-built binaries. Why we
use VC++ and not gcc is explained further in the FAQ section.
</p>

<p>
These instructions apply for both 32-bit and 64-bit Windows. Note that
even if you build a 64-bit version of Erlang, most of the directories
and files involved are still named win32. Some occurrences of the name
win64 are however present. The installation file for a 64-bit Windows
version of Erlang, for example, is <span class="code">otp_win64_23.exe</span>.
</p>

<p>
If you feel comfortable with the environment and build
system, and have all the necessary tools, you have a great opportunity
to make the Erlang/OTP distribution for Windows better. Please submit
any suggestions to our <span class="bold_code bc-20"><a href="http://bugs.erlang.org">JIRA</a></span> and patches to our <span class="bold_code bc-20"><a href="https://github.com/erlang/otp">git project</a></span> to let
them find their way into the next version of Erlang. If making changes
to the build system (like makefiles etc) please bear in mind that the
same makefiles are used on Unix/VxWorks, so that your changes
don't break other platforms. That of course goes for C-code too; system
specific code resides in the <span class="code">$ERL_TOP/erts/emulator/sys/win32</span> and
<span class="code">$ERL_TOP/erts/etc/win32</span> directories mostly. The
<span class="code">$ERL_TOP/erts/emulator/beam</span> directory is for common code.
</p>



<h3>
<a name="Short-Version"></a><span onMouseOver="document.getElementById('ghlink-short-version-idm1466').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-short-version-idm1466').style.visibility = 'hidden';"><a class="title_link" name="short-version">4.2 
          Short Version</a><span id="ghlink-short-version-idm1466" class="ghlink-after"><a href="#short-version" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
In the following sections, we've described as much as we could about
the installation of the tools needed. Once the tools are installed,
building is quite easy. We have also tried to make these instructions
understandable for people with limited Unix experience. WSL is a whole
new environment to some Windows users, why careful explanation of
environment variables etc seemed to be in place.
</p>

<p>
This is the short story though, for the experienced and impatient:
</p>

<ul><li>
<p>Get and install complete WSL environment
</p>

<ul>
<li>
<p>Install Visual Studio 2019
</p>

</li>
<li>
<p>Get and install windows JDK-8
</p>

</li>
<li>
<p>Get and install windows NSIS 3.05 or later (3.05 tried and working)
</p>

</li>
<li>
<p>Get, build and install OpenSSL v1.1.1d or later (up to 1.1.1d
tried &amp; working) with static libs.
</p>

</li>
<li>
<p>Get, build and install wxWidgets-3.1.3 or later (up to 3.1.3
tried &amp; working) with static libs.
</p>

</li>
<li>
<p>Get the Erlang source distribution (from
<span class="bold_code bc-20"><a href="http://www.erlang.org/download.html">http://www.erlang.org/download.html</a></span>) and unpack with <span class="code">tar</span>
to the windows disk for example to: /mnt/c/src/
</p>

</li>
<li>
<p>Install mingw-gcc, and make: <span class="code">sudo apt install g++-mingw-w64 gcc-mingw-w64 make</span>
</p>

</li>
<li>
<p><span class="code">$ cd UNPACK_DIR</span>
</p>

</li>
<li>
<p>Modify PATH and other environment variables so that all these tools
are runnable from a bash shell. Still standing in <span class="code">$ERL_TOP</span>, issue
the following commands (for 32-bit Windows, remove the x64 from the
first row and change <span class="code">otp_win64_23</span> to <span class="code">otp_win32_23</span> on
the last row):
</p>

<div class="example example-none"><pre>$ eval `./otp_build env_win32 x64`
$ ./otp_build configure
$ ./otp_build boot -a
$ ./otp_build release -a
$ ./otp_build installer_win32
$ release/win32/otp_win64_23 /S</pre></div>
</li>
</ul>
<p>Voila! <span class="code">Start-&gt;Programs-&gt;Erlang OTP 23-&gt;Erlang</span> starts the Erlang
Windows shell.
</p>
</li></ul>


<h3>
<a name="Tools-you-Need-and-Their-Environment"></a><span onMouseOver="document.getElementById('ghlink-tools-you-need-and-their-environment-idm1503').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-tools-you-need-and-their-environment-idm1503').style.visibility = 'hidden';"><a class="title_link" name="tools-you-need-and-their-environment">4.3 
          Tools you Need and Their Environment</a><span id="ghlink-tools-you-need-and-their-environment-idm1503" class="ghlink-after"><a href="#tools-you-need-and-their-environment" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
You need some tools to be able to build Erlang/OTP on Windows. Most
notably you'll need WSL (with ubuntu), Visual Studio and
Microsofts Windows SDK, but you might also want a Java compiler, the
NSIS install system, OpenSSL and wxWidgets. Well, here's some information about
the different tools:
</p>

<ul>
<li>
<p>WSL: Install WSL and Ubuntu in Windows 10
<span class="bold_code bc-20"><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a></span>
</p>

<p>We have used and tested with WSL-1, WSL-2 was not available and may
not be prefered when building Erlang/OTP since access to the windows
disk is (currently) slower WSL-2.
</p>

</li>
<li>
<p>Visual Studio 2019
Download and run the installer from:
<span class="bold_code bc-20"><a href="http://visualstudio.microsoft.com/downloads">http://visualstudio.microsoft.com/downloads</a></span>
Install C++ and SDK packages to the default installation directory.
</p>

</li>
<li>
<p>Java JDK 8 or later  (optional)
If you don't care about Java, you can skip this step. The
result will be that jinterface is not built.
</p>

<p>Our Java code (jinterface, ic) is tested on windows with JDK 8.
Get it for Windows and install it, the JRE is not enough.
</p>

<p>URL: <span class="bold_code bc-20"><a href="http://www.oracle.com/java/technologies/javase-downloads.html">http://www.oracle.com/java/technologies/javase-downloads.html</a></span>
</p>

<p>Add javac to your path environment, in my case this means:
</p>

<div class="example example-none"><pre>`PATH="/mnt/c/Program\ Files/Java/jdk1.8.0_241/bin:$PATH`</pre></div>
<p>No <span class="code">CLASSPATH</span> or anything is needed. Type <span class="code">javac.exe</span> in the bash prompt
and you should get a list of available Java options.
</p>

</li>
<li>
<p>Nullsoft NSIS installer system (optional)
You need this to build the self installing package.
</p>

<p>Download and run the installer from:
URL: <span class="bold_code bc-20"><a href="http://nsis.sourceforge.net/download">http://nsis.sourceforge.net/download</a></span>
</p>

<p>Add 'makensis.exe' to your path environment:
</p>

<div class="example example-none"><pre> `PATH="/mnt/c/Program\ Files/NSIS/Bin:$PATH`</pre></div>
<p>Type <span class="code">which makensis.exe</span> in the bash prompt and you should get the
path to the program.
</p>

</li>
<li>
<p>OpenSSL (optional)
You need this to build crypto, ssh and ssl libs.
</p>

<p>We recommend v1.1.1d or later.
There are prebuilt avaiable binaries, which you can just
download and install, available here:
URL: <span class="bold_code bc-20"><a href="http://wiki.openssl.org/index.php/Binaries">http://wiki.openssl.org/index.php/Binaries</a></span>
</p>

<p>Install into <span class="code">C:/OpenSSL-Win64</span> (or <span class="code">C:/OpenSSL-Win32</span>)
</p>

</li>
<li>
<p>wxWidgets (optional)
You need this to build wx and use gui's in debugger and observer.
</p>

<p>We recommend v3.1.3 or later.
Unpack into <span class="code">c:/opt/local64/pgm/wxWidgets-3.1.3</span>
</p>

<p>If the <span class="code">wxUSE_POSTSCRIPT</span> isn't enabled in  <span class="code">c:/opt/local64/pgm/wxWidgets-3.1.3/include/wx/msw/setup.h</span>,
enable it.
</p>

<p>Build with:
</p>

<div class="example example-none"><pre>C:\...\&gt; cd c:\opt\local64\pgm\wxWidgets-3.1.3\build\msw
C:\...\&gt; nmake TARGET_CPU=amd64 BUILD=release SHARED=0 DIR_SUFFIX_CPU= -f makefile.vc</pre></div>
<p>Remove the <span class="code">TARGET_CPU=amd64</span> for 32bit build.
</p>

</li>
<li>
<p>Get the Erlang source distribution (from <span class="bold_code bc-20"><a href="http://www.erlang.org/download.html">http://www.erlang.org/download.html</a></span>).
The same as for Unix platforms. Preferably use tar to
unpack the source tar.gz (<span class="code">tar zxf otp_src_23.tar.gz</span>) to somewhere
on the windows disk, <span class="code">/mnt/c/path/to/otp_src</span>
</p>

<p>NOTE: It is important that source on the windows disk.
</p>

<p>Set the environment <span class="code">ERL_TOP</span> to point to the root directory of the
source distribution. Let's say I stood in <span class="code">/mnt/c/src</span> and unpacked
<span class="code">otp_src_23.tar.gz</span>, I then add the following to <span class="code">.profile</span>:
</p>

<div class="example example-none"><pre>ERL_TOP=/mnt/c/src/otp_src_23
export ERL_TOP</pre></div>
</li>
</ul>


<h3>
<a name="The-Shell-Environment"></a><span onMouseOver="document.getElementById('ghlink-the-shell-environment-idm1563').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-the-shell-environment-idm1563').style.visibility = 'hidden';"><a class="title_link" name="the-shell-environment">4.4 
          The Shell Environment</a><span id="ghlink-the-shell-environment-idm1563" class="ghlink-after"><a href="#the-shell-environment" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
The path variable should now contain the windows paths to javac.exe and makensis.exe.
</p>

<p>
Setup the environment with:
</p>

<div class="example example-none"><pre>$ export PATH
$ cd /mnt/c/path/to/otp_src/
$ eval `./otp_build env_win32 x64`</pre></div>
<p>
This should setup the additional environment variables.
</p>

<p>
This should do the final touch to the environment and building should
be easy after this. You could run <span class="code">./otp_build env_win32</span> without
<span class="code">eval</span> just to see what it does, and to see that the environment it
sets seems OK. The path is cleaned of spaces if possible (using DOS
style short names instead), the variables <span class="code">OVERRIDE_TARGET</span>, <span class="code">CC</span>, <span class="code">CXX</span>,
<span class="code">AR</span> and <span class="code">RANLIB</span> are set to their respective wrappers and the directories
<span class="code">$ERL_TOP/erts/etc/win32/wsl_tools/vc</span> and
<span class="code">$ERL_TOP/erts/etc/win32/wsl_tools</span> are added first in the PATH.
</p>

<p>
Now you can check which erlc you have by writing <span class="code">type erlc</span> in your shell.
It should reside in <span class="code">$ERL_TOP/erts/etc/win32/wsl_tools</span>.
</p>

<p>
And running <span class="code">cl.exe</span> should print the Microsoft compiler usage message.
</p>

<p>
The needed compiler environment variables are setup inside <span class="code">otp_build</span>
via <span class="code">erts/etc/win32/wsl_tools/SetupWSLcross.bat</span>. It contains some
hardcoded paths, if your installation path is different it can be added
to that file.
</p>



<h3>
<a name="Building-and-Installing"></a><span onMouseOver="document.getElementById('ghlink-building-and-installing-idm1588').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-building-and-installing-idm1588').style.visibility = 'hidden';"><a class="title_link" name="building-and-installing">4.5 
          Building and Installing</a><span id="ghlink-building-and-installing-idm1588" class="ghlink-after"><a href="#building-and-installing" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
Building is easiest using the <span class="code">otp_build</span> script:
</p>

<div class="example example-none"><pre>$ ./otp_build configure &lt;optional configure options&gt;
$ ./otp_build boot -a
$ ./otp_build release -a &lt;installation directory&gt;
$ ./otp_build installer_win32 &lt;installation directory&gt; # optional</pre></div>
<p>
Now you will have a file called <span class="code">otp_win32_23.exe</span> or <span class="code">otp_win64_23.exe</span>
in the <span class="code">&lt;installation directory&gt;</span>, i.e. <span class="code">$ERL_TOP/release/win32</span>.
</p>

<p>
Lets get into more detail:
</p>

<ul>
<li>
<p><span class="code">$ ./otp_build configure</span> - This runs the newly generated configure
scripts with options making configure behave nicely. The target machine
type is plainly <span class="code">win32</span>, so a lot of the configure-scripts recognize
this awkward target name and behave accordingly. The CC variable also
makes the compiler be <span class="code">cc.sh</span>, which wraps MSVC++, so all configure
tests regarding the C compiler gets to run the right compiler. A lot of
the tests are not needed on Windows, but we thought it best to run the
whole configure anyway.
</p>

</li>
<li>
<p><span class="code">$ ./otp_build boot -a</span> - This uses the bootstrap directory (shipped
with the source, <span class="code">$ERL_TOP/bootstrap</span>) to build a complete OTP
system. When this is done you can run erl from within the source tree;
just type <span class="code">$ERL_TOP/bin/erl</span> and you should have the prompt.
</p>

</li>
<li>
<p><span class="code">$ ./otp_build release -a</span> - Builds a commercial release tree from the
source tree. The default is to put it in <span class="code">$ERL_TOP/release/win32</span>. You can
give any directory as parameter, but it doesn't really
matter if you're going to build a self extracting installer too.
</p>

</li>
<li>
<p><span class="code">$ ./otp_build installer_win32</span> - Creates the self extracting installer executable.
The executable <span class="code">otp_win32_23.exe</span> or <span class="code">otp_win64_23.exe</span> will be placed
in the top directory of the release created in the previous step. If
no release directory is specified, the release is expected to have
been built to <span class="code">$ERL_TOP/release/win32</span>, which also will be the place
where the installer executable will be placed. If you specified some
other directory for the release (i.e. <span class="code">./otp_build release -a
/tmp/erl_release</span>), you're expected to give the same parameter here,
(i.e. <span class="code">./otp_build installer_win32 /tmp/erl_release</span>). You need to have
a full NSIS installation and <span class="code">makensis.exe</span> in your path for this to
work. Once you have created the installer, you can run it to
install Erlang/OTP in the regular way, just run the executable and
follow the steps in the installation wizard. To get all default settings
in the installation without any questions asked, you run the executable
with the parameter <span class="code">/S</span> (capital S) like in:
</p>

<div class="example example-none"><pre>$ cd $ERL_TOP
$ release/win32/otp_win32_23 /S
...</pre></div>
<p>or
</p>

<div class="example example-none"><pre>$ cd $ERL_TOP
$ release/win32/otp_win64_23 /S
...</pre></div>
<p>and after a while Erlang/OTP-23 will have been installed in
<span class="code">C:\Program Files\erl11.2.2.18\</span>, with shortcuts in the menu etc.
</p>
</li>
</ul>


<h3>
<a name="Development"></a><span onMouseOver="document.getElementById('ghlink-development-idm1630').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-development-idm1630').style.visibility = 'hidden';"><a class="title_link" name="development">4.6 
          Development</a><span id="ghlink-development-idm1630" class="ghlink-after"><a href="#development" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<p>
Once the system is built, you might want to change it. Having a test
release in some nice directory might be useful, but you can also run
Erlang from within the source tree. The target <span class="code">local_setup</span>, makes
the program <span class="code">$ERL_TOP/bin/erl.exe</span> usable and it also uses all the OTP
libraries in the source tree.
</p>

<p>
If you hack the emulator, you can build the emulator executable
by standing in <span class="code">$ERL_TOP/erts/emulator</span> and do a simple
</p>

<div class="example example-none"><pre>$ make opt</pre></div>
<p>
Note that you need to have run <span class="code">(cd $ERL_TOP &amp;&amp; eval `./otp_build env_win32`)</span>
in the particular shell before building anything on Windows. After
doing a make opt you can test your result by running <span class="code">$ERL_TOP/bin/erl</span>.
If you want to copy the result to a release directory (say
<span class="code">/tmp/erl_release</span>), you do this (still in  <span class="code">$ERL_TOP/erts/emulator</span>)
</p>

<div class="example example-none"><pre>$ make TESTROOT=/tmp/erl_release release</pre></div>
<p>
That will copy the emulator executables.
</p>

<p>
To make a debug build of the emulator, you need to recompile both
<span class="code">beam.dll</span> (the actual runtime system) and <span class="code">erlexec.dll</span>. Do like this
</p>

<div class="example example-none"><pre>$ cd $ERL_TOP
$ rm bin/win32/erlexec.dll
$ cd erts/emulator
$ make debug
$ cd ../etc
$ make debug</pre></div>
<p>
and sometimes
</p>

<div class="example example-none"><pre>$ cd $ERL_TOP
$ make local_setup</pre></div>
<p>
So now when you run <span class="code">$ERL_TOP/erl.exe</span>, you should have a debug compiled
emulator, which you will see if you do a:
</p>

<div class="example example-none"><pre>1&gt; erlang:system_info(system_version).</pre></div>
<p>
in the erlang shell. If the returned string contains <span class="code">[debug]</span>, you
got a debug compiled emulator.
</p>

<p>
To hack the erlang libraries, you simply do a <span class="code">make opt</span> in the
specific "applications" directory, like:
</p>

<div class="example example-none"><pre>$ cd $ERL_TOP/lib/stdlib
$ make opt</pre></div>
<p>
or even in the source directory...
</p>

<div class="example example-none"><pre>$ cd $ERL_TOP/lib/stdlib/src
$ make opt</pre></div>
<p>
Note that you're expected to have a fresh Erlang in your path when
doing this, preferably the plain 23 you have built in the previous
steps. You could also add <span class="code">$ERL_TOP/bootstrap/bin</span> to your <span class="code">PATH</span> before
rebuilding specific libraries. That would give you a good enough
Erlang system to compile any OTP erlang code.  Setting up the path
correctly is a little bit tricky. You still need to have
<span class="code">$ERL_TOP/erts/etc/win32/wsl_tools/vc</span> and
<span class="code">$ERL_TOP/erts/etc/win32/wsl_tools</span> <strong>before</strong> the actual emulator
in the path. A typical setting of the path for using the bootstrap
compiler would be:
</p>

<div class="example example-none"><pre>$ export PATH=$ERL_TOP/erts/etc/win32/wsl_tools/vc\
:$ERL_TOP/erts/etc/win32/wsl_tools:$ERL_TOP/bootstrap/bin:$PATH</pre></div>
<p>
That should make it possible to rebuild any library without hassle...
</p>

<p>
If you want to copy a library (an application) newly built, to a
release area, you do like with the emulator:
</p>

<div class="example example-none"><pre>$ cd $ERL_TOP/lib/stdlib
$ make TESTROOT=/tmp/erlang_release release</pre></div>
<p>
Remember that:
</p>

<ul>
<li>
<p>Windows specific C-code goes in the <span class="code">$ERL_TOP/erts/emulator/sys/win32</span>,
<span class="code">$ERL_TOP/erts/emulator/drivers/win32</span> or <span class="code">$ERL_TOP/erts/etc/win32</span>.
</p>

</li>
<li>
<p>Windows specific erlang code should be used conditionally and the
host OS tested in <strong>runtime</strong>, the exactly same beam files should be
distributed for every platform! So write code like:
</p>

<div class="example example-none"><pre>case os:type() of
    {win32,_} -&gt;
        do_windows_specific();
    Other -&gt;
        do_fallback_or_exit()
end,</pre></div>
</li>
</ul>
<p>
That's basically all you need to get going.
</p>



<h3>
<a name="Frequently-Asked-Questions"></a><span onMouseOver="document.getElementById('ghlink-frequently-asked-questions-idm1684').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-frequently-asked-questions-idm1684').style.visibility = 'hidden';"><a class="title_link" name="frequently-asked-questions">4.7 
          Frequently Asked Questions</a><span id="ghlink-frequently-asked-questions-idm1684" class="ghlink-after"><a href="#frequently-asked-questions" title="Link to this place!"><span class="paperclip-after"></span></a></span></span>
</h3>



<ul>
<li>
<p>Q: So, now I can build Erlang using GCC on Windows?
</p>

<p>A: No, unfortunately not. You'll need Microsoft's Visual C++
still. A Bourne-shell script (cc.sh) wraps the Visual C++ compiler
and runs it from within the WSL environment. All other tools
needed to build Erlang are free-ware/open source, but not the C
compiler.
</p>

</li>
<li>
<p>Q: Why haven't you got rid of VC++ then, you ******?
</p>

<p>A: Well, partly because it's a good compiler - really! Actually it's
been possible in late R11-releases to build using mingw instead of
visual C++ (you might see the remnants of that in some scripts and
directories). Unfortunately the development of the SMP version for
Windows broke the mingw build and we chose to focus on the VC++ build
as the performance has been much better in the VC++ versions. The
mingw build will possibly be back, but as long as VC++ gives better
performance, the commercial build will be a VC++ one.
</p>

</li>
<li>
<p>Q: Hah, I saw you, you used GCC even though you said you didn't!
</p>

<p>A: OK, I admit, one of the files is compiled using
MinGW's GCC and the resulting object code is then converted to MS
VC++ compatible coff using a small C hack. It's because that
particular file, <span class="code">beam_emu.c</span> benefits immensely from being able
to use the GCC labels-as-values extension, which boosts emulator
performance by up to 50%. That does unfortunately not (yet) mean
that all of OTP could be compiled using GCC. That particular
source code does not do anything system specific and actually is
adopted to the fact that GCC is used to compile it on Windows.
</p>

</li>
<li>
<p>Q: So now there's a MS VC++ project file somewhere and I can build OTP
using the nifty VC++ GUI?
</p>

<p>A: No, never. The hassle of keeping the project files up to date and
do all the steps that constitute an OTP build from within the VC++ GUI
is simply not worth it, maybe even impossible. A VC++ project
file for Erlang/OTP will never happen.
</p>

</li>
<li>
<p>Q: So how does it all work then?
</p>

<p>A: WSL/Ubuntu is the environment, it's almost like you had a
virtual Unix machine inside Windows. Configure, given certain
parameters, then creates makefiles that are used by the
environment's gnu-make to built the system. Most of the actual
compilers etc are not, however, WSL tools, so we've written
a couple of wrappers (Bourne-shell scripts), which reside in
<span class="code">$ERL_TOP/etc/win32/wsl_tools</span>. They all do conversion of
parameters and switches common in the Unix environment to fit the
native Windows tools. Most notable is of course the paths, which
in WSL are Unix-like paths with "forward slashes" (/) and
no drive letters. The WSL specific command <span class="code">wslpath</span> is used
for most of the path conversions in a WSL environment.
Luckily most compilers accept forward slashes instead
of backslashes as path separators, but one still have to get the drive
letters etc right, though. The wrapper scripts are not general in
the sense that, for example, cc.sh would understand and translate
every possible gcc option and pass correct options to
cl.exe. The principle is that the scripts are powerful enough to
allow building of Erlang/OTP, no more, no less. They might need
extensions to cope with changes during the development of Erlang, and
that's one of the reasons we made them into shell-scripts and not
Perl-scripts. We believe they are easier to understand and change
that way.
</p>

<p>In <span class="code">$ERL_TOP</span>, there is a script called <span class="code">otp_build</span>. That script handles
the hassle of giving all the right parameters to <span class="code">configure</span>/<span class="code">make</span> and
also helps you set up the correct environment variables to work with
the Erlang source under WSL.
</p>

</li>
<li>
<p>Q: Can I build something that looks exactly as the commercial release?
</p>

<p>A: Yes, we use the exact same build procedure.
</p>

</li>
<li>
<p>Q: Which version of WSL and other tools do you use then?
</p>

<p>A:  We use WSL 1 with Ubuntu 18.04.
The GCC we used for 23 was version 7.3-win32.
We used Visual studio 2019, Sun's JDK 1.8.0_241,
NSIS 3.05, Win32 OpenSSL 1.1.1d and wxWidgets-3.1.3.
</p>


</li>
</ul>


</div>
<div class="footer">
<hr>
<p>Copyright © 1997-2024 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../js/';</script><script type="text/javascript" src="../js/highlight.js"></script>
</body>
</html>
