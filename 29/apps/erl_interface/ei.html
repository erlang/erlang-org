<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.38.1">
    <meta name="project" content="erl_interface v5.6-rc0">


<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=29&q=">
<meta name="major-vsn" content="29">
<link rel="canonical" href="https://www.erlang.org/docs/29/apps/erl_interface/ei.html" />
    <title>ei — erl_interface v5.6-rc0</title>

    <link rel="stylesheet" href="dist/html-erlang-ZK43ZOAC.css" />

    <script defer src="dist/sidebar_items-6AF843C2.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-DPJLHKSM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="erl_interface" />
        </a>

      <div>
        <a href="../../index.html" class="sidebar-projectName" translate="no">
erl_interface
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v5.6-rc0
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of erl_interface</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>ei</h1>


      <a href="https://github.com/erlang/otp/blob/master/lib/erl_interface/doc/references/ei.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<p>Routines for handling the Erlang binary term format.</p><h2 id="description" class="section-heading"><a href="#description" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Description</span></h2><p>The library <code class="inline">ei</code> contains macros and functions to encode and decode the Erlang
binary term format.</p><p><code class="inline">ei</code> allows you to convert atoms, lists, numbers, and binaries to and from the
binary format. This is useful when writing port programs and drivers. <code class="inline">ei</code> uses
a given buffer, no dynamic memory (except <code class="inline">ei_decode_fun()</code>) and is often quite
fast.</p><p><code class="inline">ei</code> also handles C-nodes, C-programs that talks Erlang distribution with Erlang
nodes (or other C-nodes) using the Erlang distribution format.The <code class="inline">ei</code> library
is thread safe, and using threads, one process can handle multiple C-nodes.</p><p>The decode and encode functions use a buffer and an index into the buffer, which
points at the point where to encode and decode. The index is updated to point
right after the term encoded/decoded. No checking is done whether the term fits
in the buffer or not. If encoding goes outside the buffer, the program can
crash.</p><p>All functions take two parameters:</p><ul><li><code class="inline">buf</code> is a pointer to the buffer where the binary data is or will be.</li><li><code class="inline">index</code> is a pointer to an index into the buffer. This parameter is
incremented with the size of the term decoded/encoded.</li></ul><p>The data is thus at <code class="inline">buf[*index]</code> when an <code class="inline">ei</code> function is called.</p><p>All encode functions assume that the <code class="inline">buf</code> and <code class="inline">index</code> parameters point to a
buffer large enough for the data. Note that the binary term format uses variable-
length encoding so different values can require a different amount of space. For
example, smaller integer values can be more compact than larger ones. To get
the size of an encoded term, without encoding it, pass <code class="inline">NULL</code> instead of a
buffer pointer. Parameter <code class="inline">index</code> is incremented, but nothing will be encoded.
This is the way in <code class="inline">ei</code> to &quot;preflight&quot; term encoding.</p><p>There are also encode functions that use a dynamic buffer. It is often more
convenient to use these to encode data. All encode functions comes in two
versions; those starting with <code class="inline">ei_x_</code> use a dynamic buffer of type
<a href="ei.html#ei_x_buff"><code class="inline">ei_x_buff</code></a>.</p><p>All functions return <code class="inline">0</code> if successful, otherwise <code class="inline">-1</code> (for example, if a term
is not of the expected type, or the data to decode is an invalid Erlang term).</p><p>Some of the decode functions need a pre-allocated buffer. This buffer must be
allocated large enough, and for non-compound types the
<a href="ei.html#ei_get_type"><code class="inline">ei_get_type()</code></a> function returns the size required (notice
that for strings an extra byte is needed for the <code class="inline">NULL</code>-terminator).</p><h2 id="data-types" class="section-heading"><a href="#data-types" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Data Types</span></h2><ul><li><p><strong><code class="inline" id="ei_term">ei_term</code></strong></p><pre><code class="makeup c" translate="no"><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p" data-group-id="2323061417-1">{</span><span class="w">
    </span><span class="kt">char</span><span class="w"> </span><span class="n">ei_type</span><span class="p">;</span><span class="w">
    </span><span class="kt">int</span><span class="w"> </span><span class="n">arity</span><span class="p">;</span><span class="w">
    </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">
    </span><span class="k">union</span><span class="w"> </span><span class="p" data-group-id="2323061417-2">{</span><span class="w">
  </span><span class="kt">long</span><span class="w"> </span><span class="n">i_val</span><span class="p">;</span><span class="w">
  </span><span class="kt">double</span><span class="w"> </span><span class="n">d_val</span><span class="p">;</span><span class="w">
  </span><span class="kt">char</span><span class="w"> </span><span class="n">atom_name</span><span class="p" data-group-id="2323061417-3">[</span><span class="no">MAXATOMLEN_UTF8</span><span class="p" data-group-id="2323061417-3">]</span><span class="p">;</span><span class="w">
  </span><span class="n">erlang_pid</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span><span class="w">
  </span><span class="n">erlang_port</span><span class="w"> </span><span class="n">port</span><span class="p">;</span><span class="w">
  </span><span class="n">erlang_ref</span><span class="w"> </span><span class="n">ref</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="2323061417-2">}</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="2323061417-1">}</span><span class="w"> </span><span class="n">ei_term</span><span class="p">;</span></code></pre><p>Structure written by <a href="ei.html#ei_decode_ei_term"><code class="inline">ei_decode_ei_term()</code></a>. The
<code class="inline">ei_type</code> field is the type of the term which equals to what
<a href="ei.html#ei_get_type"><code class="inline">ei_get_type()</code></a> sets <code class="inline">*type</code> to.</p></li><li><p><strong><code class="inline" id="ei_x_buff">ei_x_buff</code></strong> - A dynamically resized buffer. It is a
<code class="inline">struct</code> with two fields of interest for the user:</p><ul><li><p><strong><code class="inline">char *buff</code></strong> - Pointer to the dynamically allocated buffer.</p></li><li><p><strong><code class="inline">int index</code></strong> - Offset to the next byte to write which also equals the
amount of bytes currently written.</p></li></ul><p>An <code class="inline">ei_x_buff</code> is initialized by calling either <a href="ei.html#ei_x_new"><code class="inline">ei_x_new()</code></a>
or <a href="ei.html#ei_x_new_with_version"><code class="inline">ei_x_new_with_version()</code></a>. The memory used
by an initialized <code class="inline">ei_x_buff</code> is released by calling
<a href="ei.html#ei_x_free"><code class="inline">ei_x_free()</code></a>.</p></li><li><p><strong><code class="inline" id="erlang_char_encoding">erlang_char_encoding</code></strong></p><pre><code class="makeup c" translate="no"><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p" data-group-id="0746688303-1">{</span><span class="w">
    </span><span class="no">ERLANG_ASCII</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="no">ERLANG_LATIN1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
    </span><span class="no">ERLANG_UTF8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span><span class="p" data-group-id="0746688303-1">}</span><span class="w"> </span><span class="n">erlang_char_encoding</span><span class="p">;</span></code></pre><p>The character encodings used for atoms. <code class="inline">ERLANG_ASCII</code> represents 7-bit ASCII.
Latin-1 and UTF-8 are different extensions of 7-bit ASCII. All 7-bit ASCII
characters are valid Latin-1 and UTF-8 characters. ASCII and Latin-1 both
represent each character by one byte. An UTF-8 character can consist of 1-4
bytes. Notice that these constants are bit-flags and can be combined with
bitwise OR.</p></li><li><p><strong><code class="inline" id="erlang_fun">erlang_fun</code></strong> - Opaque data type representing an Erlang
fun.</p></li><li><p><strong><code class="inline" id="erlang_pid">erlang_pid</code></strong> - Opaque data type representing an Erlang
process identifier.</p></li><li><p><strong><code class="inline" id="erlang_port">erlang_port</code></strong> - Opaque data type representing an Erlang
port identifier.</p></li><li><p><strong><code class="inline" id="erlang_ref">erlang_ref</code></strong> - Opaque data type representing an Erlang
reference.</p></li><li><p><strong><code class="inline" id="erlang_trace">erlang_trace</code></strong> - Opaque data type representing an Erlang
sequential trace token.</p></li></ul><h2 id="ei_cmp_pids" class="section-heading"><a href="#ei_cmp_pids" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_cmp_pids()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_cmp_pids</span><span class="p" data-group-id="7424248986-1">(</span><span class="n">erlang_pid</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_pid</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p" data-group-id="7424248986-1">)</span><span class="p">;</span></code></pre><p>Compare two process identifiers. The comparison is done the same way as Erlang
does.</p><p>Returns <code class="inline">0</code> if <code class="inline">a</code> and <code class="inline">b</code> are equal. Returns a value less than <code class="inline">0</code> if <code class="inline">a</code>
compares as less than <code class="inline">b</code>. Returns a value larger than <code class="inline">0</code> if <code class="inline">a</code> compares as
larger than <code class="inline">b</code>.</p><p>Available since OTP 23.0</p><h2 id="ei_cmp_ports" class="section-heading"><a href="#ei_cmp_ports" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_cmp_ports()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_cmp_ports</span><span class="p" data-group-id="8131723322-1">(</span><span class="n">erlang_port</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_port</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p" data-group-id="8131723322-1">)</span><span class="p">;</span></code></pre><p>Compare two port identifiers. The comparison is done the same way as Erlang
does.</p><p>Returns <code class="inline">0</code> if <code class="inline">a</code> and <code class="inline">b</code> are equal. Returns a value less than <code class="inline">0</code> if <code class="inline">a</code>
compares as less than <code class="inline">b</code>. Returns a value larger than <code class="inline">0</code> if <code class="inline">a</code> compares as
larger than <code class="inline">b</code>.</p><p>Available since OTP 23.0</p><h2 id="ei_cmp_refs" class="section-heading"><a href="#ei_cmp_refs" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_cmp_refs()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_cmp_refs</span><span class="p" data-group-id="8039388183-1">(</span><span class="n">erlang_ref</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_ref</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p" data-group-id="8039388183-1">)</span><span class="p">;</span></code></pre><p>Compare two references. The comparison is done the same way as Erlang does.</p><p>Returns <code class="inline">0</code> if <code class="inline">a</code> and <code class="inline">b</code> are equal. Returns a value less than <code class="inline">0</code> if <code class="inline">a</code>
compares as less than <code class="inline">b</code>. Returns a value larger than <code class="inline">0</code> if <code class="inline">a</code> compares as
larger than <code class="inline">b</code>.</p><p>Available since OTP 23.0</p><h2 id="ei_decode_atom" class="section-heading"><a href="#ei_decode_atom" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_atom()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_atom</span><span class="p" data-group-id="3483559297-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="3483559297-1">)</span><span class="p">;</span></code></pre><p>Decodes an atom from the binary format. The <code class="inline">NULL</code>-terminated name of the atom
is placed at <code class="inline">p</code>. At most <code class="inline">MAXATOMLEN</code> bytes can be placed in the buffer.</p><h2 id="ei_decode_atom_as" class="section-heading"><a href="#ei_decode_atom_as" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_atom_as()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_atom_as</span><span class="p" data-group-id="3362587502-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">plen</span><span class="p">,</span><span class="w">
  </span><span class="n">erlang_char_encoding</span><span class="w"> </span><span class="n">want</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_char_encoding</span><span class="o">*</span><span class="w"> </span><span class="n">was</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_char_encoding</span><span class="o">*</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="3362587502-1">)</span><span class="p">;</span></code></pre><p>Decodes an atom from the binary format. The <code class="inline">NULL</code>-terminated name of the atom
is placed in buffer at <code class="inline">p</code> of length <code class="inline">plen</code> bytes.</p><p>The wanted string encoding is specified by <a href="ei.html#erlang_char_encoding"><code class="inline">want</code></a>.
The original encoding used in the binary format (Latin-1 or UTF-8) can be
obtained from <code class="inline">*was</code>. The encoding of the resulting string (7-bit ASCII,
Latin-1, or UTF-8) can be obtained from <code class="inline">*result</code>. Both <code class="inline">was</code> and <code class="inline">result</code> can
be <code class="inline">NULL</code>. <code class="inline">*result</code> can differ from <code class="inline">want</code> if <code class="inline">want</code> is a bitwise OR'd
combination like <code class="inline">ERLANG_LATIN1|ERLANG_UTF8</code> or if <code class="inline">*result</code> turns out to be
pure 7-bit ASCII (compatible with both Latin-1 and UTF-8).</p><p>This function fails if the atom is too long for the buffer or if it cannot be
represented with encoding <code class="inline">want</code>.</p><p>This function was introduced in Erlang/OTP R16 as part of a first step to
support UTF-8 atoms.</p><p>Available since OTP R16B</p><h2 id="ei_decode_bignum" class="section-heading"><a href="#ei_decode_bignum" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_bignum()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_bignum</span><span class="p" data-group-id="0903991977-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">mpz_t</span><span class="w"> </span><span class="n">obj</span><span class="p" data-group-id="0903991977-1">)</span><span class="p">;</span></code></pre><p>Decodes an integer in the binary format to a GMP <code class="inline">mpz_t</code> integer. To use this
function, the <code class="inline">ei</code> library must be configured and compiled to use the GMP
library.</p><h2 id="ei_decode_binary" class="section-heading"><a href="#ei_decode_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_binary</span><span class="p" data-group-id="4878266692-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">len</span><span class="p" data-group-id="4878266692-1">)</span><span class="p">;</span></code></pre><p>Decodes a binary from the binary format. Parameter <code class="inline">len</code> is set to the actual
size of the binary. Notice that <code class="inline">ei_decode_binary()</code> assumes that there is
enough room for the binary. The size required can be fetched by
<a href="ei.html#ei_get_type"><code class="inline">ei_get_type()</code></a>.</p><h2 id="ei_decode_bitstring" class="section-heading"><a href="#ei_decode_bitstring" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_bitstring()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_bitstring</span><span class="p" data-group-id="0808451742-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="o">*</span><span class="n">pp</span><span class="p">,</span><span class="w">
  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">bitoffsp</span><span class="p">,</span><span class="w"> </span><span class="n">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">nbitsp</span><span class="p" data-group-id="0808451742-1">)</span><span class="p">;</span></code></pre><p>Decodes a bit string from the binary format.</p><ul><li><p><strong><code class="inline">pp</code></strong> - Either <code class="inline">NULL</code> or <code class="inline">*pp</code> returns a pointer to the first byte of the
bit string. The returned bit string is readable as long as the buffer pointed
to by <code class="inline">buf</code> is readable and not written to.</p></li><li><p><strong><code class="inline">bitoffsp</code></strong> - Either <code class="inline">NULL</code> or <code class="inline">*bitoffsp</code> returns the number of unused
bits in the first byte pointed to by <code class="inline">*pp</code>. The value of <code class="inline">*bitoffsp</code> is
between 0 and 7. Unused bits in the first byte are the most significant bits.</p></li><li><p><strong><code class="inline">nbitsp</code></strong> - Either <code class="inline">NULL</code> or <code class="inline">*nbitsp</code> returns the length of the bit string
in <em>bits</em>.</p></li></ul><p>Returns <code class="inline">0</code> if it was a bit string term.</p><p>The number of <em>bytes</em> pointed to by <code class="inline">*pp</code>, which are part of the bit string, is
<code class="inline">(*bitoffsp + *nbitsp + 7)/8</code>. If <code class="inline">(*bitoffsp + *bitsp)%8 &gt; 0</code> then only
<code class="inline">(*bitoffsp + *bitsp)%8</code> bits of the last byte are used. Unused bits in the last
byte are the least significant bits.</p><p>The values of unused bits in the first and last byte are undefined and cannot be
relied on.</p><p>Number of bits may be divisible by 8, which means a binary decodable by
<code class="inline">ei_decode_binary</code> is also decodable by <code class="inline">ei_decode_bitstring</code>.</p><p>Available since OTP 22.0</p><h2 id="ei_decode_boolean" class="section-heading"><a href="#ei_decode_boolean" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_boolean()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_boolean</span><span class="p" data-group-id="4735055754-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="4735055754-1">)</span><span class="p">;</span></code></pre><p>Decodes a boolean value from the binary format. A boolean is actually an atom,
<code class="inline">true</code> decodes 1 and <code class="inline">false</code> decodes 0.</p><h2 id="ei_decode_char" class="section-heading"><a href="#ei_decode_char" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_char()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_char</span><span class="p" data-group-id="6855675853-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="6855675853-1">)</span><span class="p">;</span></code></pre><p>Decodes a char (8-bit) integer between 0-255 from the binary format. For
historical reasons the returned integer is of type <code class="inline">char</code>. Your C code is to
consider the returned value to be of type <code class="inline">unsigned char</code> even if the C
compilers and system can define <code class="inline">char</code> to be signed.</p><h2 id="ei_decode_double" class="section-heading"><a href="#ei_decode_double" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_double()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_double</span><span class="p" data-group-id="7230933819-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="7230933819-1">)</span><span class="p">;</span></code></pre><p>Decodes a double-precision (64-bit) floating point number from the binary
format.</p><h2 id="ei_decode_ei_term" class="section-heading"><a href="#ei_decode_ei_term" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_ei_term()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_ei_term</span><span class="p" data-group-id="7998946335-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">ei_term</span><span class="o">*</span><span class="w"> </span><span class="n">term</span><span class="p" data-group-id="7998946335-1">)</span><span class="p">;</span></code></pre><p>Decodes any term, or at least tries to. If the term pointed at by <code class="inline">*index</code> in
<code class="inline">buf</code> fits in the <code class="inline">term</code> union, it is decoded, and the appropriate field in
<code class="inline">term-&gt;value</code> is set, and <code class="inline">*index</code> is incremented by the term size.</p><p>The function returns <code class="inline">1</code> on successful decoding, <code class="inline">-1</code> on error, and <code class="inline">0</code> if the
term seems alright, but does not fit in the <code class="inline">term</code> structure. If <code class="inline">1</code> is
returned, the <code class="inline">index</code> is incremented, and <code class="inline">term</code> contains the decoded term.</p><p>The <code class="inline">term</code> structure contains the arity for a tuple or list, size for a binary,
string, or atom. It contains a term if it is any of the following: integer,
float, atom, pid, port, or ref.</p><h2 id="ei_decode_fun" class="section-heading"><a href="#ei_decode_fun" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_fun()</span></h2><h2 id="free_fun" class="section-heading"><a href="#free_fun" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">free_fun()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_fun</span><span class="p" data-group-id="5000467250-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_fun</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="5000467250-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">free_fun</span><span class="p" data-group-id="3884135022-1">(</span><span class="n">erlang_fun</span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p" data-group-id="3884135022-1">)</span><span class="p">;</span></code></pre><p>Decodes a fun from the binary format. Parameter <code class="inline">p</code> is to be <code class="inline">NULL</code> or point to
an <code class="inline">erlang_fun</code> structure. This is the only decode function that allocates
memory. When the <code class="inline">erlang_fun</code> is no longer needed, it is to be freed with
<code class="inline">free_fun</code>. (This has to do with the arbitrary size of the environment for a
fun.)</p><h2 id="ei_decode_iodata" class="section-heading"><a href="#ei_decode_iodata" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_iodata()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_iodata</span><span class="p" data-group-id="3641047575-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">outbuf</span><span class="p" data-group-id="3641047575-1">)</span><span class="p">;</span></code></pre><p>Decodes a term of the type <a href="../../system/typespec.html#builtin_types"><code class="inline">iodata()</code></a>.
The <a href="../../apps/erts/erlang.html#t:iodata/0"><code class="inline">iodata/0</code></a> term will be flattened an written into the buffer pointed to by
the <code class="inline">outbuf</code> argument. The byte size of the <code class="inline">iodata</code> is written into the integer
variable pointed to by the <code class="inline">size</code> argument. Both <code class="inline">size</code> and <code class="inline">outbuf</code> can be set
to <code class="inline">NULL</code>. The integer pointed to by the <code class="inline">index</code> argument is updated to refer to
the term following after the <a href="../../apps/erts/erlang.html#t:iodata/0"><code class="inline">iodata/0</code></a> term regardless of the the state of
the <code class="inline">size</code> and the <code class="inline">outbuf</code> arguments.</p><p>Note that the buffer pointed to by the <code class="inline">outbuf</code> argument must be large enough if
a non <code class="inline">NULL</code> value is passed as <code class="inline">outbuf</code>. You typically want to call
<code class="inline">ei_decode_iodata()</code> twice. First with a non <code class="inline">NULL</code> <code class="inline">size</code> argument and a <code class="inline">NULL</code>
<code class="inline">outbuf</code> argument in order to determine the size of the buffer needed, and then
once again in order to do the actual decoding. Note that the integer pointed to
by <code class="inline">index</code> will be updated by the call determining the size as well, so you need
to reset it before the second call doing the actual decoding.</p><p>Returns <code class="inline">0</code> on success and <code class="inline">-1</code> on failure. Failure might be either due to
invalid encoding of the term or due to the term not being of the type
<a href="../../apps/erts/erlang.html#t:iodata/0"><code class="inline">iodata/0</code></a>. On failure, the integer pointed to by the <code class="inline">index</code> argument will be
updated to refer to the sub term where the failure was detected.</p><p>Available since OTP 23.0</p><h2 id="ei_decode_list_header" class="section-heading"><a href="#ei_decode_list_header" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_list_header()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_list_header</span><span class="p" data-group-id="8817742809-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">arity</span><span class="p" data-group-id="8817742809-1">)</span><span class="p">;</span></code></pre><p>Decodes a list header from the binary format. The number of elements is returned
in <code class="inline">arity</code>. The <code class="inline">arity+1</code> elements follow (the last one is the tail of the list,
normally an empty list). If <code class="inline">arity</code> is <code class="inline">0</code>, it is an empty list.</p><p>Notice that lists are encoded as strings if they consist entirely of integers in
the range 0..255. This function do not decode such strings, use
<code class="inline">ei_decode_string()</code> instead.</p><h2 id="ei_decode_long" class="section-heading"><a href="#ei_decode_long" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_long()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_long</span><span class="p" data-group-id="4430856303-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="4430856303-1">)</span><span class="p">;</span></code></pre><p>Decodes a long integer from the binary format. If the code is 64 bits, the
function <code class="inline">ei_decode_long()</code> is the same as <code class="inline">ei_decode_longlong()</code>.</p><h2 id="ei_decode_longlong" class="section-heading"><a href="#ei_decode_longlong" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_longlong()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_longlong</span><span class="p" data-group-id="1083487440-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="1083487440-1">)</span><span class="p">;</span></code></pre><p>Decodes a GCC <code class="inline">long long</code> or Visual C++ <code class="inline">__int64</code> (64-bit) integer from the
binary format.</p><h2 id="ei_decode_map_header" class="section-heading"><a href="#ei_decode_map_header" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_map_header()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_map_header</span><span class="p" data-group-id="6398788583-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">arity</span><span class="p" data-group-id="6398788583-1">)</span><span class="p">;</span></code></pre><p>Decodes a map header from the binary format. The number of key-value pairs is
returned in <code class="inline">*arity</code>. Keys and values follow in this order:
<code class="inline">K1, V1, K2, V2, ..., Kn, Vn</code>. This makes a total of <code class="inline">arity*2</code> terms. If <code class="inline">arity</code>
is zero, it is an empty map. A correctly encoded map does not have duplicate
keys.</p><p>Available since OTP 17.0</p><h2 id="ei_decode_pid" class="section-heading"><a href="#ei_decode_pid" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_pid()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_pid</span><span class="p" data-group-id="4339920439-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_pid</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="4339920439-1">)</span><span class="p">;</span></code></pre><p>Decodes a process identifier (pid) from the binary format.</p><h2 id="ei_decode_port" class="section-heading"><a href="#ei_decode_port" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_port()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_port</span><span class="p" data-group-id="4572839549-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_port</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="4572839549-1">)</span><span class="p">;</span></code></pre><p>Decodes a port identifier from the binary format.</p><h2 id="ei_decode_ref" class="section-heading"><a href="#ei_decode_ref" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_ref()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_ref</span><span class="p" data-group-id="2889873481-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_ref</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="2889873481-1">)</span><span class="p">;</span></code></pre><p>Decodes a reference from the binary format.</p><h2 id="ei_decode_string" class="section-heading"><a href="#ei_decode_string" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_string()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_string</span><span class="p" data-group-id="3801461181-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="3801461181-1">)</span><span class="p">;</span></code></pre><p>Decodes a string from the binary format. A string in Erlang is a list of
integers between 0 and 255. Notice that as the string is just a list, sometimes
lists are encoded as strings by <a href="../../apps/erts/erlang.html#term_to_binary/1"><code class="inline">term_to_binary/1</code></a>, even
if it was not intended.</p><p>The string is copied to <code class="inline">p</code>, and enough space must be allocated. The returned
string is <code class="inline">NULL</code>-terminated, so you must add an extra byte to the memory
requirement.</p><h2 id="ei_decode_trace" class="section-heading"><a href="#ei_decode_trace" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_trace()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_trace</span><span class="p" data-group-id="2563684122-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_trace</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="2563684122-1">)</span><span class="p">;</span></code></pre><p>Decodes an Erlang trace token from the binary format.</p><h2 id="ei_decode_tuple_header" class="section-heading"><a href="#ei_decode_tuple_header" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_tuple_header()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_tuple_header</span><span class="p" data-group-id="0589379428-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">arity</span><span class="p" data-group-id="0589379428-1">)</span><span class="p">;</span></code></pre><p>Decodes a tuple header, the number of elements is returned in <code class="inline">arity</code>. The tuple
elements follow in order in the buffer.</p><h2 id="ei_decode_ulong" class="section-heading"><a href="#ei_decode_ulong" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_ulong()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_ulong</span><span class="p" data-group-id="7300180724-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="7300180724-1">)</span><span class="p">;</span></code></pre><p>Decodes an unsigned long integer from the binary format. If the code is 64 bits,
the function <code class="inline">ei_decode_ulong()</code> is the same as <code class="inline">ei_decode_ulonglong()</code>.</p><h2 id="ei_decode_ulonglong" class="section-heading"><a href="#ei_decode_ulonglong" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_ulonglong()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_ulonglong</span><span class="p" data-group-id="8431676719-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="8431676719-1">)</span><span class="p">;</span></code></pre><p>Decodes a GCC <code class="inline">unsigned long long</code> or Visual C++ <code class="inline">unsigned __int64</code> (64-bit)
integer from the binary format.</p><h2 id="ei_decode_version" class="section-heading"><a href="#ei_decode_version" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_decode_version()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_decode_version</span><span class="p" data-group-id="8954771871-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">version</span><span class="p" data-group-id="8954771871-1">)</span><span class="p">;</span></code></pre><p>Decodes the version magic number for the Erlang binary term format. It must be
the first token in a binary term.</p><h2 id="ei_encode_atom" class="section-heading"><a href="#ei_encode_atom" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_atom()</span></h2><h2 id="ei_encode_atom_len" class="section-heading"><a href="#ei_encode_atom_len" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_atom_len()</span></h2><h2 id="ei_x_encode_atom" class="section-heading"><a href="#ei_x_encode_atom" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_atom()</span></h2><h2 id="ei_x_encode_atom_len" class="section-heading"><a href="#ei_x_encode_atom_len" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_atom_len()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_atom</span><span class="p" data-group-id="3505523593-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="3505523593-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_atom_len</span><span class="p" data-group-id="7584467404-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="7584467404-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_atom</span><span class="p" data-group-id="5087854406-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="5087854406-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_atom_len</span><span class="p" data-group-id="8252110355-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="8252110355-1">)</span><span class="p">;</span></code></pre><p>Encodes an atom in the binary format. Parameter <code class="inline">p</code> is the name of the atom in
Latin-1 encoding. Only up to <code class="inline">MAXATOMLEN-1</code> bytes are encoded. The name is to be
<code class="inline">NULL</code>-terminated, except for the <code class="inline">ei_x_encode_atom_len()</code> function.</p><h2 id="ei_encode_atom_as" class="section-heading"><a href="#ei_encode_atom_as" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_atom_as()</span></h2><p>Available since OTP R16B</p><h2 id="ei_encode_atom_len_as" class="section-heading"><a href="#ei_encode_atom_len_as" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_atom_len_as()</span></h2><p>Available since OTP R16B</p><h2 id="ei_x_encode_atom_as" class="section-heading"><a href="#ei_x_encode_atom_as" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_atom_as()</span></h2><p>Available since OTP R16B</p><h2 id="ei_x_encode_atom_len_as" class="section-heading"><a href="#ei_x_encode_atom_len_as" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_atom_len_as()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_atom_as</span><span class="p" data-group-id="3807068852-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w">
  </span><span class="n">erlang_char_encoding</span><span class="w"> </span><span class="n">from_enc</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_char_encoding</span><span class="w"> </span><span class="n">to_enc</span><span class="p" data-group-id="3807068852-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_atom_len_as</span><span class="p" data-group-id="4604703696-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w">
  </span><span class="n">erlang_char_encoding</span><span class="w"> </span><span class="n">from_enc</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_char_encoding</span><span class="w"> </span><span class="n">to_enc</span><span class="p" data-group-id="4604703696-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_atom_as</span><span class="p" data-group-id="4574235839-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w">
  </span><span class="n">erlang_char_encoding</span><span class="w"> </span><span class="n">from_enc</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_char_encoding</span><span class="w"> </span><span class="n">to_enc</span><span class="p" data-group-id="4574235839-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_atom_len_as</span><span class="p" data-group-id="2431124163-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w">
  </span><span class="n">erlang_char_encoding</span><span class="w"> </span><span class="n">from_enc</span><span class="p">,</span><span class="w"> </span><span class="n">erlang_char_encoding</span><span class="w"> </span><span class="n">to_enc</span><span class="p" data-group-id="2431124163-1">)</span><span class="p">;</span></code></pre><p>Encodes an atom in the binary format. Parameter <code class="inline">p</code> is the name of the atom with
character encoding <a href="ei.html#erlang_char_encoding"><code class="inline">from_enc</code></a> (ASCII, Latin-1, or
UTF-8). The name must either be <code class="inline">NULL</code>-terminated or a function variant with a
<code class="inline">len</code> parameter must be used.</p><p>The encoding fails if <code class="inline">p</code> is not a valid string in encoding <code class="inline">from_enc</code>.</p><p>Argument <code class="inline">to_enc</code> is ignored. As from Erlang/OTP 20 the encoding is always done
in UTF-8 which is readable by nodes as old as Erlang/OTP R16.</p><p>Available since OTP R16B</p><h2 id="ei_encode_bignum" class="section-heading"><a href="#ei_encode_bignum" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_bignum()</span></h2><h2 id="ei_x_encode_bignum" class="section-heading"><a href="#ei_x_encode_bignum" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_bignum()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_bignum</span><span class="p" data-group-id="8322005950-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">mpz_t</span><span class="w"> </span><span class="n">obj</span><span class="p" data-group-id="8322005950-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_bignum</span><span class="p" data-group-id="9548651594-1">(</span><span class="n">ei_x_buff</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">mpz_t</span><span class="w"> </span><span class="n">obj</span><span class="p" data-group-id="9548651594-1">)</span><span class="p">;</span></code></pre><p>Encodes a GMP <code class="inline">mpz_t</code> integer to binary format. To use this function, the <code class="inline">ei</code>
library must be configured and compiled to use the GMP library.</p><h2 id="ei_encode_binary" class="section-heading"><a href="#ei_encode_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_binary()</span></h2><h2 id="ei_x_encode_binary" class="section-heading"><a href="#ei_x_encode_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_binary</span><span class="p" data-group-id="6246185274-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="6246185274-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_binary</span><span class="p" data-group-id="9497135307-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="9497135307-1">)</span><span class="p">;</span></code></pre><p>Encodes a binary in the binary format. The data is at <code class="inline">p</code>, of <code class="inline">len</code> bytes
length.</p><h2 id="ei_encode_bitstring" class="section-heading"><a href="#ei_encode_bitstring" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_bitstring()</span></h2><p>Available since OTP 22.0</p><h2 id="ei_x_encode_bitstring" class="section-heading"><a href="#ei_x_encode_bitstring" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_bitstring()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_bitstring</span><span class="p" data-group-id="5365362550-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">size_t</span><span class="w"> </span><span class="n">bitoffs</span><span class="p">,</span><span class="w"> </span><span class="n">size_t</span><span class="w"> </span><span class="n">nbits</span><span class="p" data-group-id="5365362550-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_bitstring</span><span class="p" data-group-id="8982017220-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">size_t</span><span class="w"> </span><span class="n">bitoffs</span><span class="p">,</span><span class="w"> </span><span class="n">size_t</span><span class="w"> </span><span class="n">nbits</span><span class="p" data-group-id="8982017220-1">)</span><span class="p">;</span></code></pre><p>Encodes a bit string in the binary format.</p><p>The data is at <code class="inline">p</code>. The length of the bit string is <code class="inline">nbits</code> bits. The first
<code class="inline">bitoffs</code> bits of the data at <code class="inline">p</code> are unused. The first byte which is part of
the bit string is <code class="inline">p[bitoffs/8]</code>. The <code class="inline">bitoffs%8</code> most significant bits of the
first byte <code class="inline">p[bitoffs/8]</code> are unused.</p><p>The number of bytes which is part of the bit string is
<code class="inline">(bitoffs + nbits + 7)/8</code>. If <code class="inline">(bitoffs + nbits)%8 &gt; 0</code> then only
<code class="inline">(bitoffs + nbits)%8</code> bits of the last byte are used. Unused bits in the last
byte are the least significant bits.</p><p>The values of unused bits are disregarded and does not need to be cleared.</p><p>Available since OTP 22.0</p><h2 id="ei_encode_boolean" class="section-heading"><a href="#ei_encode_boolean" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_boolean()</span></h2><h2 id="ei_x_encode_boolean" class="section-heading"><a href="#ei_x_encode_boolean" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_boolean()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_boolean</span><span class="p" data-group-id="4825722252-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="4825722252-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_boolean</span><span class="p" data-group-id="0131618013-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="0131618013-1">)</span><span class="p">;</span></code></pre><p>Encodes a boolean value as the atom <code class="inline">true</code> if <code class="inline">p</code> is not zero, or <code class="inline">false</code> if <code class="inline">p</code>
is zero.</p><h2 id="ei_encode_char" class="section-heading"><a href="#ei_encode_char" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_char()</span></h2><h2 id="ei_x_encode_char" class="section-heading"><a href="#ei_x_encode_char" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_char()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_char</span><span class="p" data-group-id="3830028239-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="3830028239-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_char</span><span class="p" data-group-id="6051600816-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="6051600816-1">)</span><span class="p">;</span></code></pre><p>Encodes a char (8-bit) as an integer between 0-255 in the binary format. For
historical reasons the integer argument is of type <code class="inline">char</code>. Your C code is to
consider the specified argument to be of type <code class="inline">unsigned char</code> even if the C
compilers and system may define <code class="inline">char</code> to be signed.</p><h2 id="ei_encode_double" class="section-heading"><a href="#ei_encode_double" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_double()</span></h2><h2 id="ei_x_encode_double" class="section-heading"><a href="#ei_x_encode_double" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_double()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_double</span><span class="p" data-group-id="5599731102-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="5599731102-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_double</span><span class="p" data-group-id="9833101440-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="9833101440-1">)</span><span class="p">;</span></code></pre><p>Encodes a double-precision (64-bit) floating point number in the binary format.</p><p>Returns <code class="inline">-1</code> if the floating point number is not finite.</p><h2 id="ei_encode_empty_list" class="section-heading"><a href="#ei_encode_empty_list" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_empty_list()</span></h2><h2 id="ei_x_encode_empty_list" class="section-heading"><a href="#ei_x_encode_empty_list" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_empty_list()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_empty_list</span><span class="p" data-group-id="4949098710-1">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">index</span><span class="p" data-group-id="4949098710-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_empty_list</span><span class="p" data-group-id="5309901295-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p" data-group-id="5309901295-1">)</span><span class="p">;</span></code></pre><p>Encodes an empty list. It is often used at the tail of a list.</p><h2 id="ei_encode_fun" class="section-heading"><a href="#ei_encode_fun" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_fun()</span></h2><h2 id="ei_x_encode_fun" class="section-heading"><a href="#ei_x_encode_fun" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_fun()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_fun</span><span class="p" data-group-id="7870867251-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">erlang_fun</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="7870867251-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_fun</span><span class="p" data-group-id="4752942298-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">erlang_fun</span><span class="o">*</span><span class="w"> </span><span class="n">fun</span><span class="p" data-group-id="4752942298-1">)</span><span class="p">;</span></code></pre><p>Encodes a fun in the binary format. Parameter <code class="inline">p</code> points to an <code class="inline">erlang_fun</code>
structure. The <code class="inline">erlang_fun</code> is not freed automatically, the <code class="inline">free_fun</code> is to be
called if the fun is not needed after encoding.</p><h2 id="ei_encode_list_header" class="section-heading"><a href="#ei_encode_list_header" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_list_header()</span></h2><h2 id="ei_x_encode_list_header" class="section-heading"><a href="#ei_x_encode_list_header" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_list_header()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_list_header</span><span class="p" data-group-id="9176777908-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arity</span><span class="p" data-group-id="9176777908-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_list_header</span><span class="p" data-group-id="0098650625-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arity</span><span class="p" data-group-id="0098650625-1">)</span><span class="p">;</span></code></pre><p>Encodes a list header, with a specified arity. The next <code class="inline">arity+1</code> terms are the
elements (actually its <code class="inline">arity</code> cons cells) and the tail of the list. Lists and
tuples are encoded recursively, so that a list can contain another list or
tuple.</p><p>For example, to encode the list <code class="inline">[c, d, [e | f]]</code>:</p><pre><code class="makeup c" translate="no"><span class="nf">ei_encode_list_header</span><span class="p" data-group-id="5964520263-1">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="5964520263-1">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_encode_atom</span><span class="p" data-group-id="5964520263-2">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p" data-group-id="5964520263-2">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_encode_atom</span><span class="p" data-group-id="5964520263-3">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;d&quot;</span><span class="p" data-group-id="5964520263-3">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_encode_list_header</span><span class="p" data-group-id="5964520263-4">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="5964520263-4">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_encode_atom</span><span class="p" data-group-id="5964520263-5">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;e&quot;</span><span class="p" data-group-id="5964520263-5">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_encode_atom</span><span class="p" data-group-id="5964520263-6">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;f&quot;</span><span class="p" data-group-id="5964520263-6">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_encode_empty_list</span><span class="p" data-group-id="5964520263-7">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p" data-group-id="5964520263-7">)</span><span class="p">;</span></code></pre><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>It may seem that there is no way to create a list without knowing the number
of elements in advance. But indeed there is a way. Notice that the list
<code class="inline">[a, b, c]</code> can be written as <code class="inline">[a | [b | [c]]]</code>. Using this, a list can be
written as conses.</p></section><p>To encode a list, without knowing the arity in advance:</p><pre><code class="makeup c" translate="no"><span class="k">while</span><span class="w"> </span><span class="p" data-group-id="7372379766-1">(</span><span class="nf">something</span><span class="p" data-group-id="7372379766-2">(</span><span class="p" data-group-id="7372379766-2">)</span><span class="p" data-group-id="7372379766-1">)</span><span class="w"> </span><span class="p" data-group-id="7372379766-3">{</span><span class="w">
    </span><span class="nf">ei_x_encode_list_header</span><span class="p" data-group-id="7372379766-4">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="7372379766-4">)</span><span class="p">;</span><span class="w">
    </span><span class="nf">ei_x_encode_ulong</span><span class="p" data-group-id="7372379766-5">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p" data-group-id="7372379766-5">)</span><span class="p">;</span><span class="w"> </span><span class="cm">/* just an example */</span><span class="w">
</span><span class="p" data-group-id="7372379766-3">}</span><span class="w">
</span><span class="nf">ei_x_encode_empty_list</span><span class="p" data-group-id="7372379766-6">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p" data-group-id="7372379766-6">)</span><span class="p">;</span></code></pre><h2 id="ei_encode_long" class="section-heading"><a href="#ei_encode_long" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_long()</span></h2><h2 id="ei_x_encode_long" class="section-heading"><a href="#ei_x_encode_long" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_long()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_long</span><span class="p" data-group-id="5947177666-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="5947177666-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_long</span><span class="p" data-group-id="7468832934-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="7468832934-1">)</span><span class="p">;</span></code></pre><p>Encodes a long integer in the binary format. If the code is 64 bits, the
function <code class="inline">ei_encode_long()</code> is the same as <code class="inline">ei_encode_longlong()</code>.</p><h2 id="ei_encode_longlong" class="section-heading"><a href="#ei_encode_longlong" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_longlong()</span></h2><h2 id="ei_x_encode_longlong" class="section-heading"><a href="#ei_x_encode_longlong" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_longlong()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_longlong</span><span class="p" data-group-id="2404253808-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="2404253808-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_longlong</span><span class="p" data-group-id="4372414369-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="4372414369-1">)</span><span class="p">;</span></code></pre><p>Encodes a GCC <code class="inline">long long</code> or Visual C++ <code class="inline">__int64</code> (64-bit) integer in the binary
format.</p><h2 id="ei_encode_map_header" class="section-heading"><a href="#ei_encode_map_header" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_map_header()</span></h2><p>Available since OTP 17.0</p><h2 id="ei_x_encode_map_header" class="section-heading"><a href="#ei_x_encode_map_header" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_map_header()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_map_header</span><span class="p" data-group-id="2790276085-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arity</span><span class="p" data-group-id="2790276085-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_map_header</span><span class="p" data-group-id="2281815378-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arity</span><span class="p" data-group-id="2281815378-1">)</span><span class="p">;</span></code></pre><p>Encodes a map header, with a specified arity. The next <code class="inline">arity*2</code> terms encoded
will be the keys and values of the map encoded in the following order:
<code class="inline">K1, V1, K2, V2, ..., Kn, Vn</code>.</p><p>For example, to encode the map <code class="inline">#{a =&gt; &quot;Apple&quot;, b =&gt; &quot;Banana&quot;}</code>:</p><pre><code class="makeup c" translate="no"><span class="nf">ei_x_encode_map_header</span><span class="p" data-group-id="1172108861-1">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="1172108861-1">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_x_encode_atom</span><span class="p" data-group-id="1172108861-2">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p" data-group-id="1172108861-2">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_x_encode_string</span><span class="p" data-group-id="1172108861-3">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Apple&quot;</span><span class="p" data-group-id="1172108861-3">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_x_encode_atom</span><span class="p" data-group-id="1172108861-4">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p" data-group-id="1172108861-4">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_x_encode_string</span><span class="p" data-group-id="1172108861-5">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Banana&quot;</span><span class="p" data-group-id="1172108861-5">)</span><span class="p">;</span></code></pre><p>A correctly encoded map cannot have duplicate keys.</p><p>Available since OTP 17.0</p><h2 id="ei_encode_pid" class="section-heading"><a href="#ei_encode_pid" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_pid()</span></h2><h2 id="ei_x_encode_pid" class="section-heading"><a href="#ei_x_encode_pid" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_pid()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_pid</span><span class="p" data-group-id="3971144558-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">erlang_pid</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="3971144558-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_pid</span><span class="p" data-group-id="5766294068-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">erlang_pid</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="5766294068-1">)</span><span class="p">;</span></code></pre><p>Encodes an Erlang process identifier (pid) in the binary format. Parameter <code class="inline">p</code>
points to an <code class="inline">erlang_pid</code> structure which should either have been obtained
earlier with <a href="ei.html#ei_decode_pid"><code class="inline">ei_decode_pid()</code></a>,
<a href="ei_connect.html#ei_self"><code class="inline">ei_self()</code></a> or created by
<a href="ei_connect.html#ei_make_pid"><code class="inline">ei_make_pid()</code></a>.</p><h2 id="ei_encode_port" class="section-heading"><a href="#ei_encode_port" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_port()</span></h2><h2 id="ei_x_encode_port" class="section-heading"><a href="#ei_x_encode_port" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_port()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_port</span><span class="p" data-group-id="2535072138-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">erlang_port</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="2535072138-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_port</span><span class="p" data-group-id="8187418129-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">erlang_port</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="8187418129-1">)</span><span class="p">;</span></code></pre><p>Encodes an Erlang port in the binary format. Parameter <code class="inline">p</code> points to an
<code class="inline">erlang_port</code> structure which should have been obtained earlier with
<a href="ei.html#ei_decode_port"><code class="inline">ei_decode_port()</code></a>,</p><h2 id="ei_encode_ref" class="section-heading"><a href="#ei_encode_ref" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_ref()</span></h2><h2 id="ei_x_encode_ref" class="section-heading"><a href="#ei_x_encode_ref" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_ref()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_ref</span><span class="p" data-group-id="7552674501-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">erlang_ref</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="7552674501-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_ref</span><span class="p" data-group-id="6296091804-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">erlang_ref</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="6296091804-1">)</span><span class="p">;</span></code></pre><p>Encodes an Erlang reference in the binary format. Parameter <code class="inline">p</code> points to an
<code class="inline">erlang_ref</code> structure which either should have been obtained earlier with
<a href="ei.html#ei_decode_ref"><code class="inline">ei_decode_ref()</code></a>, or created by
<a href="ei_connect.html#ei_make_ref"><code class="inline">ei_make_ref()</code></a>.</p><h2 id="ei_encode_string" class="section-heading"><a href="#ei_encode_string" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_string()</span></h2><h2 id="ei_encode_string_len" class="section-heading"><a href="#ei_encode_string_len" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_string_len()</span></h2><h2 id="ei_x_encode_string" class="section-heading"><a href="#ei_x_encode_string" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_string()</span></h2><h2 id="ei_x_encode_string_len" class="section-heading"><a href="#ei_x_encode_string_len" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_string_len()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_string</span><span class="p" data-group-id="8092861952-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="8092861952-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_string_len</span><span class="p" data-group-id="9834097611-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="9834097611-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_string</span><span class="p" data-group-id="3256598907-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="3256598907-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_string_len</span><span class="p" data-group-id="1628659858-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="1628659858-1">)</span><span class="p">;</span></code></pre><p>Encodes a string in the binary format. (A string in Erlang is a list, but is
encoded as a character array in the binary format.) The string is to be
<code class="inline">NULL</code>-terminated, except for the <code class="inline">ei_x_encode_string_len()</code> function.</p><h2 id="ei_encode_trace" class="section-heading"><a href="#ei_encode_trace" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_trace()</span></h2><h2 id="ei_x_encode_trace" class="section-heading"><a href="#ei_x_encode_trace" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_trace()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_trace</span><span class="p" data-group-id="6128181428-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">erlang_trace</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="6128181428-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_trace</span><span class="p" data-group-id="8559906864-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">erlang_trace</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p" data-group-id="8559906864-1">)</span><span class="p">;</span></code></pre><p>Encodes an Erlang trace token in the binary format. Parameter <code class="inline">p</code> points to a
<code class="inline">erlang_trace</code> structure which should have been obtained earlier with
<a href="ei.html#ei_decode_trace"><code class="inline">ei_decode_trace()</code></a>.</p><h2 id="ei_encode_tuple_header" class="section-heading"><a href="#ei_encode_tuple_header" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_tuple_header()</span></h2><h2 id="ei_x_encode_tuple_header" class="section-heading"><a href="#ei_x_encode_tuple_header" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_tuple_header()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_tuple_header</span><span class="p" data-group-id="1873815989-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arity</span><span class="p" data-group-id="1873815989-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_tuple_header</span><span class="p" data-group-id="6508750150-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arity</span><span class="p" data-group-id="6508750150-1">)</span><span class="p">;</span></code></pre><p>Encodes a tuple header, with a specified arity. The next <code class="inline">arity</code> terms encoded
will be the elements of the tuple. Tuples and lists are encoded recursively, so
that a tuple can contain another tuple or list.</p><p>For example, to encode the tuple <code class="inline">{a, {b, {}}}</code>:</p><pre><code class="makeup c" translate="no"><span class="nf">ei_encode_tuple_header</span><span class="p" data-group-id="3294288938-1">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="3294288938-1">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_encode_atom</span><span class="p" data-group-id="3294288938-2">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p" data-group-id="3294288938-2">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_encode_tuple_header</span><span class="p" data-group-id="3294288938-3">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="3294288938-3">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_encode_atom</span><span class="p" data-group-id="3294288938-4">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p" data-group-id="3294288938-4">)</span><span class="p">;</span><span class="w">
</span><span class="nf">ei_encode_tuple_header</span><span class="p" data-group-id="3294288938-5">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="3294288938-5">)</span><span class="p">;</span></code></pre><h2 id="ei_encode_ulong" class="section-heading"><a href="#ei_encode_ulong" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_ulong()</span></h2><h2 id="ei_x_encode_ulong" class="section-heading"><a href="#ei_x_encode_ulong" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_ulong()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_ulong</span><span class="p" data-group-id="5422034134-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="5422034134-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_ulong</span><span class="p" data-group-id="0948575637-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="0948575637-1">)</span><span class="p">;</span></code></pre><p>Encodes an unsigned long integer in the binary format. If the code is 64 bits,
the function <code class="inline">ei_encode_ulong()</code> is the same as <code class="inline">ei_encode_ulonglong()</code>.</p><h2 id="ei_encode_ulonglong" class="section-heading"><a href="#ei_encode_ulonglong" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_ulonglong()</span></h2><h2 id="ei_x_encode_ulonglong" class="section-heading"><a href="#ei_x_encode_ulonglong" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_ulonglong()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_ulonglong</span><span class="p" data-group-id="1375200830-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="1375200830-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_ulonglong</span><span class="p" data-group-id="4684634897-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">p</span><span class="p" data-group-id="4684634897-1">)</span><span class="p">;</span></code></pre><p>Encodes a GCC <code class="inline">unsigned long long</code> or Visual C++ <code class="inline">unsigned __int64</code> (64-bit)
integer in the binary format.</p><h2 id="ei_encode_version" class="section-heading"><a href="#ei_encode_version" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_encode_version()</span></h2><h2 id="ei_x_encode_version" class="section-heading"><a href="#ei_x_encode_version" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_encode_version()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_encode_version</span><span class="p" data-group-id="0739103603-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p" data-group-id="0739103603-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_encode_version</span><span class="p" data-group-id="8142543337-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p" data-group-id="8142543337-1">)</span><span class="p">;</span></code></pre><p>Encodes a version magic number for the binary format. Must be the first token in
a binary term.</p><h2 id="ei_get_type" class="section-heading"><a href="#ei_get_type" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_get_type()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_get_type</span><span class="p" data-group-id="7791223511-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="p" data-group-id="7791223511-1">)</span><span class="p">;</span></code></pre><p>Returns the type in <code class="inline">*type</code> and size in <code class="inline">*size</code> of the encoded term. For strings
and atoms, size is the number of characters <em>not</em> including the terminating
<code class="inline">NULL</code>. For binaries and bitstrings, <code class="inline">*size</code> is the number of bytes. For lists,
tuples and maps, <code class="inline">*size</code> is the arity of the object. For bignum integers,
<code class="inline">*size</code> is the number of bytes for the absolute value of the bignum. For other
types, <code class="inline">*size</code> is 0. In all cases, <code class="inline">index</code> is left unchanged.</p><p>Currently <code class="inline">*type</code> is one of:</p><ul><li><p><strong>ERL_ATOM_EXT</strong> - Decode using either
<a href="ei.html#ei_decode_atom"><code class="inline">ei_decode_atom()</code></a>,
<a href="ei.html#ei_decode_atom_as"><code class="inline">ei_decode_atom_as()</code></a>, or
<a href="ei.html#ei_decode_boolean"><code class="inline">ei_decode_boolean()</code></a>.</p></li><li><p><strong>ERL_BINARY_EXT</strong> - Decode using either
<a href="ei.html#ei_decode_binary"><code class="inline">ei_decode_binary()</code></a>,
<a href="ei.html#ei_decode_bitstring"><code class="inline">ei_decode_bitstring()</code></a>, or
<a href="ei.html#ei_decode_iodata"><code class="inline">ei_decode_iodata()</code></a>.</p></li><li><p><strong>ERL_BIT_BINARY_EXT</strong> - Decode using
<a href="ei.html#ei_decode_bitstring"><code class="inline">ei_decode_bitstring()</code></a>.</p></li><li><p><strong>ERL_FLOAT_EXT</strong> - Decode using
<a href="ei.html#ei_decode_double"><code class="inline">ei_decode_double()</code></a>.</p></li><li><p><strong>ERL_NEW_FUN_EXT, ERL_FUN_EXT, ERL_EXPORT_EXT</strong> -
Decode using <a href="ei.html#ei_decode_fun"><code class="inline">ei_decode_fun()</code></a>.</p></li><li><p><strong>ERL_SMALL_INTEGER_EXT, ERL_INTEGER_EXT, ERL_SMALL_BIG_EXT, ERL_LARGE_BIG_EXT</strong> -
Decode using either <a href="ei.html#ei_decode_char"><code class="inline">ei_decode_char()</code></a>,
<a href="ei.html#ei_decode_long"><code class="inline">ei_decode_long()</code></a>,
<a href="ei.html#ei_decode_longlong"><code class="inline">ei_decode_longlong()</code></a>,
<a href="ei.html#ei_decode_ulong"><code class="inline">ei_decode_ulong()</code></a>,
<a href="ei.html#ei_decode_ulonglong"><code class="inline">ei_decode_ulonglong()</code></a>, or
<a href="ei.html#ei_decode_bignum"><code class="inline">ei_decode_bignum()</code></a>.</p></li><li><p><strong>ERL_LIST_EXT, ERL_NIL_EXT</strong> -
Decode using either <a href="ei.html#ei_decode_list_header"><code class="inline">ei_decode_list_header()</code></a>,
or <a href="ei.html#ei_decode_iodata"><code class="inline">ei_decode_iodata()</code></a>.</p></li><li><p><strong>ERL_STRING_EXT</strong> - Decode using either
<a href="ei.html#ei_decode_string"><code class="inline">ei_decode_string()</code></a>, or
<a href="ei.html#ei_decode_iodata"><code class="inline">ei_decode_iodata()</code></a>.</p></li><li><p><strong>ERL_MAP_EXT</strong> - Decode using
<a href="ei.html#ei_decode_map_header"><code class="inline">ei_decode_map_header()</code></a>.</p></li><li><p><strong>ERL_PID_EXT</strong> - Decode using <a href="ei.html#ei_decode_pid"><code class="inline">ei_decode_pid()</code></a>.</p></li><li><p><strong>ERL_PORT_EXT</strong> - Decode using <a href="ei.html#ei_decode_port"><code class="inline">ei_decode_port()</code></a>.</p></li><li><p><strong>ERL_NEW_REFERENCE_EXT</strong> - Decode using
<a href="ei.html#ei_decode_ref"><code class="inline">ei_decode_ref()</code></a>.</p></li><li><p><strong>ERL_SMALL_TUPLE_EXT, ERL_LARGE_TUPLE_EXT</strong><br/>Decode using <a href="ei.html#ei_decode_tuple_header"><code class="inline">ei_decode_tuple_header()</code></a>.</p></li></ul><p>Instead of decoding a term you can also skipped past it if you are not
interested in the data by usage of <a href="ei.html#ei_skip_term"><code class="inline">ei_skip_term()</code></a>.</p><h2 id="ei_init" class="section-heading"><a href="#ei_init" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_init()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_init</span><span class="p" data-group-id="4058584736-1">(</span><span class="kc">void</span><span class="p" data-group-id="4058584736-1">)</span><span class="p">;</span></code></pre><p>Initialize the <code class="inline">ei</code> library. This function should be called once (and only once)
before calling any other functionality in the <code class="inline">ei</code> library.</p><p>On success zero is returned. On failure a posix error code is returned.</p><p>Available since OTP 21.3</p><h2 id="ei_print_term" class="section-heading"><a href="#ei_print_term" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_print_term()</span></h2><h2 id="ei_s_print_term" class="section-heading"><a href="#ei_s_print_term" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_s_print_term()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_print_term</span><span class="p" data-group-id="4541642063-1">(</span><span class="no">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fp</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">index</span><span class="p" data-group-id="4541642063-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_s_print_term</span><span class="p" data-group-id="9669255497-1">(</span><span class="kt">char</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">index</span><span class="p" data-group-id="9669255497-1">)</span><span class="p">;</span></code></pre><p>Prints a term, in clear text, to the file specified by <code class="inline">fp</code>, or the buffer
pointed to by <code class="inline">s</code>. It tries to resemble the term printing in the Erlang shell.</p><p>In <code class="inline">ei_s_print_term()</code>, parameter <code class="inline">s</code> is to point to a dynamically (malloc)
allocated string of <code class="inline">BUFSIZ</code> bytes or a <code class="inline">NULL</code> pointer. The string can be
reallocated (and <code class="inline">*s</code> can be updated) by this function if the result is more
than <code class="inline">BUFSIZ</code> characters. The string returned is <code class="inline">NULL</code>-terminated.</p><p>The return value is the number of characters written to the file or string, or
<code class="inline">-1</code> if <code class="inline">buf[index]</code> does not contain a valid term. Unfortunately, I/O errors on
<code class="inline">fp</code> is not checked.</p><p>Argument <code class="inline">index</code> is updated, that is, this function can be viewed as a decode
function that decodes a term into a human-readable format.</p><h2 id="ei_set_compat_rel" class="section-heading"><a href="#ei_set_compat_rel" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_set_compat_rel()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">ei_set_compat_rel</span><span class="p" data-group-id="9718694889-1">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">release_number</span><span class="p" data-group-id="9718694889-1">)</span><span class="p">;</span></code></pre><p>In general, the <code class="inline">ei</code> library is guaranteed to be compatible with other
Erlang/OTP components that are 2 major releases older or newer than the <code class="inline">ei</code>
library itself.</p><p>Sometimes an exception to the above rule has to be made to make new features (or
even bug fixes) possible. A call to <code class="inline">ei_set_compat_rel(release_number)</code> sets the
<code class="inline">ei</code> library in compatibility mode of OTP release <code class="inline">release_number</code>.</p><p>The only useful value for <code class="inline">release_number</code> is currently <code class="inline">21</code>. This will only be
useful and have an effect if <em>bit strings</em> or <em>export funs</em> are received from a
connected node. Before OTP 22, bit strings and export funs were not supported by
<code class="inline">ei</code>. They were instead encoded using an undocumented fallback tuple format when
sent from the emulator to <code class="inline">ei</code>:</p><ul><li><p><strong><code class="inline">Bit string</code></strong> - The term <code class="inline">&lt;&lt;42, 1:1&gt;&gt;</code> was encoded as <code class="inline">{&lt;&lt;42, 128&gt;&gt;, 1}</code>.
The first element of the tuple is a binary and the second element denotes how
many bits of the last bytes are part of the bit string. In this example only
the most significant bit of the last byte (128) is part of the bit string.</p></li><li><p><strong><code class="inline">Export fun</code></strong> - The term <code class="inline">fun lists:map/2</code> was encoded as <code class="inline">{lists,map}</code>. A
tuple with the module, function and a missing arity.</p></li></ul><p>If <code class="inline">ei_set_compat_rel(21)</code> is <em>not</em> called then a connected emulator will send
bit strings and export funs correctly encoded. The functions
<a href="ei.html#ei_decode_bitstring"><code class="inline">ei_decode_bitstring</code></a> and
<a href="ei.html#ei_decode_fun"><code class="inline">ei_decode_fun</code></a> has to be used to decode such terms.
Calling <code class="inline">ei_set_compat_rel(21)</code> should only be done as a workaround to keep an
old implementation alive, which expects to receive the undocumented tuple
formats for bit strings and/or export funs.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>If this function is called, it can only be called once and must be called
before any other functions in the <code class="inline">ei</code> library are called.</p></section><h2 id="ei_skip_term" class="section-heading"><a href="#ei_skip_term" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_skip_term()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_skip_term</span><span class="p" data-group-id="9986459012-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">index</span><span class="p" data-group-id="9986459012-1">)</span><span class="p">;</span></code></pre><p>Skips a term in the specified buffer; recursively skips elements of lists and
tuples, so that a full term is skipped. This is a way to get the size of an
Erlang term.</p><p><code class="inline">buf</code> is the buffer.</p><p><code class="inline">index</code> is updated to point right after the term in the buffer.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>This can be useful when you want to hold arbitrary terms: skip them and copy
the binary term data to some buffer.</p></section><p>Returns <code class="inline">0</code> on success, otherwise <code class="inline">-1</code>.</p><h2 id="ei_x_append" class="section-heading"><a href="#ei_x_append" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_append()</span></h2><h2 id="ei_x_append_buf" class="section-heading"><a href="#ei_x_append_buf" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_append_buf()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_append</span><span class="p" data-group-id="3317658633-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x2</span><span class="p" data-group-id="3317658633-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_append_buf</span><span class="p" data-group-id="9942474385-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="9942474385-1">)</span><span class="p">;</span></code></pre><p>Appends data at the end of buffer <code class="inline">x</code>.</p><h2 id="ei_x_format" class="section-heading"><a href="#ei_x_format" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_format()</span></h2><h2 id="ei_x_format_wo_ver" class="section-heading"><a href="#ei_x_format_wo_ver" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_format_wo_ver()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_format</span><span class="p" data-group-id="9500120591-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="9500120591-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_format_wo_ver</span><span class="p" data-group-id="0695497012-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="p" data-group-id="0695497012-1">)</span><span class="p">;</span></code></pre><p>Formats a term, given as a string, to a buffer. Works like a sprintf for Erlang
terms. <code class="inline">fmt</code> contains a format string, with arguments like <code class="inline">~d</code>, to insert terms
from variables. The following formats are supported (with the C types given):</p><pre><code class="text">~a  An atom, char*
~c  A character, char
~s  A string, char*
~i  An integer, int
~l  A long integer, long int
~u  A unsigned long integer, unsigned long int
~f  A float, float
~d  A double float, double float
~p  An Erlang pid, erlang_pid*</code></pre><p>For example, to encode a tuple with some stuff:</p><pre><code class="makeup c" translate="no"><span class="nf">ei_x_format</span><span class="p" data-group-id="9183651209-1">(</span><span class="s">&quot;{~a,~i,~d}&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;numbers&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14159</span><span class="p" data-group-id="9183651209-1">)</span><span class="w">
</span><span class="n">encodes</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="p" data-group-id="9183651209-2">{</span><span class="n">numbers</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mf">3.14159</span><span class="p" data-group-id="9183651209-2">}</span></code></pre><p><code class="inline">ei_x_format_wo_ver()</code> formats into a buffer, without the initial version byte.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>Since OTP 26.2 maps can be encoded with syntax like <code class="inline">&quot;#{k1 =&gt; v1, k2 =&gt; v2}&quot;</code>.</p></section><h2 id="ei_x_free" class="section-heading"><a href="#ei_x_free" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_free()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_free</span><span class="p" data-group-id="8438808636-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p" data-group-id="8438808636-1">)</span><span class="p">;</span></code></pre><p>Deallocates the dynamically allocated content of the buffer referred by <code class="inline">x</code>.
After deallocation, the <code class="inline">buff</code> field is set to <code class="inline">NULL</code>.</p><h2 id="ei_x_new" class="section-heading"><a href="#ei_x_new" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_new()</span></h2><h2 id="ei_x_new_with_version" class="section-heading"><a href="#ei_x_new_with_version" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">ei_x_new_with_version()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_new</span><span class="p" data-group-id="5930725731-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p" data-group-id="5930725731-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">ei_x_new_with_version</span><span class="p" data-group-id="0576954123-1">(</span><span class="n">ei_x_buff</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p" data-group-id="0576954123-1">)</span><span class="p">;</span></code></pre><p>Initialize the dynamically realizable buffer referred to by <code class="inline">x</code>. The fields of
the structure pointed to by parameter <code class="inline">x</code> is filled in, and a default buffer is
allocated. <code class="inline">ei_x_new_with_version()</code> also puts an initial version byte, which is
used in the binary format (so that <code class="inline">ei_x_encode_version()</code> will not be needed.)</p><h2 id="debug-information" class="section-heading"><a href="#debug-information" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Debug Information</span></h2><p>Some tips on what to check when the emulator does not seem to receive the terms
that you send:</p><ul><li>Be careful with the version header, use <code class="inline">ei_x_new_with_version()</code> when
appropriate.</li><li>Turn on distribution tracing on the Erlang node.</li><li>Check the result codes from <code class="inline">ei_decode_-calls</code>.</li></ul>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="erl_call_cmd.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
erl_call
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="ei_connect.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
ei_connect
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="erl_interface.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.38.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright © 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
