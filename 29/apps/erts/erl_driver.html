<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.38.1">
    <meta name="project" content="erts v16.1.2-rc0">


<meta name="major-vsn" content="29">
<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=29&q=">
<link rel="canonical" href="https://www.erlang.org/doc/apps/erts/erl_driver.html" />
    <title>erl_driver â€” erts v16.1.2-rc0</title>

    <link rel="stylesheet" href="dist/html-erlang-ZK43ZOAC.css" />

    <script defer src="dist/sidebar_items-25752129.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-DPJLHKSM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="erts" />
        </a>

      <div>
        <a href="../../index.html" class="sidebar-projectName" translate="no">
erts
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v16.1.2-rc0
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of erts</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>erl_driver</h1>


      <a href="https://github.com/erlang/otp/blob/master/erts/doc/references/erl_driver.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<p>API functions for an Erlang driver.</p><h2 id="description" class="section-heading"><a href="#description" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Description</span></h2><p>An Erlang driver is a library containing a set of native driver callback
functions that the Erlang Virtual Machine calls when certain events occur. There
can be multiple instances of a driver, each instance is associated with an
Erlang port.</p><p><a href="" id="WARNING"></a></p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p><em>Use this functionality with extreme care.</em></p><p>A driver callback is executed as a direct extension of the native code of the
VM. Execution is not made in a safe environment. The VM <em>cannot</em> provide the
same services as provided when executing Erlang code, such as pre-emptive
scheduling or memory protection. If the driver callback function does not
behave well, the whole VM will misbehave.</p><ul><li>A driver callback that crash will crash the whole VM.</li><li>An erroneously implemented driver callback can cause a VM internal state
inconsistency, which can cause a crash of the VM, or miscellaneous
misbehaviors of the VM at any point after the call to the driver callback.</li><li>A driver callback doing <a href="erl_driver.html#lengthy_work">lengthy work</a> before
returning degrades responsiveness of the VM and can cause miscellaneous
strange behaviors. Such strange behaviors include, but are not limited to,
extreme memory usage and bad load balancing between schedulers. Strange
behaviors that can occur because of lengthy work can also vary between
Erlang/OTP releases.</li></ul></section><p>As from ERTS 5.5.3 the driver interface has been extended (see
<a href="driver_entry.html#extended_marker"><code class="inline">extended marker</code></a>). The extended interface
introduces <a href="erl_driver.html#version_management">version management</a>, the
possibility to pass capability flags (see
<a href="driver_entry.html#driver_flags"><code class="inline">driver_flags</code></a>) to the runtime system at driver
initialization, and some new driver API functions.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>As from ERTS 5.9 old drivers must be recompiled and use the extended
interface. They must also be adjusted to the
<a href="erl_driver.html#rewrites_for_64_bits">64-bit capable driver interface</a>.</p></section><p>The driver calls back to the emulator, using the API functions declared in
<code class="inline">erl_driver.h</code>. They are used for outputting data from the driver, using timers,
and so on.</p><p>Each driver instance is associated with a port. Every port has a port owner
process. Communication with the port is normally done through the port owner
process. Most of the functions take the <code class="inline">port</code> handle as an argument. This
identifies the driver instance. Notice that this port handle must be stored by
the driver, it is not given when the driver is called from the emulator (see
<a href="driver_entry.html#emulator"><code class="inline">driver_entry</code></a>).</p><p>Some of the functions take a parameter of type <code class="inline">ErlDrvBinary</code>, a driver binary.
It is to be both allocated and freed by the caller. Using a binary directly
avoids one extra copying of data.</p><p>Many of the output functions have a &quot;header buffer&quot;, with <code class="inline">hbuf</code> and <code class="inline">hlen</code>
parameters. This buffer is sent as a list before the binary (or list, depending
on port mode) that is sent. This is convenient when matching on messages
received from the port. (Although in the latest Erlang versions there is the
binary syntax, which enables you to match on the beginning of a binary.)</p><p><a href="" id="smp_support"></a> Drivers are locked either on driver level or port level
(driver instance level). By default driver level locking will be used, that is,
only one emulator thread will execute code in the driver at a time. If port
level locking is used, multiple emulator threads can execute code in the driver
at the same time. Only one thread at a time will call driver callbacks
corresponding to the same port, though. To enable port level locking, set the
<code class="inline">ERL_DRV_FLAG_USE_PORT_LOCKING</code> <a href="driver_entry.html#driver_flags">driver flag</a> in
the <a href="driver_entry.html"><code class="inline">driver_entry</code></a> used by the driver. When port level
locking is used, the driver writer is responsible for synchronizing all accesses
to data shared by the ports (driver instances).</p><p>Most drivers written before the runtime system with SMP support existed can run
in the runtime system with SMP support, without being rewritten, if driver level
locking is used.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>It is assumed that drivers do not access other drivers. If drivers access each
other, they must provide their own mechanism for thread-safe synchronization.
Such &quot;inter-driver communication&quot; is strongly discouraged.</p></section><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Regardless of locking scheme used, calls to driver callbacks can be made from
different threads.</p></section><p>Most functions in this API are <em>not</em> thread-safe, that is, they <em>cannot</em> be
called from arbitrary threads. Functions that are not documented as thread-safe
can only be called from driver callbacks or function calls descending from a
driver callback call. Notice that driver callbacks can be called from different
threads. This, however, is not a problem for any function in this API, as the
emulator has control over these threads.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>Functions not explicitly documented as thread-safe are <em>not</em> thread safe.</p><p>A function not explicitly documented as thread-safe can, at some point in
time, have a thread-safe implementation in the runtime system. Such an
implementation can however change to a thread <em>unsafe</em> implementation at any
time <em>without any notice</em>.</p><p><em>Only use functions explicitly documented as thread-safe from arbitrary
threads.</em></p></section><p><a href="" id="lengthy_work"></a> As mentioned in the <a href="erl_driver.html#WARNING">warning</a> text
at the beginning of this section, it is of vital importance that a driver
callback returns relatively fast. It is difficult to give an exact maximum
amount of time that a driver callback is allowed to work, but usually a
well-behaving driver callback is to return within 1 millisecond. This can be
achieved using different approaches. If you have full control over the code to
execute in the driver callback, the best approach is to divide the work into
multiple chunks of work, and trigger multiple calls to the
<a href="driver_entry.html#timeout">time-out callback</a> using zero time-outs. Function
<a href="erl_driver.html#erl_drv_consume_timeslice"><code class="inline">erl_drv_consume_timeslice</code></a> can be
useful to determine when to trigger such time-out callback calls. However,
sometimes it cannot be implemented this way, for example when calling
third-party libraries. In this case, you typically want to dispatch the work to
another thread. Information about thread primitives is provided below.</p><h2 id="functionality" class="section-heading"><a href="#functionality" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Functionality</span></h2><p>All functions that a driver needs to do with Erlang are performed through driver
API functions. Functions exist for the following functionality:</p><ul><li><p><strong>Timer functions</strong> - Control the timer that a driver can use. The timer has
the emulator call the <a href="driver_entry.html#timeout"><code class="inline">timeout</code></a> entry function
after a specified time. Only one timer is available for each driver instance.</p></li><li><p><strong>Queue handling</strong> - Every driver instance has an associated queue. This queue
is a <code class="inline">SysIOVec</code>, which works as a buffer. It is mostly used for the driver to
buffer data that is to be written to a device, it is a byte stream. If the
port owner process closes the driver, and the queue is not empty, the driver
is not closed. This enables the driver to flush its buffers before closing.</p><p>The queue can be manipulated from any threads if a port data lock is used. For
more information, see <a href="erl_driver.html#ErlDrvPDL"><code class="inline">ErlDrvPDL</code></a>.</p></li><li><p><strong>Output functions</strong> - With these functions, the driver sends data back to the
emulator. The data is received as messages by the port owner process, see
<a href="erlang.html#open_port/2"><code class="inline">erlang:open_port/2</code></a>. The vector function and the function taking a driver
binary are faster, as they avoid copying the data buffer. There is also a fast
way of sending terms from the driver, without going through the binary term
format.</p></li><li><p><strong>Failure</strong> - The driver can exit and signal errors up to Erlang. This is only
for severe errors, when the driver cannot possibly keep open.</p></li><li><p><strong>Asynchronous calls</strong> - Erlang/OTP R7B and later versions have provision for
asynchronous function calls, using a thread pool provided by Erlang. There is
also a select call, which can be used for asynchronous drivers.</p></li><li><p><strong><a href="" id="multi_threading"></a> Multi-threading</strong><br/>A POSIX thread like API for multi-threading is provided. The Erlang driver
thread API only provides a subset of the functionality provided by the POSIX
thread API. The subset provided is more or less the basic functionality needed
for multi-threaded programming:</p><ul><li><a href="erl_driver.html#ErlDrvTid">Threads</a></li><li><a href="erl_driver.html#ErlDrvMutex">Mutexes</a></li><li><a href="erl_driver.html#ErlDrvCond">Condition variables</a></li><li><a href="erl_driver.html#ErlDrvRWLock">Read/write locks</a></li><li><a href="erl_driver.html#ErlDrvTSDKey">Thread-specific data</a></li></ul><p>The Erlang driver thread API can be used in conjunction with the POSIX thread
API on UN-ices and with the Windows native thread API on Windows. The Erlang
driver thread API has the advantage of being portable, but there can exist
situations where you want to use functionality from the POSIX thread API or
the Windows native thread API.</p><p>The Erlang driver thread API only returns error codes when it is reasonable to
recover from an error condition. If it is not reasonable to recover from an
error condition, the whole runtime system is terminated. For example, if a
create mutex operation fails, an error code is returned, but if a lock
operation on a mutex fails, the whole runtime system is terminated.</p><p>Notice that there is no &quot;condition variable wait with time-out&quot; in the Erlang
driver thread API. This because of issues with <code class="inline">pthread_cond_timedwait</code>. When
the system clock suddenly is changed, it is not always guaranteed that you
will wake up from the call as expected. An Erlang runtime system must be able
to cope with sudden changes of the system clock. Therefore, we have omitted it
from the Erlang driver thread API. In the Erlang driver case, time-outs can
and are to be handled with the timer functionality of the Erlang driver API.</p><p>Notice that many functions in the Erlang driver API are <em>not</em> thread-safe. If
a function is not documented as thread-safe, it is <em>not</em> thread-safe.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>When executing in an emulator thread, it is <em>very important</em> that you unlock
<em>all</em> locks you have locked before letting the thread out of your control;
otherwise you are <em>very likely</em> to deadlock the whole emulator.</p><p>If you need to use thread-specific data in an emulator thread, only have the
thread-specific data set while the thread is under your control, and clear
the thread-specific data before you let the thread out of your control.</p></section><p>In the future, debug functionality will probably be integrated with the Erlang
driver thread API. All functions that create entities take a <code class="inline">name</code> argument.
Currently the <code class="inline">name</code> argument is unused, but it will be used when the debug
functionality is implemented. If you name all entities created well, the debug
functionality will be able to give you better error reports.</p></li><li><p><strong>Adding/removing drivers</strong> - A driver can add and later remove drivers.</p></li><li><p><strong>Monitoring processes</strong> - A driver can monitor a process that does not own a
port.</p></li><li><p><strong><a href="" id="version_management"></a> Version management</strong><br/>Version management is enabled for drivers that have set the
<a href="driver_entry.html#extended_marker"><code class="inline">extended_marker</code></a> field of their
<a href="driver_entry.html"><code class="inline">driver_entry</code></a> to <code class="inline">ERL_DRV_EXTENDED_MARKER</code>. <code class="inline">erl_driver.h</code>
defines:</p><ul><li><code class="inline">ERL_DRV_EXTENDED_MARKER</code></li><li><code class="inline">ERL_DRV_EXTENDED_MAJOR_VERSION</code>, which is incremented when driver
incompatible changes are made to the Erlang runtime system. Normally it
suffices to recompile drivers when <code class="inline">ERL_DRV_EXTENDED_MAJOR_VERSION</code> has
changed, but it can, under rare circumstances, mean that drivers must be
slightly modified. If so, this will of course be documented.</li><li><code class="inline">ERL_DRV_EXTENDED_MINOR_VERSION</code>, which is incremented when new features are
added. The runtime system uses the minor version of the driver to determine
what features to use.</li></ul><p>The runtime system normally refuses to load a driver if the major versions
differ, or if the major versions are equal and the minor version used by the
driver is greater than the one used by the runtime system. Old drivers with
lower major versions are however allowed after a bump of the major version
during a transition period of two major releases. Such old drivers can,
however, fail if deprecated features are used.</p><p>The emulator refuses to load a driver that does not use the extended driver
interface, to allow for 64-bit capable drivers, as incompatible type changes
for the callbacks <a href="driver_entry.html#output"><code class="inline">output</code></a>,
<a href="driver_entry.html#control"><code class="inline">control</code></a>, and <a href="driver_entry.html#call"><code class="inline">call</code></a> were
introduced in Erlang/OTP R15B. A driver written with the old types would
compile with warnings and when called return garbage sizes to the emulator,
causing it to read random memory and create huge incorrect result blobs.</p><p>Therefore it is not enough to only recompile drivers written with version
management for pre R15B types; the types must be changed in the driver
suggesting other rewrites, especially regarding size variables. <em>Investigate
all warnings when recompiling.</em></p><p>Also, the API driver functions <code class="inline">driver_output*</code> and <code class="inline">driver_vec_to_buf</code>,
<code class="inline">driver_alloc/realloc*</code>, and the <code class="inline">driver_*</code> queue functions were changed to
have larger length arguments and return values. This is a lesser problem, as
code that passes smaller types gets them auto-converted in the calls, and as
long as the driver does not handle sizes that overflow an <code class="inline">int</code>, all will work
as before.</p></li><li><p><strong><a href="" id="time_measurement"></a> Time measurement</strong><br/>Support for time measurement in drivers:</p><ul><li><a href="erl_driver.html#ErlDrvTime"><code class="inline">ErlDrvTime</code></a></li><li><a href="erl_driver.html#ErlDrvTimeUnit"><code class="inline">ErlDrvTimeUnit</code></a></li><li><a href="erl_driver.html#erl_drv_monotonic_time"><code class="inline">erl_drv_monotonic_time</code></a></li><li><a href="erl_driver.html#erl_drv_time_offset"><code class="inline">erl_drv_time_offset</code></a></li><li><a href="erl_driver.html#erl_drv_convert_time_unit"><code class="inline">erl_drv_convert_time_unit</code></a></li></ul></li></ul><p><a href="" id="rewrites_for_64_bits"></a></p><h2 id="rewrites-for-64-bit-driver-interface" class="section-heading"><a href="#rewrites-for-64-bit-driver-interface" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Rewrites for 64-Bit Driver Interface</span></h2><p>ERTS 5.9 introduced two new integer types,
<a href="erl_driver.html#ErlDrvSizeT"><code class="inline">ErlDrvSizeT</code></a> and
<a href="erl_driver.html#ErlDrvSSizeT"><code class="inline">ErlDrvSSizeT</code></a>, which can hold 64-bit sizes if
necessary.</p><p>To not update a driver and only recompile, it probably works when building for a
32-bit machine creating a false sense of security. Hopefully that will generate
many important warnings. But when recompiling the same driver later on for a
64-bit machine, there <em>will</em> be warnings and almost certainly crashes. So it is
a <em>bad</em> idea to postpone updating the driver and not fixing the warnings.</p><p>When recompiling with <code class="inline">gcc</code>, use flag <code class="inline">-Wstrict-prototypes</code> to get better
warnings. Try to find a similar flag if you use another compiler.</p><p>The following is a checklist for rewriting a pre ERTS 5.9 driver, most important
first:</p><ul><li><p><strong>Return types for driver callbacks</strong> - Rewrite driver callback
<a href="driver_entry.html#control"><code class="inline">control</code></a> to use return type <code class="inline">ErlDrvSSizeT</code> instead
of <code class="inline">int</code>.</p><p>Rewrite driver callback <a href="driver_entry.html#call"><code class="inline">call</code></a> to use return type
<code class="inline">ErlDrvSSizeT</code> instead of <code class="inline">int</code>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>These changes are essential not to crash the emulator or worse cause
malfunction. Without them a driver can return garbage in the high 32 bits to
the emulator, causing it to build a huge result from random bytes, either
crashing on memory allocation or succeeding with a random result from the
driver call.</p></section></li><li><p><strong>Arguments to driver callbacks</strong> - Driver callback
<a href="driver_entry.html#output"><code class="inline">output</code></a> now gets <code class="inline">ErlDrvSizeT</code> as 3rd argument
instead of previously <code class="inline">int</code>.</p><p>Driver callback <a href="driver_entry.html#control"><code class="inline">control</code></a> now gets <code class="inline">ErlDrvSizeT</code> as
4th and 6th arguments instead of previously <code class="inline">int</code>.</p><p>Driver callback <a href="driver_entry.html#call"><code class="inline">call</code></a> now gets <code class="inline">ErlDrvSizeT</code> as 4th
and 6th arguments instead of previously <code class="inline">int</code>.</p><p>Sane compiler's calling conventions probably make these changes necessary only
for a driver to handle data chunks that require 64-bit size fields (mostly
larger than 2 GB, as that is what an <code class="inline">int</code> of 32 bits can hold). But it is
possible to think of non-sane calling conventions that would make the driver
callbacks mix up the arguments causing malfunction.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The argument type change is from signed to unsigned. This can cause problems
for, for example, loop termination conditions or error conditions if you
only change the types all over the place.</p></section></li><li><p><strong>Larger <code class="inline">size</code> field in <code class="inline">ErlIOVec</code></strong> - The <code class="inline">size</code> field in
<a href="erl_driver.html#ErlIOVec"><code class="inline">ErlIOVec</code></a> has been changed to <code class="inline">ErlDrvSizeT</code> from
<code class="inline">int</code>. Check all code that use that field.</p><p>Automatic type-casting probably makes these changes necessary only for a
driver that encounters sizes &gt; 32 bits.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The <code class="inline">size</code> field changed from signed to unsigned. This can cause problems
for, for example, loop termination conditions or error conditions if you
only change the types all over the place.</p></section></li><li><p><strong>Arguments and return values in the driver API</strong> - Many driver API functions
have changed argument type and/or return value to <code class="inline">ErlDrvSizeT</code> from mostly
<code class="inline">int</code>. Automatic type-casting probably makes these changes necessary only for
a driver that encounters sizes &gt; 32 bits.</p><ul><li><p><strong><a href="erl_driver.html#driver_output"><code class="inline">driver_output</code></a></strong> - 3rd argument</p></li><li><p><strong><a href="erl_driver.html#driver_output2"><code class="inline">driver_output2</code></a></strong> - 3rd and 5th arguments</p></li><li><p><strong><a href="erl_driver.html#driver_output_binary"><code class="inline">driver_output_binary</code></a></strong> - 3rd, 5th,
and 6th arguments</p></li><li><p><strong><a href="erl_driver.html#driver_outputv"><code class="inline">driver_outputv</code></a></strong> - 3rd and 5th arguments</p></li><li><p><strong><a href="erl_driver.html#driver_vec_to_buf"><code class="inline">driver_vec_to_buf</code></a></strong> - 3rd argument
and return value</p></li><li><p><strong><a href="erl_driver.html#driver_alloc"><code class="inline">driver_alloc</code></a></strong> - 1st argument</p></li><li><p><strong><a href="erl_driver.html#driver_realloc"><code class="inline">driver_realloc</code></a></strong> - 2nd argument</p></li><li><p><strong><a href="erl_driver.html#driver_alloc_binary"><code class="inline">driver_alloc_binary</code></a></strong> - 1st
argument</p></li><li><p><strong><a href="erl_driver.html#driver_realloc_binary"><code class="inline">driver_realloc_binary</code></a></strong> - 2nd
argument</p></li><li><p><strong><a href="erl_driver.html#driver_enq"><code class="inline">driver_enq</code></a></strong> - 3rd argument</p></li><li><p><strong><a href="erl_driver.html#driver_pushq"><code class="inline">driver_pushq</code></a></strong> - 3rd argument</p></li><li><p><strong><a href="erl_driver.html#driver_deq"><code class="inline">driver_deq</code></a></strong> - 2nd argument and return value</p></li><li><p><strong><a href="erl_driver.html#driver_sizeq"><code class="inline">driver_sizeq</code></a></strong> - Return value</p></li><li><p><strong><a href="erl_driver.html#driver_enq_bin"><code class="inline">driver_enq_bin</code></a></strong> - 3rd and 4th arguments</p></li><li><p><strong><a href="erl_driver.html#driver_pushq_bin"><code class="inline">driver_pushq_bin</code></a></strong> - 3rd and 4th
arguments</p></li><li><p><strong><a href="erl_driver.html#driver_enqv"><code class="inline">driver_enqv</code></a></strong> - 3rd argument</p></li><li><p><strong><a href="erl_driver.html#driver_pushqv"><code class="inline">driver_pushqv</code></a></strong> - 3rd argument</p></li><li><p><strong><a href="erl_driver.html#driver_peekqv"><code class="inline">driver_peekqv</code></a></strong> - Return value</p></li></ul><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>This is a change from signed to unsigned. This can cause problems for, for
example, loop termination conditions and error conditions if you only change
the types all over the place.</p></section></li></ul><h2 id="data-types" class="section-heading"><a href="#data-types" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Data Types</span></h2><ul><li><p><strong><code class="inline" id="ErlDrvSizeT">ErlDrvSizeT</code></strong> - An unsigned integer type to be used as
<code class="inline">size_t</code>.</p></li><li><p><strong><code class="inline" id="ErlDrvSSizeT">ErlDrvSSizeT</code></strong> - A signed integer type, the size of
<code class="inline">ErlDrvSizeT</code>.</p></li><li><p><strong><code class="inline" id="ErlDrvSysInfo">ErlDrvSysInfo</code></strong></p><pre><code class="makeup c" translate="no"><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="no">ErlDrvSysInfo</span><span class="w"> </span><span class="p" data-group-id="5924720019-1">{</span><span class="w">
   </span><span class="kt">int</span><span class="w"> </span><span class="n">driver_major_version</span><span class="p">;</span><span class="w">
   </span><span class="kt">int</span><span class="w"> </span><span class="n">driver_minor_version</span><span class="p">;</span><span class="w">
   </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">erts_version</span><span class="p">;</span><span class="w">
   </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">otp_release</span><span class="p">;</span><span class="w">
   </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_support</span><span class="p">;</span><span class="w">
   </span><span class="kt">int</span><span class="w"> </span><span class="n">smp_support</span><span class="p">;</span><span class="w">
   </span><span class="kt">int</span><span class="w"> </span><span class="n">async_threads</span><span class="p">;</span><span class="w">
   </span><span class="kt">int</span><span class="w"> </span><span class="n">scheduler_threads</span><span class="p">;</span><span class="w">
   </span><span class="kt">int</span><span class="w"> </span><span class="n">nif_major_version</span><span class="p">;</span><span class="w">
   </span><span class="kt">int</span><span class="w"> </span><span class="n">nif_minor_version</span><span class="p">;</span><span class="w">
   </span><span class="kt">int</span><span class="w"> </span><span class="n">dirty_scheduler_support</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="5924720019-1">}</span><span class="w"> </span><span class="no">ErlDrvSysInfo</span><span class="p">;</span></code></pre><p>The <code class="inline">ErlDrvSysInfo</code> structure is used for storage of information about the
Erlang runtime system.
<a href="erl_driver.html#driver_system_info"><code class="inline">driver_system_info</code></a> writes the system
information when passed a reference to a <code class="inline">ErlDrvSysInfo</code> structure. The fields
in the structure are as follows:</p><ul><li><p><strong><code class="inline">driver_major_version</code></strong> - The value of
<a href="erl_driver.html#version_management"><code class="inline">ERL_DRV_EXTENDED_MAJOR_VERSION</code></a> when
the runtime system was compiled. This value is the same as the value of
<a href="erl_driver.html#version_management"><code class="inline">ERL_DRV_EXTENDED_MAJOR_VERSION</code></a> used
when compiling the driver; otherwise the runtime system would have refused
to load the driver.</p></li><li><p><strong><code class="inline">driver_minor_version</code></strong> - The value of
<a href="erl_driver.html#version_management"><code class="inline">ERL_DRV_EXTENDED_MINOR_VERSION</code></a> when
the runtime system was compiled. This value can differ from the value of
<a href="erl_driver.html#version_management"><code class="inline">ERL_DRV_EXTENDED_MINOR_VERSION</code></a> used
when compiling the driver.</p></li><li><p><strong><code class="inline">erts_version</code></strong> - A string containing the version number of the runtime
system (the same as returned by
<a href="erlang.html#system_info_version"><code class="inline">erlang:system_info(version)</code></a>).</p></li><li><p><strong><code class="inline">otp_release</code></strong> - A string containing the OTP release number (the same as
returned by
<a href="erlang.html#system_info_otp_release"><code class="inline">erlang:system_info(otp_release)</code></a>).</p></li><li><p><strong><code class="inline">thread_support</code></strong> - A value <code class="inline">!= 0</code> if the runtime system has thread
support; otherwise <code class="inline">0</code>.</p></li><li><p><strong><code class="inline">smp_support</code></strong> - A value <code class="inline">!= 0</code> if the runtime system has SMP support;
otherwise <code class="inline">0</code>.</p></li><li><p><strong><code class="inline">async_threads</code></strong> - The number of async threads in the async thread pool
used by <a href="erl_driver.html#driver_async"><code class="inline">driver_async</code></a> (the same as returned
by
<a href="erlang.html#system_info_thread_pool_size"><code class="inline">erlang:system_info(thread_pool_size)</code></a>).</p></li><li><p><strong><code class="inline">scheduler_threads</code></strong> - The number of scheduler threads used by the
runtime system (the same as returned by
<a href="erlang.html#system_info_schedulers"><code class="inline">erlang:system_info(schedulers)</code></a>).</p></li><li><p><strong><code class="inline">nif_major_version</code></strong> - The value of <code class="inline">ERL_NIF_MAJOR_VERSION</code> when the
runtime system was compiled.</p></li><li><p><strong><code class="inline">nif_minor_version</code></strong> - The value of <code class="inline">ERL_NIF_MINOR_VERSION</code> when the
runtime system was compiled.</p></li><li><p><strong><code class="inline">dirty_scheduler_support</code></strong> - A value <code class="inline">!= 0</code> if the runtime system has
support for dirty scheduler threads; otherwise <code class="inline">0</code>.</p></li></ul></li><li><p><strong><code class="inline" id="ErlDrvBinary">ErlDrvBinary</code></strong></p><pre><code class="text">typedef struct ErlDrvBinary {
   ErlDrvSint orig_size;
   char orig_bytes[];
} ErlDrvBinary;</code></pre><p>The <code class="inline">ErlDrvBinary</code> structure is a binary, as sent between the emulator and the
driver. All binaries are reference counted; when <code class="inline">driver_binary_free</code> is
called, the reference count is decremented, when it reaches zero, the binary
is deallocated. <code class="inline">orig_size</code> is the binary size and <code class="inline">orig_bytes</code> is the buffer.
<code class="inline">ErlDrvBinary</code> has not a fixed size, its size is
<code class="inline">orig_size + 2 * sizeof(int)</code>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The <code class="inline">refc</code> field has been removed. The reference count of an <code class="inline">ErlDrvBinary</code>
is now stored elsewhere. The reference count of an <code class="inline">ErlDrvBinary</code> can be
accessed through
<a href="erl_driver.html#driver_binary_get_refc"><code class="inline">driver_binary_get_refc</code></a>,
<a href="erl_driver.html#driver_binary_inc_refc"><code class="inline">driver_binary_inc_refc</code></a>, and
<a href="erl_driver.html#driver_binary_dec_refc"><code class="inline">driver_binary_dec_refc</code></a>.</p></section><p>Some driver calls, such as <code class="inline">driver_enq_binary</code>, increment the driver reference
count, and others, such as <code class="inline">driver_deq</code> decrement it.</p><p>Using a driver binary instead of a normal buffer is often faster, as the
emulator needs not to copy the data, only the pointer is used.</p><p>A driver binary allocated in the driver, with <code class="inline">driver_alloc_binary</code>, is to be
freed in the driver (unless otherwise stated) with <code class="inline">driver_free_binary</code>.
(Notice that this does not necessarily deallocate it, if the driver is still
referred in the emulator, the ref-count will not go to zero.)</p><p>Driver binaries are used in the <code class="inline">driver_output2</code> and <code class="inline">driver_outputv</code> calls,
and in the queue. Also the driver callback
<a href="driver_entry.html#outputv"><code class="inline">outputv</code></a> uses driver binaries.</p><p>If the driver for some reason wants to keep a driver binary around, for
example in a static variable, the reference count is to be incremented, and
the binary can later be freed in the <a href="driver_entry.html#stop"><code class="inline">stop</code></a> callback,
with <code class="inline">driver_free_binary</code>.</p><p>Notice that as a driver binary is shared by the driver and the emulator. A
binary received from the emulator or sent to the emulator must not be changed
by the driver.</p><p>Since ERTS 5.5 (Erlang/OTP R11B), <code class="inline">orig_bytes</code> is guaranteed to be properly
aligned for storage of an array of doubles (usually 8-byte aligned).</p></li><li><p><strong><code class="inline">ErlDrvData</code></strong> - A handle to driver-specific data, passed to the driver
callbacks. It is a pointer, and is most often type cast to a specific pointer
in the driver.</p></li><li><p><strong><code class="inline">SysIOVec</code></strong> - A system I/O vector, as used by <code class="inline">writev</code> on Unix and
<code class="inline">WSASend</code> on Win32. It is used in <code class="inline">ErlIOVec</code>.</p></li><li><p><strong><code class="inline" id="ErlIOVec">ErlIOVec</code></strong></p><pre><code class="makeup c" translate="no"><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="no">ErlIOVec</span><span class="w"> </span><span class="p" data-group-id="0817005201-1">{</span><span class="w">
  </span><span class="kt">int</span><span class="w"> </span><span class="n">vsize</span><span class="p">;</span><span class="w">
  </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">
  </span><span class="no">SysIOVec</span><span class="o">*</span><span class="w"> </span><span class="n">iov</span><span class="p">;</span><span class="w">
  </span><span class="no">ErlDrvBinary</span><span class="o">*</span><span class="o">*</span><span class="w"> </span><span class="n">binv</span><span class="p">;</span><span class="w">
</span><span class="p" data-group-id="0817005201-1">}</span><span class="w"> </span><span class="no">ErlIOVec</span><span class="p">;</span></code></pre><p>The I/O vector used by the emulator and drivers is a list of binaries, with a
<code class="inline">SysIOVec</code> pointing to the buffers of the binaries. It is used in
<code class="inline">driver_outputv</code> and the <a href="driver_entry.html#outputv"><code class="inline">outputv</code></a> driver callback.
Also, the driver queue is an <code class="inline">ErlIOVec</code>.</p></li><li><p><strong><code class="inline">ErlDrvMonitor</code></strong> - When a driver creates a monitor for a process, a
<code class="inline">ErlDrvMonitor</code> is filled in. This is an opaque data type that can be assigned
to, but not compared without using the supplied compare function (that is, it
behaves like a struct).</p><p>The driver writer is to provide the memory for storing the monitor when
calling <a href="erl_driver.html#driver_monitor_process"><code class="inline">driver_monitor_process</code></a>. The
address of the data is not stored outside of the driver, so <code class="inline">ErlDrvMonitor</code>
can be used as any other data, it can be copied, moved in memory, forgotten,
and so on.</p></li><li><p><strong><code class="inline" id="ErlDrvNowData">ErlDrvNowData</code></strong> - The <code class="inline">ErlDrvNowData</code> structure holds a
time stamp consisting of three values measured from some arbitrary point in
the past. The three structure members are:</p><ul><li><p><strong><code class="inline">megasecs</code></strong> - The number of whole megaseconds elapsed since the arbitrary
point in time</p></li><li><p><strong><code class="inline">secs</code></strong> - The number of whole seconds elapsed since the arbitrary point
in time</p></li><li><p><strong><code class="inline">microsecs</code></strong> - The number of whole microseconds elapsed since the
arbitrary point in time</p></li></ul></li><li><p><strong><code class="inline" id="ErlDrvPDL">ErlDrvPDL</code></strong> - If certain port-specific data must be
accessed from other threads than those calling the driver callbacks, a port
data lock can be used to synchronize the operations on the data. Currently,
the only port-specific data that the emulator associates with the port data
lock is the driver queue.</p><p>Normally a driver instance has no port data lock. If the driver instance wants
to use a port data lock, it must create the port data lock by calling
<a href="erl_driver.html#driver_pdl_create"><code class="inline">driver_pdl_create</code></a>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Once the port data lock has been created, every access to data associated
with the port data lock must be done while the port data lock is locked. The
port data lock is locked and unlocked by
<a href="erl_driver.html#driver_pdl_lock"><code class="inline">driver_pdl_lock</code></a>, and
<a href="erl_driver.html#driver_pdl_unlock"><code class="inline">driver_pdl_unlock</code></a>, respectively.</p></section><p>A port data lock is reference counted, and when the reference count reaches
zero, it is destroyed. The emulator at least increments the reference count
once when the lock is created and decrements it once the port associated with
the lock terminates. The emulator also increments the reference count when an
async job is enqueued and decrements it when an async job has been invoked.
Also, the driver is responsible for ensuring that the reference count does not
reach zero before the last use of the lock by the driver has been made. The
reference count can be read, incremented, and decremented by
<a href="erl_driver.html#driver_pdl_get_refc"><code class="inline">driver_pdl_get_refc</code></a>,
<a href="erl_driver.html#driver_pdl_inc_refc"><code class="inline">driver_pdl_inc_refc</code></a>, and
<a href="erl_driver.html#driver_pdl_dec_refc"><code class="inline">driver_pdl_dec_refc</code></a>, respectively.</p></li><li><p><strong><code class="inline" id="ErlDrvTid">ErlDrvTid</code></strong> - Thread identifier.</p><p>See also <a href="erl_driver.html#erl_drv_thread_create"><code class="inline">erl_drv_thread_create</code></a>,
<a href="erl_driver.html#erl_drv_thread_exit"><code class="inline">erl_drv_thread_exit</code></a>,
<a href="erl_driver.html#erl_drv_thread_join"><code class="inline">erl_drv_thread_join</code></a>,
<a href="erl_driver.html#erl_drv_thread_self"><code class="inline">erl_drv_thread_self</code></a>, and
<a href="erl_driver.html#erl_drv_equal_tids"><code class="inline">erl_drv_equal_tids</code></a>.</p></li><li><p><strong><code class="inline" id="ErlDrvThreadOpts">ErlDrvThreadOpts</code></strong></p><pre><code class="text">int suggested_stack_size;</code></pre><p>Thread options structure passed to
<a href="erl_driver.html#erl_drv_thread_create"><code class="inline">erl_drv_thread_create</code></a>. The following
field exists:</p><ul><li><strong><code class="inline">suggested_stack_size</code></strong> - A suggestion, in kilowords, on how large a
stack to use. A value &lt; 0 means default size.</li></ul><p>See also
<a href="erl_driver.html#erl_drv_thread_opts_create"><code class="inline">erl_drv_thread_opts_create</code></a>,
<a href="erl_driver.html#erl_drv_thread_opts_destroy"><code class="inline">erl_drv_thread_opts_destroy</code></a>,
and <a href="erl_driver.html#erl_drv_thread_create"><code class="inline">erl_drv_thread_create</code></a>.</p></li><li><p><strong><code class="inline" id="ErlDrvMutex">ErlDrvMutex</code></strong> - Mutual exclusion lock. Used for
synchronizing access to shared data. Only one thread at a time can lock a
mutex.</p><p>See also <a href="erl_driver.html#erl_drv_mutex_create"><code class="inline">erl_drv_mutex_create</code></a>,
<a href="erl_driver.html#erl_drv_mutex_destroy"><code class="inline">erl_drv_mutex_destroy</code></a>,
<a href="erl_driver.html#erl_drv_mutex_lock"><code class="inline">erl_drv_mutex_lock</code></a>,
<a href="erl_driver.html#erl_drv_mutex_trylock"><code class="inline">erl_drv_mutex_trylock</code></a>, and
<a href="erl_driver.html#erl_drv_mutex_unlock"><code class="inline">erl_drv_mutex_unlock</code></a>.</p></li><li><p><strong><code class="inline" id="ErlDrvCond">ErlDrvCond</code></strong> - Condition variable. Used when threads must
wait for a specific condition to appear before continuing execution. Condition
variables must be used with associated mutexes.</p><p>See also <a href="erl_driver.html#erl_drv_cond_create"><code class="inline">erl_drv_cond_create</code></a>,
<a href="erl_driver.html#erl_drv_cond_destroy"><code class="inline">erl_drv_cond_destroy</code></a>,
<a href="erl_driver.html#erl_drv_cond_signal"><code class="inline">erl_drv_cond_signal</code></a>,
<a href="erl_driver.html#erl_drv_cond_broadcast"><code class="inline">erl_drv_cond_broadcast</code></a>, and
<a href="erl_driver.html#erl_drv_cond_wait"><code class="inline">erl_drv_cond_wait</code></a>.</p></li><li><p><strong><code class="inline" id="ErlDrvRWLock">ErlDrvRWLock</code></strong> - Read/write lock. Used to allow multiple
threads to read shared data while only allowing one thread to write the same
data. Multiple threads can read lock an rwlock at the same time, while only
one thread can read/write lock an rwlock at a time.</p><p>See also <a href="erl_driver.html#erl_drv_rwlock_create"><code class="inline">erl_drv_rwlock_create</code></a>,
<a href="erl_driver.html#erl_drv_rwlock_destroy"><code class="inline">erl_drv_rwlock_destroy</code></a>,
<a href="erl_driver.html#erl_drv_rwlock_rlock"><code class="inline">erl_drv_rwlock_rlock</code></a>,
<a href="erl_driver.html#erl_drv_rwlock_tryrlock"><code class="inline">erl_drv_rwlock_tryrlock</code></a>,
<a href="erl_driver.html#erl_drv_rwlock_runlock"><code class="inline">erl_drv_rwlock_runlock</code></a>,
<a href="erl_driver.html#erl_drv_rwlock_rwlock"><code class="inline">erl_drv_rwlock_rwlock</code></a>,
<a href="erl_driver.html#erl_drv_rwlock_tryrwlock"><code class="inline">erl_drv_rwlock_tryrwlock</code></a>, and
<a href="erl_driver.html#erl_drv_rwlock_rwunlock"><code class="inline">erl_drv_rwlock_rwunlock</code></a>.</p></li><li><p><strong><code class="inline" id="ErlDrvTSDKey">ErlDrvTSDKey</code></strong> - Key that thread-specific data can be
associated with.</p><p>See also <a href="erl_driver.html#erl_drv_tsd_key_create"><code class="inline">erl_drv_tsd_key_create</code></a>,
<a href="erl_driver.html#erl_drv_tsd_key_destroy"><code class="inline">erl_drv_tsd_key_destroy</code></a>,
<a href="erl_driver.html#erl_drv_tsd_set"><code class="inline">erl_drv_tsd_set</code></a>, and
<a href="erl_driver.html#erl_drv_tsd_get"><code class="inline">erl_drv_tsd_get</code></a>.</p></li><li><p><strong><code class="inline" id="ErlDrvTime">ErlDrvTime</code></strong> - A signed 64-bit integer type for time
representation.</p></li><li><p><strong><code class="inline" id="ErlDrvTimeUnit">ErlDrvTimeUnit</code></strong> - An enumeration of time units
supported by the driver API:</p><ul><li><p><strong><code class="inline">ERL_DRV_SEC</code></strong> - Seconds</p></li><li><p><strong><code class="inline">ERL_DRV_MSEC</code></strong> - Milliseconds</p></li><li><p><strong><code class="inline">ERL_DRV_USEC</code></strong> - Microseconds</p></li><li><p><strong><code class="inline">ERL_DRV_NSEC</code></strong> - Nanoseconds</p></li></ul></li></ul><h2 id="add_driver_entry" class="section-heading"><a href="#add_driver_entry" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">add_driver_entry()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">add_driver_entry</span><span class="p" data-group-id="2594497418-1">(</span><span class="no">ErlDrvEntry</span><span class="w">
        </span><span class="o">*</span><span class="n">de</span><span class="p" data-group-id="2594497418-1">)</span><span class="p">;</span></code></pre><p>Adds a driver entry to the list of drivers known by Erlang. The
<a href="driver_entry.html#init"><code class="inline">init</code></a> function of parameter <code class="inline">de</code> is called.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>To use this function for adding drivers residing in dynamically loaded code is
dangerous. If the driver code for the added driver resides in the same
dynamically loaded module (that is, <code class="inline">.so</code> file) as a normal dynamically loaded
driver (loaded with the <code class="inline">erl_ddll</code> interface), the caller is to call
<a href="erl_driver.html#driver_lock_driver"><code class="inline">driver_lock_driver</code></a> before adding driver
entries.</p><p><em>Use of this function is generally deprecated.</em></p></section><h2 id="driver_alloc" class="section-heading"><a href="#driver_alloc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_alloc()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">driver_alloc</span><span class="p" data-group-id="0076909520-1">(</span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="0076909520-1">)</span><span class="p">;</span></code></pre><p>Allocates a memory block of the size specified in <code class="inline">size</code>, and returns it. This
fails only on out of memory, in which case <code class="inline">NULL</code> is returned. (This is most
often a wrapper for <code class="inline">malloc</code>).</p><p>Memory allocated must be explicitly freed with a corresponding call to
<a href="erl_driver.html#driver_free"><code class="inline">driver_free</code></a> (unless otherwise stated).</p><p>This function is thread-safe.</p><h2 id="driver_alloc_binary" class="section-heading"><a href="#driver_alloc_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_alloc_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvBinary</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">driver_alloc_binary</span><span class="p" data-group-id="8764216740-1">(</span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="8764216740-1">)</span><span class="p">;</span></code></pre><p>Allocates a driver binary with a memory block of at least <code class="inline">size</code> bytes, and
returns a pointer to it, or <code class="inline">NULL</code> on failure (out of memory). When a driver
binary has been sent to the emulator, it must not be changed. Every allocated
binary is to be freed by a corresponding call to
<a href="erl_driver.html#driver_free_binary"><code class="inline">driver_free_binary</code></a> (unless otherwise
stated).</p><p>Notice that a driver binary has an internal reference counter. This means that
calling <code class="inline">driver_free_binary</code>, it may not actually dispose of it. If it is sent
to the emulator, it can be referenced there.</p><p>The driver binary has a field, <code class="inline">orig_bytes</code>, which marks the start of the data
in the binary.</p><p>This function is thread-safe.</p><h2 id="driver_async" class="section-heading"><a href="#driver_async" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_async()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">long</span><span class="w"> </span><span class="nf">driver_async</span><span class="p" data-group-id="6654041353-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w">
        </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kc">void</span><span class="w"> </span><span class="p" data-group-id="6654041353-2">(</span><span class="o">*</span><span class="n">async_invoke</span><span class="p" data-group-id="6654041353-2">)</span><span class="p" data-group-id="6654041353-3">(</span><span class="kc">void</span><span class="o">*</span><span class="p" data-group-id="6654041353-3">)</span><span class="p">,</span><span class="w"> </span><span class="kc">void</span><span class="o">*</span><span class="w"> </span><span class="n">async_data</span><span class="p">,</span><span class="w"> </span><span class="kc">void</span><span class="w">
        </span><span class="p" data-group-id="6654041353-4">(</span><span class="o">*</span><span class="n">async_free</span><span class="p" data-group-id="6654041353-4">)</span><span class="p" data-group-id="6654041353-5">(</span><span class="kc">void</span><span class="o">*</span><span class="p" data-group-id="6654041353-5">)</span><span class="p" data-group-id="6654041353-1">)</span><span class="p">;</span></code></pre><p>Performs an asynchronous call. The function <code class="inline">async_invoke</code> is invoked in a
thread separate from the emulator thread. This enables the driver to perform
time-consuming, blocking operations without blocking the emulator.</p><p>The async thread pool size can be set with command-line argument
<a href="erl_cmd.html#async_thread_pool_size"><code class="inline">+A</code></a> in <a href="erl_cmd.html"><code class="inline">erl(1)</code></a>. If an async
thread pool is unavailable, the call is made synchronously in the thread calling
<code class="inline">driver_async</code>. The current number of async threads in the async thread pool can
be retrieved through <a href="erl_driver.html#driver_system_info"><code class="inline">driver_system_info</code></a>.</p><p>If a thread pool is available, a thread is used. If argument <code class="inline">key</code> is <code class="inline">NULL</code>,
the threads from the pool are used in a round-robin way, each call to
<code class="inline">driver_async</code> uses the next thread in the pool. With argument <code class="inline">key</code> set, this
behavior is changed. The two same values of <code class="inline">*key</code> always get the same thread.</p><p>To ensure that a driver instance always uses the same thread, the following call
can be used:</p><pre><code class="text">unsigned int myKey = driver_async_port_key(myPort);

r = driver_async(myPort, &amp;myKey, myData, myFunc);</code></pre><p>It is enough to initialize <code class="inline">myKey</code> once for each driver instance.</p><p>If a thread is already working, the calls are queued up and executed in order.
Using the same thread for each driver instance ensures that the calls are made
in sequence.</p><p>The <code class="inline">async_data</code> is the argument to the functions <code class="inline">async_invoke</code> and
<code class="inline">async_free</code>. It is typically a pointer to a structure containing a pipe or
event that can be used to signal that the async operation completed. The data is
to be freed in <code class="inline">async_free</code>.</p><p>When the async operation is done, <a href="driver_entry.html#ready_async"><code class="inline">ready_async</code></a>
driver entry function is called. If <code class="inline">ready_async</code> is <code class="inline">NULL</code> in the driver entry,
the <code class="inline">async_free</code> function is called instead.</p><p>The return value is <code class="inline">-1</code> if the <code class="inline">driver_async</code> call fails.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>As from ERTS 5.5.4.3 the default stack size for threads in the async-thread
pool is 16 kilowords, that is, 64 kilobyte on 32-bit architectures. This small
default size has been chosen because the amount of async-threads can be quite
large. The default stack size is enough for drivers delivered with Erlang/OTP,
but is possibly not sufficiently large for other dynamically linked-in drivers
that use the <code class="inline">driver_async</code> functionality. A suggested stack size for threads
in the async-thread pool can be configured through command-line argument
<a href="erl_cmd.html#async_thread_stack_size"><code class="inline">+a</code></a> in <a href="erl_cmd.html"><code class="inline">erl(1)</code></a>.</p></section><h2 id="driver_async_port_key" class="section-heading"><a href="#driver_async_port_key" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_async_port_key()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">driver_async_port_key</span><span class="p" data-group-id="3281354579-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p" data-group-id="3281354579-1">)</span><span class="p">;</span></code></pre><p>Calculates a key for later use in <a href="erl_driver.html#driver_async"><code class="inline">driver_async</code></a>.
The keys are evenly distributed so that a fair mapping between port IDs and
async thread IDs is achieved.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Before Erlang/OTP R16, the port ID could be used as a key with proper casting,
but after the rewrite of the port subsystem, this is no longer the case. With
this function, you can achieve the same distribution based on port IDs as
before Erlang/OTP R16.</p></section><p>Available since OTP R16B02</p><h2 id="driver_binary_dec_refc" class="section-heading"><a href="#driver_binary_dec_refc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_binary_dec_refc()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">long</span><span class="w"> </span><span class="nf">driver_binary_dec_refc</span><span class="p" data-group-id="5996409161-1">(</span><span class="no">ErlDrvBinary</span><span class="w"> </span><span class="o">*</span><span class="n">bin</span><span class="p" data-group-id="5996409161-1">)</span><span class="p">;</span></code></pre><p>Decrements the reference count on <code class="inline">bin</code> and returns the reference count reached
after the decrement.</p><p>This function is thread-safe.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The reference count of driver binary is normally to be decremented by calling
<a href="erl_driver.html#driver_free_binary"><code class="inline">driver_free_binary</code></a>.</p><p><code class="inline">driver_binary_dec_refc</code> does <em>not</em> free the binary if the reference count
reaches zero. <em>Only</em> use <code class="inline">driver_binary_dec_refc</code> when you are sure <em>not</em> to
reach a reference count of zero.</p></section><h2 id="driver_binary_get_refc" class="section-heading"><a href="#driver_binary_get_refc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_binary_get_refc()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">long</span><span class="w"> </span><span class="nf">driver_binary_get_refc</span><span class="p" data-group-id="1480073173-1">(</span><span class="no">ErlDrvBinary</span><span class="w"> </span><span class="o">*</span><span class="n">bin</span><span class="p" data-group-id="1480073173-1">)</span><span class="p">;</span></code></pre><p>Returns the current reference count on <code class="inline">bin</code>.</p><p>This function is thread-safe.</p><h2 id="driver_binary_inc_refc" class="section-heading"><a href="#driver_binary_inc_refc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_binary_inc_refc()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">long</span><span class="w"> </span><span class="nf">driver_binary_inc_refc</span><span class="p" data-group-id="5726609687-1">(</span><span class="no">ErlDrvBinary</span><span class="w"> </span><span class="o">*</span><span class="n">bin</span><span class="p" data-group-id="5726609687-1">)</span><span class="p">;</span></code></pre><p>Increments the reference count on <code class="inline">bin</code> and returns the reference count reached
after the increment.</p><p>This function is thread-safe.</p><h2 id="driver_caller" class="section-heading"><a href="#driver_caller" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_caller()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvTermData</span><span class="w"> </span><span class="nf">driver_caller</span><span class="p" data-group-id="6072654135-1">(</span><span class="no">ErlDrvPort</span><span class="w">
        </span><span class="n">port</span><span class="p" data-group-id="6072654135-1">)</span><span class="p">;</span></code></pre><p>Returns the process ID of the process that made the current call to the driver.
The process ID can be used with
<a href="erl_driver.html#driver_send_term"><code class="inline">driver_send_term</code></a> to send back data to the
caller. <code class="inline">driver_caller</code> only returns valid data when currently executing in one
of the following driver callbacks:</p><ul><li><p><strong><a href="driver_entry.html#start"><code class="inline">start</code></a></strong> - Called from <a href="erlang.html#open_port/2"><code class="inline">erlang:open_port/2</code></a>.</p></li><li><p><strong><a href="driver_entry.html#output"><code class="inline">output</code></a></strong> - Called from <a href="erlang.html#send/2"><code class="inline">erlang:send/2</code></a> and
<a href="erlang.html#port_command/2"><code class="inline">erlang:port_command/2</code></a>.</p></li><li><p><strong><a href="driver_entry.html#outputv"><code class="inline">outputv</code></a></strong> - Called from <a href="erlang.html#send/2"><code class="inline">erlang:send/2</code></a> and
<a href="erlang.html#port_command/2"><code class="inline">erlang:port_command/2</code></a>.</p></li><li><p><strong><a href="driver_entry.html#control"><code class="inline">control</code></a></strong> - Called from
<a href="erlang.html#port_control/3"><code class="inline">erlang:port_control/3</code></a>.</p></li><li><p><strong><a href="driver_entry.html#call"><code class="inline">call</code></a></strong> - Called from <a href="erlang.html#port_call/3"><code class="inline">erlang:port_call/3</code></a>.</p></li></ul><p>Notice that this function is <em>not</em> thread-safe.</p><h2 id="driver_cancel_timer" class="section-heading"><a href="#driver_cancel_timer" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_cancel_timer()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_cancel_timer</span><span class="p" data-group-id="6939580788-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p" data-group-id="6939580788-1">)</span><span class="p">;</span></code></pre><p>Cancels a timer set with <a href="erl_driver.html#driver_set_timer"><code class="inline">driver_set_timer</code></a>.</p><p>The return value is <code class="inline">0</code>.</p><h2 id="driver_compare_monitors" class="section-heading"><a href="#driver_compare_monitors" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_compare_monitors()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_compare_monitors</span><span class="p" data-group-id="7644724999-1">(</span><span class="k">const</span><span class="w"> </span><span class="no">ErlDrvMonitor</span><span class="w">
        </span><span class="o">*</span><span class="n">monitor1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="no">ErlDrvMonitor</span><span class="w"> </span><span class="o">*</span><span class="n">monitor2</span><span class="p" data-group-id="7644724999-1">)</span><span class="p">;</span></code></pre><p>Compares two <code class="inline">ErlDrvMonitor</code>s. Can also be used to imply some artificial order
on monitors, for whatever reason.</p><p>Returns <code class="inline">0</code> if <code class="inline">monitor1</code> and <code class="inline">monitor2</code> are equal, &lt; <code class="inline">0</code> if <code class="inline">monitor1</code> &lt;
<code class="inline">monitor2</code>, and &gt; <code class="inline">0</code> if <code class="inline">monitor1</code> &gt; <code class="inline">monitor2</code>.</p><h2 id="driver_connected" class="section-heading"><a href="#driver_connected" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_connected()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvTermData</span><span class="w"> </span><span class="nf">driver_connected</span><span class="p" data-group-id="0938729116-1">(</span><span class="no">ErlDrvPort</span><span class="w">
        </span><span class="n">port</span><span class="p" data-group-id="0938729116-1">)</span><span class="p">;</span></code></pre><p>Returns the port owner process.</p><p>Notice that this function is <em>not</em> thread-safe.</p><h2 id="driver_create_port" class="section-heading"><a href="#driver_create_port" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_create_port()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvPort</span><span class="w"> </span><span class="nf">driver_create_port</span><span class="p" data-group-id="2531023172-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvTermData</span><span class="w"> </span><span class="n">owner_pid</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvData</span><span class="w"> </span><span class="n">drv_data</span><span class="p" data-group-id="2531023172-1">)</span><span class="p">;</span></code></pre><p>Creates a new port executing the same driver code as the port creating the new
port.</p><ul><li><p><strong><code class="inline">port</code></strong> - The port handle of the port (driver instance) creating the new
port.</p></li><li><p><strong><code class="inline">owner_pid</code></strong> - The process ID of the Erlang process to become owner of the
new port. This process will be linked to the new port. You usually want to use
<code class="inline">driver_caller(port)</code> as <code class="inline">owner_pid</code>.</p></li><li><p><strong><code class="inline">name</code></strong> - The port name of the new port. You usually want to use the same
port name as the driver name (<a href="driver_entry.html#driver_name"> <code class="inline">driver_name</code></a>
field of the <a href="driver_entry.html"><code class="inline">driver_entry</code></a>).</p></li><li><p><strong><code class="inline">drv_data</code></strong> - The driver-defined handle that is passed in later calls to
driver callbacks. Notice that the
<a href="driver_entry.html#start">driver start callback</a> is not called for this new
driver instance. The driver-defined handle is normally created in the
<a href="driver_entry.html#start">driver start callback</a> when a port is created through
<a href="erlang.html#open_port/2"><code class="inline">erlang:open_port/2</code></a>.</p></li></ul><p>The caller of <code class="inline">driver_create_port</code> is allowed to manipulate the newly created
port when <code class="inline">driver_create_port</code> has returned. When
<a href="erl_driver.html#smp_support">port level locking</a> is used, the creating port is
only allowed to manipulate the newly created port until the current driver
callback, which was called by the emulator, returns.</p><h2 id="driver_demonitor_process" class="section-heading"><a href="#driver_demonitor_process" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_demonitor_process()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_demonitor_process</span><span class="p" data-group-id="4297522179-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="k">const</span><span class="w"> </span><span class="no">ErlDrvMonitor</span><span class="w"> </span><span class="o">*</span><span class="n">monitor</span><span class="p" data-group-id="4297522179-1">)</span><span class="p">;</span></code></pre><p>Cancels a monitor created earlier.</p><p>Returns <code class="inline">0</code> if a monitor was removed and &gt; 0 if the monitor no longer exists.</p><h2 id="driver_deq" class="section-heading"><a href="#driver_deq" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_deq()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="nf">driver_deq</span><span class="p" data-group-id="7898133068-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="7898133068-1">)</span><span class="p">;</span></code></pre><p>Dequeues data by moving the head pointer forward in the driver queue by <code class="inline">size</code>
bytes. The data in the queue is deallocated.</p><p>Returns the number of bytes remaining in the queue on success, otherwise <code class="inline">-1</code>.</p><p>This function can be called from any thread if a
<a href="erl_driver.html#ErlDrvPDL">port data lock</a> associated with the <code class="inline">port</code> is locked
by the calling thread during the call.</p><h2 id="driver_enq" class="section-heading"><a href="#driver_enq" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_enq()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_enq</span><span class="p" data-group-id="0467588892-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="0467588892-1">)</span><span class="p">;</span></code></pre><p>Enqueues data in the driver queue. The data in <code class="inline">buf</code> is copied (<code class="inline">len</code> bytes) and
placed at the end of the driver queue. The driver queue is normally used in a
FIFO way.</p><p>The driver queue is available to queue output from the emulator to the driver
(data from the driver to the emulator is queued by the emulator in normal Erlang
message queues). This can be useful if the driver must wait for slow devices,
and so on, and wants to yield back to the emulator. The driver queue is
implemented as an <code class="inline">ErlIOVec</code>.</p><p>When the queue contains data, the driver does not close until the queue is
empty.</p><p>The return value is <code class="inline">0</code>.</p><p>This function can be called from any thread if a
<a href="erl_driver.html#ErlDrvPDL">port data lock</a> associated with the <code class="inline">port</code> is locked
by the calling thread during the call.</p><h2 id="driver_enq_bin" class="section-heading"><a href="#driver_enq_bin" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_enq_bin()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_enq_bin</span><span class="p" data-group-id="9389390260-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvBinary</span><span class="w"> </span><span class="o">*</span><span class="n">bin</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="9389390260-1">)</span><span class="p">;</span></code></pre><p>Enqueues a driver binary in the driver queue. The data in <code class="inline">bin</code> at <code class="inline">offset</code> with
length <code class="inline">len</code> is placed at the end of the queue. This function is most often
faster than <a href="erl_driver.html#driver_enq"><code class="inline">driver_enq</code></a>, because no data must be
copied.</p><p>This function can be called from any thread if a
<a href="erl_driver.html#ErlDrvPDL">port data lock</a> associated with the <code class="inline">port</code> is locked
by the calling thread during the call.</p><p>The return value is <code class="inline">0</code>.</p><h2 id="driver_enqv" class="section-heading"><a href="#driver_enqv" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_enqv()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_enqv</span><span class="p" data-group-id="0714542765-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="no">ErlIOVec</span><span class="w"> </span><span class="o">*</span><span class="n">ev</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">skip</span><span class="p" data-group-id="0714542765-1">)</span><span class="p">;</span></code></pre><p>Enqueues the data in <code class="inline">ev</code>, skipping the first <code class="inline">skip</code> bytes of it, at the end of
the driver queue. It is faster than <a href="erl_driver.html#driver_enq"><code class="inline">driver_enq</code></a>,
because no data must be copied.</p><p>The return value is <code class="inline">0</code>.</p><p>This function can be called from any thread if a
<a href="erl_driver.html#ErlDrvPDL">port data lock</a> associated with the <code class="inline">port</code> is locked
by the calling thread during the call.</p><h2 id="driver_failure" class="section-heading"><a href="#driver_failure" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_failure()</span></h2><h2 id="driver_failure_atom" class="section-heading"><a href="#driver_failure_atom" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_failure_atom()</span></h2><h2 id="driver_failure_posix" class="section-heading"><a href="#driver_failure_posix" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_failure_posix()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_failure</span><span class="p" data-group-id="8248829284-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w">
        </span><span class="n">error</span><span class="p" data-group-id="8248829284-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_failure_atom</span><span class="p" data-group-id="0841459978-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w">
        </span><span class="o">*</span><span class="n">string</span><span class="p" data-group-id="0841459978-1">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_failure_posix</span><span class="p" data-group-id="9394024429-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w">
        </span><span class="n">error</span><span class="p" data-group-id="9394024429-1">)</span><span class="p">;</span></code></pre><p>Signals to Erlang that the driver has encountered an error and is to be closed.
The port is closed and the tuple <code class="inline">{'EXIT', error, Err}</code> is sent to the port
owner process, where error is an error atom (<code class="inline">driver_failure_atom</code> and
<code class="inline">driver_failure_posix</code>) or an integer (<code class="inline">driver_failure</code>).</p><p>The driver is to fail only when in severe error situations, when the driver
cannot possibly keep open, for example, buffer allocation gets out of memory.
For normal errors it is more appropriate to send error codes with
<a href="erl_driver.html#driver_output"><code class="inline">driver_output</code></a>.</p><p>The return value is <code class="inline">0</code>.</p><h2 id="driver_failure_eof" class="section-heading"><a href="#driver_failure_eof" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_failure_eof()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_failure_eof</span><span class="p" data-group-id="5692973003-1">(</span><span class="no">ErlDrvPort</span><span class="w">
        </span><span class="n">port</span><span class="p" data-group-id="5692973003-1">)</span><span class="p">;</span></code></pre><p>Signals to Erlang that the driver has encountered an EOF and is to be closed,
unless the port was opened with option <code class="inline">eof</code>, in which case <code class="inline">eof</code> is sent to the
port. Otherwise the port is closed and an <code class="inline">'EXIT'</code> message is sent to the port
owner process.</p><p>The return value is <code class="inline">0</code>.</p><h2 id="driver_free" class="section-heading"><a href="#driver_free" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_free()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">driver_free</span><span class="p" data-group-id="8041567358-1">(</span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p" data-group-id="8041567358-1">)</span><span class="p">;</span></code></pre><p>Frees the memory pointed to by <code class="inline">ptr</code>. The memory is to have been allocated with
<code class="inline">driver_alloc</code>. All allocated memory is to be deallocated, only once. There is
no garbage collection in drivers.</p><p>This function is thread-safe.</p><h2 id="driver_free_binary" class="section-heading"><a href="#driver_free_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_free_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">driver_free_binary</span><span class="p" data-group-id="4241935467-1">(</span><span class="no">ErlDrvBinary</span><span class="w"> </span><span class="o">*</span><span class="n">bin</span><span class="p" data-group-id="4241935467-1">)</span><span class="p">;</span></code></pre><p>Frees a driver binary <code class="inline">bin</code>, allocated previously with
<a href="erl_driver.html#driver_alloc_binary"><code class="inline">driver_alloc_binary</code></a>. As binaries in
Erlang are reference counted, the binary can still be around.</p><p>This function is thread-safe.</p><h2 id="driver_get_monitored_process" class="section-heading"><a href="#driver_get_monitored_process" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_get_monitored_process()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvTermData</span><span class="w"> </span><span class="nf">driver_get_monitored_process</span><span class="p" data-group-id="1721419763-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w">
        </span><span class="no">ErlDrvMonitor</span><span class="w"> </span><span class="o">*</span><span class="n">monitor</span><span class="p" data-group-id="1721419763-1">)</span><span class="p">;</span></code></pre><p>Returns the process ID associated with a living monitor. It can be used in the
<a href="driver_entry.html#process_exit"><code class="inline">process_exit</code></a> callback to get the process
identification for the exiting process.</p><p>Returns <code class="inline">driver_term_nil</code> if the monitor no longer exists.</p><h2 id="driver_get_now" class="section-heading"><a href="#driver_get_now" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_get_now()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_get_now</span><span class="p" data-group-id="6010619245-1">(</span><span class="no">ErlDrvNowData</span><span class="w"> </span><span class="o">*</span><span class="n">now</span><span class="p" data-group-id="6010619245-1">)</span><span class="p">;</span></code></pre><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p><em>This function is deprecated. Do not use it.</em> Use
<a href="erl_driver.html#erl_drv_monotonic_time"><code class="inline">erl_drv_monotonic_time</code></a> (perhaps in
combination with <a href="erl_driver.html#erl_drv_time_offset"><code class="inline">erl_drv_time_offset</code></a>)
instead.</p></section><p>Reads a time stamp into the memory pointed to by parameter <code class="inline">now</code>. For
information about specific fields, see
<a href="erl_driver.html#ErlDrvNowData"><code class="inline">ErlDrvNowData</code></a>.</p><p>The return value is <code class="inline">0</code>, unless the <code class="inline">now</code> pointer is invalid, in which case it
is &lt; <code class="inline">0</code>.</p><h2 id="driver_lock_driver" class="section-heading"><a href="#driver_lock_driver" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_lock_driver()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_lock_driver</span><span class="p" data-group-id="5880793894-1">(</span><span class="no">ErlDrvPort</span><span class="w">
        </span><span class="n">port</span><span class="p" data-group-id="5880793894-1">)</span><span class="p">;</span></code></pre><p>Locks the driver used by the port <code class="inline">port</code> in memory for the rest of the emulator
process' lifetime. After this call, the driver behaves as one of Erlang's
statically linked-in drivers.</p><h2 id="driver_mk_atom" class="section-heading"><a href="#driver_mk_atom" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_mk_atom()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvTermData</span><span class="w"> </span><span class="nf">driver_mk_atom</span><span class="p" data-group-id="8421972862-1">(</span><span class="kt">char</span><span class="o">*</span><span class="w">
        </span><span class="n">string</span><span class="p" data-group-id="8421972862-1">)</span><span class="p">;</span></code></pre><p>Returns an atom given a name <code class="inline">string</code>. The atom is created and does not change,
so the return value can be saved and reused, which is faster than looking up the
atom several times.</p><p>Notice that this function is <em>not</em> thread-safe.</p><h2 id="driver_mk_port" class="section-heading"><a href="#driver_mk_port" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_mk_port()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvTermData</span><span class="w"> </span><span class="nf">driver_mk_port</span><span class="p" data-group-id="7382031690-1">(</span><span class="no">ErlDrvPort</span><span class="w">
        </span><span class="n">port</span><span class="p" data-group-id="7382031690-1">)</span><span class="p">;</span></code></pre><p>Converts a port handle to the Erlang term format, usable in
<a href="erl_driver.html#erl_drv_output_term"><code class="inline">erl_drv_output_term</code></a> and
<a href="erl_driver.html#erl_drv_send_term"><code class="inline">erl_drv_send_term</code></a>.</p><p>Notice that this function is <em>not</em> thread-safe.</p><h2 id="driver_monitor_process" class="section-heading"><a href="#driver_monitor_process" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_monitor_process()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_monitor_process</span><span class="p" data-group-id="2898895135-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvTermData</span><span class="w"> </span><span class="n">process</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvMonitor</span><span class="w"> </span><span class="o">*</span><span class="n">monitor</span><span class="p" data-group-id="2898895135-1">)</span><span class="p">;</span></code></pre><p>Starts monitoring a process from a driver. When a process is monitored, a
process exit results in a call to the provided
<a href="driver_entry.html#process_exit"><code class="inline">process_exit</code></a> callback in the
<a href="driver_entry.html"><code class="inline">ErlDrvEntry</code></a> structure. The <code class="inline">ErlDrvMonitor</code> structure is
filled in, for later removal or compare.</p><p>Parameter <code class="inline">process</code> is to be the return value of an earlier call to
<a href="erl_driver.html#driver_caller"><code class="inline">driver_caller</code></a> or
<a href="erl_driver.html#driver_connected"><code class="inline">driver_connected</code></a> call.</p><p>Returns <code class="inline">0</code> on success, &lt; 0 if no callback is provided, and &gt; 0 if the process
is no longer alive.</p><h2 id="driver_output" class="section-heading"><a href="#driver_output" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_output()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_output</span><span class="p" data-group-id="4595191445-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="4595191445-1">)</span><span class="p">;</span></code></pre><p>Sends data from the driver up to the emulator. The data is received as terms or
binary data, depending on how the driver port was opened.</p><p>The data is queued in the port owner process' message queue. Notice that this
does not yield to the emulator (as the driver and the emulator run in the same
thread).</p><p>Parameter <code class="inline">buf</code> points to the data to send, and <code class="inline">len</code> is the number of bytes.</p><p>The return value for all output functions is <code class="inline">0</code> for normal use. If the driver
is used for distribution, it can fail and return <code class="inline">-1</code>.</p><h2 id="driver_output_binary" class="section-heading"><a href="#driver_output_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_output_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_output_binary</span><span class="p" data-group-id="1019104093-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w">
        </span><span class="o">*</span><span class="n">hbuf</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">hlen</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvBinary</span><span class="o">*</span><span class="w"> </span><span class="n">bin</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="1019104093-1">)</span><span class="p">;</span></code></pre><p>Sends data to a port owner process from a driver binary. It has a header buffer
(<code class="inline">hbuf</code> and <code class="inline">hlen</code>) just like <a href="erl_driver.html#driver_output2"><code class="inline">driver_output2</code></a>.
Parameter <code class="inline">hbuf</code> can be <code class="inline">NULL</code>.</p><p>Parameter <code class="inline">offset</code> is an offset into the binary and <code class="inline">len</code> is the number of bytes
to send.</p><p>Driver binaries are created with
<a href="erl_driver.html#driver_alloc_binary"><code class="inline">driver_alloc_binary</code></a>.</p><p>The data in the header is sent as a list and the binary as an Erlang binary in
the tail of the list.</p><p>For example, if <code class="inline">hlen</code> is <code class="inline">2</code>, the port owner process receives
<code class="inline">[H1, H2 | &lt;&lt;T&gt;&gt;]</code>.</p><p>The return value is <code class="inline">0</code> for normal use.</p><p>Notice that, using the binary syntax in Erlang, the driver application can match
the header directly from the binary, so the header can be put in the binary, and
<code class="inline">hlen</code> can be set to <code class="inline">0</code>.</p><h2 id="driver_output_term" class="section-heading"><a href="#driver_output_term" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_output_term()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_output_term</span><span class="p" data-group-id="1486451632-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvTermData</span><span class="o">*</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p" data-group-id="1486451632-1">)</span><span class="p">;</span></code></pre><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p><em>This function is deprecated.</em> Use
<a href="erl_driver.html#erl_drv_send_term"><code class="inline">erl_drv_output_term</code></a>instead.</p></section><p>Parameters <code class="inline">term</code> and <code class="inline">n</code> work as in
<a href="erl_driver.html#erl_drv_output_term"><code class="inline">erl_drv_output_term</code></a>.</p><p>Notice that this function is <em>not</em> thread-safe.</p><h2 id="driver_output2" class="section-heading"><a href="#driver_output2" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_output2()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_output2</span><span class="p" data-group-id="6030173496-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">hbuf</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">hlen</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="6030173496-1">)</span><span class="p">;</span></code></pre><p>First sends <code class="inline">hbuf</code> (length in <code class="inline">hlen</code>) data as a list, regardless of port
settings. Then sends <code class="inline">buf</code> as a binary or list. For example, if <code class="inline">hlen</code> is <code class="inline">3</code>,
the port owner process receives <code class="inline">[H1, H2, H3 | T]</code>.</p><p>The point of sending data as a list header, is to facilitate matching on the
data received.</p><p>The return value is <code class="inline">0</code> for normal use.</p><h2 id="driver_outputv" class="section-heading"><a href="#driver_outputv" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_outputv()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_outputv</span><span class="p" data-group-id="3416250417-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">hbuf</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">hlen</span><span class="p">,</span><span class="w"> </span><span class="no">ErlIOVec</span><span class="w"> </span><span class="o">*</span><span class="n">ev</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">skip</span><span class="p" data-group-id="3416250417-1">)</span><span class="p">;</span></code></pre><p>Sends data from an I/O vector, <code class="inline">ev</code>, to the port owner process. It has a header
buffer (<code class="inline">hbuf</code> and <code class="inline">hlen</code>), just like
<a href="erl_driver.html#driver_output2"><code class="inline">driver_output2</code></a>.</p><p>Parameter <code class="inline">skip</code> is a number of bytes to skip of the <code class="inline">ev</code> vector from the head.</p><p>You get vectors of <code class="inline">ErlIOVec</code> type from the driver queue (see below), and the
<a href="driver_entry.html#outputv"><code class="inline">outputv</code></a> driver entry function. You can also make
them yourself, if you want to send several <code class="inline">ErlDrvBinary</code> buffers at once. Often
it is faster to use <a href="erl_driver.html#driver_output"><code class="inline">driver_output</code></a> or .</p><p>For example, if <code class="inline">hlen</code> is <code class="inline">2</code> and <code class="inline">ev</code> points to an array of three binaries, the
port owner process receives <code class="inline">[H1, H2, &lt;&lt;B1&gt;&gt;, &lt;&lt;B2&gt;&gt; | &lt;&lt;B3&gt;&gt;]</code>.</p><p>The return value is <code class="inline">0</code> for normal use.</p><p>The comment for <code class="inline">driver_output_binary</code> also applies for <code class="inline">driver_outputv</code>.</p><h2 id="driver_pdl_create" class="section-heading"><a href="#driver_pdl_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_pdl_create()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvPDL</span><span class="w"> </span><span class="nf">driver_pdl_create</span><span class="p" data-group-id="5119988762-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p" data-group-id="5119988762-1">)</span><span class="p">;</span></code></pre><p>Creates a port data lock associated with the <code class="inline">port</code>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Once a port data lock has been created, it must be locked during all
operations on the driver queue of the <code class="inline">port</code>.</p></section><p>Returns a newly created port data lock on success, otherwise <code class="inline">NULL</code>. The
function fails if <code class="inline">port</code> is invalid or if a port data lock already has been
associated with the <code class="inline">port</code>.</p><h2 id="driver_pdl_dec_refc" class="section-heading"><a href="#driver_pdl_dec_refc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_pdl_dec_refc()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">long</span><span class="w"> </span><span class="nf">driver_pdl_dec_refc</span><span class="p" data-group-id="0718034584-1">(</span><span class="no">ErlDrvPDL</span><span class="w">
        </span><span class="n">pdl</span><span class="p" data-group-id="0718034584-1">)</span><span class="p">;</span></code></pre><p>Decrements the reference count of the port data lock passed as argument (<code class="inline">pdl</code>).</p><p>The current reference count after the decrement has been performed is returned.</p><p>This function is thread-safe.</p><h2 id="driver_pdl_get_refc" class="section-heading"><a href="#driver_pdl_get_refc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_pdl_get_refc()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">long</span><span class="w"> </span><span class="nf">driver_pdl_get_refc</span><span class="p" data-group-id="9852958218-1">(</span><span class="no">ErlDrvPDL</span><span class="w"> </span><span class="n">pdl</span><span class="p" data-group-id="9852958218-1">)</span><span class="p">;</span></code></pre><p>Returns the current reference count of the port data lock passed as argument
(<code class="inline">pdl</code>).</p><p>This function is thread-safe.</p><h2 id="driver_pdl_inc_refc" class="section-heading"><a href="#driver_pdl_inc_refc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_pdl_inc_refc()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">long</span><span class="w"> </span><span class="nf">driver_pdl_inc_refc</span><span class="p" data-group-id="4999510052-1">(</span><span class="no">ErlDrvPDL</span><span class="w"> </span><span class="n">pdl</span><span class="p" data-group-id="4999510052-1">)</span><span class="p">;</span></code></pre><p>Increments the reference count of the port data lock passed as argument (<code class="inline">pdl</code>).</p><p>The current reference count after the increment has been performed is returned.</p><p>This function is thread-safe.</p><h2 id="driver_pdl_lock" class="section-heading"><a href="#driver_pdl_lock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_pdl_lock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">driver_pdl_lock</span><span class="p" data-group-id="7359397207-1">(</span><span class="no">ErlDrvPDL</span><span class="w"> </span><span class="n">pdl</span><span class="p" data-group-id="7359397207-1">)</span><span class="p">;</span></code></pre><p>Locks the port data lock passed as argument (<code class="inline">pdl</code>).</p><p>This function is thread-safe.</p><h2 id="driver_pdl_unlock" class="section-heading"><a href="#driver_pdl_unlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_pdl_unlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">driver_pdl_unlock</span><span class="p" data-group-id="3175302245-1">(</span><span class="no">ErlDrvPDL</span><span class="w"> </span><span class="n">pdl</span><span class="p" data-group-id="3175302245-1">)</span><span class="p">;</span></code></pre><p>Unlocks the port data lock passed as argument (<code class="inline">pdl</code>).</p><p>This function is thread-safe.</p><h2 id="driver_peekq" class="section-heading"><a href="#driver_peekq" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_peekq()</span></h2><pre><code class="makeup c" translate="no"><span class="no">SysIOVec</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">driver_peekq</span><span class="p" data-group-id="7895703089-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w">
        </span><span class="o">*</span><span class="n">vlen</span><span class="p" data-group-id="7895703089-1">)</span><span class="p">;</span></code></pre><p>Retrieves the driver queue as a pointer to an array of <code class="inline">SysIOVec</code>s. It also
returns the number of elements in <code class="inline">vlen</code>. This is one of two ways to get data
out of the queue.</p><p>Nothing is removed from the queue by this function, that must be done with
<a href="erl_driver.html#driver_deq"><code class="inline">driver_deq</code></a>.</p><p>The returned array is suitable to use with the Unix system call <code class="inline">writev</code>.</p><p>This function can be called from any thread if a
<a href="erl_driver.html#ErlDrvPDL">port data lock</a> associated with the <code class="inline">port</code> is locked
by the calling thread during the call.</p><h2 id="driver_peekqv" class="section-heading"><a href="#driver_peekqv" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_peekqv()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="nf">driver_peekqv</span><span class="p" data-group-id="4537775567-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlIOVec</span><span class="w"> </span><span class="o">*</span><span class="n">ev</span><span class="p" data-group-id="4537775567-1">)</span><span class="p">;</span></code></pre><p>Retrieves the driver queue into a supplied <code class="inline">ErlIOVec</code> <code class="inline">ev</code>. It also returns the
queue size. This is one of two ways to get data out of the queue.</p><p>If <code class="inline">ev</code> is <code class="inline">NULL</code>, all ones that is <code class="inline">-1</code> type cast to <code class="inline">ErlDrvSizeT</code> are
returned.</p><p>Nothing is removed from the queue by this function, that must be done with
<a href="erl_driver.html#driver_deq"><code class="inline">driver_deq</code></a>.</p><p>This function can be called from any thread if a
<a href="erl_driver.html#ErlDrvPDL">port data lock</a> associated with the <code class="inline">port</code> is locked
by the calling thread during the call.</p><p>Available since OTP R15B</p><h2 id="driver_pushq" class="section-heading"><a href="#driver_pushq" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_pushq()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_pushq</span><span class="p" data-group-id="1708035160-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="1708035160-1">)</span><span class="p">;</span></code></pre><p>Puts data at the head of the driver queue. The data in <code class="inline">buf</code> is copied (<code class="inline">len</code>
bytes) and placed at the beginning of the queue.</p><p>The return value is <code class="inline">0</code>.</p><p>This function can be called from any thread if a
<a href="erl_driver.html#ErlDrvPDL">port data lock</a> associated with the <code class="inline">port</code> is locked
by the calling thread during the call.</p><h2 id="driver_pushq_bin" class="section-heading"><a href="#driver_pushq_bin" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_pushq_bin()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_pushq_bin</span><span class="p" data-group-id="2786128274-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvBinary</span><span class="w"> </span><span class="o">*</span><span class="n">bin</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="2786128274-1">)</span><span class="p">;</span></code></pre><p>Puts data in the binary <code class="inline">bin</code>, at <code class="inline">offset</code> with length <code class="inline">len</code> at the head of the
driver queue. It is most often faster than
<a href="erl_driver.html#driver_pushq"><code class="inline">driver_pushq</code></a>, because no data must be copied.</p><p>This function can be called from any thread if a
<a href="erl_driver.html#ErlDrvPDL">port data lock</a> associated with the <code class="inline">port</code> is locked
by the calling thread during the call.</p><p>The return value is <code class="inline">0</code>.</p><h2 id="driver_pushqv" class="section-heading"><a href="#driver_pushqv" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_pushqv()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_pushqv</span><span class="p" data-group-id="7571556472-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="no">ErlIOVec</span><span class="w">
        </span><span class="o">*</span><span class="n">ev</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">skip</span><span class="p" data-group-id="7571556472-1">)</span><span class="p">;</span></code></pre><p>Puts the data in <code class="inline">ev</code>, skipping the first <code class="inline">skip</code> bytes of it, at the head of the
driver queue. It is faster than <a href="erl_driver.html#driver_pushq"><code class="inline">driver_pushq</code></a>,
because no data must be copied.</p><p>The return value is <code class="inline">0</code>.</p><p>This function can be called from any thread if a
<a href="erl_driver.html#ErlDrvPDL">port data lock</a> associated with the <code class="inline">port</code> is locked
by the calling thread during the call.</p><h2 id="driver_read_timer" class="section-heading"><a href="#driver_read_timer" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_read_timer()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_read_timer</span><span class="p" data-group-id="4301279626-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w">
        </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">time_left</span><span class="p" data-group-id="4301279626-1">)</span><span class="p">;</span></code></pre><p>Reads the current time of a timer, and places the result in <code class="inline">time_left</code>. This is
the time in milliseconds, before the time-out occurs.</p><p>The return value is <code class="inline">0</code>.</p><h2 id="driver_realloc" class="section-heading"><a href="#driver_realloc" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_realloc()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">driver_realloc</span><span class="p" data-group-id="5259199283-1">(</span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="5259199283-1">)</span><span class="p">;</span></code></pre><p>Resizes a memory block, either in place, or by allocating a new block, copying
the data, and freeing the old block. A pointer is returned to the reallocated
memory. On failure (out of memory), <code class="inline">NULL</code> is returned. (This is most often a
wrapper for <code class="inline">realloc</code>.)</p><p>This function is thread-safe.</p><h2 id="driver_realloc_binary" class="section-heading"><a href="#driver_realloc_binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_realloc_binary()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvBinary</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">driver_realloc_binary</span><span class="p" data-group-id="6439746670-1">(</span><span class="no">ErlDrvBinary</span><span class="w"> </span><span class="o">*</span><span class="n">bin</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="6439746670-1">)</span><span class="p">;</span></code></pre><p>Resizes a driver binary, while keeping the data.</p><p>Returns the resized driver binary on success. Returns <code class="inline">NULL</code> on failure (out of
memory).</p><p>This function is thread-safe.</p><h2 id="driver_select" class="section-heading"><a href="#driver_select" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_select()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_select</span><span class="p" data-group-id="2827415052-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvEvent</span><span class="w">
        </span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">on</span><span class="p" data-group-id="2827415052-1">)</span><span class="p">;</span></code></pre><p>This function is used by drivers to provide the emulator with events to check
for. This enables the emulator to call the driver when something has occurred
asynchronously.</p><p>Parameter <code class="inline">event</code> identifies an OS-specific event object. On Unix systems, the
functions <code class="inline">select</code>/<code class="inline">poll</code> are used. The event object must be a socket or pipe
(or other object that <code class="inline">select</code>/<code class="inline">poll</code> can use). On Windows, the Win32 API
function <code class="inline">WaitForMultipleObjects</code> is used. This places other restrictions on the
event object; see the Win32 SDK documentation.</p><p>Parameter <code class="inline">on</code> is to be <code class="inline">1</code> for setting events and <code class="inline">0</code> for clearing them.</p><p>Parameter <code class="inline">mode</code> is a bitwise OR combination of <code class="inline">ERL_DRV_READ</code>, <code class="inline">ERL_DRV_WRITE</code>,
and <code class="inline">ERL_DRV_USE</code>. The first two specify whether to wait for read events and/or
write events. A fired read event calls
<a href="driver_entry.html#ready_input"><code class="inline">ready_input</code></a> and a fired write event calls
<a href="driver_entry.html#ready_output"><code class="inline">ready_output</code></a>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Some OS (Windows) do not differentiate between read and write events. The
callback for a fired event then only depends on the value of <code class="inline">mode</code>.</p></section><p><code class="inline">ERL_DRV_USE</code> specifies if we are using the event object or if we want to close
it. It is not safe to clear all events and then close the event object after
<code class="inline">driver_select</code> has returned. Another thread can still be using the event object
internally. To safely close an event object, call <code class="inline">driver_select</code> with
<code class="inline">ERL_DRV_USE</code> and <code class="inline">on==0</code>, which clears all events and then either calls
<a href="driver_entry.html#stop_select"><code class="inline">stop_select</code></a> or schedules it to be called when
it is safe to close the event object. <code class="inline">ERL_DRV_USE</code> is to be set together with
the first event for an event object. It is harmless to set <code class="inline">ERL_DRV_USE</code> even if
it already has been done. Clearing all events but keeping <code class="inline">ERL_DRV_USE</code> set
indicates that we are using the event object and probably will set events for it
again.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p><code class="inline">ERL_DRV_USE</code> was added in Erlang/OTP R13. Old drivers still work as before,
but it is recommended to update them to use <code class="inline">ERL_DRV_USE</code> and <code class="inline">stop_select</code> to
ensure that event objects are closed in a safe way.</p></section><p>The return value is <code class="inline">0</code>, unless <code class="inline">ready_input</code>/<code class="inline">ready_output</code> is <code class="inline">NULL</code>, in which
case it is <code class="inline">-1</code>.</p><h2 id="driver_send_term" class="section-heading"><a href="#driver_send_term" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_send_term()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_send_term</span><span class="p" data-group-id="4698179005-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvTermData</span><span class="w"> </span><span class="n">receiver</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvTermData</span><span class="o">*</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p" data-group-id="4698179005-1">)</span><span class="p">;</span></code></pre><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p><em>This function is deprecated.</em> Use
<a href="erl_driver.html#erl_drv_send_term"><code class="inline">erl_drv_send_term</code></a> instead.</p></section><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The parameters of this function cannot be properly checked by the runtime
system when executed by arbitrary threads. This can cause the function not to
fail when it should.</p></section><p>Parameters <code class="inline">term</code> and <code class="inline">n</code> work as in
<a href="erl_driver.html#erl_drv_output_term"><code class="inline">erl_drv_output_term</code></a>.</p><p>This function is thread-safe.</p><h2 id="driver_set_timer" class="section-heading"><a href="#driver_set_timer" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_set_timer()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">driver_set_timer</span><span class="p" data-group-id="3997466528-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w">
        </span><span class="kt">long</span><span class="w"> </span><span class="n">time</span><span class="p" data-group-id="3997466528-1">)</span><span class="p">;</span></code></pre><p>Sets a timer on the driver, which will count down and call the driver when it is
timed out. Parameter <code class="inline">time</code> is the time in milliseconds before the timer
expires.</p><p>When the timer reaches <code class="inline">0</code> and expires, the driver entry function
<a href="driver_entry.html#timeout"><code class="inline">timeout</code></a> is called.</p><p>Notice that only one timer exists on each driver instance; setting a new timer
replaces an older one.</p><p>Return value is <code class="inline">0</code>, unless the <code class="inline">timeout</code> driver function is <code class="inline">NULL</code>, in which
case it is <code class="inline">-1</code>.</p><h2 id="driver_sizeq" class="section-heading"><a href="#driver_sizeq" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_sizeq()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="nf">driver_sizeq</span><span class="p" data-group-id="4613888053-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p" data-group-id="4613888053-1">)</span><span class="p">;</span></code></pre><p>Returns the number of bytes currently in the driver queue.</p><p>This function can be called from any thread if a
<a href="erl_driver.html#ErlDrvPDL">port data lock</a> associated with the <code class="inline">port</code> is locked
by the calling thread during the call.</p><h2 id="driver_system_info" class="section-heading"><a href="#driver_system_info" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_system_info()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">driver_system_info</span><span class="p" data-group-id="2885364831-1">(</span><span class="no">ErlDrvSysInfo</span><span class="w">
        </span><span class="o">*</span><span class="n">sys_info_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size_t</span><span class="w"> </span><span class="n">size</span><span class="p" data-group-id="2885364831-1">)</span><span class="p">;</span></code></pre><p>Writes information about the Erlang runtime system into the
<a href="erl_driver.html#ErlDrvSysInfo"><code class="inline">ErlDrvSysInfo</code></a> structure referred to by the
first argument. The second argument is to be the size of the
<a href="erl_driver.html#ErlDrvSysInfo"><code class="inline">ErlDrvSysInfo</code></a> structure, that is,
<code class="inline">sizeof(ErlDrvSysInfo)</code>.</p><p>For information about specific fields, see
<a href="erl_driver.html#ErlDrvSysInfo"><code class="inline">ErlDrvSysInfo</code></a>.</p><h2 id="driver_vec_to_buf" class="section-heading"><a href="#driver_vec_to_buf" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">driver_vec_to_buf()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="nf">driver_vec_to_buf</span><span class="p" data-group-id="9388004160-1">(</span><span class="no">ErlIOVec</span><span class="w"> </span><span class="o">*</span><span class="n">ev</span><span class="p">,</span><span class="w">
        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="n">len</span><span class="p" data-group-id="9388004160-1">)</span><span class="p">;</span></code></pre><p>Collects several segments of data, referenced by <code class="inline">ev</code>, by copying them in order
to the buffer <code class="inline">buf</code>, of the size <code class="inline">len</code>.</p><p>If the data is to be sent from the driver to the port owner process, it is
faster to use <a href="erl_driver.html#driver_outputv"><code class="inline">driver_outputv</code></a>.</p><p>The return value is the space left in the buffer, that is, if <code class="inline">ev</code> contains less
than <code class="inline">len</code> bytes it is the difference, and if <code class="inline">ev</code> contains <code class="inline">len</code> bytes or more,
it is <code class="inline">0</code>. This is faster if there is more than one header byte, as the binary
syntax can construct integers directly from the binary.</p><h2 id="erl_drv_busy_msgq_limits" class="section-heading"><a href="#erl_drv_busy_msgq_limits" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_busy_msgq_limits()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_busy_msgq_limits</span><span class="p" data-group-id="2228548631-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="o">*</span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvSizeT</span><span class="w"> </span><span class="o">*</span><span class="n">high</span><span class="p" data-group-id="2228548631-1">)</span><span class="p">;</span></code></pre><p>Sets and gets limits that will be used for controlling the busy state of the
port message queue.</p><p>The port message queue is set into a busy state when the amount of command data
queued on the message queue reaches the <code class="inline">high</code> limit. The port message queue is
set into a not busy state when the amount of command data queued on the message
queue falls below the <code class="inline">low</code> limit. Command data is in this context data passed
to the port using either <code class="inline">Port ! {Owner, {command, Data}}</code> or
<code class="inline">port_command/[2,3]</code>. Notice that these limits only concerns command data that
have not yet reached the port. The <a href="erl_driver.html#set_busy_port">busy port</a>
feature can be used for data that has reached the port.</p><p>Valid limits are values in the range
<code class="inline">[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]</code>. Limits are
automatically adjusted to be sane. That is, the system adjusts values so that
the low limit used is lower than or equal to the high limit used. By default the
high limit is 8 kB and the low limit is 4 kB.</p><p>By passing a pointer to an integer variable containing the value
<code class="inline">ERL_DRV_BUSY_MSGQ_READ_ONLY</code>, the currently used limit is read and written back
to the integer variable. A new limit can be set by passing a pointer to an
integer variable containing a valid limit. The passed value is written to the
internal limit. The internal limit is then adjusted. After this the adjusted
limit is written back to the integer variable from which the new value was read.
Values are in bytes.</p><p>The busy message queue feature can be disabled either by setting the
<code class="inline">ERL_DRV_FLAG_NO_BUSY_MSGQ</code> <a href="driver_entry.html#driver_flags">driver flag</a> in the
<a href="driver_entry.html"><code class="inline">driver_entry</code></a> used by the driver, or by calling this
function with <code class="inline">ERL_DRV_BUSY_MSGQ_DISABLED</code> as a limit (either low or high). When
this feature has been disabled, it cannot be enabled again. When reading the
limits, both are <code class="inline">ERL_DRV_BUSY_MSGQ_DISABLED</code> if this feature has been disabled.</p><p>Processes sending command data to the port are suspended if either the port is
busy or if the port message queue is busy. Suspended processes are resumed when
neither the port or the port message queue is busy.</p><p>For information about busy port functionality, see
<a href="erl_driver.html#set_busy_port"><code class="inline">set_busy_port</code></a>.</p><p>Available since OTP R16B</p><h2 id="erl_drv_cond_broadcast" class="section-heading"><a href="#erl_drv_cond_broadcast" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_cond_broadcast()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_cond_broadcast</span><span class="p" data-group-id="0778904355-1">(</span><span class="no">ErlDrvCond</span><span class="w">
        </span><span class="o">*</span><span class="n">cnd</span><span class="p" data-group-id="0778904355-1">)</span><span class="p">;</span></code></pre><p>Broadcasts on a condition variable. That is, if other threads are waiting on the
condition variable being broadcast on, <em>all</em> of them are woken.</p><p><code class="inline">cnd</code> is a pointer to a condition variable to broadcast on.</p><p>This function is thread-safe.</p><h2 id="erl_drv_cond_create" class="section-heading"><a href="#erl_drv_cond_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_cond_create()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvCond</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">erl_drv_cond_create</span><span class="p" data-group-id="9139912867-1">(</span><span class="kt">char</span><span class="w">
        </span><span class="o">*</span><span class="n">name</span><span class="p" data-group-id="9139912867-1">)</span><span class="p">;</span></code></pre><p>Creates a condition variable and returns a pointer to it.</p><p><code class="inline">name</code> is a string identifying the created condition variable. It is used to
identify the condition variable in planned future debug functionality.</p><p>Returns <code class="inline">NULL</code> on failure. The driver creating the condition variable is
responsible for destroying it before the driver is unloaded.</p><p>This function is thread-safe.</p><h2 id="erl_drv_cond_destroy" class="section-heading"><a href="#erl_drv_cond_destroy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_cond_destroy()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_cond_destroy</span><span class="p" data-group-id="7284341406-1">(</span><span class="no">ErlDrvCond</span><span class="w">
        </span><span class="o">*</span><span class="n">cnd</span><span class="p" data-group-id="7284341406-1">)</span><span class="p">;</span></code></pre><p>Destroys a condition variable previously created by
<a href="erl_driver.html#erl_drv_cond_create"><code class="inline">erl_drv_cond_create</code></a>.</p><p><code class="inline">cnd</code> is a pointer to a condition variable to destroy.</p><p>This function is thread-safe.</p><h2 id="erl_drv_cond_name" class="section-heading"><a href="#erl_drv_cond_name" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_cond_name()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">erl_drv_cond_name</span><span class="p" data-group-id="4950337563-1">(</span><span class="no">ErlDrvCond</span><span class="w">
        </span><span class="o">*</span><span class="n">cnd</span><span class="p" data-group-id="4950337563-1">)</span><span class="p">;</span></code></pre><p>Returns a pointer to the name of the condition.</p><p><code class="inline">cnd</code> is a pointer to an initialized condition.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>This function is intended for debugging purposes only.</p></section><p>Available since OTP R16B02</p><h2 id="erl_drv_cond_signal" class="section-heading"><a href="#erl_drv_cond_signal" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_cond_signal()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_cond_signal</span><span class="p" data-group-id="7846473703-1">(</span><span class="no">ErlDrvCond</span><span class="w">
        </span><span class="o">*</span><span class="n">cnd</span><span class="p" data-group-id="7846473703-1">)</span><span class="p">;</span></code></pre><p>Signals on a condition variable. That is, if other threads are waiting on the
condition variable being signaled, <em>one</em> of them is woken.</p><p><code class="inline">cnd</code> is a pointer to a condition variable to signal on.</p><p>This function is thread-safe.</p><h2 id="erl_drv_cond_wait" class="section-heading"><a href="#erl_drv_cond_wait" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_cond_wait()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_cond_wait</span><span class="p" data-group-id="1664921884-1">(</span><span class="no">ErlDrvCond</span><span class="w"> </span><span class="o">*</span><span class="n">cnd</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvMutex</span><span class="w"> </span><span class="o">*</span><span class="n">mtx</span><span class="p" data-group-id="1664921884-1">)</span><span class="p">;</span></code></pre><p>Waits on a condition variable. The calling thread is blocked until another
thread wakes it by signaling or broadcasting on the condition variable. Before
the calling thread is blocked, it unlocks the mutex passed as argument. When the
calling thread is woken, it locks the same mutex before returning. That is, the
mutex currently must be locked by the calling thread when calling this function.</p><p><code class="inline">cnd</code> is a pointer to a condition variable to wait on. <code class="inline">mtx</code> is a pointer to a
mutex to unlock while waiting.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p><code class="inline">erl_drv_cond_wait</code> can return even if no one has signaled or broadcast on the
condition variable. Code calling <code class="inline">erl_drv_cond_wait</code> is always to be prepared
for <code class="inline">erl_drv_cond_wait</code> returning even if the condition that the thread was
waiting for has not occurred. That is, when returning from
<code class="inline">erl_drv_cond_wait</code>, always check if the condition has occurred, and if not
call <code class="inline">erl_drv_cond_wait</code> again.</p></section><p>This function is thread-safe.</p><h2 id="erl_drv_consume_timeslice" class="section-heading"><a href="#erl_drv_consume_timeslice" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_consume_timeslice()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">erl_drv_consume_timeslice</span><span class="p" data-group-id="4818431315-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="kt">int</span><span class="w"> </span><span class="n">percent</span><span class="p" data-group-id="4818431315-1">)</span><span class="p">;</span></code></pre><p>Gives the runtime system a hint about how much CPU time the current driver
callback call has consumed since the last hint, or since the the start of the
callback if no previous hint has been given.</p><ul><li><p><strong><code class="inline">port</code></strong> - Port handle of the executing port.</p></li><li><p><strong><code class="inline">percent</code></strong> - Approximate consumed fraction of a full time-slice in percent.</p></li></ul><p>The time is specified as a fraction, in percent, of a full time-slice that a
port is allowed to execute before it is to surrender the CPU to other runnable
ports or processes. Valid range is <code class="inline">[1, 100]</code>. The scheduling time-slice is not
an exact entity, but can usually be approximated to about 1 millisecond.</p><p>Notice that it is up to the runtime system to determine if and how to use this
information. Implementations on some platforms can use other means to determine
the consumed fraction of the time-slice. Lengthy driver callbacks should,
regardless of this, frequently call this function to determine if it is allowed
to continue execution or not.</p><p>This function returns a non-zero value if the time-slice has been exhausted, and
zero if the callback is allowed to continue execution. If a non-zero value is
returned, the driver callback is to return as soon as possible in order for the
port to be able to yield.</p><p>This function is provided to better support co-operative scheduling, improve
system responsiveness, and to make it easier to prevent misbehaviors of the VM
because of a port monopolizing a scheduler thread. It can be used when dividing
lengthy work into some repeated driver callback calls, without the need to use
threads.</p><p>See also the important <a href="erl_driver.html#WARNING">warning</a> text at the beginning of
this manual page.</p><p>Available since OTP R16B</p><h2 id="erl_drv_convert_time_unit" class="section-heading"><a href="#erl_drv_convert_time_unit" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_convert_time_unit()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvTime</span><span class="w"> </span><span class="nf">erl_drv_convert_time_unit</span><span class="p" data-group-id="6884169487-1">(</span><span class="no">ErlDrvTime</span><span class="w">
        </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvTimeUnit</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvTimeUnit</span><span class="w"> </span><span class="n">to</span><span class="p" data-group-id="6884169487-1">)</span><span class="p">;</span></code></pre><p>Converts the <code class="inline">val</code> value of time unit <code class="inline">from</code> to the corresponding value of time
unit <code class="inline">to</code>. The result is rounded using the floor function.</p><ul><li><p><strong><code class="inline">val</code></strong> - Value to convert time unit for.</p></li><li><p><strong><code class="inline">from</code></strong> - Time unit of <code class="inline">val</code>.</p></li><li><p><strong><code class="inline">to</code></strong> - Time unit of returned value.</p></li></ul><p>Returns <code class="inline">ERL_DRV_TIME_ERROR</code> if called with an invalid time unit argument.</p><p>See also <a href="erl_driver.html#ErlDrvTime"><code class="inline">ErlDrvTime</code></a> and
<a href="erl_driver.html#ErlDrvTimeUnit"><code class="inline">ErlDrvTimeUnit</code></a>.</p><p>Available since OTP 18.3</p><h2 id="erl_drv_equal_tids" class="section-heading"><a href="#erl_drv_equal_tids" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_equal_tids()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">erl_drv_equal_tids</span><span class="p" data-group-id="2645934997-1">(</span><span class="no">ErlDrvTid</span><span class="w"> </span><span class="n">tid1</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvTid</span><span class="w"> </span><span class="n">tid2</span><span class="p" data-group-id="2645934997-1">)</span><span class="p">;</span></code></pre><p>Compares two thread identifiers, <code class="inline">tid1</code> and <code class="inline">tid2</code>, for equality.</p><p>Returns <code class="inline">0</code> it they are not equal, and a value not equal to <code class="inline">0</code> if they are
equal.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>A thread identifier can be reused very quickly after a thread has terminated.
Therefore, if a thread corresponding to one of the involved thread identifiers
has terminated since the thread identifier was saved, the result of
<code class="inline">erl_drv_equal_tids</code> does possibly not give the expected result.</p></section><p>This function is thread-safe.</p><h2 id="erl_drv_getenv" class="section-heading"><a href="#erl_drv_getenv" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_getenv()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">erl_drv_getenv</span><span class="p" data-group-id="2664505825-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w">
        </span><span class="o">*</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">value_size</span><span class="p" data-group-id="2664505825-1">)</span><span class="p">;</span></code></pre><p>Retrieves the value of an environment variable.</p><ul><li><p><strong><code class="inline">key</code></strong> - A <code class="inline">NULL</code>-terminated string containing the name of the environment
variable.</p></li><li><p><strong><code class="inline">value</code></strong> - A pointer to an output buffer.</p></li><li><p><strong><code class="inline">value_size</code></strong> - A pointer to an integer. The integer is used both for
passing input and output sizes (see below).</p></li></ul><p>When this function is called, <code class="inline">*value_size</code> is to contain the size of the
<code class="inline">value</code> buffer.</p><p>On success, <code class="inline">0</code> is returned, the value of the environment variable has been
written to the <code class="inline">value</code> buffer, and <code class="inline">*value_size</code> contains the string length
(excluding the terminating <code class="inline">NULL</code> character) of the value written to the <code class="inline">value</code>
buffer.</p><p>On failure, that is, no such environment variable was found, a value &lt; <code class="inline">0</code> is
returned. When the size of the <code class="inline">value</code> buffer is too small, a value &gt; <code class="inline">0</code> is
returned and <code class="inline">*value_size</code> has been set to the buffer size needed.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>This function reads the emulated environment used by <a href="../../apps/kernel/os.html#getenv/1"><code class="inline">os:getenv/1</code></a> and not the
environment used by libc's <code class="inline">getenv(3)</code> or similar. Drivers that <em>require</em> that
these are in sync will need to do so themselves, but keep in mind that they
are segregated for a reason; <code class="inline">getenv(3)</code> and its friends are <em>not thread-safe</em>
and may cause unrelated code to misbehave or crash the emulator.</p></section><p>This function is thread-safe.</p><h2 id="erl_drv_init_ack" class="section-heading"><a href="#erl_drv_init_ack" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_init_ack()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_init_ack</span><span class="p" data-group-id="0600970089-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvData</span><span class="w"> </span><span class="n">res</span><span class="p" data-group-id="0600970089-1">)</span><span class="p">;</span></code></pre><p>Acknowledges the start of the port.</p><ul><li><p><strong><code class="inline">port</code></strong> - The port handle of the port (driver instance) doing the
acknowledgment.</p></li><li><p><strong><code class="inline">res</code></strong> - The result of the port initialization. Can be the same values as
the return value of <a href="driver_entry.html#start"><code class="inline">start</code></a>, that is, any of the
error codes or the <code class="inline">ErlDrvData</code> that is to be used for this port.</p></li></ul><p>When this function is called the initiating <code class="inline">erlang:open_port</code> call is returned
as if the <a href="driver_entry.html#start"><code class="inline">start</code></a> function had just been called. It can
only be used when flag
<a href="driver_entry.html#driver_flags"><code class="inline">ERL_DRV_FLAG_USE_INIT_ACK</code></a> has been set on the
linked-in driver.</p><p>Available since OTP 19.0</p><h2 id="erl_drv_monotonic_time" class="section-heading"><a href="#erl_drv_monotonic_time" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_monotonic_time()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvTime</span><span class="w"> </span><span class="nf">erl_drv_monotonic_time</span><span class="p" data-group-id="1971541347-1">(</span><span class="no">ErlDrvTimeUnit</span><span class="w"> </span><span class="n">time_unit</span><span class="p" data-group-id="1971541347-1">)</span><span class="p">;</span></code></pre><p>Returns <a href="time_correction.html#erlang-monotonic-time">Erlang monotonic time</a>.
Notice that negative values are not uncommon.</p><p><code class="inline">time_unit</code> is time unit of returned value.</p><p>Returns <code class="inline">ERL_DRV_TIME_ERROR</code> if called with an invalid time unit argument, or if
called from a thread that is not a scheduler thread.</p><p>See also <a href="erl_driver.html#ErlDrvTime"><code class="inline">ErlDrvTime</code></a> and
<a href="erl_driver.html#ErlDrvTimeUnit"><code class="inline">ErlDrvTimeUnit</code></a>.</p><p>Available since OTP 18.3</p><h2 id="erl_drv_mutex_create" class="section-heading"><a href="#erl_drv_mutex_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_mutex_create()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvMutex</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">erl_drv_mutex_create</span><span class="p" data-group-id="8443790374-1">(</span><span class="kt">char</span><span class="w">
        </span><span class="o">*</span><span class="n">name</span><span class="p" data-group-id="8443790374-1">)</span><span class="p">;</span></code></pre><p>Creates a mutex and returns a pointer to it.</p><p><code class="inline">name</code> is a string identifying the created mutex. It is used to identify the
mutex in debug functionality (see note).</p><p>Returns <code class="inline">NULL</code> on failure. The driver creating the mutex is responsible for
destroying it before the driver is unloaded.</p><p>This function is thread-safe.</p><section role="note" class="admonition info"><h4 class="admonition-title info" id="lock_checker">Note</h4><p>One such debug functionality is the <em>lock checker</em>, which can detect locking
order violations and thereby potential deadlock bugs. For the lock checker to
work the <code class="inline">name</code> should be on the format <code class="inline">&quot;App.Type&quot;</code> or
<code class="inline">&quot;App.Type[Instance]&quot;</code>, where App is the name of the application, Type is the
name of the lock type and Instance is optional information about each lock
instance. &quot;App.Type&quot; should be a unique name for the lock checker to detect
lock order violations between locks of different types. The Instance
information is currently ignored.</p><p>For example, if we have mutexes of types &quot;myapp.xtable&quot; and &quot;myapp.xitem&quot; then
the lock checker will make sure either &quot;myapp.xtable&quot; locks are never locked
after &quot;myapp.xitem&quot; locks or vice versa.</p></section><h2 id="erl_drv_mutex_destroy" class="section-heading"><a href="#erl_drv_mutex_destroy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_mutex_destroy()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_mutex_destroy</span><span class="p" data-group-id="1590022227-1">(</span><span class="no">ErlDrvMutex</span><span class="w">
        </span><span class="o">*</span><span class="n">mtx</span><span class="p" data-group-id="1590022227-1">)</span><span class="p">;</span></code></pre><p>Destroys a mutex previously created by
<a href="erl_driver.html#erl_drv_mutex_create"><code class="inline">erl_drv_mutex_create</code></a>. The mutex must be
in an unlocked state before it is destroyed.</p><p><code class="inline">mtx</code> is a pointer to a mutex to destroy.</p><p>This function is thread-safe.</p><h2 id="erl_drv_mutex_lock" class="section-heading"><a href="#erl_drv_mutex_lock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_mutex_lock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_mutex_lock</span><span class="p" data-group-id="0337921197-1">(</span><span class="no">ErlDrvMutex</span><span class="w">
        </span><span class="o">*</span><span class="n">mtx</span><span class="p" data-group-id="0337921197-1">)</span><span class="p">;</span></code></pre><p>Locks a mutex. The calling thread is blocked until the mutex has been locked. A
thread that has currently locked the mutex <em>cannot</em> lock the same mutex again.</p><p><code class="inline">mtx</code> is a pointer to a mutex to lock.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>If you leave a mutex locked in an emulator thread when you let the thread out
of your control, you will <em>very likely</em> deadlock the whole emulator.</p></section><p>This function is thread-safe.</p><h2 id="erl_drv_mutex_name" class="section-heading"><a href="#erl_drv_mutex_name" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_mutex_name()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">erl_drv_mutex_name</span><span class="p" data-group-id="6834771204-1">(</span><span class="no">ErlDrvMutex</span><span class="w">
        </span><span class="o">*</span><span class="n">mtx</span><span class="p" data-group-id="6834771204-1">)</span><span class="p">;</span></code></pre><p>Returns a pointer to the mutex name.</p><p><code class="inline">mtx</code> is a pointer to an initialized mutex.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>This function is intended for debugging purposes only.</p></section><p>Available since OTP R16B02</p><h2 id="erl_drv_mutex_trylock" class="section-heading"><a href="#erl_drv_mutex_trylock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_mutex_trylock()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">erl_drv_mutex_trylock</span><span class="p" data-group-id="7603810705-1">(</span><span class="no">ErlDrvMutex</span><span class="w">
        </span><span class="o">*</span><span class="n">mtx</span><span class="p" data-group-id="7603810705-1">)</span><span class="p">;</span></code></pre><p>Tries to lock a mutex. A thread that has currently locked the mutex <em>cannot</em> try
to lock the same mutex again.</p><p><code class="inline">mtx</code> is a pointer to a mutex to try to lock.</p><p>Returns <code class="inline">0</code> on success, otherwise <code class="inline">EBUSY</code>.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>If you leave a mutex locked in an emulator thread when you let the thread out
of your control, you will <em>very likely</em> deadlock the whole emulator.</p></section><p>This function is thread-safe.</p><h2 id="erl_drv_mutex_unlock" class="section-heading"><a href="#erl_drv_mutex_unlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_mutex_unlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_mutex_unlock</span><span class="p" data-group-id="5598539719-1">(</span><span class="no">ErlDrvMutex</span><span class="w">
        </span><span class="o">*</span><span class="n">mtx</span><span class="p" data-group-id="5598539719-1">)</span><span class="p">;</span></code></pre><p>Unlocks a mutex. The mutex currently must be locked by the calling thread.</p><p><code class="inline">mtx</code> is a pointer to a mutex to unlock.</p><p>This function is thread-safe.</p><h2 id="erl_drv_output_term" class="section-heading"><a href="#erl_drv_output_term" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_output_term()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">erl_drv_output_term</span><span class="p" data-group-id="4725536160-1">(</span><span class="no">ErlDrvTermData</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvTermData</span><span class="o">*</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p" data-group-id="4725536160-1">)</span><span class="p">;</span></code></pre><p>Sends data in the special driver term format to the port owner process. This is
a fast way to deliver term data from a driver. It needs no binary conversion, so
the port owner process receives data as normal Erlang terms. The
<a href="erl_driver.html#erl_drv_send_term"><code class="inline">erl_drv_send_term</code></a> functions can be used for
sending to any process on the local node.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Parameter <code class="inline">port</code> is <em>not</em> an ordinary port handle, but a port handle converted
using <a href="erl_driver.html#driver_mk_port"><code class="inline">driver_mk_port</code></a>.</p></section><p>Parameter <code class="inline">term</code> points to an array of <code class="inline">ErlDrvTermData</code> with <code class="inline">n</code> elements. This
array contains terms described in the driver term format. Every term consists of
1-4 elements in the array. The first term has a term type and then arguments.
Parameter <code class="inline">port</code> specifies the sending port.</p><p>Tuples, maps, and lists (except strings, see below) are built in reverse polish
notation, so that to build a tuple, the elements are specified first, and then
the tuple term, with a count. Likewise for lists and maps.</p><ul><li>A tuple must be specified with the number of elements. (The elements precede
the <code class="inline">ERL_DRV_TUPLE</code> term.)</li><li>A map must be specified with the number of key-value pairs <code class="inline">N</code>. The key-value
pairs must precede the <code class="inline">ERL_DRV_MAP</code> in this order:
<code class="inline">key1,value1,key2,value2,...,keyN,valueN</code>. Duplicate keys are not allowed.</li><li>A list must be specified with the number of elements, including the tail,
which is the last term preceding <code class="inline">ERL_DRV_LIST</code>.</li></ul><p>The special term <code class="inline">ERL_DRV_STRING_CONS</code> is used to &quot;splice&quot; in a string in a
list, a string specified this way is not a list in itself, but the elements are
elements of the surrounding list.</p><pre><code class="text">Term type            Arguments
---------            ---------
ERL_DRV_NIL
ERL_DRV_ATOM         ErlDrvTermData atom (from driver_mk_atom(char *string))
ERL_DRV_INT          ErlDrvSInt integer
ERL_DRV_UINT         ErlDrvUInt integer
ERL_DRV_INT64        ErlDrvSInt64 *integer_ptr
ERL_DRV_UINT64       ErlDrvUInt64 *integer_ptr
ERL_DRV_PORT         ErlDrvTermData port (from driver_mk_port(ErlDrvPort port))
ERL_DRV_BINARY       ErlDrvBinary *bin, ErlDrvUInt len, ErlDrvUInt offset
ERL_DRV_BUF2BINARY   char *buf, ErlDrvUInt len
ERL_DRV_STRING       char *str, int len
ERL_DRV_TUPLE        int sz
ERL_DRV_LIST         int sz
ERL_DRV_PID          ErlDrvTermData pid (from driver_connected(ErlDrvPort port)
                     or driver_caller(ErlDrvPort port))
ERL_DRV_STRING_CONS  char *str, int len
ERL_DRV_FLOAT        double *dbl
ERL_DRV_EXT2TERM     char *buf, ErlDrvUInt len
ERL_DRV_MAP          int sz</code></pre><p>The unsigned integer data type <code class="inline">ErlDrvUInt</code> and the signed integer data type
<code class="inline">ErlDrvSInt</code> are 64 bits wide on a 64-bit runtime system and 32 bits wide on a
32-bit runtime system. They were introduced in ERTS 5.6 and replaced some of the
<code class="inline">int</code> arguments in the list above.</p><p>The unsigned integer data type <code class="inline">ErlDrvUInt64</code> and the signed integer data type
<code class="inline">ErlDrvSInt64</code> are always 64 bits wide. They were introduced in ERTS 5.7.4.</p><p>To build the tuple <code class="inline">{tcp, Port, [100 | Binary]}</code>, the following call can be
made.</p><pre><code class="text">ErlDrvBinary* bin = ...
ErlDrvPort port = ...
ErlDrvTermData spec[] = {
    ERL_DRV_ATOM, driver_mk_atom(&quot;tcp&quot;),
    ERL_DRV_PORT, driver_mk_port(drvport),
        ERL_DRV_INT, 100,
        ERL_DRV_BINARY, bin, 50, 0,
        ERL_DRV_LIST, 2,
    ERL_DRV_TUPLE, 3,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));</code></pre><p>Here <code class="inline">bin</code> is a driver binary of length at least 50 and <code class="inline">drvport</code> is a port
handle. Notice that <code class="inline">ERL_DRV_LIST</code> comes after the elements of the list,
likewise <code class="inline">ERL_DRV_TUPLE</code>.</p><p>The <code class="inline">ERL_DRV_STRING_CONS</code> term is a way to construct strings. It works
differently from how <code class="inline">ERL_DRV_STRING</code> works. <code class="inline">ERL_DRV_STRING_CONS</code> builds a
string list in reverse order (as opposed to how <code class="inline">ERL_DRV_LIST</code> works),
concatenating the strings added to a list. The tail must be specified before
<code class="inline">ERL_DRV_STRING_CONS</code>.</p><p><code class="inline">ERL_DRV_STRING</code> constructs a string, and ends it. (So it is the same as
<code class="inline">ERL_DRV_NIL</code> followed by <code class="inline">ERL_DRV_STRING_CONS</code>.)</p><pre><code class="makeup c" translate="no"><span class="cm">/* to send [x, &quot;abc&quot;, y] to the port: */</span><span class="w">
</span><span class="no">ErlDrvTermData</span><span class="w"> </span><span class="n">spec</span><span class="p" data-group-id="2214368144-1">[</span><span class="p" data-group-id="2214368144-1">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="2214368144-2">{</span><span class="w">
    </span><span class="no">ERL_DRV_ATOM</span><span class="p">,</span><span class="w"> </span><span class="nf">driver_mk_atom</span><span class="p" data-group-id="2214368144-3">(</span><span class="s">&quot;x&quot;</span><span class="p" data-group-id="2214368144-3">)</span><span class="p">,</span><span class="w">
    </span><span class="no">ERL_DRV_STRING</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2214368144-4">(</span><span class="no">ErlDrvTermData</span><span class="p" data-group-id="2214368144-4">)</span><span class="s">&quot;abc&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">
    </span><span class="no">ERL_DRV_ATOM</span><span class="p">,</span><span class="w"> </span><span class="nf">driver_mk_atom</span><span class="p" data-group-id="2214368144-5">(</span><span class="s">&quot;y&quot;</span><span class="p" data-group-id="2214368144-5">)</span><span class="p">,</span><span class="w">
    </span><span class="no">ERL_DRV_NIL</span><span class="p">,</span><span class="w">
    </span><span class="no">ERL_DRV_LIST</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span><span class="p" data-group-id="2214368144-2">}</span><span class="p">;</span><span class="w">
</span><span class="nf">erl_drv_output_term</span><span class="p" data-group-id="2214368144-6">(</span><span class="nf">driver_mk_port</span><span class="p" data-group-id="2214368144-7">(</span><span class="n">drvport</span><span class="p" data-group-id="2214368144-7">)</span><span class="p">,</span><span class="w"> </span><span class="n">spec</span><span class="p">,</span><span class="w"> </span><span class="nf">sizeof</span><span class="p" data-group-id="2214368144-8">(</span><span class="n">spec</span><span class="p" data-group-id="2214368144-8">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nf">sizeof</span><span class="p" data-group-id="2214368144-9">(</span><span class="n">spec</span><span class="p" data-group-id="2214368144-10">[</span><span class="mi">0</span><span class="p" data-group-id="2214368144-10">]</span><span class="p" data-group-id="2214368144-9">)</span><span class="p" data-group-id="2214368144-6">)</span><span class="p">;</span></code></pre><pre><code class="makeup c" translate="no"><span class="cm">/* to send &quot;abc123&quot; to the port: */</span><span class="w">
</span><span class="no">ErlDrvTermData</span><span class="w"> </span><span class="n">spec</span><span class="p" data-group-id="1298438251-1">[</span><span class="p" data-group-id="1298438251-1">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1298438251-2">{</span><span class="w">
    </span><span class="no">ERL_DRV_NIL</span><span class="p">,</span><span class="w">        </span><span class="cm">/* with STRING_CONS, the tail comes first */</span><span class="w">
    </span><span class="no">ERL_DRV_STRING_CONS</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1298438251-3">(</span><span class="no">ErlDrvTermData</span><span class="p" data-group-id="1298438251-3">)</span><span class="s">&quot;123&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">
    </span><span class="no">ERL_DRV_STRING_CONS</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1298438251-4">(</span><span class="no">ErlDrvTermData</span><span class="p" data-group-id="1298438251-4">)</span><span class="s">&quot;abc&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">
</span><span class="p" data-group-id="1298438251-2">}</span><span class="p">;</span><span class="w">
</span><span class="nf">erl_drv_output_term</span><span class="p" data-group-id="1298438251-5">(</span><span class="nf">driver_mk_port</span><span class="p" data-group-id="1298438251-6">(</span><span class="n">drvport</span><span class="p" data-group-id="1298438251-6">)</span><span class="p">,</span><span class="w"> </span><span class="n">spec</span><span class="p">,</span><span class="w"> </span><span class="nf">sizeof</span><span class="p" data-group-id="1298438251-7">(</span><span class="n">spec</span><span class="p" data-group-id="1298438251-7">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nf">sizeof</span><span class="p" data-group-id="1298438251-8">(</span><span class="n">spec</span><span class="p" data-group-id="1298438251-9">[</span><span class="mi">0</span><span class="p" data-group-id="1298438251-9">]</span><span class="p" data-group-id="1298438251-8">)</span><span class="p" data-group-id="1298438251-5">)</span><span class="p">;</span></code></pre><p><a href="" id="ERL_DRV_EXT2TERM"></a></p><p>The <code class="inline">ERL_DRV_EXT2TERM</code> term type is used for passing
a term encoded with the <a href="erl_ext_dist.html">external format</a>, that is, a term that
has been encoded by <a href="erlang.html#term_to_binary/2"><code class="inline">erlang:term_to_binary()</code></a>,
<a href="../../apps/erl_interface/ei.html"><code class="inline">erl_interface:ei(3)</code></a>, and so on. For example, if
<code class="inline">binp</code> is a pointer to an <code class="inline">ErlDrvBinary</code> that contains term <code class="inline">{17, 4711}</code> encoded
with the <a href="erl_ext_dist.html">external format</a>, and you want to wrap it in a
two-tuple with the tag <code class="inline">my_tag</code>, that is, <code class="inline">{my_tag, {17, 4711}}</code>, you can do as
follows:</p><pre><code class="text">ErlDrvTermData spec[] = {
        ERL_DRV_ATOM, driver_mk_atom(&quot;my_tag&quot;),
        ERL_DRV_EXT2TERM, (ErlDrvTermData) binp-&gt;orig_bytes, binp-&gt;orig_size
    ERL_DRV_TUPLE, 2,
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));</code></pre><p>To build the map <code class="inline">#{key1 =&gt; 100, key2 =&gt; {200, 300}}</code>, the following call can be
made.</p><pre><code class="text">ErlDrvPort port = ...
ErlDrvTermData spec[] = {
    ERL_DRV_ATOM, driver_mk_atom(&quot;key1&quot;),
        ERL_DRV_INT, 100,
    ERL_DRV_ATOM, driver_mk_atom(&quot;key2&quot;),
        ERL_DRV_INT, 200,
        ERL_DRV_INT, 300,
    ERL_DRV_TUPLE, 2,
    ERL_DRV_MAP, 2
};
erl_drv_output_term(driver_mk_port(drvport), spec, sizeof(spec) / sizeof(spec[0]));</code></pre><p>If you want to pass a binary and do not already have the content of the binary
in an <code class="inline">ErlDrvBinary</code>, you can benefit from using <code class="inline">ERL_DRV_BUF2BINARY</code> instead of
creating an <code class="inline">ErlDrvBinary</code> through
<a href="erl_driver.html#driver_alloc_binary"><code class="inline">driver_alloc_binary</code></a> and then pass the
binary through <code class="inline">ERL_DRV_BINARY</code>. The runtime system often allocates binaries
smarter if <code class="inline">ERL_DRV_BUF2BINARY</code> is used. However, if the content of the binary
to pass already resides in an <code class="inline">ErlDrvBinary</code>, it is normally better to pass the
binary using <code class="inline">ERL_DRV_BINARY</code> and the <code class="inline">ErlDrvBinary</code> in question.</p><p>The <code class="inline">ERL_DRV_UINT</code>, <code class="inline">ERL_DRV_BUF2BINARY</code>, and <code class="inline">ERL_DRV_EXT2TERM</code> term types were
introduced in ERTS 5.6.</p><p>This function is thread-safe.</p><p>Available since OTP R16B</p><h2 id="erl_drv_putenv" class="section-heading"><a href="#erl_drv_putenv" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_putenv()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">erl_drv_putenv</span><span class="p" data-group-id="8681105827-1">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w">
        </span><span class="o">*</span><span class="n">value</span><span class="p" data-group-id="8681105827-1">)</span><span class="p">;</span></code></pre><p>Sets the value of an environment variable.</p><p><code class="inline">key</code> is a <code class="inline">NULL</code>-terminated string containing the name of the environment
variable.</p><p><code class="inline">value</code> is a <code class="inline">NULL</code>-terminated string containing the new value of the
environment variable.</p><p>Returns <code class="inline">0</code> on success, otherwise a value <code class="inline">!= 0</code>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The result of passing the empty string (<code class="inline">&quot;&quot;</code>) as a value is
platform-dependent. On some platforms the variable value is set to the empty
string, on others the environment variable is removed.</p></section><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>This function modifies the emulated environment used by <a href="../../apps/kernel/os.html#putenv/2"><code class="inline">os:putenv/2</code></a> and not
the environment used by libc's <code class="inline">putenv(3)</code> or similar. Drivers that <em>require</em>
that these are in sync will need to do so themselves, but keep in mind that
they are segregated for a reason; <code class="inline">putenv(3)</code> and its friends are <em>not
thread-safe</em> and may cause unrelated code to misbehave or crash the emulator.</p></section><p>This function is thread-safe.</p><h2 id="erl_drv_rwlock_create" class="section-heading"><a href="#erl_drv_rwlock_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_rwlock_create()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvRWLock</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">erl_drv_rwlock_create</span><span class="p" data-group-id="4236898589-1">(</span><span class="kt">char</span><span class="w">
        </span><span class="o">*</span><span class="n">name</span><span class="p" data-group-id="4236898589-1">)</span><span class="p">;</span></code></pre><p>Creates an rwlock and returns a pointer to it.</p><p><code class="inline">name</code> is a string identifying the created rwlock. It is used to identify the
rwlock in debug functionality (see note about the
<a href="erl_driver.html#lock_checker">lock checker</a>).</p><p>Returns <code class="inline">NULL</code> on failure. The driver creating the rwlock is responsible for
destroying it before the driver is unloaded.</p><p>This function is thread-safe.</p><h2 id="erl_drv_rwlock_destroy" class="section-heading"><a href="#erl_drv_rwlock_destroy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_rwlock_destroy()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_rwlock_destroy</span><span class="p" data-group-id="7030486453-1">(</span><span class="no">ErlDrvRWLock</span><span class="w">
        </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="7030486453-1">)</span><span class="p">;</span></code></pre><p>Destroys an rwlock previously created by
<a href="erl_driver.html#erl_drv_rwlock_create"><code class="inline">erl_drv_rwlock_create</code></a>. The rwlock must
be in an unlocked state before it is destroyed.</p><p><code class="inline">rwlck</code> is a pointer to an rwlock to destroy.</p><p>This function is thread-safe.</p><h2 id="erl_drv_rwlock_name" class="section-heading"><a href="#erl_drv_rwlock_name" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_rwlock_name()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">erl_drv_rwlock_name</span><span class="p" data-group-id="5612280302-1">(</span><span class="no">ErlDrvRWLock</span><span class="w">
        </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="5612280302-1">)</span><span class="p">;</span></code></pre><p>Returns a pointer to the name of the rwlock.</p><p><code class="inline">rwlck</code> is a pointer to an initialized rwlock.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>This function is intended for debugging purposes only.</p></section><p>Available since OTP R16B02</p><h2 id="erl_drv_rwlock_rlock" class="section-heading"><a href="#erl_drv_rwlock_rlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_rwlock_rlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_rwlock_rlock</span><span class="p" data-group-id="7159394836-1">(</span><span class="no">ErlDrvRWLock</span><span class="w">
        </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="7159394836-1">)</span><span class="p">;</span></code></pre><p>Read locks an rwlock. The calling thread is blocked until the rwlock has been
read locked. A thread that currently has read or read/write locked the rwlock
<em>cannot</em> lock the same rwlock again.</p><p><code class="inline">rwlck</code> is a pointer to the rwlock to read lock.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>If you leave an rwlock locked in an emulator thread when you let the thread
out of your control, you will <em>very likely</em> deadlock the whole emulator.</p></section><p>This function is thread-safe.</p><h2 id="erl_drv_rwlock_runlock" class="section-heading"><a href="#erl_drv_rwlock_runlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_rwlock_runlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_rwlock_runlock</span><span class="p" data-group-id="4920226228-1">(</span><span class="no">ErlDrvRWLock</span><span class="w">
        </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="4920226228-1">)</span><span class="p">;</span></code></pre><p>Read unlocks an rwlock. The rwlock currently must be read locked by the calling
thread.</p><p><code class="inline">rwlck</code> is a pointer to an rwlock to read unlock.</p><p>This function is thread-safe.</p><h2 id="erl_drv_rwlock_rwlock" class="section-heading"><a href="#erl_drv_rwlock_rwlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_rwlock_rwlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_rwlock_rwlock</span><span class="p" data-group-id="1756332830-1">(</span><span class="no">ErlDrvRWLock</span><span class="w">
        </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="1756332830-1">)</span><span class="p">;</span></code></pre><p>Read/write locks an rwlock. The calling thread is blocked until the rwlock has
been read/write locked. A thread that currently has read or read/write locked
the rwlock <em>cannot</em> lock the same rwlock again.</p><p><code class="inline">rwlck</code> is a pointer to an rwlock to read/write lock.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>If you leave an rwlock locked in an emulator thread when you let the thread
out of your control, you will <em>very likely</em> deadlock the whole emulator.</p></section><p>This function is thread-safe.</p><h2 id="erl_drv_rwlock_rwunlock" class="section-heading"><a href="#erl_drv_rwlock_rwunlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_rwlock_rwunlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_rwlock_rwunlock</span><span class="p" data-group-id="5009143896-1">(</span><span class="no">ErlDrvRWLock</span><span class="w">
        </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="5009143896-1">)</span><span class="p">;</span></code></pre><p>Read/write unlocks an rwlock. The rwlock currently must be read/write locked by
the calling thread.</p><p><code class="inline">rwlck</code> is a pointer to an rwlock to read/write unlock.</p><p>This function is thread-safe.</p><h2 id="erl_drv_rwlock_tryrlock" class="section-heading"><a href="#erl_drv_rwlock_tryrlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_rwlock_tryrlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">erl_drv_rwlock_tryrlock</span><span class="p" data-group-id="4148195107-1">(</span><span class="no">ErlDrvRWLock</span><span class="w">
        </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="4148195107-1">)</span><span class="p">;</span></code></pre><p>Tries to read lock an rwlock.</p><p><code class="inline">rwlck</code> is a pointer to an rwlock to try to read lock.</p><p>Returns <code class="inline">0</code> on success, otherwise <code class="inline">EBUSY</code>. A thread that currently has read or
read/write locked the rwlock <em>cannot</em> try to lock the same rwlock again.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>If you leave an rwlock locked in an emulator thread when you let the thread
out of your control, you will <em>very likely</em> deadlock the whole emulator.</p></section><p>This function is thread-safe.</p><h2 id="erl_drv_rwlock_tryrwlock" class="section-heading"><a href="#erl_drv_rwlock_tryrwlock" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_rwlock_tryrwlock()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">erl_drv_rwlock_tryrwlock</span><span class="p" data-group-id="8235688674-1">(</span><span class="no">ErlDrvRWLock</span><span class="w">
        </span><span class="o">*</span><span class="n">rwlck</span><span class="p" data-group-id="8235688674-1">)</span><span class="p">;</span></code></pre><p>Tries to read/write lock an rwlock. A thread that currently has read or
read/write locked the rwlock <em>cannot</em> try to lock the same rwlock again.</p><p><code class="inline">rwlck</code>is pointer to an rwlock to try to read/write lock.</p><p>Returns <code class="inline">0</code> on success, otherwise <code class="inline">EBUSY</code>.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>If you leave an rwlock locked in an emulator thread when you let the thread
out of your control, you will <em>very likely</em> deadlock the whole emulator.</p></section><p>This function is thread-safe.</p><h2 id="erl_drv_send_term" class="section-heading"><a href="#erl_drv_send_term" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_send_term()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">erl_drv_send_term</span><span class="p" data-group-id="6288615650-1">(</span><span class="no">ErlDrvTermData</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvTermData</span><span class="w"> </span><span class="n">receiver</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvTermData</span><span class="o">*</span><span class="w"> </span><span class="n">term</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p" data-group-id="6288615650-1">)</span><span class="p">;</span></code></pre><p>This function is the only way for a driver to send data to <em>other</em> processes
than the port owner process. Parameter <code class="inline">receiver</code> specifies the process to
receive the data.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Parameter <code class="inline">port</code> is <em>not</em> an ordinary port handle, but a port handle converted
using <a href="erl_driver.html#driver_mk_port"><code class="inline">driver_mk_port</code></a>.</p></section><p>Parameters <code class="inline">port</code>, <code class="inline">term</code>, and <code class="inline">n</code> work as in
<a href="erl_driver.html#erl_drv_output_term"><code class="inline">erl_drv_output_term</code></a>.</p><p>This function is thread-safe.</p><p>Available since OTP R16B</p><h2 id="erl_drv_set_os_pid" class="section-heading"><a href="#erl_drv_set_os_pid" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_set_os_pid()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_set_os_pid</span><span class="p" data-group-id="4130266679-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvSInt</span><span class="w"> </span><span class="n">pid</span><span class="p" data-group-id="4130266679-1">)</span><span class="p">;</span></code></pre><p>Sets the <code class="inline">os_pid</code> seen when doing <a href="erlang.html#port_info/2"><code class="inline">erlang:port_info/2</code></a> on this port.</p><p><code class="inline">port</code> is the port handle of the port (driver instance) to set the pid on.
<code class="inline">pid</code>is the pid to set.</p><p>Available since OTP 19.0</p><h2 id="erl_drv_thread_create" class="section-heading"><a href="#erl_drv_thread_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_thread_create()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">erl_drv_thread_create</span><span class="p" data-group-id="3693555532-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvTid</span><span class="w">
        </span><span class="o">*</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p" data-group-id="3693555532-2">(</span><span class="o">*</span><span class="n">func</span><span class="p" data-group-id="3693555532-2">)</span><span class="p" data-group-id="3693555532-3">(</span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="p" data-group-id="3693555532-3">)</span><span class="p">,</span><span class="w"> </span><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="no">ErlDrvThreadOpts</span><span class="w">
        </span><span class="o">*</span><span class="n">opts</span><span class="p" data-group-id="3693555532-1">)</span><span class="p">;</span></code></pre><p>Creates a new thread.</p><ul><li><p><strong><code class="inline">name</code></strong> - A string identifying the created thread. It is used to identify
the thread in planned future debug functionality.</p></li><li><p><strong><code class="inline">tid</code></strong> - A pointer to a thread identifier variable.</p></li><li><p><strong><code class="inline">func</code></strong> - A pointer to a function to execute in the created thread.</p></li><li><p><strong><code class="inline">arg</code></strong> - A pointer to argument to the <code class="inline">func</code> function.</p></li><li><p><strong><code class="inline">opts</code></strong> - A pointer to thread options to use or <code class="inline">NULL</code>.</p></li></ul><p>Returns <code class="inline">0</code> on success, otherwise an <code class="inline">errno</code> value is returned to indicate the
error. The newly created thread begins executing in the function pointed to by
<code class="inline">func</code>, and <code class="inline">func</code> is passed <code class="inline">arg</code> as argument. When <code class="inline">erl_drv_thread_create</code>
returns, the thread identifier of the newly created thread is available in
<code class="inline">*tid</code>. <code class="inline">opts</code> can be either a <code class="inline">NULL</code> pointer, or a pointer to an
<a href="erl_driver.html#ErlDrvThreadOpts"><code class="inline">ErlDrvThreadOpts</code></a> structure. If <code class="inline">opts</code> is a
<code class="inline">NULL</code> pointer, default options are used, otherwise the passed options are used.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>You are not allowed to allocate the
<a href="erl_driver.html#ErlDrvThreadOpts"><code class="inline">ErlDrvThreadOpts</code></a> structure by yourself. It
must be allocated and initialized by
<a href="erl_driver.html#erl_drv_thread_opts_create"><code class="inline">erl_drv_thread_opts_create</code></a>.</p></section><p>The created thread terminates either when <code class="inline">func</code> returns or if
<a href="erl_driver.html#erl_drv_thread_exit"><code class="inline">erl_drv_thread_exit</code></a> is called by the
thread. The exit value of the thread is either returned from <code class="inline">func</code> or passed as
argument to <a href="erl_driver.html#erl_drv_thread_exit"><code class="inline">erl_drv_thread_exit</code></a>. The
driver creating the thread is responsible for joining the thread, through
<a href="erl_driver.html#erl_drv_thread_join"><code class="inline">erl_drv_thread_join</code></a>, before the driver is
unloaded. &quot;Detached&quot; threads cannot be created, that is, threads that do not
need to be joined.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>All created threads must be joined by the driver before it is unloaded. If the
driver fails to join all threads created before it is unloaded, the runtime
system most likely crashes when the driver code is unloaded.</p></section><p>This function is thread-safe.</p><h2 id="erl_drv_thread_exit" class="section-heading"><a href="#erl_drv_thread_exit" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_thread_exit()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_thread_exit</span><span class="p" data-group-id="3576150906-1">(</span><span class="kc">void</span><span class="w">
        </span><span class="o">*</span><span class="n">exit_value</span><span class="p" data-group-id="3576150906-1">)</span><span class="p">;</span></code></pre><p>Terminates the calling thread with the exit value passed as argument.
<code class="inline">exit_value</code> is a pointer to an exit value or <code class="inline">NULL</code>.</p><p>You are only allowed to terminate threads created with
<a href="erl_driver.html#erl_drv_thread_create"><code class="inline">erl_drv_thread_create</code></a>.</p><p>The exit value can later be retrieved by another thread through
<a href="erl_driver.html#erl_drv_thread_join"><code class="inline">erl_drv_thread_join</code></a>.</p><p>This function is thread-safe.</p><h2 id="erl_drv_thread_join" class="section-heading"><a href="#erl_drv_thread_join" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_thread_join()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">erl_drv_thread_join</span><span class="p" data-group-id="1703487657-1">(</span><span class="no">ErlDrvTid</span><span class="w"> </span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="kc">void</span><span class="w">
        </span><span class="o">*</span><span class="o">*</span><span class="n">exit_value</span><span class="p" data-group-id="1703487657-1">)</span><span class="p">;</span></code></pre><p>Joins the calling thread with another thread, that is, the calling thread is
blocked until the thread identified by <code class="inline">tid</code> has terminated.</p><p><code class="inline">tid</code> is the thread identifier of the thread to join. <code class="inline">exit_value</code> is a pointer
to a pointer to an exit value, or <code class="inline">NULL</code>.</p><p>Returns <code class="inline">0</code> on success, otherwise an <code class="inline">errno</code> value is returned to indicate the
error.</p><p>A thread can only be joined once. The behavior of joining more than once is
undefined, an emulator crash is likely. If <code class="inline">exit_value == NULL</code>, the exit value
of the terminated thread is ignored, otherwise the exit value of the terminated
thread is stored at <code class="inline">*exit_value</code>.</p><p>This function is thread-safe.</p><h2 id="erl_drv_thread_name" class="section-heading"><a href="#erl_drv_thread_name" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_thread_name()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">erl_drv_thread_name</span><span class="p" data-group-id="1898185785-1">(</span><span class="no">ErlDrvTid</span><span class="w">
        </span><span class="n">tid</span><span class="p" data-group-id="1898185785-1">)</span><span class="p">;</span></code></pre><p>Returns a pointer to the name of the thread.</p><p><code class="inline">tid</code> is a thread identifier.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>This function is intended for debugging purposes only.</p></section><p>Available since OTP R16B02</p><h2 id="erl_drv_thread_opts_create" class="section-heading"><a href="#erl_drv_thread_opts_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_thread_opts_create()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvThreadOpts</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">erl_drv_thread_opts_create</span><span class="p" data-group-id="4698806834-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p" data-group-id="4698806834-1">)</span><span class="p">;</span></code></pre><p>Allocates and initializes a thread option structure.</p><p><code class="inline">name</code> is a string identifying the created thread options. It is used to
identify the thread options in planned future debug functionality.</p><p>Returns <code class="inline">NULL</code> on failure. A thread option structure is used for passing options
to <a href="erl_driver.html#erl_drv_thread_create"><code class="inline">erl_drv_thread_create</code></a>. If the
structure is not modified before it is passed to
<a href="erl_driver.html#erl_drv_thread_create"><code class="inline">erl_drv_thread_create</code></a>, the default
values are used.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>You are not allowed to allocate the
<a href="erl_driver.html#ErlDrvThreadOpts"><code class="inline">ErlDrvThreadOpts</code></a> structure by yourself. It
must be allocated and initialized by <code class="inline">erl_drv_thread_opts_create</code>.</p></section><p>This function is thread-safe.</p><h2 id="erl_drv_thread_opts_destroy" class="section-heading"><a href="#erl_drv_thread_opts_destroy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_thread_opts_destroy()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_thread_opts_destroy</span><span class="p" data-group-id="1925761673-1">(</span><span class="no">ErlDrvThreadOpts</span><span class="w"> </span><span class="o">*</span><span class="n">opts</span><span class="p" data-group-id="1925761673-1">)</span><span class="p">;</span></code></pre><p>Destroys thread options previously created by
<a href="erl_driver.html#erl_drv_thread_opts_create"><code class="inline">erl_drv_thread_opts_create</code></a>.</p><p><code class="inline">opts</code> is a pointer to thread options to destroy.</p><p>This function is thread-safe.</p><h2 id="erl_drv_thread_self" class="section-heading"><a href="#erl_drv_thread_self" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_thread_self()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvTid</span><span class="w"> </span><span class="nf">erl_drv_thread_self</span><span class="p" data-group-id="9468779925-1">(</span><span class="kc">void</span><span class="p" data-group-id="9468779925-1">)</span><span class="p">;</span></code></pre><p>Returns the thread identifier of the calling thread.</p><p>This function is thread-safe.</p><h2 id="erl_drv_time_offset" class="section-heading"><a href="#erl_drv_time_offset" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_time_offset()</span></h2><pre><code class="makeup c" translate="no"><span class="no">ErlDrvTime</span><span class="w"> </span><span class="nf">erl_drv_time_offset</span><span class="p" data-group-id="6165742692-1">(</span><span class="no">ErlDrvTimeUnit</span><span class="w">
        </span><span class="n">time_unit</span><span class="p" data-group-id="6165742692-1">)</span><span class="p">;</span></code></pre><p>Returns the current time offset between
<a href="time_correction.html#erlang-monotonic-time">Erlang monotonic time</a> and
<a href="time_correction.html#erlang-system-time">Erlang system time</a> converted into the
<code class="inline">time_unit</code> passed as argument.</p><p><code class="inline">time_unit</code> is time unit of returned value.</p><p>Returns <code class="inline">ERL_DRV_TIME_ERROR</code> if called with an invalid time unit argument, or if
called from a thread that is not a scheduler thread.</p><p>See also <a href="erl_driver.html#ErlDrvTime"><code class="inline">ErlDrvTime</code></a> and
<a href="erl_driver.html#ErlDrvTimeUnit"><code class="inline">ErlDrvTimeUnit</code></a>.</p><p>Available since OTP 18.3</p><h2 id="erl_drv_tsd_get" class="section-heading"><a href="#erl_drv_tsd_get" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_tsd_get()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">erl_drv_tsd_get</span><span class="p" data-group-id="2549397875-1">(</span><span class="no">ErlDrvTSDKey</span><span class="w">
        </span><span class="n">key</span><span class="p" data-group-id="2549397875-1">)</span><span class="p">;</span></code></pre><p>Returns the thread-specific data associated with <code class="inline">key</code> for the calling thread.</p><p><code class="inline">key</code> is a thread-specific data key.</p><p>Returns <code class="inline">NULL</code> if no data has been associated with <code class="inline">key</code> for the calling thread.</p><p>This function is thread-safe.</p><h2 id="erl_drv_tsd_key_create" class="section-heading"><a href="#erl_drv_tsd_key_create" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_tsd_key_create()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">erl_drv_tsd_key_create</span><span class="p" data-group-id="9627594657-1">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w">
        </span><span class="no">ErlDrvTSDKey</span><span class="w"> </span><span class="o">*</span><span class="n">key</span><span class="p" data-group-id="9627594657-1">)</span><span class="p">;</span></code></pre><p>Creates a thread-specific data key.</p><p><code class="inline">name</code> is a string identifying the created key. It is used to identify the key
in planned future debug functionality.</p><p><code class="inline">key</code> is a pointer to a thread-specific data key variable.</p><p>Returns <code class="inline">0</code> on success, otherwise an <code class="inline">errno</code> value is returned to indicate the
error. The driver creating the key is responsible for destroying it before the
driver is unloaded.</p><p>This function is thread-safe.</p><h2 id="erl_drv_tsd_key_destroy" class="section-heading"><a href="#erl_drv_tsd_key_destroy" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_tsd_key_destroy()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_tsd_key_destroy</span><span class="p" data-group-id="3323318652-1">(</span><span class="no">ErlDrvTSDKey</span><span class="w">
        </span><span class="n">key</span><span class="p" data-group-id="3323318652-1">)</span><span class="p">;</span></code></pre><p>Destroys a thread-specific data key previously created by
<a href="erl_driver.html#erl_drv_tsd_key_create"><code class="inline">erl_drv_tsd_key_create</code></a>. All
thread-specific data using this key in all threads must be cleared (see
<a href="erl_driver.html#erl_drv_tsd_set"><code class="inline">erl_drv_tsd_set</code></a>) before the call to
<code class="inline">erl_drv_tsd_key_destroy</code>.</p><p><code class="inline">key</code> is a thread-specific data key to destroy.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>A destroyed key is very likely to be reused soon. Therefore, if you fail to
clear the thread-specific data using this key in a thread before destroying
the key, you will <em>very likely</em> get unexpected errors in other parts of the
system.</p></section><p>This function is thread-safe.</p><h2 id="erl_drv_tsd_set" class="section-heading"><a href="#erl_drv_tsd_set" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_drv_tsd_set()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">erl_drv_tsd_set</span><span class="p" data-group-id="3632448429-1">(</span><span class="no">ErlDrvTSDKey</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kc">void</span><span class="w">
        </span><span class="o">*</span><span class="n">data</span><span class="p" data-group-id="3632448429-1">)</span><span class="p">;</span></code></pre><p>Sets thread-specific data associated with <code class="inline">key</code> for the calling thread. You are
only allowed to set thread-specific data for threads while they are fully under
your control. For example, if you set thread-specific data in a thread calling a
driver callback function, it must be cleared, that is, set to <code class="inline">NULL</code>, before
returning from the driver callback function.</p><p><code class="inline">key</code> is a thread-specific data key.</p><p><code class="inline">data</code> is a pointer to data to associate with <code class="inline">key</code> in the calling thread.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>If you fail to clear thread-specific data in an emulator thread before letting
it out of your control, you might never be able to clear this data with later
unexpected errors in other parts of the system as a result.</p></section><p>This function is thread-safe.</p><h2 id="erl_errno_id" class="section-heading"><a href="#erl_errno_id" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">erl_errno_id()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">erl_errno_id</span><span class="p" data-group-id="8687549280-1">(</span><span class="kt">int</span><span class="w"> </span><span class="n">error</span><span class="p" data-group-id="8687549280-1">)</span><span class="p">;</span></code></pre><p>Returns the atom name of the Erlang error, given the error number in <code class="inline">error</code>.
The error atoms are <code class="inline">einval</code>, <code class="inline">enoent</code>, and so on. It can be used to make error
terms from the driver.</p><h2 id="remove_driver_entry" class="section-heading"><a href="#remove_driver_entry" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">remove_driver_entry()</span></h2><pre><code class="makeup c" translate="no"><span class="kt">int</span><span class="w"> </span><span class="nf">remove_driver_entry</span><span class="p" data-group-id="1600523912-1">(</span><span class="no">ErlDrvEntry</span><span class="w">
        </span><span class="o">*</span><span class="n">de</span><span class="p" data-group-id="1600523912-1">)</span><span class="p">;</span></code></pre><p>Removes a driver entry <code class="inline">de</code> previously added with
<a href="erl_driver.html#add_driver_entry"><code class="inline">add_driver_entry</code></a>.</p><p>Driver entries added by the <code class="inline">erl_ddll</code> Erlang interface cannot be removed by
using this interface.</p><h2 id="set_busy_port" class="section-heading"><a href="#set_busy_port" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">set_busy_port()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">set_busy_port</span><span class="p" data-group-id="8603373991-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w">
        </span><span class="n">on</span><span class="p" data-group-id="8603373991-1">)</span><span class="p">;</span></code></pre><p>Sets and unsets the busy state of the port. If <code class="inline">on</code> is non-zero, the port is set
to busy. If it is zero, the port is set to not busy. You typically want to
combine this feature with the
<a href="erl_driver.html#erl_drv_busy_msgq_limits">busy port message queue</a> functionality.</p><p>Processes sending command data to the port are suspended if either the port or
the port message queue is busy. Suspended processes are resumed when neither the
port or the port message queue is busy. Command data is in this context data
passed to the port using either <code class="inline">Port ! {Owner, {command, Data}}</code> or
<code class="inline">port_command/[2,3]</code>.</p><p>If the <a href="driver_entry.html#driver_flags">ERL_DRV_FLAG_SOFT_BUSY</a> has been set in
the <a href="driver_entry.html"><code class="inline">driver_entry</code></a>, data can be forced into the driver
through <a href="erlang.html#port_command/3"><code class="inline">erlang:port_command(Port, Data, [force])</code></a>
even if the driver has signaled that it is busy.</p><p>For information about busy port message queue functionality, see
<a href="erl_driver.html#erl_drv_busy_msgq_limits"><code class="inline">erl_drv_busy_msgq_limits</code></a>.</p><h2 id="set_port_control_flags" class="section-heading"><a href="#set_port_control_flags" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">set_port_control_flags()</span></h2><pre><code class="makeup c" translate="no"><span class="kc">void</span><span class="w"> </span><span class="nf">set_port_control_flags</span><span class="p" data-group-id="7375894134-1">(</span><span class="no">ErlDrvPort</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w">
        </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p" data-group-id="7375894134-1">)</span><span class="p">;</span></code></pre><p>Sets flags for how the <a href="driver_entry.html#control"><code class="inline">control</code></a> driver entry
function will return data to the port owner process. (The <code class="inline">control</code> function is
called from <a href="erlang.html#port_control/3"><code class="inline">erlang:port_control/3</code></a>.)</p><p>Currently there are only two meaningful values for <code class="inline">flags</code>: <code class="inline">0</code> means that data
is returned in a list, and <code class="inline">PORT_CONTROL_FLAG_BINARY</code> means data is returned as
a binary from <code class="inline">control</code>.</p><h2 id="see-also" class="section-heading"><a href="#see-also" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">See Also</span></h2><p><a href="driver_entry.html"><code class="inline">driver_entry(3)</code></a>, <a href="erlang.html"><code class="inline">erlang</code></a>, <a href="../../apps/kernel/erl_ddll.html"><code class="inline">erl_ddll</code></a>, section
<a href="alt_dist.html">How to Implement an Alternative Carrier for the Erlang Distribution</a>
in the User's Guide</p>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="driver_entry.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          â† Previous Page
        </span>
        <span class="title">
driver_entry
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="erl_nif.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page â†’
        </span>
        <span class="title">
erl_nif
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.38.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright Â© 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
