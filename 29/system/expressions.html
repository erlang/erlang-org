<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.38.1">
    <meta name="project" content="Erlang System Documentation v29.0-rc0">


<meta name="major-vsn" content="29">
<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=29&q=">
<link rel="canonical" href="https://www.erlang.org/doc/system/expressions.html" />
    <title>Expressions — Erlang System Documentation v29.0-rc0</title>

    <link rel="stylesheet" href="dist/html-erlang-ZK43ZOAC.css" />

    <script defer src="dist/sidebar_items-1026E94C.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-DPJLHKSM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="Erlang System Documentation" />
        </a>

      <div>
        <a href="../index.html" class="sidebar-projectName" translate="no">
Erlang System Documentation
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v29.0-rc0
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of Erlang System Documentation</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>Expressions</h1>


      <a href="https://github.com/erlang/otp/blob/master/system/doc/reference_manual/expressions.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<p>In this section, all valid Erlang expressions are listed. When writing Erlang
programs, it is also allowed to use macro and record expressions. However,
these expressions are expanded during compilation and are in that sense not true
Erlang expressions. Macro and record expressions are covered in separate
sections:</p><ul><li><a href="macros.html">Preprocessor</a></li><li><a href="ref_man_records.html">Records</a></li></ul><h2 id="expression-evaluation" class="section-heading"><a href="#expression-evaluation" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Expression Evaluation</span></h2><p>All subexpressions are evaluated before an expression itself is evaluated,
unless explicitly stated otherwise. For example, consider the expression:</p><pre><code class="makeup erlang" translate="no"><span class="n">Expr1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Expr2</span></code></pre><p><code class="inline">Expr1</code> and <code class="inline">Expr2</code>, which are also expressions, are evaluated first — in any
order — before the addition is performed.</p><p>Many of the operators can only be applied to arguments of a certain type. For
example, arithmetic operators can only be applied to numbers. An argument of the
wrong type causes a <code class="inline">badarg</code> runtime error.</p><h2 id="terms" class="section-heading"><a href="#terms" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Terms</span></h2><p>The simplest form of expression is a term, that is one of
<a href="../apps/erts/erlang.html#t:integer/0"><code class="inline">integer/0</code></a>, <a href="../apps/erts/erlang.html#t:float/0"><code class="inline">float/0</code></a>, <a href="../apps/erts/erlang.html#t:atom/0"><code class="inline">atom/0</code></a>, <a href="../apps/erts/erlang.html#t:string/0"><code class="inline">string/0</code></a>, <a href="../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a>,
<a href="../apps/erts/erlang.html#t:map/0"><code class="inline">map/0</code></a>, or <a href="../apps/erts/erlang.html#t:tuple/0"><code class="inline">tuple/0</code></a>. The return value is the term itself.</p><h2 id="variables" class="section-heading"><a href="#variables" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Variables</span></h2><p>A variable is an expression. If a variable is bound to a value, the return value
is this value. Unbound variables are only allowed in patterns.</p><p>Variables start with an uppercase letter or underscore (<code class="inline">_</code>). Variables can
contain alphanumeric characters, underscore, and <code class="inline">@</code>.</p><p><em>Examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="n">X</span><span class="w">
</span><span class="n">Name1</span><span class="w">
</span><span class="n">PhoneNumber</span><span class="w">
</span><span class="n">Phone_number</span><span class="w">
</span><span class="p">_</span><span class="w">
</span><span class="p">_</span><span class="n">Height</span><span class="w">
</span><span class="ss">name@node</span></code></pre><p>Variables are bound to values using <a href="patterns.html">pattern matching</a>. Erlang uses
<em>single assignment</em>, that is, a variable can only be bound once.</p><p>The <em>anonymous variable</em> is denoted by underscore (_) and can be used when a
variable is required but its value can be ignored.</p><p><em>Example:</em></p><pre><code class="text">[H|_] = [1,2,3]</code></pre><p>Variables starting with underscore (<code class="inline">_</code>), for example, <code class="inline">_Height</code>, are normal
variables, not anonymous. However, they are ignored by the compiler in the sense
that they do not generate warnings.</p><p><em>Example:</em></p><p>The following code:</p><pre><code class="makeup erlang" translate="no"><span class="nf">member</span><span class="p" data-group-id="8155044299-1">(</span><span class="p">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8155044299-2">[</span><span class="p" data-group-id="8155044299-2">]</span><span class="p" data-group-id="8155044299-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="8155044299-3">[</span><span class="p" data-group-id="8155044299-3">]</span><span class="p">.</span></code></pre><p>can be rewritten to be more readable:</p><pre><code class="makeup erlang" translate="no"><span class="nf">member</span><span class="p" data-group-id="3018103267-1">(</span><span class="n">Elem</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3018103267-2">[</span><span class="p" data-group-id="3018103267-2">]</span><span class="p" data-group-id="3018103267-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="3018103267-3">[</span><span class="p" data-group-id="3018103267-3">]</span><span class="p">.</span></code></pre><p>This causes a warning for an unused variable, <code class="inline">Elem</code>. To avoid the warning,
the code can be rewritten to:</p><pre><code class="makeup erlang" translate="no"><span class="nf">member</span><span class="p" data-group-id="7874967825-1">(</span><span class="p">_</span><span class="n">Elem</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7874967825-2">[</span><span class="p" data-group-id="7874967825-2">]</span><span class="p" data-group-id="7874967825-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="7874967825-3">[</span><span class="p" data-group-id="7874967825-3">]</span><span class="p">.</span></code></pre><p>Notice that since variables starting with an underscore are not anonymous, the
following example matches:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="7970572910-1">{</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p" data-group-id="7970572910-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7970572910-2">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="7970572910-2">}</span></code></pre><p>But this example fails:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="6189774307-1">{</span><span class="p">_</span><span class="n">N</span><span class="p">,</span><span class="p">_</span><span class="n">N</span><span class="p" data-group-id="6189774307-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="6189774307-2">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="6189774307-2">}</span></code></pre><p>The scope for a variable is its function clause. Variables bound in a branch of
an <code class="inline">if</code>, <code class="inline">case</code>, or <code class="inline">receive</code> expression must be bound in all branches to have a
value outside the expression. Otherwise they are regarded as unsafe outside
the expression.</p><p>For the <code class="inline">try</code> expression variable scoping is limited so that variables bound in
the expression are always unsafe outside the expression.</p><h2 id="patterns" class="section-heading"><a href="#patterns" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Patterns</span></h2><p>A pattern has the same structure as a term but can contain unbound variables.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="n">Name1</span><span class="w">
</span><span class="p" data-group-id="8007887974-1">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="8007887974-1">]</span><span class="w">
</span><span class="p" data-group-id="8007887974-2">{</span><span class="ss">error</span><span class="p">,</span><span class="n">Reason</span><span class="p" data-group-id="8007887974-2">}</span></code></pre><p>Patterns are allowed in clause heads, <a href="expressions.html#case">case expressions</a>,
<a href="expressions.html#receive">receive expressions</a>, and
<a href="expressions.html#the-match-operator">match expressions</a>.</p><h3 id="the-compound-pattern-operator" class="section-heading"><a href="#the-compound-pattern-operator" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">The Compound Pattern Operator</span></h3><p>If <code class="inline">Pattern1</code> and <code class="inline">Pattern2</code> are valid patterns, the following is also a valid
pattern:</p><pre><code class="makeup erlang" translate="no"><span class="n">Pattern1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pattern2</span></code></pre><p>When matched against a term, both <code class="inline">Pattern1</code> and <code class="inline">Pattern2</code> are matched against
the term. The idea behind this feature is to avoid reconstruction of terms.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="nf">f</span><span class="p" data-group-id="4299836179-1">(</span><span class="p" data-group-id="4299836179-2">{</span><span class="ss">connect</span><span class="p">,</span><span class="n">From</span><span class="p">,</span><span class="n">To</span><span class="p">,</span><span class="n">Number</span><span class="p">,</span><span class="n">Options</span><span class="p" data-group-id="4299836179-2">}</span><span class="p">,</span><span class="w"> </span><span class="n">To</span><span class="p" data-group-id="4299836179-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="n">Signal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4299836179-3">{</span><span class="ss">connect</span><span class="p">,</span><span class="n">From</span><span class="p">,</span><span class="n">To</span><span class="p">,</span><span class="n">Number</span><span class="p">,</span><span class="n">Options</span><span class="p" data-group-id="4299836179-3">}</span><span class="p">,</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">;</span><span class="w">
</span><span class="nf">f</span><span class="p" data-group-id="4299836179-4">(</span><span class="n">Signal</span><span class="p">,</span><span class="w"> </span><span class="n">To</span><span class="p" data-group-id="4299836179-4">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="ss">ignore</span><span class="p">.</span></code></pre><p>can instead be written as</p><pre><code class="makeup erlang" translate="no"><span class="nf">f</span><span class="p" data-group-id="2644069190-1">(</span><span class="p" data-group-id="2644069190-2">{</span><span class="ss">connect</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="n">To</span><span class="p">,</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p" data-group-id="2644069190-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Signal</span><span class="p">,</span><span class="w"> </span><span class="n">To</span><span class="p" data-group-id="2644069190-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">;</span><span class="w">
</span><span class="nf">f</span><span class="p" data-group-id="2644069190-3">(</span><span class="n">Signal</span><span class="p">,</span><span class="w"> </span><span class="n">To</span><span class="p" data-group-id="2644069190-3">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="ss">ignore</span><span class="p">.</span></code></pre><p>The compound pattern operator does not imply that its operands are matched in
any particular order. That means that it is not legal to bind a variable in
<code class="inline">Pattern1</code> and use it in <code class="inline">Pattern2</code>, or vice versa.</p><h3 id="string-prefix-in-patterns" class="section-heading"><a href="#string-prefix-in-patterns" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">String Prefix in Patterns</span></h3><p>When matching strings, the following is a valid pattern:</p><pre><code class="makeup erlang" translate="no"><span class="nf">f</span><span class="p" data-group-id="6051188237-1">(</span><span class="s">&quot;prefix&quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">Str</span><span class="p" data-group-id="6051188237-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span></code></pre><p>This is syntactic sugar for the equivalent, but harder to read:</p><pre><code class="makeup erlang" translate="no"><span class="nf">f</span><span class="p" data-group-id="3172707046-1">(</span><span class="p" data-group-id="3172707046-2">[</span><span class="sc">$p</span><span class="p">,</span><span class="sc">$r</span><span class="p">,</span><span class="sc">$e</span><span class="p">,</span><span class="sc">$f</span><span class="p">,</span><span class="sc">$i</span><span class="p">,</span><span class="sc">$x</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="n">Str</span><span class="p" data-group-id="3172707046-2">]</span><span class="p" data-group-id="3172707046-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span></code></pre><h3 id="expressions-in-patterns" class="section-heading"><a href="#expressions-in-patterns" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Expressions in Patterns</span></h3><p>An arithmetic expression can be used within a pattern if it meets both of the
following two conditions:</p><ul><li>It uses only numeric or bitwise operators.</li><li>Its value can be evaluated to a constant when complied.</li></ul><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="k">case</span><span class="w"> </span><span class="p" data-group-id="4469785682-1">{</span><span class="n">Value</span><span class="p">,</span><span class="w"> </span><span class="n">Result</span><span class="p" data-group-id="4469785682-1">}</span><span class="w"> </span><span class="k">of</span><span class="w">
    </span><span class="p" data-group-id="4469785682-2">{</span><span class="o">?</span><span class="n">THRESHOLD</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">ok</span><span class="p" data-group-id="4469785682-2">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span></code></pre><h2 id="the-match-operator" class="section-heading"><a href="#the-match-operator" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">The Match Operator</span></h2><p>The following matches <code class="inline">Pattern</code> against <code class="inline">Expr</code>:</p><pre><code class="makeup erlang" translate="no"><span class="n">Pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Expr</span></code></pre><p>If the matching succeeds, any unbound variable in the pattern becomes bound and
the value of <code class="inline">Expr</code> is returned.</p><p>If multiple match operators are applied in sequence, they will be evaluated from
right to left.</p><p>If the matching fails, a <code class="inline">badmatch</code> run-time error occurs.</p><p><em>Examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="2568541510-1">{</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p" data-group-id="2568541510-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="2568541510-2">{</span><span class="ss">answer</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p" data-group-id="2568541510-2">}</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2568541510-3">{</span><span class="ss">answer</span><span class="p">,</span><span class="mi">42</span><span class="p" data-group-id="2568541510-3">}</span><span class="gp unselectable">
2&gt; </span><span class="n">A</span><span class="p">.</span><span class="w">
</span><span class="ss">answer</span><span class="gp unselectable">
3&gt; </span><span class="n">B</span><span class="p">.</span><span class="w">
</span><span class="mi">42</span><span class="gp unselectable">
4&gt; </span><span class="n">T</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2568541510-4">{</span><span class="ss">answer</span><span class="p">,</span><span class="mi">42</span><span class="p" data-group-id="2568541510-4">}</span><span class="gp unselectable">
5&gt; </span><span class="p" data-group-id="2568541510-5">{</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p" data-group-id="2568541510-5">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="2568541510-6">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="2568541510-6">]</span><span class="p">.</span><span class="w">
</span><span class="gt">** exception error: no match of right-hand side value [1,2]</span></code></pre><p>Because multiple match operators are evaluated from right to left, it means
that:</p><pre><code class="makeup erlang" translate="no"><span class="n">Pattern1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pattern2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PatternN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Expression</span></code></pre><p>is equivalent to:</p><pre><code class="makeup erlang" translate="no"><span class="n">Temporary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Expression</span><span class="p">,</span><span class="w">
</span><span class="n">PatternN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Temporary</span><span class="p">,</span><span class="w">
   </span><span class="p">.</span><span class="w">
   </span><span class="p">.</span><span class="w">
   </span><span class="p">.</span><span class="p">,</span><span class="w">
</span><span class="n">Pattern2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Temporary</span><span class="p">,</span><span class="w">
</span><span class="n">Pattern</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Temporary</span></code></pre><h2 id="the-match-operator-and-the-compound-pattern-operator" class="section-heading"><a href="#the-match-operator-and-the-compound-pattern-operator" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">The Match Operator and the Compound Pattern Operator</span></h2><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>This is an advanced section, which references to topics not yet introduced. It
can safely be skipped on a first reading.</p></section><p>The <code class="inline">=</code> character is used to denote two similar but distinct operators: the
match operator and the compound pattern operator. Which one is meant is
determined by context.</p><p>The <em>compound pattern operator</em> is used to construct a compound pattern from two
patterns. Compound patterns are accepted everywhere a pattern is accepted. A
compound pattern matches if all of its constituent patterns match. It is not
legal for a pattern that is part of a compound pattern to use variables (as keys
in map patterns or sizes in binary patterns) bound in other sub patterns of the
same compound pattern.</p><p><em>Examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="nf">fun</span><span class="p" data-group-id="9225019002-1">(</span><span class="p" data-group-id="9225019002-2">#{</span><span class="n">Key</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Value</span><span class="p" data-group-id="9225019002-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9225019002-3">#{</span><span class="ss">key</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Key</span><span class="p" data-group-id="9225019002-3">}</span><span class="p" data-group-id="9225019002-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="k">end</span><span class="p">.</span><span class="w">
</span><span class="gt">* 1:7: variable &#39;Key&#39; is unbound</span><span class="gp unselectable">
2&gt; </span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">fun</span><span class="p" data-group-id="9225019002-4">(</span><span class="p" data-group-id="9225019002-5">{</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p" data-group-id="9225019002-5">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">E</span><span class="p" data-group-id="9225019002-4">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="9225019002-6">{</span><span class="n">E</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p" data-group-id="9225019002-6">}</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p" data-group-id="9225019002-7">(</span><span class="p" data-group-id="9225019002-8">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="9225019002-8">}</span><span class="p" data-group-id="9225019002-7">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9225019002-9">{</span><span class="p" data-group-id="9225019002-10">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="9225019002-10">}</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="9225019002-9">}</span><span class="gp unselectable">
3&gt; </span><span class="n">G</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">fun</span><span class="p" data-group-id="9225019002-11">(</span><span class="p" data-group-id="9225019002-12">&lt;&lt;</span><span class="n">A</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="n">B</span><span class="p">:</span><span class="mi">8</span><span class="p" data-group-id="9225019002-12">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9225019002-13">&lt;&lt;</span><span class="n">C</span><span class="p">:</span><span class="mi">16</span><span class="p" data-group-id="9225019002-13">&gt;&gt;</span><span class="p" data-group-id="9225019002-11">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="9225019002-14">{</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p" data-group-id="9225019002-14">}</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="n">G</span><span class="p" data-group-id="9225019002-15">(</span><span class="p" data-group-id="9225019002-16">&lt;&lt;</span><span class="mi">42</span><span class="p">,</span><span class="mi">43</span><span class="p" data-group-id="9225019002-16">&gt;&gt;</span><span class="p" data-group-id="9225019002-15">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9225019002-17">{</span><span class="mi">42</span><span class="p">,</span><span class="mi">43</span><span class="p">,</span><span class="mi">10795</span><span class="p" data-group-id="9225019002-17">}</span></code></pre><p>The <em>match operator</em> is allowed everywhere an expression is allowed. It is used
to match the value of an expression to a pattern. If multiple match operators
are applied in sequence, they will be evaluated from right to left.</p><p><em>Examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8664853090-1">#{</span><span class="ss">key</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">key2</span><span class="p">,</span><span class="w"> </span><span class="ss">key2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">value</span><span class="p" data-group-id="8664853090-1">}</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8664853090-2">#{</span><span class="ss">key</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">key2</span><span class="p">,</span><span class="ss">key2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">value</span><span class="p" data-group-id="8664853090-2">}</span><span class="gp unselectable">
2&gt; </span><span class="nf">f</span><span class="p" data-group-id="8664853090-3">(</span><span class="n">Key</span><span class="p" data-group-id="8664853090-3">)</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8664853090-4">#{</span><span class="n">Key</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Value</span><span class="p" data-group-id="8664853090-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8664853090-5">#{</span><span class="ss">key</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Key</span><span class="p" data-group-id="8664853090-5">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="p">.</span><span class="w">
</span><span class="ss">value</span><span class="gp unselectable">
3&gt; </span><span class="nf">f</span><span class="p" data-group-id="8664853090-6">(</span><span class="n">Key</span><span class="p" data-group-id="8664853090-6">)</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8664853090-7">#{</span><span class="n">Key</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Value</span><span class="p" data-group-id="8664853090-7">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8664853090-8">(</span><span class="p" data-group-id="8664853090-9">#{</span><span class="ss">key</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Key</span><span class="p" data-group-id="8664853090-9">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p" data-group-id="8664853090-8">)</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="p">.</span><span class="w">
</span><span class="ss">value</span><span class="gp unselectable">
4&gt; </span><span class="nf">f</span><span class="p" data-group-id="8664853090-10">(</span><span class="n">Key</span><span class="p" data-group-id="8664853090-10">)</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8664853090-11">(</span><span class="p" data-group-id="8664853090-12">#{</span><span class="n">Key</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Value</span><span class="p" data-group-id="8664853090-12">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8664853090-13">#{</span><span class="ss">key</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Key</span><span class="p" data-group-id="8664853090-13">}</span><span class="p" data-group-id="8664853090-11">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="p">.</span><span class="w">
</span><span class="gt">* 1:12: variable &#39;Key&#39; is unbound</span><span class="gp unselectable">
5&gt; </span><span class="p" data-group-id="8664853090-14">&lt;&lt;</span><span class="n">X</span><span class="p">:</span><span class="n">Y</span><span class="p" data-group-id="8664853090-14">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">begin</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8664853090-15">&lt;&lt;</span><span class="mi">42</span><span class="p">:</span><span class="mi">8</span><span class="p" data-group-id="8664853090-15">&gt;&gt;</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">.</span><span class="w">
</span><span class="mi">42</span></code></pre><p>The expression at prompt <code class="inline">2&gt;</code> first matches the value of variable <code class="inline">M</code> against
pattern <code class="inline">#{key := Key}</code>, binding variable <code class="inline">Key</code>. It then matches the value of
<code class="inline">M</code> against pattern <code class="inline">#{Key := Value}</code> using variable <code class="inline">Key</code> as the key, binding
variable <code class="inline">Value</code>.</p><p>The expression at prompt <code class="inline">3&gt;</code> matches expression <code class="inline">(#{key := Key} = M)</code> against
pattern <code class="inline">#{Key := Value}</code>. The expression inside the parentheses is evaluated
first. That is, <code class="inline">M</code> is matched against <code class="inline">#{key := Key}</code>, and then the value of
<code class="inline">M</code> is matched against pattern <code class="inline">#{Key := Value}</code>. That is the same evaluation
order as in <em>2</em>; therefore, the parentheses are redundant.</p><p>In the expression at prompt <code class="inline">4&gt;</code> the expression <code class="inline">M</code> is matched against a pattern
inside parentheses. Since the construct inside the parentheses is a pattern, the
<code class="inline">=</code> that separates the two patterns is the compound pattern operator (<em>not</em> the
match operator). The match fails because the two sub patterns are matched at the
same time, and the variable <code class="inline">Key</code> is therefore not bound when matching against
pattern <code class="inline">#{Key := Value}</code>.</p><p>In the expression at prompt <code class="inline">5&gt;</code> the expressions inside the
<a href="expressions.html#block-expressions">block expression</a> are evaluated first,
binding variable <code class="inline">Y</code> and creating a binary. The binary is then matched against
pattern <code class="inline">&lt;&lt;X:Y&gt;&gt;</code> using the value of <code class="inline">Y</code> as the size of the segment.</p><h2 id="function-calls" class="section-heading"><a href="#function-calls" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Function Calls</span></h2><pre><code class="makeup erlang" translate="no"><span class="n">ExprF</span><span class="p" data-group-id="0033781095-1">(</span><span class="n">Expr1</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="n">ExprN</span><span class="p" data-group-id="0033781095-1">)</span><span class="w">
</span><span class="n">ExprM</span><span class="p">:</span><span class="n">ExprF</span><span class="p" data-group-id="0033781095-2">(</span><span class="n">Expr1</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="n">ExprN</span><span class="p" data-group-id="0033781095-2">)</span></code></pre><p>In the first form of function calls, <code class="inline">ExprM:ExprF(Expr1,...,ExprN)</code>, each of
<code class="inline">ExprM</code> and <code class="inline">ExprF</code> must be an atom or an expression that evaluates to an atom.
The function is said to be called by using the <em>fully qualified function name</em>.
This is often referred to as a <em>remote</em> or <em>external function call</em>.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="nc">lists</span><span class="p">:</span><span class="nf">keyfind</span><span class="p" data-group-id="7030547320-1">(</span><span class="n">Name</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="p" data-group-id="7030547320-1">)</span></code></pre><p>In the second form of function calls, <code class="inline">ExprF(Expr1,...,ExprN)</code>, <code class="inline">ExprF</code> must be
an atom or evaluate to a fun.</p><p>If <code class="inline">ExprF</code> is an atom, the function is said to be called by using the
<em>implicitly qualified function name</em>. If the function <code class="inline">ExprF</code> is locally
defined, it is called. Alternatively, if <code class="inline">ExprF</code> is explicitly imported from the
<code class="inline">M</code> module, <code class="inline">M:ExprF(Expr1,...,ExprN)</code> is called. If <code class="inline">ExprF</code> is neither declared
locally nor explicitly imported, <code class="inline">ExprF</code> must be the name of an automatically
imported BIF.</p><p><em>Examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="nf">handle</span><span class="p" data-group-id="8652059924-1">(</span><span class="n">Msg</span><span class="p">,</span><span class="w"> </span><span class="n">State</span><span class="p" data-group-id="8652059924-1">)</span><span class="w">
</span><span class="nf">spawn</span><span class="p" data-group-id="8652059924-2">(</span><span class="ss">m</span><span class="p">,</span><span class="w"> </span><span class="ss">init</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8652059924-3">[</span><span class="p" data-group-id="8652059924-3">]</span><span class="p" data-group-id="8652059924-2">)</span></code></pre><p><em>Examples</em> where <code class="inline">ExprF</code> is a fun:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="n">Fun1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">fun</span><span class="p" data-group-id="8584826703-1">(</span><span class="n">X</span><span class="p" data-group-id="8584826703-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">X</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="k">end</span><span class="p">,</span><span class="w">
</span><span class="n">Fun1</span><span class="p" data-group-id="8584826703-2">(</span><span class="mi">3</span><span class="p" data-group-id="8584826703-2">)</span><span class="p">.</span><span class="w">
</span><span class="mi">4</span><span class="gp unselectable">
2&gt; </span><span class="k">fun</span><span class="w"> </span><span class="nc">lists</span><span class="p">:</span><span class="ss">append</span><span class="p">/</span><span class="mi">2</span><span class="p" data-group-id="8584826703-3">(</span><span class="p" data-group-id="8584826703-4">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="8584826703-4">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8584826703-5">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="8584826703-5">]</span><span class="p" data-group-id="8584826703-3">)</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8584826703-6">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="8584826703-6">]</span><span class="w">
</span><span class="mi">3</span><span class="o">&gt;</span></code></pre><p>Notice that when calling a local function, there is a difference between using
the implicitly or fully qualified function name. The latter always refers to the
latest version of the module. See
<a href="code_loading.html">Compilation and Code Loading </a>and
<a href="ref_man_functions.html#eval">Function Evaluation</a>.</p><h3 id="local-function-names-clashing-with-auto-imported-bifs" class="section-heading"><a href="#local-function-names-clashing-with-auto-imported-bifs" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Local Function Names Clashing With Auto-Imported BIFs</span></h3><p>If a local function has the same name as an auto-imported BIF, the semantics is
that implicitly qualified function calls are directed to the locally defined
function, not to the BIF. To avoid confusion, there is a compiler directive
available, <code class="inline">-compile({no_auto_import,[F/A]})</code>, that makes a BIF not being
auto-imported. In certain situations, such a compile-directive is mandatory.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>Before Erlang/OTP R14A (ERTS version 5.8), an implicitly qualified function call to a
function having the same name as an auto-imported BIF always resulted in the
BIF being called. In newer versions of the compiler, the local function is
called instead. This is to avoid that future additions to the set of
auto-imported BIFs do not silently change the behavior of old code.</p></section><p>However, to avoid that old (pre R14) code changed its behavior when compiled
with Erlang/OTP version R14A or later, the following restriction applies: If you
override the name of a BIF that was auto-imported in OTP versions prior to R14A
(ERTS version 5.8) and have an implicitly qualified call to that function in
your code, you either need to explicitly remove the auto-import using a compiler
directive, or replace the call with a fully qualified function call. Otherwise
you get a compilation error. See the following example:</p><pre><code class="makeup erlang" translate="no"><span class="p">-</span><span class="na">export</span><span class="p" data-group-id="3191333876-1">(</span><span class="p" data-group-id="3191333876-2">[</span><span class="nb">length</span><span class="p">/</span><span class="mi">1</span><span class="p">,</span><span class="ss">f</span><span class="p">/</span><span class="mi">1</span><span class="p" data-group-id="3191333876-2">]</span><span class="p" data-group-id="3191333876-1">)</span><span class="p">.</span><span class="w">
</span><span class="w">
</span><span class="p">-</span><span class="na">compile</span><span class="p" data-group-id="3191333876-3">(</span><span class="p" data-group-id="3191333876-4">{</span><span class="ss">no_auto_import</span><span class="p">,</span><span class="p" data-group-id="3191333876-5">[</span><span class="nb">length</span><span class="p">/</span><span class="mi">1</span><span class="p" data-group-id="3191333876-5">]</span><span class="p" data-group-id="3191333876-4">}</span><span class="p" data-group-id="3191333876-3">)</span><span class="p">.</span><span class="w"> </span><span class="c1">% erlang:length/1 no longer autoimported</span><span class="w">

</span><span class="nf">length</span><span class="p" data-group-id="3191333876-6">(</span><span class="p" data-group-id="3191333876-7">[</span><span class="p" data-group-id="3191333876-7">]</span><span class="p" data-group-id="3191333876-6">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="nf">length</span><span class="p" data-group-id="3191333876-8">(</span><span class="p" data-group-id="3191333876-9">[</span><span class="n">H</span><span class="p">|</span><span class="n">T</span><span class="p" data-group-id="3191333876-9">]</span><span class="p" data-group-id="3191333876-8">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">length</span><span class="p" data-group-id="3191333876-10">(</span><span class="n">T</span><span class="p" data-group-id="3191333876-10">)</span><span class="p">.</span><span class="w"> </span><span class="c1">%% Calls the local function length/1</span><span class="w">

</span><span class="nf">f</span><span class="p" data-group-id="3191333876-11">(</span><span class="n">X</span><span class="p" data-group-id="3191333876-11">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nc">erlang</span><span class="p">:</span><span class="nf">length</span><span class="p" data-group-id="3191333876-12">(</span><span class="n">X</span><span class="p" data-group-id="3191333876-12">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="c1">%% Calls erlang:length/1,</span><span class="w">
                                  </span><span class="c1">%% which is allowed in guards</span><span class="w">
    </span><span class="ss">long</span><span class="p">.</span></code></pre><p>The same logic applies to explicitly imported functions from other modules, as
to locally defined functions. It is not allowed to both import a function from
another module and have the function declared in the module at the same time:</p><pre><code class="makeup erlang" translate="no"><span class="p">-</span><span class="na">export</span><span class="p" data-group-id="8929591432-1">(</span><span class="p" data-group-id="8929591432-2">[</span><span class="ss">f</span><span class="p">/</span><span class="mi">1</span><span class="p" data-group-id="8929591432-2">]</span><span class="p" data-group-id="8929591432-1">)</span><span class="p">.</span><span class="w">
</span><span class="w">
</span><span class="p">-</span><span class="na">compile</span><span class="p" data-group-id="8929591432-3">(</span><span class="p" data-group-id="8929591432-4">{</span><span class="ss">no_auto_import</span><span class="p">,</span><span class="p" data-group-id="8929591432-5">[</span><span class="nb">length</span><span class="p">/</span><span class="mi">1</span><span class="p" data-group-id="8929591432-5">]</span><span class="p" data-group-id="8929591432-4">}</span><span class="p" data-group-id="8929591432-3">)</span><span class="p">.</span><span class="w"> </span><span class="c1">% erlang:length/1 no longer autoimported</span><span class="w">
</span><span class="w">
</span><span class="p">-</span><span class="na">import</span><span class="p" data-group-id="8929591432-6">(</span><span class="ss">mod</span><span class="p">,</span><span class="p" data-group-id="8929591432-7">[</span><span class="nb">length</span><span class="p">/</span><span class="mi">1</span><span class="p" data-group-id="8929591432-7">]</span><span class="p" data-group-id="8929591432-6">)</span><span class="p">.</span><span class="w">

</span><span class="nf">f</span><span class="p" data-group-id="8929591432-8">(</span><span class="n">X</span><span class="p" data-group-id="8929591432-8">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="nc">erlang</span><span class="p">:</span><span class="nf">length</span><span class="p" data-group-id="8929591432-9">(</span><span class="n">X</span><span class="p" data-group-id="8929591432-9">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">33</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="c1">%% Calls erlang:length/1,</span><span class="w">
                                   </span><span class="c1">%% which is allowed in guards</span><span class="w">

    </span><span class="nc">erlang</span><span class="p">:</span><span class="nf">length</span><span class="p" data-group-id="8929591432-10">(</span><span class="n">X</span><span class="p" data-group-id="8929591432-10">)</span><span class="p">;</span><span class="w">              </span><span class="c1">%% Explicit call to erlang:length in body</span><span class="w">

</span><span class="nf">f</span><span class="p" data-group-id="8929591432-11">(</span><span class="n">X</span><span class="p" data-group-id="8929591432-11">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nf">length</span><span class="p" data-group-id="8929591432-12">(</span><span class="n">X</span><span class="p" data-group-id="8929591432-12">)</span><span class="p">.</span><span class="w">                     </span><span class="c1">%% mod:length/1 is called</span></code></pre><p>For auto-imported BIFs added in Erlang/OTP R14A and thereafter, overriding the
name with a local function or explicit import is always allowed. However, if the
<code class="inline">-compile({no_auto_import,[F/A])</code> directive is not used, the compiler issues a
warning whenever the function is called in the module using the implicitly
qualified function name.</p><h2 id="if" class="section-heading"><a href="#if" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">If</span></h2><pre><code class="makeup erlang" translate="no"><span class="k">if</span><span class="w">
    </span><span class="n">GuardSeq1</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">Body1</span><span class="p">;</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">;</span><span class="w">
    </span><span class="n">GuardSeqN</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">BodyN</span><span class="w">
</span><span class="k">end</span></code></pre><p>The branches of an <code class="inline">if</code>-expression are scanned sequentially until a guard
sequence <code class="inline">GuardSeq</code> that evaluates to true is found. Then the corresponding
<code class="inline">Body</code> (a sequence of expressions separated by <code class="inline">,</code>) is evaluated.</p><p>The return value of <code class="inline">Body</code> is the return value of the <code class="inline">if</code> expression.</p><p>If no guard sequence is evaluated as true, an <code class="inline">if_clause</code> run-time error occurs.
If necessary, the guard expression <code class="inline">true</code> can be used in the last branch, as
that guard sequence is always true.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="nf">is_greater_than</span><span class="p" data-group-id="1787517173-1">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p" data-group-id="1787517173-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="k">if</span><span class="w">
        </span><span class="n">X</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
            </span><span class="ss">true</span><span class="p">;</span><span class="w">
        </span><span class="ss">true</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="c1">% works as an &#39;else&#39; branch</span><span class="w">
            </span><span class="ss">false</span><span class="w">
    </span><span class="k">end</span></code></pre><h2 id="case" class="section-heading"><a href="#case" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Case</span></h2><pre><code class="makeup erlang" translate="no"><span class="k">case</span><span class="w"> </span><span class="n">Expr</span><span class="w"> </span><span class="k">of</span><span class="w">
    </span><span class="n">Pattern1</span><span class="w"> </span><span class="p" data-group-id="4028745803-1">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeq1</span><span class="p" data-group-id="4028745803-1">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">Body1</span><span class="p">;</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">;</span><span class="w">
    </span><span class="n">PatternN</span><span class="w"> </span><span class="p" data-group-id="4028745803-2">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeqN</span><span class="p" data-group-id="4028745803-2">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">BodyN</span><span class="w">
</span><span class="k">end</span></code></pre><p>The expression <code class="inline">Expr</code> is evaluated and the patterns <code class="inline">Pattern</code> are sequentially
matched against the result. If a match succeeds and the optional guard sequence
<code class="inline">GuardSeq</code> is true, the corresponding <code class="inline">Body</code> is evaluated.</p><p>The return value of <code class="inline">Body</code> is the return value of the <code class="inline">case</code> expression.</p><p>If there is no matching pattern with a true guard sequence, a <code class="inline">case_clause</code>
run-time error occurs.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="nf">is_valid_signal</span><span class="p" data-group-id="8636956330-1">(</span><span class="n">Signal</span><span class="p" data-group-id="8636956330-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="n">Signal</span><span class="w"> </span><span class="k">of</span><span class="w">
        </span><span class="p" data-group-id="8636956330-2">{</span><span class="ss">signal</span><span class="p">,</span><span class="w"> </span><span class="p">_</span><span class="n">What</span><span class="p">,</span><span class="w"> </span><span class="p">_</span><span class="n">From</span><span class="p">,</span><span class="w"> </span><span class="p">_</span><span class="n">To</span><span class="p" data-group-id="8636956330-2">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
            </span><span class="ss">true</span><span class="p">;</span><span class="w">
        </span><span class="p" data-group-id="8636956330-3">{</span><span class="ss">signal</span><span class="p">,</span><span class="w"> </span><span class="p">_</span><span class="n">What</span><span class="p">,</span><span class="w"> </span><span class="p">_</span><span class="n">To</span><span class="p" data-group-id="8636956330-3">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
            </span><span class="ss">true</span><span class="p">;</span><span class="w">
        </span><span class="p">_</span><span class="n">Else</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
            </span><span class="ss">false</span><span class="w">
    </span><span class="k">end</span><span class="p">.</span></code></pre><h2 id="maybe" class="section-heading"><a href="#maybe" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Maybe</span></h2><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>The <code class="inline">maybe</code> <a href="../system/features.html#features">feature</a> was introduced
in Erlang/OTP 25. Starting from Erlang/OTP 27 is is enabled by default.</p></section><pre><code class="makeup erlang" translate="no"><span class="k">maybe</span><span class="w">
    </span><span class="n">Expr1</span><span class="p">,</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w">
    </span><span class="n">ExprN</span><span class="w">
</span><span class="k">end</span></code></pre><p>The expressions in a <code class="inline">maybe</code> block are evaluated sequentially. If all
expressions are evaluated successfully, the return value of the <code class="inline">maybe</code> block is
<code class="inline">ExprN</code>. However, execution can be short-circuited by a conditional match
expression:</p><pre><code class="makeup erlang" translate="no"><span class="n">Expr1</span><span class="w"> </span><span class="o">?</span><span class="o">=</span><span class="w"> </span><span class="n">Expr2</span></code></pre><p><code class="inline">?=</code> is called the conditional match operator. It is only allowed to be used at
the top-level of a <code class="inline">maybe</code> block. It matches the pattern <code class="inline">Expr1</code> against
<code class="inline">Expr2</code>. If the matching succeeds, any unbound variable in the pattern becomes
bound. If the expression is the last expression in the <code class="inline">maybe</code> block, it also
returns the value of <code class="inline">Expr2</code>. If the matching is unsuccessful, the rest of the
expressions in the <code class="inline">maybe</code> block are skipped and the return value of the <code class="inline">maybe</code>
block is <code class="inline">Expr2</code>.</p><p>None of the variables bound in a <code class="inline">maybe</code> block must be used in the code that
follows the block.</p><p>Here is an example:</p><pre><code class="makeup erlang" translate="no"><span class="k">maybe</span><span class="w">
    </span><span class="p" data-group-id="9564555400-1">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p" data-group-id="9564555400-1">}</span><span class="w"> </span><span class="o">?</span><span class="o">=</span><span class="w"> </span><span class="nf">a</span><span class="p" data-group-id="9564555400-2">(</span><span class="p" data-group-id="9564555400-2">)</span><span class="p">,</span><span class="w">
    </span><span class="ss">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="9564555400-3">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p" data-group-id="9564555400-3">}</span><span class="w"> </span><span class="o">?</span><span class="o">=</span><span class="w"> </span><span class="nf">b</span><span class="p" data-group-id="9564555400-4">(</span><span class="p" data-group-id="9564555400-4">)</span><span class="p">,</span><span class="w">
    </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="w">
</span><span class="k">end</span></code></pre><p>Let us first assume that <code class="inline">a()</code> returns <code class="inline">{ok,42}</code> and <code class="inline">b()</code> returns <code class="inline">{ok,58}</code>.
With those return values, all of the match operators will succeed, and the
return value of the <code class="inline">maybe</code> block is <code class="inline">A + B</code>, which is equal to <code class="inline">42 + 58 = 100</code>.</p><p>Now let us assume that <code class="inline">a()</code> returns <code class="inline">error</code>. The conditional match operator in
<code class="inline">{ok, A} ?= a()</code> fails to match, and the return value of the <code class="inline">maybe</code> block is
the value of the expression that failed to match, namely <code class="inline">error</code>. Similarly, if
<code class="inline">b()</code> returns <code class="inline">wrong</code>, the return value of the <code class="inline">maybe</code> block is <code class="inline">wrong</code>.</p><p>Finally, let us assume that <code class="inline">a()</code> returns <code class="inline">{ok,-1}</code>. Because <code class="inline">true = A &gt;= 0</code> uses
the match operator <code class="inline">=</code>, a <code class="inline">{badmatch,false}</code> run-time error occurs when the
expression fails to match the pattern.</p><p>The example can be written in a less succinct way using nested case expressions:</p><pre><code class="makeup erlang" translate="no"><span class="k">case</span><span class="w"> </span><span class="nf">a</span><span class="p" data-group-id="6246894689-1">(</span><span class="p" data-group-id="6246894689-1">)</span><span class="w"> </span><span class="k">of</span><span class="w">
    </span><span class="p" data-group-id="6246894689-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p" data-group-id="6246894689-2">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="ss">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
        </span><span class="k">case</span><span class="w"> </span><span class="nf">b</span><span class="p" data-group-id="6246894689-3">(</span><span class="p" data-group-id="6246894689-3">)</span><span class="w"> </span><span class="k">of</span><span class="w">
            </span><span class="p" data-group-id="6246894689-4">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p" data-group-id="6246894689-4">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">;</span><span class="w">
            </span><span class="n">Other1</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
                </span><span class="n">Other1</span><span class="w">
        </span><span class="k">end</span><span class="p">;</span><span class="w">
    </span><span class="n">Other2</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">Other2</span><span class="w">
</span><span class="k">end</span></code></pre><p>The <code class="inline">maybe</code> block can be augmented with <code class="inline">else</code> clauses:</p><pre><code class="makeup erlang" translate="no"><span class="k">maybe</span><span class="w">
    </span><span class="n">Expr1</span><span class="p">,</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w">
    </span><span class="n">ExprN</span><span class="w">
</span><span class="k">else</span><span class="w">
    </span><span class="n">Pattern1</span><span class="w"> </span><span class="p" data-group-id="6617140723-1">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeq1</span><span class="p" data-group-id="6617140723-1">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">Body1</span><span class="p">;</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">;</span><span class="w">
    </span><span class="n">PatternN</span><span class="w"> </span><span class="p" data-group-id="6617140723-2">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeqN</span><span class="p" data-group-id="6617140723-2">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">BodyN</span><span class="w">
</span><span class="k">end</span></code></pre><p>If a conditional match operator fails, the failed expression is matched against
the patterns in all clauses between the <code class="inline">else</code> and <code class="inline">end</code> keywords. If a match
succeeds and the optional guard sequence <code class="inline">GuardSeq</code> is true, the corresponding
<code class="inline">Body</code> is evaluated. The value returned from the body is the return value of the
<code class="inline">maybe</code> block.</p><p>If there is no matching pattern with a true guard sequence, an <code class="inline">else_clause</code>
run-time error occurs.</p><p>None of the variables bound in a <code class="inline">maybe</code> block must be used in the <code class="inline">else</code>
clauses. None of the variables bound in the <code class="inline">else</code> clauses must be used in the
code that follows the <code class="inline">maybe</code> block.</p><p>Here is the previous example augmented with <code class="inline">else</code> clauses:</p><pre><code class="makeup erlang" translate="no"><span class="k">maybe</span><span class="w">
    </span><span class="p" data-group-id="3211980831-1">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p" data-group-id="3211980831-1">}</span><span class="w"> </span><span class="o">?</span><span class="o">=</span><span class="w"> </span><span class="nf">a</span><span class="p" data-group-id="3211980831-2">(</span><span class="p" data-group-id="3211980831-2">)</span><span class="p">,</span><span class="w">
    </span><span class="ss">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="3211980831-3">{</span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p" data-group-id="3211980831-3">}</span><span class="w"> </span><span class="o">?</span><span class="o">=</span><span class="w"> </span><span class="nf">b</span><span class="p" data-group-id="3211980831-4">(</span><span class="p" data-group-id="3211980831-4">)</span><span class="p">,</span><span class="w">
    </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="w">
</span><span class="k">else</span><span class="w">
    </span><span class="ss">error</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="ss">error</span><span class="p">;</span><span class="w">
    </span><span class="ss">wrong</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="ss">error</span><span class="w">
</span><span class="k">end</span></code></pre><p>The <code class="inline">else</code> clauses translate the failing value from the conditional match
operators to the value <code class="inline">error</code>. If the failing value is not one of the
recognized values, a <code class="inline">else_clause</code> run-time error occurs.</p><h2 id="send" class="section-heading"><a href="#send" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Send</span></h2><pre><code class="makeup erlang" translate="no"><span class="n">Expr1</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">Expr2</span></code></pre><p>Sends the value of <code class="inline">Expr2</code> as a message to the process specified by <code class="inline">Expr1</code>. The
value of <code class="inline">Expr2</code> is also the return value of the expression.</p><p><code class="inline">Expr1</code> must evaluate to a pid, an alias (reference), a port, a registered name
(atom), or a tuple <code class="inline">{Name,Node}</code>. <code class="inline">Name</code> is an atom and <code class="inline">Node</code> is a node name,
also an atom.</p><ul><li>If <code class="inline">Expr1</code> evaluates to a name, but this name is not registered, a <code class="inline">badarg</code>
run-time error occurs.</li><li>Sending a message to a reference never fails, even if the reference is no
longer (or never was) an alias.</li><li>Sending a message to a pid never fails, even if the pid identifies a
non-existing process.</li><li>Distributed message sending, that is, if <code class="inline">Expr1</code> evaluates to a tuple
<code class="inline">{Name,Node}</code> (or a pid located at another node), also never fails.</li></ul><h2 id="receive" class="section-heading"><a href="#receive" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Receive</span></h2><pre><code class="makeup erlang" translate="no"><span class="k">receive</span><span class="w">
    </span><span class="n">Pattern1</span><span class="w"> </span><span class="p" data-group-id="7390427062-1">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeq1</span><span class="p" data-group-id="7390427062-1">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">Body1</span><span class="p">;</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">;</span><span class="w">
    </span><span class="n">PatternN</span><span class="w"> </span><span class="p" data-group-id="7390427062-2">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeqN</span><span class="p" data-group-id="7390427062-2">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">BodyN</span><span class="w">
</span><span class="k">end</span></code></pre><p>The <code class="inline">receive</code> expression searches for a message in the message queue that match
one of the patterns in the clauses of the <code class="inline">receive</code> expression. The patterns in
the clauses is matched against a message from top to bottom. The first message,
from the start of the message queue, that matches will be selected. Messages are
normally
<a href="ref_man_processes.html#message-queue-order">enqueued in the message queue</a> in
order they were received. However,
if <a href="ref_man_processes.html#enable-prio-msg-recv">reception of priority messages</a>
has been enabled by the receiving process, this is not always the case. When a
match succeeds and the optional guard sequence <code class="inline">GuardSeq</code> is true, the matching
message is fetched from the message queue and the corresponding <code class="inline">Body</code> is
evaluated. All other messages in the message queue remain unchanged.</p><p>The return value of <code class="inline">Body</code> is the return value of the <code class="inline">receive</code> expression.</p><p><code class="inline">receive</code> never fails. The execution is suspended, possibly indefinitely, until
a message arrives that matches one of the patterns and with a true guard
sequence.</p><p><a href="" id="selective-receive-warning"></a></p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>The time complexity of a <code class="inline">receive</code> expression is <code class="inline">O(N)</code> where <code class="inline">N</code> corresponds
to the amount of messages preceeding the matching message in the message queue.
That is, when the combination of patterns of a <code class="inline">receive</code> expression only match
specific messages and the message queue is huge, executing such a <code class="inline">receive</code>
expression might become very expensive.</p><p>One type of <code class="inline">receive</code> expressions matching on only specific patterns can,
however, be optimized by the compiler and runtime system. This in the scenario
where you create a <a href="../system/data_types.html#reference"><em>reference</em></a> and
match on it in all clauses of a <code class="inline">receive</code> expression <em>close</em> to where the
reference was created. In this case only the amount of messages received after
the reference was created needs to be inspected. For more information see the
<a href="../system/eff_guide_processes.html#fetching-received-messages"><em>Fetching Received Messages</em> section of the <em>Efficiency Guide</em></a>.</p></section><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="nf">wait_for_onhook</span><span class="p" data-group-id="6999009147-1">(</span><span class="p" data-group-id="6999009147-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="k">receive</span><span class="w">
        </span><span class="ss">onhook</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
            </span><span class="nf">disconnect</span><span class="p" data-group-id="6999009147-2">(</span><span class="p" data-group-id="6999009147-2">)</span><span class="p">,</span><span class="w">
            </span><span class="nf">idle</span><span class="p" data-group-id="6999009147-3">(</span><span class="p" data-group-id="6999009147-3">)</span><span class="p">;</span><span class="w">
        </span><span class="p" data-group-id="6999009147-4">{</span><span class="ss">connect</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p" data-group-id="6999009147-4">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
            </span><span class="n">B</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p" data-group-id="6999009147-5">{</span><span class="ss">busy</span><span class="p">,</span><span class="w"> </span><span class="nf">self</span><span class="p" data-group-id="6999009147-6">(</span><span class="p" data-group-id="6999009147-6">)</span><span class="p" data-group-id="6999009147-5">}</span><span class="p">,</span><span class="w">
            </span><span class="nf">wait_for_onhook</span><span class="p" data-group-id="6999009147-7">(</span><span class="p" data-group-id="6999009147-7">)</span><span class="w">
    </span><span class="k">end</span><span class="p">.</span></code></pre><p>The <code class="inline">receive</code> expression can be augmented with a timeout:</p><pre><code class="makeup erlang" translate="no"><span class="k">receive</span><span class="w">
    </span><span class="n">Pattern1</span><span class="w"> </span><span class="p" data-group-id="1064968486-1">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeq1</span><span class="p" data-group-id="1064968486-1">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">Body1</span><span class="p">;</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">;</span><span class="w">
    </span><span class="n">PatternN</span><span class="w"> </span><span class="p" data-group-id="1064968486-2">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeqN</span><span class="p" data-group-id="1064968486-2">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">BodyN</span><span class="w">
</span><span class="k">after</span><span class="w">
    </span><span class="n">ExprT</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">BodyT</span><span class="w">
</span><span class="k">end</span></code></pre><p><code class="inline">receive...after</code> works exactly as <code class="inline">receive</code>, except that if no matching message
has arrived within <code class="inline">ExprT</code> milliseconds, then <code class="inline">BodyT</code> is evaluated instead. The
return value of <code class="inline">BodyT</code> then becomes the return value of the <code class="inline">receive...after</code>
expression. <code class="inline">ExprT</code> is to evaluate to an integer, or the atom <code class="inline">infinity</code>. The
allowed integer range is from 0 to 4294967295, that is, the longest possible
timeout is almost 50 days. With a zero value the timeout occurs immediately if
there is no matching message in the message queue.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning">Warning</h4><p>It might seem like a <code class="inline">receive</code> expression with an <code class="inline">after 0</code> clause (or
another short timeout) might be cheap since the timeout is short. This is
<em>not</em> necessarily the case. If the patterns in the clauses of the <code class="inline">receive</code>
expression only match specific messages and no such messages exist in the
message queue, the whole message queue needs to be inspected before the
timeout can occur. That is, the same apply as in
<a href="#selective-receive-warning">the warning above</a>.</p></section><p>The atom <code class="inline">infinity</code> will make the process wait indefinitely for a matching
message. This is the same as not using a timeout. It can be useful for timeout
values that are calculated at runtime.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="nf">wait_for_onhook</span><span class="p" data-group-id="8655096073-1">(</span><span class="p" data-group-id="8655096073-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="k">receive</span><span class="w">
        </span><span class="ss">onhook</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
            </span><span class="nf">disconnect</span><span class="p" data-group-id="8655096073-2">(</span><span class="p" data-group-id="8655096073-2">)</span><span class="p">,</span><span class="w">
            </span><span class="nf">idle</span><span class="p" data-group-id="8655096073-3">(</span><span class="p" data-group-id="8655096073-3">)</span><span class="p">;</span><span class="w">
        </span><span class="p" data-group-id="8655096073-4">{</span><span class="ss">connect</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p" data-group-id="8655096073-4">}</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
            </span><span class="n">B</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p" data-group-id="8655096073-5">{</span><span class="ss">busy</span><span class="p">,</span><span class="w"> </span><span class="nf">self</span><span class="p" data-group-id="8655096073-6">(</span><span class="p" data-group-id="8655096073-6">)</span><span class="p" data-group-id="8655096073-5">}</span><span class="p">,</span><span class="w">
            </span><span class="nf">wait_for_onhook</span><span class="p" data-group-id="8655096073-7">(</span><span class="p" data-group-id="8655096073-7">)</span><span class="w">
    </span><span class="k">after</span><span class="w">
        </span><span class="mi">60000</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
            </span><span class="nf">disconnect</span><span class="p" data-group-id="8655096073-8">(</span><span class="p" data-group-id="8655096073-8">)</span><span class="p">,</span><span class="w">
            </span><span class="nf">error</span><span class="p" data-group-id="8655096073-9">(</span><span class="p" data-group-id="8655096073-9">)</span><span class="w">
    </span><span class="k">end</span><span class="p">.</span></code></pre><p>It is legal to use a <code class="inline">receive...after</code> expression with no branches:</p><pre><code class="makeup erlang" translate="no"><span class="k">receive</span><span class="w">
</span><span class="k">after</span><span class="w">
    </span><span class="n">ExprT</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">BodyT</span><span class="w">
</span><span class="k">end</span></code></pre><p>This construction does not consume any messages, only suspends execution in the
process for <code class="inline">ExprT</code> milliseconds. This can be used to implement simple timers.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="nf">timer</span><span class="p" data-group-id="1426216230-1">(</span><span class="p" data-group-id="1426216230-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nf">spawn</span><span class="p" data-group-id="1426216230-2">(</span><span class="ss">m</span><span class="p">,</span><span class="w"> </span><span class="ss">timer</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1426216230-3">[</span><span class="nf">self</span><span class="p" data-group-id="1426216230-4">(</span><span class="p" data-group-id="1426216230-4">)</span><span class="p" data-group-id="1426216230-3">]</span><span class="p" data-group-id="1426216230-2">)</span><span class="p">.</span><span class="w">

</span><span class="nf">timer</span><span class="p" data-group-id="1426216230-5">(</span><span class="n">Pid</span><span class="p" data-group-id="1426216230-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="k">receive</span><span class="w">
    </span><span class="k">after</span><span class="w">
        </span><span class="mi">5000</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
            </span><span class="n">Pid</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="ss">timeout</span><span class="w">
    </span><span class="k">end</span><span class="p">.</span></code></pre><p>For more information on timers in Erlang in general, see the
<a href="../apps/erts/time_correction.html#timers"><em>Timers</em></a> section of the
<a href="../apps/erts/time_correction.html"><em>Time and Time Correction in Erlang</em></a>
ERTS User's guide.</p><h2 id="term-comparisons" class="section-heading"><a href="#term-comparisons" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Term Comparisons</span></h2><pre><code class="makeup erlang" translate="no"><span class="n">Expr1</span><span class="w"> </span><span class="ss">op</span><span class="w"> </span><span class="n">Expr2</span></code></pre><table><thead><tr><th style="text-align: left;">op</th><th style="text-align: left;">Description</th></tr></thead><tbody><tr><td style="text-align: left;"><code class="inline">==</code></td><td style="text-align: left;">Equal to</td></tr><tr><td style="text-align: left;"><code class="inline">/=</code></td><td style="text-align: left;">Not equal to</td></tr><tr><td style="text-align: left;"><code class="inline">=&lt;</code></td><td style="text-align: left;">Less than or equal to</td></tr><tr><td style="text-align: left;"><code class="inline">&lt;</code></td><td style="text-align: left;">Less than</td></tr><tr><td style="text-align: left;"><code class="inline">&gt;=</code></td><td style="text-align: left;">Greater than or equal to</td></tr><tr><td style="text-align: left;"><code class="inline">&gt;</code></td><td style="text-align: left;">Greater than</td></tr><tr><td style="text-align: left;"><code class="inline">=:=</code></td><td style="text-align: left;">Term equivalence</td></tr><tr><td style="text-align: left;"><code class="inline">=/=</code></td><td style="text-align: left;">Term non-equivalence</td></tr></tbody></table><p><em>Table: Term Comparison Operators.</em></p><p>The arguments can be of different data types. The following order is defined:</p><pre><code class="text">number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; map &lt; nil &lt; list &lt; bit string</code></pre><p><code class="inline">nil</code> in the previous expression represents the empty list (<code class="inline">[]</code>), which is
regarded as a separate type from <a href="../apps/erts/erlang.html#t:list/0"><code class="inline">list/0</code></a>. That is why <code class="inline">nil &lt; list</code>.</p><p>Lists are compared element by element. Tuples are ordered by size, two tuples
with the same size are compared element by element.</p><p>Bit strings are compared bit by bit. If one bit string is a prefix of the other,
the shorter bit string is considered smaller.</p><p>Maps are ordered by size, two maps with the same size are compared by keys in
ascending term order and then by values in key order. In maps key order integers
types are considered less than floats types.</p><p>Atoms are compared using their string value, codepoint by codepoint.</p><p>When comparing an integer to a float, the term with the lesser precision is
converted into the type of the other term, unless the operator is one of <code class="inline">=:=</code>
or <code class="inline">=/=</code>. A float is more precise than an integer until all significant figures
of the float are to the left of the decimal point. This happens when the float
is larger/smaller than +/-9007199254740992.0. The conversion strategy is changed
depending on the size of the float because otherwise comparison of large floats
and integers would lose their transitivity.</p><p>The term equivalence operators, <code class="inline">=:=</code> and <code class="inline">=/=</code>, return whether two terms are
indistinguishable. While the other operators consider the same <em>numbers</em> equal
even when their types differ (<code class="inline">1 == 1.0</code> is true), the term equivalence
operators return whether or not there exists a way to tell the arguments apart.</p><p>For example, while the terms <code class="inline">0</code> and <code class="inline">0.0</code> represent the same <em>number</em>, we can
tell them apart by using the <a href="../apps/erts/erlang.html#is_integer/1"><code class="inline">is_integer/1</code></a> function. Hence,
<code class="inline">=:=</code> and <code class="inline">=/=</code> consider them different.</p><p>Furthermore, the terms <code class="inline">0.0</code> and <code class="inline">-0.0</code> also represent the same <em>number</em>, but
they yield different results when converted to string form through
<a href="../apps/erts/erlang.html#float_to_list/1"><code class="inline">float_to_list/1</code></a>: when given the former it returns a
string without a sign, and when given the latter it returns a string with a
sign. Therefore, <code class="inline">=:=</code> and <code class="inline">=/=</code> consider them different.</p><p>The term equivalence operators are useful when reasoning about terms as opaque
values, for example in associative containers or memoized functions where using
the equal-to operator (<code class="inline">==</code>) risks producing incorrect results as a consequence
of mixing up numbers of different types.</p><p>Term comparison operators return the Boolean value of the expression, <code class="inline">true</code> or
<code class="inline">false</code>.</p><p><em>Examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1.0</span><span class="p">.</span><span class="w">
</span><span class="ss">true</span><span class="gp unselectable">
2&gt; </span><span class="mi">1</span><span class="w"> </span><span class="o">=:=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">.</span><span class="w">
</span><span class="ss">false</span><span class="gp unselectable">
3&gt; </span><span class="mi">0</span><span class="w"> </span><span class="o">=:=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">.</span><span class="w">
</span><span class="ss">false</span><span class="gp unselectable">
4&gt; </span><span class="mf">0.0</span><span class="w"> </span><span class="o">=:=</span><span class="w"> </span><span class="o">-</span><span class="mf">0.0</span><span class="p">.</span><span class="w">
</span><span class="ss">false</span><span class="gp unselectable">
5&gt; </span><span class="mf">0.0</span><span class="w"> </span><span class="o">=:=</span><span class="w"> </span><span class="o">+</span><span class="mf">0.0</span><span class="p">.</span><span class="w">
</span><span class="ss">true</span><span class="gp unselectable">
6&gt; </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="ss">a</span><span class="p">.</span><span class="w">
</span><span class="ss">false</span><span class="gp unselectable">
7&gt; </span><span class="p" data-group-id="2767113741-1">#{</span><span class="ss">c</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="2767113741-1">}</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="2767113741-2">#{</span><span class="ss">a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="2767113741-2">}</span><span class="p">.</span><span class="w">
</span><span class="ss">false</span><span class="gp unselectable">
8&gt; </span><span class="p" data-group-id="2767113741-3">#{</span><span class="ss">a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="2767113741-3">}</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p" data-group-id="2767113741-4">#{</span><span class="ss">a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mf">2.0</span><span class="p" data-group-id="2767113741-4">}</span><span class="p">.</span><span class="w">
</span><span class="ss">true</span><span class="gp unselectable">
9&gt; </span><span class="p" data-group-id="2767113741-5">&lt;&lt;</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p" data-group-id="2767113741-5">&gt;&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p" data-group-id="2767113741-6">&lt;&lt;</span><span class="mi">128</span><span class="p" data-group-id="2767113741-6">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="ss">true</span><span class="gp unselectable">
10&gt; </span><span class="p" data-group-id="2767113741-7">&lt;&lt;</span><span class="mi">3</span><span class="p">:</span><span class="mi">2</span><span class="p" data-group-id="2767113741-7">&gt;&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p" data-group-id="2767113741-8">&lt;&lt;</span><span class="mi">128</span><span class="p" data-group-id="2767113741-8">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="ss">false</span></code></pre><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Prior to OTP 27, the term equivalence operators considered <code class="inline">0.0</code>
and <code class="inline">-0.0</code> to be the same term.</p><p>This was changed in OTP 27 but legacy code may have expected them to be
considered the same. To help users catch errors that may arise from an
upgrade, the compiler raises a warning when <code class="inline">0.0</code> is pattern-matched or used
in a term equivalence test.</p><p>If you need to match <code class="inline">0.0</code> specifically, the warning can be silenced by
writing <code class="inline">+0.0</code> instead, which produces the same term but makes the compiler
interpret the match as being done on purpose.</p></section><h2 id="arithmetic-expressions" class="section-heading"><a href="#arithmetic-expressions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Arithmetic Expressions</span></h2><pre><code class="makeup erlang" translate="no"><span class="ss">op</span><span class="w"> </span><span class="n">Expr</span><span class="w">
</span><span class="n">Expr1</span><span class="w"> </span><span class="ss">op</span><span class="w"> </span><span class="n">Expr2</span></code></pre><table><thead><tr><th style="text-align: left;">Operator</th><th style="text-align: left;">Description</th><th style="text-align: left;">Argument Type</th></tr></thead><tbody><tr><td style="text-align: left;"><code class="inline">+</code></td><td style="text-align: left;">Unary +</td><td style="text-align: left;">Number</td></tr><tr><td style="text-align: left;"><code class="inline">-</code></td><td style="text-align: left;">Negation (unary -)</td><td style="text-align: left;">Number</td></tr><tr><td style="text-align: left;"><code class="inline">+</code></td><td style="text-align: left;">Addition</td><td style="text-align: left;">Number</td></tr><tr><td style="text-align: left;"><code class="inline">-</code></td><td style="text-align: left;">Subtraction</td><td style="text-align: left;">Number</td></tr><tr><td style="text-align: left;"><code class="inline">*</code></td><td style="text-align: left;">Multiplication</td><td style="text-align: left;">Number</td></tr><tr><td style="text-align: left;"><code class="inline">/</code></td><td style="text-align: left;">Floating point division</td><td style="text-align: left;">Number</td></tr><tr><td style="text-align: left;"><code class="inline">bnot</code></td><td style="text-align: left;">Unary bitwise NOT</td><td style="text-align: left;">Integer</td></tr><tr><td style="text-align: left;"><code class="inline">div</code></td><td style="text-align: left;">Integer division</td><td style="text-align: left;">Integer</td></tr><tr><td style="text-align: left;"><code class="inline">rem</code></td><td style="text-align: left;">Integer remainder of X/Y</td><td style="text-align: left;">Integer</td></tr><tr><td style="text-align: left;"><code class="inline">band</code></td><td style="text-align: left;">Bitwise AND</td><td style="text-align: left;">Integer</td></tr><tr><td style="text-align: left;"><code class="inline">bor</code></td><td style="text-align: left;">Bitwise OR</td><td style="text-align: left;">Integer</td></tr><tr><td style="text-align: left;"><code class="inline">bxor</code></td><td style="text-align: left;">Bitwise XOR</td><td style="text-align: left;">Integer</td></tr><tr><td style="text-align: left;"><code class="inline">bsl</code></td><td style="text-align: left;">Bitshift left</td><td style="text-align: left;">Integer</td></tr><tr><td style="text-align: left;"><code class="inline">bsr</code></td><td style="text-align: left;">Arithmetic bitshift right</td><td style="text-align: left;">Integer</td></tr></tbody></table><p><em>Table: Arithmetic Operators.</em></p><p><em>Examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="o">+</span><span class="mi">1</span><span class="p">.</span><span class="w">
</span><span class="mi">1</span><span class="gp unselectable">
2&gt; </span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="w">
</span><span class="o">-</span><span class="mi">1</span><span class="gp unselectable">
3&gt; </span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">.</span><span class="w">
</span><span class="mi">2</span><span class="gp unselectable">
4&gt; </span><span class="mi">4</span><span class="o">/</span><span class="mi">2</span><span class="p">.</span><span class="w">
</span><span class="mf">2.0</span><span class="gp unselectable">
5&gt; </span><span class="mi">5</span><span class="w"> </span><span class="ow">div</span><span class="w"> </span><span class="mi">2</span><span class="p">.</span><span class="w">
</span><span class="mi">2</span><span class="gp unselectable">
6&gt; </span><span class="mi">5</span><span class="w"> </span><span class="ow">rem</span><span class="w"> </span><span class="mi">2</span><span class="p">.</span><span class="w">
</span><span class="mi">1</span><span class="gp unselectable">
7&gt; </span><span class="mi">2#10</span><span class="w"> </span><span class="ow">band</span><span class="w"> </span><span class="mi">2#01</span><span class="p">.</span><span class="w">
</span><span class="mi">0</span><span class="gp unselectable">
8&gt; </span><span class="mi">2#10</span><span class="w"> </span><span class="ow">bor</span><span class="w"> </span><span class="mi">2#01</span><span class="p">.</span><span class="w">
</span><span class="mi">3</span><span class="gp unselectable">
9&gt; </span><span class="ss">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">.</span><span class="w">
</span><span class="gt">** exception error: an error occurred when evaluating an arithmetic expression
     in operator  +/2
        called as a + 10</span><span class="gp unselectable">
10&gt; </span><span class="mi">1</span><span class="w"> </span><span class="nf">bsl</span><span class="w"> </span><span class="p" data-group-id="3801579382-1">(</span><span class="mi">1</span><span class="w"> </span><span class="ow">bsl</span><span class="w"> </span><span class="mi">64</span><span class="p" data-group-id="3801579382-1">)</span><span class="p">.</span><span class="w">
</span><span class="gt">** exception error: a system limit has been reached
     in operator  bsl/2
        called as 1 bsl 18446744073709551616</span></code></pre><h2 id="boolean-expressions" class="section-heading"><a href="#boolean-expressions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Boolean Expressions</span></h2><pre><code class="makeup erlang" translate="no"><span class="ss">op</span><span class="w"> </span><span class="n">Expr</span><span class="w">
</span><span class="n">Expr1</span><span class="w"> </span><span class="ss">op</span><span class="w"> </span><span class="n">Expr2</span></code></pre><table><thead><tr><th style="text-align: left;">Operator</th><th style="text-align: left;">Description</th></tr></thead><tbody><tr><td style="text-align: left;"><code class="inline">not</code></td><td style="text-align: left;">Unary logical NOT</td></tr><tr><td style="text-align: left;"><code class="inline">and</code></td><td style="text-align: left;">Logical AND</td></tr><tr><td style="text-align: left;"><code class="inline">or</code></td><td style="text-align: left;">Logical OR</td></tr><tr><td style="text-align: left;"><code class="inline">xor</code></td><td style="text-align: left;">Logical XOR</td></tr></tbody></table><p><em>Table: Logical Operators.</em></p><p><em>Examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="ow">not</span><span class="w"> </span><span class="ss">true</span><span class="p">.</span><span class="w">
</span><span class="ss">false</span><span class="gp unselectable">
2&gt; </span><span class="ss">true</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="ss">false</span><span class="p">.</span><span class="w">
</span><span class="ss">false</span><span class="gp unselectable">
3&gt; </span><span class="ss">true</span><span class="w"> </span><span class="ow">xor</span><span class="w"> </span><span class="ss">false</span><span class="p">.</span><span class="w">
</span><span class="ss">true</span><span class="gp unselectable">
4&gt; </span><span class="ss">true</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="ss">garbage</span><span class="p">.</span><span class="w">
</span><span class="gt">** exception error: bad argument
     in operator  or/2
        called as true or garbage</span></code></pre><h2 id="short-circuit-expressions" class="section-heading"><a href="#short-circuit-expressions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Short-Circuit Expressions</span></h2><pre><code class="makeup erlang" translate="no"><span class="n">Expr1</span><span class="w"> </span><span class="ow">orelse</span><span class="w"> </span><span class="n">Expr2</span><span class="w">
</span><span class="n">Expr1</span><span class="w"> </span><span class="ow">andalso</span><span class="w"> </span><span class="n">Expr2</span></code></pre><p><code class="inline">Expr2</code> is evaluated only if necessary. That is, <code class="inline">Expr2</code> is evaluated only if:</p><ul><li><code class="inline">Expr1</code> evaluates to <code class="inline">false</code> in an <code class="inline">orelse</code> expression.</li></ul><p>or</p><ul><li><code class="inline">Expr1</code> evaluates to <code class="inline">true</code> in an <code class="inline">andalso</code> expression.</li></ul><p>Returns either the value of <code class="inline">Expr1</code> (that is, <code class="inline">true</code> or <code class="inline">false</code>) or the value of
<code class="inline">Expr2</code> (if <code class="inline">Expr2</code> is evaluated).</p><p><em>Example 1:</em></p><pre><code class="makeup erlang" translate="no"><span class="k">case</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="o">-</span><span class="mf">1.0</span><span class="w"> </span><span class="ow">andalso</span><span class="w"> </span><span class="nc">math</span><span class="p">:</span><span class="nf">sqrt</span><span class="p" data-group-id="8547158327-1">(</span><span class="n">A</span><span class="o">+</span><span class="mi">1</span><span class="p" data-group-id="8547158327-1">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="k">of</span></code></pre><p>This works even if <code class="inline">A</code> is less than <code class="inline">-1.0</code>, since in that case, <a href="../apps/stdlib/math.html#sqrt/1"><code class="inline">math:sqrt/1</code></a> is
never evaluated.</p><p><em>Example 2:</em></p><pre><code class="makeup erlang" translate="no"><span class="n">OnlyOne</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">is_atom</span><span class="p" data-group-id="5291388057-1">(</span><span class="n">L</span><span class="p" data-group-id="5291388057-1">)</span><span class="w"> </span><span class="nf">orelse</span><span class="w">
         </span><span class="p" data-group-id="5291388057-2">(</span><span class="nf">is_list</span><span class="p" data-group-id="5291388057-3">(</span><span class="n">L</span><span class="p" data-group-id="5291388057-3">)</span><span class="w"> </span><span class="ow">andalso</span><span class="w"> </span><span class="nf">length</span><span class="p" data-group-id="5291388057-4">(</span><span class="n">L</span><span class="p" data-group-id="5291388057-4">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="5291388057-2">)</span><span class="p">,</span></code></pre><p><code class="inline">Expr2</code> is not required to evaluate to a Boolean value. Because of that,
<code class="inline">andalso</code> and <code class="inline">orelse</code> are tail-recursive.</p><p><em>Example 3 (tail-recursive function):</em></p><pre><code class="makeup erlang" translate="no"><span class="nf">all</span><span class="p" data-group-id="3323205259-1">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3323205259-2">[</span><span class="n">Hd</span><span class="p">|</span><span class="n">Tail</span><span class="p" data-group-id="3323205259-2">]</span><span class="p" data-group-id="3323205259-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="n">Pred</span><span class="p" data-group-id="3323205259-3">(</span><span class="n">Hd</span><span class="p" data-group-id="3323205259-3">)</span><span class="w"> </span><span class="ow">andalso</span><span class="w"> </span><span class="nf">all</span><span class="p" data-group-id="3323205259-4">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">Tail</span><span class="p" data-group-id="3323205259-4">)</span><span class="p">;</span><span class="w">
</span><span class="nf">all</span><span class="p" data-group-id="3323205259-5">(</span><span class="p">_</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3323205259-6">[</span><span class="p" data-group-id="3323205259-6">]</span><span class="p" data-group-id="3323205259-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="ss">true</span><span class="p">.</span></code></pre><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>Before Erlang/OTP R13A, <code class="inline">Expr2</code> was required to evaluate to a Boolean value,
and as consequence, <code class="inline">andalso</code> and <code class="inline">orelse</code> were <strong>not</strong> tail-recursive.</p></section><h2 id="list-operations" class="section-heading"><a href="#list-operations" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">List Operations</span></h2><pre><code class="makeup erlang" translate="no"><span class="n">Expr1</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">Expr2</span><span class="w">
</span><span class="n">Expr1</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="n">Expr2</span></code></pre><p>The list concatenation operator <code class="inline">++</code> appends its second argument to its first
and returns the resulting list.</p><p>The list subtraction operator <code class="inline">--</code> produces a list that is a copy of the first
argument. The procedure is as follows: for each element in the second argument,
the first occurrence of this element (if any) is removed.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="4002907768-1">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="4002907768-1">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p" data-group-id="4002907768-2">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="4002907768-2">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="4002907768-3">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="4002907768-3">]</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="4002907768-4">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="4002907768-4">]</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="p" data-group-id="4002907768-5">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="4002907768-5">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="4002907768-6">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="4002907768-6">]</span></code></pre><h2 id="map-expressions" class="section-heading"><a href="#map-expressions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Map Expressions</span></h2><h3 id="creating-maps" class="section-heading"><a href="#creating-maps" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Creating Maps</span></h3><p>Constructing a new map is done by letting an expression <code class="inline">K</code> be associated with
another expression <code class="inline">V</code>:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="9729943470-1">#{</span><span class="n">K</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">V</span><span class="p" data-group-id="9729943470-1">}</span></code></pre><p>New maps can include multiple associations at construction by listing every
association:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="1198377946-1">#{</span><span class="n">K1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="n">Kn</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">Vn</span><span class="p" data-group-id="1198377946-1">}</span></code></pre><p>An empty map is constructed by not associating any terms with each other:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="9240843262-1">#{</span><span class="p" data-group-id="9240843262-1">}</span></code></pre><p>All keys and values in the map are terms. Any expression is first evaluated and
then the resulting terms are used as <em>key</em> and <em>value</em> respectively.</p><p>Keys and values are separated by the <code class="inline">=&gt;</code> arrow and associations are separated
by a comma (<code class="inline">,</code>).</p><p><em>Examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="n">M0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4918384779-1">#{</span><span class="p" data-group-id="4918384779-1">}</span><span class="p">,</span><span class="w">                 </span><span class="c1">% empty map</span><span class="w">
</span><span class="n">M1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4918384779-2">#{</span><span class="ss">a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p" data-group-id="4918384779-3">&lt;&lt;</span><span class="s">&quot;hello&quot;</span><span class="p" data-group-id="4918384779-3">&gt;&gt;</span><span class="p" data-group-id="4918384779-2">}</span><span class="p">,</span><span class="w"> </span><span class="c1">% single association with literals</span><span class="w">
</span><span class="n">M2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4918384779-4">#{</span><span class="mi">1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">b</span><span class="p" data-group-id="4918384779-4">}</span><span class="p">,</span><span class="w">   </span><span class="c1">% multiple associations with literals</span><span class="w">
</span><span class="n">M3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4918384779-5">#{</span><span class="ss">k</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p" data-group-id="4918384779-6">{</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p" data-group-id="4918384779-6">}</span><span class="p" data-group-id="4918384779-5">}</span><span class="p">,</span><span class="w">       </span><span class="c1">% single association with variables</span><span class="w">
</span><span class="n">M4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4918384779-7">#{</span><span class="p" data-group-id="4918384779-8">{</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="4918384779-8">}</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nf">f</span><span class="p" data-group-id="4918384779-9">(</span><span class="p" data-group-id="4918384779-9">)</span><span class="p" data-group-id="4918384779-7">}</span><span class="p">.</span><span class="w">  </span><span class="c1">% compound key associated with an evaluated expression</span></code></pre><p>Here, <code class="inline">A</code> and <code class="inline">B</code> are any expressions and <code class="inline">M0</code> through <code class="inline">M4</code> are the resulting
map terms.</p><p>If two matching keys are declared, the latter key takes precedence.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="3485764697-1">#{</span><span class="mi">1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">a</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">b</span><span class="p" data-group-id="3485764697-1">}</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="3485764697-2">#{</span><span class="mi">1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="p" data-group-id="3485764697-2">}</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="3485764697-3">#{</span><span class="mf">1.0</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">a</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">b</span><span class="p" data-group-id="3485764697-3">}</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="3485764697-4">#{</span><span class="mi">1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">b</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">a</span><span class="p" data-group-id="3485764697-4">}</span></code></pre><p>The order in which the expressions constructing the keys (and their associated
values) are evaluated is not defined. The syntactic order of the key-value pairs
in the construction is of no relevance, except in the recently mentioned case of
two matching keys.</p><h3 id="updating-maps" class="section-heading"><a href="#updating-maps" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Updating Maps</span></h3><p>Updating a map has a similar syntax as constructing it.</p><p>An expression defining the map to be updated is put in front of the expression
defining the keys to be updated and their respective values:</p><pre><code class="makeup erlang" translate="no"><span class="n">M</span><span class="p" data-group-id="1109455185-1">#{</span><span class="n">K</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">V</span><span class="p" data-group-id="1109455185-1">}</span></code></pre><p>Here <code class="inline">M</code> is a term of type map and <code class="inline">K</code> and <code class="inline">V</code> are any expression.</p><p>If key <code class="inline">K</code> does not match any existing key in the map, a new association is
created from key <code class="inline">K</code> to value <code class="inline">V</code>.</p><p>If key <code class="inline">K</code> matches an existing key in map <code class="inline">M</code>, its associated value is replaced
by the new value <code class="inline">V</code>. In both cases, the evaluated map expression returns a new
map.</p><p>If <code class="inline">M</code> is not of type map, an exception of type <code class="inline">badmap</code> is raised.</p><p>To only update an existing value, the following syntax is used:</p><pre><code class="makeup erlang" translate="no"><span class="n">M</span><span class="p" data-group-id="9904711019-1">#{</span><span class="n">K</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">V</span><span class="p" data-group-id="9904711019-1">}</span></code></pre><p>Here <code class="inline">M</code> is a term of type map, <code class="inline">V</code> is an expression and <code class="inline">K</code> is an expression
that evaluates to an existing key in <code class="inline">M</code>.</p><p>If key <code class="inline">K</code> does not match any existing keys in map <code class="inline">M</code>, an exception of type
<code class="inline">badkey</code> is raised at runtime. If a matching key <code class="inline">K</code> is present in map <code class="inline">M</code>,
its associated value is replaced by the new value <code class="inline">V</code>, and the evaluated map
expression returns a new map.</p><p>If <code class="inline">M</code> is not of type map, an exception of type <code class="inline">badmap</code> is raised.</p><p><em>Examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="n">M0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8657053914-1">#{</span><span class="p" data-group-id="8657053914-1">}</span><span class="p">,</span><span class="w">
</span><span class="n">M1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M0</span><span class="p" data-group-id="8657053914-2">#{</span><span class="ss">a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="8657053914-2">}</span><span class="p">,</span><span class="w">
</span><span class="n">M2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M1</span><span class="p" data-group-id="8657053914-3">#{</span><span class="ss">a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="8657053914-3">}</span><span class="p">,</span><span class="w">
</span><span class="n">M3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M2</span><span class="p" data-group-id="8657053914-4">#{</span><span class="s">&quot;function&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nf">fun</span><span class="p" data-group-id="8657053914-5">(</span><span class="p" data-group-id="8657053914-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nf">f</span><span class="p" data-group-id="8657053914-6">(</span><span class="p" data-group-id="8657053914-6">)</span><span class="w"> </span><span class="k">end</span><span class="p" data-group-id="8657053914-4">}</span><span class="p">,</span><span class="w">
</span><span class="n">M4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M3</span><span class="p" data-group-id="8657053914-7">#{</span><span class="ss">a</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="8657053914-7">}</span><span class="p">.</span><span class="w">  </span><span class="c1">% &#39;a&#39; and &#39;b&#39; was added in `M1` and `M2`.</span></code></pre><p>Here <code class="inline">M0</code> is any map. It follows that <code class="inline">M1</code> through <code class="inline">M4</code> are maps as well.</p><p><em>More examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8812717145-1">#{</span><span class="mi">1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">a</span><span class="p" data-group-id="8812717145-1">}</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8812717145-2">#{</span><span class="mi">1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">a</span><span class="w"> </span><span class="p" data-group-id="8812717145-2">}</span><span class="gp unselectable">
2&gt; </span><span class="n">M</span><span class="p" data-group-id="8812717145-3">#{</span><span class="mf">1.0</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">b</span><span class="p" data-group-id="8812717145-3">}</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8812717145-4">#{</span><span class="mi">1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">a</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">b</span><span class="p" data-group-id="8812717145-4">}</span><span class="p">.</span><span class="gp unselectable">
3&gt; </span><span class="n">M</span><span class="p" data-group-id="8812717145-5">#{</span><span class="mi">1</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">b</span><span class="p" data-group-id="8812717145-5">}</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8812717145-6">#{</span><span class="mi">1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">b</span><span class="p" data-group-id="8812717145-6">}</span><span class="gp unselectable">
4&gt; </span><span class="n">M</span><span class="p" data-group-id="8812717145-7">#{</span><span class="mf">1.0</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">b</span><span class="p" data-group-id="8812717145-7">}</span><span class="p">.</span><span class="w">
</span><span class="gt">** exception error: bad argument</span></code></pre><p>As in construction, the order in which the key and value expressions are
evaluated is not defined. The syntactic order of the key-value pairs in the
update is of no relevance, except in the case where two keys match. In that
case, the latter value is used.</p><h3 id="maps-in-patterns" class="section-heading"><a href="#maps-in-patterns" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Maps in Patterns</span></h3><p>Matching of key-value associations from maps is done as follows:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="8120729980-1">#{</span><span class="n">K</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">V</span><span class="p" data-group-id="8120729980-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span></code></pre><p>Here <code class="inline">M</code> is any map. The key <code class="inline">K</code> must be a
<a href="expressions.html#guard-expressions">guard expression</a>, with all variables already
bound. <code class="inline">V</code> can be any pattern with either bound or unbound variables.</p><p>If the variable <code class="inline">V</code> is unbound, it becomes bound to the value associated with
the key <code class="inline">K</code>, which must exist in the map <code class="inline">M</code>. If the variable <code class="inline">V</code> is bound, it
must match the value associated with <code class="inline">K</code> in <code class="inline">M</code>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>Before Erlang/OTP 23, the expression defining the key <code class="inline">K</code> was restricted to be
either a single variable or a literal.</p></section><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5347444436-1">#{</span><span class="s">&quot;tuple&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p" data-group-id="5347444436-2">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="5347444436-2">}</span><span class="p" data-group-id="5347444436-1">}</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="5347444436-3">#{</span><span class="s">&quot;tuple&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p" data-group-id="5347444436-4">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="5347444436-4">}</span><span class="p" data-group-id="5347444436-3">}</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="5347444436-5">#{</span><span class="s">&quot;tuple&quot;</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="p" data-group-id="5347444436-6">{</span><span class="mi">1</span><span class="p">,</span><span class="n">B</span><span class="p" data-group-id="5347444436-6">}</span><span class="p" data-group-id="5347444436-5">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="5347444436-7">#{</span><span class="s">&quot;tuple&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p" data-group-id="5347444436-8">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="5347444436-8">}</span><span class="p" data-group-id="5347444436-7">}</span><span class="gp unselectable">
3&gt; </span><span class="n">B</span><span class="p">.</span><span class="w">
</span><span class="mi">2</span><span class="p">.</span></code></pre><p>This binds variable <code class="inline">B</code> to integer <code class="inline">2</code>.</p><p>Similarly, multiple values from the map can be matched:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="9151068944-1">#{</span><span class="n">K1</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="n">Kn</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">Vn</span><span class="p" data-group-id="9151068944-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span></code></pre><p>Here keys <code class="inline">K1</code> through <code class="inline">Kn</code> are any expressions with literals or bound
variables. If all key expressions evaluate successfully and all keys
exist in map <code class="inline">M</code>, all variables in <code class="inline">V1 .. Vn</code> is matched to the
associated values of their respective keys.</p><p>If the matching conditions are not met the match fails.</p><p>Note that when matching a map, only the <code class="inline">:=</code> operator (not the <code class="inline">=&gt;</code>) is allowed
as a delimiter for the associations.</p><p>The order in which keys are declared in matching has no relevance.</p><p>Duplicate keys are allowed in matching and match each pattern associated to the
keys:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="2958607075-1">#{</span><span class="n">K</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">V2</span><span class="p" data-group-id="2958607075-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span></code></pre><p>The empty map literal (<code class="inline">#{}</code>) matches any map when used as a pattern:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="8312721064-1">#{</span><span class="p" data-group-id="8312721064-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Expr</span></code></pre><p>This expression matches if the expression <code class="inline">Expr</code> is of type map, otherwise it
fails with an exception <code class="inline">badmatch</code>.</p><p>Here the key to be retrieved is constructed from an expression:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="5284248555-1">#{</span><span class="p" data-group-id="5284248555-2">{</span><span class="ss">tag</span><span class="p">,</span><span class="nf">length</span><span class="p" data-group-id="5284248555-3">(</span><span class="n">List</span><span class="p" data-group-id="5284248555-3">)</span><span class="p" data-group-id="5284248555-2">}</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">V</span><span class="p" data-group-id="5284248555-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Map</span></code></pre><p><code class="inline">List</code> must be an already bound variable.</p><h4>Matching Syntax</h4><p>Matching of literals as keys are allowed in function heads:</p><pre><code class="makeup erlang" translate="no"><span class="c1">%% only start if not_started</span><span class="w">
</span><span class="nf">handle_call</span><span class="p" data-group-id="8317343532-1">(</span><span class="ss">start</span><span class="p">,</span><span class="w"> </span><span class="n">From</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8317343532-2">#{</span><span class="ss">state</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">not_started</span><span class="p" data-group-id="8317343532-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p" data-group-id="8317343532-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w">
    </span><span class="p" data-group-id="8317343532-3">{</span><span class="ss">reply</span><span class="p">,</span><span class="w"> </span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p" data-group-id="8317343532-4">#{</span><span class="ss">state</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">start</span><span class="p" data-group-id="8317343532-4">}</span><span class="p" data-group-id="8317343532-3">}</span><span class="p">;</span><span class="w">

</span><span class="c1">%% only change if started</span><span class="w">
</span><span class="nf">handle_call</span><span class="p" data-group-id="8317343532-5">(</span><span class="ss">change</span><span class="p">,</span><span class="w"> </span><span class="n">From</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8317343532-6">#{</span><span class="ss">state</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">start</span><span class="p" data-group-id="8317343532-6">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p" data-group-id="8317343532-5">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w">
    </span><span class="p" data-group-id="8317343532-7">{</span><span class="ss">reply</span><span class="p">,</span><span class="w"> </span><span class="ss">ok</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p" data-group-id="8317343532-8">#{</span><span class="ss">state</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="ss">changed</span><span class="p" data-group-id="8317343532-8">}</span><span class="p" data-group-id="8317343532-7">}</span><span class="p">;</span></code></pre><h3 id="maps-in-guards" class="section-heading"><a href="#maps-in-guards" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Maps in Guards</span></h3><p>Maps are allowed in guards as long as all subexpressions are valid guard
expressions.</p><p>The following guard BIFs handle maps:</p><ul><li><a href="../apps/erts/erlang.html#is_map/1">is_map/1</a> in the <code class="inline">erlang</code> module</li><li><a href="../apps/erts/erlang.html#is_map_key/2">is_map_key/2</a> in the <code class="inline">erlang</code> module</li><li><a href="../apps/erts/erlang.html#map_get/2">map_get/2</a> in the <code class="inline">erlang</code> module</li><li><a href="../apps/erts/erlang.html#map_size/1">map_size/1</a> in the <code class="inline">erlang</code> module</li></ul><h2 id="bit-syntax-expressions" class="section-heading"><a href="#bit-syntax-expressions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Bit Syntax Expressions</span></h2><p>The bit syntax operates on <em>bit strings</em>. A bit string is a sequence of bits
ordered from the most significant bit to the least significant bit.</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="7487570497-1">&lt;&lt;</span><span class="p" data-group-id="7487570497-1">&gt;&gt;</span><span class="w">  </span><span class="c1">% The empty bit string, zero length</span><span class="w">
</span><span class="p" data-group-id="7487570497-2">&lt;&lt;</span><span class="n">E1</span><span class="p" data-group-id="7487570497-2">&gt;&gt;</span><span class="w">
</span><span class="p" data-group-id="7487570497-3">&lt;&lt;</span><span class="n">E1</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="n">En</span><span class="p" data-group-id="7487570497-3">&gt;&gt;</span></code></pre><p>Each element <code class="inline">Ei</code> specifies a <em>segment</em> of the bit string. The segments are
ordered left to right from the most significant bit to the least significant bit
of the bit string.</p><p>Each segment specification <code class="inline">Ei</code> is a value, whose default type is <code class="inline">integer</code>,
followed by an optional <em>size expression</em> and an optional <em>type specifier list</em>.</p><pre><code class="makeup erlang" translate="no"><span class="n">Ei</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="p">|</span><span class="w">
     </span><span class="n">Value</span><span class="p">:</span><span class="n">Size</span><span class="w"> </span><span class="p">|</span><span class="w">
     </span><span class="n">Value</span><span class="o">/</span><span class="n">TypeSpecifierList</span><span class="w"> </span><span class="p">|</span><span class="w">
     </span><span class="n">Value</span><span class="p">:</span><span class="n">Size</span><span class="o">/</span><span class="n">TypeSpecifierList</span></code></pre><p>When used in a bit string construction, <code class="inline">Value</code> is an expression that is to
evaluate to an integer, float, or bit string. If the expression is not a single
literal or variable, it is to be enclosed in parentheses.</p><p>When used in a bit string matching, <code class="inline">Value</code> must be a variable, or an integer,
float, or string.</p><p>Notice that, for example, using a string literal as in <code class="inline">&lt;&lt;&quot;abc&quot;&gt;&gt;</code> is syntactic
sugar for <code class="inline">&lt;&lt;$a,$b,$c&gt;&gt;</code>.</p><p>When used in a bit string construction, <code class="inline">Size</code> is an expression that is to
evaluate to an integer.</p><p>When used in a bit string matching, <code class="inline">Size</code> must be a
<a href="expressions.html#guard-expressions">guard expression</a> that evaluates to an
integer. All variables in the guard expression must be already bound.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>Before Erlang/OTP 23, <code class="inline">Size</code> was restricted to be an integer or a variable
bound to an integer.</p></section><p>The value of <code class="inline">Size</code> specifies the size of the segment in units (see below). The
default value depends on the type (see below):</p><ul><li>For <code class="inline">integer</code> it is 8.</li><li>For <code class="inline">float</code> it is 64.</li><li>For <code class="inline">binary</code> and <code class="inline">bitstring</code> it is the whole binary or bit string.</li></ul><p>In matching, the default value for a binary or bit string segment is only valid
for the last element. All other bit string or binary elements in the matching
must have a size specification.</p><p><a href="" id="binaries"></a></p><p><strong>Binaries</strong></p><p>A bit string with a length that is a multiple of 8 bits is known as a <em>binary</em>,
which is the most common and useful type of bit string.</p><p>A binary has a canonical representation in memory. Here follows a sequence of
bytes where each byte's value is its sequence number:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="5263449137-1">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p" data-group-id="5263449137-1">&gt;&gt;</span></code></pre><p>Bit strings are a later generalization of binaries, so many texts and much
information about binaries apply just as well for bit strings.</p><p><strong>Example:</strong></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="2214541552-1">&lt;&lt;</span><span class="n">A</span><span class="o">/</span><span class="ss">binary</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="2214541552-1">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="2214541552-2">&lt;&lt;</span><span class="s">&quot;abcde&quot;</span><span class="p" data-group-id="2214541552-2">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="gt">* 1:3: a binary field without size is only allowed at the end of a binary pattern</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="2214541552-3">&lt;&lt;</span><span class="n">A</span><span class="p">:</span><span class="mi">3</span><span class="o">/</span><span class="ss">binary</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="2214541552-3">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="2214541552-4">&lt;&lt;</span><span class="s">&quot;abcde&quot;</span><span class="p" data-group-id="2214541552-4">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2214541552-5">&lt;&lt;</span><span class="s">&quot;abcde&quot;</span><span class="p" data-group-id="2214541552-5">&gt;&gt;</span><span class="gp unselectable">
3&gt; </span><span class="n">A</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2214541552-6">&lt;&lt;</span><span class="s">&quot;abc&quot;</span><span class="p" data-group-id="2214541552-6">&gt;&gt;</span><span class="gp unselectable">
4&gt; </span><span class="n">B</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2214541552-7">&lt;&lt;</span><span class="s">&quot;de&quot;</span><span class="p" data-group-id="2214541552-7">&gt;&gt;</span></code></pre><p>For the <code class="inline">utf8</code>, <code class="inline">utf16</code>, and <code class="inline">utf32</code> types, <code class="inline">Size</code> must not be given. The size
of the segment is implicitly determined by the type and value itself.</p><p><code class="inline">TypeSpecifierList</code> is a list of type specifiers, in any order, separated by
hyphens (-). Default values are used for any omitted type specifiers.</p><ul><li><p><strong><code class="inline">Type</code>= <code class="inline">integer</code> | <code class="inline">float</code> | <code class="inline">binary</code> | <code class="inline">bytes</code> | <code class="inline">bitstring</code> | <code class="inline">bits</code> |
<code class="inline">utf8</code> | <code class="inline">utf16</code> | <code class="inline">utf32</code></strong> - The default is <code class="inline">integer</code>. <code class="inline">bytes</code> is a
shorthand for <code class="inline">binary</code> and <code class="inline">bits</code> is a shorthand for <code class="inline">bitstring</code>. See below
for more information about the <code class="inline">utf</code> types.</p></li><li><p><strong><code class="inline">Signedness</code>= <code class="inline">signed</code> | <code class="inline">unsigned</code></strong> - Only matters for matching and when
the type is <code class="inline">integer</code>. The default is <code class="inline">unsigned</code>.</p></li><li><p><strong><code class="inline">Endianness</code>= <code class="inline">big</code> | <code class="inline">little</code> | <code class="inline">native</code></strong> - Specifies byte level (octet
level) endianness (byte order). Native-endian means that the endianness is
resolved at load time to be either big-endian or little-endian, depending on
what is native for the CPU that the Erlang machine is run on. Endianness only
matters when the <strong>Type</strong> is either <code class="inline">integer</code>, <code class="inline">utf16</code>, <code class="inline">utf32</code>, or <code class="inline">float</code>. The
default is <code class="inline">big</code>.</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="1216250947-1">&lt;&lt;</span><span class="mi">16#1234</span><span class="p">:</span><span class="mi">16</span><span class="o">/</span><span class="ss">little</span><span class="p" data-group-id="1216250947-1">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1216250947-2">&lt;&lt;</span><span class="mi">16#3412</span><span class="p">:</span><span class="mi">16</span><span class="p" data-group-id="1216250947-2">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1216250947-3">&lt;&lt;</span><span class="mi">16#34</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">16#12</span><span class="p">:</span><span class="mi">8</span><span class="p" data-group-id="1216250947-3">&gt;&gt;</span></code></pre></li><li><p><strong><code class="inline">Unit</code>= <code class="inline">unit:IntegerLiteral</code></strong> - The allowed range is 1 through 256.
Defaults to 1 for <code class="inline">integer</code>, <code class="inline">float</code>, and <code class="inline">bitstring</code>, and to 8 for <code class="inline">binary</code>.
For types <code class="inline">bitstring</code>, <code class="inline">bits</code>, and <code class="inline">bytes</code>, it is not allowed to specify a
unit value different from the default value. No unit specifier must be given
for the types <code class="inline">utf8</code>, <code class="inline">utf16</code>, and <code class="inline">utf32</code>.</p></li></ul><h3 id="integer-segments" class="section-heading"><a href="#integer-segments" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Integer segments</span></h3><p>The value of <code class="inline">Size</code> multiplied with the unit gives the size of the segment in
bits.</p><p>When constructing bit strings, if the size <code class="inline">N</code> of an integer segment is too
small to contain the given integer, the most significant bits of the integer are
silently discarded and only the <code class="inline">N</code> least significant bits are put into the bit
string. For example, <code class="inline">&lt;&lt;16#ff:4&gt;&gt;</code> will result in the bit string <code class="inline">&lt;&lt;15:4&gt;&gt;</code>.</p><h3 id="float-segments" class="section-heading"><a href="#float-segments" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Float segments</span></h3><p>The value of <code class="inline">Size</code> multiplied with the unit gives the size of the segment in
bits. The size of a float segment in bits must be one of 16, 32, or 64.</p><p>When constructing bit strings, if the size of a float segment is too small to
contain the representation of the given float value, an exception is raised.</p><p>When matching bit strings, matching of float segments fails if the bits of the
segment does not contain the representation of a finite floating point value.</p><h3 id="binary-segments" class="section-heading"><a href="#binary-segments" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Binary segments</span></h3><p>In this section, the phrase &quot;binary segment&quot; refers to any one of the segment
types <code class="inline">binary</code>, <code class="inline">bitstring</code>, <code class="inline">bytes</code>, and <code class="inline">bits</code>.</p><p>See also the paragraphs about <a href="expressions.html#binaries">Binaries</a>.</p><p>When constructing binaries and no size is specified for a binary segment, the
entire binary value is interpolated into the binary being constructed. However,
the size in bits of the binary being interpolated must be evenly divisible by
the unit value for the segment; otherwise an exception is raised.</p><p>For example, the following examples all succeed:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="2559648298-1">&lt;&lt;</span><span class="p" data-group-id="2559648298-2">(</span><span class="p" data-group-id="2559648298-3">&lt;&lt;</span><span class="s">&quot;abc&quot;</span><span class="p" data-group-id="2559648298-3">&gt;&gt;</span><span class="p" data-group-id="2559648298-2">)</span><span class="o">/</span><span class="ss">bitstring</span><span class="p" data-group-id="2559648298-1">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2559648298-4">&lt;&lt;</span><span class="s">&quot;abc&quot;</span><span class="p" data-group-id="2559648298-4">&gt;&gt;</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="2559648298-5">&lt;&lt;</span><span class="p" data-group-id="2559648298-6">(</span><span class="p" data-group-id="2559648298-7">&lt;&lt;</span><span class="s">&quot;abc&quot;</span><span class="p" data-group-id="2559648298-7">&gt;&gt;</span><span class="p" data-group-id="2559648298-6">)</span><span class="o">/</span><span class="ss">binary</span><span class="o">-</span><span class="nc">unit</span><span class="p">:</span><span class="mi">1</span><span class="p" data-group-id="2559648298-5">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2559648298-8">&lt;&lt;</span><span class="s">&quot;abc&quot;</span><span class="p" data-group-id="2559648298-8">&gt;&gt;</span><span class="gp unselectable">
3&gt; </span><span class="p" data-group-id="2559648298-9">&lt;&lt;</span><span class="p" data-group-id="2559648298-10">(</span><span class="p" data-group-id="2559648298-11">&lt;&lt;</span><span class="s">&quot;abc&quot;</span><span class="p" data-group-id="2559648298-11">&gt;&gt;</span><span class="p" data-group-id="2559648298-10">)</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="2559648298-9">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2559648298-12">&lt;&lt;</span><span class="s">&quot;abc&quot;</span><span class="p" data-group-id="2559648298-12">&gt;&gt;</span></code></pre><p>The first two examples have a unit value of 1 for the segment, while the third
segment has a unit value of 8.</p><p>Attempting to interpolate a bit string of size 1 into a binary segment with unit
8 (the default unit for <code class="inline">binary</code>) fails as shown in this example:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="3045155131-1">&lt;&lt;</span><span class="p" data-group-id="3045155131-2">(</span><span class="p" data-group-id="3045155131-3">&lt;&lt;</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p" data-group-id="3045155131-3">&gt;&gt;</span><span class="p" data-group-id="3045155131-2">)</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="3045155131-1">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="gt">** exception error: bad argument</span></code></pre><p>For the construction to succeed, the unit value of the segment must be 1:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">2&gt; </span><span class="p" data-group-id="8957948779-1">&lt;&lt;</span><span class="p" data-group-id="8957948779-2">(</span><span class="p" data-group-id="8957948779-3">&lt;&lt;</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p" data-group-id="8957948779-3">&gt;&gt;</span><span class="p" data-group-id="8957948779-2">)</span><span class="o">/</span><span class="ss">bitstring</span><span class="p" data-group-id="8957948779-1">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8957948779-4">&lt;&lt;</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p" data-group-id="8957948779-4">&gt;&gt;</span><span class="gp unselectable">
3&gt; </span><span class="p" data-group-id="8957948779-5">&lt;&lt;</span><span class="p" data-group-id="8957948779-6">(</span><span class="p" data-group-id="8957948779-7">&lt;&lt;</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p" data-group-id="8957948779-7">&gt;&gt;</span><span class="p" data-group-id="8957948779-6">)</span><span class="o">/</span><span class="ss">binary</span><span class="o">-</span><span class="nc">unit</span><span class="p">:</span><span class="mi">1</span><span class="p" data-group-id="8957948779-5">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8957948779-8">&lt;&lt;</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p" data-group-id="8957948779-8">&gt;&gt;</span></code></pre><p>Similarly, when matching a binary segment with no size specified, the match
succeeds if and only if the size in bits of the rest of the binary is evenly
divisible by the unit value:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="5233559408-1">&lt;&lt;</span><span class="p">_</span><span class="o">/</span><span class="ss">binary</span><span class="o">-</span><span class="nc">unit</span><span class="p">:</span><span class="mi">16</span><span class="p" data-group-id="5233559408-1">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5233559408-2">&lt;&lt;</span><span class="s">&quot;&quot;</span><span class="p" data-group-id="5233559408-2">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="5233559408-3">&lt;&lt;</span><span class="p" data-group-id="5233559408-3">&gt;&gt;</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="5233559408-4">&lt;&lt;</span><span class="p">_</span><span class="o">/</span><span class="ss">binary</span><span class="o">-</span><span class="nc">unit</span><span class="p">:</span><span class="mi">16</span><span class="p" data-group-id="5233559408-4">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5233559408-5">&lt;&lt;</span><span class="s">&quot;a&quot;</span><span class="p" data-group-id="5233559408-5">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="gt">** exception error: no match of right hand side value &lt;&lt;&quot;a&quot;&gt;&gt;</span><span class="gp unselectable">
3&gt; </span><span class="p" data-group-id="5233559408-6">&lt;&lt;</span><span class="p">_</span><span class="o">/</span><span class="ss">binary</span><span class="o">-</span><span class="nc">unit</span><span class="p">:</span><span class="mi">16</span><span class="p" data-group-id="5233559408-6">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5233559408-7">&lt;&lt;</span><span class="s">&quot;ab&quot;</span><span class="p" data-group-id="5233559408-7">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="5233559408-8">&lt;&lt;</span><span class="s">&quot;ab&quot;</span><span class="p" data-group-id="5233559408-8">&gt;&gt;</span><span class="gp unselectable">
4&gt; </span><span class="p" data-group-id="5233559408-9">&lt;&lt;</span><span class="p">_</span><span class="o">/</span><span class="ss">binary</span><span class="o">-</span><span class="nc">unit</span><span class="p">:</span><span class="mi">16</span><span class="p" data-group-id="5233559408-9">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5233559408-10">&lt;&lt;</span><span class="s">&quot;abc&quot;</span><span class="p" data-group-id="5233559408-10">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="gt">** exception error: no match of right hand side value &lt;&lt;&quot;abc&quot;&gt;&gt;</span><span class="gp unselectable">
5&gt; </span><span class="p" data-group-id="5233559408-11">&lt;&lt;</span><span class="p">_</span><span class="o">/</span><span class="ss">binary</span><span class="o">-</span><span class="nc">unit</span><span class="p">:</span><span class="mi">16</span><span class="p" data-group-id="5233559408-11">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5233559408-12">&lt;&lt;</span><span class="s">&quot;abcd&quot;</span><span class="p" data-group-id="5233559408-12">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="5233559408-13">&lt;&lt;</span><span class="s">&quot;abcd&quot;</span><span class="p" data-group-id="5233559408-13">&gt;&gt;</span></code></pre><p>When a size is explicitly specified for a binary segment, the segment size in
bits is the value of <code class="inline">Size</code> multiplied by the default or explicit unit value.</p><p>When constructing binaries, the size of the binary being interpolated into the
constructed binary must be at least as large as the size of the binary segment.</p><p><strong>Examples:</strong></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="8425924273-1">&lt;&lt;</span><span class="p" data-group-id="8425924273-2">(</span><span class="p" data-group-id="8425924273-3">&lt;&lt;</span><span class="s">&quot;abc&quot;</span><span class="p" data-group-id="8425924273-3">&gt;&gt;</span><span class="p" data-group-id="8425924273-2">)</span><span class="p">:</span><span class="mi">2</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="8425924273-1">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8425924273-4">&lt;&lt;</span><span class="s">&quot;ab&quot;</span><span class="p" data-group-id="8425924273-4">&gt;&gt;</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="8425924273-5">&lt;&lt;</span><span class="p" data-group-id="8425924273-6">(</span><span class="p" data-group-id="8425924273-7">&lt;&lt;</span><span class="s">&quot;a&quot;</span><span class="p" data-group-id="8425924273-7">&gt;&gt;</span><span class="p" data-group-id="8425924273-6">)</span><span class="p">:</span><span class="mi">2</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="8425924273-5">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="gt">** exception error: construction of binary failed
        *** segment 1 of type &#39;binary&#39;: the value &lt;&lt;&quot;a&quot;&gt;&gt; is shorter than the size of the segment</span></code></pre><h3 id="unicode-segments" class="section-heading"><a href="#unicode-segments" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Unicode segments</span></h3><p>The types <code class="inline">utf8</code>, <code class="inline">utf16</code>, and <code class="inline">utf32</code> specifies encoding/decoding of the
<em>Unicode Transformation Format</em>s <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>,
<a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a>, and
<a href="https://en.wikipedia.org/wiki/UTF-32">UTF-32</a>, respectively.</p><p>When constructing a segment of a <code class="inline">utf</code> type, <code class="inline">Value</code> must be an integer in the
range <code class="inline">0</code> through <code class="inline">16#D7FF</code> or <code class="inline">16#E000</code> through <code class="inline">16#10FFFF</code>. Construction fails with a
<code class="inline">badarg</code> exception if <code class="inline">Value</code> is outside the allowed ranges. The sizes of the
encoded values are as follows:</p><ul><li>For <code class="inline">utf8</code>, <code class="inline">Value</code> is encoded in 1-4 bytes.</li><li>For <code class="inline">utf16</code>, <code class="inline">Value</code> is encoded in 2 or 4 bytes.</li><li>For <code class="inline">utf32</code>, <code class="inline">Value</code> is encoded in 4 bytes.</li></ul><p>When constructing, a literal string can be given followed by one of the UTF
types, for example: <code class="inline">&lt;&lt;&quot;abc&quot;/utf8&gt;&gt;</code> which is syntactic sugar for
<code class="inline">&lt;&lt;$a/utf8,$b/utf8,$c/utf8&gt;&gt;</code>.</p><p>A successful match of a segment of a <code class="inline">utf</code> type, results in an integer in the
range <code class="inline">0</code> through <code class="inline">16#D7FF</code> or <code class="inline">16#E000</code> through <code class="inline">16#10FFFF</code>. The match fails if the
returned value falls outside those ranges.</p><p>A segment of type <code class="inline">utf8</code> matches 1-4 bytes in the bit string, if the bit string
at the match position contains a valid UTF-8 sequence. (See RFC-3629 or the
Unicode standard.)</p><p>A segment of type <code class="inline">utf16</code> can match 2 or 4 bytes in the bit string. The match
fails if the bit string at the match position does not contain a legal UTF-16
encoding of a Unicode code point. (See RFC-2781 or the Unicode standard.)</p><p>A segment of type <code class="inline">utf32</code> can match 4 bytes in the bit string in the same way as
an <code class="inline">integer</code> segment matches 32 bits. The match fails if the resulting integer
is outside the legal ranges previously mentioned.</p><p><em>Examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="n">Bin1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9192301215-1">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">42</span><span class="p" data-group-id="9192301215-1">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9192301215-2">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">42</span><span class="p" data-group-id="9192301215-2">&gt;&gt;</span><span class="gp unselectable">
2&gt; </span><span class="n">Bin2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9192301215-3">&lt;&lt;</span><span class="s">&quot;abc&quot;</span><span class="p" data-group-id="9192301215-3">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9192301215-4">&lt;&lt;</span><span class="mi">97</span><span class="p">,</span><span class="mi">98</span><span class="p">,</span><span class="mi">99</span><span class="p" data-group-id="9192301215-4">&gt;&gt;</span><span class="w">

</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bin3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9192301215-5">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">42</span><span class="p">:</span><span class="mi">16</span><span class="p" data-group-id="9192301215-5">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9192301215-6">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">42</span><span class="p" data-group-id="9192301215-6">&gt;&gt;</span><span class="gp unselectable">
4&gt; </span><span class="p" data-group-id="9192301215-7">&lt;&lt;</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">:</span><span class="mi">16</span><span class="p" data-group-id="9192301215-7">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9192301215-8">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">42</span><span class="p">:</span><span class="mi">16</span><span class="p" data-group-id="9192301215-8">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9192301215-9">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">42</span><span class="p" data-group-id="9192301215-9">&gt;&gt;</span><span class="gp unselectable">
5&gt; </span><span class="n">C</span><span class="p">.</span><span class="w">
</span><span class="mi">42</span><span class="gp unselectable">
6&gt; </span><span class="p" data-group-id="9192301215-10">&lt;&lt;</span><span class="n">D</span><span class="p">:</span><span class="mi">16</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">F</span><span class="p" data-group-id="9192301215-10">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9192301215-11">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">42</span><span class="p">:</span><span class="mi">16</span><span class="p" data-group-id="9192301215-11">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9192301215-12">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">42</span><span class="p" data-group-id="9192301215-12">&gt;&gt;</span><span class="gp unselectable">
7&gt; </span><span class="n">D</span><span class="p">.</span><span class="w">
</span><span class="mi">273</span><span class="gp unselectable">
8&gt; </span><span class="n">F</span><span class="p">.</span><span class="w">
</span><span class="mi">42</span><span class="gp unselectable">
9&gt; </span><span class="p" data-group-id="9192301215-13">&lt;&lt;</span><span class="n">G</span><span class="p">,</span><span class="n">H</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="9192301215-13">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9192301215-14">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">42</span><span class="p">:</span><span class="mi">16</span><span class="p" data-group-id="9192301215-14">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9192301215-15">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">42</span><span class="p" data-group-id="9192301215-15">&gt;&gt;</span><span class="gp unselectable">
10&gt; </span><span class="n">H</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9192301215-16">&lt;&lt;</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">42</span><span class="p" data-group-id="9192301215-16">&gt;&gt;</span><span class="gp unselectable">
11&gt; </span><span class="p" data-group-id="9192301215-17">&lt;&lt;</span><span class="n">G</span><span class="p">,</span><span class="n">J</span><span class="o">/</span><span class="ss">bitstring</span><span class="p" data-group-id="9192301215-17">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9192301215-18">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">42</span><span class="p">:</span><span class="mi">12</span><span class="p" data-group-id="9192301215-18">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9192301215-19">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">:</span><span class="mi">4</span><span class="p" data-group-id="9192301215-19">&gt;&gt;</span><span class="gp unselectable">
12&gt; </span><span class="n">J</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9192301215-20">&lt;&lt;</span><span class="mi">17</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">:</span><span class="mi">4</span><span class="p" data-group-id="9192301215-20">&gt;&gt;</span><span class="w">

</span><span class="mi">13</span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="9192301215-21">&lt;&lt;</span><span class="mi">1024</span><span class="o">/</span><span class="ss">utf8</span><span class="p" data-group-id="9192301215-21">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9192301215-22">&lt;&lt;</span><span class="mi">208</span><span class="p">,</span><span class="mi">128</span><span class="p" data-group-id="9192301215-22">&gt;&gt;</span><span class="w">

</span><span class="mi">14</span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="9192301215-23">&lt;&lt;</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">7</span><span class="p" data-group-id="9192301215-23">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9192301215-24">&lt;&lt;</span><span class="mi">128</span><span class="p" data-group-id="9192301215-24">&gt;&gt;</span><span class="gp unselectable">
15&gt; </span><span class="p" data-group-id="9192301215-25">&lt;&lt;</span><span class="mi">16#123</span><span class="p">:</span><span class="mi">12</span><span class="o">/</span><span class="ss">little</span><span class="p" data-group-id="9192301215-25">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9192301215-26">&lt;&lt;</span><span class="mi">16#231</span><span class="p">:</span><span class="mi">12</span><span class="p" data-group-id="9192301215-26">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9192301215-27">&lt;&lt;</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p" data-group-id="9192301215-27">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9192301215-28">&lt;&lt;</span><span class="mi">35</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p" data-group-id="9192301215-28">&gt;&gt;</span></code></pre><p>Notice that bit string patterns cannot be nested.</p><p>Notice also that &quot;<code class="inline">B=&lt;&lt;1&gt;&gt;</code>&quot; is interpreted as &quot;<code class="inline">B =&lt; &lt;1&gt;&gt;</code>&quot; which is a syntax
error. The correct way is to write a space after <code class="inline">=</code>: &quot;<code class="inline">B = &lt;&lt;1&gt;&gt;</code>.</p><p>More examples are provided in <a href="../system/bit_syntax.html">Programming Examples</a>.</p><h2 id="fun-expressions" class="section-heading"><a href="#fun-expressions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Fun Expressions</span></h2><pre><code class="makeup erlang" translate="no"><span class="k">fun</span><span class="w">
    </span><span class="p" data-group-id="9959759117-1">[</span><span class="n">Name</span><span class="p" data-group-id="9959759117-1">]</span><span class="p" data-group-id="9959759117-2">(</span><span class="n">Pattern11</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="n">Pattern1N</span><span class="p" data-group-id="9959759117-2">)</span><span class="w"> </span><span class="p" data-group-id="9959759117-3">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeq1</span><span class="p" data-group-id="9959759117-3">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
              </span><span class="n">Body1</span><span class="p">;</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">;</span><span class="w">
    </span><span class="p" data-group-id="9959759117-4">[</span><span class="n">Name</span><span class="p" data-group-id="9959759117-4">]</span><span class="p" data-group-id="9959759117-5">(</span><span class="n">PatternK1</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="n">PatternKN</span><span class="p" data-group-id="9959759117-5">)</span><span class="w"> </span><span class="p" data-group-id="9959759117-6">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeqK</span><span class="p" data-group-id="9959759117-6">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
              </span><span class="n">BodyK</span><span class="w">
</span><span class="k">end</span></code></pre><p>A fun expression begins with the keyword <code class="inline">fun</code> and ends with the keyword <code class="inline">end</code>.
Between them is to be a function declaration, similar to a
<a href="ref_man_functions.html#function-declaration-syntax">regular function declaration</a>,
except that the function name is optional and is to be a variable, if any.</p><p>Variables in a fun head shadow the function name and both shadow variables in
the function clause surrounding the fun expression. Variables bound in a fun
body are local to the fun body.</p><p>The return value of the expression is the resulting fun.</p><p><em>Examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="n">Fun1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">fun</span><span class="w"> </span><span class="p" data-group-id="4095808101-1">(</span><span class="n">X</span><span class="p" data-group-id="4095808101-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">X</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="k">end</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">erl_eval</span><span class="p">.</span><span class="mf">6.39074546</span><span class="o">&gt;</span><span class="gp unselectable">
2&gt; </span><span class="n">Fun1</span><span class="p" data-group-id="4095808101-2">(</span><span class="mi">2</span><span class="p" data-group-id="4095808101-2">)</span><span class="p">.</span><span class="w">
</span><span class="mi">3</span><span class="gp unselectable">
3&gt; </span><span class="n">Fun2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">fun</span><span class="w"> </span><span class="p" data-group-id="4095808101-3">(</span><span class="n">X</span><span class="p" data-group-id="4095808101-3">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="n">X</span><span class="o">&gt;=</span><span class="mi">5</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="ss">gt</span><span class="p">;</span><span class="w"> </span><span class="p" data-group-id="4095808101-4">(</span><span class="n">X</span><span class="p" data-group-id="4095808101-4">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="ss">lt</span><span class="w"> </span><span class="k">end</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">erl_eval</span><span class="p">.</span><span class="mf">6.39074546</span><span class="o">&gt;</span><span class="gp unselectable">
4&gt; </span><span class="n">Fun2</span><span class="p" data-group-id="4095808101-5">(</span><span class="mi">7</span><span class="p" data-group-id="4095808101-5">)</span><span class="p">.</span><span class="w">
</span><span class="ss">gt</span><span class="gp unselectable">
5&gt; </span><span class="n">Fun3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">Fact</span><span class="p" data-group-id="4095808101-6">(</span><span class="mi">1</span><span class="p" data-group-id="4095808101-6">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">Fact</span><span class="p" data-group-id="4095808101-7">(</span><span class="n">X</span><span class="p" data-group-id="4095808101-7">)</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Fact</span><span class="p" data-group-id="4095808101-8">(</span><span class="n">X</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="4095808101-8">)</span><span class="w"> </span><span class="k">end</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">erl_eval</span><span class="p">.</span><span class="mf">6.39074546</span><span class="o">&gt;</span><span class="gp unselectable">
6&gt; </span><span class="n">Fun3</span><span class="p" data-group-id="4095808101-9">(</span><span class="mi">4</span><span class="p" data-group-id="4095808101-9">)</span><span class="p">.</span><span class="w">
</span><span class="mi">24</span></code></pre><p>The following fun expressions are also allowed:</p><pre><code class="makeup erlang" translate="no"><span class="k">fun</span><span class="w"> </span><span class="n">Name</span><span class="o">/</span><span class="n">Arity</span><span class="w">
</span><span class="k">fun</span><span class="w"> </span><span class="n">Module</span><span class="p">:</span><span class="n">Name</span><span class="o">/</span><span class="n">Arity</span></code></pre><p>In <code class="inline">Name/Arity</code>, <code class="inline">Name</code> is an atom and <code class="inline">Arity</code> is an integer. <code class="inline">Name/Arity</code> must
specify an existing local function. The expression is syntactic sugar for:</p><pre><code class="makeup erlang" translate="no"><span class="nf">fun</span><span class="w"> </span><span class="p" data-group-id="1833229888-1">(</span><span class="n">Arg1</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="n">ArgN</span><span class="p" data-group-id="1833229888-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">Name</span><span class="p" data-group-id="1833229888-2">(</span><span class="n">Arg1</span><span class="p">,</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="n">ArgN</span><span class="p" data-group-id="1833229888-2">)</span><span class="w"> </span><span class="k">end</span></code></pre><p>In <code class="inline">Module:Name/Arity</code>, <code class="inline">Module</code>, and <code class="inline">Name</code> are atoms and <code class="inline">Arity</code> is an
integer. <code class="inline">Module</code>, <code class="inline">Name</code>, and <code class="inline">Arity</code> can also be variables. A fun defined in
this way refers to the function <code class="inline">Name</code> with arity <code class="inline">Arity</code> in the <em>latest</em>
version of module <code class="inline">Module</code>. A fun defined in this way is not dependent on the
code for the module in which it is defined.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>Before Erlang/OTP R15, <code class="inline">Module</code>, <code class="inline">Name</code>, and <code class="inline">Arity</code> were not allowed to be
variables.</p></section><p>More examples are provided in <a href="../system/funs.html">Programming Examples</a>.</p><h2 id="catch-and-throw" class="section-heading"><a href="#catch-and-throw" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Catch and Throw</span></h2><pre><code class="makeup erlang" translate="no"><span class="k">catch</span><span class="w"> </span><span class="n">Expr</span></code></pre><p>Returns the value of <code class="inline">Expr</code> unless an exception is raised during the evaluation. In
that case, the exception is caught. The return value depends on the class of the
exception:</p><ul><li><p><strong><code class="inline">error</code></strong> (a run-time error or the code called <a href="../apps/erts/erlang.html#error/1"><code class="inline">error(Term)</code></a>) -
<code class="inline">{'EXIT',{Reason,Stack}}</code> is returned.</p></li><li><p><strong><code class="inline">exit</code></strong> (the code called <a href="../apps/erts/erlang.html#exit/1"><code class="inline">exit(Term)</code></a>) - <code class="inline">{'EXIT',Term}</code> is returned.</p></li><li><p><strong><code class="inline">throw</code></strong> (the code called <a href="../apps/erts/erlang.html#throw/1"><code class="inline">throw(Term)</code></a>): <code class="inline">Term</code> is returned.</p></li></ul><p><code class="inline">Reason</code> depends on the type of error that occurred, and <code class="inline">Stack</code> is the stack of
recent function calls, see <a href="errors.html#exit_reasons">Exit Reasons</a>.</p><p><em>Examples:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="k">catch</span><span class="w"> </span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">.</span><span class="w">
</span><span class="mi">3</span><span class="gp unselectable">
2&gt; </span><span class="k">catch</span><span class="w"> </span><span class="mi">1</span><span class="o">+</span><span class="ss">a</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="7737353580-1">{</span><span class="ss">&#39;EXIT&#39;</span><span class="p">,</span><span class="p" data-group-id="7737353580-2">{</span><span class="ss">badarith</span><span class="p">,</span><span class="p" data-group-id="7737353580-3">[</span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p" data-group-id="7737353580-3">]</span><span class="p" data-group-id="7737353580-2">}</span><span class="p" data-group-id="7737353580-1">}</span></code></pre><p>The BIF <a href="../apps/erts/erlang.html#throw/1"><code class="inline">throw(Any)</code></a> can be used for non-local return from a
function. It must be evaluated within a <code class="inline">catch</code>, which returns the value <code class="inline">Any</code>.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">3&gt; </span><span class="k">catch</span><span class="w"> </span><span class="nf">throw</span><span class="p" data-group-id="3757617338-1">(</span><span class="ss">hello</span><span class="p" data-group-id="3757617338-1">)</span><span class="p">.</span><span class="w">
</span><span class="ss">hello</span></code></pre><p>If <a href="../apps/erts/erlang.html#throw/1"><code class="inline">throw/1</code></a> is not evaluated within a catch, a <code class="inline">nocatch</code> run-time
error occurs.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>Before Erlang/OTP 24, the <code class="inline">catch</code> operator had the lowest precedence, making
it necessary to add parentheses when combining it with the <code class="inline">match</code> operator:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="2829563404-1">(</span><span class="k">catch</span><span class="w"> </span><span class="mi">42</span><span class="p" data-group-id="2829563404-1">)</span><span class="p">.</span><span class="w">
</span><span class="mi">42</span><span class="gp unselectable">
2&gt; </span><span class="n">A</span><span class="p">.</span><span class="w">
</span><span class="mi">42</span></code></pre><p>Starting from Erlang/OTP 24, the parentheses can be omitted:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="mi">42</span><span class="p">.</span><span class="w">
</span><span class="mi">42</span><span class="gp unselectable">
2&gt; </span><span class="n">A</span><span class="p">.</span><span class="w">
</span><span class="mi">42</span></code></pre></section><h2 id="try" class="section-heading"><a href="#try" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Try</span></h2><pre><code class="makeup erlang" translate="no"><span class="k">try</span><span class="w"> </span><span class="n">Exprs</span><span class="w">
</span><span class="k">catch</span><span class="w">
    </span><span class="n">Class1</span><span class="p">:</span><span class="n">ExceptionPattern1</span><span class="p" data-group-id="8238703400-1">[</span><span class="p">:</span><span class="n">Stacktrace</span><span class="p" data-group-id="8238703400-1">]</span><span class="w"> </span><span class="p" data-group-id="8238703400-2">[</span><span class="k">when</span><span class="w"> </span><span class="n">ExceptionGuardSeq1</span><span class="p" data-group-id="8238703400-2">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">ExceptionBody1</span><span class="p">;</span><span class="w">
    </span><span class="n">ClassN</span><span class="p">:</span><span class="n">ExceptionPatternN</span><span class="p" data-group-id="8238703400-3">[</span><span class="p">:</span><span class="n">Stacktrace</span><span class="p" data-group-id="8238703400-3">]</span><span class="w"> </span><span class="p" data-group-id="8238703400-4">[</span><span class="k">when</span><span class="w"> </span><span class="n">ExceptionGuardSeqN</span><span class="p" data-group-id="8238703400-4">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">ExceptionBodyN</span><span class="w">
</span><span class="k">end</span></code></pre><p>This is an enhancement of <a href="expressions.html#catch-and-throw">catch</a>. It gives the
possibility to:</p><ul><li>Distinguish between different exception classes.</li><li>Choose to handle only the desired ones.</li><li>Passing the others on to an enclosing <code class="inline">try</code> or <code class="inline">catch</code>, or to default error
handling.</li></ul><p>Notice that although the keyword <code class="inline">catch</code> is used in the <code class="inline">try</code> expression, there
is not a <code class="inline">catch</code> expression within the <code class="inline">try</code> expression.</p><p>It returns the value of <code class="inline">Exprs</code> (a sequence of expressions <code class="inline">Expr1, ..., ExprN</code>)
unless an exception occurs during the evaluation. In that case the exception is
caught and the patterns <code class="inline">ExceptionPattern</code> with the right exception class
<code class="inline">Class</code> are sequentially matched against the caught exception. If a match
succeeds and the optional guard sequence <code class="inline">ExceptionGuardSeq</code> is true, the
corresponding <code class="inline">ExceptionBody</code> is evaluated to become the return value.</p><p><code class="inline">Stacktrace</code>, if specified, must be the name of a variable (not a pattern). The
stack trace is bound to the variable when the corresponding <code class="inline">ExceptionPattern</code>
matches.</p><p>If an exception occurs during evaluation of <code class="inline">Exprs</code> but there is no matching
<code class="inline">ExceptionPattern</code> of the right <code class="inline">Class</code> with a true guard sequence, the
exception is passed on as if <code class="inline">Exprs</code> had not been enclosed in a <code class="inline">try</code>
expression.</p><p>If an exception occurs during evaluation of <code class="inline">ExceptionBody</code>, it is not caught.</p><p>It is allowed to omit <code class="inline">Class</code> and <code class="inline">Stacktrace</code>. An omitted <code class="inline">Class</code> is shorthand
for <code class="inline">throw</code>:</p><pre><code class="makeup erlang" translate="no"><span class="k">try</span><span class="w"> </span><span class="n">Exprs</span><span class="w">
</span><span class="k">catch</span><span class="w">
    </span><span class="n">ExceptionPattern1</span><span class="w"> </span><span class="p" data-group-id="6526632818-1">[</span><span class="k">when</span><span class="w"> </span><span class="n">ExceptionGuardSeq1</span><span class="p" data-group-id="6526632818-1">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">ExceptionBody1</span><span class="p">;</span><span class="w">
    </span><span class="n">ExceptionPatternN</span><span class="w"> </span><span class="p" data-group-id="6526632818-2">[</span><span class="k">when</span><span class="w"> </span><span class="n">ExceptionGuardSeqN</span><span class="p" data-group-id="6526632818-2">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">ExceptionBodyN</span><span class="w">
</span><span class="k">end</span></code></pre><p>The <code class="inline">try</code> expression can have an <code class="inline">of</code> section:</p><pre><code class="makeup erlang" translate="no"><span class="k">try</span><span class="w"> </span><span class="n">Exprs</span><span class="w"> </span><span class="k">of</span><span class="w">
    </span><span class="n">Pattern1</span><span class="w"> </span><span class="p" data-group-id="7357632067-1">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeq1</span><span class="p" data-group-id="7357632067-1">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">Body1</span><span class="p">;</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">;</span><span class="w">
    </span><span class="n">PatternN</span><span class="w"> </span><span class="p" data-group-id="7357632067-2">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeqN</span><span class="p" data-group-id="7357632067-2">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">BodyN</span><span class="w">
</span><span class="k">catch</span><span class="w">
    </span><span class="n">Class1</span><span class="p">:</span><span class="n">ExceptionPattern1</span><span class="p" data-group-id="7357632067-3">[</span><span class="p">:</span><span class="n">Stacktrace</span><span class="p" data-group-id="7357632067-3">]</span><span class="w"> </span><span class="p" data-group-id="7357632067-4">[</span><span class="k">when</span><span class="w"> </span><span class="n">ExceptionGuardSeq1</span><span class="p" data-group-id="7357632067-4">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">ExceptionBody1</span><span class="p">;</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">;</span><span class="w">
    </span><span class="n">ClassN</span><span class="p">:</span><span class="n">ExceptionPatternN</span><span class="p" data-group-id="7357632067-5">[</span><span class="p">:</span><span class="n">Stacktrace</span><span class="p" data-group-id="7357632067-5">]</span><span class="w"> </span><span class="p" data-group-id="7357632067-6">[</span><span class="k">when</span><span class="w"> </span><span class="n">ExceptionGuardSeqN</span><span class="p" data-group-id="7357632067-6">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">ExceptionBodyN</span><span class="w">
</span><span class="k">end</span></code></pre><p>If the evaluation of <code class="inline">Exprs</code> succeeds without an exception, the patterns
<code class="inline">Pattern</code> are sequentially matched against the result in the same way as for a
<a href="expressions.html#case">case</a> expression, except that if the matching fails, a
<code class="inline">try_clause</code> run-time error occurs instead of a <code class="inline">case_clause</code>.</p><p>Only exceptions occurring during the evaluation of <code class="inline">Exprs</code> can be caught by the
<code class="inline">catch</code> section. Exceptions occurring in a <code class="inline">Body</code> or due to a failed match are
not caught.</p><p>The <code class="inline">try</code> expression can also be augmented with an <code class="inline">after</code> section, intended to
be used for cleanup with side effects:</p><pre><code class="makeup erlang" translate="no"><span class="k">try</span><span class="w"> </span><span class="n">Exprs</span><span class="w"> </span><span class="k">of</span><span class="w">
    </span><span class="n">Pattern1</span><span class="w"> </span><span class="p" data-group-id="4116476450-1">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeq1</span><span class="p" data-group-id="4116476450-1">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">Body1</span><span class="p">;</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">;</span><span class="w">
    </span><span class="n">PatternN</span><span class="w"> </span><span class="p" data-group-id="4116476450-2">[</span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeqN</span><span class="p" data-group-id="4116476450-2">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">BodyN</span><span class="w">
</span><span class="k">catch</span><span class="w">
    </span><span class="n">Class1</span><span class="p">:</span><span class="n">ExceptionPattern1</span><span class="p" data-group-id="4116476450-3">[</span><span class="p">:</span><span class="n">Stacktrace</span><span class="p" data-group-id="4116476450-3">]</span><span class="w"> </span><span class="p" data-group-id="4116476450-4">[</span><span class="k">when</span><span class="w"> </span><span class="n">ExceptionGuardSeq1</span><span class="p" data-group-id="4116476450-4">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">ExceptionBody1</span><span class="p">;</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">;</span><span class="w">
    </span><span class="n">ClassN</span><span class="p">:</span><span class="n">ExceptionPatternN</span><span class="p" data-group-id="4116476450-5">[</span><span class="p">:</span><span class="n">Stacktrace</span><span class="p" data-group-id="4116476450-5">]</span><span class="w"> </span><span class="p" data-group-id="4116476450-6">[</span><span class="k">when</span><span class="w"> </span><span class="n">ExceptionGuardSeqN</span><span class="p" data-group-id="4116476450-6">]</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">ExceptionBodyN</span><span class="w">
</span><span class="k">after</span><span class="w">
    </span><span class="n">AfterBody</span><span class="w">
</span><span class="k">end</span></code></pre><p><code class="inline">AfterBody</code> is evaluated after either <code class="inline">Body</code> or <code class="inline">ExceptionBody</code>, no matter which
one. The evaluated value of <code class="inline">AfterBody</code> is lost; the return value of the <code class="inline">try</code>
expression is the same with an <code class="inline">after</code> section as without.</p><p>Even if an exception occurs during evaluation of <code class="inline">Body</code> or <code class="inline">ExceptionBody</code>,
<code class="inline">AfterBody</code> is evaluated. In this case the exception is passed on after
<code class="inline">AfterBody</code> has been evaluated, so the exception from the <code class="inline">try</code> expression is
the same with an <code class="inline">after</code> section as without.</p><p>If an exception occurs during evaluation of <code class="inline">AfterBody</code> itself, it is not
caught. So if <code class="inline">AfterBody</code> is evaluated after an exception in <code class="inline">Exprs</code>, <code class="inline">Body</code>, or
<code class="inline">ExceptionBody</code>, that exception is lost and masked by the exception in
<code class="inline">AfterBody</code>.</p><p>The <code class="inline">of</code>, <code class="inline">catch</code>, and <code class="inline">after</code> sections are all optional, as long as there is at
least a <code class="inline">catch</code> or an <code class="inline">after</code> section. So the following are valid <code class="inline">try</code>
expressions:</p><pre><code class="makeup erlang" translate="no"><span class="k">try</span><span class="w"> </span><span class="n">Exprs</span><span class="w"> </span><span class="k">of</span><span class="w">
    </span><span class="n">Pattern</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="n">GuardSeq</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">Body</span><span class="w">
</span><span class="k">after</span><span class="w">
    </span><span class="n">AfterBody</span><span class="w">
</span><span class="k">end</span><span class="w">

</span><span class="k">try</span><span class="w"> </span><span class="n">Exprs</span><span class="w">
</span><span class="k">catch</span><span class="w">
    </span><span class="n">ExpressionPattern</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">ExpressionBody</span><span class="w">
</span><span class="k">after</span><span class="w">
    </span><span class="n">AfterBody</span><span class="w">
</span><span class="k">end</span><span class="w">

</span><span class="k">try</span><span class="w"> </span><span class="n">Exprs</span><span class="w"> </span><span class="k">after</span><span class="w"> </span><span class="n">AfterBody</span><span class="w"> </span><span class="k">end</span></code></pre><p>Next is an example of using <code class="inline">after</code>. This closes the file, even in the event of
exceptions in <a href="../apps/kernel/file.html#read/2"><code class="inline">file:read/2</code></a> or in <a href="../apps/erts/erlang.html#binary_to_term/1"><code class="inline">binary_to_term/1</code></a>. The
exceptions are the same as without the <code class="inline">try</code>...<code class="inline">after</code>...<code class="inline">end</code> expression:</p><pre><code class="makeup erlang" translate="no"><span class="nf">termize_file</span><span class="p" data-group-id="2212068029-1">(</span><span class="n">Name</span><span class="p" data-group-id="2212068029-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="p" data-group-id="2212068029-2">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">F</span><span class="p" data-group-id="2212068029-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">open</span><span class="p" data-group-id="2212068029-3">(</span><span class="n">Name</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2212068029-4">[</span><span class="ss">read</span><span class="p">,</span><span class="ss">binary</span><span class="p" data-group-id="2212068029-4">]</span><span class="p" data-group-id="2212068029-3">)</span><span class="p">,</span><span class="w">
    </span><span class="k">try</span><span class="w">
        </span><span class="p" data-group-id="2212068029-5">{</span><span class="ss">ok</span><span class="p">,</span><span class="n">Bin</span><span class="p" data-group-id="2212068029-5">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">file</span><span class="p">:</span><span class="nf">read</span><span class="p" data-group-id="2212068029-6">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p" data-group-id="2212068029-6">)</span><span class="p">,</span><span class="w">
        </span><span class="nf">binary_to_term</span><span class="p" data-group-id="2212068029-7">(</span><span class="n">Bin</span><span class="p" data-group-id="2212068029-7">)</span><span class="w">
    </span><span class="k">after</span><span class="w">
        </span><span class="nc">file</span><span class="p">:</span><span class="nf">close</span><span class="p" data-group-id="2212068029-8">(</span><span class="n">F</span><span class="p" data-group-id="2212068029-8">)</span><span class="w">
    </span><span class="k">end</span><span class="p">.</span></code></pre><p>Next is an example of using <code class="inline">try</code> to emulate <code class="inline">catch Expr</code>:</p><pre><code class="makeup erlang" translate="no"><span class="k">try</span><span class="w"> </span><span class="n">Expr</span><span class="w">
</span><span class="k">catch</span><span class="w">
    </span><span class="nc">throw</span><span class="p">:</span><span class="n">Term</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">Term</span><span class="p">;</span><span class="w">
    </span><span class="nc">exit</span><span class="p">:</span><span class="n">Reason</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="2595534666-1">{</span><span class="ss">&#39;EXIT&#39;</span><span class="p">,</span><span class="n">Reason</span><span class="p" data-group-id="2595534666-1">}</span><span class="p">;</span><span class="w">
    </span><span class="nc">error</span><span class="p">:</span><span class="n">Reason</span><span class="p">:</span><span class="n">Stk</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p" data-group-id="2595534666-2">{</span><span class="ss">&#39;EXIT&#39;</span><span class="p">,</span><span class="p" data-group-id="2595534666-3">{</span><span class="n">Reason</span><span class="p">,</span><span class="n">Stk</span><span class="p" data-group-id="2595534666-3">}</span><span class="p" data-group-id="2595534666-2">}</span><span class="w">
</span><span class="k">end</span></code></pre><p>Variables bound in the various parts of these expressions have different scopes.
Variables bound just after the <code class="inline">try</code> keyword are:</p><ul><li>bound in the <code class="inline">of</code> section</li><li>unsafe in both the <code class="inline">catch</code> and <code class="inline">after</code> sections, as well as after the whole
construct</li></ul><p>Variables bound in <code class="inline">of</code> section are:</p><ul><li>unbound in the <code class="inline">catch</code> section</li><li>unsafe in both the <code class="inline">after</code> section, as well as after the whole construct</li></ul><p>Variables bound in the <code class="inline">catch</code> section are unsafe in the <code class="inline">after</code> section, as
well as after the whole construct.</p><p>Variables bound in the <code class="inline">after</code> section are unsafe after the whole construct.</p><h2 id="parenthesized-expressions" class="section-heading"><a href="#parenthesized-expressions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Parenthesized Expressions</span></h2><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="0697963858-1">(</span><span class="n">Expr</span><span class="p" data-group-id="0697963858-1">)</span></code></pre><p>Parenthesized expressions are useful to override
<a href="expressions.html#prec">operator precedences</a>, for example, in arithmetic
expressions:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">.</span><span class="w">
</span><span class="mi">7</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="9015891211-1">(</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="9015891211-1">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">.</span><span class="w">
</span><span class="mi">9</span></code></pre><h2 id="block-expressions" class="section-heading"><a href="#block-expressions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Block Expressions</span></h2><pre><code class="makeup erlang" translate="no"><span class="k">begin</span><span class="w">
   </span><span class="n">Expr1</span><span class="p">,</span><span class="w">
   </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">,</span><span class="w">
   </span><span class="n">ExprN</span><span class="w">
</span><span class="k">end</span></code></pre><p>Block expressions provide a way to group a sequence of expressions, similar to a
clause body. The return value is the value of the last expression <code class="inline">ExprN</code>.</p><p><a href="" id="lcs"></a></p><h2 id="comprehensions" class="section-heading"><a href="#comprehensions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Comprehensions</span></h2><p>Comprehensions provide a succinct notation for iterating over one or more terms
and constructing a new term. Comprehensions come in three different flavors,
depending on the type of term they build.</p><p>List comprehensions construct lists. They have the following syntax:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="9997520369-1">[</span><span class="n">Expr</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">Qualifier1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="n">QualifierN</span><span class="p" data-group-id="9997520369-1">]</span></code></pre><p>Here, <code class="inline">Expr</code> is an arbitrary expression, and each <code class="inline">Qualifier</code> is either a
<strong>generator</strong> or a <strong>filter</strong>.</p><p>Bit string comprehensions construct bit strings or binaries. They have the
following syntax:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="8005265633-1">&lt;&lt;</span><span class="w"> </span><span class="n">BitStringExpr</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">Qualifier1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="n">QualifierN</span><span class="w"> </span><span class="p" data-group-id="8005265633-1">&gt;&gt;</span></code></pre><p><code class="inline">BitStringExpr</code> is an expression that evaluates to a bit string. If
<code class="inline">BitStringExpr</code> is a function call, it must be enclosed in parentheses. Each
<code class="inline">Qualifier</code> is either a <strong>generator</strong> or a <strong>filter</strong>.</p><p>Map comprehensions construct maps. They have the following syntax:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="9592698054-1">#{</span><span class="n">KeyExpr</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">ValueExpr</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">Qualifier1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="p">,</span><span class="w"> </span><span class="n">QualifierN</span><span class="p" data-group-id="9592698054-1">}</span></code></pre><p>Here, <code class="inline">KeyExpr</code> and <code class="inline">ValueExpr</code> are arbitrary expressions, and each <code class="inline">Qualifier</code>
is either a <strong>generator</strong> or a <strong>filter</strong>.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>Map comprehensions and map generators were introduced in Erlang/OTP 26.</p></section><p>There are four kinds of generators. Three of them have a relaxed and a strict
variant. The fourth kind of generator, zip generator, is composed by two or
more non-zip generators.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>Strict generators and zip generators were introduced in Erlang/OTP 28.
Using strict generators is a better practice when either strict or relaxed
generators work. More details are in
<a href="../system/list_comprehensions.html">Programming Examples.</a></p></section><p>A <em>list generator</em> has the following syntax for relaxed:</p><pre><code class="makeup erlang" translate="no"><span class="n">Pattern</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ListExpr</span></code></pre><p>and strict variant:</p><pre><code class="makeup erlang" translate="no"><span class="n">Pattern</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="n">ListExpr</span></code></pre><p>where <code class="inline">ListExpr</code> is an expression that evaluates to a list of terms.</p><p>A <em>bit string generator</em> has the following syntax for relaxed:</p><pre><code class="makeup erlang" translate="no"><span class="n">BitstringPattern</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">BitStringExpr</span></code></pre><p>and strict variant:</p><pre><code class="makeup erlang" translate="no"><span class="n">BitstringPattern</span><span class="w"> </span><span class="o">&lt;:=</span><span class="w"> </span><span class="n">BitStringExpr</span></code></pre><p>where <code class="inline">BitStringExpr</code> is an expression that evaluates to a bit string.</p><p>A <em>map generator</em> has the following syntax for relaxed:</p><pre><code class="makeup erlang" translate="no"><span class="n">KeyPattern</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">ValuePattern</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">MapExpression</span></code></pre><p>and strict variant:</p><pre><code class="makeup erlang" translate="no"><span class="n">KeyPattern</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">ValuePattern</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="n">MapExpression</span></code></pre><p>where <code class="inline">MapExpr</code> is an expression that evaluates to a map, or a map iterator
obtained by calling <a href="../apps/stdlib/maps.html#iterator/1"><code class="inline">maps:iterator/1</code></a> or <a href="../apps/stdlib/maps.html#iterator/2"><code class="inline">maps:iterator/2</code></a>.</p><p>A <em>zip generator</em> has the following syntax:</p><pre><code class="makeup erlang" translate="no"><span class="n">Generator_1</span><span class="w"> </span><span class="p">&amp;&amp;</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="p">&amp;&amp;</span><span class="w"> </span><span class="n">Generator_n</span></code></pre><p>where every <code class="inline">Generator_i</code> is a non-zip generator. Generators within a zip
generator are treated as one generator and evaluated in parallel.</p><p>A <em>filter</em> is an expression that evaluates to <code class="inline">true</code> or <code class="inline">false</code>.</p><p>The variables in the generator patterns shadow previously bound variables,
including variables bound in a previous generator pattern.</p><p>Variables bound in a generator expression are not visible outside the
expression:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="7074015712-1">[</span><span class="p" data-group-id="7074015712-2">{</span><span class="n">E</span><span class="p">,</span><span class="n">L</span><span class="p" data-group-id="7074015712-2">}</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">L</span><span class="o">=</span><span class="p" data-group-id="7074015712-3">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="7074015712-3">]</span><span class="p" data-group-id="7074015712-1">]</span><span class="p">.</span><span class="w">
</span><span class="gt">* 1:5: variable &#39;L&#39; is unbound</span></code></pre><p>A <strong>list comprehension</strong> returns a list, where the list elements are the result
of evaluating <code class="inline">Expr</code> for each combination of generator elements for which all
filters are true.</p><p>A <strong>bit string comprehension</strong> returns a bit string, which is created by
concatenating the results of evaluating <code class="inline">BitStringExpr</code> for each combination of
bit string generator elements for which all filters are true.</p><p>A <strong>map comprehension</strong> returns a map, where the map elements are the result of
evaluating <code class="inline">KeyExpr</code> and <code class="inline">ValueExpr</code> for each combination of generator elements
for which all filters are true. If the key expressions are not unique, the last
occurrence is stored in the map.</p><p><strong>Examples:</strong></p><p>Multiplying each element in a list by two:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="6430563452-1">[</span><span class="n">X</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="p" data-group-id="6430563452-2">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="6430563452-2">]</span><span class="p" data-group-id="6430563452-1">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="6430563452-3">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p" data-group-id="6430563452-3">]</span></code></pre><p>Multiplying each byte in a binary by two, returning a list:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="9298688037-1">[</span><span class="n">X</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="p" data-group-id="9298688037-2">&lt;&lt;</span><span class="n">X</span><span class="p" data-group-id="9298688037-2">&gt;&gt;</span><span class="w"> </span><span class="o">&lt;:=</span><span class="w"> </span><span class="p" data-group-id="9298688037-3">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="9298688037-3">&gt;&gt;</span><span class="p" data-group-id="9298688037-1">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="9298688037-4">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p" data-group-id="9298688037-4">]</span></code></pre><p>Multiplying each byte in a binary by two:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="1728224536-1">&lt;&lt;</span><span class="w"> </span><span class="p" data-group-id="1728224536-2">&lt;&lt;</span><span class="p" data-group-id="1728224536-3">(</span><span class="n">X</span><span class="o">*</span><span class="mi">2</span><span class="p" data-group-id="1728224536-3">)</span><span class="p" data-group-id="1728224536-2">&gt;&gt;</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="p" data-group-id="1728224536-4">&lt;&lt;</span><span class="n">X</span><span class="p" data-group-id="1728224536-4">&gt;&gt;</span><span class="w"> </span><span class="o">&lt;:=</span><span class="w"> </span><span class="p" data-group-id="1728224536-5">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="1728224536-5">&gt;&gt;</span><span class="w"> </span><span class="p" data-group-id="1728224536-1">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1728224536-6">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p" data-group-id="1728224536-6">&gt;&gt;</span></code></pre><p>Multiplying each element in a list by two, returning a binary:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="7152817623-1">&lt;&lt;</span><span class="w"> </span><span class="p" data-group-id="7152817623-2">&lt;&lt;</span><span class="p" data-group-id="7152817623-3">(</span><span class="n">X</span><span class="o">*</span><span class="mi">2</span><span class="p" data-group-id="7152817623-3">)</span><span class="p" data-group-id="7152817623-2">&gt;&gt;</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="p" data-group-id="7152817623-4">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="7152817623-4">]</span><span class="w"> </span><span class="p" data-group-id="7152817623-1">&gt;&gt;</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="7152817623-5">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p" data-group-id="7152817623-5">&gt;&gt;</span></code></pre><p>Creating a mapping from an integer to its square:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="0446331398-1">#{</span><span class="n">X</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">X</span><span class="o">*</span><span class="n">X</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="p" data-group-id="0446331398-2">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="0446331398-2">]</span><span class="p" data-group-id="0446331398-1">}</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="0446331398-3">#{</span><span class="mi">1</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">9</span><span class="p" data-group-id="0446331398-3">}</span></code></pre><p>Multiplying the value of each element in a map by two:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="2988430937-1">#{</span><span class="n">K</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">V</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">K</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="p" data-group-id="2988430937-2">#{</span><span class="ss">a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="ss">b</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="ss">c</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="2988430937-2">}</span><span class="p" data-group-id="2988430937-1">}</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2988430937-3">#{</span><span class="ss">a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="ss">b</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="ss">c</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">6</span><span class="p" data-group-id="2988430937-3">}</span></code></pre><p>Filtering a list, keeping odd numbers:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="3623701225-1">[</span><span class="n">X</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="p" data-group-id="3623701225-2">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="3623701225-2">]</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="ow">rem</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">=:=</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="3623701225-1">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="3623701225-3">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="3623701225-3">]</span></code></pre><p>Filtering a list, keeping only elements that match:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="0196516583-1">[</span><span class="n">X</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="p" data-group-id="0196516583-2">{</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p" data-group-id="0196516583-2">}</span><span class="o">=</span><span class="n">X</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p" data-group-id="0196516583-3">[</span><span class="p" data-group-id="0196516583-4">{</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p" data-group-id="0196516583-4">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0196516583-5">[</span><span class="ss">a</span><span class="p" data-group-id="0196516583-5">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0196516583-6">{</span><span class="ss">x</span><span class="p">,</span><span class="ss">y</span><span class="p">,</span><span class="ss">z</span><span class="p" data-group-id="0196516583-6">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0196516583-7">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="0196516583-7">}</span><span class="p" data-group-id="0196516583-3">]</span><span class="p" data-group-id="0196516583-1">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="0196516583-8">[</span><span class="p" data-group-id="0196516583-9">{</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p" data-group-id="0196516583-9">}</span><span class="p">,</span><span class="p" data-group-id="0196516583-10">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="0196516583-10">}</span><span class="p" data-group-id="0196516583-8">]</span></code></pre><p>Filtering a list, crashing when the element is not a 2-tuple:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="2788770347-1">[</span><span class="n">X</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="p" data-group-id="2788770347-2">{</span><span class="p">_</span><span class="p">,</span><span class="p">_</span><span class="p" data-group-id="2788770347-2">}</span><span class="o">=</span><span class="n">X</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="p" data-group-id="2788770347-3">[</span><span class="p" data-group-id="2788770347-4">{</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p" data-group-id="2788770347-4">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2788770347-5">[</span><span class="ss">a</span><span class="p" data-group-id="2788770347-5">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2788770347-6">{</span><span class="ss">x</span><span class="p">,</span><span class="ss">y</span><span class="p">,</span><span class="ss">z</span><span class="p" data-group-id="2788770347-6">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2788770347-7">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="2788770347-7">}</span><span class="p" data-group-id="2788770347-3">]</span><span class="p" data-group-id="2788770347-1">]</span><span class="p">.</span><span class="w">
</span><span class="gt">** exception error: no match of right hand side value [a]</span></code></pre><p>Combining elements from two list generators:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="2640809167-1">[</span><span class="p" data-group-id="2640809167-2">{</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p" data-group-id="2640809167-2">}</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="p" data-group-id="2640809167-3">[</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p">,</span><span class="ss">c</span><span class="p" data-group-id="2640809167-3">]</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="p" data-group-id="2640809167-4">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="2640809167-4">]</span><span class="p" data-group-id="2640809167-1">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2640809167-5">[</span><span class="p" data-group-id="2640809167-6">{</span><span class="ss">a</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="2640809167-6">}</span><span class="p">,</span><span class="p" data-group-id="2640809167-7">{</span><span class="ss">a</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="2640809167-7">}</span><span class="p">,</span><span class="p" data-group-id="2640809167-8">{</span><span class="ss">b</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="2640809167-8">}</span><span class="p">,</span><span class="p" data-group-id="2640809167-9">{</span><span class="ss">b</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="2640809167-9">}</span><span class="p">,</span><span class="p" data-group-id="2640809167-10">{</span><span class="ss">c</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="2640809167-10">}</span><span class="p">,</span><span class="p" data-group-id="2640809167-11">{</span><span class="ss">c</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="2640809167-11">}</span><span class="p" data-group-id="2640809167-5">]</span></code></pre><p>Combining elements from two list generators, using a zip generator:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="0535470326-1">[</span><span class="p" data-group-id="0535470326-2">{</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p" data-group-id="0535470326-2">}</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="p" data-group-id="0535470326-3">[</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p">,</span><span class="ss">c</span><span class="p" data-group-id="0535470326-3">]</span><span class="w"> </span><span class="p">&amp;&amp;</span><span class="w"> </span><span class="n">Q</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="p" data-group-id="0535470326-4">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="0535470326-4">]</span><span class="p" data-group-id="0535470326-1">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="0535470326-5">[</span><span class="p" data-group-id="0535470326-6">{</span><span class="ss">a</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="0535470326-6">}</span><span class="p">,</span><span class="p" data-group-id="0535470326-7">{</span><span class="ss">b</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="0535470326-7">}</span><span class="p">,</span><span class="p" data-group-id="0535470326-8">{</span><span class="ss">c</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="0535470326-8">}</span><span class="p" data-group-id="0535470326-5">]</span></code></pre><p>Combining elements from two list generators using a zip generator, filtering
out odd numbers:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="2959720989-1">[</span><span class="p" data-group-id="2959720989-2">{</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p" data-group-id="2959720989-2">}</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="p" data-group-id="2959720989-3">[</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p">,</span><span class="ss">c</span><span class="p" data-group-id="2959720989-3">]</span><span class="w"> </span><span class="p">&amp;&amp;</span><span class="w"> </span><span class="n">Q</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="p" data-group-id="2959720989-4">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="2959720989-4">]</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="w"> </span><span class="ow">rem</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">=:=</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="2959720989-1">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="2959720989-5">[</span><span class="p" data-group-id="2959720989-6">{</span><span class="ss">a</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="2959720989-6">}</span><span class="p">,</span><span class="p" data-group-id="2959720989-7">{</span><span class="ss">b</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="2959720989-7">}</span><span class="p">,</span><span class="p" data-group-id="2959720989-8">{</span><span class="ss">c</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="2959720989-8">}</span><span class="p" data-group-id="2959720989-5">]</span></code></pre><p>Filtering out non-matching elements from two lists.</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="3736763719-1">[</span><span class="n">X</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p" data-group-id="3736763719-2">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="3736763719-2">]</span><span class="w"> </span><span class="p">&amp;&amp;</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p" data-group-id="3736763719-3">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p" data-group-id="3736763719-3">]</span><span class="p" data-group-id="3736763719-1">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="3736763719-4">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="3736763719-4">]</span></code></pre><p>More examples are provided in
<a href="../system/list_comprehensions.html">Programming Examples.</a></p><p>When there are no generators, a comprehension returns either a term constructed
from a single element (the result of evaluating <code class="inline">Expr</code>) if all filters are true,
or a term constructed from no elements (that is, <code class="inline">[]</code> for list comprehension,
<code class="inline">&lt;&lt;&gt;&gt;</code> for a bit string comprehension, and <code class="inline">#{}</code> for a map comprehension).</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="p" data-group-id="4943911275-1">[</span><span class="mi">2</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="nf">is_integer</span><span class="p" data-group-id="4943911275-2">(</span><span class="mi">2</span><span class="p" data-group-id="4943911275-2">)</span><span class="p" data-group-id="4943911275-1">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="4943911275-3">[</span><span class="mi">2</span><span class="p" data-group-id="4943911275-3">]</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="4943911275-4">[</span><span class="ss">x</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="nf">is_integer</span><span class="p" data-group-id="4943911275-5">(</span><span class="ss">x</span><span class="p" data-group-id="4943911275-5">)</span><span class="p" data-group-id="4943911275-4">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="4943911275-6">[</span><span class="p" data-group-id="4943911275-6">]</span></code></pre><p>What happens when the filter expression does not evaluate to a boolean value
depends on the expression:</p><ul><li>If the expression is a <a href="expressions.html#guard-expressions">guard expression</a>,
failure to evaluate or evaluating to a non-boolean value is equivalent to
evaluating to <code class="inline">false</code>.</li><li>If the expression is not a guard expression and evaluates to a non-Boolean
value <code class="inline">Val</code>, an exception <code class="inline">{bad_filter, Val}</code> is triggered at runtime. If the
evaluation of the expression raises an exception, it is not caught by the
comprehension.</li></ul><p><strong>Examples</strong> (using a guard expression as filter):</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="n">List</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1885748302-1">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p">,</span><span class="ss">c</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="1885748302-1">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1885748302-2">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p">,</span><span class="ss">c</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="1885748302-2">]</span><span class="gp unselectable">
2&gt; </span><span class="p" data-group-id="1885748302-3">[</span><span class="n">E</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="n">List</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="ow">rem</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="1885748302-3">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1885748302-4">[</span><span class="p" data-group-id="1885748302-4">]</span><span class="gp unselectable">
3&gt; </span><span class="p" data-group-id="1885748302-5">[</span><span class="n">E</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="n">List</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="ow">rem</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">=:=</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="1885748302-5">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="1885748302-6">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="1885748302-6">]</span></code></pre><p><strong>Examples</strong> (using a non-guard expression as filter):</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="n">List</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8350978311-1">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p">,</span><span class="ss">c</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="8350978311-1">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8350978311-2">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="ss">a</span><span class="p">,</span><span class="ss">b</span><span class="p">,</span><span class="ss">c</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="8350978311-2">]</span><span class="gp unselectable">
2&gt; </span><span class="n">FaultyIsEven</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">fun</span><span class="p" data-group-id="8350978311-3">(</span><span class="n">E</span><span class="p" data-group-id="8350978311-3">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="ow">rem</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">end</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">erl_eval</span><span class="p">.</span><span class="mf">42.17316486</span><span class="o">&gt;</span><span class="gp unselectable">
3&gt; </span><span class="p" data-group-id="8350978311-4">[</span><span class="n">E</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="n">List</span><span class="p">,</span><span class="w"> </span><span class="n">FaultyIsEven</span><span class="p" data-group-id="8350978311-5">(</span><span class="n">E</span><span class="p" data-group-id="8350978311-5">)</span><span class="p" data-group-id="8350978311-4">]</span><span class="p">.</span><span class="w">
</span><span class="gt">** exception error: bad filter 1</span><span class="gp unselectable">
4&gt; </span><span class="n">IsEven</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">fun</span><span class="p" data-group-id="8350978311-6">(</span><span class="n">E</span><span class="p" data-group-id="8350978311-6">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="ow">rem</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">=:=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">end</span><span class="p">.</span><span class="w">
</span><span class="p">#</span><span class="n">Fun</span><span class="o">&lt;</span><span class="ss">erl_eval</span><span class="p">.</span><span class="mf">42.17316486</span><span class="o">&gt;</span><span class="gp unselectable">
5&gt; </span><span class="p" data-group-id="8350978311-7">[</span><span class="n">E</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="n">List</span><span class="p">,</span><span class="w"> </span><span class="n">IsEven</span><span class="p" data-group-id="8350978311-8">(</span><span class="n">E</span><span class="p" data-group-id="8350978311-8">)</span><span class="p" data-group-id="8350978311-7">]</span><span class="p">.</span><span class="w">
</span><span class="gt">** exception error: an error occurred when evaluating an arithmetic expression
     in operator  rem/2
        called as a rem 2</span><span class="gp unselectable">
6&gt; </span><span class="p" data-group-id="8350978311-9">[</span><span class="n">E</span><span class="w"> </span><span class="p">||</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">&lt;:-</span><span class="w"> </span><span class="n">List</span><span class="p">,</span><span class="w"> </span><span class="nf">is_integer</span><span class="p" data-group-id="8350978311-10">(</span><span class="n">E</span><span class="p" data-group-id="8350978311-10">)</span><span class="p">,</span><span class="w"> </span><span class="n">IsEven</span><span class="p" data-group-id="8350978311-11">(</span><span class="n">E</span><span class="p" data-group-id="8350978311-11">)</span><span class="p" data-group-id="8350978311-9">]</span><span class="p">.</span><span class="w">
</span><span class="p" data-group-id="8350978311-12">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="8350978311-12">]</span></code></pre><p><a href="" id="guards"></a></p><h2 id="guard-sequences" class="section-heading"><a href="#guard-sequences" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Guard Sequences</span></h2><p>A <em>guard sequence</em> is a sequence of guards, separated by semicolon (<code class="inline">;</code>). The
guard sequence is true if at least one of the guards is true. (The remaining
guards, if any, are not evaluated.)</p><p><code class="inline">Guard1; ...; GuardK</code></p><p>A <em>guard</em> is a sequence of guard expressions, separated by comma (<code class="inline">,</code>). The guard
is true if all guard expressions evaluate to <code class="inline">true</code>.</p><p><code class="inline">GuardExpr1, ..., GuardExprN</code></p><h2 id="guard-expressions" class="section-heading"><a href="#guard-expressions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Guard Expressions</span></h2><p>The set of valid <em>guard expressions</em> is a subset of the set of valid Erlang
expressions. The reason for restricting the set of valid expressions is that
evaluation of a guard expression must be guaranteed to be free of side effects.
Valid guard expressions are the following:</p><ul><li>Variables</li><li>Constants (atoms, integer, floats, lists, tuples, records, binaries, and maps)</li><li>Expressions that construct atoms, integer, floats, lists, tuples, records,
binaries, and maps</li><li>Expressions that update a map</li><li>The record expressions <code class="inline">Expr#Name.Field</code> and <code class="inline">#Name.Field</code></li><li>Calls to the BIFs specified in tables <em>Type Test BIFs</em> and <em>Other BIFs Allowed
in Guard Expressions</em></li><li>Term comparisons</li><li>Arithmetic expressions</li><li>Boolean expressions</li><li>Short-circuit expressions (<code class="inline">andalso</code>/<code class="inline">orelse</code>)</li></ul><table><thead><tr><th style="text-align: left;">BIF</th></tr></thead><tbody><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_atom/1"><code class="inline">is_atom/1</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_binary/1"><code class="inline">is_binary/1</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_bitstring/1"><code class="inline">is_bitstring/1</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_boolean/1"><code class="inline">is_boolean/1</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_float/1"><code class="inline">is_float/1</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_function/1"><code class="inline">is_function/1</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_function/2"><code class="inline">is_function/2</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_integer/1"><code class="inline">is_integer/1</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_list/1"><code class="inline">is_list/1</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_map/1"><code class="inline">is_map/1</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_number/1"><code class="inline">is_number/1</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_pid/1"><code class="inline">is_pid/1</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_port/1"><code class="inline">is_port/1</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_record/2"><code class="inline">is_record/2</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_record/3"><code class="inline">is_record/3</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_reference/1"><code class="inline">is_reference/1</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_tuple/1"><code class="inline">is_tuple/1</code></a></td></tr></tbody></table><p><em>Table: Type Test BIFs</em></p><p>Notice that most type test BIFs have older equivalents, without the
<code class="inline">is_</code> prefix. These old BIFs are retained only for backwards
compatibility and are not to be used in new code. They are also only
allowed at top level. For example, they are not allowed in Boolean
expressions in guards.</p><table><thead><tr><th style="text-align: left;">BIF</th></tr></thead><tbody><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#abs/1"><code class="inline">abs(Number)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#bit_size/1"><code class="inline">bit_size(Bitstring)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#byte_size/1"><code class="inline">byte_size(Bitstring)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#element/2"><code class="inline">element(N, Tuple)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#float/1"><code class="inline">float(Term)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#hd/1"><code class="inline">hd(List)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#is_map_key/2"><code class="inline">is_map_key(Key, Map)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#length/1"><code class="inline">length(List)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#map_get/2"><code class="inline">map_get(Key, Map)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#map_size/1"><code class="inline">map_size(Map)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#max/2"><code class="inline">max(A, B)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#min/2"><code class="inline">min(A, B)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#node/0"><code class="inline">node/0</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#node/1"><code class="inline">node(Pid | Ref | Port)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#round/1"><code class="inline">round(Number)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#self/0"><code class="inline">self/0</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#size/1"><code class="inline">size(Tuple | Bitstring)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#tl/1"><code class="inline">tl(List)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#trunc/1"><code class="inline">trunc(Number)</code></a></td></tr><tr><td style="text-align: left;"><a href="../apps/erts/erlang.html#tuple_size/1"><code class="inline">tuple_size(Tuple)</code></a></td></tr></tbody></table><p><em>Table: Other BIFs Allowed in Guard Expressions</em></p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>The <a href="../apps/erts/erlang.html#min/2"><code class="inline">min/2</code></a> and <a href="../apps/erts/erlang.html#max/2"><code class="inline">max/2</code></a> BIFs are allowed to be used in
guards from Erlang/OTP 26.</p></section><p>If an arithmetic expression, a Boolean expression, a short-circuit expression,
or a call to a guard BIF fails (because of invalid arguments), the entire guard
fails. If the guard was part of a guard sequence, the next guard in the sequence
(that is, the guard following the next semicolon) is evaluated.</p><p><a href="" id="prec"></a></p><h2 id="operator-precedence" class="section-heading"><a href="#operator-precedence" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Operator Precedence</span></h2><p>Operator precedence in descending order:</p><table><thead><tr><th style="text-align: left;">Operator</th><th style="text-align: left;">Association</th></tr></thead><tbody><tr><td style="text-align: left;"><code class="inline">#</code></td><td style="text-align: left;"></td></tr><tr><td style="text-align: left;">Unary <code class="inline">+</code> <code class="inline">-</code> <code class="inline">bnot</code> <code class="inline">not</code></td><td style="text-align: left;"></td></tr><tr><td style="text-align: left;"><code class="inline">/</code> <code class="inline">*</code> <code class="inline">div</code> <code class="inline">rem</code> <code class="inline">band</code> <code class="inline">and</code></td><td style="text-align: left;">Left-associative</td></tr><tr><td style="text-align: left;"><code class="inline">+</code> <code class="inline">-</code> <code class="inline">bor</code> <code class="inline">bxor</code> <code class="inline">bsl</code> <code class="inline">bsr</code> <code class="inline">or</code> <code class="inline">xor</code></td><td style="text-align: left;">Left-associative</td></tr><tr><td style="text-align: left;"><code class="inline">++</code> <code class="inline">--</code></td><td style="text-align: left;">Right-associative</td></tr><tr><td style="text-align: left;"><code class="inline">==</code> <code class="inline">/=</code> <code class="inline">=&lt;</code> <code class="inline">&lt;</code> <code class="inline">&gt;=</code> <code class="inline">&gt;</code> <code class="inline">=:=</code> <code class="inline">=/=</code></td><td style="text-align: left;">Non-associative</td></tr><tr><td style="text-align: left;"><code class="inline">andalso</code></td><td style="text-align: left;">Left-associative</td></tr><tr><td style="text-align: left;"><code class="inline">orelse</code></td><td style="text-align: left;">Left-associative</td></tr><tr><td style="text-align: left;"><code class="inline">catch</code></td><td style="text-align: left;"></td></tr><tr><td style="text-align: left;"><code class="inline">=</code> <code class="inline">!</code></td><td style="text-align: left;">Right-associative</td></tr><tr><td style="text-align: left;"><code class="inline">?=</code></td><td style="text-align: left;">Non-associative</td></tr></tbody></table><p><em>Table: Operator Precedence</em></p><section role="note" class="admonition info"><h4 class="admonition-title info">Change</h4><p>Before Erlang/OTP 24, the <code class="inline">catch</code> operator had the lowest precedence.</p></section><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>The <code class="inline">=</code> operator in the table is the
<a href="expressions.html#the-match-operator">match operator</a>. The character <code class="inline">=</code> can also
denote the
<a href="expressions.html#the-compound-pattern-operator">compound pattern operator</a>, which
can only be used in patterns.</p><p><code class="inline">?=</code> is restricted in that it can only be used at the top-level inside a
<code class="inline">maybe</code> block.</p></section><p>When evaluating an expression, the operator with the highest precedence is
evaluated first. Operators with the same precedence are evaluated according to
their associativity. Non-associative operators cannot be combined with operators
of the same precedence.</p><p><em>Examples:</em></p><p>The left-associative arithmetic operators are evaluated left to right:</p><pre><code class="makeup erlang" translate="no"><span class="mi">6</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">evaluates</span><span class="w"> </span><span class="ss">to</span><span class="w">
</span><span class="mi">6</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.5</span><span class="w"> </span><span class="ss">evaluates</span><span class="w"> </span><span class="ss">to</span><span class="w">
</span><span class="mi">26</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.5</span><span class="w"> </span><span class="ss">evaluates</span><span class="w"> </span><span class="ss">to</span><span class="w">
</span><span class="mf">24.5</span></code></pre><p>The non-associative operators cannot be combined:</p><pre><code class="makeup erlang" translate="no"><span class="gp unselectable">1&gt; </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">.</span><span class="w">
</span><span class="gt">* 1:7: syntax error before: &#39;&lt;&#39;</span></code></pre>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="nominals.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Nominals
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="macros.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Preprocessor
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="Erlang System Documentation.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.38.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright © 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
