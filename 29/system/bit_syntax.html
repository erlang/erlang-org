<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.38.1">
    <meta name="project" content="Erlang System Documentation v29.0-rc0">


<meta name="major-vsn" content="29">
<meta name="exdoc:full-text-search-url" content="/doc/search.html?v=29&q=">
<link rel="canonical" href="https://www.erlang.org/doc/system/bit_syntax.html" />
    <title>Bit Syntax — Erlang System Documentation v29.0-rc0</title>

    <link rel="stylesheet" href="dist/html-erlang-ZK43ZOAC.css" />

    <script defer src="dist/sidebar_items-1026E94C.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-DPJLHKSM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="Erlang System Documentation" />
        </a>

      <div>
        <a href="../index.html" class="sidebar-projectName" translate="no">
Erlang System Documentation
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v29.0-rc0
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of Erlang System Documentation</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search" tabindex="-1">
            <i class="ri-search-2-line ri-lg" aria-hidden="true"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>Bit Syntax</h1>


      <a href="https://github.com/erlang/otp/blob/master/system/doc/programming_examples/bit_syntax.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<h2 id="introduction" class="section-heading"><a href="#introduction" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Introduction</span></h2><p>The complete specification for the bit syntax appears in the
<a href="../system/expressions.html#bit-syntax-expressions">Reference Manual</a>.</p><p>In Erlang, a Bin is used for constructing binaries and matching binary patterns.
A Bin is written with the following syntax:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="5769713484-1">&lt;&lt;</span><span class="n">E1</span><span class="p">,</span><span class="w"> </span><span class="n">E2</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="n">En</span><span class="p" data-group-id="5769713484-1">&gt;&gt;</span></code></pre><p>A Bin is a low-level sequence of bits or bytes. The purpose of a Bin is to
enable construction of binaries:</p><pre><code class="makeup erlang" translate="no"><span class="n">Bin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9635181328-1">&lt;&lt;</span><span class="n">E1</span><span class="p">,</span><span class="w"> </span><span class="n">E2</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="n">En</span><span class="p" data-group-id="9635181328-1">&gt;&gt;</span></code></pre><p>All elements must be bound. Or match a binary:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="2259549036-1">&lt;&lt;</span><span class="n">E1</span><span class="p">,</span><span class="w"> </span><span class="n">E2</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w"> </span><span class="n">En</span><span class="p" data-group-id="2259549036-1">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bin</span></code></pre><p>Here, <code class="inline">Bin</code> is bound and the elements are bound or unbound, as in any match.</p><p>A Bin does not need to consist of a whole number of bytes.</p><p>A <em>bitstring</em> is a sequence of zero or more bits, where the number of bits does
not need to be divisible by 8. If the number of bits is divisible by 8, the
bitstring is also a binary.</p><p>Each element specifies a certain <em>segment</em> of the bitstring. A segment is a set
of contiguous bits of the binary (not necessarily on a byte boundary). The first
element specifies the initial segment, the second element specifies the
following segment, and so on.</p><p>The following examples illustrate how binaries are constructed, or matched, and
how elements and tails are specified.</p><h3 id="examples" class="section-heading"><a href="#examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h3><p><em>Example 1:</em> A binary can be constructed from a set of constants or a string
literal:</p><pre><code class="makeup erlang" translate="no"><span class="n">Bin11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4609775307-1">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p" data-group-id="4609775307-1">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="n">Bin12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4609775307-2">&lt;&lt;</span><span class="s">&quot;abc&quot;</span><span class="p" data-group-id="4609775307-2">&gt;&gt;</span></code></pre><p>This gives two binaries of size 3, with the following evaluations:</p><ul><li><a href="../apps/erts/erlang.html#binary_to_list/1"><code class="inline">binary_to_list(Bin11)</code></a> evaluates to <code class="inline">[1, 17, 42]</code>.</li><li><a href="../apps/erts/erlang.html#binary_to_list/1"><code class="inline">binary_to_list(Bin12)</code></a> evaluates to <code class="inline">[97, 98, 99]</code>.</li></ul><p><em>Example 2:</em>Similarly, a binary can be constructed from a set of bound
variables:</p><pre><code class="makeup erlang" translate="no"><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w">
</span><span class="n">Bin2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="3698961478-1">&lt;&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">:</span><span class="mi">16</span><span class="p" data-group-id="3698961478-1">&gt;&gt;</span></code></pre><p>This gives a binary of size 4. Here, a <em>size expression</em> is used for the
variable <code class="inline">C</code> to specify a 16-bits segment of <code class="inline">Bin2</code>.</p><p><a href="../apps/erts/erlang.html#binary_to_list/1"><code class="inline">binary_to_list(Bin2)</code></a> evaluates to <code class="inline">[1, 17, 00, 42]</code>.</p><p><em>Example 3:</em> A Bin can also be used for matching. <code class="inline">D</code>, <code class="inline">E</code>, and <code class="inline">F</code> are unbound
variables, and <code class="inline">Bin2</code> is bound, as in Example 2:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="2235410186-1">&lt;&lt;</span><span class="n">D</span><span class="p">:</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="2235410186-1">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bin2</span></code></pre><p>This gives <code class="inline">D = 273</code>, <code class="inline">E = 00</code>, and F binds to a binary of size 1:
<code class="inline">binary_to_list(F) = [42]</code>.</p><p><em>Example 4:</em> The following is a more elaborate example of matching. Here,
<code class="inline">Dgram</code> is bound to the consecutive bytes of an IP datagram of IP protocol
version 4. The ambition is to extract the header and the data of the datagram:</p><pre><code class="makeup erlang" translate="no"><span class="p">-</span><span class="na">define</span><span class="p" data-group-id="7630653924-1">(</span><span class="n">IP_VERSION</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p" data-group-id="7630653924-1">)</span><span class="p">.</span><span class="w">
</span><span class="p">-</span><span class="na">define</span><span class="p" data-group-id="7630653924-2">(</span><span class="n">IP_MIN_HDR_LEN</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p" data-group-id="7630653924-2">)</span><span class="p">.</span><span class="w">

</span><span class="n">DgramSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">byte_size</span><span class="p" data-group-id="7630653924-3">(</span><span class="n">Dgram</span><span class="p" data-group-id="7630653924-3">)</span><span class="p">,</span><span class="w">
</span><span class="k">case</span><span class="w"> </span><span class="n">Dgram</span><span class="w"> </span><span class="k">of</span><span class="w">
    </span><span class="p" data-group-id="7630653924-4">&lt;&lt;</span><span class="o">?</span><span class="n">IP_VERSION</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">HLen</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">SrvcType</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">TotLen</span><span class="p">:</span><span class="mi">16</span><span class="p">,</span><span class="w">
      </span><span class="n">ID</span><span class="p">:</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="n">Flgs</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">FragOff</span><span class="p">:</span><span class="mi">13</span><span class="p">,</span><span class="w">
      </span><span class="n">TTL</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">Proto</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">HdrChkSum</span><span class="p">:</span><span class="mi">16</span><span class="p">,</span><span class="w">
      </span><span class="n">SrcIP</span><span class="p">:</span><span class="mi">32</span><span class="p">,</span><span class="w">
      </span><span class="n">DestIP</span><span class="p">:</span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="n">RestDgram</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="7630653924-4">&gt;&gt;</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="n">HLen</span><span class="o">&gt;=</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">HLen</span><span class="o">=&lt;</span><span class="n">DgramSize</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
        </span><span class="n">OptsLen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="p" data-group-id="7630653924-5">(</span><span class="n">HLen</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">?</span><span class="n">IP_MIN_HDR_LEN</span><span class="p" data-group-id="7630653924-5">)</span><span class="p">,</span><span class="w">
        </span><span class="p" data-group-id="7630653924-6">&lt;&lt;</span><span class="n">Opts</span><span class="p">:</span><span class="n">OptsLen</span><span class="o">/</span><span class="ss">binary</span><span class="p">,</span><span class="n">Data</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="7630653924-6">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RestDgram</span><span class="p">,</span><span class="w">
    </span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="w">
</span><span class="k">end</span><span class="p">.</span></code></pre><p>Here, the segment corresponding to the <code class="inline">Opts</code> variable has a <em>type modifier</em>,
specifying that <code class="inline">Opts</code> is to bind to a binary. All other variables have the
default type equal to unsigned integer.</p><p>An IP datagram header is of variable length. This length is measured in the
number of 32-bit words and is given in the segment corresponding to <code class="inline">HLen</code>. The
minimum value of <code class="inline">HLen</code> is 5. It is the segment corresponding to <code class="inline">Opts</code> that is
variable, so if <code class="inline">HLen</code> is equal to 5, <code class="inline">Opts</code> becomes an empty binary.</p><p>The tail variables <code class="inline">RestDgram</code> and <code class="inline">Data</code> bind to binaries, as all tail
variables do. Both can bind to empty binaries.</p><p>The match of <code class="inline">Dgram</code> fails if one of the following occurs:</p><ul><li>The first 4-bits segment of <code class="inline">Dgram</code> is not equal to 4.</li><li><code class="inline">HLen</code> is less than 5.</li><li>The size of <code class="inline">Dgram</code> is less than <code class="inline">4*HLen</code>.</li></ul><h2 id="lexical-note" class="section-heading"><a href="#lexical-note" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Lexical Note</span></h2><p>Notice that &quot;<code class="inline">B=&lt;&lt;1&gt;&gt;</code>&quot; will be interpreted as &quot;<code class="inline">B =&lt; &lt;1&gt;&gt;</code>&quot;, which is a syntax
error. The correct way to write the expression is: <code class="inline">B = &lt;&lt;1&gt;&gt;</code>.</p><h2 id="segments" class="section-heading"><a href="#segments" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Segments</span></h2><p>Each segment has the following general syntax:</p><p><code class="inline">Value:Size/TypeSpecifierList</code></p><p>The <code class="inline">Size</code> or the <code class="inline">TypeSpecifier</code>, or both, can be omitted. Thus, the following
variants are allowed:</p><ul><li><code class="inline">Value</code></li><li><code class="inline">Value:Size</code></li><li><code class="inline">Value/TypeSpecifierList</code></li></ul><p>Default values are used when specifications are missing. The default values are
described in <a href="#defaults">Defaults</a>.</p><p>The <code class="inline">Value</code> part is any expression, when used in binary construction. Used in
binary matching, the <code class="inline">Value</code> part must be a literal or a variable. For more
information about the <code class="inline">Value</code> part, see
<a href="#constructing-binaries-and-bitstrings">Constructing Binaries and Bitstrings</a>
and <a href="#matching-binaries">Matching Binaries</a>.</p><p>The <code class="inline">Size</code> part of the segment multiplied by the unit in <code class="inline">TypeSpecifierList</code>
(described later) gives the number of bits for the segment. In construction,
<code class="inline">Size</code> is any expression that evaluates to an integer. In matching, <code class="inline">Size</code> must
be a constant expression or a variable.</p><p>The <code class="inline">TypeSpecifierList</code> is a list of type specifiers separated by hyphens.</p><ul><li><p><strong>Type</strong> - The most commonly used types are <code class="inline">integer</code>, <code class="inline">float</code>, and <code class="inline">binary</code>.
See
<a href="../system/expressions.html#bit-syntax-expressions">Bit Syntax Expressions in the Reference Manual</a>
for a complete description.</p></li><li><p><strong>Signedness</strong> - The signedness specification can be either <code class="inline">signed</code> or
<code class="inline">unsigned</code>. Notice that signedness only matters for matching.</p></li><li><p><strong>Endianness</strong> - The endianness specification can be either <code class="inline">big</code>, <code class="inline">little</code>,
or <code class="inline">native</code>. Native-endian means that the endian is resolved at load time, to
be either big-endian or little-endian, depending on what is &quot;native&quot; for the
CPU that the Erlang machine is run on.</p></li><li><p><strong>Unit</strong> - The unit size is given as <code class="inline">unit:IntegerLiteral</code>. The allowed range
is 1-256. It is multiplied by the <code class="inline">Size</code> specifier to give the effective size
of the segment. The unit size specifies the alignment for binary segments
without size.</p></li></ul><p><em>Example:</em></p><pre><code class="text">X:4/little-signed-integer-unit:8</code></pre><p>This element has a total size of 4*8 = 32 bits, and it contains a signed
integer in little-endian order.</p><h2 id="defaults" class="section-heading"><a href="#defaults" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Defaults</span></h2><p>The default type for a segment is integer. The default type
does not depend on the value, even if the value is a literal. For example, the
default type in <code class="inline">&lt;&lt;3.14&gt;&gt;</code> is integer, not float.</p><p>The default <code class="inline">Size</code> depends on the type. For integer it is 8. For float it is 64.
For binary it is all of the binary. In matching, this default value is only
valid for the last element. All other binary elements in matching must have a
size specification.</p><p>The default unit depends on the type. For <code class="inline">integer</code>, <code class="inline">float</code>, and <code class="inline">bitstring</code> it
is 1. For binary it is 8.</p><p>The default signedness is <code class="inline">unsigned</code>.</p><p>The default endianness is <code class="inline">big</code>.</p><h2 id="constructing-binaries-and-bitstrings" class="section-heading"><a href="#constructing-binaries-and-bitstrings" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Constructing Binaries and Bitstrings</span></h2><p>This section describes the rules for constructing binaries using the bit syntax.
Unlike when constructing lists or tuples, the construction of a binary can fail
with a <code class="inline">badarg</code> exception.</p><p>There can be zero or more segments in a binary to be constructed. The expression
<code class="inline">&lt;&lt;&gt;&gt;</code> constructs a zero length binary.</p><p>Each segment in a binary can consist of zero or more bits. There are no
alignment rules for individual segments of type <code class="inline">integer</code> and <code class="inline">float</code>. For
binaries and bitstrings without size, the unit specifies the alignment. Since
the default alignment for the <code class="inline">binary</code> type is 8, the size of a binary segment
must be a multiple of 8 bits, that is, only whole bytes.</p><p><em>Example:</em></p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="0593858259-1">&lt;&lt;</span><span class="n">Bin</span><span class="o">/</span><span class="ss">binary</span><span class="p">,</span><span class="n">Bitstring</span><span class="o">/</span><span class="ss">bitstring</span><span class="p" data-group-id="0593858259-1">&gt;&gt;</span></code></pre><p>The variable <code class="inline">Bin</code> must contain a whole number of bytes, because the <code class="inline">binary</code>
type defaults to <code class="inline">unit:8</code>. A <code class="inline">badarg</code> exception is generated if <code class="inline">Bin</code> consist
of, for example, 17 bits.</p><p>The <code class="inline">Bitstring</code> variable can consist of any number of bits, for example, 0, 1,
8, 11, 17, 42, and so on. This is because the default <code class="inline">unit</code> for bitstrings
is 1.</p><p>For clarity, it is recommended not to change the unit size for binaries.
Instead, use <code class="inline">binary</code> when you need byte alignment and <code class="inline">bitstring</code> when you need
bit alignment.</p><p>The following example successfully constructs a bitstring of 7 bits, provided
that all of X and Y are integers:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="8752100346-1">&lt;&lt;</span><span class="n">X</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="n">Y</span><span class="p">:</span><span class="mi">6</span><span class="p" data-group-id="8752100346-1">&gt;&gt;</span></code></pre><p>As mentioned earlier, segments have the following general syntax:</p><p><code class="inline">Value:Size/TypeSpecifierList</code></p><p>When constructing binaries, <code class="inline">Value</code> and <code class="inline">Size</code> can be any Erlang expression.
However, for syntactical reasons, both <code class="inline">Value</code> and <code class="inline">Size</code> must be enclosed in
parenthesis if the expression consists of anything more than a single literal or
a variable. The following gives a compiler syntax error:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="5627163873-1">&lt;&lt;</span><span class="n">X</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="mi">8</span><span class="p" data-group-id="5627163873-1">&gt;&gt;</span></code></pre><p>This expression must be rewritten into the following, to be accepted by the
compiler:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="1078397821-1">&lt;&lt;</span><span class="p" data-group-id="1078397821-2">(</span><span class="n">X</span><span class="o">+</span><span class="mi">1</span><span class="p" data-group-id="1078397821-2">)</span><span class="p">:</span><span class="mi">8</span><span class="p" data-group-id="1078397821-1">&gt;&gt;</span></code></pre><h3 id="including-literal-strings" class="section-heading"><a href="#including-literal-strings" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Including Literal Strings</span></h3><p>A literal string can be written instead of an element:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="6775622813-1">&lt;&lt;</span><span class="s">&quot;hello&quot;</span><span class="p" data-group-id="6775622813-1">&gt;&gt;</span></code></pre><p>This is syntactic sugar for the following:</p><pre><code class="makeup erlang" translate="no"><span class="p" data-group-id="8462834541-1">&lt;&lt;</span><span class="sc">$h</span><span class="p">,</span><span class="sc">$e</span><span class="p">,</span><span class="sc">$l</span><span class="p">,</span><span class="sc">$l</span><span class="p">,</span><span class="sc">$o</span><span class="p" data-group-id="8462834541-1">&gt;&gt;</span></code></pre><h2 id="matching-binaries" class="section-heading"><a href="#matching-binaries" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Matching Binaries</span></h2><p>This section describes the rules for matching binaries, using the bit syntax.</p><p>There can be zero or more segments in a binary pattern. A binary pattern can
occur wherever patterns are allowed, including inside other patterns. Binary
patterns cannot be nested. The pattern <code class="inline">&lt;&lt;&gt;&gt;</code> matches a zero length binary.</p><p>Each segment in a binary can consist of zero or more bits. A segment of type
<code class="inline">binary</code> must have a size evenly divisible by 8 (or divisible by the unit size,
if the unit size has been changed). A segment of type <code class="inline">bitstring</code> has no
restrictions on the size. A segment of type <code class="inline">float</code> must have size 64 or 32.</p><p>As mentioned earlier, segments have the following general syntax:</p><p><code class="inline">Value:Size/TypeSpecifierList</code></p><p>When matching <code class="inline">Value</code>, value must be either a variable or an integer, or a
floating point literal. Expressions are not allowed.</p><p><code class="inline">Size</code> must be a
<a href="../system/expressions.html#guard-expressions">guard expression</a>, which can use
literals and previously bound variables. The following is not allowed:</p><pre><code class="makeup erlang" translate="no"><span class="nf">foo</span><span class="p" data-group-id="3966678060-1">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3966678060-2">&lt;&lt;</span><span class="n">X</span><span class="p">:</span><span class="n">N</span><span class="p">,</span><span class="n">T</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="3966678060-2">&gt;&gt;</span><span class="p" data-group-id="3966678060-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
   </span><span class="p" data-group-id="3966678060-3">{</span><span class="n">X</span><span class="p">,</span><span class="n">T</span><span class="p" data-group-id="3966678060-3">}</span><span class="p">.</span></code></pre><p>The two occurrences of <code class="inline">N</code> are not related. The compiler will complain that the
<code class="inline">N</code> in the size field is unbound.</p><p>The correct way to write this example is as follows:</p><pre><code class="makeup erlang" translate="no"><span class="nf">foo</span><span class="p" data-group-id="2883896884-1">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">Bin</span><span class="p" data-group-id="2883896884-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
   </span><span class="p" data-group-id="2883896884-2">&lt;&lt;</span><span class="n">X</span><span class="p">:</span><span class="n">N</span><span class="p">,</span><span class="n">T</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="2883896884-2">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bin</span><span class="p">,</span><span class="w">
   </span><span class="p" data-group-id="2883896884-3">{</span><span class="n">X</span><span class="p">,</span><span class="n">T</span><span class="p" data-group-id="2883896884-3">}</span><span class="p">.</span></code></pre><section role="note" class="admonition info"><h4 class="admonition-title info">Note</h4><p>Before OTP 23, <code class="inline">Size</code> was restricted to be an integer or a variable bound to
an integer.</p></section><h3 id="binding-and-using-a-size-variable" class="section-heading"><a href="#binding-and-using-a-size-variable" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Binding and Using a Size Variable</span></h3><p>There is one exception to the rule that a variable that is used as size must be
previously bound. It is possible to match and bind a variable, and use it as a
size within the same binary pattern. For example:</p><pre><code class="makeup erlang" translate="no"><span class="nf">bar</span><span class="p" data-group-id="2717595239-1">(</span><span class="p" data-group-id="2717595239-2">&lt;&lt;</span><span class="n">Sz</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="n">Payload</span><span class="p">:</span><span class="n">Sz</span><span class="o">/</span><span class="ss">binary</span><span class="o">-</span><span class="nc">unit</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="n">Rest</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="2717595239-2">&gt;&gt;</span><span class="p" data-group-id="2717595239-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
   </span><span class="p" data-group-id="2717595239-3">{</span><span class="n">Payload</span><span class="p">,</span><span class="n">Rest</span><span class="p" data-group-id="2717595239-3">}</span><span class="p">.</span></code></pre><p>Here <code class="inline">Sz</code> is bound to the value in the first byte of the binary. <code class="inline">Sz</code> is then
used at the number of bytes to match out as a binary.</p><p>Starting in OTP 23, the size can be a guard expression:</p><pre><code class="makeup erlang" translate="no"><span class="nf">bar</span><span class="p" data-group-id="7151399162-1">(</span><span class="p" data-group-id="7151399162-2">&lt;&lt;</span><span class="n">Sz</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="n">Payload</span><span class="p">:</span><span class="p" data-group-id="7151399162-3">(</span><span class="p" data-group-id="7151399162-4">(</span><span class="n">Sz</span><span class="o">-</span><span class="mi">1</span><span class="p" data-group-id="7151399162-4">)</span><span class="o">*</span><span class="mi">8</span><span class="p" data-group-id="7151399162-3">)</span><span class="o">/</span><span class="ss">binary</span><span class="p">,</span><span class="n">Rest</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="7151399162-2">&gt;&gt;</span><span class="p" data-group-id="7151399162-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
   </span><span class="p" data-group-id="7151399162-5">{</span><span class="n">Payload</span><span class="p">,</span><span class="n">Rest</span><span class="p" data-group-id="7151399162-5">}</span><span class="p">.</span></code></pre><p>Here <code class="inline">Sz</code> is the combined size of the header and the payload, so we will need to
subtract one byte to get the size of the payload.</p><h3 id="getting-the-rest-of-the-binary-or-bitstring" class="section-heading"><a href="#getting-the-rest-of-the-binary-or-bitstring" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Getting the Rest of the Binary or Bitstring</span></h3><p>To match out the rest of a binary, specify a binary field without size:</p><pre><code class="makeup erlang" translate="no"><span class="nf">foo</span><span class="p" data-group-id="1534778688-1">(</span><span class="p" data-group-id="1534778688-2">&lt;&lt;</span><span class="n">A</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="n">Rest</span><span class="o">/</span><span class="ss">binary</span><span class="p" data-group-id="1534778688-2">&gt;&gt;</span><span class="p" data-group-id="1534778688-1">)</span><span class="w"> </span><span class="p">-&gt;</span></code></pre><p>The size of the tail must be evenly divisible by 8.</p><p>To match out the rest of a bitstring, specify a field without size:</p><pre><code class="makeup erlang" translate="no"><span class="nf">foo</span><span class="p" data-group-id="7534179725-1">(</span><span class="p" data-group-id="7534179725-2">&lt;&lt;</span><span class="n">A</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span><span class="n">Rest</span><span class="o">/</span><span class="ss">bitstring</span><span class="p" data-group-id="7534179725-2">&gt;&gt;</span><span class="p" data-group-id="7534179725-1">)</span><span class="w"> </span><span class="p">-&gt;</span></code></pre><p>There are no restrictions on the number of bits in the tail.</p><h2 id="appending-to-a-binary" class="section-heading"><a href="#appending-to-a-binary" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Appending to a Binary</span></h2><p>Appending to a binary in an efficient way can be done as follows:</p><pre><code class="makeup erlang" translate="no"><span class="nf">triples_to_bin</span><span class="p" data-group-id="2688922547-1">(</span><span class="n">T</span><span class="p" data-group-id="2688922547-1">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nf">triples_to_bin</span><span class="p" data-group-id="2688922547-2">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2688922547-3">&lt;&lt;</span><span class="p" data-group-id="2688922547-3">&gt;&gt;</span><span class="p" data-group-id="2688922547-2">)</span><span class="p">.</span><span class="w">

</span><span class="nf">triples_to_bin</span><span class="p" data-group-id="2688922547-4">(</span><span class="p" data-group-id="2688922547-5">[</span><span class="p" data-group-id="2688922547-6">{</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p" data-group-id="2688922547-6">}</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="n">T</span><span class="p" data-group-id="2688922547-5">]</span><span class="p">,</span><span class="w"> </span><span class="n">Acc</span><span class="p" data-group-id="2688922547-4">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="nf">triples_to_bin</span><span class="p" data-group-id="2688922547-7">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2688922547-8">&lt;&lt;</span><span class="n">Acc</span><span class="o">/</span><span class="ss">binary</span><span class="p">,</span><span class="n">X</span><span class="p">:</span><span class="mi">32</span><span class="p">,</span><span class="n">Y</span><span class="p">:</span><span class="mi">32</span><span class="p">,</span><span class="n">Z</span><span class="p">:</span><span class="mi">32</span><span class="p" data-group-id="2688922547-8">&gt;&gt;</span><span class="p" data-group-id="2688922547-7">)</span><span class="p">;</span><span class="w">
</span><span class="nf">triples_to_bin</span><span class="p" data-group-id="2688922547-9">(</span><span class="p" data-group-id="2688922547-10">[</span><span class="p" data-group-id="2688922547-10">]</span><span class="p">,</span><span class="w"> </span><span class="n">Acc</span><span class="p" data-group-id="2688922547-9">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w">
    </span><span class="n">Acc</span><span class="p">.</span></code></pre>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="list_comprehensions.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
List Comprehensions
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="reference_manual.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Introduction
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="Erlang System Documentation.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.38.1) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>
<p>Copyright © 1996-2025 <a href="https://www.ericsson.com">Ericsson AB</a></p>
    </footer>
  </div>
</main>
</div>
  <script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
  <script>
  let initialized = false;

  window.addEventListener("exdoc:loaded", () => {
      if (!initialized) {
      mermaid.initialize({
          startOnLoad: false,
          theme: document.body.className.includes("dark") ? "dark" : "default"
      });
      initialized = true;
      }

      let id = 0;
      for (const codeEl of document.querySelectorAll("pre code.mermaid")) {
      const preEl = codeEl.parentElement;
      const graphDefinition = codeEl.textContent;
      const graphEl = document.createElement("div");
      const graphId = "mermaid-graph-" + id++;
      mermaid.render(graphId, graphDefinition).then(({svg, bindFunctions}) => {
          graphEl.innerHTML = svg;
          bindFunctions?.(graphEl);
          preEl.insertAdjacentElement("afterend", graphEl);
          preEl.remove();
      });
      }
  });
  </script>

  </body>
</html>
