<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="utf-8">
<link rel="stylesheet" href="../../otp_doc.css" type="text/css">
<meta name="major-vsn" content="24">
<title>Erlang -- BeamAsm, the Erlang JIT</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../../js/erlresolvelinks.js"></script><script id="js3" type="text/javascript" src="../../../doc/js/topbar.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function setscrollpos() {
                var objf = document.getElementById('loadscrollpos');
                if (objf) {
                  document.getElementById("leftnav").firstChild.scrollTop = objf.offsetTop - 10;
                }
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //-->
</script><div class="topbar">
<div class="topbar-expand "><button onclick="toggleDisplay();"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" id="Capa_1" viewBox="0 0 54 54" width="24" height="24"><g><path style="fill:#000000;" d="M27,54c-0.552,0-1-0.448-1-1V8c0-0.552,0.448-1,1-1s1,0.448,1,1v45C28,53.552,27.552,54,27,54z"></path><path style="fill:#000000;" d="M11,25c-0.256,0-0.512-0.098-0.707-0.293c-0.391-0.391-0.391-1.023,0-1.414l16-16                                      c0.391-0.391,1.023-0.391,1.414,0s0.391,1.023,0,1.414l-16,16C11.512,24.902,11.256,25,11,25z"></path><path style="fill:#000000;" d="M43,25c-0.256,0-0.512-0.098-0.707-0.293l-16-16c-0.391-0.391-0.391-1.023,0-1.414                                      s1.023-0.391,1.414,0l16,16c0.391,0.391,0.391,1.023,0,1.414C43.512,24.902,43.256,25,43,25z"></path><path style="fill:#000000;" d="M43,2H11c-0.552,0-1-0.448-1-1s0.448-1,1-1h32c0.552,0,1,0.448,1,1S43.552,2,43,2z"></path></g></svg></button></div>
<div class="topbar-title"><h1 id="BeamAsm, the Erlang JIT">1Â 
                BeamAsm, the Erlang JIT</h1></div>
<div class="search-expand ">        <button id="docsearch-mobile">
            <svg fill="#000000" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 50 50" width="24" height="24"><path d="M 21 3 C 11.621094 3 4 10.621094 4 20 C 4 29.378906 11.621094 37 21 37 C 24.710938 37 28.140625 35.804688 30.9375 33.78125 L 44.09375 46.90625 L 46.90625 44.09375 L 33.90625 31.0625 C 36.460938 28.085938 38 24.222656 38 20 C 38 10.621094 30.378906 3 21 3 Z M 21 5 C 29.296875 5 36 11.703125 36 20 C 36 28.296875 29.296875 35 21 35 C 12.703125 35 6 28.296875 6 20 C 6 11.703125 12.703125 5 21 5 Z"/></svg>
        </button>
</div>
</div>
<aside class="hide-mobile" id="leftnav"><nav class="leftnav-tube"><div class="erlang-logo-wrapper"><a href="../../index.html"><img alt="Erlang Logo" src="../../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Erlang Run-Time System Application (ERTS)</p>
<p class="section-subtitle">Internal Documentation</p>
<p class="section-version">Version 12.3.2.17</p>
<ul class="panel-sections">
<li><a href="users_guide.html">User's Guide</a></li>
<li><a href="index.html">Reference Manual</a></li>
<li><a href="internal_docs.html">Internal Documentation</a></li>
<li><a href="notes.html">Release Notes</a></li>
<li><a href="erts.pdf">PDF</a></li>
<li><a href="../../index.html">Top</a></li>
</ul>
<div id="docsearch"></div>
<div style="padding-left: 1rem; padding-top: 0.1rem;"><a href="/doc/search?v=24">Paginated Search</a></div>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3 id="chapters">Chapters</h3>
<ul class="flipMenu" imagePath="../../js/flipmenu">
<li id="loadscrollpos" title="BeamAsm, the Erlang JIT" expanded="true">BeamAsm, the Erlang JIT<ul>
<li><a href="BeamAsm.html">
              Top of chapter
            </a></li>
<li title="Loading Code"><a href="BeamAsm.html#loading-code">Loading Code</a></li>
<li title="Running Erlang code"><a href="BeamAsm.html#running-erlang-code">Running Erlang code</a></li>
<li title="Running C code"><a href="BeamAsm.html#running-c-code">Running C code</a></li>
<li title="Tracing and NIF Loading"><a href="BeamAsm.html#tracing-and-nif-loading">Tracing and NIF Loading</a></li>
<li title="Description of each file"><a href="BeamAsm.html#description-of-each-file">Description of each file</a></li>
<li title="Linux perf support"><a href="BeamAsm.html#linux-perf-support">Linux perf support</a></li>
<li title="FAQ"><a href="BeamAsm.html#faq">FAQ</a></li>
</ul>
</li>
<li id="no" title="Carrier Migration" expanded="false">Carrier Migration<ul>
<li><a href="CarrierMigration.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="CarrierMigration.html#introduction">Introduction</a></li>
<li title="Problem"><a href="CarrierMigration.html#problem">Problem</a></li>
<li title="Solution"><a href="CarrierMigration.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Counting Instructions" expanded="false">Counting Instructions<ul><li><a href="CountingInstructions.html">
              Top of chapter
            </a></li></ul>
</li>
<li id="no" title="Delayed Dealloc" expanded="false">Delayed Dealloc<ul>
<li><a href="DelayedDealloc.html">
              Top of chapter
            </a></li>
<li title="Problem"><a href="DelayedDealloc.html#problem">Problem</a></li>
<li title="Functionality Used to Address This problem"><a href="DelayedDealloc.html#functionality-used-to-address-this-problem">Functionality Used to Address This problem</a></li>
</ul>
</li>
<li id="no" title="Erlang Garbage Collector" expanded="false">Erlang Garbage Collector<ul>
<li><a href="GarbageCollection.html">
              Top of chapter
            </a></li>
<li title="Overview"><a href="GarbageCollection.html#overview">Overview</a></li>
<li title="Generational Garbage Collection"><a href="GarbageCollection.html#generational-garbage-collection">Generational Garbage Collection</a></li>
<li title="The young heap"><a href="GarbageCollection.html#the-young-heap">The young heap</a></li>
<li title="Sizing the heap"><a href="GarbageCollection.html#sizing-the-heap">Sizing the heap</a></li>
<li title="Literals"><a href="GarbageCollection.html#literals">Literals</a></li>
<li title="Binary heap"><a href="GarbageCollection.html#binary-heap">Binary heap</a></li>
<li title="Messages"><a href="GarbageCollection.html#messages">Messages</a></li>
<li title="References"><a href="GarbageCollection.html#references">References</a></li>
</ul>
</li>
<li id="no" title="Non-blocking code loading" expanded="false">Non-blocking code loading<ul>
<li><a href="CodeLoading.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="CodeLoading.html#introduction">Introduction</a></li>
<li title="The Load Phases"><a href="CodeLoading.html#the-load-phases">The Load Phases</a></li>
<li title="The Finishing Sequence"><a href="CodeLoading.html#the-finishing-sequence">The Finishing Sequence</a></li>
</ul>
</li>
<li id="no" title="Non-blocking trace setting" expanded="false">Non-blocking trace setting<ul>
<li><a href="Tracing.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="Tracing.html#introduction">Introduction</a></li>
<li title="Redesign of Breakpoint Wheel"><a href="Tracing.html#redesign-of-breakpoint-wheel">Redesign of Breakpoint Wheel</a></li>
<li title="Same Same but Different"><a href="Tracing.html#same-same-but-different">Same Same but Different</a></li>
<li title="Adding a new Breakpoint"><a href="Tracing.html#adding-a-new-breakpoint">Adding a new Breakpoint</a></li>
<li title="To Updating and Remove Breakpoints"><a href="Tracing.html#to-updating-and-remove-breakpoints">To Updating and Remove Breakpoints</a></li>
<li title="Global Tracing"><a href="Tracing.html#global-tracing">Global Tracing</a></li>
<li title="Future work"><a href="Tracing.html#future-work">Future work</a></li>
</ul>
</li>
<li id="no" title="Port Signals" expanded="false">Port Signals<ul>
<li><a href="PortSignals.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="PortSignals.html#problems">Problems</a></li>
<li title="Solution"><a href="PortSignals.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Process and Port Tables" expanded="false">Process and Port Tables<ul>
<li><a href="PTables.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="PTables.html#problems">Problems</a></li>
<li title="Solution"><a href="PTables.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Process Management Optimizations" expanded="false">Process Management Optimizations<ul>
<li><a href="ProcessManagementOptimizations.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="ProcessManagementOptimizations.html#problems">Problems</a></li>
<li title="Solution"><a href="ProcessManagementOptimizations.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="Super Carrier" expanded="false">Super Carrier<ul>
<li><a href="SuperCarrier.html">
              Top of chapter
            </a></li>
<li title="Problem"><a href="SuperCarrier.html#problem">Problem</a></li>
<li title="Solution"><a href="SuperCarrier.html#solution">Solution</a></li>
</ul>
</li>
<li id="no" title="The beam_makeops script" expanded="false">The beam_makeops script<ul>
<li><a href="beam_makeops.html">
              Top of chapter
            </a></li>
<li title="Introduction"><a href="beam_makeops.html#introduction">Introduction</a></li>
<li title="An example: the move instruction"><a href="beam_makeops.html#an-example--the-move-instruction">An example: the move instruction</a></li>
<li title="Short overview of instruction loading for the interpreter"><a href="beam_makeops.html#short-overview-of-instruction-loading-for-the-interpreter">Short overview of instruction loading for the interpreter</a></li>
<li title="Short overview of instruction loading for BeamAsm"><a href="beam_makeops.html#short-overview-of-instruction-loading-for-beamasm">Short overview of instruction loading for BeamAsm</a></li>
<li title="Running beam_makeops"><a href="beam_makeops.html#running-beam_makeops">Running beam_makeops</a></li>
<li title="Syntax of .tab files"><a href="beam_makeops.html#syntax-of-.tab-files">Syntax of .tab files</a></li>
</ul>
</li>
<li id="no" title="Thread Progress" expanded="false">Thread Progress<ul>
<li><a href="ThreadProgress.html">
              Top of chapter
            </a></li>
<li title="Problems"><a href="ThreadProgress.html#problems">Problems</a></li>
<li title="Functionality Used to Address These Problems"><a href="ThreadProgress.html#functionality-used-to-address-these-problems">Functionality Used to Address These Problems</a></li>
<li title="Implementation of the Thread Progress Functionality"><a href="ThreadProgress.html#implementation-of-the-thread-progress-functionality">Implementation of the Thread Progress Functionality</a></li>
</ul>
</li>
</ul></nav></aside><div id="content">
<div class="innertube">
<h1 id="BeamAsm, the Erlang JIT">1Â BeamAsm, the Erlang JIT</h1>


<p>
BeamAsm provides load-time conversion of Erlang BEAM instructions into
native code on x86-64. This allows the loader to eliminate any instruction
dispatching overhead and also specialize each instruction on their argument types.
</p>

<p>
BeamAsm does hardly any cross instruction optimizations and the x and y
register arrays work the same as when interpreting BEAM instructions.
This allows the Erlang run-time system to be largely unchanged except for
places that need to work with loaded BEAM instructions like code loading,
tracing, and a few others.
</p>

<p>
BeamAsm uses <span class="bold_code bc-20"><a href="https://github.com/asmjit/asmjit">asmjit</a></span> to generate native code
in run-time. Only small parts of the
<span class="bold_code bc-20"><a href="https://asmjit.com/doc/group__asmjit__assembler.html">Assembler API</a></span> of
<span class="bold_code bc-20"><a href="https://github.com/asmjit/asmjit">asmjit</a></span> is used. At the moment
<span class="bold_code bc-20"><a href="https://github.com/asmjit/asmjit">asmjit</a></span> only supports x86 32/64 bit assembler.
</p>

<a name="Loading-Code"></a><h3 id="loading-code" class="title-link" onMouseOver="document.getElementById('ghlink-loading-code-idm30650').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-loading-code-idm30650').style.visibility = 'hidden';">
<div class="title-name">1.1Â 
        Loading Code</div>
<div class="title-anchors"><span id="ghlink-loading-code-idm30650" class="ghlink-after"><a href="#loading-code" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
The code is loaded very similarly to how it is loaded for the interpreter. Each beam
file is parsed and then optimized through the transformations described in
<span class="bold_code bc-15"><a href="beam_makeops.html#defining-transformation-rules">beam_makeops</a></span>. The transformations
used in BeamAsm are much simpler than the interpreter's, as most of the
transformations for the interpreter are done only to eliminate the instruction
dispatch overhead.
</p>

<p>
Then each instruction is encoded using the C++ functions in the jit/instr<strong></strong>.cpp files.
Example:
</p>

<div class="example example-none"><pre>void BeamModuleAssembler::emit_is_nonempty_list(const ArgVal &amp;Fail, const ArgVal &amp;Src) {
  a.test(getArgRef(Src), imm(_TAG_PRIMARY_MASK - TAG_PRIMARY_LIST));
  a.jne(labels[Fail.getValue()]);
}</pre></div>
<p>
<span class="bold_code bc-20"><a href="https://github.com/asmjit/asmjit">asmjit</a></span> provides a fairly straightforward
mapping from a C++ function call to the x86 assembly instruction. The above
instruction tests if the value in the <span class="code">Src</span> register is a non-empty list and if
it is not then it jumps to the fail label.
</p>

<p>
For comparison, the interpreter has 8 combinations and specializations of
this implementation to minimize the instruction dispatch overhead for
common patterns.
</p>

<p>
The original register allocation done by the Erlang compiler is used to manage the
liveness of values and the physical registers are statically allocated to keep
the necessary process state. At the moment this is the static register allocation:
</p>

<div class="example example-none"><pre>rbx: ErtsSchedulerRegisters struct (contains x/float registers and some metadata)
rbp: Active code index
r12: Optional Save slot for the Erlang stack pointer when executing C code
r13: Current running process
r14: Remaining reductions
r15: Erlang heap pointer</pre></div>
<p>
Note that all of these are callee save registers under the System V and Windows
ABIs which means that BeamAsm never has to spill any of these when making C
function calls.
</p>

<p>
The caller save registers are used as scratch registers within instructions but
usually do not carry information between them. For some frequent instruction
sequences such as tuple matching cross instruction optimization <strong>are</strong> done to avoid
fetching the base address of the tuple in every <span class="code">get_tuple_element</span> instruction.
</p>

<a name="Loading-Code_Reducing-code-size-and-load-time"></a><h4 id="reducing-code-size-and-load-time" class="title-link" onMouseOver="document.getElementById('ghlink-reducing-code-size-and-load-time-idm30668').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-reducing-code-size-and-load-time-idm30668').style.visibility = 'hidden';">
<div class="title-name">Reducing code size and load time</div>
<div class="title-anchors"><span id="ghlink-reducing-code-size-and-load-time-idm30668" class="ghlink-after"><a href="#reducing-code-size-and-load-time" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
One of the strengths of the interpreter is that it uses relatively little memory
for loaded code. This is because the implementation of each loaded instruction is
shared and only the arguments to the instructions vary. Using as little memory as
possible has many advantages; less memory is used, loading time decreases,
higher cache hit-rate.
</p>

<p>
In BeamAsm we need to achieve something similar since the load-time of a module
scales almost linearly with the amount of memory it uses. Early BeamAsm prototypes
used about double the amount of memory for code as the interpreter, while current
versions use about 10% more. How was this achieved?
</p>

<p>
In BeamAsm we heavily use shared code fragments to try to emit as much code as
possible as global shared fragments instead of duplicating the code unnecessarily.
For instance, the return instruction looks something like this:
</p>

<div class="example example-none"><pre>Label yield = a.newLabel();

a.dec(FCALLS);           /* Decrement reduction counter */
a.jl(dispatch_return);   /* Check if we should yield */
a.ret();

a.bind(yield);
abs_jmp(ga-&gt;get_dispatch_return());</pre></div>
<p>
The code above is not exactly what is emitted, but close enough. The thing to note
is that the code for doing the context switch is never emitted. Instead, we jump
to a global fragment that all return instructions share. This greatly reduces
the amount of code that has to be emitted for each module.
</p>





<a name="Running-Erlang-code"></a><h3 id="running-erlang-code" class="title-link" onMouseOver="document.getElementById('ghlink-running-erlang-code-idm30676').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-running-erlang-code-idm30676').style.visibility = 'hidden';">
<div class="title-name">1.2Â 
        Running Erlang code</div>
<div class="title-anchors"><span id="ghlink-running-erlang-code-idm30676" class="ghlink-after"><a href="#running-erlang-code" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
Running BeamAsm code is very similar to running the interpreter, except that
native code is executed instead of interpreted code.
</p>

<p>
We had to tweak the way the Erlang stack works in order to execute native
instructions on it. While the interpreter uses a stack slot for
the current frame's return address (setting it to <span class="code">[]</span> when unused), the
native code merely reserves enough space for it as the x86 <span class="code">call</span> and <span class="code">ret</span>
instructions bump the stack pointer when executed.
</p>

<p>
This only affects the <strong>current stack frame</strong>, and is functionally identical
aside from two caveats:
</p>

<ol>
<li>
<p>Exceptions must not be thrown when the return address is reserved.
</p>

<p>It's hard to tell where the stack will end up after an exception; the return
address won't be on the stack if we crash in the <strong>current stack frame</strong>, but
will be if we crash in a function we call. Telling these apart turned out to
rather complicated, so we decided to require the return address to be used
when an exception is thrown.
</p>

<p><span class="code">emit_handle_error</span> handles this for you, and shared fragments that have been
called (rather than jumped to) satisfy this requirement by default.
</p>

</li>
<li>
<p>Garbage collection needs to take return addresses into account.
</p>

<p>If we're about to create a term we have to make sure that there's enough
space for this term <strong>and</strong> a potential return address, or else the next
<span class="code">call</span> will clobber said term. This is taken care of in <span class="code">emit_gc_test</span> and
you generally don't need to think about it.
</p>
</li>
</ol>
<p>
In addition to the above, we ensure that there's always at least <span class="code">S_REDZONE</span>
free words on the stack so we can make calls to shared fragments or trace
handlers even when we lack a stack frame. This is merely a reservation and has
no effect on how the stack works, and all values stored there must be valid
Erlang terms in case of a garbage collection.
</p>



<a name="Running-C-code"></a><h3 id="running-c-code" class="title-link" onMouseOver="document.getElementById('ghlink-running-c-code-idm30701').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-running-c-code-idm30701').style.visibility = 'hidden';">
<div class="title-name">1.3Â 
        Running C code</div>
<div class="title-anchors"><span id="ghlink-running-c-code-idm30701" class="ghlink-after"><a href="#running-c-code" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
As Erlang stacks can be very small, we have to switch over to a different stack
when we need to execute C code (which may expect a much larger stack). This is
done through <span class="code">emit_enter_runtime</span> and <span class="code">emit_leave_runtime</span>, for example:
</p>

<div class="example example-none"><pre>mov_arg(ARG4, NumFree);

/* Move to the C stack and swap out our current reductions, stack-, and
 * heap pointer to the process structure. */
emit_enter_runtime&lt;Update::eReductions | Update::eStack | Update::eHeap&gt;();

a.mov(ARG1, c_p);
load_x_reg_array(ARG2);
make_move_patch(ARG3, lambdas[Fun.getValue()].patches);

/* Call `new_fun`, asserting that we're on the C stack. */
runtime_call&lt;4&gt;(new_fun);

/* Move back to the C stack, and read the updated values from the process
 * structure */
emit_leave_runtime&lt;Update::eReductions | Update::eStack | Update::eHeap&gt;();

a.mov(getXRef(0), RET);</pre></div>
<p>
All combinations of the <span class="code">Update</span> constants are legal, but the ones given to
<span class="code">emit_leave_runtime</span> <strong>must</strong> be the same as those given to <span class="code">emit_enter_runtime</span>.
</p>



<a name="Tracing-and-NIF-Loading"></a><h3 id="tracing-and-nif-loading" class="title-link" onMouseOver="document.getElementById('ghlink-tracing-and-nif-loading-idm30713').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-tracing-and-nif-loading-idm30713').style.visibility = 'hidden';">
<div class="title-name">1.4Â 
        Tracing and NIF Loading</div>
<div class="title-anchors"><span id="ghlink-tracing-and-nif-loading-idm30713" class="ghlink-after"><a href="#tracing-and-nif-loading" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
To make tracing and NIF loading work there needs to be a way to intercept
any function call. In the interpreter, this is done by rewriting the loaded BEAM code,
but this is more complicated in BeamAsm as we want to have a fast and compact way to
do this. This is solved by emitting the code below at the start of each function:
</p>

<div class="example example-none"><pre>0x0: jmp 6
0x2: ERTS_ASM_BP_FLAG_NONE
0x3: relative near call
0x4: &amp;genericBPTramp
0x8: actual code for the function</pre></div>
<p>
When code starts to execute it will simply see the <span class="code">jmp 6</span> instruction
which skips the prologue and starts to execute the code directly.
</p>

<p>
When we want to enable a certain break point we set the <span class="code">jmp</span> target to
be 1 (which means it will land on the call instruction) and will call
genericBPTramp. genericBPTramp is a label at the top of each module
that contains <span class="bold_code bc-20"><a href="https://en.wikipedia.org/wiki/Trampoline_">trampolines</a></span> for all flag combinations.
</p>


<div class="example example-none"><pre>genericBPTramp:

0x0: ret
0x10: jmp call_nif_early
0x20: call generic_bp_local
0x30: call generic_bp_local
0x35: jmp call_nif_early</pre></div>
<p>
Note that each target is 16 byte aligned. This is because the call target
in the function prologue is updated to target the correct place when a flag
is updated. So if CALL_NIF_EARLY is set, then it is updated to be
genericBPTramp + 0x10. If BP is set, it is updated to genericBPTramp + 0x20
and the combination makes it to be genericBPTramp + 0x30.
</p>

<a name="Tracing-and-NIF-Loading_Updating-code"></a><h4 id="updating-code" class="title-link" onMouseOver="document.getElementById('ghlink-updating-code-idm30725').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-updating-code-idm30725').style.visibility = 'hidden';">
<div class="title-name">Updating code</div>
<div class="title-anchors"><span id="ghlink-updating-code-idm30725" class="ghlink-after"><a href="#updating-code" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
Because many environments enforce [W^X] it's not always possible to write
directly to the code pages. Because of this we map code twice: once with an
executable page and once with a writable page. Since they're backed by the
same memory, writes to the writable page appear magically in the executable
one.
</p>

<p>
The <span class="code">erts_writable_code_ptr</span> function can be used to get writable pointers,
given a module instance:
</p>

<div class="example example-none"><pre>for (i = 0; i &lt; n; ++i) {
    ErtsCodeInfo* ci;
    void *w_ptr;

    w_ptr = erts_writable_code_ptr(&amp;modp-&gt;curr,
                                   code_hdr-&gt;functions[i]);
    ci = (ErtsCodeInfo*)w_ptr;

    uninstall_breakpoint(ci);
    consolidate_bp_data(modp, ci, 1);
    ASSERT(ci-&gt;u.gen_bp == NULL);
}</pre></div>
<p>
Without the module instance there's no reliable way to figure out the writable
address of a code page, and we rely on <strong>address space layout randomization</strong>
(ASLR) to make it difficult to guess.
</p>



<a name="Tracing-and-NIF-Loading_Export-tracing"></a><h4 id="export-tracing" class="title-link" onMouseOver="document.getElementById('ghlink-export-tracing-idm30734').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-export-tracing-idm30734').style.visibility = 'hidden';">
<div class="title-name">Export tracing</div>
<div class="title-anchors"><span id="ghlink-export-tracing-idm30734" class="ghlink-after"><a href="#export-tracing" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
Unlike the interpreter, we don't execute code inside export entries as that's
very annoying to do in the face of [W^X]. When tracing is enabled, we instead
point to a fragment that looks at the current export entry and decides what to
do.
</p>

<p>
This fragment is shared between all export entries, and the export entry to
operate on is assumed to be in a certain register (<span class="code">RET</span> as of writing). This
means that all remote calls <strong>must</strong> place the export entry in said register,
even when we don't know beforehand that the call is remote, such as when
calling a fun.
</p>

<p>
This is pretty easy to do in assembler and the <span class="code">emit_setup_export_call</span> helper
handles it nicely for us, but we can't set registers when trapping out from C
code. When trapping to an export entry from C code one must set <span class="code">c_p-&gt;current</span>
to the <span class="code">ErtsCodeMFA</span> inside the export entry in question, and then set <span class="code">c_p-&gt;i</span>
to <span class="code">beam_bif_export_trap</span>.
</p>

<p>
The <span class="code">BIF_TRAP</span> macros handle this for you, so you generally don't need to
think about it.
</p>






<a name="Description-of-each-file"></a><h3 id="description-of-each-file" class="title-link" onMouseOver="document.getElementById('ghlink-description-of-each-file-idm30749').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-description-of-each-file-idm30749').style.visibility = 'hidden';">
<div class="title-name">1.5Â 
        Description of each file</div>
<div class="title-anchors"><span id="ghlink-description-of-each-file-idm30749" class="ghlink-after"><a href="#description-of-each-file" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
The BeamAsm implementation resides in the <span class="code">$ERL_TOP/erts/emulator/beam/jit</span> folder.
The files are:
</p>

<ul>
<li>
<span class="code">load.h</span>

<ul><li>
BeamAsm specific header for loading code

</li></ul>
</li>
<li>
<span class="code">asm_load.c</span>

<ul><li>
BeamAsm specific functions for loading code

</li></ul>
</li>
<li>
<span class="code">generators.tab</span>, <span class="code">predicates.tab</span>, <span class="code">ops.tab</span>

<ul><li>
BeamAsm specific transformations for instructions. See <span class="bold_code bc-19"><a href="beam_makeops.html">beam_makeops</a></span> for
more details.

</li></ul>
</li>
<li>
<span class="code">beam_asm.h</span>

<ul><li>
Header file describing the C -&gt; C++ api

</li></ul>
</li>
<li>
<span class="code">beam_asm.hpp</span>

<ul><li>
Header file describing the structs and classes used by BeamAsm.

</li></ul>
</li>
<li>
<span class="code">beam_asm.cpp</span>

<ul>
<li>
Implementation of the main process loop

</li>
<li>
The BeamAsm initialization code

</li>
<li>
The C -&gt; C++ interface functions.

</li>
</ul>
</li>
<li>
<span class="code">beam_asm_module.cpp</span>

<ul><li>
The code for the BeamAsm module code generator logic

</li></ul>
</li>
<li>
<span class="code">beam_asm_global.cpp</span>

<ul><li>
Global code fragments that are used by multiple instructions, e.g. error handling code.

</li></ul>
</li>
<li>
<span class="code">instr_*.cpp</span>

<ul><li>
Implementation of individual instructions grouped into files by area

</li></ul>
</li>
<li>
<span class="code">beam_asm_perf.cpp</span>

<ul><li>
The linux perf support for BeamAsm

</li></ul>
</li>
</ul>


<a name="Linux-perf-support"></a><h3 id="linux-perf-support" class="title-link" onMouseOver="document.getElementById('ghlink-linux-perf-support-idm30800').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-linux-perf-support-idm30800').style.visibility = 'hidden';">
<div class="title-name">1.6Â 
        Linux perf support</div>
<div class="title-anchors"><span id="ghlink-linux-perf-support-idm30800" class="ghlink-after"><a href="#linux-perf-support" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<p>
perf can also be instrumented using BeamAsm symbols to provide more information. As with
gdb, only the currently executing function will show up in the stack trace, which means
that perf provides functionality similar to that of <span class="bold_code bc-20"><a href="https://erlang.org/doc/man/eprof.html">eprof</a></span>.
</p>

<p>
You can run perf on BeamAsm like this:
</p>

<div class="example example-none"><pre>perf record erl +JPperf true</pre></div>
<p>
and then look at the results using <span class="code">perf report</span> as you normally would with perf.
</p>

<p>
If you want to get some context to you calls you cann use the <span class="bold_code bc-20"><a href="https://lwn.net/Articles/680985/">lbr</a></span>
call-graph option to <span class="code">perf record</span>. Using <span class="code">lbr</span> is not perfect (for instance you
do not get any syscalls in the context), but it work well enough.
For example, you can run perf to analyze dialyzer building a PLT like this:
</p>

<div class="example example-none"><pre> ERL_FLAGS="+JPperf true +S 1" perf record --call-graph lbr \
   dialyzer --build_plt -Wunknown --apps compiler crypto erts kernel stdlib \
   syntax_tools asn1 edoc et ftp inets mnesia observer public_key \
   sasl runtime_tools snmp ssl tftp wx xmerl tools</pre></div>
<p>
The above code is run using <span class="code">+S 1</span> to make the perf output easier to understand.
If you then run <span class="code">perf report -f --no-children</span> you may get something similar to this:
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/perf-beamasm.png" class="doc-image"><p class="doc-image-caption">Figure
        1.1:
        Â 
        Linux Perf report: dialyzer PLT build</p>
</div>

<p>
Any Erlang function in the report is prefixed with a <span class="code">$</span> and all C functions have
their normal names. Any Erlang function that has the prefix <span class="code">$global::</span> refers
to a global shared fragment.
</p>

<p>
So in the above, we can see that we spend the most time doing <span class="code">eq</span>, i.e. comparing two terms.
By expanding it and looking at its parents we can see that it is the function
<span class="code">erl_types:t_is_equal/2</span> that contributes the most to this value. Go and have a look
at it in the source code to see if you can figure out why so much time is spent there.
</p>

<p>
After <span class="code">eq</span> we see the function <span class="code">erl_types:t_has_var/1</span> where we spend almost
6% of the entire execution in. A while further down you can see <span class="code">copy_struct</span> which
is the function used to copy terms. If we expand it to view the parents we find that
it is mostly <span class="code">ets:lookup_element/3</span> that contributes to this time via the Erlang
function <span class="code">dialyzer_plt:ets_table_lookup/2</span>.
</p>

<a name="Linux-perf-support_Flame-Graph"></a><h4 id="flame-graph" class="title-link" onMouseOver="document.getElementById('ghlink-flame-graph-idm30831').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-flame-graph-idm30831').style.visibility = 'hidden';">
<div class="title-name">Flame Graph</div>
<div class="title-anchors"><span id="ghlink-flame-graph-idm30831" class="ghlink-after"><a href="#flame-graph" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
You can also create a Flame Graph from the perf output. Flame Graphs are basically
just another way to look at the same data as the <span class="code">perf report</span> output, but can
be more easily shared with others and manipulated to give a graph tailor-made for
your needs. For instance, if we run dialyzer with all schedulers:
</p>

<div class="example example-none"><pre>## Run dialyzer with multiple schedulers
ERL_FLAGS="+JPperf true" perf record --call-graph lbr \
  dialyzer --build_plt -Wunknown --apps compiler crypto erts kernel stdlib \
  syntax_tools asn1 edoc et ftp inets mnesia observer public_key \
  sasl runtime_tools snmp ssl tftp wx xmerl tools --statistics</pre></div>
<p>
And then use the scripts found at Brendan Gregg's <span class="bold_code bc-20"><a href="http://www.brendangregg.com/FlameGraphs/cpuflamegraphs">CPU Flame Graphs</a></span>
web page as follows:
</p>

<div class="example example-none"><pre>## Collect the results
perf script &gt; out.perf
## run stackcollapse
stackcollapse-perf.pl out.perf &gt; out.folded
## Create the svg
flamegraph.pl out.folded &gt; out.svg</pre></div>
<p>
We get a graph that would look something like this:
</p>

<div class="doc-image-wrapper">
<object alt="IMAGE MISSING" data="figures/perf-beamasm.svg" class="doc-svg doc-image"></object><p class="doc-image-caption">Figure
        1.2:
        Â 
        Linux Perf FlameGraph: dialyzer PLT build</p>
</div>

<p>
You can view a larger version <span class="bold_code bc-19"><a href="../../apps/erts/figures/perf-beamasm.svg">here</a></span>. It contains
the same information, but it is easier to share with others as it does
not need the symbols in the executable.
</p>

<p>
Using the same data we can also produce a graph where the scheduler profile data
has been merged by using <span class="code">sed</span>:
</p>

<div class="example example-none"><pre>## Strip [0-9]+_ from all scheduler names
sed -e 's/^[0-9]\+_//' out.folded &gt; out.folded_sched
## Create the svg
flamegraph.pl out.folded_sched &gt; out_sched.svg</pre></div>
<div class="doc-image-wrapper">
<object alt="IMAGE MISSING" data="figures/perf-beamasm-merged.svg" class="doc-svg doc-image"></object><p class="doc-image-caption">Figure
        1.3:
        Â 
        Linux Perf FlameGraph: dialyzer PLT build</p>
</div>

<p>
You can view a larger version <span class="bold_code bc-19"><a href="../../apps/erts/figures/perf-beamasm-merged.svg">here</a></span>.
There are many different transformations that you can do to make the graph show
you what you want.
</p>



<a name="Linux-perf-support_Annotate-perf-functions"></a><h4 id="annotate-perf-functions" class="title-link" onMouseOver="document.getElementById('ghlink-annotate-perf-functions-idm30852').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-annotate-perf-functions-idm30852').style.visibility = 'hidden';">
<div class="title-name">Annotate perf functions</div>
<div class="title-anchors"><span id="ghlink-annotate-perf-functions-idm30852" class="ghlink-after"><a href="#annotate-perf-functions" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
If you want to be able to use the <span class="code">perf annotate</span> functionality (and in extention
the annotate functionality in the <span class="code">perf report</span> gui) you need to use a monotonic
clock when calling <span class="code">perf record</span>, i.e. <span class="code">perf record -k mono</span>. So for a dialyzer
run you would do this:
</p>

<div class="example example-none"><pre>ERL_FLAGS="+JPperf true +S 1" perf record -k mono --call-graph lbr \
  dialyzer --build_plt -Wunknown --apps compiler crypto erts kernel stdlib \
  syntax_tools asn1 edoc et ftp inets mnesia observer public_key \
  sasl runtime_tools snmp ssl tftp wx xmerl tools</pre></div>
<p>
In order to use the <span class="code">perf.data</span> produced by this record you need to first call
<span class="code">perf inject --jit</span> like this:
</p>

<div class="example example-none"><pre>perf inject --jit -i perf.data -o perf.jitted.data</pre></div>
<p>
and then you can view an annotated function like this:
</p>

<div class="example example-none"><pre>perf annotate -M intel -i perf.jitted.data erl_types:t_has_var/1</pre></div>
<p>
or by pressing <span class="code">a</span> in the <span class="code">perf report</span> ui. Then you get something like this:
</p>

<div class="doc-image-wrapper">
<img alt="IMAGE MISSING" src="figures/beamasm-perf-annotate.png" class="doc-image"><p class="doc-image-caption">Figure
        1.4:
        Â 
        Linux Perf FlameGraph: dialyzer PLT build</p>
</div>

<div class="warning">
<div class="label">Warning</div>
<div class="content"><p>
<p>
Calling <span class="code">perf inject --jit</span> will create a lot of files in <span class="code">/tmp/</span>
 and in <span class="code">~/.debug/tmp/</span>. So make sure to cleanup in those directories from time to
 time or you may run out of inodes.
</p>
</p></div>
</div>



<a name="Linux-perf-support_perf-tips-and-tricks"></a><h4 id="perf-tips-and-tricks" class="title-link" onMouseOver="document.getElementById('ghlink-perf-tips-and-tricks-idm30877').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-perf-tips-and-tricks-idm30877').style.visibility = 'hidden';">
<div class="title-name">perf tips and tricks</div>
<div class="title-anchors"><span id="ghlink-perf-tips-and-tricks-idm30877" class="ghlink-after"><a href="#perf-tips-and-tricks" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
You can do a lot of neat things with <span class="code">perf</span>. Below is a list of some of the options
we have found useful:
</p>

<ul>
<li>
<span class="code">perf report --no-children</span>
Do not include the accumulation of all children in a call.

</li>
<li>
<span class="code">perf report  --call-graph callee</span>
Show the callee rather than the caller when expanding a function call.

</li>
<li>
<span class="code">perf archive</span>
Create an archive with all the artifacts needed to inspect the data
on another host. In early version of perf this command does not work,
instead you can use <span class="bold_code bc-20"><a href="https://github.com/torvalds/linux/blob/master/tools/perf/perf-archive.sh">this bash script</a></span>.

</li>
<li>
<span class="code">perf report</span> gives "failed to process sample" and/or "failed to process type: 68"
This probably means that you are running a bugge version of perf. We have
seen this when running Ubuntu 18.04 with kernel version 4. If you update
to Ubuntu 20.04 or use Ubuntu 18.04 with kernel version 5 the problem
should go away.

</li>
</ul>




<a name="FAQ"></a><h3 id="faq" class="title-link" onMouseOver="document.getElementById('ghlink-faq-idm30892').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-faq-idm30892').style.visibility = 'hidden';">
<div class="title-name">1.7Â 
        FAQ</div>
<div class="title-anchors"><span id="ghlink-faq-idm30892" class="ghlink-after"><a href="#faq" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>



<a name="FAQ_How-do-I-know-that-Im-running-a-JIT-enabled-Erlang"></a><h4 id="how-do-i-know-that-i'm-running-a-jit-enabled-erlang-" class="title-link" onMouseOver="document.getElementById('ghlink-how-do-i-know-that-i'm-running-a-jit-enabled-erlang--idm30895').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-how-do-i-know-that-i'm-running-a-jit-enabled-erlang--idm30895').style.visibility = 'hidden';">
<div class="title-name">How do I know that I'm running a JIT enabled Erlang?</div>
<div class="title-anchors"><span id="ghlink-how-do-i-know-that-i'm-running-a-jit-enabled-erlang--idm30895" class="ghlink-after"><a href="#how-do-i-know-that-i'm-running-a-jit-enabled-erlang-" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
You will see a banner containing <span class="code">[jit]</span> shell when you start. You can also use
<span class="code">erlang:system_info(emu_flavor)</span> to check the flavor and it should be <span class="code">jit</span>.
</p>

<p>
There are three major reasons why when building Erlang/OTP you would not get the JIT.
</p>

<ul>
<li>
You are not building x86 64-bit

</li>
<li>
You do not have a C++ compiler that supports C++-17

</li>
<li>
You do not have an OS that supports executable <strong>and</strong> writable memory

</li>
</ul>
<p>
If you run <span class="code">./configure --enable-jit</span> configure will abort when it discovers that
your system cannot build the JIT.
</p>



<a name="FAQ_Is-the-interpreter-still-available"></a><h4 id="is-the-interpreter-still-available-" class="title-link" onMouseOver="document.getElementById('ghlink-is-the-interpreter-still-available--idm30910').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-is-the-interpreter-still-available--idm30910').style.visibility = 'hidden';">
<div class="title-name">Is the interpreter still available?</div>
<div class="title-anchors"><span id="ghlink-is-the-interpreter-still-available--idm30910" class="ghlink-after"><a href="#is-the-interpreter-still-available-" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
Yes, you can still build the interpreter if you want to. In fact, it is what is used
on platforms where BeamAsm does not yet work. You can either completely disable
BeamAsm by passing <span class="code">--disable-jit</span> to configure. Or you can build the
interpreter using <span class="code">make FLAVOR=emu</span> and then run it using <span class="code">erl -emu_flavor emu</span>.
</p>

<p>
It is possible to have both the JIT and interpreter available at the same time.
</p>



<a name="FAQ_How-much-of-a-speedup-should-I-expect-from-BeamAsm-compared-to-the-interpreter"></a><h4 id="how-much-of-a-speedup-should-i-expect-from-beamasm-compared-to-the-interpreter-" class="title-link" onMouseOver="document.getElementById('ghlink-how-much-of-a-speedup-should-i-expect-from-beamasm-compared-to-the-interpreter--idm30918').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-how-much-of-a-speedup-should-i-expect-from-beamasm-compared-to-the-interpreter--idm30918').style.visibility = 'hidden';">
<div class="title-name">How much of a speedup should I expect from BeamAsm compared to the interpreter?</div>
<div class="title-anchors"><span id="ghlink-how-much-of-a-speedup-should-i-expect-from-beamasm-compared-to-the-interpreter--idm30918" class="ghlink-after"><a href="#how-much-of-a-speedup-should-i-expect-from-beamasm-compared-to-the-interpreter-" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
It depends a lot on what your application does. Anything from no difference to up to
four times as fast is possible.
</p>

<p>
BeamAsm tries very hard to not be slower than the interpreter, but there can be cases
when that happens. One such could be very short-lived small scripts. If you come across
any scenarios when this happens, please open a bug report at
<span class="bold_code bc-20"><a href="https://github.com/erlang/otp/issues">the Erlang/OTP bug tracker</a></span>.
</p>



<a name="FAQ_Would-it-be-possible-to-add-support-for-BeamAsm-on-ARM"></a><h4 id="would-it-be-possible-to-add-support-for-beamasm-on-arm-" class="title-link" onMouseOver="document.getElementById('ghlink-would-it-be-possible-to-add-support-for-beamasm-on-arm--idm30924').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-would-it-be-possible-to-add-support-for-beamasm-on-arm--idm30924').style.visibility = 'hidden';">
<div class="title-name">Would it be possible to add support for BeamAsm on ARM?</div>
<div class="title-anchors"><span id="ghlink-would-it-be-possible-to-add-support-for-beamasm-on-arm--idm30924" class="ghlink-after"><a href="#would-it-be-possible-to-add-support-for-beamasm-on-arm-" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
Any new architecture needs support in the assembler as well. Since we use
<span class="bold_code bc-20"><a href="https://github.com/asmjit/asmjit">asmjit</a></span> for this, that means we need support
in <span class="bold_code bc-20"><a href="https://github.com/asmjit/asmjit">asmjit</a></span>. BeamAsm uses relatively few
instructions (mostly, <span class="code">mov</span>, <span class="code">jmp</span>, <span class="code">cmp</span>, <span class="code">sub</span>, <span class="code">add</span>), so it would not need to have
full support of all ARM instructions.
</p>

<p>
Another approach would be to not use <span class="bold_code bc-20"><a href="https://github.com/asmjit/asmjit">asmjit</a></span>
for ARM, but instead, use something different to assemble code during load-time.
</p>



<a name="FAQ_Would-it-be-possible-to-add-support-for-BeamAsm-on-another-OS"></a><h4 id="would-it-be-possible-to-add-support-for-beamasm-on-another-os-" class="title-link" onMouseOver="document.getElementById('ghlink-would-it-be-possible-to-add-support-for-beamasm-on-another-os--idm30937').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-would-it-be-possible-to-add-support-for-beamasm-on-another-os--idm30937').style.visibility = 'hidden';">
<div class="title-name">Would it be possible to add support for BeamAsm on another OS?</div>
<div class="title-anchors"><span id="ghlink-would-it-be-possible-to-add-support-for-beamasm-on-another-os--idm30937" class="ghlink-after"><a href="#would-it-be-possible-to-add-support-for-beamasm-on-another-os-" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
Adding a new OS that runs x86-64 should not need any large changes if
the OS supports mapping of memory as executable. If the ABI used by the
OS is not supported changes related to calling C-functions also have to
be made.
</p>

<p>
As a reference, it took us about 2-3 weeks to implement support for Windows.
</p>



<a name="FAQ_Would-it-be-possible-to-add-support-in-perf-to-better-crawl-the-Erlang-stack"></a><h4 id="would-it-be-possible-to-add-support-in-perf-to-better-crawl-the-erlang-stack-" class="title-link" onMouseOver="document.getElementById('ghlink-would-it-be-possible-to-add-support-in-perf-to-better-crawl-the-erlang-stack--idm30942').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-would-it-be-possible-to-add-support-in-perf-to-better-crawl-the-erlang-stack--idm30942').style.visibility = 'hidden';">
<div class="title-name">Would it be possible to add support in perf to better crawl the Erlang stack?</div>
<div class="title-anchors"><span id="ghlink-would-it-be-possible-to-add-support-in-perf-to-better-crawl-the-erlang-stack--idm30942" class="ghlink-after"><a href="#would-it-be-possible-to-add-support-in-perf-to-better-crawl-the-erlang-stack-" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h4>



<p>
Yes, though not easily.
</p>

<p>
Using <span class="code">perf --call-graph lbr</span> works for Erlang, but it does not give a
perfect record as the buffer has a limited size.
</p>




</div>
<div class="footer">
<hr>
<p>Copyright Â© 1997-2024 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../../js/';</script><script type="text/javascript" src="../../js/highlight.js"></script>
<script type="text/javascript">
_docsearch_version = "24";
</script> 
<script src="/assets/js/doc-search.bundle.js"></script>
</body>
</html>
