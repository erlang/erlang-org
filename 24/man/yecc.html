<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:erl="http://erlang.org" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="utf-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<meta name="major-vsn" content="24">
<title>Erlang -- yecc</title>
</head>
<body>
<div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script id="js3" type="text/javascript" src="../../../../doc/js/topbar.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function setscrollpos() {
                var objf = document.getElementById('loadscrollpos');
                if (objf) {
                  document.getElementById("leftnav").firstChild.scrollTop = objf.offsetTop - 10;
                }
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //-->
</script><div class="topbar">
<div class="topbar-expand "><button onclick="toggleDisplay();"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" id="Capa_1" viewBox="0 0 54 54" width="24" height="24"><g><path style="fill:#000000;" d="M27,54c-0.552,0-1-0.448-1-1V8c0-0.552,0.448-1,1-1s1,0.448,1,1v45C28,53.552,27.552,54,27,54z"></path><path style="fill:#000000;" d="M11,25c-0.256,0-0.512-0.098-0.707-0.293c-0.391-0.391-0.391-1.023,0-1.414l16-16                                      c0.391-0.391,1.023-0.391,1.414,0s0.391,1.023,0,1.414l-16,16C11.512,24.902,11.256,25,11,25z"></path><path style="fill:#000000;" d="M43,25c-0.256,0-0.512-0.098-0.707-0.293l-16-16c-0.391-0.391-0.391-1.023,0-1.414                                      s1.023-0.391,1.414,0l16,16c0.391,0.391,0.391,1.023,0,1.414C43.512,24.902,43.256,25,43,25z"></path><path style="fill:#000000;" d="M43,2H11c-0.552,0-1-0.448-1-1s0.448-1,1-1h32c0.552,0,1,0.448,1,1S43.552,2,43,2z"></path></g></svg></button></div>
<div class="topbar-title"><h1 id="yecc">yecc</h1></div>
<div class="search-expand ">        <button id="docsearch-mobile">
            <svg fill="#000000" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 50 50" width="24" height="24"><path d="M 21 3 C 11.621094 3 4 10.621094 4 20 C 4 29.378906 11.621094 37 21 37 C 24.710938 37 28.140625 35.804688 30.9375 33.78125 L 44.09375 46.90625 L 46.90625 44.09375 L 33.90625 31.0625 C 36.460938 28.085938 38 24.222656 38 20 C 38 10.621094 30.378906 3 21 3 Z M 21 5 C 29.296875 5 36 11.703125 36 20 C 36 28.296875 29.296875 35 21 35 C 12.703125 35 6 28.296875 6 20 C 6 11.703125 12.703125 5 21 5 Z"/></svg>
        </button>
</div>
</div>
<aside class="hide-mobile" id="leftnav"><nav class="leftnav-tube"><div class="erlang-logo-wrapper"><a href="../index.html"><img alt="Erlang Logo" src="../erlang-logo.png" class="erlang-logo"></a></div>
<p class="section-title">Parse Tools</p>
<p class="section-subtitle">Reference Manual</p>
<p class="section-version">Version 2.3.2</p>
<ul class="panel-sections">
<li><a href="../apps/parsetools/index.html">Reference Manual</a></li>
<li><a href="../apps/parsetools/notes.html">Release Notes</a></li>
<li><a href="../apps/parsetools/parsetools.pdf">PDF</a></li>
<li><a href="../index.html">Top</a></li>
</ul>
<div id="docsearch"></div>
<div style="padding-left: 1rem; padding-top: 0.1rem;"><a href="/doc/search?v=24">Paginated Search</a></div>
<ul class="expand-collapse-items">
<li><a href="javascript:openAllFlips()">Expand All</a></li>
<li><a href="javascript:closeAllFlips()">Contract All</a></li>
</ul>
<h3 id="toc">Table of Contents</h3>
<ul class="flipMenu">
<li id="loadscrollpos" title="yecc " expanded="true">yecc<ul>
<li><a href="yecc.html">
                  Top of manual page
                </a></li>
    <li title="file-1"><a href="yecc.html#file-1">file/1</a></li>
    <li title="file-2"><a href="yecc.html#file-2">file/2</a></li>
    <li title="format_error-1"><a href="yecc.html#format_error-1">format_error/1</a></li>
    </ul>
</li>
<li id="no" title="leex " expanded="false">leex<ul>
<li><a href="leex.html">
                  Top of manual page
                </a></li>
    <li title="file-1"><a href="leex.html#file-1">file/1</a></li>
    <li title="file-2"><a href="leex.html#file-2">file/2</a></li>
    <li title="format_error-1"><a href="leex.html#format_error-1">format_error/1</a></li>
    <li title="Module:string-1"><a href="leex.html#Module:string-1">Module:string/1</a></li>
    <li title="Module:string-2"><a href="leex.html#Module:string-2">Module:string/2</a></li>
    <li title="Module:token-2"><a href="leex.html#Module:token-2">Module:token/2</a></li>
    <li title="Module:token-3"><a href="leex.html#Module:token-3">Module:token/3</a></li>
    <li title="Module:tokens-2"><a href="leex.html#Module:tokens-2">Module:tokens/2</a></li>
    <li title="Module:tokens-3"><a href="leex.html#Module:tokens-3">Module:tokens/3</a></li>
    </ul>
</li>
</ul></nav></aside><div id="content">
<div class="innertube"></div>
<!-- refpage --><div class="innertube"><center><h1>yecc</h1></center></div>
  
  <div class="innertube">
<h3 id="module" class="title-link" onMouseOver="document.getElementById('ghlink-module-idm51').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-module-idm51').style.visibility = 'hidden';">
<div class="title-name">Module</div>
<div class="title-anchors"><span id="ghlink-module-idm51" class="ghlink-after"><a href="#module" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>
<div class="REFBODY module-body">yecc</div>
</div>
  <div class="innertube">
<h3 id="module-summary" class="title-link" onMouseOver="document.getElementById('ghlink-module-summary-idm52').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-module-summary-idm52').style.visibility = 'hidden';">
<div class="title-name">Module Summary</div>
<div class="title-anchors"><span id="ghlink-module-summary-idm52" class="ghlink-after"><a href="#module-summary" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>
<div class="REFBODY module-summary-body">LALR-1 Parser Generator</div>
</div>
  <section class="description"><div class="innertube">
<h3 id="description" class="title-link" onMouseOver="document.getElementById('ghlink-description-idm53').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-description-idm53').style.visibility = 'hidden';">
<div class="title-name">Description</div>
<div class="title-anchors"><span id="ghlink-description-idm53" class="ghlink-after"><a href="#description" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/parsetools/doc/src/yecc.xml#L37" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
<div class="REFBODY description-body"><p>
    <p>An LALR-1 parser generator for Erlang, similar to <span class="code">yacc</span>.
      Takes a BNF grammar definition as input, and produces Erlang code
      for a parser. </p>
    <p>To understand this text, you also have to
      look at the <span class="code">yacc</span> documentation in the UNIX(TM) manual. This
      is most probably necessary in order to understand the idea of a
      parser generator, and the principle and problems of LALR parsing
      with finite look-ahead.</p>
  </p></div>
</div></section>

  <div class="innertube">
<h3 id="data-types" class="title-link" onMouseOver="document.getElementById('ghlink-data-types-idm58').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-data-types-idm58').style.visibility = 'hidden';">
<div class="title-name">Data Types</div>
<div class="title-anchors"><span id="ghlink-data-types-idm58" class="ghlink-after"><a href="#data-types" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3>
    <article class="data-types-body"><h4 id="type-error_info" class="title-link data-type-name" onMouseOver="document.getElementById('ghlink-type-error_info').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-type-error_info').style.visibility = 'hidden';">
<div class="title-anchors"><span id="ghlink-type-error_info" class="ghlink-before"><a href="#type-error_info" title="Link to this place!"><span class="paperclip-before"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/parsetools/doc/src/yecc.xml#L49" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-before"></span></a></span></div>
<div class="title-name">
      <span class="bold_code bc-4"><a name="type-error_info">error_info()</a> = <br>    {<span class="bold_code bc-14"><a href="erl_anno.html#type-location">erl_anno:location()</a></span> | none,<br>     <span class="bold_code bc-14"><a href="erlang.html#type-module">module()</a></span>,<br>     ErrorDescriptor :: <span class="bold_code bc-14"><a href="erlang.html#type-term">term()</a></span>}</span><br>
</div>
</h4>
<div class="data-type-desc"><div class="REFBODY rb-7">
<p>The standard <span class="code">error_info()</span> structure that is returned
        from all I/O modules. <span class="code">ErrorDescriptor</span> is formattable
        by <span class="bold_code bc-17"><a href="#format_error-1"><span class="code">format_error/1</span></a></span>.</p>
      </div></div></article>
  </div>

  <div class="innertube"><h3 id="export" class="title-link" onMouseOver="document.getElementById('ghlink-export-idm68').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-export-idm68').style.visibility = 'hidden';">
<div class="title-name">Exports</div>
<div class="title-anchors"><span id="ghlink-export-idm68" class="ghlink-after"><a href="#export" title="Link to this place!"><span class="paperclip-after"></span></a></span></div>
</h3></div>
<div class="exports-body">
<article class="func"><h4 id="file-1" class="bold_code title-link func-head" onMouseOver="document.getElementById('ghlink-file-1-idp1').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-file-1-idp1').style.visibility = 'hidden';">
<div class="title-anchors"><span id="ghlink-file-1-idp1" class="ghlink-before"><a href="#file-1" title="Link to this place!"><span class="paperclip-before"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/parsetools/doc/src/yecc.xml#L59" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-before"></span></a></span></div>
<span class="title-name">file(FileName) -&gt; yecc_ret()</span>
</h4>
<h4 id="file-2" class="bold_code title-link func-head" onMouseOver="document.getElementById('ghlink-file-2-idp2').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-file-2-idp2').style.visibility = 'hidden';">
<div class="title-anchors"><span id="ghlink-file-2-idp2" class="ghlink-before"><a href="#file-2" title="Link to this place!"><span class="paperclip-before"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/parsetools/doc/src/yecc.xml#L59" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-before"></span></a></span></div>
<span class="title-name">file(Grammarfile, Options) -&gt; yecc_ret()</span>
</h4>
<div class="REFBODY fun-types">
<h3 id="types" class="func-types-title">Types</h3>
<div class="REFTYPES rt-1"><span class="bold_code bc-2">Grammarfile = <span class="bold_code bc-14"><a href="file.html#type-filename">file:filename()</a></span></span></div>
<div class="REFTYPES rt-1"><span class="bold_code bc-2">Options = Option | [Option]</span></div>
<div class="REFTYPES rt-1"><span class="bold_code bc-2">Option = <br>    {error_location, column | line} |<br>    {includefile, Includefile :: <span class="bold_code bc-14"><a href="file.html#type-filename">file:filename()</a></span>} |<br>    {report_errors, <span class="bold_code bc-14"><a href="erlang.html#type-boolean">boolean()</a></span>} |<br>    {report_warnings, <span class="bold_code bc-14"><a href="erlang.html#type-boolean">boolean()</a></span>} |<br>    {report, <span class="bold_code bc-14"><a href="erlang.html#type-boolean">boolean()</a></span>} |<br>    {return_errors, <span class="bold_code bc-14"><a href="erlang.html#type-boolean">boolean()</a></span>} |<br>    {return_warnings, <span class="bold_code bc-14"><a href="erlang.html#type-boolean">boolean()</a></span>} |<br>    {return, <span class="bold_code bc-14"><a href="erlang.html#type-boolean">boolean()</a></span>} |<br>    {parserfile, Parserfile :: <span class="bold_code bc-14"><a href="file.html#type-filename">file:filename()</a></span>} |<br>    {verbose, <span class="bold_code bc-14"><a href="erlang.html#type-boolean">boolean()</a></span>} |<br>    {warnings_as_errors, <span class="bold_code bc-14"><a href="erlang.html#type-boolean">boolean()</a></span>} |<br>    report_errors | report_warnings | report | return_errors |<br>    return_warnings | return | verbose | warnings_as_errors</span></div>
<div class="REFTYPES rt-2">
      <span class="bold_code bc-5">yecc_ret() = ok_ret() | error_ret()</span><br>
</div>
<div class="REFTYPES rt-2">
      <span class="bold_code bc-5">ok_ret() = <br>    {ok, Parserfile :: <span class="bold_code bc-14"><a href="file.html#type-filename">file:filename()</a></span>} |<br>    {ok, Parserfile :: <span class="bold_code bc-14"><a href="file.html#type-filename">file:filename()</a></span>, warnings()}</span><br>
</div>
<div class="REFTYPES rt-2">
      <span class="bold_code bc-5">error_ret() = <br>    error | {error, Errors :: errors(), Warnings :: warnings()}</span><br>
</div>
<div class="REFTYPES rt-2">
      <span class="bold_code bc-5">errors() = [{<span class="bold_code bc-14"><a href="file.html#type-filename">file:filename()</a></span>, [<span class="bold_code bc-17"><a href="#type-error_info">error_info()</a></span>]}]</span><br>
</div>
<div class="REFTYPES rt-2">
      <span class="bold_code bc-5">warnings() = [{<span class="bold_code bc-14"><a href="file.html#type-filename">file:filename()</a></span>, [<span class="bold_code bc-17"><a href="#type-error_info">error_info()</a></span>]}]</span><br>
</div>
</div>
<div class="exports-tube"><div class="REFBODY rb-7">
        <p><span class="code">Grammarfile</span> is the file of declarations and grammar
          rules. Returns <span class="code">ok</span> upon success, or <span class="code">error</span> if
          there are errors. An Erlang file containing the parser is
          created if there are no errors. The options are:
          </p>
        <dl>
          <dt><strong><span class="code">{includefile, Includefile}</span>.</strong></dt>
          <dd>
<p>Indicates a customized prologue file which the user
           may want to use instead of the default file
          <span class="code">lib/parsetools/include/yeccpre.hrl</span> which is
           otherwise included at the beginning of the resulting
           parser file. <strong>N.B.</strong> The <span class="code">Includefile</span> is
           included 'as is' in the parser file, so it must not have a
           module declaration of its own, and it should not be
           compiled. It must, however, contain the necessary export
           declarations. The default is indicated by <span class="code">""</span>.</p>
          </dd>
          <dt><strong><span class="code">{parserfile, Parserfile}</span>.</strong></dt>
          <dd>
<p><span class="code">Parserfile</span> is the name of the file that will
           contain the Erlang parser code that is generated. The
           default (<span class="code">""</span>) is to add the extension <span class="code">.erl</span>
           to <span class="code">Grammarfile</span> stripped of the <span class="code">.yrl</span>
           extension.</p>
          </dd>
          <dt><strong><span class="code">{report_errors, boolean()}</span>.</strong></dt>
          <dd>
<p>Causes errors to be printed as they occur. Default is
          <span class="code">true</span>.</p>
          </dd>
          <dt><strong><span class="code">{report_warnings, boolean()}</span>.</strong></dt>
          <dd>
<p>Causes warnings to be printed as they occur. Default is
          <span class="code">true</span>.</p>
          </dd>
          <dt><strong><span class="code">{report, boolean()}</span>.</strong></dt>
          <dd>
<p>This is a short form for both <span class="code">report_errors</span> and
          <span class="code">report_warnings</span>.</p>
          </dd>
          <dt><strong><span class="code">{return_errors, boolean()}</span>.</strong></dt>
          <dd>
<p>If this flag is set,
	   <span class="code">{error, Errors, Warnings}</span>
           is returned when there are errors. Default is
          <span class="code">false</span>.</p>
          </dd>
          <dt><strong><span class="code">{return_warnings, boolean()}</span>.</strong></dt>
          <dd>
<p>If this flag is set, an extra field containing
          <span class="code">Warnings</span> is added to the tuple returned upon
           success. Default is <span class="code">false</span>.</p>
          </dd>
          <dt><strong><span class="code">{return, boolean()}</span>.</strong></dt>
          <dd>
<p>This is a short form for both <span class="code">return_errors</span> and
          <span class="code">return_warnings</span>.</p>
          </dd>
          <dt><strong><span class="code">{verbose, boolean()}</span>. </strong></dt>
          <dd>
<p>Determines whether the parser generator should give
           full information about resolved and unresolved parse
           action conflicts (<span class="code">true</span>), or only about those
           conflicts that prevent a parser from being generated from
           the input grammar (<span class="code">false</span>, the default).</p>
          </dd>
          <dt><strong><span class="code">{warnings_as_errors, boolean()}</span></strong></dt>
          <dd>
            <p>Causes warnings to be treated as errors.</p>
          </dd>
          <dt><strong><span class="code">{error_location, column | line}</span>.</strong></dt>
          <dd>If the value of this flag is <span class="code">line</span>, the location
            of warnings and errors is a line number. If the value
            is <span class="code">column</span>, the location includes a line number and
            a column number. Default is <span class="code">column</span>.
          </dd>
        </dl>
        <p>Any of the Boolean options can be set to <span class="code">true</span> by 
          stating the name of the option. For example, <span class="code">verbose</span>
          is equivalent to <span class="code">{verbose, true}</span>.
          </p>
        <p>The value of the <span class="code">Parserfile</span> option stripped of the
          <span class="code">.erl</span> extension is used by Yecc as the module name of
          the generated parser file.</p>
        <p>Yecc will add the extension <span class="code">.yrl</span> to the
          <span class="code">Grammarfile</span> name, the extension <span class="code">.hrl</span> to the
          <span class="code">Includefile</span> name, and the extension <span class="code">.erl</span> to
          the <span class="code">Parserfile</span> name, unless the extension is already
          there.</p>
      </div></div></article><article class="func"><h4 id="format_error-1" class="bold_code title-link func-head" onMouseOver="document.getElementById('ghlink-format_error-1-idp3').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-format_error-1-idp3').style.visibility = 'hidden';">
<div class="title-anchors"><span id="ghlink-format_error-1-idp3" class="ghlink-before"><a href="#format_error-1" title="Link to this place!"><span class="paperclip-before"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/parsetools/doc/src/yecc.xml#L152" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-before"></span></a></span></div>
<span class="title-name">format_error(ErrorDescriptor) -&gt; <span class="bold_code bc-14"><a href="io_lib.html#type-chars">io_lib:chars()</a></span></span>
</h4>
<div class="REFBODY fun-types">
<h3 id="types" class="func-types-title">Types</h3>
<div class="REFTYPES rt-1"><span class="bold_code bc-2">ErrorDescriptor = <span class="bold_code bc-14"><a href="erlang.html#type-term">term()</a></span></span></div>
</div>
<div class="exports-tube"><div class="REFBODY rb-7">
        <p>Returns a descriptive string in English of an error reason
          <span class="code">ErrorDescriptor</span> returned by
          <span class="code">yecc:file/1,2</span>. This function is mainly
          used by the compiler invoking Yecc.</p>
      </div></div></article>
</div>

  <section class="innertube"><h3 id="default-yecc-options" class="title-link" onMouseOver="document.getElementById('ghlink-default-yecc-options-idm186').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-default-yecc-options-idm186').style.visibility = 'hidden';">
<div class="title-name">Default Yecc Options</div>
<div class="title-anchors"><span id="ghlink-default-yecc-options-idm186" class="ghlink-after"><a href="#default-yecc-options" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/parsetools/doc/src/yecc.xml#L164" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
<div class="REFBODY rb-3">
    
    <p>The (host operating system) environment variable
      <span class="code">ERL_COMPILER_OPTIONS</span> can be used to give default Yecc
      options. Its value must be a valid Erlang term. If the value is a
      list, it is used as is. If it is not a list, it is put
      into a list.</p>

      <p>The list is appended to any options given to
      <span class="bold_code bc-17"><a href="#file-2">file/2</a></span>.</p>

      <p>The list can be retrieved with
      <span class="bold_code bc-13"><a href="compile.html#env_compiler_options-0">
      compile:env_compiler_options/0</a></span>.</p>
  </div></section>

  <section class="innertube"><h3 id="pre-processing" class="title-link" onMouseOver="document.getElementById('ghlink-pre-processing-idm194').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-pre-processing-idm194').style.visibility = 'hidden';">
<div class="title-name">Pre-Processing</div>
<div class="title-anchors"><span id="ghlink-pre-processing-idm194" class="ghlink-after"><a href="#pre-processing" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/parsetools/doc/src/yecc.xml#L180" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
<div class="REFBODY rb-3">
    
    <p>A <span class="code">scanner</span> to pre-process the text (program, etc.) to be
      parsed is not provided in the <span class="code">yecc</span> module. The scanner
      serves as a kind of lexicon look-up routine. It is possible to
      write a grammar that uses only character tokens as terminal
      symbols, thereby eliminating the need for a scanner, but this
      would make the parser larger and slower.</p>
    <p>The user should implement a scanner that segments the input
      text, and turns it into one or more lists of tokens. Each token
      should be a tuple containing information about syntactic
      category, position in the text (e.g. line number), and the
      actual terminal symbol found in the text: <span class="code">{Category, Position, Symbol}</span>.</p>
    <p>If a terminal symbol is the only member of a category, and the
      symbol name is identical to the category name, the token format
      may be <span class="code">{Symbol, Position}</span>.</p>
    <p>A list of tokens produced by the scanner should end with a
      special <span class="code">end_of_input</span> tuple which the parser is looking
      for. The format of this tuple should be <span class="code">{Endsymbol, EndPosition}</span>, where <span class="code">Endsymbol</span> is an identifier
      that is distinguished from all the terminal and non-terminal
      categories of the syntax rules. The <span class="code">Endsymbol</span> may be
      declared in the grammar file (see below).</p>
    <p>The simplest case is to segment the input string into a list of
      identifiers (atoms) and use those atoms both as categories and
      values of the tokens. For example, the input string <span class="code">aaa bbb 777, X</span> may be scanned (tokenized) as:</p>
    <div class="example example-none"><pre>[{aaa, 1}, {bbb, 1}, {777, 1}, {',' , 1}, {'X', 1},
 {'$end', 1}].    </pre></div>
    <p>This assumes that this is the first line of the input text, and
      that <span class="code">'$end'</span> is the distinguished <span class="code">end_of_input</span>
      symbol.</p>
    <p>The Erlang scanner in the <span class="code">io</span> module can be used as a
      starting point when writing a new scanner. Study
      <span class="code">yeccscan.erl</span> in order to see how a filter can be added on
      top of <span class="code">io:scan_erl_form/3</span> to provide a scanner for
      Yecc that tokenizes grammar files before parsing them
      with the Yecc parser. A more general approach to scanner
      implementation is to use a scanner generator. A scanner
      generator in Erlang called <span class="code">leex</span> is under development.</p>
  </div></section>

  <section class="innertube"><h3 id="grammar-definition-format" class="title-link" onMouseOver="document.getElementById('ghlink-grammar-definition-format-idm219').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-grammar-definition-format-idm219').style.visibility = 'hidden';">
<div class="title-name">Grammar Definition Format</div>
<div class="title-anchors"><span id="ghlink-grammar-definition-format-idm219" class="ghlink-after"><a href="#grammar-definition-format" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/parsetools/doc/src/yecc.xml#L221" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
<div class="REFBODY rb-3">
    
    <p>Erlang style <span class="code">comments</span>, starting with a <span class="code">'%'</span>, are
      allowed in grammar files.</p>
    <p>Each <span class="code">declaration</span> or <span class="code">rule</span> ends with a dot (the
      character <span class="code">'.'</span>).</p>
    <p>The grammar starts with an optional <span class="code">header</span> section. The
      header is put first in the generated file, before the module
      declaration. The purpose of the header is to provide a means to
      make the documentation generated by EDoc look nicer. Each
      header line should be enclosed in double quotes, and newlines
      will be inserted between the lines. For example:</p>
    <div class="example example-none"><pre>Header "%% Copyright (C)"
"%% @private"
"%% @Author John".</pre></div>
    <p>Next comes a declaration of the <span class="code">nonterminal categories</span>
      to be used in the rules. For example:</p>
    <div class="example example-none"><pre>Nonterminals sentence nounphrase verbphrase.    </pre></div>
    <p>A non-terminal category can be used at the left hand side (=
      <span class="code">lhs</span>, or <span class="code">head</span>) of a grammar rule. It can also
      appear at the right hand side of rules.</p>
    <p>Next comes a declaration of the <span class="code">terminal categories</span>,
      which are the categories of tokens produced by the scanner. For
      example:</p>
    <div class="example example-none"><pre>Terminals article adjective noun verb.    </pre></div>
    <p>Terminal categories may only appear in the right hand sides (=
      <span class="code">rhs</span>) of grammar rules.</p>
    <p>Next comes a declaration of the <span class="code">rootsymbol</span>, or start
      category of the grammar. For example:</p>
    <div class="example example-none"><pre>Rootsymbol sentence.    </pre></div>
    <p>This symbol should appear in the lhs of at least one grammar
      rule. This is the most general syntactic category which the
      parser ultimately will parse every input string into.</p>
    <p>After the rootsymbol declaration comes an optional declaration
      of the <span class="code">end_of_input</span> symbol that your scanner is expected
      to use. For example:</p>
    <div class="example example-none"><pre>Endsymbol '$end'.    </pre></div>
    <p>Next comes one or more declarations of <span class="code">operator precedences</span>, if needed. These are used to resolve
      shift/reduce conflicts (see <span class="code">yacc</span> documentation).</p>
    <p>Examples of operator declarations:</p>
    <div class="example example-none"><pre>Right 100 '='.
Nonassoc 200 '==' '=/='.
Left 300 '+'.
Left 400 '*'.
Unary 500 '-'.    </pre></div>
    <p>These declarations mean that <span class="code">'='</span> is defined as a
      <span class="code">right associative binary</span> operator with precedence 100,
      <span class="code">'=='</span> and <span class="code">'=/='</span> are operators with <span class="code">no associativity</span>, <span class="code">'+'</span> and <span class="code">'*'</span> are <span class="code">left associative binary</span> operators, where <span class="code">'*'</span> takes
      precedence over <span class="code">'+'</span> (the normal case), and <span class="code">'-'</span> is
      a <span class="code">unary</span> operator of higher precedence than <span class="code">'*'</span>.
      The fact that '==' has no associativity means that an expression
      like <span class="code">a == b == c</span> is considered a syntax error.</p>
    <p>Certain rules are assigned precedence: each rule gets its
      precedence from the last terminal symbol mentioned in the right
      hand side of the rule. It is also possible to declare precedence
      for non-terminals, "one level up". This is practical when an
      operator is overloaded (see also example 3 below).</p>
    <p>Next come the <span class="code">grammar rules</span>. Each rule has the general
      form</p>
    <div class="example example-none"><pre>Left_hand_side -&gt; Right_hand_side : Associated_code.    </pre></div>
    <p>The left hand side is a non-terminal category. The right hand
      side is a sequence of one or more non-terminal or terminal
      symbols with spaces between. The associated code is a sequence
      of zero or more Erlang expressions (with commas <span class="code">','</span> as
      separators). If the associated code is empty, the separating
      colon <span class="code">':'</span> is also omitted. A final dot marks the end of
      the rule.</p>
    <p>Symbols such as <span class="code">'{'</span>, <span class="code">'.'</span>, etc., have to be
      enclosed in single quotes when used as terminal or non-terminal
      symbols in grammar rules. The use of the symbols
      <span class="code">'$empty'</span>, <span class="code">'$end'</span>, and <span class="code">'$undefined'</span> should
      be avoided.</p>
    <p>The last part of the grammar file is an optional section with
      Erlang code (= function definitions) which is included 'as is'
      in the resulting parser file. This section must start with the
      pseudo declaration, or key words</p>
    <div class="example example-none"><pre>Erlang code.    </pre></div>
    <p>No syntax rule definitions or other declarations may follow
      this section. To avoid conflicts with internal variables, do not
      use variable names beginning with two underscore characters
      ('__') in the Erlang code in this section, or in the code
      associated with the individual syntax rules.</p>
    <p>The optional <span class="code">expect</span> declaration can be placed anywhere
      before the last optional section with Erlang code. It is used
      for suppressing the warning about conflicts that is ordinarily
      given if the grammar is ambiguous. An example:</p>
    <div class="example example-none"><pre>Expect 2.    </pre></div>
    <p>The warning is given if the number of shift/reduce conflicts
      differs from 2, or if there are reduce/reduce conflicts.
      </p>
  </div></section>

  <section class="innertube"><h3 id="examples" class="title-link" onMouseOver="document.getElementById('ghlink-examples-idm289').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-examples-idm289').style.visibility = 'hidden';">
<div class="title-name">Examples</div>
<div class="title-anchors"><span id="ghlink-examples-idm289" class="ghlink-after"><a href="#examples" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/parsetools/doc/src/yecc.xml#L322" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
<div class="REFBODY rb-3">
    
    <p>A grammar to parse list expressions (with empty associated
      code):</p>
    <div class="example example-none"><pre>Nonterminals list elements element.
Terminals atom '(' ')'.
Rootsymbol list.
list -&gt; '(' ')'.
list -&gt; '(' elements ')'.
elements -&gt; element.
elements -&gt; element elements.
element -&gt; atom.
element -&gt; list.    </pre></div>
    <p>This grammar can be used to generate a parser which parses list
      expressions, such as <span class="code">(), (a), (peter charles), (a (b c) d (())), ...</span> provided that your scanner tokenizes, for
      example, the input <span class="code">(peter charles)</span> as follows:</p>
    <div class="example example-none"><pre>[{'(', 1} , {atom, 1, peter}, {atom, 1, charles}, {')', 1}, 
 {'$end', 1}]    </pre></div>
    <p>When a grammar rule is used by the parser to parse (part of)
      the input string as a grammatical phrase, the associated code is
      evaluated, and the value of the last expression becomes the
      value of the parsed phrase. This value may be used by the parser
      later to build structures that are values of higher phrases of
      which the current phrase is a part. The values initially
      associated with terminal category phrases, i.e. input tokens,
      are the token tuples themselves.</p>
    <p>Below is an example of the grammar above with structure
      building code added:</p>
    <div class="example example-none"><pre>list -&gt; '(' ')' : nil.
list -&gt; '(' elements ')' : '$2'.
elements -&gt; element : {cons, '$1', nil}.
elements -&gt; element elements : {cons, '$1', '$2'}.
element -&gt; atom : '$1'.
element -&gt; list : '$1'.    </pre></div>
    <p>With this code added to the grammar rules, the parser produces
      the following value (structure) when parsing the input string
      <span class="code">(a b c).</span>. This still assumes that this was the first
      input line that the scanner tokenized:</p>
    <div class="example example-none"><pre>{cons, {atom, 1, a,} {cons, {atom, 1, b},
                            {cons, {atom, 1, c}, nil}}}    </pre></div>
    <p>The associated code contains <span class="code">pseudo variables</span> <span class="code">'$1'</span>, <span class="code">'$2'</span>, <span class="code">'$3'</span>, etc. which refer to (are
      bound to) the values associated previously by the parser with
      the symbols of the right hand side of the rule. When these
      symbols are terminal categories, the values are token tuples of
      the input string (see above).</p>
    <p>The associated code may not only be used to build structures
      associated with phrases, but may also be used for syntactic and
      semantic tests, printout actions (for example for tracing), etc.
      during the parsing process. Since tokens contain positional
      (line number) information, it is possible to produce error
      messages which contain line numbers. If there is no associated
      code after the right hand side of the rule, the value
      <span class="code">'$undefined'</span> is associated with the phrase.</p>
    <p>The right hand side of a grammar rule may be empty. This is
      indicated by using the special symbol <span class="code">'$empty'</span> as rhs.
      Then the list grammar above may be simplified to:</p>
    <div class="example example-none"><pre>list -&gt; '(' elements ')' : '$2'.
elements -&gt; element elements : {cons, '$1', '$2'}.
elements -&gt; '$empty' : nil.
element -&gt; atom : '$1'.
element -&gt; list : '$1'.    </pre></div>
  </div></section>

  <section class="innertube"><h3 id="generating-a-parser" class="title-link" onMouseOver="document.getElementById('ghlink-generating-a-parser-idm313').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-generating-a-parser-idm313').style.visibility = 'hidden';">
<div class="title-name">Generating a Parser</div>
<div class="title-anchors"><span id="ghlink-generating-a-parser-idm313" class="ghlink-after"><a href="#generating-a-parser" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/parsetools/doc/src/yecc.xml#L390" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
<div class="REFBODY rb-3">
    
    <p>To call the parser generator, use the following command:</p>
    <div class="example example-none"><pre>yecc:file(Grammarfile).    </pre></div>
    <p>An error message from Yecc will be shown if the grammar
      is not of the LALR type (for example too ambiguous).
      Shift/reduce conflicts are resolved in favor of shifting if
      there are no operator precedence declarations. Refer to the
      <span class="code">yacc</span> documentation on the use of operator precedence.</p>
    <p>The output file contains Erlang source code for a parser module
      with module name equal to the <span class="code">Parserfile</span> parameter. After
      compilation, the parser can be called as follows (the module
      name is assumed to be <span class="code">myparser</span>):</p>
    <div class="example example-none"><pre>myparser:parse(myscanner:scan(Inport))    </pre></div>
    <p>The call format may be different if a customized prologue file
      has been included when generating the parser instead of the
      default file <span class="code">lib/parsetools/include/yeccpre.hrl</span>.</p>
    <p>With the standard prologue, this call will return either
      <span class="code">{ok, Result}</span>, where <span class="code">Result</span> is a structure that the
      Erlang code of the grammar file has built, or <span class="code">{error, {Position, Module, Message}}</span> if there was a syntax error
      in the input.</p>
    <p><span class="code">Message</span> is something which may be converted into a
      string by calling <span class="code">Module:format_error(Message)</span>
      and printed with <span class="code">io:format/3</span>.</p>
    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>By default, the parser that was generated will not print out
        error messages to the screen. The user will have to do this
        either by printing the returned error messages, or by
        inserting tests and print instructions in the Erlang code
        associated with the syntax rules of the grammar file.</p>
    </p></div>
</div>
    <p>It is also possible to make the parser ask for more input
      tokens when needed if the following call format is used:</p>
    <div class="example example-none"><pre>myparser:parse_and_scan({Function, Args})
myparser:parse_and_scan({Mod, Tokenizer, Args})    </pre></div>
    <p>The tokenizer <span class="code">Function</span> is either a fun or a tuple
      <span class="code">{Mod, Tokenizer}</span>. The call <span class="code">apply(Function, Args)</span>
      or <span class="code">apply({Mod, Tokenizer}, Args)</span> is executed whenever a
      new token is needed. This, for example, makes it possible to
      parse from a file, token by token.</p>
    <p>The tokenizer used above has to be implemented so as to return
      one of the following:</p>
    <div class="example example-none"><pre>{ok, Tokens, EndPosition}
{eof, EndPosition}
{error, Error_description, EndPosition}    </pre></div>
    <p>This conforms to the format used by the scanner in the Erlang
      <span class="code">io</span> library module.</p>
    <p>If <span class="code">{eof, EndPosition}</span> is returned immediately, the call to
      <span class="code">parse_and_scan/1</span> returns <span class="code">{ok, eof}</span>. If <span class="code">{eof, EndPosition}</span> is returned before the parser expects end of input,
      <span class="code">parse_and_scan/1</span> will, of course, return an error message
      (see above). Otherwise <span class="code">{ok, Result}</span> is returned.</p>
  </div></section>

  <section class="innertube"><h3 id="more-examples" class="title-link" onMouseOver="document.getElementById('ghlink-more-examples-idm353').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-more-examples-idm353').style.visibility = 'hidden';">
<div class="title-name">More Examples</div>
<div class="title-anchors"><span id="ghlink-more-examples-idm353" class="ghlink-after"><a href="#more-examples" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/parsetools/doc/src/yecc.xml#L447" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
<div class="REFBODY rb-3">
    
    <p>1. A grammar for parsing infix arithmetic expressions into
      prefix notation, without operator precedence:</p>
    <div class="example example-none"><pre>Nonterminals E T F.
Terminals '+' '*' '(' ')' number.
Rootsymbol E.
E -&gt; E '+' T: {'$2', '$1', '$3'}.
E -&gt; T : '$1'.
T -&gt; T '*' F: {'$2', '$1', '$3'}.
T -&gt; F : '$1'.
F -&gt; '(' E ')' : '$2'.
F -&gt; number : '$1'.    </pre></div>
    <p>2. The same with operator precedence becomes simpler:</p>
    <div class="example example-none"><pre>Nonterminals E.
Terminals '+' '*' '(' ')' number.
Rootsymbol E.
Left 100 '+'.
Left 200 '*'.
E -&gt; E '+' E : {'$2', '$1', '$3'}.
E -&gt; E '*' E : {'$2', '$1', '$3'}.
E -&gt; '(' E ')' : '$2'.
E -&gt; number : '$1'.    </pre></div>
    <p>3. An overloaded minus operator:</p>
    <div class="example example-none"><pre>Nonterminals E uminus.
Terminals '*' '-' number.
Rootsymbol E.

Left 100 '-'.
Left 200 '*'.
Unary 300 uminus.

E -&gt; E '-' E.
E -&gt; E '*' E.
E -&gt; uminus.
E -&gt; number.

uminus -&gt; '-' E.    </pre></div>
    <p>4. The Yecc grammar that is used for parsing grammar
      files, including itself:</p>
    <div class="example example-none"><pre>Nonterminals
grammar declaration rule head symbol symbols attached_code
token tokens.
Terminals
atom float integer reserved_symbol reserved_word string char var
'-&gt;' ':' dot.
Rootsymbol grammar.
Endsymbol '$end'.
grammar -&gt; declaration : '$1'.
grammar -&gt; rule : '$1'.
declaration -&gt; symbol symbols dot: {'$1', '$2'}.
rule -&gt; head '-&gt;' symbols attached_code dot: {rule, ['$1' | '$3'], 
        '$4'}.
head -&gt; symbol : '$1'.
symbols -&gt; symbol : ['$1'].
symbols -&gt; symbol symbols : ['$1' | '$2'].
attached_code -&gt; ':' tokens : {erlang_code, '$2'}.
attached_code -&gt; '$empty' : {erlang_code, 
                 [{atom, 0, '$undefined'}]}.
tokens -&gt; token : ['$1'].
tokens -&gt; token tokens : ['$1' | '$2'].
symbol -&gt; var : value_of('$1').
symbol -&gt; atom : value_of('$1').
symbol -&gt; integer : value_of('$1').
symbol -&gt; reserved_word : value_of('$1').
token -&gt; var : '$1'.
token -&gt; atom : '$1'.
token -&gt; float : '$1'.
token -&gt; integer : '$1'.
token -&gt; string : '$1'.
token -&gt; char : '$1'.
token -&gt; reserved_symbol : {value_of('$1'), line_of('$1')}.
token -&gt; reserved_word : {value_of('$1'), line_of('$1')}.
token -&gt; '-&gt;' : {'-&gt;', line_of('$1')}.
token -&gt; ':' : {':', line_of('$1')}.
Erlang code.
value_of(Token) -&gt;
    element(3, Token).
line_of(Token) -&gt;
    element(2, Token).    </pre></div>
    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>The symbols <span class="code">'-&gt;'</span>, and <span class="code">':'</span> have to be treated in
        a special way, as they are meta symbols of the grammar
        notation, as well as terminal symbols of the Yecc
        grammar.</p>
    </p></div>
</div>
    <p>5. The file <span class="code">erl_parse.yrl</span> in the <span class="code">lib/stdlib/src</span>
      directory contains the grammar for Erlang.</p>
    <div class="note">
<div class="label">Note</div>
<div class="content"><p>
      <p>Syntactic tests are used in the code associated with some
        rules, and an error is thrown (and caught by the generated
        parser to produce an error message) when a test fails. The
        same effect can be achieved with a call to
        <span class="code">return_error(ErrorPosition, Message_string)</span>, which is
        defined in the <span class="code">yeccpre.hrl</span> default header file.</p>
    </p></div>
</div>
  </div></section>

  <section class="innertube"><h3 id="files" class="title-link" onMouseOver="document.getElementById('ghlink-files-idm374').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-files-idm374').style.visibility = 'hidden';">
<div class="title-name">Files</div>
<div class="title-anchors"><span id="ghlink-files-idm374" class="ghlink-after"><a href="#files" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/parsetools/doc/src/yecc.xml#L549" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
<div class="REFBODY rb-3">
    
    <div class="example example-none"><pre>lib/parsetools/include/yeccpre.hrl    </pre></div>
  </div></section>

  <section class="innertube"><h3 id="see-also" class="title-link" onMouseOver="document.getElementById('ghlink-see-also-idm377').style.visibility = 'visible';" onMouseOut="document.getElementById('ghlink-see-also-idm377').style.visibility = 'hidden';">
<div class="title-name">See Also</div>
<div class="title-anchors"><span id="ghlink-see-also-idm377" class="ghlink-after"><a href="#see-also" title="Link to this place!"><span class="paperclip-after"></span></a><a href="https://github.com/erlang/otp/edit/maint/lib/parsetools/doc/src/yecc.xml#L555" title="Found an issue with the documentation? Fix it by clicking here!"><span class="pencil-after"></span></a></span></div>
</h3>
<div class="REFBODY rb-3">
    
    <p>Aho &amp; Johnson: 'LR Parsing', ACM Computing Surveys, vol. 6:2, 1974.</p>
  </div></section>
<div class="footer">
<hr>
<p>Copyright © 1997-2024 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div>
<script type="text/javascript">window.__otpTopDocDir = '../js/';</script><script type="text/javascript" src="../js/highlight.js"></script>
<script type="text/javascript">
_docsearch_version = "24";
</script> 
<script src="/assets/js/doc-search.bundle.js"></script>
</body>
</html>
